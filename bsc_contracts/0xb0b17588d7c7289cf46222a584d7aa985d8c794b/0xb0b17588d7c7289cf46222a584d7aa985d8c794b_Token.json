{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/briandonatiello/Documents/GemBooster/contract/contracts/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nimport \\\"./interfaces/DexRouter.sol\\\";\\nimport \\\"./libraries/ABDKMathQuad.sol\\\";\\n\\ncontract Token is IERC20 {\\n    using SafeMath for uint256;\\n\\n    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)\\n    address private constant ROUTER =\\n        0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)\\n    address private constant BNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n\\n    uint256 private constant FEE = 2;\\n    uint256 public TRANSACTION_LIMIT = 1000000000000000000;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n\\n    mapping(address => bool) private excludedFromTax;\\n    mapping(address => bool) private lpPairs;\\n    address private _owner;\\n\\n    DexRouter router;\\n\\n    uint256 public target_buy;\\n    uint256 public target_sell;\\n    bool public can_buy;\\n    bool public can_sell;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor(uint256 _supply) {\\n        _name = \\\"GemBooster\\\";\\n        _symbol = \\\"GBST\\\";\\n\\n        _transferOwnership(msg.sender);\\n\\n        _totalSupply += _supply.mul((10**decimals()));\\n        _balances[_owner] += _supply.mul((10**decimals()));\\n\\n        excludedFromTax[_owner] = true;\\n        excludedFromTax[ROUTER] = true;\\n        excludedFromTax[address(this)] = true;\\n\\n        router = DexRouter(ROUTER);\\n        _approve(address(this), ROUTER, totalSupply());\\n\\n        target_buy = 0;\\n        target_sell = 0;\\n        can_buy = false;\\n        can_sell = false;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(\\n            _owner == msg.sender || msg.sender == address(this),\\n            \\\"Ownable: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n    function manageTrading(uint256 _type, bool _status) external onlyOwner {\\n        if (_type == 0) {\\n            can_buy = _status;\\n        } else {\\n            can_sell = _status;\\n        }\\n    }\\n\\n    function setTargets() public onlyOwner {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = BNB;\\n        uint256 price = router.getAmountsOut(1000000000000000000, path)[1];\\n        target_buy = price.add(price);\\n        target_sell = price;\\n    }\\n\\n    function setLPPair(address _pair) external onlyOwner {\\n        lpPairs[_pair] = true;\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address the_owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[the_owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[msg.sender][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"ERC20: decreased allowance below zero\\\"\\n        );\\n        unchecked {\\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address the_owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(\\n            the_owner != address(0),\\n            \\\"ERC20: approve from the zero address\\\"\\n        );\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[the_owner][spender] = amount;\\n        emit Approval(the_owner, spender, amount);\\n    }\\n\\n    function adjustTargets() private {\\n        target_sell = target_sell.add(((target_buy - target_sell) / 2));\\n        target_buy = target_sell.add(target_sell);\\n    }\\n\\n    function processTransfers(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) private {\\n        if (\\n            excludedFromTax[msg.sender] ||\\n            excludedFromTax[_sender] ||\\n            (!lpPairs[_recipient] && !lpPairs[_sender])\\n        ) {\\n            _transfer(_sender, _recipient, _amount);\\n        } else {\\n            address[] memory path = new address[](2);\\n            path[0] = address(this);\\n            path[1] = BNB;\\n            uint256 tokenPrice = router.getAmountsOut(1 * 10**18, path)[1];\\n\\n            if (tokenPrice > target_buy && can_buy) {\\n                can_buy = false;\\n                can_sell = true;\\n                adjustTargets();\\n            } else if (tokenPrice < target_sell && can_sell) {\\n                can_sell = false;\\n                can_buy = true;\\n                adjustTargets();\\n                TRANSACTION_LIMIT = TRANSACTION_LIMIT + 500000000000000000;\\n            }\\n\\n            uint256 investment = (tokenPrice * _amount).div(10**18);\\n            require(investment <= TRANSACTION_LIMIT);\\n\\n            // Check Sell\\n            if (lpPairs[_recipient]) {\\n                require(can_sell, \\\"cannot sell\\\");\\n            }\\n            // Check Buy\\n            else if (lpPairs[_sender]) {\\n                require(can_buy, \\\"cannot buy\\\");\\n            }\\n\\n            uint256 taxFee = mulDiv(_amount, FEE, 100);\\n            _transfer(_sender, _recipient, _amount.sub(taxFee));\\n            _transfer(_sender, address(this), taxFee);\\n        }\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(\\n            senderBalance >= amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function accumulateFees() public onlyOwner {\\n        uint256 tokenBalance = balanceOf(address(this));\\n        uint256 fee = mulDiv(tokenBalance, FEE, 100);\\n        swapTokens(fee, _owner);\\n    }\\n\\n    function transfer(address _recipient, uint256 _amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        processTransfers(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address the_owner,\\n        address _recipient,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        processTransfers(the_owner, _recipient, _amount);\\n\\n        uint256 currentAllowance = allowance(the_owner, msg.sender);\\n        require(\\n            currentAllowance >= _amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        unchecked {\\n            _approve(the_owner, msg.sender, currentAllowance.sub(_amount));\\n        }\\n\\n        return true;\\n    }\\n\\n    function swapTokens(uint256 _amount, address _to) private {\\n        require(_amount > 0, \\\"amount less than 0\\\");\\n        require(_to != address(0), \\\"address equal to 0\\\");\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = BNB;\\n        uint256 amountWethMin = router.getAmountsOut(_amount, path)[1];\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            _amount,\\n            amountWethMin,\\n            path,\\n            _to,\\n            block.timestamp\\n        );\\n    }\\n\\n    function excludeFromFee(address _user, bool _exclude) external onlyOwner {\\n        require(_user != address(0));\\n        excludedFromTax[_user] = _exclude;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.div(\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.fromUInt(x),\\n                        ABDKMathQuad.fromUInt(y)\\n                    ),\\n                    ABDKMathQuad.fromUInt(z)\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/Users/briandonatiello/Documents/GemBooster/contract/contracts/libraries/ABDKMathQuad.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n    /*\\n     * 0.\\n     */\\n    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n    /*\\n     * -0.\\n     */\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n    /*\\n     * +Infinity.\\n     */\\n    bytes16 private constant POSITIVE_INFINITY =\\n        0x7FFF0000000000000000000000000000;\\n\\n    /*\\n     * -Infinity.\\n     */\\n    bytes16 private constant NEGATIVE_INFINITY =\\n        0xFFFF0000000000000000000000000000;\\n\\n    /*\\n     * Canonical NaN value.\\n     */\\n    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n    /**\\n     * Convert signed 256-bit integer number into quadruple precision number.\\n     *\\n     * @param x signed 256-bit integer number\\n     * @return quadruple precision number\\n     */\\n    function fromInt(int256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint256(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result =\\n                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                    ((16383 + msb) << 112);\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 256-bit integer number\\n     * rounding towards zero.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 256-bit integer number\\n     */\\n    function toInt(bytes16 x) internal pure returns (int256) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            require(exponent <= 16638); // Overflow\\n            if (exponent < 16383) return 0; // Underflow\\n\\n            uint256 result = (uint256(uint128(x)) &\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                0x10000000000000000000000000000;\\n\\n            if (exponent < 16495) result >>= 16495 - exponent;\\n            else if (exponent > 16495) result <<= exponent - 16495;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(\\n                    result <=\\n                        0x8000000000000000000000000000000000000000000000000000000000000000\\n                );\\n                return -int256(result); // We rely on overflow behavior here\\n            } else {\\n                require(\\n                    result <=\\n                        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                );\\n                return int256(result);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert unsigned 256-bit integer number into quadruple precision number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return quadruple precision number\\n     */\\n    function fromUInt(uint256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                uint256 result = x;\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result =\\n                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                    ((16383 + msb) << 112);\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into unsigned 256-bit integer number\\n     * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n     * without error, because they are rounded to zero.\\n     *\\n     * @param x quadruple precision number\\n     * @return unsigned 256-bit integer number\\n     */\\n    function toUInt(bytes16 x) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            if (exponent < 16383) return 0; // Underflow\\n\\n            require(uint128(x) < 0x80000000000000000000000000000000); // Negative\\n\\n            require(exponent <= 16638); // Overflow\\n            uint256 result = (uint256(uint128(x)) &\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                0x10000000000000000000000000000;\\n\\n            if (exponent < 16495) result >>= 16495 - exponent;\\n            else if (exponent > 16495) result <<= exponent - 16495;\\n\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 128.128 bit fixed point number into quadruple precision\\n     * number.\\n     *\\n     * @param x signed 128.128 bit fixed point number\\n     * @return quadruple precision number\\n     */\\n    function from128x128(int256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint256(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result =\\n                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                    ((16255 + msb) << 112);\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 128.128 bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 128.128 bit fixed point number\\n     */\\n    function to128x128(bytes16 x) internal pure returns (int256) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            require(exponent <= 16510); // Overflow\\n            if (exponent < 16255) return 0; // Underflow\\n\\n            uint256 result = (uint256(uint128(x)) &\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                0x10000000000000000000000000000;\\n\\n            if (exponent < 16367) result >>= 16367 - exponent;\\n            else if (exponent > 16367) result <<= exponent - 16367;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(\\n                    result <=\\n                        0x8000000000000000000000000000000000000000000000000000000000000000\\n                );\\n                return -int256(result); // We rely on overflow behavior here\\n            } else {\\n                require(\\n                    result <=\\n                        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                );\\n                return int256(result);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 64.64 bit fixed point number into quadruple precision\\n     * number.\\n     *\\n     * @param x signed 64.64 bit fixed point number\\n     * @return quadruple precision number\\n     */\\n    function from64x64(int128 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint128(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result =\\n                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                    ((16319 + msb) << 112);\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 64.64 bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 64.64 bit fixed point number\\n     */\\n    function to64x64(bytes16 x) internal pure returns (int128) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            require(exponent <= 16446); // Overflow\\n            if (exponent < 16319) return 0; // Underflow\\n\\n            uint256 result = (uint256(uint128(x)) &\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                0x10000000000000000000000000000;\\n\\n            if (exponent < 16431) result >>= 16431 - exponent;\\n            else if (exponent > 16431) result <<= exponent - 16431;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x80000000000000000000000000000000);\\n                return -int128(int256(result)); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int128(int256(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert octuple precision number into quadruple precision number.\\n     *\\n     * @param x octuple precision number\\n     * @return quadruple precision number\\n     */\\n    function fromOctuple(bytes32 x) internal pure returns (bytes16) {\\n        unchecked {\\n            bool negative = x &\\n                0x8000000000000000000000000000000000000000000000000000000000000000 >\\n                0;\\n\\n            uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\\n            uint256 significand = uint256(x) &\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFFF) {\\n                if (significand > 0) return NaN;\\n                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            }\\n\\n            if (exponent > 278526)\\n                return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else if (exponent < 245649)\\n                return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n            else if (exponent < 245761) {\\n                significand =\\n                    (significand |\\n                        0x100000000000000000000000000000000000000000000000000000000000) >>\\n                    (245885 - exponent);\\n                exponent = 0;\\n            } else {\\n                significand >>= 124;\\n                exponent -= 245760;\\n            }\\n\\n            uint128 result = uint128(significand | (exponent << 112));\\n            if (negative) result |= 0x80000000000000000000000000000000;\\n\\n            return bytes16(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into octuple precision number.\\n     *\\n     * @param x quadruple precision number\\n     * @return octuple precision number\\n     */\\n    function toOctuple(bytes16 x) internal pure returns (bytes32) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFF)\\n                exponent = 0x7FFFF; // Infinity or NaN\\n            else if (exponent == 0) {\\n                if (result > 0) {\\n                    uint256 msb = mostSignificantBit(result);\\n                    result =\\n                        (result << (236 - msb)) &\\n                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    exponent = 245649 + msb;\\n                }\\n            } else {\\n                result <<= 124;\\n                exponent += 245760;\\n            }\\n\\n            result |= exponent << 236;\\n            if (uint128(x) >= 0x80000000000000000000000000000000)\\n                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n            return bytes32(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert double precision number into quadruple precision number.\\n     *\\n     * @param x double precision number\\n     * @return quadruple precision number\\n     */\\n    function fromDouble(bytes8 x) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 exponent = (uint64(x) >> 52) & 0x7FF;\\n\\n            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FF)\\n                exponent = 0x7FFF; // Infinity or NaN\\n            else if (exponent == 0) {\\n                if (result > 0) {\\n                    uint256 msb = mostSignificantBit(result);\\n                    result =\\n                        (result << (112 - msb)) &\\n                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    exponent = 15309 + msb;\\n                }\\n            } else {\\n                result <<= 60;\\n                exponent += 15360;\\n            }\\n\\n            result |= exponent << 112;\\n            if (x & 0x8000000000000000 > 0)\\n                result |= 0x80000000000000000000000000000000;\\n\\n            return bytes16(uint128(result));\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into double precision number.\\n     *\\n     * @param x quadruple precision number\\n     * @return double precision number\\n     */\\n    function toDouble(bytes16 x) internal pure returns (bytes8) {\\n        unchecked {\\n            bool negative = uint128(x) >= 0x80000000000000000000000000000000;\\n\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFF) {\\n                if (significand > 0) return 0x7FF8000000000000;\\n                // NaN\\n                else\\n                    return\\n                        negative\\n                            ? bytes8(0xFFF0000000000000) // -Infinity\\n                            : bytes8(0x7FF0000000000000); // Infinity\\n            }\\n\\n            if (exponent > 17406)\\n                return\\n                    negative\\n                        ? bytes8(0xFFF0000000000000) // -Infinity\\n                        : bytes8(0x7FF0000000000000);\\n            // Infinity\\n            else if (exponent < 15309)\\n                return\\n                    negative\\n                        ? bytes8(0x8000000000000000) // -0\\n                        : bytes8(0x0000000000000000);\\n            // 0\\n            else if (exponent < 15361) {\\n                significand =\\n                    (significand | 0x10000000000000000000000000000) >>\\n                    (15421 - exponent);\\n                exponent = 0;\\n            } else {\\n                significand >>= 60;\\n                exponent -= 15360;\\n            }\\n\\n            uint64 result = uint64(significand | (exponent << 52));\\n            if (negative) result |= 0x8000000000000000;\\n\\n            return bytes8(result);\\n        }\\n    }\\n\\n    /**\\n     * Test whether given quadruple precision number is NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @return true if x is NaN, false otherwise\\n     */\\n    function isNaN(bytes16 x) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n                0x7FFF0000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Test whether given quadruple precision number is positive or negative\\n     * infinity.\\n     *\\n     * @param x quadruple precision number\\n     * @return true if x is positive or negative infinity, false otherwise\\n     */\\n    function isInfinity(bytes16 x) internal pure returns (bool) {\\n        unchecked {\\n            return\\n                uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n                0x7FFF0000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @return sign of x\\n     */\\n    function sign(bytes16 x) internal pure returns (int8) {\\n        unchecked {\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            if (absoluteX == 0) return 0;\\n            else if (uint128(x) >= 0x80000000000000000000000000000000)\\n                return -1;\\n            else return 1;\\n        }\\n    }\\n\\n    /**\\n     * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n     * arguments are infinities of the same sign.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return sign (x - y)\\n     */\\n    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\\n        unchecked {\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            // Not infinities of the same sign\\n            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n            if (x == y) return 0;\\n            else {\\n                bool negativeX = uint128(x) >=\\n                    0x80000000000000000000000000000000;\\n                bool negativeY = uint128(y) >=\\n                    0x80000000000000000000000000000000;\\n\\n                if (negativeX) {\\n                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\\n                    else return -1;\\n                } else {\\n                    if (negativeY) return 1;\\n                    else return absoluteX > absoluteY ? int8(1) : -1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n     * anything.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return true if x equals to y, false otherwise\\n     */\\n    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\\n        unchecked {\\n            if (x == y) {\\n                return\\n                    uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n                    0x7FFF0000000000000000000000000000;\\n            } else return false;\\n        }\\n    }\\n\\n    /**\\n     * Calculate x + y.  Special values behave in the following way:\\n     *\\n     * NaN + x = NaN for any x.\\n     * Infinity + x = Infinity for any finite x.\\n     * -Infinity + x = -Infinity for any finite x.\\n     * Infinity + Infinity = Infinity.\\n     * -Infinity + -Infinity = -Infinity.\\n     * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) {\\n                    if (x == y) return x;\\n                    else return NaN;\\n                } else return x;\\n            } else if (yExponent == 0x7FFF) return y;\\n            else {\\n                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\\n                uint256 xSignifier = uint128(x) &\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\\n                uint256 ySignifier = uint128(y) &\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                if (xSignifier == 0)\\n                    return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n                else if (ySignifier == 0)\\n                    return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n                else {\\n                    int256 delta = int256(xExponent) - int256(yExponent);\\n\\n                    if (xSign == ySign) {\\n                        if (delta > 112) return x;\\n                        else if (delta > 0) ySignifier >>= uint256(delta);\\n                        else if (delta < -112) return y;\\n                        else if (delta < 0) {\\n                            xSignifier >>= uint256(-delta);\\n                            xExponent = yExponent;\\n                        }\\n\\n                        xSignifier += ySignifier;\\n\\n                        if (xSignifier >= 0x20000000000000000000000000000) {\\n                            xSignifier >>= 1;\\n                            xExponent += 1;\\n                        }\\n\\n                        if (xExponent == 0x7FFF)\\n                            return\\n                                xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n                        else {\\n                            if (xSignifier < 0x10000000000000000000000000000)\\n                                xExponent = 0;\\n                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                            return\\n                                bytes16(\\n                                    uint128(\\n                                        (\\n                                            xSign\\n                                                ? 0x80000000000000000000000000000000\\n                                                : 0\\n                                        ) |\\n                                            (xExponent << 112) |\\n                                            xSignifier\\n                                    )\\n                                );\\n                        }\\n                    } else {\\n                        if (delta > 0) {\\n                            xSignifier <<= 1;\\n                            xExponent -= 1;\\n                        } else if (delta < 0) {\\n                            ySignifier <<= 1;\\n                            xExponent = yExponent - 1;\\n                        }\\n\\n                        if (delta > 112) ySignifier = 1;\\n                        else if (delta > 1)\\n                            ySignifier =\\n                                ((ySignifier - 1) >> uint256(delta - 1)) +\\n                                1;\\n                        else if (delta < -112) xSignifier = 1;\\n                        else if (delta < -1)\\n                            xSignifier =\\n                                ((xSignifier - 1) >> uint256(-delta - 1)) +\\n                                1;\\n\\n                        if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n                        else {\\n                            xSignifier = ySignifier - xSignifier;\\n                            xSign = ySign;\\n                        }\\n\\n                        if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n                        uint256 msb = mostSignificantBit(xSignifier);\\n\\n                        if (msb == 113) {\\n                            xSignifier =\\n                                (xSignifier >> 1) &\\n                                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                            xExponent += 1;\\n                        } else if (msb < 112) {\\n                            uint256 shift = 112 - msb;\\n                            if (xExponent > shift) {\\n                                xSignifier =\\n                                    (xSignifier << shift) &\\n                                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                                xExponent -= shift;\\n                            } else {\\n                                xSignifier <<= xExponent - 1;\\n                                xExponent = 0;\\n                            }\\n                        } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                        if (xExponent == 0x7FFF)\\n                            return\\n                                xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n                        else\\n                            return\\n                                bytes16(\\n                                    uint128(\\n                                        (\\n                                            xSign\\n                                                ? 0x80000000000000000000000000000000\\n                                                : 0\\n                                        ) |\\n                                            (xExponent << 112) |\\n                                            xSignifier\\n                                    )\\n                                );\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x - y.  Special values behave in the following way:\\n     *\\n     * NaN - x = NaN for any x.\\n     * Infinity - x = Infinity for any finite x.\\n     * -Infinity - x = -Infinity for any finite x.\\n     * Infinity - -Infinity = Infinity.\\n     * -Infinity - Infinity = -Infinity.\\n     * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            return add(x, y ^ 0x80000000000000000000000000000000);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y.  Special values behave in the following way:\\n     *\\n     * NaN * x = NaN for any x.\\n     * Infinity * x = Infinity for any finite positive x.\\n     * Infinity * x = -Infinity for any finite negative x.\\n     * -Infinity * x = -Infinity for any finite positive x.\\n     * -Infinity * x = Infinity for any finite negative x.\\n     * Infinity * 0 = NaN.\\n     * -Infinity * 0 = NaN.\\n     * Infinity * Infinity = Infinity.\\n     * Infinity * -Infinity = -Infinity.\\n     * -Infinity * Infinity = -Infinity.\\n     * -Infinity * -Infinity = Infinity.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) {\\n                    if (x == y)\\n                        return x ^ (y & 0x80000000000000000000000000000000);\\n                    else if (x ^ y == 0x80000000000000000000000000000000)\\n                        return x | y;\\n                    else return NaN;\\n                } else {\\n                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                    else return x ^ (y & 0x80000000000000000000000000000000);\\n                }\\n            } else if (yExponent == 0x7FFF) {\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                else return y ^ (x & 0x80000000000000000000000000000000);\\n            } else {\\n                uint256 xSignifier = uint128(x) &\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                uint256 ySignifier = uint128(y) &\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                xSignifier *= ySignifier;\\n                if (xSignifier == 0)\\n                    return\\n                        (x ^ y) & 0x80000000000000000000000000000000 > 0\\n                            ? NEGATIVE_ZERO\\n                            : POSITIVE_ZERO;\\n\\n                xExponent += yExponent;\\n\\n                uint256 msb = xSignifier >=\\n                    0x200000000000000000000000000000000000000000000000000000000\\n                    ? 225\\n                    : xSignifier >=\\n                        0x100000000000000000000000000000000000000000000000000000000\\n                    ? 224\\n                    : mostSignificantBit(xSignifier);\\n\\n                if (xExponent + msb < 16496) {\\n                    // Underflow\\n                    xExponent = 0;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb < 16608) {\\n                    // Subnormal\\n                    if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\\n                    else if (xExponent > 16496)\\n                        xSignifier <<= xExponent - 16496;\\n                    xExponent = 0;\\n                } else if (xExponent + msb > 49373) {\\n                    xExponent = 0x7FFF;\\n                    xSignifier = 0;\\n                } else {\\n                    if (msb > 112) xSignifier >>= msb - 112;\\n                    else if (msb < 112) xSignifier <<= 112 - msb;\\n\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                    xExponent = xExponent + msb - 16607;\\n                }\\n\\n                return\\n                    bytes16(\\n                        uint128(\\n                            uint128(\\n                                (x ^ y) & 0x80000000000000000000000000000000\\n                            ) |\\n                                (xExponent << 112) |\\n                                xSignifier\\n                        )\\n                    );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y.  Special values behave in the following way:\\n     *\\n     * NaN / x = NaN for any x.\\n     * x / NaN = NaN for any x.\\n     * Infinity / x = Infinity for any finite non-negative x.\\n     * Infinity / x = -Infinity for any finite negative x including -0.\\n     * -Infinity / x = -Infinity for any finite non-negative x.\\n     * -Infinity / x = Infinity for any finite negative x including -0.\\n     * x / Infinity = 0 for any finite non-negative x.\\n     * x / -Infinity = -0 for any finite non-negative x.\\n     * x / Infinity = -0 for any finite non-negative x including -0.\\n     * x / -Infinity = 0 for any finite non-negative x including -0.\\n     *\\n     * Infinity / Infinity = NaN.\\n     * Infinity / -Infinity = -NaN.\\n     * -Infinity / Infinity = -NaN.\\n     * -Infinity / -Infinity = NaN.\\n     *\\n     * Division by zero behaves in the following way:\\n     *\\n     * x / 0 = Infinity for any finite positive x.\\n     * x / -0 = -Infinity for any finite positive x.\\n     * x / 0 = -Infinity for any finite negative x.\\n     * x / -0 = Infinity for any finite negative x.\\n     * 0 / 0 = NaN.\\n     * 0 / -0 = NaN.\\n     * -0 / 0 = NaN.\\n     * -0 / -0 = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) return NaN;\\n                else return x ^ (y & 0x80000000000000000000000000000000);\\n            } else if (yExponent == 0x7FFF) {\\n                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n                else\\n                    return\\n                        POSITIVE_ZERO |\\n                        ((x ^ y) & 0x80000000000000000000000000000000);\\n            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                else\\n                    return\\n                        POSITIVE_INFINITY |\\n                        ((x ^ y) & 0x80000000000000000000000000000000);\\n            } else {\\n                uint256 ySignifier = uint128(y) &\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                uint256 xSignifier = uint128(x) &\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) {\\n                    if (xSignifier != 0) {\\n                        uint256 shift = 226 - mostSignificantBit(xSignifier);\\n\\n                        xSignifier <<= shift;\\n\\n                        xExponent = 1;\\n                        yExponent += shift - 114;\\n                    }\\n                } else {\\n                    xSignifier =\\n                        (xSignifier | 0x10000000000000000000000000000) <<\\n                        114;\\n                }\\n\\n                xSignifier = xSignifier / ySignifier;\\n                if (xSignifier == 0)\\n                    return\\n                        (x ^ y) & 0x80000000000000000000000000000000 > 0\\n                            ? NEGATIVE_ZERO\\n                            : POSITIVE_ZERO;\\n\\n                assert(xSignifier >= 0x1000000000000000000000000000);\\n\\n                uint256 msb = xSignifier >= 0x80000000000000000000000000000\\n                    ? mostSignificantBit(xSignifier)\\n                    : xSignifier >= 0x40000000000000000000000000000\\n                    ? 114\\n                    : xSignifier >= 0x20000000000000000000000000000\\n                    ? 113\\n                    : 112;\\n\\n                if (xExponent + msb > yExponent + 16497) {\\n                    // Overflow\\n                    xExponent = 0x7FFF;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb + 16380 < yExponent) {\\n                    // Underflow\\n                    xExponent = 0;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb + 16268 < yExponent) {\\n                    // Subnormal\\n                    if (xExponent + 16380 > yExponent)\\n                        xSignifier <<= xExponent + 16380 - yExponent;\\n                    else if (xExponent + 16380 < yExponent)\\n                        xSignifier >>= yExponent - xExponent - 16380;\\n\\n                    xExponent = 0;\\n                } else {\\n                    // Normal\\n                    if (msb > 112) xSignifier >>= msb - 112;\\n\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                    xExponent = xExponent + msb + 16269 - yExponent;\\n                }\\n\\n                return\\n                    bytes16(\\n                        uint128(\\n                            uint128(\\n                                (x ^ y) & 0x80000000000000000000000000000000\\n                            ) |\\n                                (xExponent << 112) |\\n                                xSignifier\\n                        )\\n                    );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate -x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function neg(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return x ^ 0x80000000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Calculate |x|.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function abs(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        }\\n    }\\n\\n    /**\\n     * Calculate square root of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function sqrt(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n            else {\\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n                if (xExponent == 0x7FFF) return x;\\n                else {\\n                    uint256 xSignifier = uint128(x) &\\n                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    if (xExponent == 0) xExponent = 1;\\n                    else xSignifier |= 0x10000000000000000000000000000;\\n\\n                    if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n                    bool oddExponent = xExponent & 0x1 == 0;\\n                    xExponent = (xExponent + 16383) >> 1;\\n\\n                    if (oddExponent) {\\n                        if (xSignifier >= 0x10000000000000000000000000000)\\n                            xSignifier <<= 113;\\n                        else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            uint256 shift = (226 - msb) & 0xFE;\\n                            xSignifier <<= shift;\\n                            xExponent -= (shift - 112) >> 1;\\n                        }\\n                    } else {\\n                        if (xSignifier >= 0x10000000000000000000000000000)\\n                            xSignifier <<= 112;\\n                        else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            uint256 shift = (225 - msb) & 0xFE;\\n                            xSignifier <<= shift;\\n                            xExponent -= (shift - 112) >> 1;\\n                        }\\n                    }\\n\\n                    uint256 r = 0x10000000000000000000000000000;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n                    uint256 r1 = xSignifier / r;\\n                    if (r1 < r) r = r1;\\n\\n                    return\\n                        bytes16(\\n                            uint128(\\n                                (xExponent << 112) |\\n                                    (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                            )\\n                        );\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function log_2(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n            else if (x == 0x3FFF0000000000000000000000000000)\\n                return POSITIVE_ZERO;\\n            else {\\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n                if (xExponent == 0x7FFF) return x;\\n                else {\\n                    uint256 xSignifier = uint128(x) &\\n                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    if (xExponent == 0) xExponent = 1;\\n                    else xSignifier |= 0x10000000000000000000000000000;\\n\\n                    if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n                    bool resultNegative;\\n                    uint256 resultExponent = 16495;\\n                    uint256 resultSignifier;\\n\\n                    if (xExponent >= 0x3FFF) {\\n                        resultNegative = false;\\n                        resultSignifier = xExponent - 0x3FFF;\\n                        xSignifier <<= 15;\\n                    } else {\\n                        resultNegative = true;\\n                        if (xSignifier >= 0x10000000000000000000000000000) {\\n                            resultSignifier = 0x3FFE - xExponent;\\n                            xSignifier <<= 15;\\n                        } else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            resultSignifier = 16493 - msb;\\n                            xSignifier <<= 127 - msb;\\n                        }\\n                    }\\n\\n                    if (xSignifier == 0x80000000000000000000000000000000) {\\n                        if (resultNegative) resultSignifier += 1;\\n                        uint256 shift = 112 -\\n                            mostSignificantBit(resultSignifier);\\n                        resultSignifier <<= shift;\\n                        resultExponent -= shift;\\n                    } else {\\n                        uint256 bb = resultNegative ? 1 : 0;\\n                        while (\\n                            resultSignifier < 0x10000000000000000000000000000\\n                        ) {\\n                            resultSignifier <<= 1;\\n                            resultExponent -= 1;\\n\\n                            xSignifier *= xSignifier;\\n                            uint256 b = xSignifier >> 255;\\n                            resultSignifier += b ^ bb;\\n                            xSignifier >>= 127 + b;\\n                        }\\n                    }\\n\\n                    return\\n                        bytes16(\\n                            uint128(\\n                                (\\n                                    resultNegative\\n                                        ? 0x80000000000000000000000000000000\\n                                        : 0\\n                                ) |\\n                                    (resultExponent << 112) |\\n                                    (resultSignifier &\\n                                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                            )\\n                        );\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function ln(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n        }\\n    }\\n\\n    /**\\n     * Calculate 2^x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function pow_2(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n            else if (xExponent > 16397)\\n                return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n            else if (xExponent < 16255)\\n                return 0x3FFF0000000000000000000000000000;\\n            else {\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                if (xExponent > 16367) xSignifier <<= xExponent - 16367;\\n                else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\\n\\n                if (\\n                    xNegative &&\\n                    xSignifier > 0x406E00000000000000000000000000000000\\n                ) return POSITIVE_ZERO;\\n\\n                if (\\n                    !xNegative &&\\n                    xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                ) return POSITIVE_INFINITY;\\n\\n                uint256 resultExponent = xSignifier >> 128;\\n                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xNegative && xSignifier != 0) {\\n                    xSignifier = ~xSignifier;\\n                    resultExponent += 1;\\n                }\\n\\n                uint256 resultSignifier = 0x80000000000000000000000000000000;\\n                if (xSignifier & 0x80000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x16A09E667F3BCC908B2FB1366EA957D3E) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1306FE0A31B7152DE8D5A46305C85EDEC) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1172B83C7D517ADCDF7C8C50EB14A791F) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10B5586CF9890F6298B92B71842A98363) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1059B0D31585743AE7C548EB68CA417FD) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x102C9A3E778060EE6F7CACA4F7A29BDE8) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10163DA9FB33356D84A66AE336DCDFA3F) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100B1AFA5ABCBED6129AB13EC11DC9543) >>\\n                        128;\\n                if (xSignifier & 0x800000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10058C86DA1C09EA1FF19D294CF2F679B) >>\\n                        128;\\n                if (xSignifier & 0x400000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1002C605E2E8CEC506D21BFC89A23A00F) >>\\n                        128;\\n                if (xSignifier & 0x200000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100162F3904051FA128BCA9C55C31E5DF) >>\\n                        128;\\n                if (xSignifier & 0x100000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000B175EFFDC76BA38E31671CA939725) >>\\n                        128;\\n                if (xSignifier & 0x80000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100058BA01FB9F96D6CACD4B180917C3D) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10002C5CC37DA9491D0985C348C68E7B3) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000162E525EE054754457D5995292026) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000B17255775C040618BF4A4ADE83FC) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000162E43F4F831060E02D839A9D16D) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000B1721BCFC99D9F890EA06911763) >>\\n                        128;\\n                if (xSignifier & 0x800000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000058B90CF1E6D97F9CA14DBCC1628) >>\\n                        128;\\n                if (xSignifier & 0x400000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000002C5C863B73F016468F6BAC5CA2B) >>\\n                        128;\\n                if (xSignifier & 0x200000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000162E430E5A18F6119E3C02282A5) >>\\n                        128;\\n                if (xSignifier & 0x100000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000B1721835514B86E6D96EFD1BFE) >>\\n                        128;\\n                if (xSignifier & 0x80000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000058B90C0B48C6BE5DF846C5B2EF) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000002C5C8601CC6B9E94213C72737A) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000162E42FFF037DF38AA2B219F06) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000B17217FBA9C739AA5819F44F9) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000058B90BFCDEE5ACD3C1CEDC823) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000002C5C85FE31F35A6A30DA1BE50) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000162E42FF0999CE3541B9FFFCF) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000B17217F80F4EF5AADDA45554) >>\\n                        128;\\n                if (xSignifier & 0x800000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000058B90BFBF8479BD5A81B51AD) >>\\n                        128;\\n                if (xSignifier & 0x400000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000002C5C85FDF84BD62AE30A74CC) >>\\n                        128;\\n                if (xSignifier & 0x200000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000162E42FEFB2FED257559BDAA) >>\\n                        128;\\n                if (xSignifier & 0x100000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000B17217F7D5A7716BBA4A9AE) >>\\n                        128;\\n                if (xSignifier & 0x80000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000058B90BFBE9DDBAC5E109CCE) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000002C5C85FDF4B15DE6F17EB0D) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000162E42FEFA494F1478FDE05) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000B17217F7D20CF927C8E94C) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000058B90BFBE8F71CB4E4B33D) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000002C5C85FDF477B662B26945) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000162E42FEFA3AE53369388C) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000B17217F7D1D351A389D40) >>\\n                        128;\\n                if (xSignifier & 0x800000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000058B90BFBE8E8B2D3D4EDE) >>\\n                        128;\\n                if (xSignifier & 0x400000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000002C5C85FDF4741BEA6E77E) >>\\n                        128;\\n                if (xSignifier & 0x200000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000162E42FEFA39FE95583C2) >>\\n                        128;\\n                if (xSignifier & 0x100000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000B17217F7D1CFB72B45E1) >>\\n                        128;\\n                if (xSignifier & 0x80000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000058B90BFBE8E7CC35C3F0) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000002C5C85FDF473E242EA38) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000162E42FEFA39F02B772C) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000B17217F7D1CF7D83C1A) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000058B90BFBE8E7BDCBE2E) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000002C5C85FDF473DEA871F) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000162E42FEFA39EF44D91) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000B17217F7D1CF79E949) >>\\n                        128;\\n                if (xSignifier & 0x800000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000058B90BFBE8E7BCE544) >>\\n                        128;\\n                if (xSignifier & 0x400000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000002C5C85FDF473DE6ECA) >>\\n                        128;\\n                if (xSignifier & 0x200000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000162E42FEFA39EF366F) >>\\n                        128;\\n                if (xSignifier & 0x100000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000B17217F7D1CF79AFA) >>\\n                        128;\\n                if (xSignifier & 0x80000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000058B90BFBE8E7BCD6D) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000002C5C85FDF473DE6B2) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000162E42FEFA39EF358) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000B17217F7D1CF79AB) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000058B90BFBE8E7BCD5) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000002C5C85FDF473DE6A) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000162E42FEFA39EF34) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000B17217F7D1CF799) >>\\n                        128;\\n                if (xSignifier & 0x800000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000058B90BFBE8E7BCC) >>\\n                        128;\\n                if (xSignifier & 0x400000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000002C5C85FDF473DE5) >>\\n                        128;\\n                if (xSignifier & 0x200000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000162E42FEFA39EF2) >>\\n                        128;\\n                if (xSignifier & 0x100000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000B17217F7D1CF78) >>\\n                        128;\\n                if (xSignifier & 0x80000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000058B90BFBE8E7BB) >>\\n                        128;\\n                if (xSignifier & 0x40000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000002C5C85FDF473DD) >>\\n                        128;\\n                if (xSignifier & 0x20000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000162E42FEFA39EE) >>\\n                        128;\\n                if (xSignifier & 0x10000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000B17217F7D1CF6) >>\\n                        128;\\n                if (xSignifier & 0x8000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000058B90BFBE8E7A) >>\\n                        128;\\n                if (xSignifier & 0x4000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000002C5C85FDF473C) >>\\n                        128;\\n                if (xSignifier & 0x2000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000162E42FEFA39D) >>\\n                        128;\\n                if (xSignifier & 0x1000000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000B17217F7D1CE) >>\\n                        128;\\n                if (xSignifier & 0x800000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000058B90BFBE8E6) >>\\n                        128;\\n                if (xSignifier & 0x400000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000002C5C85FDF472) >>\\n                        128;\\n                if (xSignifier & 0x200000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000162E42FEFA38) >>\\n                        128;\\n                if (xSignifier & 0x100000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000B17217F7D1B) >>\\n                        128;\\n                if (xSignifier & 0x80000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000058B90BFBE8D) >>\\n                        128;\\n                if (xSignifier & 0x40000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000002C5C85FDF46) >>\\n                        128;\\n                if (xSignifier & 0x20000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000162E42FEFA2) >>\\n                        128;\\n                if (xSignifier & 0x10000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000B17217F7D0) >>\\n                        128;\\n                if (xSignifier & 0x8000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000058B90BFBE7) >>\\n                        128;\\n                if (xSignifier & 0x4000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000002C5C85FDF3) >>\\n                        128;\\n                if (xSignifier & 0x2000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000162E42FEF9) >>\\n                        128;\\n                if (xSignifier & 0x1000000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000B17217F7C) >>\\n                        128;\\n                if (xSignifier & 0x800000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000058B90BFBD) >>\\n                        128;\\n                if (xSignifier & 0x400000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000002C5C85FDE) >>\\n                        128;\\n                if (xSignifier & 0x200000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000162E42FEE) >>\\n                        128;\\n                if (xSignifier & 0x100000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000B17217F6) >>\\n                        128;\\n                if (xSignifier & 0x80000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000058B90BFA) >>\\n                        128;\\n                if (xSignifier & 0x40000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000002C5C85FC) >>\\n                        128;\\n                if (xSignifier & 0x20000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000162E42FD) >>\\n                        128;\\n                if (xSignifier & 0x10000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000B17217E) >>\\n                        128;\\n                if (xSignifier & 0x8000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000058B90BE) >>\\n                        128;\\n                if (xSignifier & 0x4000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000002C5C85E) >>\\n                        128;\\n                if (xSignifier & 0x2000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000162E42E) >>\\n                        128;\\n                if (xSignifier & 0x1000000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000B17216) >>\\n                        128;\\n                if (xSignifier & 0x800000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000058B90A) >>\\n                        128;\\n                if (xSignifier & 0x400000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000002C5C84) >>\\n                        128;\\n                if (xSignifier & 0x200000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000162E41) >>\\n                        128;\\n                if (xSignifier & 0x100000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000000B1720) >>\\n                        128;\\n                if (xSignifier & 0x80000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000058B8F) >>\\n                        128;\\n                if (xSignifier & 0x40000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000002C5C7) >>\\n                        128;\\n                if (xSignifier & 0x20000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000000162E3) >>\\n                        128;\\n                if (xSignifier & 0x10000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000000B171) >>\\n                        128;\\n                if (xSignifier & 0x8000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000000058B8) >>\\n                        128;\\n                if (xSignifier & 0x4000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000002C5B) >>\\n                        128;\\n                if (xSignifier & 0x2000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000000162D) >>\\n                        128;\\n                if (xSignifier & 0x1000 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000000B16) >>\\n                        128;\\n                if (xSignifier & 0x800 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000000058A) >>\\n                        128;\\n                if (xSignifier & 0x400 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000000002C4) >>\\n                        128;\\n                if (xSignifier & 0x200 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000000161) >>\\n                        128;\\n                if (xSignifier & 0x100 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x1000000000000000000000000000000B0) >>\\n                        128;\\n                if (xSignifier & 0x80 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000000057) >>\\n                        128;\\n                if (xSignifier & 0x40 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000000002B) >>\\n                        128;\\n                if (xSignifier & 0x20 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000000015) >>\\n                        128;\\n                if (xSignifier & 0x10 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x10000000000000000000000000000000A) >>\\n                        128;\\n                if (xSignifier & 0x8 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000000004) >>\\n                        128;\\n                if (xSignifier & 0x4 > 0)\\n                    resultSignifier =\\n                        (resultSignifier *\\n                            0x100000000000000000000000000000001) >>\\n                        128;\\n\\n                if (!xNegative) {\\n                    resultSignifier =\\n                        (resultSignifier >> 15) &\\n                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    resultExponent += 0x3FFF;\\n                } else if (resultExponent <= 0x3FFE) {\\n                    resultSignifier =\\n                        (resultSignifier >> 15) &\\n                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    resultExponent = 0x3FFF - resultExponent;\\n                } else {\\n                    resultSignifier =\\n                        resultSignifier >>\\n                        (resultExponent - 16367);\\n                    resultExponent = 0;\\n                }\\n\\n                return\\n                    bytes16(uint128((resultExponent << 112) | resultSignifier));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate e^x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function exp(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n        }\\n    }\\n\\n    /**\\n     * Get index of the most significant non-zero bit in binary representation of\\n     * x.  Reverts if x is zero.\\n     *\\n     * @return index of the most significant non-zero bit in binary representation\\n     *         of x\\n     */\\n    function mostSignificantBit(uint256 x) private pure returns (uint256) {\\n        unchecked {\\n            require(x > 0);\\n\\n            uint256 result = 0;\\n\\n            if (x >= 0x100000000000000000000000000000000) {\\n                x >>= 128;\\n                result += 128;\\n            }\\n            if (x >= 0x10000000000000000) {\\n                x >>= 64;\\n                result += 64;\\n            }\\n            if (x >= 0x100000000) {\\n                x >>= 32;\\n                result += 32;\\n            }\\n            if (x >= 0x10000) {\\n                x >>= 16;\\n                result += 16;\\n            }\\n            if (x >= 0x100) {\\n                x >>= 8;\\n                result += 8;\\n            }\\n            if (x >= 0x10) {\\n                x >>= 4;\\n                result += 4;\\n            }\\n            if (x >= 0x4) {\\n                x >>= 2;\\n                result += 2;\\n            }\\n            if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n            return result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/briandonatiello/Documents/GemBooster/contract/contracts/interfaces/DexRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface DexRouter {\\n    function WETH() external pure returns (address);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TRANSACTION_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"the_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"can_buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"can_sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exclude\",\"type\":\"bool\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"manageTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"setLPPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setTargets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target_buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target_sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"the_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000989680", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}