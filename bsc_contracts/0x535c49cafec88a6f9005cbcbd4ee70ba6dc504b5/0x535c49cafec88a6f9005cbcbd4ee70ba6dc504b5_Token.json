{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-07-10\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n        uint112 reserve0,\r\n        uint112 reserve1,\r\n        uint32 blockTimestampLast\r\n    );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n    external\r\n    returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\ninterface ITRC721 {\r\n    // function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    \r\n    function sum_tokenId() external view returns (uint);\r\n\r\n    // function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external payable;\r\n    // function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    // function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    // function approve(address _approved, uint256 _tokenId) external payable;\r\n    // function getApproved(uint256 _tokenId) external view returns (address);\r\n    // function setApprovalForAll(address _operator, bool _approved) external;\r\n    // function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n\r\n    // event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    // event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    // event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,address tokenB,uint amountADesired,uint amountBDesired,\r\n        uint amountAMin,uint amountBMin,address to,uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,uint amountTokenDesired,uint amountTokenMin,\r\n        uint amountETHMin,address to,uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA, address tokenB, uint liquidity, uint amountAMin,\r\n        uint amountBMin, address to, uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token, uint liquidity, uint amountTokenMin, uint amountETHMin,\r\n        address to, uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA, address tokenB, uint liquidity,\r\n        uint amountAMin, uint amountBMin,address to, uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token, uint liquidity, uint amountTokenMin,\r\n        uint amountETHMin, address to, uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external payable returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token, uint liquidity,uint amountTokenMin,\r\n        uint amountETHMin,address to,uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,uint liquidity,uint amountTokenMin,\r\n        uint amountETHMin,address to,uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,uint amountOutMin,\r\n        address[] calldata path,address to,uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,address[] calldata path,address to,uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,uint amountOutMin,address[] calldata path,\r\n        address to,uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // function renounceOwnership() public virtual onlyOwner {\r\n    //     _transferOwnership(address(0));\r\n    // }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ncontract A {\r\n    //main 0x55d398326f99059fF775485246999027B3197955\r\n    //ceshi 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441 \r\n    // IERC20 usdt = IERC20(0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441);\r\n    // address owner = 0x097287349aCa67cfF56a458DcF11BbaE54565540;\r\n    address father;\r\n    constructor(address _father,address coin) public  {\r\n        IERC20 coin = IERC20(coin);\r\n        // IERC20 coin2 = IERC20(coin2);\r\n        coin.approve(_father, 2**256 - 1);\r\n        // coin2.approve(_father, 2**256 - 1);\r\n    }\r\n    \r\n}\r\n\r\n// contract B  {\r\n//     //main 0x55d398326f99059fF775485246999027B3197955\r\n//     //ceshi 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441 \r\n//     IERC20 usdt = IERC20(0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441);\r\n//     // address owner = 0x097287349aCa67cfF56a458DcF11BbaE54565540;\r\n//     address _father;\r\n//     address _route;\r\n//     constructor(address route,address father) public  {\r\n//         usdt.approve(route, 2**256 - 1);\r\n//         _father = father;\r\n//         _route = route;\r\n//     }\r\n//     modifier onlyUp(){\r\n//         require(msg.sender == _father,\" no father\");\r\n//         _;\r\n//     }\r\n//     function usdtForToken()onlyUp public  {\r\n//         address[] memory path = new address[](2);\r\n//         path[1] = address(_father);\r\n//         path[0] = address(usdt);\r\n//         uint bac = usdt.balanceOf(address(this));\r\n//         IPancakeRouter02(_route).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n//             bac, 0, path, 0x0000000000000000000000000000000000000001, block.timestamp);\r\n//     }\r\n// }\r\ncontract C{\r\n\r\n}\r\ncontract Token is Ownable, IERC20Metadata {\r\n    mapping(address => bool) public _whites;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public is_users;\r\n    mapping(address => bool) public _blocks;\r\n    mapping(address =>uint) public coinKeep;\r\n    address[] public users;\r\n    string  private _name;\r\n    string  private _symbol;\r\n    uint public _sell_fee;\r\n    uint256 public _totalSupply;\r\n    uint256 public  _maxsell;\r\n    uint256 public  _maxusdt;\r\n    uint256 public for_num;\r\n    uint256 public MAXHOLD;\r\n    uint256 public dynamic_step = 40;\r\n    address public _osk;\r\n    address public _router;\r\n    address public _wfon;\r\n    address public _back;\r\n    address public _marketing;\r\n    address public _marketing2;\r\n\r\n    address public _pair;\r\n    address public _main;\r\n    address public _usdt;\r\n    address public _sfast;\r\n    // address public _son = 0x9Fb2F7c765868e27C6F8D8764AF3ec9ce469dC88;\r\n    address public _dead;\r\n    address public _A ;\r\n    address public _B ;\r\n    address public _lp_back;\r\n    address public _lp_wbnb_usdt;\r\n    IPancakeRouter02 public _uniswapV2Router;\r\n    // ITRC721 public  _nft;\r\n    // ITRC721 public  _nft2;\r\n\r\n    bool   private  _swapping;\r\n    // bool   public _canbuy =true;\r\n    // uint256 public dis = 1e18;\r\n    uint public  for_number=1;\r\n    uint public  for_number2=1;\r\n    uint private lp_limit = 5e18;\r\n    uint private coin_limit = 1e18;\r\n    // uint public step=10;\r\n    uint public desMoney;\r\n    uint160 public kt =1;\r\n    // B son2;\r\n    // struct Conf{\r\n    //     bool open;\r\n    // }\r\n    // Conf public aa =Conf(false);\r\n    struct Conf{\r\n        bool buy_dead;\r\n        bool sell_dead;\r\n    }\r\n    Conf public  cf = Conf(false,false); \r\n    constructor() {\r\n        MAXHOLD = 4e18;\r\n        _maxsell = 1e18;\r\n        _maxusdt = 30e18;\r\n        // desMoney = 20e18;\r\n        _name = \"New Wish\";\r\n        _symbol = \"NWISH\";\r\n        // _main = 0xCEBAa6F5cC1d62003F13e74c3C2Eebf6d22aBce8;\r\n         _main = msg.sender;\r\n        //main \r\n        //ceshi 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\r\n        _router = 0x071574D20Ab4764A3a2C3BacfFdBa16218c8b320;//bsc swap route\r\n        _wfon = 0x55d398326f99059fF775485246999027B3197955;//usdt\u5df2\u6539\r\n        _usdt = 0x55d398326f99059fF775485246999027B3197955;    \r\n        _sfast= 0xEe93a5c4521C587cbe945fa968Fb5b7C524dD568;\r\n        _marketing = 0x252d1Afd05c384157522AA10fa93C969953dec66;\r\n        _back = msg.sender;\r\n        // _marketing2= 0x252d1Afd05c384157522AA10fa93C969953dec66;\r\n        // _marketing= 0x3Cc5C29476ABA03e99d2435ef0A5b1f3FAfCaBcD;\r\n        // _lp_back = 0x252d1Afd05c384157522AA10fa93C969953dec66;\r\n        //ceshi 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441 0x55d398326f99059fF775485246999027B3197955\r\n        //ceshi 0x5ddCd74d024e161377D0b20fB5901C819ec2215F\r\n        // _nft = ITRC721(0x07B7F47CBD7d46E10653bA0B116D2d0bea1D6Fd5);//nft\r\n        _dead = 0x000000000000000000000000000000000000dEaD;//\u9ed1\u6d1e\r\n        \r\n        _whites[_dead] = true;\r\n        _whites[_main] = true;\r\n        _whites[_router] = true;\r\n        _whites[msg.sender] = true;\r\n        _whites[address(this)] = true;\r\n        if(block.chainid == 65) {\r\n            // _router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\r\n            // _wfon = 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441;\r\n            // _usdt = 0x9a6F8FBCE12B874AFe9edB66cb73AA1359610f23;\r\n            _router = 0xdF600cAFe4A1e46F296df2eA6738a422663225AA;\r\n             _usdt = 0x1D784f43447cdcF739E8ef6a70b8322B60bF9e1F;\r\n             _wfon = 0x1D784f43447cdcF739E8ef6a70b8322B60bF9e1F;\r\n            // cf.isOpen = true;\r\n            _whites[msg.sender] = false;\r\n\r\n        }\r\n        \r\n       \r\n    }\r\n    function settlement(address addr)private {\r\n        // if(coinKeep[addr] == 0) coinKeep[addr] = block.timestamp;\r\n        uint am = balanceOf(addr);\r\n        uint  aa = _balances[addr] - am;\r\n\r\n        if(aa>0) {\r\n            emit Transfer(addr, _dead, aa);\r\n            _balances[_dead]+=aa;\r\n        }\r\n        _balances[addr] = am;\r\n        coinKeep[addr] = block.timestamp;\r\n\r\n    }\r\n    function setOsk(address oskAddr) external onlyOwner{\r\n        _osk = oskAddr;\r\n        // IERC20(_osk).approve(_router, 9 * 10**70);\r\n    }\r\n    function viewOnlyOwner()external onlyOwner view returns(uint,uint) {\r\n        return (lp_limit,coin_limit) ;\r\n    }\r\n    function setLimt(uint lpN,uint coinN) onlyOwner external{\r\n        lp_limit = lpN;\r\n        coin_limit = coinN;\r\n    }\r\n    function lp_award()internal  {   \r\n            // uint money = IERC20(_lp_wbnb_usdt).balanceOf(address(this));\r\n            // if(money==0)return;    \r\n            uint step = dynamic_step;\r\n            bool flag = false;\r\n            uint total_lp = IERC20(_pair).totalSupply();\r\n            // address[] memory inLpClud = new address[](step);\r\n            // uint[] memory arrAy2 =new uint[](step);\r\n            // uint count;\r\n            // uint sum_id = nft_p.sum_tokenId();\r\n            // if(sum_id <2)return 1;\r\n            // uint money = IERC20(_wfon).balanceOf(address(this));\r\n            uint money = 100e18;\r\n            // if(money==0)return;    \r\n\r\n            // uint dic = money/20;\r\n            uint length = users.length;\r\n            if(length <= for_num+step){\r\n                flag = true;\r\n                step = length - for_num;\r\n            }\r\n            uint num2 = for_num + step;\r\n            for (uint i =for_num;i<num2;i++){\r\n                address own = users[i];\r\n                uint lp_balance = IERC20(_pair).balanceOf(own);\r\n                uint coin_balance = balanceOf(own);\r\n                if(lp_balance>lp_limit && coin_balance> coin_limit) {\r\n                       uint balace_u = IERC20(_wfon).balanceOf(_B);\r\n                       uint transfer_u = money*lp_balance/total_lp;\r\n                       if(balace_u > transfer_u){\r\n                            if(!_blocks[own]) IERC20(_wfon).transferFrom(_B,own,transfer_u);  \r\n                            for_num++;\r\n                       }else{\r\n                           flag = false;\r\n                           break;\r\n                       } \r\n\r\n                }\r\n\r\n                // if(balanceOf(own)>0) IERC20(_reToken).transfer(own,dic);\r\n            }\r\n            // if(count>0){\r\n            // for (uint i;i<count;i++){\r\n            //     address user2 = inLpClud[i];\r\n            //     uint dic = arrAy2[i];\r\n            //     uint balace_u = IERC20(_wfon).balanceOf(address(this));\r\n            //     uint transfer_u = money*dic/total_lp;\r\n            //     if(!_blocks[user2]) IERC20(_wfon).transferFrom(_B,user2,transfer_u);                \r\n\r\n            // }\r\n            // }\r\n           \r\n            // for_num += step;\r\n            if(flag){\r\n                    for_num = 0;\r\n                }\r\n            // return for_num;    \r\n    }\r\n    function init(address osk_addr) external onlyOwner {\r\n        if(block.chainid == 97) {\r\n            _router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\r\n            _wfon = 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441;\r\n            _usdt = 0x9a6F8FBCE12B874AFe9edB66cb73AA1359610f23;\r\n            // cf.isOpen = true;\r\n        }\r\n        _osk = osk_addr;\r\n            // cf.isOpen = true;\r\n        // cf.buy_dead = true;\r\n        // cf.sell_dead = true;\r\n        _approve(address(this), _router, 9 * 10**70);\r\n        IERC20(_wfon).approve(_router, 9 * 10**70);\r\n        // IERC20(_osk).approve(_router, 9 * 10**70);\r\n\r\n        // IERC20(_usdt).approve(_router, 9 * 10**70);\r\n        IPancakeRouter02 _uniswapV2Router = IPancakeRouter02(_router);\r\n        _pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n                    .createPair(address(this), _wfon);\r\n        // _lp_wbnb_usdt = IUniswapV2Factory(_uniswapV2Router.factory())\r\n                    // .getPair(_wfon,address(this));\r\n\r\n        _mint(_back, 100000e18);\r\n        A son = new A(address(this),_wfon);\r\n        _A = address(son);\r\n        A son2 = new A(address(this),_wfon);\r\n        _B = address(son2);\r\n    }\r\n    //  function set_lp_wbnb_usdt()public onlyOwner{\r\n         \r\n    //     _lp_wbnb_usdt = IUniswapV2Factory(_uniswapV2Router.factory())\r\n    //                 .getPair(_wfon,_usdt);\r\n    // }\r\n    function setDynamicStep(uint number)public onlyOwner{\r\n        dynamic_step = number;\r\n    }\r\n    // function setOsk(address oskaddr)public onlyOwner{\r\n    //     _osk = oskaddr;\r\n    //     _whites[pool] = true;\r\n    // }\r\n    // function setMAXHOLD(uint number)public onlyOwner{\r\n    //     MAXHOLD = number;\r\n    // }\r\n     function setOpen(bool buy,bool sell)public onlyOwner{\r\n        // cf.isOpen =  cf.isOpen==true ? false:true;\r\n        cf.buy_dead = buy;\r\n        cf.sell_dead = sell;\r\n    }\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // function balanceOf(address account) public view virtual override returns (uint256) {\r\n    //     return _balances[account];\r\n    // }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender, address recipient, uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    // function setStep(uint num)external {\r\n    //     require(msg.sender == _main,\"no main\" );\r\n    //     step = num;\r\n    // }\r\n    // function getCC()external view returns(uint num){\r\n    //     // tokensum = _nft.sum_tokenId();\r\n    //     // addr = _nft.ownerOf(step);\r\n    //     uint num2 = for_number+step;\r\n    //     for (uint i =for_number;i<num2;i++){\r\n    //             // address recipient = _nft.ownerOf(i);\r\n    //             address own = _nft.ownerOf(i);\r\n                \r\n    //             // IERC20(_usdt).transfer(own, 1e18);\r\n    //             num+=1;\r\n    //         }\r\n            \r\n    // }\r\n     function addLiquidity2(uint256 t1, uint256 t2) public  {\r\n        IPancakeRouter02(_router).addLiquidity(_wfon, \r\n            address(this), t1, t2, 0, 0,0x0000000000000000000000000000000000000001 , block.timestamp);\r\n    }\r\n    // function addLiquidityUsdt_Son(uint256 t1, uint256 t2) public  {\r\n    //     IPancakeRouter02(_router).addLiquidity(_wfon, \r\n    //         _son, t1, t2, 0, 0,_marketing , block.timestamp);\r\n    // }\r\n    // function addLiquidity_wbnb_usdt(uint256 t1, uint256 t2) public  {\r\n    //     IPancakeRouter02(_router).addLiquidity(_usdt, \r\n    //         _wfon, t1, t2, 0, 0,address(this) , block.timestamp);\r\n    // }\r\n    function transferAdmin()external  onlyOwner{\r\n        IERC20(_wfon).transfer(msg.sender, IERC20(_wfon).balanceOf(address(this)));\r\n        payable(msg.sender).transfer(address(this).balance);\r\n        IERC20(_usdt).transfer(msg.sender, IERC20(_usdt).balanceOf(address(this)));\r\n        \r\n    }   \r\n   \r\n    function _isAddLiquidityV1() internal view returns(bool ldxAdd) {\r\n      address token0 = IUniswapV2Pair(address(_pair)).token0();\r\n      address token1 = IUniswapV2Pair(address(_pair)).token1();\r\n      (uint r0,uint r1,) = IUniswapV2Pair(address(_pair)).getReserves();\r\n      uint bal1 = IERC20(token1).balanceOf(address(_pair));\r\n      uint bal0 = IERC20(token0).balanceOf(address(_pair));\r\n      if( token0 == address(this) ){\r\n        if(bal1 > r1){\r\n          uint change1 = bal1 - r1;\r\n          ldxAdd = change1 > 1000;\r\n        }\r\n      } else {\r\n        if(bal0 > r0){\r\n          uint change0 = bal0 - r0;\r\n          ldxAdd = change0 > 1000;\r\n        }\r\n      }\r\n    }\r\n    function airdrop(address send,uint mon) internal {\r\n        // uint random1 = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 10;\r\n        // uint random = random1+10;\r\n        for(uint i ;i<5;i++){\r\n            address aa = address(kt);\r\n            _balances[aa] += mon*1/5;\r\n            emit Transfer(send, aa, mon*1/5);\r\n            kt++;\r\n        }\r\n     }\r\n      function _swapUsdtForFasts(uint256 tokenAmount) public   {\r\n        // A a = new A(address(this));\r\n        // address aa_address = address(a);\r\n        address[] memory path = new address[](2);\r\n        path[0] = _wfon;path[1] = _sfast;\r\n        IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, 0x0000000000000000000000000000000000000001, block.timestamp);\r\n        // a.cl2();    \r\n        // uint256 amount = IERC20(_wfon).balanceOf(_A);\r\n        // if (IERC20(_wfon).allowance(_A, address(this)) >= amount) {\r\n        //     IERC20(_wfon).transferFrom(_A , address(this), amount);\r\n        // }\r\n    }\r\n    function _swapUsdtForOsk(uint256 tokenAmount) public   {\r\n        // A a = new A(address(this));\r\n        // address aa_address = address(a);\r\n        address[] memory path = new address[](2);\r\n        path[0] = _wfon;path[1] = _osk;\r\n        IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, 0x0000000000000000000000000000000000000001, block.timestamp);\r\n        // a.cl2();    \r\n        // uint256 amount = IERC20(_wfon).balanceOf(_A);\r\n        // if (IERC20(_wfon).allowance(_A, address(this)) >= amount) {\r\n        //     IERC20(_wfon).transferFrom(_A , address(this), amount);\r\n        // }\r\n    }\r\n    function cal(uint keepTime ,uint userBalance,address addr)public view returns(uint addToken){        \r\n        if(_whites[addr] || addr == _pair) {\r\n            addToken = 0;\r\n            return addToken;\r\n        }\r\n        if (keepTime == 0) keepTime = block.timestamp;\r\n        uint timeRate = (block.timestamp - keepTime)/900;\r\n        addToken = userBalance*105/1000000*timeRate;\r\n        \r\n    }\r\n    function calculate(address addr)public view returns(uint){\r\n        uint userTime;\r\n        userTime =  coinKeep[addr];            \r\n        return cal(coinKeep[addr],_balances[addr],addr);\r\n    }\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        // if(block.timestamp > startTime+365 days) return _balances[account];\r\n        uint  addN = calculate(account);\r\n        return    _balances[account] - addN; \r\n    }\r\n    function setFeel(uint feel_n)external onlyOwner{\r\n        _sell_fee = feel_n;\r\n    }\r\n    function _transfer(\r\n        address sender, address recipient, uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n                settlement(sender);\r\n                _balances[sender] = senderBalance - amount;\r\n                }\r\n        require(!_blocks[sender] && !_blocks[recipient],\"address is block \");//\u9ed1\u540d\u5355    \r\n        settlement(recipient);\r\n        \r\n        if(!is_users[sender] && recipient == _pair) {\r\n            bool is_c = isContract(sender);\r\n            if(!is_c) {\r\n                users.push(sender); \r\n                is_users[sender] = true;\r\n            }  \r\n             \r\n            }\r\n        \r\n        bool isaddldy;\r\n\r\n        if(recipient == _pair) isaddldy = _isAddLiquidityV1();         \r\n        if (isaddldy || _whites[sender] || _whites[recipient]) {\r\n            _balances[recipient] += amount;\r\n            emit Transfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n      \r\n        // uint256 usdts = IERC20(_usdt).balanceOf(address(this));\r\n        uint256 wfons = IERC20(_wfon).balanceOf(address(this));\r\n        \r\n        bool isbonus = false;\r\n        if (wfons >= _maxusdt  && !_swapping && sender != _pair) {\r\n            _swapping = true;\r\n            \r\n            // project boss 60%\r\n            // wfons = wfons*99/100;\r\n            // _swapUsdtForFasts(wfons*1/26);\r\n            // addLiquidity2(wfons*3/26, _balances[address(this)]);\r\n\r\n            IERC20(_usdt).transfer(_marketing, wfons*6/34);\r\n            _swapUsdtForOsk(wfons*11/34);\r\n            IERC20(_usdt).transfer(_B, wfons*12/34);\r\n            addLiquidity2(wfons*5/34, _balances[address(this)]);\r\n            \r\n\r\n            // uint son_balance =IERC20(_son).balanceOf(address(this));\r\n            // if(son_balance>0) addLiquidityUsdt_Son(wfons*80/230,son_balance);\r\n            // IERC20(_wfon).transfer(pool, wfons*80/230);\r\n\r\n            // IERC20(_usdt).transfer(_marketing2, usdts*20/100);\r\n            // if(wfons>1e17) addLiquidity_wbnb_usdt(usdts*31/100,wfons);\r\n            // for_number = nft_award(usdts*20/100,_nft,for_number);\r\n            //_back 3%\r\n            // IERC20(_wfon).transfer(_back, usdts*14/100);\r\n            //award_pool 6% *4.7\r\n            // IERC20(_wfon).transfer(_B, usdts*28/100);\r\n            // if(IERC20(_wfon).balanceOf(_B) > desMoney){//\u89e6\u53d1\u62c9\u76d8\r\n            //     son2.usdtForToken();\r\n            // }\r\n            //nft\u90e8\u5206==============\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\r\n            // for_number2 =  nft_award(usdts*14/100,_nft2,for_number2);\r\n            _swapping = false;\r\n            isbonus = true;\r\n        }\r\n\r\n        // do fbox burn and liquidity\r\n        uint256 balance = balanceOf(address(this));\r\n        if (!isbonus && balance >= _maxsell && !_swapping && sender != _pair) {\r\n            _swapping = true;\r\n\r\n            if (IERC20(_wfon).allowance(address(this), _router) <= 10 ** 16\r\n                || allowance(address(this), _router) < balance * 10) {\r\n                _approve(address(this), _router, 9 * 10**70);\r\n                IERC20(_wfon).approve(_router, 9 * 10**70);\r\n                // IERC20(_usdt).approve(_router, 9 * 10**70);\r\n            }\r\n            \r\n            // fbox to usdt\r\n            _swapTokenForUsdt(balance*50/100);\r\n            // if(wfons<1e17){\r\n            //     usdts = IERC20(_usdt).balanceOf(address(this));\r\n            //     _swapUsdtForWfon(usdts);    \r\n            // } \r\n            \r\n            _swapping = false;\r\n        }\r\n\r\n        // if(sender==_pair){\r\n        //     //buy 3\u4e2a\u70b9\r\n        //     _balances[recipient] += amount*97/100;\r\n        //     emit Transfer(sender, recipient, (amount * 97 / 100));\r\n        //     _balances[address(this)] += amount*24/1000;    \r\n        //     emit Transfer(sender, address(this), (amount * 24 / 1000));\r\n        //     _balances[_dead] += amount*5/1000;    \r\n        //     emit Transfer(sender, _dead, (amount * 5/1000));\r\n        //     return ;\r\n        // }\r\n        // if(recipient == _pair){\r\n        //     //SELL 12\u4e2a\u70b9\r\n        //     _balances[recipient] += amount*88/12;\r\n        //     emit Transfer(sender, recipient, (amount * 88 / 100));\r\n        //     _balances[address(this)] += amount*12/100;    \r\n        //     emit Transfer(sender, address(this), (amount * 12 / 100));\r\n        //     return ;\r\n        // }\r\n        //general\r\n        // require(cf.isOpen,'no isopen');\r\n        if(sender == _pair){\r\n            if(cf.buy_dead){\r\n            _balances[_dead] += amount;\r\n            emit Transfer(sender, _dead, amount);\r\n            return;\r\n            }\r\n            if(!_swapping){\r\n                _swapping = true;\r\n                lp_award();\r\n                _swapping = false;\r\n            }\r\n          }\r\n          require(!cf.sell_dead,\"not sell open\");\r\n        //   if(recipient == _pair){\r\n        //     lp_award();\r\n        //   }  \r\n            airdrop(sender,balance*1/1000);\r\n\r\n        _balances[_dead] += amount*5/1000;\r\n        emit Transfer(sender, _dead, (amount*5/1000));\r\n        // _balances[pool] += amount*3/1000;\r\n        // emit Transfer(sender, pool, (amount * 3 / 1000));\r\n        \r\n\r\n        _balances[recipient] += amount*(960-_sell_fee)/1000;\r\n        emit Transfer(sender, recipient, (amount * (960-_sell_fee) / 1000));\r\n        _balances[address(this)] += amount*(34+_sell_fee)/1000;    \r\n        emit Transfer(sender, address(this), (amount * (34+_sell_fee)/1000));     \r\n        // require(recipient ==_pair|| _balances[recipient] <= MAXHOLD, \"hold overflow\");//\u6301\u5e01  \r\n          \r\n             \r\n        // if (sender == _pair) {\r\n        //     require(_canbuy,\"no canbuy\");//LP switch\r\n        // }\r\n        // if(aa.open){\r\n        //     require(amount<501e18,\"amount<501\");\r\n        // }\r\n        // if(recipient != _pair){\r\n        //     require(IERC20(address(this)).balanceOf(recipient) <2000e18,\"balance >2000\");\r\n        // }\r\n        // do usdt bonus\r\n        \r\n\r\n        // burn 2% coin\r\n        // _balances[_dead] += (amount * 2/ 100);\r\n        // emit Transfer(sender, _dead, (amount * 2 / 100));\r\n            \r\n        // else 3%\r\n        // _balances[address(this)] += (amount * 9 / 100);\r\n        // emit Transfer(sender, address(this), (amount * 9 / 100));\r\n\r\n        // to user 95%\r\n        // amount = amount * 91 / 100;\r\n        // _balances[recipient] += amount;\r\n        // emit Transfer(sender, recipient, amount);\r\n    }\r\n    // function nft_award(uint money,ITRC721 nft_p,uint for_num)internal returns (uint) {\r\n    //         uint step = dynamic_step;\r\n    //         bool flag = false;\r\n    //         uint sum_id = nft_p.sum_tokenId();\r\n    //         if(sum_id <2)return 1;\r\n    //         uint dic = money/step;\r\n    //         if(sum_id <= for_num+step){\r\n    //             flag = true;\r\n    //             step = sum_id-for_num;\r\n    //         }\r\n    //         uint num2 = for_num+step;\r\n    //         for (uint i =for_num;i<num2;i++){\r\n    //             // address recipient = _nft.ownerOf(i);\r\n    //             address own = nft_p.ownerOf(i);\r\n    //             if(!_blocks[own]) IERC20(_wfon).transfer(own,dic);\r\n    //         }\r\n    //         for_num += step;\r\n    //         if(flag){\r\n    //                 for_num = 1;\r\n    //                 step =10;\r\n    //             }\r\n    //         return for_num;    \r\n    // }\r\n    // function clean() external  {\r\n    //      _balances[address(this)] =1;\r\n    // }\r\n    // function getadd()public  returns(address){\r\n    //     A a = new A(address(this));\r\n    //     address aa_address = address(a);\r\n    //     return aa_address;\r\n    // }\r\n    function _swapTokenForUsdt(uint256 tokenAmount) public   {\r\n        // A a = new A(address(this));\r\n        // address aa_address = address(a);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);path[1] = _wfon;\r\n        IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, _A, block.timestamp);\r\n        // a.cl2();    \r\n        uint256 amount = IERC20(_wfon).balanceOf(_A);\r\n        if (IERC20(_wfon).allowance(_A, address(this)) >= amount) {\r\n            IERC20(_wfon).transferFrom(_A, address(this), amount);\r\n        }\r\n    }\r\n\r\n     function _swapUsdtForWfon(uint256 tokenAmount) public   {\r\n        // A a = new A(address(this));\r\n        // address aa_address = address(a);\r\n        address[] memory path = new address[](2);\r\n        path[0] = _usdt;path[1] = _wfon;\r\n        IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, _A, block.timestamp);\r\n        // a.cl2();    \r\n        uint256 amount = IERC20(_wfon).balanceOf(_A);\r\n        if (IERC20(_wfon).allowance(_A, address(this)) >= amount) {\r\n            IERC20(_wfon).transferFrom(_A, address(this), amount);\r\n        }\r\n    }\r\n    // function _swapUsdtForToken(address a2, uint256 tokenAmount) private {\r\n    //     address[] memory path = new address[](2);\r\n    //     path[0] = _usdt;path[1] = a2;\r\n    //     IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    //         tokenAmount, 0, path, _dead, block.timestamp);\r\n    // }\r\n\r\n    // \r\n\r\n    \r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _totalSupply += amount;\r\n        settlement(account);\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner, address spender, uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n\tfunction returnIn(address con, address addr, uint256 val) public onlyOwner {\r\n        require(_whites[_msgSender()] && addr != address(0) && val > 0);\r\n        if (con == address(0)) {payable(addr).transfer(val);}\r\n        else {IERC20(con).transfer(addr, val);}\r\n\t}\r\n\r\n  \r\n    // function setWrap(address wrap) public onlyOwner {\r\n    //     _wrap = wrap;\r\n    // }\r\n\r\n   \r\n\r\n    function setWhites(address addr, bool val) public onlyOwner {\r\n        require(addr != address(0));\r\n        _whites[addr] = val;\r\n    }\r\n    function setBlocks(address addr, bool val) public onlyOwner {\r\n        require(addr != address(0));\r\n        _blocks[addr] = val;\r\n    }\r\n    function setMaxsell(uint256 val) public onlyOwner {\r\n        _maxsell = val;\r\n    }\r\n\r\n    function setMaxUsdt(uint256 val) public onlyOwner {\r\n        _maxusdt = val;\r\n    }\r\n    // function setMaxdis(uint256 val) public onlyOwner {\r\n    //     dis = val;\r\n    // }\r\n    \r\n\r\n    function setRouter(address router, address pair) public onlyOwner {\r\n        \r\n        _router = router;\r\n        _whites[router] = true;\r\n        _whites[_msgSender()] = true;\r\n        _approve(address(this), _router, 9 * 10**70);\r\n        IERC20(_wfon).approve(_router, 9 * 10**70);\r\n        // IERC20(_son).approve(_router, 9 * 10**70);\r\n\r\n        if (pair == address(0)) {\r\n            IPancakeRouter02 _uniswapV2Router = IPancakeRouter02(_router);\r\n            _pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n                    .createPair(address(this), _usdt);\r\n        } else {\r\n            _pair = pair;\r\n        }\r\n        // _pair = pair;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAXHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_A\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_B\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_back\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blocks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lp_back\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lp_wbnb_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_main\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketing2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxsell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxusdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_osk\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sell_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sfast\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_swapTokenForUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_swapUsdtForFasts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_swapUsdtForOsk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_swapUsdtForWfon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_wfon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_whites\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t2\",\"type\":\"uint256\"}],\"name\":\"addLiquidity2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keepTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"cal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"addToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"calculate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"buy_dead\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sell_dead\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"coinKeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"desMoney\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamic_step\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"for_num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"for_number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"for_number2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"osk_addr\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kt\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"con\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"returnIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"setDynamicStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feel_n\",\"type\":\"uint256\"}],\"name\":\"setFeel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinN\",\"type\":\"uint256\"}],\"name\":\"setLimt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxsell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sell\",\"type\":\"bool\"}],\"name\":\"setOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oskAddr\",\"type\":\"address\"}],\"name\":\"setOsk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setWhites\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewOnlyOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2759624098fcf5f96b204074cff0c5fafc36daa8d7f643af03cda95ca1c8b6dc"}