{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/HashBet.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract HashBet is Ownable, ReentrancyGuard {\r\n    // Modulo is the number of equiprobable outcomes in a game:\r\n    //  2 for coin flip\r\n    //  6 for dice roll\r\n    //  6*6 = 36 for double dice\r\n    //  37 for roulette\r\n    //  100 for hashroll\r\n    uint constant MAX_MODULO = 100;\r\n\r\n    // Modulos below MAX_MASK_MODULO are checked against a bit mask, allowing betting on specific outcomes. \r\n    // For example in a dice roll (modolo = 6), \r\n    // 000001 mask means betting on 1. 000001 converted from binary to decimal becomes 1.\r\n    // 101000 mask means betting on 4 and 6. 101000 converted from binary to decimal becomes 40.\r\n    // The specific value is dictated by the fact that 256-bit intermediate\r\n    // multiplication result allows implementing population count efficiently\r\n    // for numbers that are up to 42 bits, and 40 is the highest multiple of\r\n    // eight below 42.\r\n    uint constant MAX_MASK_MODULO = 40;\r\n    \r\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\r\n    // past. Given that settleBet uses block hash of placeBet as one of\r\n    // complementary entropy sources, we cannot process bets older than this\r\n    // threshold. On rare occasions dice2.win croupier may fail to invoke\r\n    // settleBet in this timespan due to technical issues or extreme Ethereum\r\n    // congestion; such bets can be refunded via invoking refundBet.\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n     // This is a check on bet mask overflow. Maximum mask is equivalent to number of possible binary outcomes for maximum modulo.\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\r\n\r\n    // These are constants taht make O(1) population count in placeBet possible.\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n\r\n    // Sum of all historical deposits and withdrawals. Used for calculating profitability. Profit = Balance - cumulativeDeposit + cumulativeWithdrawal\r\n    uint public cumulativeDeposit;\r\n    uint public cumulativeWithdrawal;\r\n\r\n    // In addition to house edge, wealth tax is added every time the bet amount exceeds a multiple of a threshold.\r\n    // For example, if wealthTaxIncrementThreshold = 3000 ether,\r\n    // A bet amount of 3000 ether will have a wealth tax of 1% in addition to house edge.\r\n    // A bet amount of 6000 ether will have a wealth tax of 2% in addition to house edge.\r\n    uint public wealthTaxIncrementThreshold = 3000 ether;\r\n    uint public wealthTaxIncrementPercent = 1;\r\n\r\n    // The minimum and maximum bets.\r\n    uint public minBetAmount = 0.01 ether;\r\n    uint public maxBetAmount = 10000 ether;\r\n\r\n    // max bet profit. Used to cap bets against dynamic odds.\r\n    uint public maxProfit = 300000 ether;\r\n\r\n    // Funds that are locked in potentially winning bets. Prevents contract from committing to new bets that it cannot pay out.\r\n    uint public lockedInBets;\r\n\r\n    // The minimum larger comparison value.\r\n    uint public minOverValue = 50;\r\n\r\n    // The maximum smaller comparison value.\r\n    uint public maxUnderValue = 50;\r\n\r\n    struct BetItem {\r\n        // Wager amount in wei.\r\n        uint amount;\r\n        // Modulo of a game.\r\n        uint8 modulo;\r\n    }\r\n\r\n    // Info of each bet.\r\n    struct Bet {\r\n        BetItem item;\r\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollEdge),\r\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\r\n        uint8 rollEdge;\r\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\r\n        uint40 mask;\r\n        // Block number of placeBet tx.\r\n        uint placeBlockNumber;\r\n        // Address of a gambler, used to pay out winning bets.\r\n        address payable gambler;\r\n        // Status of bet settlement.\r\n        bool isSettled;\r\n        // Outcome of bet.\r\n        uint outcome;\r\n        // Win amount.\r\n        uint winAmount;\r\n        // Final Win amount.\r\n        uint finalWinAmount;\r\n        // Random number used to settle bet.\r\n        uint randomNumber;\r\n        // Keccak256 hash of some secret \"reveal\" random number.\r\n        uint commit;\r\n        // Comparison method.\r\n        bool isLarger;\r\n    }\r\n    \r\n    // Each bet is deducted dynamic\r\n    uint public houseEdgePercent = 2;\r\n\r\n    // Mapping from commits to all currently active & processed bets.\r\n    mapping (uint => Bet) public bets;\r\n\r\n    // Events\r\n    event BetPlaced(address indexed gambler, uint amount, uint8 indexed modulo, uint8 rollEdge, uint40 mask, uint commit, bool isLarger);\r\n    event BetSettled(address indexed gambler, uint amount, uint8 indexed modulo, uint8 rollEdge, uint40 mask, uint outcome, uint winAmount, uint finalWinAmount);\r\n    event BetRefunded(address indexed gambler, uint amount);\r\n\r\n    // Fallback payable function used to top up the bank roll.\r\n    fallback() external payable {\r\n        cumulativeDeposit += msg.value;\r\n    }\r\n    receive() external payable {\r\n        cumulativeDeposit += msg.value;\r\n    }\r\n\r\n    // See ETH balance.\r\n    function getBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // Set minimum larger comparison value.\r\n    function setMinOverValue(uint value) external onlyOwner {\r\n        minOverValue = value;\r\n    }\r\n\r\n    // Set maximum smaller comparison value.\r\n    function setMaxUnderValue(uint value) external onlyOwner {\r\n        maxUnderValue = value;\r\n    }\r\n    \r\n    // Set min house edge percent\r\n    function setHouseEdgePercent(uint _houseEdgePercent) external onlyOwner {\r\n        require ( _houseEdgePercent >= 1 && _houseEdgePercent <= 100, \"houseEdgePercent must be a sane number\");\r\n        houseEdgePercent = _houseEdgePercent;\r\n    }\r\n\r\n    // Set min bet amount. minBetAmount should be large enough such that its house edge fee can cover the Chainlink oracle fee.\r\n    function setMinBetAmount(uint _minBetAmount) external onlyOwner {\r\n        minBetAmount = _minBetAmount * 1 gwei;\r\n    }\r\n\r\n    // Set max bet amount.\r\n    function setMaxBetAmount(uint _maxBetAmount) external onlyOwner {\r\n        require (_maxBetAmount < 5000000 ether, \"maxBetAmount must be a sane number\");\r\n        maxBetAmount = _maxBetAmount;\r\n    }\r\n\r\n    // Set max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint _maxProfit) external onlyOwner {\r\n        require (_maxProfit < 50000000 ether, \"maxProfit must be a sane number\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    // Set wealth tax percentage to be added to house edge percent. Setting this to zero effectively disables wealth tax.\r\n    function setWealthTaxIncrementPercent(uint _wealthTaxIncrementPercent) external onlyOwner {\r\n        wealthTaxIncrementPercent = _wealthTaxIncrementPercent;\r\n    }\r\n\r\n    // Set threshold to trigger wealth tax.\r\n    function setWealthTaxIncrementThreshold(uint _wealthTaxIncrementThreshold) external onlyOwner {\r\n        wealthTaxIncrementThreshold = _wealthTaxIncrementThreshold;\r\n    }\r\n\r\n    // Owner can withdraw funds not exceeding balance minus potential win prizes by open bets\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Withdrawal amount larger than balance.\");\r\n        require (withdrawAmount <= address(this).balance - lockedInBets, \"Withdrawal amount larger than balance minus lockedInBets\");\r\n        beneficiary.transfer(withdrawAmount);\r\n        cumulativeWithdrawal += withdrawAmount;\r\n    }\r\n\r\n    function emitBetPlacedEvent(address gambler, uint amount, uint8 modulo, uint8 rollEdge, uint40 mask, uint commit, bool isLarger) private\r\n    {\r\n        // Record bet in event logs\r\n        emit BetPlaced(gambler, amount, uint8(modulo), uint8(rollEdge), uint40(mask), commit, isLarger);\r\n    }\r\n\r\n    // Place bet\r\n    function placeBet(uint betMask, uint modulo, uint commitLastBlock, uint commit, bool isLarger, bytes32 r, bytes32 s) external payable nonReentrant {\r\n\r\n        Bet storage bet = bets[commit];\r\n        require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        uint amount = msg.value;\r\n\r\n        validateArguments(amount, betMask, modulo, commitLastBlock, commit, isLarger, r, s);\r\n\r\n        uint rollEdge;\r\n        uint mask;\r\n\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            // Small modulo games can specify exact bet outcomes via bit mask.\r\n            // rollEdge is a number of 1 bits in this mask (population count).\r\n            // This magic looking formula is an efficient way to compute population\r\n            // count on EVM for numbers below 2**40. \r\n            rollEdge = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n            mask = betMask;\r\n        } else {\r\n            // Larger modulos games specify the right edge of half-open interval of winning bet outcomes.\r\n            require (betMask > 0 && betMask <= modulo, \"High modulo range, betMask larger than modulo.\");\r\n            rollEdge = betMask;\r\n        }\r\n\r\n        // Winning amount.\r\n        uint possibleWinAmount = getDiceWinAmount(amount, modulo, rollEdge, isLarger);\r\n\r\n        // Enforce max profit limit. Bet will not be placed if condition is not met.\r\n        require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation.\");\r\n\r\n        // Check whether contract has enough funds to accept this bet.\r\n        require (lockedInBets + possibleWinAmount <= address(this).balance, \"Unable to accept bet due to insufficient funds\");\r\n\r\n        // Update lock funds.\r\n        lockedInBets += possibleWinAmount;\r\n\r\n        // Store bet\r\n        bet.item.amount=amount;\r\n        bet.item.modulo=uint8(modulo);\r\n        bet.rollEdge=uint8(rollEdge);\r\n        bet.mask=uint40(mask);\r\n        bet.placeBlockNumber=block.number;\r\n        bet.gambler=payable(msg.sender);\r\n        bet.isSettled=false;\r\n        bet.outcome=0;\r\n        bet.winAmount=0;\r\n        bet.finalWinAmount=0;\r\n        bet.randomNumber=0;\r\n        bet.commit=commit;\r\n        bet.isLarger=isLarger;\r\n\r\n        // Record bet in event logs\r\n        emitBetPlacedEvent(bet.gambler, amount, uint8(modulo), uint8(rollEdge), uint40(mask), commit, isLarger);\r\n    }\r\n\r\n    // Get the expected win amount after house edge is subtracted.\r\n    function getDiceWinAmount(uint amount, uint modulo, uint rollEdge, bool isLarger) private view returns (uint winAmount) {\r\n        require (0 < rollEdge && rollEdge <= modulo, \"Win probability out of range.\");\r\n        uint houseEdge = amount * (houseEdgePercent + getWealthTax(amount)) / 100;\r\n        uint realRollEdge = rollEdge;\r\n        if (modulo == MAX_MODULO && isLarger) {\r\n            realRollEdge = MAX_MODULO - rollEdge;\r\n        }\r\n        winAmount = (amount - houseEdge) * modulo / realRollEdge;\r\n\r\n        uint maxWinAmount = amount + maxProfit;\r\n\r\n        if(winAmount > maxWinAmount) {\r\n            winAmount = maxWinAmount;\r\n        }\r\n    }\r\n\r\n    // Get wealth tax \r\n    function getWealthTax(uint amount) private view returns (uint wealthTax) {\r\n        wealthTax = amount / wealthTaxIncrementThreshold * wealthTaxIncrementPercent;\r\n    }\r\n    \r\n    // This is the method used to settle 99% of bets. To process a bet with a specific\r\n    // \"commit\", settleBet should supply a \"reveal\" number that would Keccak256-hash to\r\n    // \"commit\". \"transactionHash\" is the block hash of placeBet block as seen by croupier; it\r\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\r\n    function settleBet(uint reveal, bytes32 transactionHash, uint finalWinAmount) external onlyOwner {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require (bet.gambler != address(0), \"Bet should be in a 'bet' state.\");\r\n\r\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\r\n        require (block.number >= placeBlockNumber, \"settleBet before placeBet\");\r\n\r\n        // Set final win amount\r\n        bet.finalWinAmount = finalWinAmount;\r\n\r\n        // Settle bet using reveal and blockHash as entropy sources.\r\n        settleBetCommon(bet, reveal, transactionHash);\r\n    }\r\n\r\n    // This method is used to settle a bet that was mined into an uncle block. At this\r\n    // point the player was shown some bet outcome, but the blockhash at placeBet height\r\n    // is different because of Ethereum chain reorg. We supply a full merkle proof of the\r\n    // placeBet transaction receipt to provide untamperable evidence that uncle block hash\r\n    // indeed was present on-chain at some point.\r\n    function settleBetUncleMerkleProof(uint reveal, uint40 canonicalBlockNumber) external onlyOwner {\r\n        // \"commit\" for bet settlement can only be obtained by hashing a \"reveal\".\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n\r\n        // Check that canonical block hash can still be verified.\r\n        require (block.number <= canonicalBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        // Verify placeBet receipt.\r\n        requireCorrectReceipt(4 + 32 + 32 + 4);\r\n\r\n        // Reconstruct canonical & uncle block hashes from a receipt merkle proof, verify them.\r\n        bytes32 canonicalHash;\r\n        bytes32 uncleHash;\r\n        (canonicalHash, uncleHash) = verifyMerkleProof(commit, 4 + 32 + 32);\r\n        require (blockhash(canonicalBlockNumber) == canonicalHash);\r\n\r\n        // Settle bet using reveal and uncleHash as entropy sources.\r\n        settleBetCommon(bet, reveal, uncleHash);\r\n    }\r\n\r\n    // Common settlement code for settleBet & settleBetUncleMerkleProof.\r\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) private {\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint amount = bet.item.amount;\r\n        \r\n        // Validation check\r\n        require (amount > 0, \"Bet does not exist.\"); // Check that bet exists\r\n        require(bet.isSettled == false, \"Bet is settled already\"); // Check that bet is not settled yet\r\n\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint modulo = bet.item.modulo;\r\n        uint rollEdge = bet.rollEdge;\r\n        address payable gambler = bet.gambler;\r\n        bool isLarger = bet.isLarger;\r\n        \r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n        uint outcome = uint(entropy) % modulo;\r\n\r\n        // Win amount if gambler wins this bet\r\n        uint possibleWinAmount = getDiceWinAmount(amount, modulo, rollEdge, isLarger);\r\n\r\n        // Actual win amount by gambler\r\n        uint winAmount = 0;\r\n\r\n        // Determine dice outcome.\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            // For small modulo games, check the outcome against a bit mask.\r\n            if ((2 ** outcome) & bet.mask != 0) {\r\n                winAmount = possibleWinAmount;\r\n            }\r\n        } else {\r\n            // For larger modulos, check inclusion into half-open interval.\r\n            if (isLarger){\r\n                if (outcome > rollEdge) {\r\n                    winAmount = possibleWinAmount;\r\n                }\r\n            }\r\n            else{\r\n                if (outcome < rollEdge) {\r\n                    winAmount = possibleWinAmount;\r\n                }\r\n            }\r\n            \r\n        }\r\n\r\n        // Unlock possibleWinAmount from lockedInBets, regardless of the outcome.\r\n        lockedInBets -= possibleWinAmount;\r\n\r\n        // Update bet records\r\n        bet.isSettled = true;\r\n        bet.winAmount = winAmount;\r\n        bet.randomNumber = uint(entropy);\r\n        bet.outcome = outcome;\r\n\r\n        if (bet.finalWinAmount == 0 || bet.finalWinAmount > bet.winAmount)\r\n        {\r\n            bet.finalWinAmount = winAmount;\r\n        }\r\n\r\n        // Send win amount to gambler.\r\n        if (bet.finalWinAmount > 0) {\r\n            gambler.transfer(bet.finalWinAmount);\r\n        }\r\n\r\n        emitSettledEvent(bet);\r\n    }\r\n\r\n    function emitSettledEvent(Bet storage bet) private\r\n    {\r\n        uint amount = bet.item.amount;\r\n        uint outcome = bet.outcome;\r\n        uint winAmount = bet.winAmount;\r\n        uint finalWinAmount = bet.finalWinAmount;\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint modulo = bet.item.modulo;\r\n        uint rollEdge = bet.rollEdge;\r\n        address payable gambler = bet.gambler;\r\n        // Record bet settlement in event log.\r\n        emit BetSettled(gambler, amount, uint8(modulo), uint8(rollEdge), bet.mask, outcome, winAmount, finalWinAmount);\r\n    }\r\n\r\n    // Return the bet in extremely unlikely scenario it was not settled by Chainlink VRF. \r\n    // In case you ever find yourself in a situation like this, just contact hashbet support.\r\n    // However, nothing precludes you from calling this method yourself.\r\n    function refundBet(uint commit) external nonReentrant payable {\r\n        \r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.item.amount;\r\n        bool isLarger = bet.isLarger;\r\n\r\n        // Validation check\r\n        require (amount > 0, \"Bet does not exist.\"); // Check that bet exists\r\n        require (bet.isSettled == false, \"Bet is settled already.\"); // Check that bet is still open\r\n        require (block.number > bet.placeBlockNumber + 43200, \"Wait after placing bet before requesting refund.\");\r\n\r\n        uint possibleWinAmount = getDiceWinAmount(amount, bet.item.modulo, bet.rollEdge, isLarger);\r\n\r\n        // Unlock possibleWinAmount from lockedInBets, regardless of the outcome.\r\n        lockedInBets -= possibleWinAmount;\r\n\r\n        // Update bet records\r\n        bet.isSettled = true;\r\n        bet.winAmount = amount;\r\n\r\n        // Send the refund.\r\n        bet.gambler.transfer(amount);\r\n\r\n        // Record refund in event logs\r\n        emit BetRefunded(bet.gambler, amount);\r\n    }\r\n\r\n    // This helpers are used to verify cryptographic proofs of placeBet inclusion into\r\n    // uncle blocks. They are used to prevent bet outcome changing on Ethereum reorgs without\r\n    // compromising the security of the smart contract. Proof data is appended to the input data\r\n    // in a simple prefix length format and does not adhere to the ABI.\r\n    // Invariants checked:\r\n    //  - receipt trie entry contains a (1) successful transaction (2) directed at this smart\r\n    //    contract (3) containing commit as a payload.\r\n    //  - receipt trie entry is a part of a valid merkle proof of a block header\r\n    //  - the block header is a part of uncle list of some block on canonical chain\r\n    // The implementation is optimized for gas cost and relies on the specifics of Ethereum internal data structures.\r\n    // Read the whitepaper for details.\r\n\r\n    // Helper to verify a full merkle proof starting from some seedHash (usually commit). \"offset\" is the location of the proof\r\n    // beginning in the calldata.\r\n    function verifyMerkleProof(uint seedHash, uint offset) pure private returns (bytes32 blockHash, bytes32 uncleHash) {\r\n        // (Safe) assumption - nobody will write into RAM during this method invocation.\r\n        uint scratchBuf1;  assembly { scratchBuf1 := mload(0x40) }\r\n\r\n        uint uncleHeaderLength; uint blobLength; uint shift; uint hashSlot;\r\n\r\n        // Verify merkle proofs up to uncle block header. Calldata layout is:\r\n        //  - 2 byte big-endian slice length\r\n        //  - 2 byte big-endian offset to the beginning of previous slice hash within the current slice (should be zeroed)\r\n        //  - followed by the current slice verbatim\r\n        for (;; offset += blobLength) {\r\n            assembly { blobLength := and(calldataload(sub(offset, 30)), 0xffff) }\r\n            if (blobLength == 0) {\r\n                // Zero slice length marks the end of uncle proof.\r\n                break;\r\n            }\r\n\r\n            assembly { shift := and(calldataload(sub(offset, 28)), 0xffff) }\r\n            require (shift + 32 <= blobLength, \"Shift bounds check.\");\r\n\r\n            offset += 4;\r\n            assembly { hashSlot := calldataload(add(offset, shift)) }\r\n            require (hashSlot == 0, \"Non-empty hash slot.\");\r\n\r\n            assembly {\r\n                calldatacopy(scratchBuf1, offset, blobLength)\r\n                mstore(add(scratchBuf1, shift), seedHash)\r\n                seedHash := keccak256(scratchBuf1, blobLength)\r\n                uncleHeaderLength := blobLength\r\n            }\r\n        }\r\n\r\n        // At this moment the uncle hash is known.\r\n        uncleHash = bytes32(seedHash);\r\n\r\n        // Construct the uncle list of a canonical block.\r\n        uint scratchBuf2 = scratchBuf1 + uncleHeaderLength;\r\n        uint unclesLength; assembly { unclesLength := and(calldataload(sub(offset, 28)), 0xffff) }\r\n        uint unclesShift;  assembly { unclesShift := and(calldataload(sub(offset, 26)), 0xffff) }\r\n        require (unclesShift + uncleHeaderLength <= unclesLength, \"Shift bounds check.\");\r\n\r\n        offset += 6;\r\n        assembly { calldatacopy(scratchBuf2, offset, unclesLength) }\r\n        memcpy(scratchBuf2 + unclesShift, scratchBuf1, uncleHeaderLength);\r\n\r\n        assembly { seedHash := keccak256(scratchBuf2, unclesLength) }\r\n\r\n        offset += unclesLength;\r\n\r\n        // Verify the canonical block header using the computed sha3Uncles.\r\n        assembly {\r\n            blobLength := and(calldataload(sub(offset, 30)), 0xffff)\r\n            shift := and(calldataload(sub(offset, 28)), 0xffff)\r\n        }\r\n        require (shift + 32 <= blobLength, \"Shift bounds check.\");\r\n\r\n        offset += 4;\r\n        assembly { hashSlot := calldataload(add(offset, shift)) }\r\n        require (hashSlot == 0, \"Non-empty hash slot.\");\r\n\r\n        assembly {\r\n            calldatacopy(scratchBuf1, offset, blobLength)\r\n            mstore(add(scratchBuf1, shift), seedHash)\r\n\r\n            // At this moment the canonical block hash is known.\r\n            blockHash := keccak256(scratchBuf1, blobLength)\r\n        }\r\n    }\r\n\r\n\r\n    // Helper to check the placeBet receipt. \"offset\" is the location of the proof beginning in the calldata.\r\n    // RLP layout: [triePath, str([status, cumGasUsed, bloomFilter, [[address, [topics], data]])]\r\n    function requireCorrectReceipt(uint offset) view private {\r\n        uint leafHeaderByte; assembly { leafHeaderByte := byte(0, calldataload(offset)) }\r\n\r\n        require (leafHeaderByte >= 0xf7, \"Receipt leaf longer than 55 bytes.\");\r\n        offset += leafHeaderByte - 0xf6;\r\n\r\n        uint pathHeaderByte; assembly { pathHeaderByte := byte(0, calldataload(offset)) }\r\n\r\n        if (pathHeaderByte <= 0x7f) {\r\n            offset += 1;\r\n\r\n        } else {\r\n            require (pathHeaderByte >= 0x80 && pathHeaderByte <= 0xb7, \"Path is an RLP string.\");\r\n            offset += pathHeaderByte - 0x7f;\r\n        }\r\n\r\n        uint receiptStringHeaderByte; assembly { receiptStringHeaderByte := byte(0, calldataload(offset)) }\r\n        require (receiptStringHeaderByte == 0xb9, \"Receipt string is always at least 256 bytes long, but less than 64k.\");\r\n        offset += 3;\r\n\r\n        uint receiptHeaderByte; assembly { receiptHeaderByte := byte(0, calldataload(offset)) }\r\n        require (receiptHeaderByte == 0xf9, \"Receipt is always at least 256 bytes long, but less than 64k.\");\r\n        offset += 3;\r\n\r\n        uint statusByte; assembly { statusByte := byte(0, calldataload(offset)) }\r\n        require (statusByte == 0x1, \"Status should be success.\");\r\n        offset += 1;\r\n\r\n        uint cumGasHeaderByte; assembly { cumGasHeaderByte := byte(0, calldataload(offset)) }\r\n        if (cumGasHeaderByte <= 0x7f) {\r\n            offset += 1;\r\n\r\n        } else {\r\n            require (cumGasHeaderByte >= 0x80 && cumGasHeaderByte <= 0xb7, \"Cumulative gas is an RLP string.\");\r\n            offset += cumGasHeaderByte - 0x7f;\r\n        }\r\n\r\n        uint bloomHeaderByte; assembly { bloomHeaderByte := byte(0, calldataload(offset)) }\r\n        require (bloomHeaderByte == 0xb9, \"Bloom filter is always 256 bytes long.\");\r\n        offset += 256 + 3;\r\n\r\n        uint logsListHeaderByte; assembly { logsListHeaderByte := byte(0, calldataload(offset)) }\r\n        require (logsListHeaderByte == 0xf8, \"Logs list is less than 256 bytes long.\");\r\n        offset += 2;\r\n\r\n        uint logEntryHeaderByte; assembly { logEntryHeaderByte := byte(0, calldataload(offset)) }\r\n        require (logEntryHeaderByte == 0xf8, \"Log entry is less than 256 bytes long.\");\r\n        offset += 2;\r\n\r\n        uint addressHeaderByte; assembly { addressHeaderByte := byte(0, calldataload(offset)) }\r\n        require (addressHeaderByte == 0x94, \"Address is 20 bytes long.\");\r\n\r\n        uint logAddress; assembly { logAddress := and(calldataload(sub(offset, 11)), 0xffffffffffffffffffffffffffffffffffffffff) }\r\n        require (logAddress == uint(uint160(address(this))));\r\n    }\r\n\r\n    // Memory copy.\r\n    function memcpy(uint dest, uint src, uint len) pure private {\r\n        // Full 32 byte words\r\n        for(; len >= 32; len -= 32) {\r\n            assembly { mstore(dest, mload(src)) }\r\n            dest += 32; src += 32;\r\n        }\r\n\r\n        // Remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    // Check arguments\r\n    function validateArguments(uint amount, uint betMask, uint modulo, uint commitLastBlock, uint commit, bool isLarger, bytes32 r, bytes32 s) view private {\r\n        // Validate input data.\r\n        require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        require (amount >= minBetAmount && amount <= maxBetAmount, \"Bet amount should be within range.\");\r\n        require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n        \r\n        // Check that commit is valid - it has not expired and its signature is valid.\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(betMask, modulo, commitLastBlock, commit, isLarger));\r\n        require (owner() == ecrecover(signatureHash, 27, r, s), \"ECDSA signature is not valid.\");\r\n\r\n        if (modulo > MAX_MASK_MODULO) {\r\n            if (isLarger){\r\n                require (betMask >= minOverValue && betMask <= modulo, \"High modulo range, betMask must larger than minimum larger comparison value.\");\r\n            }\r\n            else{\r\n                require (betMask > 0 && betMask <= maxUnderValue, \"High modulo range, betMask must smaller than maximum smaller comparison value.\");\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"modulo\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rollEdge\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"mask\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLarger\",\"type\":\"bool\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"modulo\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rollEdge\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"mask\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalWinAmount\",\"type\":\"uint256\"}],\"name\":\"BetSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"modulo\",\"type\":\"uint8\"}],\"internalType\":\"struct HashBet.BetItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"rollEdge\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"mask\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"placeBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"gambler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalWinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLarger\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cumulativeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cumulativeWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"houseEdgePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnderValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOverValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betMask\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"modulo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLarger\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_houseEdgePercent\",\"type\":\"uint256\"}],\"name\":\"setHouseEdgePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBetAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxUnderValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBetAmount\",\"type\":\"uint256\"}],\"name\":\"setMinBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinOverValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wealthTaxIncrementPercent\",\"type\":\"uint256\"}],\"name\":\"setWealthTaxIncrementPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wealthTaxIncrementThreshold\",\"type\":\"uint256\"}],\"name\":\"setWealthTaxIncrementThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reveal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"finalWinAmount\",\"type\":\"uint256\"}],\"name\":\"settleBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reveal\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"canonicalBlockNumber\",\"type\":\"uint40\"}],\"name\":\"settleBetUncleMerkleProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wealthTaxIncrementPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wealthTaxIncrementThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HashBet", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://209146505a33f37184ebe6312ec5cd3770a8875735c5c0e052f5aee7126a4757"}