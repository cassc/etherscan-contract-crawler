{"SourceCode": "{\"fd.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Libraries.sol\\\";\\r\\n\\r\\ncontract FD is Ownable, IBEP20 {\\r\\n    uint256 private constant _initialSupply = 10000000000 * 10 ** 9; // 10B\\r\\n    \\r\\n    /* Trading */\\r\\n    address private _oneTimeExcluded;\\r\\n    uint256 private _antiBotTimer;\\r\\n    bool private _canTrade;\\r\\n\\r\\n    /* SwapAndLiquify */\\r\\n    bool private _isWithdrawing;\\r\\n    uint16 public swapThreshold;\\r\\n    bool public remove20PercentEnabled;\\r\\n    bool private _isSwappingContractModifier;\\r\\n    bool public swapAndLiquifyDisabled;\\r\\n    bool private _addingLiquidity;\\r\\n    bool private _removingLiquidity;\\r\\n    uint256 private _liquidityUnlockTime;\\r\\n    \\r\\n    /* Reward Distribution */ \\r\\n    uint256 private _profitPerToken;\\r\\n    uint256 private _totalTokensHeld;\\r\\n    \\r\\n    /* Contract BNB Trackers */\\r\\n    uint256 private _totalLiquidityBNB;\\r\\n    uint256 private _totalMarketingBNB;\\r\\n    uint256 private _totalRewardsBNB;\\r\\n    uint256 private _totalRewardBNBPaid;\\r\\n    \\r\\n    /* Sell Delay \\u0026 Token Vesting (Locking) */\\r\\n    uint256 private _maxSellDelay = 1 hours;\\r\\n    uint256 private _sellDelay = 0;\\r\\n    \\r\\n    // Primary \\u0026 Secondary Taxes.  \\r\\n    uint8 private constant _maxTax = 50;\\r\\n    uint8 private _buyTax = 15;\\r\\n    uint8 private _sellTax = 15;\\r\\n    \\r\\n    // Applied on sell tx. \\r\\n    uint8 private _burnTax = 1;\\r\\n    uint8 private _marketingTax = 20;\\r\\n    uint8 private _liquidityTax = 15;\\r\\n    uint8 private _rewardsTax = 65;\\r\\n    uint8 private constant _totalTax = 100;\\r\\n    \\r\\n    /* Balance \\u0026 Sell Limits */\\r\\n    uint256 private _maxWalletSize = _initialSupply; \\r\\n    uint256 private _maxSellSize = _initialSupply; \\r\\n    \\r\\n    /* Burn Mechanism */\\r\\n    uint256 private _totalTokensBurned;\\r\\n    uint256 private _tokensToBurn;\\r\\n    \\r\\n    /* PancakeSwap */\\r\\n    IPancakeRouter02 private _pancakeRouter;\\r\\n    address public _pancakeRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    address public _pancakePairAddress;\\r\\n    \\r\\n    /* Team Wallet */\\r\\n    address public teamWallet = 0x1dcE9145721Da58CE01FE14FABcAB2dcE2611375;\\r\\n    address public burnWallet = 0x000000000000000000000000000000000000dEaD;\\r\\n    \\r\\n    /* Promotional Token */\\r\\n    address public promoToken;\\r\\n    address public farmToken;\\r\\n    uint256 private _minHoldForBonus;\\r\\n    bool private promoTokenEnabled;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n    mapping(address =\\u003e bool) private _automatedMarketMakers;\\r\\n    mapping(address =\\u003e Holder) private _holders;\\r\\n    \\r\\n    /* Private Sale */\\r\\n    mapping(address =\\u003e bool) private _vestors;\\r\\n    mapping(address =\\u003e uint256) private _unvested;\\r\\n    uint256 private _privateSaleVestTime;\\r\\n    uint256 private _privateSaleVestRate = 1000000 * 10 ** 9;\\r\\n\\r\\n    struct Holder {\\r\\n        // Used for sell delay \\u0026 token vesting (locking)\\r\\n        uint256 nextSell;\\r\\n        uint256 rewardsPaid;\\r\\n        uint256 rewardsToBePaid;\\r\\n        bool excludeFromFees;\\r\\n        bool excludeFromRewards;\\r\\n    }\\r\\n    \\r\\n    event OwnerCreateLP(uint8 teamPercent, uint8 contractPercent);\\r\\n    event TeamBurnContractTokens(uint256 toBurn);\\r\\n    event TeamRemoveLiquidity(uint8 percent, bool rewardBoost);\\r\\n    event TeamChangeTaxes(uint8 buyTax, uint8 sellTax, uint8 burnTax, uint8 marketingTax, uint8 rewardsTax, uint8 liquidityTax);\\r\\n    event TeamChangeLimits(uint256 maxWalletSize, uint256 maxSellSize);\\r\\n    event TeamSwapContractTokens(uint16 swapThreshold, bool ignoreLimits);\\r\\n    event TeamBoostContract(bool rewardBoost, uint256 amountWei);\\r\\n    event TeamChangeSellDelay(uint256 sellDelay);\\r\\n    event TeamExtendLPLock(uint256 timeSeconds);\\r\\n    event TeamUpdateAMM(address indexed AMMAdress, bool enabled);\\r\\n    event TeamUpdateSwapThreshold(uint16 swapThreshold);\\r\\n    event TeamSwitchSwapAndLiquify(bool disabled);\\r\\n    event TeamTriggerBuyBack(uint256 amountWei);\\r\\n    event TeamSetFarmToken(address indexed farmToken);\\r\\n    event TeamSetPromoToken(address indexed promoToken, uint256 _minHoldForBonus, bool promoTokenEnabled);\\r\\n    event ClaimBNBTo(address indexed from, address indexed recipient, uint256 amountWei);\\r\\n    event Compound(address indexed recipient, uint256 amountTokens);\\r\\n    event ClaimPromoToken(address indexed recipient, uint256 amountTokens);\\r\\n    event TeamSwitch20PercentEnabled(bool enabled);\\r\\n    event LockExternalTeamTokens(address indexed _teamWallet);\\r\\n    event TeamChangeWallet(address indexed newWallet);\\r\\n    modifier lockTheSwap {\\r\\n        _isSwappingContractModifier = true;\\r\\n        _;\\r\\n        _isSwappingContractModifier = false;\\r\\n    }\\r\\n    modifier onlyTeam {\\r\\n        require(msg.sender == teamWallet);\\r\\n        _;\\r\\n    }\\r\\n    constructor() {\\r\\n        // Mint initial supply to contract\\r\\n        _updateBalance(address(this), _initialSupply);\\r\\n        emit Transfer(address(0), address(this), _initialSupply);\\r\\n        // Init \\u0026 approve PCSR\\r\\n        _pancakeRouter = IPancakeRouter02(_pancakeRouterAddress);\\r\\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\r\\n        _automatedMarketMakers[_pancakePairAddress] = true;\\r\\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);\\r\\n        // Exclude from fees \\u0026 rewards\\r\\n        _holders[msg.sender].excludeFromFees = true;\\r\\n        _holders[address(this)].excludeFromFees = true;\\r\\n        _holders[address(this)].excludeFromRewards = true;\\r\\n        _holders[_pancakePairAddress].excludeFromRewards = true;\\r\\n        _privateSaleVestTime = block.timestamp + 9 weeks;\\r\\n    }\\r\\n///////////////////////////////////////////\\r\\n// Transfer Functions\\r\\n///////////////////////////////////////////\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n        require(sender != address(0) \\u0026\\u0026 recipient != address(0), \\\"Cannot be zero address.\\\");\\r\\n        bool isBuy = _automatedMarketMakers[sender];\\r\\n        bool isSell = _automatedMarketMakers[recipient];\\r\\n        bool isExcluded = _holders[sender].excludeFromFees || _holders[recipient].excludeFromFees || \\r\\n            _addingLiquidity || _removingLiquidity||_oneTimeExcluded==sender||_oneTimeExcluded==recipient;\\r\\n        if (isExcluded) {\\r\\n            _transferExcluded(sender, recipient, amount);\\r\\n            _oneTimeExcluded = address(0);\\r\\n        } else {\\r\\n            // Trading can only be enabled once\\r\\n            require(_canTrade, \\\"Trading isn\\u0027t enabled.\\\");\\r\\n            if (isBuy) _buyTokens(recipient, amount);\\r\\n            else if (isSell) _sellTokens(sender, amount);\\r\\n            else if (sender == recipient) _claimBNBTo(sender, recipient);\\r\\n            else {\\r\\n                // Team Wallet cannot transfer tokens until lock has expired\\r\\n                if (sender == teamWallet) require(block.timestamp \\u003e= _holders[teamWallet].nextSell);\\r\\n                require(_balances[recipient] + amount \\u003c= _maxWalletSize);\\r\\n                _transferExcluded(sender, recipient, amount);\\r\\n                // Recipient will incurr sell delay to prevent pump \\u0026 dump\\r\\n                _holders[recipient].nextSell = block.timestamp + _sellDelay;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _buyTokens(address recipient, uint256 amount) private {\\r\\n        if (block.timestamp \\u003c _antiBotTimer) {\\r\\n            // 5 % of tokens will be stored in burn vault (contract)\\r\\n            _tokensToBurn += amount * 5 * 100 / 1000;\\r\\n            // 100 % of tokens sent to contract, 95 % for LP\\r\\n            _transferExcluded(_pancakePairAddress, address(this), amount);\\r\\n        } else {\\r\\n            // Team wallet cannot buy tokens until lock is over.\\r\\n            if (recipient == teamWallet) require(block.timestamp \\u003e= _holders[teamWallet].nextSell);\\r\\n            // Balance + amount cannot exceed 1 % of circulating supply (_maxWalletSize)\\r\\n            require(_balances[recipient] + amount \\u003c= _maxWalletSize);\\r\\n            // Amount of tokens to be sent to contract\\r\\n            uint256 taxedTokens = amount * _buyTax * 100 / 10000;\\r\\n            _transferIncluded(_pancakePairAddress, recipient, amount, taxedTokens);\\r\\n            _totalTokensHeld += amount - taxedTokens;\\r\\n            // Reset sell delay\\r\\n            _holders[recipient].nextSell = block.timestamp + _sellDelay;\\r\\n        }\\r\\n    }\\r\\n    function _sellTokens(address sender, uint256 amount) private {\\r\\n        // Cannot sell before nextSell\\r\\n        require(block.timestamp \\u003e= _holders[sender].nextSell);\\r\\n        require(amount \\u003c= _maxSellSize \\u0026\\u0026 amount \\u003c= _balances[sender]);\\r\\n        // Private wallets\\r\\n        if (_vestors[sender])\\r\\n        {\\r\\n            uint256 vestDate = _privateSaleVestTime;\\r\\n            require(block.timestamp \\u003e vestDate);\\r\\n            uint256 timeVested = block.timestamp - vestDate;\\r\\n            uint256 oneWeek = 1 weeks;\\r\\n            uint256 vested = (timeVested / oneWeek) * _privateSaleVestRate;\\r\\n            uint256 unvested = 0;\\r\\n            if (vested \\u003e _unvested[sender])\\r\\n            {\\r\\n                _vestors[sender] = false;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                unvested = _unvested[sender] - vested;\\r\\n            }\\r\\n            uint256 availableBalance = _balances[sender] - unvested;\\r\\n            require(amount \\u003e= availableBalance);\\r\\n        }\\r\\n        // Amount of tokens to be sent to contract\\r\\n        uint256 taxedTokens = amount * _sellTax * 100 / 10000;\\r\\n        // Tokens to burn are stored in contract for scheduled burn\\r\\n        _tokensToBurn += taxedTokens * _burnTax * 100 / 10000;\\r\\n        _transferIncluded(sender, _pancakePairAddress, amount, taxedTokens);\\r\\n        _totalTokensHeld -= amount;\\r\\n        // Reset sell delay\\r\\n        _holders[sender].nextSell = block.timestamp + _sellDelay;\\r\\n    }\\r\\n    function _transferIncluded(address sender, address recipient, uint256 amount, uint256 taxedTokens) private {\\r\\n        uint256 newAmount = amount - taxedTokens;\\r\\n        _updateBalance(sender, _balances[sender] - amount);\\r\\n        // Taxed tokens are sent to contract, including \\u0027_toBeBurned\\u0027\\r\\n        _updateBalance(address(this), _balances[address(this)] + taxedTokens);\\r\\n        _updateBalance(recipient, _balances[recipient] + newAmount);\\r\\n        emit Transfer(sender, recipient, newAmount);\\r\\n    }\\r\\n    function _transferExcluded(address sender, address recipient, uint256 amount) private {\\r\\n        _updateBalance(sender, _balances[sender] - amount);\\r\\n        _updateBalance(recipient, _balances[recipient] + amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    function _updateBalance(address account, uint256 newBalance) private {\\r\\n        // Grab any outstanding rewards before balance change\\r\\n        uint256 reward = _newRewardsOf(account);\\r\\n        _balances[account] = newBalance;\\r\\n        // If account is not exluded from rewards, reset rewards, else return\\r\\n        if (!_holders[account].excludeFromRewards) _resetRewards(account, reward);\\r\\n        else return;\\r\\n    }\\r\\n\\r\\n///////////////////////////////////////////\\r\\n// Rewards Functions\\r\\n///////////////////////////////////////////\\r\\n    function _distributeBNB(uint256 amountWei) private {\\r\\n        uint256 marketing = amountWei * _marketingTax / 100;\\r\\n        uint256 rewards = amountWei - marketing;\\r\\n        // If no tokens are held, all distributed BNB will go to marketing wallet\\r\\n        if (_totalTokensHeld == 0) _totalMarketingBNB += (marketing + rewards);\\r\\n        else {\\r\\n            _totalMarketingBNB += marketing;\\r\\n            _totalRewardsBNB += rewards;\\r\\n            _profitPerToken += (rewards * (2 ** 64)) / _totalTokensHeld;\\r\\n        }\\r\\n    }\\r\\n    function _setIncludedToRewards(address account) private {\\r\\n        require(_holders[account].excludeFromRewards);\\r\\n        _holders[account].excludeFromRewards = false;\\r\\n        _totalTokensHeld += _balances[account];\\r\\n        _resetRewards(account, 0);\\r\\n    }\\r\\n    function _deductRewards(address account, uint256 amountWei) private {\\r\\n        require(amountWei \\u003e 0 \\u0026\\u0026 amountWei \\u003c= _rewardsOf(account));\\r\\n        if (!_holders[account].excludeFromRewards) _resetRewards(account, _newRewardsOf(account));\\r\\n        _holders[account].rewardsToBePaid -= amountWei;\\r\\n    }   \\r\\n    function _resetRewards(address account, uint256 reward) private {\\r\\n        // Reset rewardsPaid offset.\\r\\n        _holders[account].rewardsPaid = _profitPerToken * _balances[account]; \\r\\n        // Add outstanding rewards to rewardsToBePaid.\\r\\n        _holders[account].rewardsToBePaid += reward;\\r\\n    }\\r\\n    function _rewardsOf(address account) private view returns (uint256) {\\r\\n        return _holders[account].excludeFromRewards ? 0 : _holders[account].rewardsToBePaid + _newRewardsOf(account);\\r\\n    }\\r\\n    function _newRewardsOf(address account) private view returns (uint256) {\\r\\n        uint256 rewards = _profitPerToken * _balances[account];\\r\\n        // If rewards are greater than rewards paid, return the difference\\r\\n        return rewards \\u003c= _holders[account].rewardsPaid ? 0 : (rewards - _holders[account].rewardsPaid) / (2 ** 64);\\r\\n    }\\r\\n    function _claimBNBTo(address from, address recipient) private {\\r\\n        uint256 totalRewards = _rewardsOf(from); \\r\\n        require(!_isWithdrawing);\\r\\n        require(totalRewards \\u003e 0);   \\r\\n        _isWithdrawing = true;\\r\\n        _deductRewards(from, totalRewards);\\r\\n        _totalRewardBNBPaid += totalRewards;\\r\\n        (bool sent,) = recipient.call{value: (totalRewards)}(\\\"\\\");\\r\\n        require(sent);\\r\\n        _isWithdrawing = false;\\r\\n        emit ClaimBNBTo(from, recipient, totalRewards);\\r\\n    }\\r\\n///////////////////////////////////////////\\r\\n// Liquidity Functions\\r\\n///////////////////////////////////////////\\r\\n    function _swapContractTokens(uint16 _swapThreshold, bool ignoreLimits) private lockTheSwap {\\r\\n        uint256 contractBalance = _balances[address(this)] - _tokensToBurn;\\r\\n        uint256 toSwap = _swapThreshold * _balances[_pancakePairAddress] / 1000;\\r\\n        toSwap = toSwap \\u003e _maxSellSize ? _maxSellSize : toSwap;\\r\\n        if (contractBalance \\u003c toSwap) {\\r\\n            if (ignoreLimits)\\r\\n                toSwap = contractBalance;\\r\\n            else return;\\r\\n        }\\r\\n        // Calculate the total tokens for LP\\r\\n        uint256 totalLiquidityTokens = toSwap * _liquidityTax / 100;\\r\\n        uint256 tokensLeft = toSwap - totalLiquidityTokens;\\r\\n        uint256 liquidityTokens = totalLiquidityTokens / 2;\\r\\n        uint256 liquidityBNBTokens = totalLiquidityTokens - liquidityTokens;\\r\\n        uint256 totalSwap = liquidityBNBTokens + tokensLeft;\\r\\n        uint256 oldBNB = address(this).balance;\\r\\n        _swapTokensForBNB(totalSwap);\\r\\n        uint256 newBNB = address(this).balance - oldBNB;\\r\\n        uint256 LPBNB = (newBNB * liquidityBNBTokens) / totalSwap;\\r\\n        _addLiquidity(liquidityTokens, LPBNB);\\r\\n        uint256 remainingBNB = address(this).balance - oldBNB;\\r\\n        _distributeBNB(remainingBNB);\\r\\n    }\\r\\n    function _addLiquidity(uint256 amountTokens, uint256 amountBNB) private {\\r\\n        _totalLiquidityBNB += amountBNB;\\r\\n        _addingLiquidity = true;\\r\\n        _pancakeRouter.addLiquidityETH{value: amountBNB}(\\r\\n            // Liquidity Tokens are sent from contract, NOT OWNER!\\r\\n            address(this),\\r\\n            amountTokens,\\r\\n            0,\\r\\n            0,\\r\\n            // contract receives CAKE-LP, NOT OWNER!\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        _addingLiquidity = false;\\r\\n    }\\r\\n    function _removeLiquidityPercent(uint8 percent) private {\\r\\n        IPancakeERC20 lpToken = IPancakeERC20(_pancakePairAddress);\\r\\n        uint256 amount = lpToken.balanceOf(address(this)) * percent / 100;\\r\\n        lpToken.approve(address(_pancakeRouter), amount);\\r\\n        _removingLiquidity = true;\\r\\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n            address(this),\\r\\n            amount,\\r\\n            0,\\r\\n            0,\\r\\n            // Receiver address\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        _removingLiquidity = false;\\r\\n    }\\r\\n    function _swapTokensForBNB(uint256 amount) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        // WBNB\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            // Receiver address\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    function _swapBNBForTokens(address recipient, address token, uint256 amountWei) private {\\r\\n        _isWithdrawing = true;\\r\\n        address[] memory path = new address[](2);\\r\\n        // WBNB\\r\\n        path[0] = _pancakeRouter.WETH();\\r\\n        path[1] = token;  \\r\\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountWei}(\\r\\n            0,\\r\\n            path,\\r\\n            recipient,\\r\\n            block.timestamp);\\r\\n        _isWithdrawing = false;\\r\\n    }\\r\\n///////////////////////////////////////////\\r\\n// Buy-Back Functions\\r\\n///////////////////////////////////////////\\r\\n    function _buyBack(uint256 amountWei) private {\\r\\n        require(!_isWithdrawing);\\r\\n        require(amountWei \\u003e 0 \\u0026\\u0026 amountWei \\u003c= _totalMarketingBNB);\\r\\n        uint256 oldBalance = _balances[address(this)]; \\r\\n        _swapBNBForTokens(address(this), address(this), amountWei);\\r\\n        // Check if tokens were actually bought\\r\\n        require(_balances[address(this)] \\u003e oldBalance);\\r\\n        // Add tokens in contract, toBeBurn\\r\\n        _tokensToBurn += _balances[address(this)] - oldBalance;\\r\\n        // Decreaste the marketing BNB\\r\\n        _totalMarketingBNB -= amountWei;\\r\\n    }\\r\\n///////////////////////////////////////////\\r\\n// Team/Owner Public Functions\\r\\n///////////////////////////////////////////\\r\\n    function ownerCreateLP(uint8 teamPercent, uint8 contractPercent) public onlyOwner {\\r\\n        require(IBEP20(_pancakePairAddress).totalSupply() == 0);\\r\\n        uint256 contractBalance = _balances[address(this)];\\r\\n        // Tokens to be reserved for the team\\r\\n        uint256 teamTokens = contractBalance * teamPercent / 100;\\r\\n        // Tokens to remain in contract\\r\\n        uint256 contractTokens = contractBalance * contractPercent / 100;\\r\\n        // Tokens to be added to the LP\\r\\n        uint256 LPTokens = contractBalance - (teamTokens + contractTokens);\\r\\n        // Team tokens sent to owner\\r\\n        _transferExcluded(address(this), msg.sender, teamTokens);\\r\\n        _addLiquidity(LPTokens, address(this).balance);\\r\\n        require(IBEP20(_pancakePairAddress).totalSupply() \\u003e 0);\\r\\n        emit OwnerCreateLP(teamPercent, contractPercent);\\r\\n    }\\r\\n    function teamEnableTrading() public onlyOwner {\\r\\n        // This function can only be called once\\r\\n        require(!_canTrade);\\r\\n        _canTrade = true; // true\\r\\n        // Liquidity is locked for 7 days\\r\\n        _liquidityUnlockTime = block.timestamp + 7 days;\\r\\n        // Team tokens are vested (locked) for 60 days\\r\\n        _holders[teamWallet].nextSell = block.timestamp + 60 days;\\r\\n        // All buys in the next 5 minutes are burned and added to LP\\r\\n        _antiBotTimer = 0;//block.timestamp;\\r\\n    }\\r\\n    // Calling this function breaks the rewards\\r\\n    function withdrawBNB() public onlyOwner {\\r\\n        // Transfers BNB in contract to owner.\\r\\n        (bool success,) = teamWallet.call{value: (address(this).balance)}(\\\"\\\");\\r\\n        require(success);\\r\\n    }\\r\\n    function lockExternalTeamTokens(address _teamWallet) public onlyOwner {\\r\\n        // Tokens cannot be locked after trading has been enabled, only before.\\r\\n        require(!_canTrade);\\r\\n        _holders[_teamWallet].nextSell = block.timestamp + 60 days;\\r\\n        _setIncludedToRewards(_teamWallet);\\r\\n        emit LockExternalTeamTokens(_teamWallet);\\r\\n    }\\r\\n    function teamBurnContractTokens(uint8 burnPercent) public onlyTeam {\\r\\n        require(_tokensToBurn \\u003e 0);\\r\\n        uint256 toBurn = _tokensToBurn * burnPercent / 100;\\r\\n        // Send _tokensToBurn to burn wallet\\r\\n        _transferExcluded(address(this), burnWallet, toBurn);\\r\\n        _totalTokensBurned += toBurn;\\r\\n        _tokensToBurn -= toBurn;\\r\\n        emit TeamBurnContractTokens(toBurn);\\r\\n    }\\r\\n    function teamRemoveLiquidityPercent(uint8 percent, bool rewardBoost) public onlyTeam {\\r\\n        // Cannot remove liquidity unless timer is over\\r\\n        require(block.timestamp \\u003e= _liquidityUnlockTime);\\r\\n        // If remove20Percent is enabled, can remove upto 20 % of LP, otherwise the lock is auto-reset\\r\\n        percent=remove20PercentEnabled?percent\\u003e20?20:percent:0;\\r\\n        _liquidityUnlockTime=block.timestamp+7 days;\\r\\n        if(percent==0)return;\\r\\n        uint256 oldBNB = address(this).balance;\\r\\n        _removeLiquidityPercent(percent);\\r\\n        uint256 newBNB = address(this).balance - oldBNB;\\r\\n        // Boost marketing, rewards\\r\\n        if (rewardBoost) _distributeBNB(newBNB);\\r\\n        // Boost only marketing BNB\\r\\n        else _totalMarketingBNB += newBNB;\\r\\n        emit TeamRemoveLiquidity(percent, rewardBoost);\\r\\n    }\\r\\n    // Incase token dies, LP can be removed.\\r\\n    function teamReleaseLiquidity() public onlyTeam {\\r\\n        // If the LP lock has not been reset for 30 days, team can remove ALL LP.\\r\\n        require(block.timestamp\\u003e=_liquidityUnlockTime+30 days);\\r\\n        uint256 oldBNB = address(this).balance;\\r\\n        // Remove 100 % of LP\\r\\n        _removeLiquidityPercent(100);\\r\\n        uint256 newBNB = address(this).balance - oldBNB;\\r\\n        _totalMarketingBNB+=newBNB;\\r\\n    }\\r\\n    function teamSwitch20PercentEnabled(bool enabled) public onlyTeam {\\r\\n        remove20PercentEnabled = enabled;\\r\\n        emit TeamSwitch20PercentEnabled(remove20PercentEnabled);\\r\\n    }\\r\\n    function teamSetPromoToken(address _promoToken, uint256 minHoldForBonus, bool enabled) public onlyTeam {\\r\\n        require(_promoToken != address(this) \\u0026\\u0026 _promoToken != _pancakePairAddress);\\r\\n        promoToken = _promoToken;\\r\\n        _minHoldForBonus = minHoldForBonus;\\r\\n        promoTokenEnabled = enabled;\\r\\n        emit TeamSetPromoToken(promoToken, _minHoldForBonus, promoTokenEnabled);\\r\\n    }\\r\\n    function teamSetFarmToken(address _farmToken) public onlyTeam {\\r\\n        require(_farmToken != address(this) \\u0026\\u0026 _farmToken != _pancakePairAddress);\\r\\n        farmToken = _farmToken;\\r\\n        emit TeamSetFarmToken(farmToken);\\r\\n    }\\r\\n    function teamTriggerBuyBack(uint256 amountWei) public onlyTeam {\\r\\n        require(!_isWithdrawing);\\r\\n        _buyBack(amountWei);\\r\\n        emit TeamTriggerBuyBack(amountWei);\\r\\n    }\\r\\n    function teamExtendLPLock(uint256 timeSeconds) public onlyTeam {\\r\\n        require(timeSeconds\\u003c=7 days);\\r\\n        _liquidityUnlockTime += timeSeconds;\\r\\n        emit TeamExtendLPLock(_liquidityUnlockTime);\\r\\n    }\\r\\n    function teamChangeTaxes(\\r\\n        uint8 buyTax,\\r\\n        uint8 sellTax,\\r\\n        uint8 burnTax,\\r\\n        uint8 marketingTax,\\r\\n        uint8 rewardsTax,\\r\\n        uint8 liquidityTax) public onlyTeam {\\r\\n            require(buyTax \\u003c= _maxTax \\u0026\\u0026 sellTax \\u003c= _maxTax \\u0026\\u0026 burnTax \\u003c= 1);\\r\\n            require((marketingTax + rewardsTax + liquidityTax) \\u003c= _totalTax);\\r\\n            _buyTax = buyTax;\\r\\n            _sellTax = sellTax;\\r\\n            _burnTax = burnTax;\\r\\n            _marketingTax = marketingTax;\\r\\n            _rewardsTax = rewardsTax;\\r\\n            _liquidityTax = liquidityTax;\\r\\n            emit TeamChangeTaxes(_buyTax, _sellTax, _burnTax, _marketingTax, _rewardsTax, _liquidityTax);\\r\\n        }\\r\\n    function teamUpdateLimits() public onlyTeam {\\r\\n        // Update to 1 % of circulating supply.\\r\\n        _maxWalletSize = _maxSellSize = (_initialSupply - _totalTokensBurned) / 100;\\r\\n        emit TeamChangeLimits(_maxWalletSize, _maxSellSize);\\r\\n    }\\r\\n    function teamTriggerSwapContractTokens(uint16 _swapThreshold, bool ignoreLimits) public onlyTeam {\\r\\n        _swapContractTokens(_swapThreshold, ignoreLimits);\\r\\n        emit TeamSwapContractTokens(swapThreshold, ignoreLimits);\\r\\n    }\\r\\n    // 0 disables sellDelay.\\r\\n    function teamChangeSellDelay(uint256 sellDelay) public onlyTeam {\\r\\n        // Cannot exceed 1 hour.\\r\\n        require(sellDelay \\u003c= _maxSellDelay);\\r\\n        _sellDelay = sellDelay;\\r\\n        emit TeamChangeSellDelay(sellDelay);\\r\\n    }\\r\\n    function teamFixStuckBNB() public onlyTeam {\\r\\n        uint256 stuckBNB = address(this).balance - (_totalMarketingBNB + _totalRewardsBNB);\\r\\n        _totalMarketingBNB += stuckBNB\\u003e0?stuckBNB:0;\\r\\n    }\\r\\n    function teamBoostContract(bool rewardBoost) public payable {\\r\\n        if (rewardBoost) _distributeBNB(msg.value);\\r\\n        else _totalMarketingBNB += msg.value;\\r\\n        emit TeamBoostContract(rewardBoost, msg.value);\\r\\n    }\\r\\n    function teamUpdateAMM(address AMMAddress, bool enabled) public onlyTeam {\\r\\n        _automatedMarketMakers[AMMAddress] = enabled;\\r\\n        _holders[AMMAddress].excludeFromRewards = true;\\r\\n        emit TeamUpdateAMM(AMMAddress, enabled);\\r\\n    }\\r\\n    function teamUpdateSwapThreshold(uint16 _swapThreshold) public onlyTeam {\\r\\n        swapThreshold=_swapThreshold\\u003e50?50:_swapThreshold;\\r\\n        emit TeamUpdateSwapThreshold(swapThreshold);\\r\\n    }\\r\\n    function teamSetExcludedFromRewards(address account, bool exclude) public onlyTeam {\\r\\n        if (exclude) {\\r\\n            require(!_holders[account].excludeFromRewards);\\r\\n            uint256 reward = _newRewardsOf(account);\\r\\n            _resetRewards(account, reward);\\r\\n            _holders[account].excludeFromRewards = true;\\r\\n        } else _setIncludedToRewards(account);\\r\\n    }\\r\\n    function teamSwitchSwapAndLiquify() public onlyOwner {\\r\\n        swapAndLiquifyDisabled = !swapAndLiquifyDisabled;\\r\\n        emit TeamSwitchSwapAndLiquify(swapAndLiquifyDisabled);\\r\\n    }\\r\\n    function TeamWithdrawStrandedToken(address strandedToken) public onlyTeam {\\r\\n        require((strandedToken!=_pancakePairAddress)\\u0026\\u0026strandedToken!=address(this)\\u0026\\u0026strandedToken!=address(promoToken));\\r\\n        IBEP20 token=IBEP20(strandedToken);\\r\\n        token.transfer(teamWallet, token.balanceOf(address(this)));\\r\\n    }\\r\\n    function teamWithdrawMarketingBNB(uint256 amountWei) public onlyTeam {\\r\\n        require(amountWei \\u003c= _totalMarketingBNB);\\r\\n        (bool success,) = teamWallet.call{value: (amountWei)}(\\\"\\\");\\r\\n        require(success);\\r\\n        _totalMarketingBNB -= amountWei;\\r\\n    }\\r\\n    function teamChangeWallet(address newWallet) public onlyTeam {\\r\\n        require(block.timestamp \\u003e= _holders[teamWallet].nextSell);\\r\\n        teamWallet = newWallet;\\r\\n        emit TeamChangeWallet(newWallet);\\r\\n    }\\r\\n    // Disable anti-snipe manually, if needed\\r\\n    function teamDisableAntiSnipe() public onlyTeam {\\r\\n        _antiBotTimer = 0;\\r\\n    }\\r\\n    function teamResetOneTimeExcluded() public onlyTeam {\\r\\n        _oneTimeExcluded = address(0);\\r\\n    }\\r\\n    function resetFlags() public onlyTeam {\\r\\n        _removingLiquidity = _addingLiquidity = _isWithdrawing = false;\\r\\n    }\\r\\n///////////////////////////////////////////\\r\\n// Public Rewards Functions\\r\\n///////////////////////////////////////////\\r\\n    function claimToken() public {\\r\\n        uint256 amountWei = _rewardsOf(msg.sender);\\r\\n        require(!_automatedMarketMakers[farmToken] \\u0026\\u0026 !_isWithdrawing \\u0026\\u0026 amountWei \\u003e 0);\\r\\n        uint256 oldBalance = IBEP20(farmToken).balanceOf(msg.sender);\\r\\n        _swapBNBForTokens(msg.sender, farmToken, amountWei);\\r\\n        uint256 newBalance = IBEP20(farmToken).balanceOf(msg.sender) - oldBalance;\\r\\n        require(newBalance \\u003e 0);\\r\\n        _deductRewards(msg.sender, amountWei);\\r\\n        _totalRewardBNBPaid += amountWei;\\r\\n        //\\r\\n    }\\r\\n    function includeMeToRewards() public {\\r\\n        _setIncludedToRewards(msg.sender);\\r\\n    }\\r\\n///////////////////////////////////////////\\r\\n// BEP-2O Functions\\r\\n///////////////////////////////////////////\\r\\n    function airdrop(address[] memory addresses, uint256[] memory amounts, bool fromContract, bool lock) external onlyOwner {\\r\\n        require(addresses.length \\u003e 0 \\u0026\\u0026 amounts.length \\u003e 0 \\u0026\\u0026 addresses.length == amounts.length);\\r\\n        address from = fromContract ? address(this) : msg.sender;\\r\\n        if (lock)\\r\\n        {\\r\\n            for (uint i = 0; i \\u003c addresses.length; i++) {\\r\\n                uint256 amount = amounts[i] * 10 ** 9; \\r\\n                _vestors[addresses[i]] = true;\\r\\n                _unvested[addresses[i]] = amount;\\r\\n                _transferExcluded(from, addresses[i], amount);\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            for (uint i = 0; i \\u003c addresses.length; i++) {\\r\\n                uint256 amount = amounts[i] * 10 ** 9; \\r\\n                _transferExcluded(from, addresses[i], amount);\\r\\n                _transferExcluded(from, addresses[i], amount);\\r\\n                }\\r\\n        }     \\r\\n    }\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require((owner != address(0) \\u0026\\u0026 spender != address(0)), \\\"Owner/Spender address cannot be 0.\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        uint256 allowance_ = _allowances[sender][msg.sender];\\r\\n        _transfer(sender, recipient, amount);\\r\\n        require(allowance_ \\u003e= amount);\\r\\n        _approve(sender, msg.sender, allowance_ - amount);\\r\\n            emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    receive() external payable {\\r\\n        require(msg.sender == _pancakeRouterAddress || msg.sender == owner() || msg.sender == teamWallet);\\r\\n    }\\r\\n    function allTaxes() external view returns (\\r\\n        uint8 buyTax, \\r\\n        uint8 sellTax, \\r\\n        uint8 burnTax, \\r\\n        uint8 marketingTax, \\r\\n        uint8 liquidityTax, \\r\\n        uint8 rewardsTax) {\\r\\n            buyTax = _buyTax;\\r\\n            sellTax = _sellTax;\\r\\n            burnTax = _burnTax;\\r\\n            marketingTax = _marketingTax;\\r\\n            liquidityTax = _liquidityTax;\\r\\n            rewardsTax = _rewardsTax;\\r\\n    }\\r\\n    function trackContractBNB() external view returns (\\r\\n        uint256 marketingBNB,\\r\\n        uint256 liquidityBNB,\\r\\n        uint256 rewardBNB) {\\r\\n            marketingBNB = _totalMarketingBNB;\\r\\n            liquidityBNB = _totalLiquidityBNB;\\r\\n            rewardBNB = _totalRewardsBNB;\\r\\n    }\\r\\n    function antiBotTimeLeft() external view returns (uint256) {\\r\\n        return _antiBotTimer\\u003eblock.timestamp?_antiBotTimer-block.timestamp:0;\\r\\n    }\\r\\n    function rewardsOf(address account) external view returns (uint256) {\\r\\n        return _rewardsOf(account);\\r\\n    }\\r\\n    function nextSellOf(address account) external view returns(uint256) {\\r\\n        return _holders[account].nextSell \\u003e block.timestamp ? _holders[account].nextSell - block.timestamp : 0;\\r\\n    }\\r\\n    function totalRewardBNBPaid() external view returns (uint256) {\\r\\n        return _totalRewardBNBPaid;\\r\\n    }\\r\\n    function totalTokensHeld() external view returns(uint256){\\r\\n        return _totalTokensHeld;\\r\\n    }\\r\\n    function totalTokensBurned() external view returns(uint256){\\r\\n        return _totalTokensBurned;\\r\\n    }\\r\\n    function tokensToBurn() external view returns(uint256){\\r\\n        return _tokensToBurn;\\r\\n    }\\r\\n    function liquidityUnlockTimeLeft() external view returns (uint256) {\\r\\n        return _liquidityUnlockTime\\u003eblock.timestamp?_liquidityUnlockTime-block.timestamp:0;\\r\\n    }\\r\\n    function allowance(address owner_, address spender) external view override returns (uint256) {\\r\\n        return _allowances[owner_][spender];\\r\\n    }\\r\\n    function balanceOf(address account) external view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"FarmerDogeV2\\\";\\r\\n    }\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"CROP\\\";\\r\\n    }\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _initialSupply - _totalTokensBurned;\\r\\n    }\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return 9;\\r\\n    }\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n}\"},\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function name() external view returns (string memory);\\r\\n  function getOwner() external view returns (address);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IPancakeERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = msg.sender;\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue\\u0027s index to valueIndex\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"ClaimBNBTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"ClaimPromoToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"Compound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"name\":\"LockExternalTeamTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"teamPercent\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"contractPercent\",\"type\":\"uint8\"}],\"name\":\"OwnerCreateLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rewardBoost\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"TeamBoostContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toBurn\",\"type\":\"uint256\"}],\"name\":\"TeamBurnContractTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWalletSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSellSize\",\"type\":\"uint256\"}],\"name\":\"TeamChangeLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellDelay\",\"type\":\"uint256\"}],\"name\":\"TeamChangeSellDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"burnTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"}],\"name\":\"TeamChangeTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"TeamChangeWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeSeconds\",\"type\":\"uint256\"}],\"name\":\"TeamExtendLPLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rewardBoost\",\"type\":\"bool\"}],\"name\":\"TeamRemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"farmToken\",\"type\":\"address\"}],\"name\":\"TeamSetFarmToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"promoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minHoldForBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"promoTokenEnabled\",\"type\":\"bool\"}],\"name\":\"TeamSetPromoToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"swapThreshold\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"TeamSwapContractTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TeamSwitch20PercentEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"TeamSwitchSwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"TeamTriggerBuyBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"AMMAdress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TeamUpdateAMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"swapThreshold\",\"type\":\"uint16\"}],\"name\":\"TeamUpdateSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strandedToken\",\"type\":\"address\"}],\"name\":\"TeamWithdrawStrandedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakePairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"fromContract\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTaxes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"burnTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiBotTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"includeMeToRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityUnlockTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"name\":\"lockExternalTeamTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nextSellOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamPercent\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"contractPercent\",\"type\":\"uint8\"}],\"name\":\"ownerCreateLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"promoToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remove20PercentEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetFlags\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"rewardBoost\",\"type\":\"bool\"}],\"name\":\"teamBoostContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"burnPercent\",\"type\":\"uint8\"}],\"name\":\"teamBurnContractTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellDelay\",\"type\":\"uint256\"}],\"name\":\"teamChangeSellDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"burnTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"}],\"name\":\"teamChangeTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"teamChangeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamDisableAntiSnipe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeSeconds\",\"type\":\"uint256\"}],\"name\":\"teamExtendLPLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamFixStuckBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamReleaseLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"rewardBoost\",\"type\":\"bool\"}],\"name\":\"teamRemoveLiquidityPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamResetOneTimeExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"teamSetExcludedFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_farmToken\",\"type\":\"address\"}],\"name\":\"teamSetFarmToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_promoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minHoldForBonus\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"teamSetPromoToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"teamSwitch20PercentEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamSwitchSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"teamTriggerBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_swapThreshold\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"teamTriggerSwapContractTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMMAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"teamUpdateAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamUpdateLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_swapThreshold\",\"type\":\"uint16\"}],\"name\":\"teamUpdateSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"teamWithdrawMarketingBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardBNBPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trackContractBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketingBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBNB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FD", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4502f7b162f20a72b6171bf70ef1bcdbd81f253d41ba9d4a5b93859c2264027"}