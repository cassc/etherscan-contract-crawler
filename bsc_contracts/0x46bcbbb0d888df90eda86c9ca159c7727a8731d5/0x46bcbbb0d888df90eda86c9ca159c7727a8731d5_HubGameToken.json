{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\ninterface IBEP20 {\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n \r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  \r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ncontract BEP20 is Context, IBEP20 {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    string private _symbol;\r\n    string private _name;\r\n    address private _owner;\r\n\r\n    constructor(string memory name_, string memory symbol_){\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _owner = _msgSender();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _balances[account] += amount;\r\n        \r\n        emit Transfer(address(0), account, amount);\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ncontract CommonUtil{\r\n    struct LockItem {\r\n        uint256 tgeAmount;\r\n        uint256 tgeTime;\r\n        uint256 releaseTime;\r\n        uint256 lockedAmount;\r\n        uint256 amountInPeriod;\r\n    }\r\n\r\n    struct Transaction {\r\n        uint256 id;\r\n        address from;\r\n        address to;\r\n        uint256 value;\r\n        bool isExecuted;\r\n        uint256 numConfirmations;\r\n        uint256[] lockParams;\r\n    }\r\n\r\n    uint256 public periodInSecond = 2628000; \r\n\r\n    event SubmitTransaction(address indexed _signer, uint256 indexed txIndex, address indexed to, uint256 value);\r\n    event ConfirmTransaction(address indexed _signer, uint256 indexed txIndex);\r\n    event RevokeConfirmation(address indexed _signer, uint256 indexed txIndex);\r\n    event ExecuteTransaction(address indexed _signer, uint256 indexed txIndex);\r\n    event CheckExecuteTransaction(address _from, address _to, uint256 _available, uint256 _value, bool _execute);\r\n\r\n    event event_lockSystemWallet(address _sender, address _wallet, uint256 _lockedAmount, uint256 _releaseTime, uint256 _numOfPeriod);\r\n    event event_lockWallet(address _sender, address _wallet, uint256 _lockedAmount, uint256 _releaseTime, uint256 _numOfPeriod);\r\n\r\n    function getLockItem(uint256 _amount, uint256 _nextReleaseTime, uint256 _numOfPeriod, uint256 _tgeTime, uint256 _tgeAmount) \r\n    internal pure returns (LockItem memory){\r\n        uint256 _lockedAmount = _amount - _tgeAmount;\r\n        return LockItem({\r\n            tgeTime: _tgeTime,\r\n            tgeAmount: _tgeAmount,\r\n            releaseTime: _nextReleaseTime, \r\n            lockedAmount: _lockedAmount, \r\n            amountInPeriod: (_lockedAmount/_numOfPeriod)});\r\n    }\r\n}\r\n\r\ncontract HubController is CommonUtil, Ownable{    \r\n    mapping (address => LockItem) public lockeds;\r\n\r\n    address[] private signers;\r\n    mapping(address => bool) public isSigner;\r\n\r\n    mapping(uint256 => Transaction) private mapTransactions;\r\n    Transaction[] private transactions;\r\n    mapping(uint256 => mapping(address => bool)) private confirms;\r\n\r\n    constructor(uint256 _supplyTokenWei, uint256 _releaseDate, address[] memory _wallets, uint256[] memory _percents, address[] memory _signers,\r\n    uint256[] memory _tgePercents, uint256[] memory _numOfPeriods, uint256[] memory _ciffs) {  \r\n        for (uint256 i = 0; i < _wallets.length; i++) {\r\n            uint256 _amount = _supplyTokenWei  * _percents[i]/100;\r\n            uint256 _tgeAmount = _amount * _tgePercents[i]/100;\r\n            uint256 _nextReleaseTime = _releaseDate + (_ciffs[i] * periodInSecond);\r\n\r\n            LockItem memory item = getLockItem(_amount, _nextReleaseTime, _numOfPeriods[i], _releaseDate, _tgeAmount);\r\n            lockeds[_wallets[i]] = item;\r\n            emit event_lockSystemWallet(owner, _wallets[i], item.lockedAmount, item.releaseTime, _numOfPeriods[i]);\r\n        }\r\n        for (uint256 i = 0; i < _signers.length; i++){\r\n            isSigner[_signers[i]] = true;\r\n            signers.push(_signers[i]);\r\n        }\r\n    }\r\n\r\n    function addSigner(address _signer) public onlyOwner returns (bool){\r\n        require(_signer != address(0) && !isSigner[_signer], \"invalid signer\");\r\n            \r\n        isSigner[_signer] = true;\r\n        signers.push(_signer);\r\n        return true;\r\n    }\r\n\r\n    function removeSigner(address _signer) public onlyOwner returns(bool){\r\n        uint256 _indexSigner;\r\n        bool exists;\r\n        for (uint256 i=0; i< signers.length; i++){\r\n            if (signers[i] == _signer){\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n        if(exists){\r\n            isSigner[_signer] = false;\r\n            signers[_indexSigner] = signers[signers.length - 1];\r\n            signers.pop();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getLockedAmount(address lockedAddress) public view returns(uint256) {\r\n        LockItem memory item = lockeds[lockedAddress];\r\n        if(item.tgeAmount > 0 && block.timestamp >= item.tgeTime){\r\n            item.tgeAmount = 0;\r\n        }\r\n        if(item.lockedAmount > 0){\r\n            while(block.timestamp >= item.releaseTime){\r\n                if(item.lockedAmount > item.amountInPeriod){\r\n                    item.lockedAmount = item.lockedAmount - item.amountInPeriod;\r\n                }else{\r\n                    item.lockedAmount = 0;\r\n                }\r\n                item.releaseTime = item.releaseTime + periodInSecond;\r\n            }\r\n        }\r\n\t    return item.lockedAmount + item.tgeAmount;\r\n\t}\r\n\r\n    function getAllTransaction() public view onlyOwner\r\n    returns (Transaction[] memory){\r\n        return transactions;\r\n    }\r\n\r\n    function getTransactionById(uint256 _txId) public view onlyOwner\r\n    returns (Transaction memory){\r\n        return mapTransactions[_txId];\r\n    }\r\n\r\n    function submit(uint256 _txId, address _sender, address _receiver, uint256 _value, uint256[] memory _lockParams) public onlyOwner\r\n    returns (bool){\r\n        Transaction memory item = Transaction(\r\n            { \r\n                id: _txId,\r\n                from: _sender, \r\n                to: _receiver, \r\n                value: _value, \r\n                isExecuted: false, \r\n                numConfirmations: 0, \r\n                lockParams: _lockParams\r\n            });\r\n        transactions.push(item);\r\n        mapTransactions[_txId] = item;\r\n        emit SubmitTransaction(_sender, _txId, _receiver, _value);\r\n        return true;\r\n    }\r\n\r\n    function confirm(address _signer, uint256 _txId) public \r\n    onlyOwner\r\n    returns (bool canExecute,\r\n            address from,\r\n            address to,\r\n            uint256 value,\r\n            uint256[] memory lockParams){\r\n        require(!confirms[_txId][_signer], \"tx already confirmed\");\r\n        Transaction storage _transaction = mapTransactions[_txId];\r\n        _validateBeforeConfirm(_signer, _txId, _transaction.isExecuted);\r\n        \r\n        _transaction.numConfirmations += 1;\r\n        confirms[_txId][_signer] = true;\r\n\r\n        canExecute = (_transaction.numConfirmations >= 3 || _transaction.numConfirmations == signers.length);\r\n        return (canExecute, _transaction.from, _transaction.to, _transaction.value, _transaction.lockParams);\r\n    }\r\n\r\n    function executed(address _signer, uint256 _txId) public \r\n    onlyOwner{\r\n        Transaction storage _transaction = mapTransactions[_txId];\r\n        _transaction.isExecuted = true;\r\n        emit ExecuteTransaction(_signer, _txId);\r\n    }\r\n\r\n    function revoke(address _signer, uint256 _txId) public \r\n    onlyOwner\r\n    returns (bool){\r\n        require(confirms[_txId][_signer], \"tx unconfirmed\");\r\n        Transaction storage _transaction = mapTransactions[_txId];\r\n        _validateBeforeConfirm(_signer, _txId, _transaction.isExecuted);\r\n\r\n        _transaction.numConfirmations -= 1;\r\n        confirms[_txId][_signer] = false;\r\n        return true;\r\n    }\r\n\r\n    function getConfirmations(uint256 _txId) public view \r\n    onlyOwner\r\n    returns (address[] memory _confirmations) {\r\n        uint256 i;\r\n        uint256 count = 0;\r\n        for (i=0; i<signers.length; i++){\r\n            if (confirms[_txId][signers[i]]) {\r\n                _confirmations[count] = signers[i];\r\n            }\r\n        }     \r\n    }\r\n\r\n    function _validateBeforeConfirm(address _signer, uint256 _txId, bool _isExecuted) internal view \r\n    returns (bool){\r\n        require(mapTransactions[_txId].to != address(0), \"tx does not exist\");\r\n        require(!_isExecuted, \"tx already executed\");\r\n        require(isSigner[_signer] == true, \"invalid signer for this transaction\");\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract HubGameToken is BEP20, Ownable, CommonUtil {\r\n    uint8 public constant decimals = 8;\r\n    uint256 private totalSupplyAtBirth = 50000000000 * 10 ** uint256(decimals);\r\n    uint256 private totalMinted = 0;\r\n    uint256 private _txIndex = 0;\r\n\r\n    mapping(address => bool) private isAdmin;\r\n    address[] private blackList;\r\n    mapping(address => bool) private isBlackList;\r\n    \r\n    mapping(address => LockItem[]) private lockedList;\r\n    mapping(address => bool) private isLocked;\r\n\r\n    mapping(string => address) private gameControllers;\r\n    mapping(string => uint256) private gameSupplies;\r\n\r\n    mapping(address => bool) private isSystemWallet;\r\n    mapping(address => string) private systemWallets;\r\n    mapping(string => mapping(address => bool)) private signerWallets;\r\n\r\n\tconstructor() BEP20(\"HubGame\", \"HUB\"){\r\n        isAdmin[msg.sender] = true;\r\n    }\r\n\r\n    modifier requireDeployed(string memory _gameCode){\r\n        require (isAdmin[msg.sender] == true, \"must be admin\");\r\n        require (gameControllers[_gameCode] != address(0), \"invalid game contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require (isAdmin[msg.sender] == true, \"must be admin\");\r\n        _;\r\n    }\r\n\r\n    modifier requireNotEmptyCode(string memory _gameCode) {\r\n        require(keccak256(abi.encodePacked(_gameCode)) != keccak256(abi.encodePacked(\"\")), \"invalid game code\");\r\n        _;\r\n    }\r\n\r\n    modifier requireSigner(string memory _gameCode) {\r\n        require(signerWallets[_gameCode][msg.sender] == true, \"Access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier requiredTransfer(address _from, address _receiver, uint256 _amount) {\r\n        require(!isSystemWallet[msg.sender], \"must be not system wallet\");\r\n        require(!isBlackList[msg.sender], \"in black list\");\r\n        require(_from != _receiver && _receiver != address(0), \"invalid address\");\r\n        require(_amount > 0 && _amount <= availableBalance(_from), \"not enough funds to transfer\");\r\n        _;\r\n    }\r\n\r\n    function getCurrentTime() public view returns (uint256){\r\n        return block.timestamp;\r\n    }\r\n\r\n    function adminAdd(address[] memory _addresses) public onlyOwner{\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            isAdmin[_addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    function adminRemove(address _address) public onlyOwner{\r\n        isAdmin[_address] = false;\r\n    }\r\n\r\n    function blackListAdd(address[] memory _addresses) public onlyOwner{\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            isBlackList[_addresses[i]] = true;\r\n            blackList.push(_addresses[i]);\r\n        }\r\n    }\r\n\r\n    function blackListIndexOf(address _address) public view onlyOwner returns(uint256 index){\r\n        require(_address != address(0) && isBlackList[_address],\"invalid address\");\r\n        for (uint256 i=0; i< blackList.length; i++){\r\n            if (blackList[i] == _address) index = i;\r\n        }\r\n    }\r\n\r\n    function blackListRemove(uint256 index) public onlyOwner{\r\n        require(index < blackList.length,\"invalid index of address\");\r\n        isBlackList[blackList[index]] = false;\r\n        blackList[index] = blackList[blackList.length - 1];\r\n        blackList.pop();\r\n    }\r\n\r\n    function getControllers(string memory _gameCode) public view \r\n    onlyAdmin \r\n    requireNotEmptyCode(_gameCode)\r\n    returns (address){\r\n        return gameControllers[_gameCode];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256){\r\n        return totalSupplyAtBirth;\r\n    }\r\n\r\n    function totalMint() public view returns (uint256){\r\n        return totalMinted;\r\n    }\r\n\r\n    function totalSupplyInGame(string memory _gameCode) public view \r\n    requireNotEmptyCode(_gameCode)\r\n    returns (uint256){\r\n        return gameSupplies[_gameCode];\r\n    }\r\n\r\n    function initGame(string memory _gameCode, uint256 _supplyToken, uint256 _listingDate, address[] memory _wallets, uint256[] memory _percents,  \r\n    address[] memory _signers, uint256[] memory _tgePercents, uint256[] memory _numOfPeriods, uint256[] memory _ciffs) \r\n    public onlyAdmin returns (address gameAddress){\r\n        require(gameControllers[_gameCode] == address(0), \"game code is exist\");\r\n\r\n        uint256 _totalSupplyWei = _supplyToken * 10 ** uint256(decimals);\r\n        require(totalSupplyAtBirth - totalMinted >= _totalSupplyWei, \"out of available balance of token\");\r\n\r\n        require(_signers.length > 0 && _wallets.length == _percents.length \r\n                && _tgePercents.length == _numOfPeriods.length && _numOfPeriods.length == _ciffs.length, \"mismatch locked param\");\r\n\r\n        for (uint256 i = 0; i < _wallets.length; i++) {\r\n            address _wallet = _wallets[i];\r\n            require(isSystemWallet[_wallet] == false, \"system wallet is exist\");\r\n\r\n            _mint(_wallet, _totalSupplyWei  * _percents[i]/100); \r\n            isSystemWallet[_wallet] = true;\r\n            systemWallets[_wallet] = _gameCode;\r\n            isLocked[_wallet] = true;\r\n        }\r\n\r\n        for (uint256 i = 0; i < _signers.length; i++) {\r\n            signerWallets[_gameCode][_signers[i]] = true;\r\n        }\r\n        //_supplyTokenWei, _releaseDate, _wallets, _percents,_signers,_tgePercents, _numOfPeriods, _ciff\r\n        gameAddress = address(new HubController{salt: keccak256(abi.encode(_gameCode, _supplyToken))}\r\n                                (_totalSupplyWei, _listingDate, _wallets , _percents, _signers, _tgePercents, _numOfPeriods, _ciffs));\r\n        gameControllers[_gameCode] = gameAddress;\r\n        gameSupplies[_gameCode] = _totalSupplyWei;\r\n        totalMinted = totalMinted + _totalSupplyWei;\r\n    }\r\n\r\n    function getSigners(string memory _gameCode) public view returns (bool){\r\n        return signerWallets[_gameCode][msg.sender];\r\n    }\r\n\r\n    function signerAdd(string memory _gameCode, address _signer) public \r\n    requireDeployed(_gameCode) returns (bool){\r\n        signerWallets[_gameCode][_signer] = true;\r\n        return HubController(gameControllers[_gameCode]).addSigner(_signer);\r\n    }\r\n\r\n    function signerRemove(string memory _gameCode, address _signer) public \r\n    requireDeployed(_gameCode) returns (bool){\r\n        signerWallets[_gameCode][_signer] = false;\r\n        return HubController(gameControllers[_gameCode]).removeSigner(_signer);\r\n    }\r\n\r\n    function getAvailableBalance(address lockedAddress) public view returns(uint256) {\r\n        uint256 bal = balanceOf(lockedAddress);\r\n        uint256 locked = _getLockedAmount(lockedAddress);\r\n        return bal-locked;\r\n\t}\r\n\r\n    function availableBalance(address lockedAddress) internal returns(uint256) {\r\n        uint256 bal = balanceOf(lockedAddress);\r\n        uint256 locked = _getLockedAmount(lockedAddress);\r\n        if(locked == 0) {\r\n            isLocked[lockedAddress] = false;\r\n        }\r\n        return bal-locked;\r\n\t}\r\n\r\n    function _getLockedAmount(address lockedAddress) internal view returns(uint256) {\r\n        if(isLocked[lockedAddress] == false) return 0;\r\n        \r\n        address _contract = gameControllers[systemWallets[lockedAddress]];\r\n        if(_contract == address(0)){\r\n            LockItem[] memory items = lockedList[lockedAddress];\r\n\t        uint256 lockedAmount = 0;\r\n            for(uint256 j = 0; j < items.length; j++) {\r\n                while(block.timestamp >= items[j].releaseTime){\r\n                    if(items[j].lockedAmount > items[j].amountInPeriod){\r\n                        items[j].lockedAmount = items[j].lockedAmount - items[j].amountInPeriod;\r\n                    }else{\r\n                        items[j].lockedAmount = 0;\r\n                    }\r\n                    items[j].releaseTime = items[j].releaseTime + periodInSecond;\r\n                }\r\n                lockedAmount += items[j].lockedAmount;\r\n            }\r\n            return lockedAmount;\r\n        }\r\n        return HubController(_contract).getLockedAmount(lockedAddress);\r\n\t}\r\n\r\n    function transfer(address _receiver, uint256 _amount) public override \r\n    requiredTransfer(msg.sender, _receiver, _amount) \r\n    returns (bool) {\r\n        return BEP20.transfer(_receiver, _amount);\r\n\t}\r\n\t\r\n    function transferFrom(address _from, address _receiver, uint256 _amount)  public override  \r\n    requiredTransfer(_from, _receiver, _amount) \r\n    returns (bool) {\r\n        return BEP20.transferFrom(_from, _receiver, _amount);\r\n    }\r\n\r\n    function _verifyGameCode(string memory _gameCode) internal view returns (address _contract){\r\n        _contract = gameControllers[_gameCode];\r\n        require(_contract != address(0), \"Access denied\");\r\n    }\r\n\r\n    function getTransactions(string memory _gameCode) public view \r\n    requireNotEmptyCode(_gameCode)\r\n    returns (Transaction[] memory){\r\n        if(totalMinted > 0){\r\n            address _contract = _verifyGameCode(_gameCode);\r\n            return HubController(_contract).getAllTransaction();\r\n        }\r\n        return new Transaction[](0);\r\n    }\r\n\r\n    function getTransactionById(string memory _gameCode, uint256 _txId) public view \r\n    requireNotEmptyCode(_gameCode)\r\n    returns (Transaction memory){\r\n        if(totalMinted > 0){\r\n            address _contract = _verifyGameCode(_gameCode);\r\n            return HubController(_contract).getTransactionById(_txId);\r\n        }\r\n        Transaction memory _transaction;\r\n        return _transaction;\r\n    }\r\n\r\n    function getConfirmations(string memory _gameCode, uint256 _txId) public view \r\n    requireNotEmptyCode(_gameCode)\r\n    returns (address[] memory) {\r\n        if(totalMinted > 0){\r\n            address _contract = _verifyGameCode(_gameCode);\r\n            return HubController(_contract).getConfirmations(_txId);\r\n        }\r\n        return new address[](0);\r\n    }\r\n\r\n    function transactionSubmit(address _receiver, uint256 _value, uint256[] memory _lockParams) public returns (uint256){\r\n        address _contract = _verifyGameCode(systemWallets[msg.sender]);\r\n        _txIndex += 1;\r\n        require(HubController(_contract).submit(_txIndex, msg.sender, _receiver, _value, _lockParams));\r\n        return _txIndex;\r\n    }\r\n\r\n    function transactionConfirm(string memory _gameCode, uint256 _txId) \r\n    requireNotEmptyCode(_gameCode)\r\n    requireSigner(_gameCode)\r\n    public{\r\n        address _from;\r\n        address _to;\r\n        uint256 _value;\r\n        bool _canExecute;\r\n        uint256[] memory _params;\r\n\r\n        address _contract = _verifyGameCode(_gameCode);\r\n        HubController _game = HubController(_contract);\r\n        (_canExecute, _from, _to, _value, _params) = _game.confirm(msg.sender, _txId);\r\n        \r\n        if(_canExecute && availableBalance(_from) >= _value){\r\n            _transfer(_from, _to, _value);\r\n            if(_params.length > 0 && _params[0] > 0){\r\n                //releaseDate, numPeriod\r\n                LockItem memory item = getLockItem(_value, _params[0], _params[1], 0, 0);\r\n                lockedList[_to].push(item);\r\n                isLocked[_to] = true;\r\n                emit event_lockWallet(_from, _to, item.lockedAmount, item.releaseTime, _params[1]);\r\n            }\r\n            _game.executed(msg.sender, _txId);\r\n        }\r\n    }\r\n\r\n    function transactionRevoke(string memory _gameCode, uint256 _txId) public \r\n    requireNotEmptyCode(_gameCode)\r\n    requireSigner(_gameCode)\r\n    {\r\n        address _contract = _verifyGameCode(_gameCode);\r\n        require(HubController(_contract).revoke(msg.sender, _txId));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_available\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_execute\",\"type\":\"bool\"}],\"name\":\"CheckExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"ConfirmTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"ExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"RevokeConfirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SubmitTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_releaseTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numOfPeriod\",\"type\":\"uint256\"}],\"name\":\"event_lockSystemWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_releaseTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numOfPeriod\",\"type\":\"uint256\"}],\"name\":\"event_lockWallet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"adminAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"adminRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"blackListAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"blackListIndexOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"blackListRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lockedAddress\",\"type\":\"address\"}],\"name\":\"getAvailableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_txId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"}],\"name\":\"getControllers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"}],\"name\":\"getSigners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_txId\",\"type\":\"uint256\"}],\"name\":\"getTransactionById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"lockParams\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CommonUtil.Transaction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"}],\"name\":\"getTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"lockParams\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CommonUtil.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_supplyToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_listingDate\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percents\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tgePercents\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_numOfPeriods\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ciffs\",\"type\":\"uint256[]\"}],\"name\":\"initGame\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodInSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"signerAdd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"signerRemove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"}],\"name\":\"totalSupplyInGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_txId\",\"type\":\"uint256\"}],\"name\":\"transactionConfirm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_gameCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_txId\",\"type\":\"uint256\"}],\"name\":\"transactionRevoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_lockParams\",\"type\":\"uint256[]\"}],\"name\":\"transactionSubmit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HubGameToken", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "constantinople", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://52534983929a830c9ca766032aced19f3a0f07baa579e25f56b6f720a07f2036"}