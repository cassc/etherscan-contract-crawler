{"SourceCode": "// File: TransferHelper.sol\r\n\r\n\r\npragma solidity >=0.8.3;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferBNB(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: BNB_TRANSFER_FAILED');\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: iSYNTHVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTHVAULT{\r\n   function depositForMember(address synth, address member) external;\r\n   function setReserveClaim(uint256 _setSynthClaim) external;\r\n}\r\n// File: iSYNTHFACTORY.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTHFACTORY {\r\n    function isSynth(address) external view returns (bool);\r\n    function getSynth(address) external view returns (address);\r\n    function removeSynth(address _token) external;\r\n    function synthCount() external returns(uint);\r\n}\r\n// File: iPOOLFACTORY.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iPOOLFACTORY {\r\n    function isCuratedPool(address) external view returns (bool);\r\n    function addCuratedPool(address) external;\r\n    function removeCuratedPool(address) external;\r\n    function isPool(address) external returns (bool);\r\n    function getPool(address) external view returns(address);\r\n    function getVaultAssets() external view returns(address [] memory);\r\n    function curatedPoolCount() external view returns (uint);\r\n}\r\n\r\n// File: iBEP20.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iBEP20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function allowance(address, address) external view returns (uint256);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function burn(uint) external;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: iDAO.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iDAO {\r\n    function ROUTER() external view returns(address);\r\n    function BASE() external view returns(address);\r\n    function LEND() external view returns(address);\r\n    function UTILS() external view returns(address);\r\n    function DAO() external view returns (address);\r\n    function RESERVE() external view returns(address);\r\n    function SYNTHVAULT() external view returns(address);\r\n    function BONDVAULT() external view returns(address);\r\n    function SYNTHFACTORY() external view returns(address);\r\n    function POOLFACTORY() external view returns(address);\r\n    function depositForMember(address pool, uint256 amount, address member) external;\r\n    function currentProposal() external view returns (uint);\r\n    function mapPID_open(uint) external view returns (bool);\r\n    function isListed(address) external view returns (bool);\r\n}\r\n// File: iBASE.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\ninterface iBASE {\r\n    function DAO() external view returns (iDAO);\r\n    function secondsPerEra() external view returns (uint256);\r\n    function changeDAO(address) external;\r\n    function setParams(uint256, uint256) external;\r\n    function flipEmissions() external;\r\n    function mintFromDAO(uint256, address) external; \r\n    function burn(uint256) external; \r\n}\r\n// File: iBONDVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iBONDVAULT{\r\n  function depositForMember(address asset, address member, uint liquidityUnits) external;\r\n  function claimForMember(address listedAsset, address member) external;\r\n  function calcBondedLP(address bondedMember, address asset) external view returns(uint);\r\n  function getMemberPoolBalance(address, address) external view returns (uint256);\r\n  function totalWeight() external view returns (uint);\r\n  function isListed(address) external view returns (bool);\r\n  function listBondAsset(address) external;\r\n  function delistBondAsset(address) external;\r\n  function claim(address, address) external;\r\n  function getMemberLPWeight( address) external view returns(uint, uint);\r\n  function mapTotalPool_balance(address) external view returns (uint);\r\n}\r\n// File: iROUTER.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iROUTER {\r\n    function addLiquidityForMember(uint, uint, address, address) external payable returns (uint);\r\n      function synthMinting() external view returns (bool);\r\n}\r\n// File: iDAOVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iDAOVAULT{\r\n  function getMemberWeight(address) external view returns (uint256);\r\n  function getMemberPoolBalance(address, address) external view returns(uint);\r\n  function getMemberLPWeight(address) external view returns(uint, uint);\r\n  function depositLP(address, uint, address) external;\r\n  function withdraw(address, address) external returns (bool);\r\n  function totalWeight() external view returns (uint);\r\n  function mapTotalPool_balance(address) external view returns (uint);\r\n}\r\n// File: iRESERVE.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iRESERVE {\r\n    function grantFunds(uint, address) external; \r\n    function emissions() external returns(bool); \r\n    function setGlobalFreeze(bool) external; \r\n    function setIncentiveAddresses(address, address, address, address) external;\r\n    function globalFreeze() external returns(bool); \r\n    function freezeTime() external returns(uint256); \r\n\r\n}\r\n\r\n// File: iSYNTH.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTH {\r\n    function genesis() external view returns(uint);\r\n    function TOKEN() external view returns(address);\r\n    function POOL() external view returns(address);\r\n    function mintSynth(address, uint) external returns(uint256);\r\n    function burnSynth(uint) external returns(uint);\r\n    function realise() external;\r\n}\r\n\r\n// File: iLEND.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\ninterface iLEND {\r\n}\r\n// File: iUTILS.sol\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\ninterface iUTILS {\r\n    function calcShare(uint, uint, uint) external pure returns (uint);\r\n    function getFeeOnTransfer(uint256, uint256) external view returns(uint);\r\n    function getPoolShareWeight(address, uint)external view returns(uint);\r\n    function calcLiquidityUnits(uint, uint, uint, uint, uint) external pure returns (uint);\r\n    function calcLiquidityHoldings(uint, address, address) external pure returns (uint);\r\n    function calcSwapOutput(uint, uint, uint) external pure returns (uint);\r\n    function calcSwapFee(uint, uint, uint) external pure returns (uint);\r\n    function calcSwapValueInBase(address, uint) external view returns (uint);\r\n    function calcSwapValueInToken(address, uint) external view returns (uint);\r\n    function calcSpotValueInBaseWithSynth(address, uint) external view returns (uint);\r\n    function calcSpotValueInBase(address, uint) external view returns (uint);\r\n    function calcPart(uint, uint) external pure returns (uint);\r\n    function calcLiquidityUnitsAsym(uint, address)external pure returns (uint);\r\n    function calcActualSynthUnits(address, uint) external view returns (uint);\r\n}\r\n// File: Dao.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Dao is ReentrancyGuard{\r\n    address private DEPLOYER;        // Address that deployed contract | can be purged to address(0)\r\n    address public immutable BASE;  // SPARTA base contract address\r\n    bool public retire;             // If DAO retired/upgraded\r\n    bool public running;            // DAO proposals running | default to false\r\n\r\n    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised\r\n    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp (2/3)\r\n    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives\r\n    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially\r\n    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be > $200\r\n    uint256 public currentProposal; // The most recent proposal; also acts as a count of all proposals\r\n    uint256 public cancelPeriod;\r\n    \r\n    struct ProposalDetails {\r\n        uint id;\r\n        string proposalType;\r\n        uint votes;\r\n        uint coolOffTime;\r\n        bool finalising;\r\n        bool finalised;\r\n        uint param;\r\n        address proposedAddress;\r\n        bool open;\r\n        uint startTime;\r\n    }\r\n\r\n    bool private daoHasMoved;\r\n    address public DAO;\r\n\r\n    iROUTER private _ROUTER;\r\n    iUTILS private _UTILS;\r\n    iBONDVAULT private _BONDVAULT;\r\n    iDAOVAULT private _DAOVAULT;\r\n    iPOOLFACTORY private _POOLFACTORY;\r\n    iSYNTHFACTORY private _SYNTHFACTORY;\r\n    iRESERVE private _RESERVE;\r\n    iSYNTHVAULT private _SYNTHVAULT;\r\n    iLEND private _LEND;\r\n\r\n    address[] public arrayMembers; // History array of all member\r\n    \r\n    mapping(address => bool) public isMember;   // Used to prevent duplicates in arrayMembers[]\r\n    mapping(address => uint256) public mapMember_lastTime; // Member's last harvest time\r\n    mapping(uint256 => uint256) private mapPID_param;    // Parameter mapped to the proposal\r\n    mapping(uint256 => address) private mapPID_address;  // Address mapped to the proposal\r\n    mapping(uint256 => string) private mapPID_type;      // String of the proposal type\r\n    mapping(uint256 => uint256) private mapPID_coolOffTime; // Cooloff ending timestamp to be able to check if finalising proposal can be actioned\r\n    mapping(uint256 => bool) private mapPID_finalising;  // Is proposal in the finalizing stage\r\n    mapping(uint256 => bool) private mapPID_finalised;   // Has the proposal already be finalised / completed\r\n    mapping(uint256 => bool) public mapPID_open;        // Is the proposal open or closed\r\n    mapping(uint256 => uint256) private mapPID_startTime; // Timestamp of proposal creation\r\n\r\n    mapping(uint256 => mapping(address => uint256)) private mapPIDAsset_votes; // Balance of assets staked in favour of a proposal\r\n    mapping(uint256 => mapping(address => bool)) private mapPIDMember_hasVoted; // Whether member has signaled their support of a proposal\r\n    \r\n    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);\r\n    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);\r\n\r\n    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);\r\n    event NewVote(address indexed member, uint indexed proposalID, string proposalType);\r\n    event RemovedVote(address indexed member, uint indexed proposalID, string proposalType);\r\n    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);\r\n    event CancelProposal(address indexed member, uint indexed proposalID);\r\n    event FinalisedProposal(address indexed member, uint indexed proposalID, string proposalType);\r\n    event DepositAsset(address indexed owner, address indexed tokenAddress, address indexed poolAddress, uint256 depositAmount, uint256 bondedLP );\r\n    event Harvest(address indexed owner, uint amount);\r\n\r\n    // Restrict access\r\n    modifier onlyDAO() {\r\n        require(msg.sender == DEPLOYER);\r\n        _;\r\n    }\r\n    // Prevent state-changing functions after DAO is retired\r\n    modifier operational() {\r\n        require(!retire, 'RETIRED');\r\n        _;\r\n    }\r\n    // Pause proposals until running is true\r\n    modifier isRunning() {\r\n        require(running, 'INACTIVE');\r\n        _;\r\n    }\r\n    // Is a weight changing function (Check if voter; update votes if true)\r\n    modifier weightChange() {\r\n        uint _currentProposal = currentProposal; // Get current proposal ID\r\n        bool _recount = mapPID_open[_currentProposal] && mapPIDMember_hasVoted[_currentProposal][msg.sender]; // Check proposal is open and that user has already voted\r\n        if (_recount) {\r\n            _removeVotes(_currentProposal); // Remove user's votes from proposal before the function\r\n        }\r\n        _;\r\n        if (_recount) {\r\n            _addVotes(_currentProposal); // Add user's new votes to proposal after the function\r\n        }\r\n    }\r\n\r\n    constructor (address _base){\r\n        BASE = _base;\r\n        DEPLOYER = msg.sender;\r\n        DAO = address(this);\r\n    }\r\n\r\n    //==================================== PROTOCOL CONTRACTs SETTER =================================//\r\n\r\n    function setGenesisAddresses(address _router, address _utils, address _reserve, address _lend) external onlyDAO {\r\n        _ROUTER = iROUTER(_router);\r\n        _UTILS = iUTILS(_utils);\r\n        _RESERVE = iRESERVE(_reserve);\r\n        _LEND = iLEND(_lend);\r\n    }\r\n\r\n    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {\r\n        _DAOVAULT = iDAOVAULT(_daovault);\r\n        _BONDVAULT = iBONDVAULT(_bondvault);\r\n        _SYNTHVAULT = iSYNTHVAULT(_synthVault); \r\n    }\r\n    \r\n    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {\r\n        _POOLFACTORY = iPOOLFACTORY(_poolFactory);\r\n        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);\r\n    }\r\n\r\n    function setGenesisFactors(uint256 _coolOff, uint256 _erasToEarn, uint256 _majorityFactor) external onlyDAO {\r\n        coolOffPeriod = _coolOff;\r\n        erasToEarn = _erasToEarn;\r\n        majorityFactor = _majorityFactor;\r\n    }\r\n\r\n    function setDaoFactors(uint256 _daoClaim, uint256 _daoFee, bool _running, uint256 _cancelPeriod) external onlyDAO {\r\n        daoClaim = _daoClaim;\r\n        daoFee = _daoFee;\r\n        running = _running;\r\n        cancelPeriod = _cancelPeriod;\r\n    }\r\n\r\n    // Can purge deployer once DAO is stable and final\r\n    function purgeDeployer() external onlyDAO {\r\n        DEPLOYER = address(0);\r\n    }\r\n    //============================== USER - DEPOSIT/WITHDRAW ================================//\r\n\r\n    // Contract deposits LP tokens for member\r\n    function deposit(address pool, uint256 amount) external operational weightChange {\r\n        require(_POOLFACTORY.isCuratedPool(pool) == true); // Pool must be Curated\r\n        require(amount > 0);     // Deposit amount must be valid\r\n        if (isMember[msg.sender] != true) {\r\n            arrayMembers.push(msg.sender);  // If not a member; add user to member array\r\n            isMember[msg.sender] = true;    // If not a member; register the user as member\r\n        }\r\n        TransferHelper.safeTransferFrom(pool, msg.sender, address(_DAOVAULT), amount);\r\n        _DAOVAULT.depositLP(pool, amount, msg.sender); // Update user's deposit balance\r\n        mapMember_lastTime[msg.sender] = block.timestamp + 60; // Reset user's last harvest time + blockShift\r\n        emit MemberDeposits(msg.sender, pool, amount);\r\n    }\r\n    \r\n    // User withdraws all of their selected asset from the DAOVault\r\n    function withdraw(address pool) external operational weightChange {\r\n        uint256 amount = _DAOVAULT.getMemberPoolBalance(pool, msg.sender); // Get the members available vault balance\r\n        require(_DAOVAULT.withdraw(pool, msg.sender)); // Withdraw assets from vault and tsf to user\r\n        emit MemberWithdraws(msg.sender, pool, amount);\r\n    }\r\n\r\n    //============================== REWARDS ================================//\r\n    \r\n    // User claims their DAOVault incentives\r\n    function harvest() external operational {\r\n        require(_RESERVE.emissions()); // Reserve must have emissions turned on\r\n        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive\r\n        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time\r\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\r\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\r\n        if(reward > daoReward){\r\n            reward = daoReward; // User cannot claim more than the daoReward limit\r\n        }\r\n        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user\r\n        emit Harvest(msg.sender, reward);\r\n    }\r\n\r\n    // Calculate the user's current incentive-claim per era\r\n    function calcCurrentReward(address member) public view operational returns(uint){\r\n        require(block.timestamp > mapMember_lastTime[member]);\r\n        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim\r\n        uint share = calcReward(member); // Get share of rewards for user\r\n        uint reward = (share * secondsSinceClaim) / iBASE(BASE).secondsPerEra(); // User's share times eras since they last claimed\r\n        return reward;\r\n    }\r\n\r\n    // Calculate the user's current total claimable incentive\r\n    function calcReward(address member) public view operational returns(uint){\r\n        (uint256 weightDAO, uint256 totalDAOWeight) = _DAOVAULT.getMemberLPWeight(member); // Get the DAOVault weights\r\n        (uint256 weightBOND, uint256 totalBONDWeight) = _BONDVAULT.getMemberLPWeight(member); // Get the BondVault weights\r\n        uint256 memberWeight = weightDAO + weightBOND; // Get user's combined vault weight\r\n        uint256 totalWeight = totalDAOWeight + totalBONDWeight; // Get vault's combined total weight\r\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days\r\n        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that\r\n        return _UTILS.calcShare(memberWeight, totalWeight, daoReward); // Get users's share of that (1 era worth)\r\n    }\r\n     //==================================BOND =========================================//\r\n\r\n    function bond(address asset, uint256 amount) external payable operational weightChange returns (bool success) {\r\n        require(amount > 0); // Amount must be valid\r\n        require(_RESERVE.globalFreeze() != true); // There must not be a global freeze in place\r\n        address _pool = _POOLFACTORY.getPool(asset); // Get the pool address\r\n        require(_BONDVAULT.isListed(_pool)); // Asset must be listed for Bond \r\n        if (isMember[msg.sender] != true) {\r\n            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array\r\n            isMember[msg.sender] = true; // Register user as a member\r\n        }\r\n        uint256 liquidityUnits = _handleTransferIn(asset, amount); // Add liquidity and calculate LP units\r\n        mapMember_lastTime[msg.sender] = block.timestamp + 60; // Reset user's last harvest time + blockShift\r\n        _BONDVAULT.depositForMember(_pool, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault\r\n        emit DepositAsset(msg.sender,asset, _pool, amount, liquidityUnits);\r\n        return true;\r\n    }\r\n\r\n    // Add bonded assets as liquidity and calculate LP units\r\n    function _handleTransferIn(address _token, uint _amount) internal nonReentrant returns (uint LPunits){\r\n        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < 2 * 10**6 * 10**18){\r\n            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required\r\n        }\r\n        if(_token == address(0)){\r\n            require((_amount == msg.value)); // Ensure BNB value matching\r\n            uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets\r\n            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(_amount, spartaAllocation, _token, address(_BONDVAULT)); // Add SPARTA & BNB liquidity, mint LP tokens to BondVault\r\n        } else {\r\n             TransferHelper.safeTransferFrom(_token, msg.sender, address(this), _amount);\r\n            uint _actualAmount = iBEP20(_token).balanceOf(address(this)); // Get actual received TOKEN amount\r\n            uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _actualAmount); // Get the SPARTA swap value of the bonded assets\r\n            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _actualAmount){\r\n                uint256 approvalTNK = iBEP20(_token).totalSupply();\r\n                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required\r\n            }\r\n            LPunits = _ROUTER.addLiquidityForMember(_actualAmount, spartaAllocation, _token, address(_BONDVAULT)); // Add SPARTA & TOKEN liquidity, mint LP tokens to BondVault\r\n        }\r\n    }\r\n       // User claims a selection of their unlocked Bonded LPs\r\n    function claim(address bondAsset) external  operational weightChange{\r\n            _BONDVAULT.claim(bondAsset, msg.sender); \r\n    }\r\n     // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)\r\n    function burnBalance() external onlyDAO returns (bool){\r\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\r\n        iBASE(BASE).burn(baseBal);   \r\n        return true;\r\n    }\r\n\r\n    // Can transfer the SPARTA remaining in this contract to a new BOND\r\n    function moveBASEBalance(address newDAO) external onlyDAO {\r\n        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));\r\n        iBEP20(BASE).transfer(newDAO, baseBal); // Tsf SPARTA (oldDao -> newDao)\r\n    }\r\n    \r\n    //============================== CREATE PROPOSALS ================================//\r\n\r\n    // New ID, but specify type, one type for each function call\r\n    // Votes counted to IDs\r\n    // IDs are finalised\r\n    // IDs are executed, but type specifies unique logic\r\n\r\n    // New DAO proposal: Simple action\r\n    function newActionProposal(string memory typeStr) external {\r\n        uint _currentProposal = _checkProposal(); // If no open proposal; construct new one\r\n        _payFee(); // Pay SPARTA fee for new proposal\r\n        mapPID_type[_currentProposal] = typeStr; // Set the proposal type\r\n        emit NewProposal(msg.sender, _currentProposal, typeStr);\r\n    }\r\n\r\n    // New DAO proposal: uint parameter\r\n    function newParamProposal(uint256 param, string memory typeStr) external {\r\n        uint _currentProposal = _checkProposal(); // If no open proposal; construct new one\r\n        _payFee(); // Pay SPARTA fee for new proposal\r\n        mapPID_param[_currentProposal] = param; // Set the proposed parameter\r\n        mapPID_type[_currentProposal] = typeStr; // Set the proposal type\r\n        emit NewProposal(msg.sender, _currentProposal, typeStr);\r\n    }\r\n\r\n    // New DAO proposal: Address parameter\r\n    function newAddressProposal(address proposedAddress, string memory typeStr) external {\r\n        bytes memory _type = bytes(typeStr); // Get the proposal type\r\n        if (isEqual(_type, 'DAO') || isEqual(_type, 'ROUTER') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') || isEqual(_type, 'REALISE')) {\r\n            require(proposedAddress != address(0)); // Proposed address must be valid\r\n        }\r\n        uint _currentProposal = _checkProposal(); // If no open proposal; construct new one\r\n        _payFee(); // Pay SPARTA fee for new proposal\r\n        mapPID_address[_currentProposal] = proposedAddress; // Set the proposed new address\r\n        mapPID_type[_currentProposal] = typeStr; // Set the proposal type\r\n        emit NewProposal(msg.sender, _currentProposal, typeStr);\r\n    }\r\n\r\n    // New DAO proposal: Grant SPARTA to wallet\r\n    function newGrantProposal(address recipient, uint amount) external {\r\n        require(recipient != address(0)); // Proposed recipient must be valid\r\n        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE\r\n        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)\r\n        require((amount > 0) && (amount < daoReward)); // Proposed grant amount must be valid\r\n        uint _currentProposal = _checkProposal(); // If no open proposal; construct new one\r\n        _payFee(); // Pay SPARTA fee for new proposal\r\n        string memory typeStr = \"GRANT\";\r\n        mapPID_type[_currentProposal] = typeStr; // Set the proposal type\r\n        mapPID_address[_currentProposal] = recipient; // Set the proposed grant recipient\r\n        mapPID_param[_currentProposal] = amount; // Set the proposed grant amount\r\n        emit NewProposal(msg.sender, _currentProposal, typeStr);\r\n    }\r\n\r\n    // If no existing open DAO proposal; register a new one\r\n    function _checkProposal() internal operational isRunning returns(uint) {\r\n        require(_RESERVE.globalFreeze() != true); // There must not be a global freeze in place\r\n        uint _currentProposal = currentProposal; // Get the current proposal ID\r\n        require(mapPID_open[_currentProposal] == false); // There must not be an existing open proposal\r\n        _currentProposal += 1; // Increment to the new PID\r\n        currentProposal = _currentProposal; // Set current proposal to the new count\r\n        mapPID_open[_currentProposal] = true; // Set new proposal as open status\r\n        mapPID_startTime[_currentProposal] = block.timestamp; // Set the start time of the proposal to now\r\n        return _currentProposal;\r\n    }\r\n    \r\n    // Pay a DAO fee\r\n    function _payFee() internal returns(bool){\r\n        TransferHelper.safeTransferFrom(BASE, msg.sender, address(_RESERVE), daoFee * 10**18);\r\n        return true;\r\n    } \r\n\r\n    //============================== VOTE && FINALISE ================================//\r\n\r\n    // Vote for a proposal\r\n    function voteProposal() external operational {\r\n        require(_RESERVE.globalFreeze() != true); // There must not be a global freeze in place\r\n        uint _currentProposal = currentProposal; // Get the current proposal ID\r\n        require(mapPID_open[_currentProposal] == true); // Proposal must be open status\r\n        require(mapPIDMember_hasVoted[_currentProposal][msg.sender] == false, \"VOTED\"); // User must not have already signaled their support\r\n        bytes memory _type = bytes(mapPID_type[_currentProposal]); // Get the proposal type\r\n        bool nonZero = _addVotes(_currentProposal); // Add votes to current proposal\r\n        mapPIDMember_hasVoted[_currentProposal][msg.sender] = true; // Signal user's support for the proposal\r\n        if (nonZero) {\r\n            emit NewVote(msg.sender, _currentProposal, string(_type)); // Emit event if vote has nonZero weight\r\n        }\r\n    }\r\n\r\n    // Remove vote from a proposal\r\n    function unvoteProposal() external operational {\r\n        uint _currentProposal = currentProposal; // Get the current proposal ID\r\n        require(mapPID_open[_currentProposal] == true); // Proposal must be open status\r\n        require(mapPIDMember_hasVoted[_currentProposal][msg.sender] == true, \"!VOTED\"); // User must have already signaled their support\r\n        bytes memory _type = bytes(mapPID_type[_currentProposal]); // Get the proposal type\r\n        bool nonZero = _removeVotes(_currentProposal); // Remove votes from current proposal\r\n        mapPIDMember_hasVoted[_currentProposal][msg.sender] = false; // Remove user's signal of support for the proposal\r\n        if (nonZero) {\r\n            emit RemovedVote(msg.sender, _currentProposal, string(_type)); // Emit event if removed votes had a nonZero weight\r\n        }\r\n    }\r\n\r\n    // Poll vote weights and check if proposal is ready to go into finalisation stage\r\n    function pollVotes() external operational {\r\n        uint _currentProposal = currentProposal; // Get the current proposal ID\r\n        require(mapPID_open[_currentProposal] == true); // Proposal must be open status\r\n        bytes memory _type = bytes(mapPID_type[_currentProposal]); // Get the proposal type\r\n        if(hasQuorum(_currentProposal) && mapPID_finalising[_currentProposal] == false){\r\n            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') || isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND') || isEqual(_type, 'GRANT') || isEqual(_type, 'ADD_CURATED_POOL')){\r\n                if(hasMajority(_currentProposal)){\r\n                    _finalise(_currentProposal, _type); // Critical proposals require 'majority' consensus to enter finalization phase\r\n                }\r\n            } else {\r\n                _finalise(_currentProposal, _type); // Other proposals require 'quorum' consensus to enter finalization phase\r\n            }\r\n        }\r\n    }\r\n\r\n    // Push the proposal into 'finalising' status\r\n    function _finalise(uint _currentProposal, bytes memory _type) internal {\r\n        mapPID_finalising[_currentProposal] = true; // Set finalising status to true\r\n        mapPID_coolOffTime[_currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from\r\n        emit ProposalFinalising(msg.sender, _currentProposal, block.timestamp+coolOffPeriod, string(_type));\r\n    }\r\n\r\n    // Attempt to cancel the open proposal\r\n    function cancelProposal() operational external {\r\n        uint _currentProposal = currentProposal; // Get the current proposal ID\r\n        require(mapPID_open[_currentProposal], \"!OPEN\"); // Proposal must be open\r\n        require(block.timestamp > (mapPID_startTime[_currentProposal] + cancelPeriod), \"!days\"); // Proposal must not be new\r\n        address [] memory votingAssets =  _POOLFACTORY.getVaultAssets(); // Get array of vault-enabled pools\r\n        for(uint i = 0; i < votingAssets.length; i++){\r\n           mapPIDAsset_votes[_currentProposal][votingAssets[i]] = 0; // Reset votes to 0\r\n        }\r\n        mapPID_finalising[_currentProposal] = false; // Remove proposal from 'finalising' stage\r\n        mapPID_open[_currentProposal] = false; // Close the proposal\r\n        emit CancelProposal(msg.sender, _currentProposal);\r\n    }\r\n\r\n    // A finalising-stage proposal can be finalised after the cool off period\r\n    function finaliseProposal() external operational isRunning {\r\n        require(_RESERVE.globalFreeze() != true, '!SAFE'); // There must not be a global freeze in place\r\n        uint _currentProposal = currentProposal; // Get the current proposal ID\r\n        require((block.timestamp - mapPID_coolOffTime[_currentProposal]) > coolOffPeriod, \"!cooloff\"); // Must be past cooloff period\r\n        require(mapPID_finalising[_currentProposal] == true, \"!finalising\"); // Must be in finalising stage\r\n        require(mapPID_open[_currentProposal] == true); // Proposal must be open\r\n        require(mapPID_finalised[_currentProposal] == false); // Proposal must not already be finalised\r\n        if(!hasQuorum(_currentProposal)){\r\n            mapPID_finalising[_currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage\r\n        } else {\r\n            bytes memory _type = bytes(mapPID_type[_currentProposal]); // Get the proposal type\r\n            if(isEqual(_type, 'DAO')){\r\n                _moveDao(_currentProposal);\r\n            } else if (isEqual(_type, 'ROUTER')) { // address\r\n                _moveRouter(_currentProposal);\r\n            } else if (isEqual(_type, 'UTILS')){ // address\r\n                _moveUtils(_currentProposal);\r\n            } else if (isEqual(_type, 'RESERVE')){ // address\r\n                _moveReserve(_currentProposal);\r\n            } else if (isEqual(_type, 'FLIP_EMISSIONS')){ // action\r\n                _flipEmissions();\r\n            } else if (isEqual(_type, 'COOL_OFF')){ // param\r\n                _changeCooloff(_currentProposal);\r\n            } else if (isEqual(_type, 'DAO_CLAIM')){ // param\r\n                _changeDAOClaim(_currentProposal);\r\n            } else if (isEqual(_type, 'SYNTH_CLAIM')){ // param\r\n                _changeSYNTHClaim(_currentProposal);\r\n            } else if (isEqual(_type, 'GRANT')){ // grant\r\n                _grantFunds(_currentProposal);\r\n            } else if (isEqual(_type, 'GET_SPARTA')){\r\n                _increaseSpartaAllocation(); // action\r\n            } else if (isEqual(_type, 'LIST_BOND')){\r\n                _listBondingAsset(_currentProposal);   // address\r\n            } else if (isEqual(_type, 'DELIST_BOND')){\r\n                _delistBondingAsset(_currentProposal);  // address\r\n            } else if (isEqual(_type, 'ADD_CURATED_POOL')){\r\n                _addCuratedPool(_currentProposal);   // address\r\n            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\r\n                _removeCuratedPool(_currentProposal); // address\r\n            } else if (isEqual(_type, 'REALISE')){\r\n                _realise(_currentProposal);  // address\r\n            } \r\n             _completeProposal(_currentProposal); // If no match; close proposal\r\n            \r\n        }\r\n    }\r\n\r\n    // Change the DAO to a new contract address\r\n    function _moveDao(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\r\n        DAO = _proposedAddress; // Change the DAO to point to the new DAO address\r\n        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\r\n        daoHasMoved = true; // Set status of this old DAO\r\n        retire = true;\r\n    }\r\n\r\n    // Change the ROUTER to a new contract address\r\n    function _moveRouter(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\r\n        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address\r\n    }\r\n\r\n    // Change the UTILS to a new contract address\r\n    function _moveUtils(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\r\n        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address\r\n    }\r\n\r\n    // Change the RESERVE to a new contract address\r\n    function _moveReserve(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\r\n        uint256 balance = iBEP20(BASE).balanceOf(address(_RESERVE));\r\n        _RESERVE.grantFunds(balance, _proposedAddress); // Grant the funds to the recipient\r\n        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address\r\n    }\r\n\r\n    // Flip the BASE emissions on/off\r\n    function _flipEmissions() internal {\r\n        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract\r\n    }\r\n\r\n    // Change cool off period (Period of time until a finalising proposal can be finalised)\r\n    function _changeCooloff(uint _proposalID) internal {\r\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\r\n        require(_proposedParam > 0, \"!param\"); // Param must be valid\r\n        coolOffPeriod = _proposedParam; // Change coolOffPeriod\r\n    }\r\n\r\n    // Change erasToEarn (Used to regulate the incentives flow)\r\n    function _changeDAOClaim(uint _proposalID) internal {\r\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\r\n        require(_proposedParam <= 1500);//maximum reserve claim 15%\r\n        daoClaim = _proposedParam; // Change erasToEarn\r\n    }\r\n\r\n    function _changeSYNTHClaim(uint _proposalID) internal {\r\n        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param\r\n        require(_proposedParam <= 1500);//maximum reserve claim 15%\r\n        _SYNTHVAULT.setReserveClaim(_proposedParam); // Change erasToEarn \r\n    }\r\n\r\n    // Grant SPARTA to the proposed recipient\r\n    function _grantFunds(uint _proposalID) internal {\r\n        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\r\n        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\r\n    }\r\n\r\n    // Mint a 2.0M SPARTA allocation for the Bond program\r\n    function _increaseSpartaAllocation() internal {\r\n        uint256 _2m = 2*10**6*10**18; //_2m\r\n        iBASE(BASE).mintFromDAO(_2m, address(this)); // Mint SPARTA and send to DAO to hold\r\n    }\r\n\r\n    // Realise value out of a synth's collateral\r\n    function _realise(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SYNTH address for realise\r\n        iSYNTH(_proposedAddress).realise(); // Calculate value of LPs vs synthSupply; burn the premium\r\n    }\r\n\r\n    // List an asset to be enabled for Bonding\r\n    function _listBondingAsset(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\r\n        _completeProposal(_proposalID); // Finalise the proposal - fire and forget\r\n       _BONDVAULT.listBondAsset(_proposedAddress); \r\n    }\r\n\r\n    // Delist an asset from being allowed to Bond\r\n    function _delistBondingAsset(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\r\n        _BONDVAULT.delistBondAsset(_proposedAddress); \r\n    }\r\n\r\n    // Add a pool as 'Curated' to enable synths, weight and incentives\r\n    function _addCuratedPool(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset\r\n        _completeProposal(_proposalID); // Finalise the proposal - fire and forget\r\n        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated\r\n    }\r\n\r\n    // Remove a pool from Curated status\r\n    function _removeCuratedPool(uint _proposalID) internal {\r\n        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal\r\n        _completeProposal(_proposalID); // Finalise the proposal - fire and forget\r\n        _BONDVAULT.delistBondAsset(_proposedAddress);\r\n        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated\r\n    }\r\n    \r\n    // After completing the proposal's action; close it\r\n    function _completeProposal(uint _proposalID) internal {\r\n        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type\r\n        address [] memory votingAssets =  _POOLFACTORY.getVaultAssets(); // Get array of current vault assets\r\n        for(uint i = 0; i < votingAssets.length; i++){\r\n           mapPIDAsset_votes[_proposalID][votingAssets[i]] = 0; // Reset votes to 0\r\n        }\r\n        mapPID_finalised[_proposalID] = true; // Finalise the proposal\r\n        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage\r\n        mapPID_open[_proposalID] = false; // Close the proposal\r\n        emit FinalisedProposal(msg.sender, _proposalID, _typeStr);\r\n    }\r\n\r\n    //============================== CONSENSUS ================================//\r\n    \r\n    // User stakes all their vault assets for a proposal\r\n    function _addVotes(uint _currentProposal) internal returns (bool nonZero) {\r\n        address [] memory votingAssets = _POOLFACTORY.getVaultAssets(); // Get array of current vault assets\r\n        for(uint i = 0; i < votingAssets.length; i++){\r\n            uint unitsAdded = _DAOVAULT.getMemberPoolBalance(votingAssets[i], msg.sender) + _BONDVAULT.getMemberPoolBalance(votingAssets[i], msg.sender); // Get user's combined vault balance per asset\r\n            if (unitsAdded > 0) {\r\n                mapPIDAsset_votes[_currentProposal][votingAssets[i]] += unitsAdded; // Add user's votes for the current proposal\r\n                nonZero = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // User removes their vault staked assets from a proposal\r\n    function _removeVotes(uint _currentProposal) internal returns (bool nonZero) {\r\n        address [] memory votingAssets = _POOLFACTORY.getVaultAssets(); // Get array of current vault assets\r\n        for(uint i = 0; i < votingAssets.length; i++){\r\n            uint unitsRemoved = _DAOVAULT.getMemberPoolBalance(votingAssets[i], msg.sender) + _BONDVAULT.getMemberPoolBalance(votingAssets[i], msg.sender); // Get user's combined vault balance per asset\r\n            if (unitsRemoved > 0) {\r\n                mapPIDAsset_votes[_currentProposal][votingAssets[i]] -= unitsRemoved; // Remove user's votes from the current proposal\r\n                nonZero = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check if a proposal has Majority consensus\r\n    function hasMajority(uint _proposalID) public view returns(bool){\r\n        address [] memory votingAssets = _POOLFACTORY.getVaultAssets(); // Get array of current vault assets\r\n        uint256 _votedWeight; uint _totalWeight;\r\n        for(uint i = 0; i < votingAssets.length; i++){\r\n            uint256 lpTotal = _DAOVAULT.mapTotalPool_balance(votingAssets[i]) + _BONDVAULT.mapTotalPool_balance(votingAssets[i]); // Get total balance of asset in the combined vaults\r\n            _votedWeight += _UTILS.getPoolShareWeight(votingAssets[i], mapPIDAsset_votes[_proposalID][votingAssets[i]]); // Get proposal's current weight\r\n            _totalWeight += _UTILS.getPoolShareWeight(votingAssets[i], lpTotal); // Get combined vault's current total weight\r\n        }\r\n        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%\r\n        return (_votedWeight > consensus);\r\n    }\r\n\r\n    // Check if a proposal has Quorum consensus\r\n    function hasQuorum(uint _proposalID) public view returns(bool){\r\n        address [] memory votingAssets = _POOLFACTORY.getVaultAssets(); // Get array of current vault assets\r\n        uint256 _votedWeight; uint _totalWeight;\r\n        for(uint i = 0; i < votingAssets.length; i++){\r\n            uint256 lpTotal = _DAOVAULT.mapTotalPool_balance(votingAssets[i]) + _BONDVAULT.mapTotalPool_balance(votingAssets[i]); // Get total balance of asset in the combined vaults\r\n            _votedWeight += _UTILS.getPoolShareWeight(votingAssets[i], mapPIDAsset_votes[_proposalID][votingAssets[i]]); // Get proposal's current weight\r\n            _totalWeight += _UTILS.getPoolShareWeight(votingAssets[i], lpTotal); // Get combined vault's current total weight\r\n        }\r\n        uint consensus = _totalWeight / 2; // Quorum > 50%\r\n        return (_votedWeight > consensus);\r\n    }\r\n\r\n    //======================================PROTOCOL CONTRACTs GETTER=================================//\r\n    \r\n    // Get the ROUTER address that the DAO currently points to\r\n    function ROUTER() external view returns(iROUTER){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).ROUTER();\r\n        } else {\r\n            return _ROUTER;\r\n        }\r\n    }\r\n\r\n    // Get the UTILS address that the DAO currently points to\r\n    function UTILS() external view returns(iUTILS){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).UTILS();\r\n        } else {\r\n            return _UTILS;\r\n        }\r\n    }\r\n\r\n    // Get the BONDVAULT address that the DAO currently points to\r\n    function BONDVAULT() external view returns(iBONDVAULT){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).BONDVAULT();\r\n        } else {\r\n            return _BONDVAULT;\r\n        }\r\n    }\r\n\r\n    // Get the DAOVAULT address that the DAO currently points to\r\n    function DAOVAULT() external view returns(iDAOVAULT){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).DAOVAULT();\r\n        } else {\r\n            return _DAOVAULT;\r\n        }\r\n    }\r\n\r\n    // Get the POOLFACTORY address that the DAO currently points to\r\n    function POOLFACTORY() external view returns(iPOOLFACTORY){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).POOLFACTORY();\r\n        } else {\r\n            return _POOLFACTORY;\r\n        }\r\n    }\r\n\r\n    // Get the SYNTHFACTORY address that the DAO currently points to\r\n    function SYNTHFACTORY() external view returns(iSYNTHFACTORY){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).SYNTHFACTORY();\r\n        } else {\r\n            return _SYNTHFACTORY;\r\n        }\r\n    }\r\n\r\n    // Get the RESERVE address that the DAO currently points to\r\n    function RESERVE() external view returns(iRESERVE){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).RESERVE();\r\n        } else {\r\n            return _RESERVE;\r\n        }\r\n    }\r\n\r\n    // Get the SYNTHVAULT address that the DAO currently points to\r\n    function SYNTHVAULT() external view returns(iSYNTHVAULT){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).SYNTHVAULT();\r\n        } else {\r\n            return _SYNTHVAULT;\r\n        }\r\n    }\r\n    // Get the LEND address that the DAO currently points to\r\n    function LEND() external view returns(iLEND){\r\n        if(daoHasMoved){\r\n            return Dao(DAO).LEND();\r\n        } else {\r\n            return _LEND;\r\n        }\r\n    }\r\n\r\n    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){\r\n        proposalDetails.id = proposalID;\r\n        proposalDetails.proposalType = mapPID_type[proposalID];\r\n        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];\r\n        proposalDetails.finalising = mapPID_finalising[proposalID];\r\n        proposalDetails.finalised = mapPID_finalised[proposalID];\r\n        proposalDetails.param = mapPID_param[proposalID];\r\n        proposalDetails.proposedAddress = mapPID_address[proposalID];\r\n        proposalDetails.open = mapPID_open[proposalID];\r\n        proposalDetails.startTime = mapPID_startTime[proposalID];\r\n        return proposalDetails;\r\n    }\r\n\r\n    function getProposalAssetVotes(uint256 proposal, address asset) public view returns (uint256) {\r\n        return mapPIDAsset_votes[proposal][asset];\r\n    }\r\n\r\n    function memberVoted(uint256 proposal, address member) public view returns (bool) {\r\n        return mapPIDMember_hasVoted[proposal][member];\r\n    }\r\n    \r\n    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){\r\n        return(sha256(part1) == sha256(part2));\r\n    }\r\n    function retireDao() external onlyDAO {\r\n        retire = true;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"CancelProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondedLP\",\"type\":\"uint256\"}],\"name\":\"DepositAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposalType\",\"type\":\"string\"}],\"name\":\"FinalisedProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MemberDeposits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"MemberWithdraws\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposalType\",\"type\":\"string\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposalType\",\"type\":\"string\"}],\"name\":\"NewVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeFinalised\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposalType\",\"type\":\"string\"}],\"name\":\"ProposalFinalising\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposalType\",\"type\":\"string\"}],\"name\":\"RemovedVote\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BONDVAULT\",\"outputs\":[{\"internalType\":\"contract iBONDVAULT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAOVAULT\",\"outputs\":[{\"internalType\":\"contract iDAOVAULT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LEND\",\"outputs\":[{\"internalType\":\"contract iLEND\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOLFACTORY\",\"outputs\":[{\"internalType\":\"contract iPOOLFACTORY\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESERVE\",\"outputs\":[{\"internalType\":\"contract iRESERVE\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract iROUTER\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYNTHFACTORY\",\"outputs\":[{\"internalType\":\"contract iSYNTHFACTORY\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYNTHVAULT\",\"outputs\":[{\"internalType\":\"contract iSYNTHVAULT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UTILS\",\"outputs\":[{\"internalType\":\"contract iUTILS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrayMembers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"calcCurrentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"calcReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bondAsset\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coolOffPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erasToEarn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finaliseProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getProposalAssetVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"getProposalDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"proposalType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coolOffTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalising\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finalised\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"param\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposedAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Dao.ProposalDetails\",\"name\":\"proposalDetails\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"hasMajority\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"hasQuorum\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"majorityFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapMember_lastTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapPID_open\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"memberVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"moveBASEBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"typeStr\",\"type\":\"string\"}],\"name\":\"newActionProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeStr\",\"type\":\"string\"}],\"name\":\"newAddressProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"newGrantProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"param\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"typeStr\",\"type\":\"string\"}],\"name\":\"newParamProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pollVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purgeDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retire\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retireDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"running\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_daoClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daoFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_running\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_cancelPeriod\",\"type\":\"uint256\"}],\"name\":\"setDaoFactors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_synthFactory\",\"type\":\"address\"}],\"name\":\"setFactoryAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_utils\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lend\",\"type\":\"address\"}],\"name\":\"setGenesisAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coolOff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_erasToEarn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_majorityFactor\",\"type\":\"uint256\"}],\"name\":\"setGenesisFactors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daovault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bondvault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_synthVault\",\"type\":\"address\"}],\"name\":\"setVaultAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unvoteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Dao", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003910db0600ea925f63c36ddb1351ab6e2c6eb102", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bdb0c1323e2f1e6c4fddfba1b05738f9a67f6a93b6133b2e87d08052e7ecf40d"}