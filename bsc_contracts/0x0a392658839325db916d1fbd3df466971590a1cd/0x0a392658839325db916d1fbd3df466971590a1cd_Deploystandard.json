{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"tokenfactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport './StandardToken.sol';\\n\\ninterface IStandard{\\n\\n   struct TokenInfo {\\n\\t\\tstring name;\\n\\t\\tstring symbol;\\n\\t\\taddress marketingFeeReceiver;\\n\\t\\taddress devFeeReceiver;\\n\\t\\tuint256 marketingTaxBuy;\\n\\t\\tuint256 marketingTaxSell;\\n\\t\\tuint256 devTaxSell;\\n\\t\\tuint256 devTaxBuy;\\n\\t\\tuint256 lpTaxBuy;\\n\\t\\tuint256 lpTaxSell;\\n\\t\\tuint256 totalSupply;\\n\\t\\tuint256 maxPercentageForWallet;\\n\\t\\tuint256 maxPercentageForTx;\\n\\t\\taddress swapRouter;\\n\\t\\taddress newOwner;\\n\\t}\\n\\n\\n    function initialise(\\n       TokenInfo memory _tokenInfo,\\n\\t\\tuint256 _deployerTax,\\n\\t\\taddress _deployFeeReceiver\\n    ) external;\\n\\n       \\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function mintToken(address newOwner,uint256 totalSupply) external;\\n}\\n\\ncontract Deploystandard{\\n\\n    mapping(address => address[]) public registry;\\n\\n    mapping(address => uint256) public createdContractsByAddress;\\n\\n    mapping(address => string) public cardURL;\\n\\n    event StandardTokenContractCreated(address Creator, address StandardTokenontract);\\n\\n    address[] public createdContracts;\\n\\n    uint256 public totalContractsCreated;\\n\\n    struct TokenInfo {\\n\\t\\tstring name;\\n\\t\\tstring symbol;\\n\\t\\taddress marketingFeeReceiver;\\n\\t\\taddress devFeeReceiver;\\n\\t\\tuint256 marketingTaxBuy;\\n\\t\\tuint256 marketingTaxSell;\\n\\t\\tuint256 devTaxSell;\\n\\t\\tuint256 devTaxBuy;\\n\\t\\tuint256 lpTaxBuy;\\n\\t\\tuint256 lpTaxSell;\\n\\t\\tuint256 totalSupply;\\n\\t\\tuint256 maxPercentageForWallet;\\n\\t\\tuint256 maxPercentageForTx;\\n\\t\\taddress swapRouter;\\n\\t\\taddress newOwner;\\n\\t}\\n\\n\\n\\n    function createStandardTokenContract(\\n        IStandard.TokenInfo memory _tokenInfo,\\n\\t\\tuint256 _deployerTax,\\n\\t\\taddress _deployFeeReceiver\\n       \\n    ) external  returns (address standardTokenContract) {\\n        \\n        bytes memory bytecode = type(StandardToken).creationCode;\\n\\n        bytes32 salt = keccak256(\\n            abi.encodePacked(\\n                msg.sender,\\n                _deployerTax,\\n                _tokenInfo.name,\\n                _tokenInfo.symbol,\\n                _tokenInfo.lpTaxBuy,\\n                _tokenInfo.maxPercentageForTx,\\n                _tokenInfo.marketingTaxBuy,\\n                _tokenInfo.marketingFeeReceiver,\\n                createdContractsByAddress[msg.sender]\\n            )\\n        );\\n        \\n\\n        assembly {\\n            standardTokenContract:= create2(\\n                0,\\n                add(bytecode, 32),\\n                mload(bytecode),\\n                salt\\n            )\\n        }\\n\\n        \\n        IStandard(standardTokenContract).initialise(\\n             _tokenInfo,\\n\\t\\t     _deployerTax,\\n\\t\\t     _deployFeeReceiver\\n        );\\n\\n\\n        createdContracts.push(standardTokenContract);\\n\\n        registry[msg.sender].push(standardTokenContract);\\n\\n        emit StandardTokenContractCreated(msg.sender, standardTokenContract);\\n\\n        return standardTokenContract;\\n    }\\n\\n    function getTokenAddress(address _address) public view returns(address[] memory){\\n        return registry[_address];\\n    }\\n\\n    function getCreatedContracts() public view returns(address[] memory){\\n        return createdContracts;\\n    }\\n\\n}\\n\\n\"\r\n    },\r\n    \"StandardToken.sol\": {\r\n      \"content\": \"// This contract was deployed for free on welaunchit.org | T.me/welaunchit\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tfunction decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n\\tmapping(address => uint256) private _balances;\\n\\n\\tmapping(address => mapping(address => uint256)) private _allowances;\\n\\n\\tuint256 private _totalSupply;\\n\\n\\tstring public _name;\\n\\tstring public _symbol;\\n\\n\\n\\n\\tfunction name() public view virtual override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction symbol() public view virtual override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction decimals() public view virtual override returns (uint8) {\\n\\t\\treturn 18;\\n\\t}\\n\\n\\tfunction totalSupply() public view virtual override returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\tfunction balanceOf(address account) public view virtual override returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\n\\tfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\t_transfer(owner, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction allowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender\\n\\t) public view virtual override returns (uint256) {\\n\\t\\treturn _allowances[owner][spender];\\n\\t}\\n\\n\\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\t_approve(owner, spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) public virtual override returns (bool) {\\n\\t\\taddress spender = _msgSender();\\n\\t\\t_spendAllowance(from, spender, amount);\\n\\t\\t_transfer(from, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\t_approve(owner, spender, allowance(owner, spender) + addedValue);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction decreaseAllowance(\\n\\t\\taddress spender,\\n\\t\\tuint256 subtractedValue\\n\\t) public virtual returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\tuint256 currentAllowance = allowance(owner, spender);\\n\\t\\trequire(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_approve(owner, spender, currentAllowance - subtractedValue);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint256 amount) internal virtual {\\n\\t\\trequire(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n\\t\\trequire(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n\\t\\t_beforeTokenTransfer(from, to, amount);\\n\\n\\t\\tuint256 fromBalance = _balances[from];\\n\\t\\trequire(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_balances[from] = fromBalance - amount;\\n\\t\\t\\t// Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n\\t\\t\\t// decrementing then incrementing.\\n\\t\\t\\t_balances[to] += amount;\\n\\t\\t}\\n\\n\\t\\temit Transfer(from, to, amount);\\n\\n\\t\\t_afterTokenTransfer(from, to, amount);\\n\\t}\\n\\n\\tfunction _mint(address account, uint256 amount) internal virtual {\\n\\t\\trequire(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n\\t\\t_beforeTokenTransfer(address(0), account, amount);\\n\\n\\t\\t_totalSupply += amount;\\n\\t\\tunchecked {\\n\\t\\t\\t// Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n\\t\\t\\t_balances[account] += amount;\\n\\t\\t}\\n\\t\\temit Transfer(address(0), account, amount);\\n\\n\\t\\t_afterTokenTransfer(address(0), account, amount);\\n\\t}\\n\\n\\tfunction _burn(address account, uint256 amount) internal virtual {\\n\\t\\trequire(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n\\t\\t_beforeTokenTransfer(account, address(0), amount);\\n\\n\\t\\tuint256 accountBalance = _balances[account];\\n\\t\\trequire(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_balances[account] = accountBalance - amount;\\n\\t\\t\\t// Overflow not possible: amount <= accountBalance <= totalSupply.\\n\\t\\t\\t_totalSupply -= amount;\\n\\t\\t}\\n\\n\\t\\temit Transfer(account, address(0), amount);\\n\\n\\t\\t_afterTokenTransfer(account, address(0), amount);\\n\\t}\\n\\n\\tfunction _approve(address owner, address spender, uint256 amount) internal virtual {\\n\\t\\trequire(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n\\t\\trequire(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n\\t\\t_allowances[owner][spender] = amount;\\n\\t\\temit Approval(owner, spender, amount);\\n\\t}\\n\\n\\tfunction _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n\\t\\tuint256 currentAllowance = allowance(owner, spender);\\n\\t\\tif (currentAllowance != type(uint256).max) {\\n\\t\\t\\trequire(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t_approve(owner, spender, currentAllowance - amount);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n\\tfunction _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\\ninterface IUniswapV2Factory {\\n\\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n\\tfunction feeTo() external view returns (address);\\n\\n\\tfunction feeToSetter() external view returns (address);\\n\\n\\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n\\tfunction allPairs(uint) external view returns (address pair);\\n\\n\\tfunction allPairsLength() external view returns (uint);\\n\\n\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n\\tfunction setFeeTo(address) external;\\n\\n\\tfunction setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Router01 {\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint amountADesired,\\n\\t\\tuint amountBDesired,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n\\tfunction addLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint amountTokenDesired,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n\\tfunction removeLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountA, uint amountB);\\n\\n\\tfunction removeLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountToken, uint amountETH);\\n\\n\\tfunction removeLiquidityWithPermit(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline,\\n\\t\\tbool approveMax,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external returns (uint amountA, uint amountB);\\n\\n\\tfunction removeLiquidityETHWithPermit(\\n\\t\\taddress token,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline,\\n\\t\\tbool approveMax,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external returns (uint amountToken, uint amountETH);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapTokensForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint[] memory amounts);\\n\\n\\tfunction swapTokensForExactETH(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\n\\tfunction swapETHForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint[] memory amounts);\\n\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint amountIn,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) external pure returns (uint amountOut);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint amountOut,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) external pure returns (uint amountIn);\\n\\n\\tfunction getAmountsOut(\\n\\t\\tuint amountIn,\\n\\t\\taddress[] calldata path\\n\\t) external view returns (uint[] memory amounts);\\n\\n\\tfunction getAmountsIn(\\n\\t\\tuint amountOut,\\n\\t\\taddress[] calldata path\\n\\t) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\n\\t\\taddress token,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountETH);\\n\\n\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n\\t\\taddress token,\\n\\t\\tuint liquidity,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline,\\n\\t\\tbool approveMax,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external returns (uint amountETH);\\n\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external;\\n\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable;\\n\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external;\\n}\\n\\nabstract contract Ownable is Context {\\n\\taddress private _owner;\\n\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\tconstructor() {\\n\\t\\t_transferOwnership(_msgSender());\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\t_checkOwner();\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction owner() public view virtual returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\tfunction _checkOwner() internal view virtual {\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t}\\n\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\t_transferOwnership(address(0));\\n\\t}\\n\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\t_transferOwnership(newOwner);\\n\\t}\\n\\n\\tfunction _transferOwnership(address newOwner) internal virtual {\\n\\t\\taddress oldOwner = _owner;\\n\\t\\t_owner = newOwner;\\n\\t\\temit OwnershipTransferred(oldOwner, newOwner);\\n\\t}\\n}\\n\\ncontract StandardToken is ERC20, Ownable {\\n\\tevent TransferFee(uint256 makertingTax, uint256 devTax, uint256 indexed lpTax);\\n\\tevent MarketingWalletUpdated(address newWallet, address oldWallet);\\n\\tevent DevWalletUpdated(address newWallet, address oldWallet);\\n\\n\\t\\n\\n\\tstruct TokenInfo {\\n\\t\\tstring name;\\n\\t\\tstring symbol;\\n\\t\\taddress marketingFeeReceiver;\\n\\t\\taddress devFeeReceiver;\\n\\t\\tuint256 marketingTaxBuy;\\n\\t\\tuint256 marketingTaxSell;\\n\\t\\tuint256 devTaxSell;\\n\\t\\tuint256 devTaxBuy;\\n\\t\\tuint256 lpTaxBuy;\\n\\t\\tuint256 lpTaxSell;\\n\\t\\tuint256 totalSupply;\\n\\t\\tuint256 maxPercentageForWallet;\\n\\t\\tuint256 maxPercentageForTx;\\n\\t\\taddress swapRouter;\\n\\t\\taddress newOwner;\\n\\t}\\n\\n\\tTokenInfo private tokenInfo;\\n\\n\\tmapping(address => bool) public isExcludeFromFee;\\n\\tmapping(address => bool) public isExcludeFromTxLimit;\\n\\tmapping(address => bool) public isExcludeFromWalletLimit;\\n\\n\\taddress deployer;\\n\\taddress public swapPair;\\n\\taddress public weth;\\n\\tuint256 private deployerTax;\\n\\tuint256 public maxAmountForWallet;\\n\\tuint256 public maxAmountForTx;\\n\\n\\tbool public swapping;\\n\\n\\tuint256 tokensForMarketing;\\n\\tuint256 tokensForDev;\\n\\tuint256 tokensForLiquidity;\\n\\tuint256 tokensForDeployer;\\n\\n\\tbool public initialised;\\n\\n\\tmodifier onlySwapping() {\\n\\t\\tswapping = true;\\n\\t\\t_;\\n\\t\\tswapping = false;\\n\\t}\\n\\n\\tfunction initialise(\\n\\t\\tTokenInfo memory _tokenInfo,\\n\\t\\tuint256 _deployerTax,\\n\\t\\taddress _deployFeeReceiver\\n\\t)public  {\\n\\t\\trequire(initialised == false ,'Aldready initialised');\\n\\t\\tdeployer = _deployFeeReceiver;\\n\\t\\ttokenInfo = _tokenInfo;\\n\\t\\tdeployerTax = _deployerTax;\\n\\n\\t\\trequire(\\n\\t\\t\\t_tokenInfo.maxPercentageForTx >= 0.5 ether && _tokenInfo.maxPercentageForTx <= 100 ether,\\n\\t\\t\\t\\\"TDP4\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_tokenInfo.maxPercentageForWallet >= 0.5 ether &&\\n\\t\\t\\t\\t_tokenInfo.maxPercentageForWallet <= 100 ether,\\n\\t\\t\\t\\\"TDP4\\\"\\n\\t\\t);\\n\\t\\t_name=_tokenInfo.name;\\n\\t\\t_symbol=_tokenInfo.symbol;\\n\\t\\tuint256 uBuyFee = tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\\n\\t\\tuint256 uSellFee = tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\\n\\t\\trequire(uBuyFee <= 15 ether && uSellFee <= 15 ether, \\\"TDP1\\\");\\n\\n\\t\\tmaxAmountForWallet = (_tokenInfo.maxPercentageForWallet * _tokenInfo.totalSupply) / 100 ether;\\n\\t\\tmaxAmountForTx = (_tokenInfo.maxPercentageForTx * _tokenInfo.totalSupply) / 100 ether;\\n\\n\\t\\taddress swapFactory = IUniswapV2Router02(_tokenInfo.swapRouter).factory();\\n\\t\\tweth = IUniswapV2Router02(_tokenInfo.swapRouter).WETH();\\n\\t\\tswapPair = IUniswapV2Factory(swapFactory).createPair(address(this), weth);\\n\\n\\t\\tisExcludeFromFee[address(this)] = true;\\n\\t\\tisExcludeFromFee[_tokenInfo.newOwner] = true;\\n\\t\\tisExcludeFromFee[_tokenInfo.marketingFeeReceiver] = true;\\n\\t\\tisExcludeFromFee[_tokenInfo.devFeeReceiver] = true;\\n\\n\\t\\tisExcludeFromTxLimit[address(this)] = true;\\n\\t\\tisExcludeFromTxLimit[_tokenInfo.newOwner] = true;\\n\\t\\tisExcludeFromTxLimit[tokenInfo.swapRouter] = true;\\n\\t\\tisExcludeFromTxLimit[_tokenInfo.marketingFeeReceiver] = true;\\n\\t\\tisExcludeFromTxLimit[_tokenInfo.devFeeReceiver] = true;\\n\\n\\t\\tisExcludeFromWalletLimit[address(this)] = true;\\n\\t\\tisExcludeFromWalletLimit[_tokenInfo.newOwner] = true;\\n\\t\\tisExcludeFromWalletLimit[tokenInfo.swapRouter] = true;\\n\\t\\tisExcludeFromWalletLimit[_tokenInfo.marketingFeeReceiver] = true;\\n\\t\\tisExcludeFromWalletLimit[_tokenInfo.devFeeReceiver] = true;\\n\\t\\tisExcludeFromWalletLimit[swapPair] = true;\\n\\n\\t\\tsuper._transferOwnership(_tokenInfo.newOwner);\\n\\t\\tsuper._mint(_tokenInfo.newOwner, _tokenInfo.totalSupply);\\n\\t\\t_approve(address(this), tokenInfo.swapRouter, type(uint256).max);\\n\\t\\tinitialised=true;\\n\\t}\\n\\n\\t \\n\\n\\t\\n\\n\\tfunction getTokenInfo() public view returns (TokenInfo memory _tokenInfo) {\\n\\t\\t_tokenInfo = tokenInfo;\\n\\t}\\n\\n\\tfunction totalBuyTaxFees() public view returns (uint256) {\\n\\t\\treturn tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\\n\\t}\\n\\n\\tfunction totalSellTaxFees() public view returns (uint256) {\\n\\t\\treturn tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\\n\\t}\\n\\n\\tfunction totalTaxFees() public view returns (uint256) {\\n\\t\\treturn totalBuyTaxFees() + totalSellTaxFees();\\n\\t}\\n\\n\\tfunction getMarketingBuyTax() external view returns (uint256) {\\n\\t\\treturn tokenInfo.marketingTaxBuy;\\n\\t}\\n\\n\\tfunction getMarketingSellTax() external view returns (uint256) {\\n\\t\\treturn tokenInfo.marketingTaxSell;\\n\\t}\\n\\n\\tfunction getDevBuyTax() external view returns (uint256) {\\n\\t\\treturn tokenInfo.devTaxBuy;\\n\\t}\\n\\n\\tfunction getDevSellTax() external view returns (uint256) {\\n\\t\\treturn tokenInfo.devTaxSell;\\n\\t}\\n\\n\\tfunction getLpBuyTax() external view returns (uint256) {\\n\\t\\treturn tokenInfo.lpTaxBuy;\\n\\t}\\n\\n\\tfunction getLpSellTax() external view returns (uint256) {\\n\\t\\treturn tokenInfo.lpTaxSell;\\n\\t}\\n\\n\\tfunction setExclusionFromFee(address account, bool value) public onlyOwner {\\n\\t\\tisExcludeFromFee[account] = value;\\n\\t}\\n\\n\\tfunction setExclusionFromTxLimit(address account, bool value) public onlyOwner {\\n\\t\\tisExcludeFromTxLimit[account] = value;\\n\\t}\\n\\n\\tfunction setExclusionFromWalletLimit(address account, bool value) public onlyOwner {\\n\\t\\tisExcludeFromWalletLimit[account] = value;\\n\\t}\\n\\n\\tfunction updateMarketingWallet(address newWallet) external onlyOwner {\\n\\t\\taddress oldWallet = tokenInfo.marketingFeeReceiver;\\n\\t\\ttokenInfo.marketingFeeReceiver = newWallet;\\n\\n\\t\\temit MarketingWalletUpdated(newWallet, oldWallet);\\n\\t}\\n\\n\\tfunction updateDevWallet(address newWallet) external onlyOwner {\\n\\t\\taddress oldWallet = tokenInfo.marketingFeeReceiver;\\n\\t\\ttokenInfo.devFeeReceiver = newWallet;\\n\\n\\t\\temit DevWalletUpdated(newWallet, oldWallet);\\n\\t}\\n\\n\\tfunction updateMarketingBuyTax(uint256 tax) external onlyOwner {\\n\\t\\ttokenInfo.marketingTaxBuy = tax;\\n\\t\\trequire(totalBuyTaxFees() <= 15 ether, \\\"TDP1\\\");\\n\\t}\\n\\n\\tfunction updateMarketingSellTax(uint256 tax) external onlyOwner {\\n\\t\\ttokenInfo.marketingTaxSell = tax;\\n\\t\\trequire(totalSellTaxFees() <= 15 ether, \\\"TDP1\\\");\\n\\t}\\n\\n\\tfunction updateDevBuyTax(uint256 tax) external onlyOwner {\\n\\t\\ttokenInfo.devTaxBuy = tax;\\n\\t\\trequire(totalBuyTaxFees() <= 15 ether, \\\"TDP1\\\");\\n\\t}\\n\\n\\tfunction updateDevSellTax(uint256 tax) external onlyOwner {\\n\\t\\ttokenInfo.devTaxSell = tax;\\n\\t\\trequire(totalSellTaxFees() <= 15 ether, \\\"TDP1\\\");\\n\\t}\\n\\n\\tfunction updateLpBuyTax(uint256 tax) external onlyOwner {\\n\\t\\ttokenInfo.lpTaxBuy = tax;\\n\\t\\trequire(totalBuyTaxFees() <= 15 ether, \\\"TDP1\\\");\\n\\t}\\n\\n\\tfunction updateLpSellTax(uint256 tax) external onlyOwner {\\n\\t\\ttokenInfo.lpTaxSell = tax;\\n\\t\\trequire(totalSellTaxFees() <= 15 ether, \\\"TDP1\\\");\\n\\t}\\n\\n\\tfunction updateMaxWalletAmount(uint256 maxWallet) external onlyOwner {\\n\\t\\trequire(maxWallet <= 100 ether && maxWallet >= 0.5 ether, \\\"TDP4\\\");\\n\\t\\ttokenInfo.maxPercentageForWallet = maxWallet;\\n\\t\\tmaxAmountForWallet = (maxWallet * tokenInfo.totalSupply) / 100 ether;\\n\\t}\\n\\n\\tfunction updateMaxTransactionAmount(uint256 maxTx) external onlyOwner {\\n\\t\\trequire(maxTx <= 100 ether && maxTx >= 0.5 ether, \\\"TDP4\\\");\\n\\t\\ttokenInfo.maxPercentageForTx = maxTx;\\n\\t\\tmaxAmountForTx = (maxTx * tokenInfo.totalSupply) / 100 ether;\\n\\t}\\n\\n\\tfunction _swapAndAddLiquidity() internal onlySwapping {\\n\\t\\tuint256 totalFees = tokensForMarketing + tokensForDev + tokensForLiquidity + tokensForDeployer;\\n\\n\\t\\trequire(totalFees > 0);\\n\\n\\t\\taddress swapRouter = tokenInfo.swapRouter;\\n\\t\\tuint256 halfLpFee = tokensForLiquidity / 2;\\n\\t\\ttotalFees -= halfLpFee;\\n\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = address(this);\\n\\t\\tpath[1] = weth;\\n\\n\\t\\tuint256 beforeEthBalance = address(this).balance;\\n\\n\\t\\tIUniswapV2Router02(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\t\\ttotalFees,\\n\\t\\t\\t0,\\n\\t\\t\\tpath,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tblock.timestamp + 60\\n\\t\\t);\\n\\n\\t\\tuint256 ethBalance = address(this).balance - beforeEthBalance;\\n\\n\\t\\tuint256 lpTaxFeeETH = (ethBalance * halfLpFee) / totalFees;\\n\\t\\tuint256 marketingTaxFeeETH = (ethBalance * tokensForMarketing) / totalFees;\\n\\t\\tuint256 devTaxFeeETH = (ethBalance * tokensForDev) / totalFees;\\n\\t\\tuint256 taxFeeForDeployer = ethBalance - lpTaxFeeETH - marketingTaxFeeETH - devTaxFeeETH;\\n\\n\\t\\tif (marketingTaxFeeETH > 0) {\\n\\t\\t\\tpayable(tokenInfo.marketingFeeReceiver).transfer(marketingTaxFeeETH);\\n\\t\\t}\\n\\t\\tif (devTaxFeeETH > 0) {\\n\\t\\t\\tpayable(tokenInfo.devFeeReceiver).transfer(devTaxFeeETH);\\n\\t\\t}\\n\\t\\tif (taxFeeForDeployer > 0) {\\n\\t\\t\\tpayable(deployer).transfer(taxFeeForDeployer);\\n\\t\\t}\\n\\n\\t\\tif (lpTaxFeeETH > 0 && halfLpFee > 0) {\\n\\t\\t\\tIUniswapV2Router02(swapRouter).addLiquidityETH{ value: lpTaxFeeETH }(\\n\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\thalfLpFee,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\towner(),\\n\\t\\t\\t\\tblock.timestamp + 60\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\ttokensForMarketing = 0;\\n\\t\\ttokensForDev = 0;\\n\\t\\ttokensForLiquidity = 0;\\n\\t\\ttokensForDeployer = 0;\\n\\n\\t\\temit TransferFee(tokensForMarketing, tokensForDev, tokensForLiquidity);\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint256 amount) internal override {\\n\\t\\tif (!isExcludeFromTxLimit[from] && !isExcludeFromTxLimit[to])\\n\\t\\t\\trequire(maxAmountForTx >= amount, \\\"TDP2\\\");\\n\\t\\tif (!isExcludeFromWalletLimit[to])\\n\\t\\t\\trequire((balanceOf(to) + amount) <= maxAmountForWallet, \\\"TDP3\\\");\\n\\n\\t\\tif (amount == 0) {\\n\\t\\t\\tsuper._transfer(from, to, 0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tuint256 fees;\\n\\t\\tif (\\n\\t\\t\\t!swapping &&\\n\\t\\t\\t!isExcludeFromFee[from] &&\\n\\t\\t\\t!isExcludeFromFee[to] &&\\n\\t\\t\\t(from == swapPair || to == swapPair)\\n\\t\\t) {\\n\\t\\t\\tuint256 uBuyFee = totalBuyTaxFees() + deployerTax;\\n\\t\\t\\tuint256 uSellFee = totalSellTaxFees() + deployerTax;\\n\\n\\t\\t\\tif (from == swapPair && uBuyFee > 0) {\\n\\t\\t\\t\\tfees = (amount * uBuyFee) / (100 ether);\\n\\t\\t\\t\\ttokensForDeployer += (fees * deployerTax) / uBuyFee;\\n\\t\\t\\t\\ttokensForDev += (fees * tokenInfo.devTaxBuy) / uBuyFee;\\n\\t\\t\\t\\ttokensForLiquidity += (fees * tokenInfo.lpTaxBuy) / uBuyFee;\\n\\t\\t\\t\\ttokensForMarketing += (fees * tokenInfo.marketingTaxBuy) / uBuyFee;\\n\\t\\t\\t}\\n\\t\\t\\tif (to == swapPair && uSellFee > 0) {\\n\\t\\t\\t\\tfees = (amount * uSellFee) / (100 ether);\\n\\t\\t\\t\\ttokensForDeployer += (fees * deployerTax) / uSellFee;\\n\\t\\t\\t\\ttokensForDev += (fees * tokenInfo.devTaxSell) / uSellFee;\\n\\t\\t\\t\\ttokensForLiquidity += (fees * tokenInfo.lpTaxSell) / uSellFee;\\n\\t\\t\\t\\ttokensForMarketing += (fees * tokenInfo.marketingTaxSell) / uSellFee;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsuper._transfer(from, address(this), fees);\\n\\n\\t\\t\\tif (to == swapPair && fees > 0) {\\n\\t\\t\\t\\t_swapAndAddLiquidity();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsuper._transfer(from, to, amount - fees);\\n\\t}\\n\\n\\treceive() external payable {}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"StandardTokenontract\",\"type\":\"address\"}],\"name\":\"StandardTokenContractCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cardURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketingTaxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingTaxSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devTaxSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devTaxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTaxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTaxSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPercentageForWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPercentageForTx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"internalType\":\"struct IStandard.TokenInfo\",\"name\":\"_tokenInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_deployerTax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_deployFeeReceiver\",\"type\":\"address\"}],\"name\":\"createStandardTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"standardTokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createdContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"createdContractsByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreatedContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContractsCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Deploystandard", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}