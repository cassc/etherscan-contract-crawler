{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CrosswiseCompensator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\n\\r\\ninterface IsCRSS is IERC20 {\\r\\n    function enter(uint256 _amount) external;\\r\\n\\r\\n    function leave(uint256 _amount) external;\\r\\n\\r\\n    function enterFor(uint256 _amount, address _to) external;\\r\\n\\r\\n    function killswitch() external;\\r\\n\\r\\n    function rescueToken(address _token, uint256 _amount) external;\\r\\n\\r\\n    function rescueETH(uint256 _amount) external;\\r\\n\\r\\n    function impactFeeStatus(bool _value) external;\\r\\n\\r\\n    function setImpactFeeReceiver(address _feeReceiver) external;\\r\\n\\r\\n    function CRSStoSCRSS(uint256 _crssAmount, bool _impactFeeOn)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 crssAmount,\\r\\n            uint256 swapFee,\\r\\n            uint256 impactFee\\r\\n        );\\r\\n\\r\\n    function sCRSStoCRSS(uint256 _sCrssAmount, bool _impactFeeOn)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 crssAmount,\\r\\n            uint256 swapFee,\\r\\n            uint256 impactFee\\r\\n        );\\r\\n\\r\\n    event TradingHalted(uint256 timestamp);\\r\\n    event TradingResumed(uint256 timestamp);\\r\\n}\\r\\n\\r\\ninterface ICRSS is IERC20 {\\r\\n    function controlledMint(uint256 _amount) external;\\r\\n\\r\\n    function controlledMintTo(address _to, uint256 _amount) external;\\r\\n}\\r\\n\\r\\ncontract CRSSCompensator is Ownable, ReentrancyGuard {\\r\\n    //this object is used during initialization\\r\\n    struct CompensationObject {\\r\\n        address userAddress;\\r\\n        uint128 crssOwed;\\r\\n    }\\r\\n    //this represent core info of every users compensation\\r\\n    struct UserCompensation {\\r\\n        address userAddress;\\r\\n        uint128 totalCrssOwed;\\r\\n        uint128 crssClaimed;\\r\\n        \\r\\n    }\\r\\n    //object for CRSS that was claimed and vested\\r\\n    struct VestingObject {\\r\\n        uint128 crssAmount;\\r\\n        uint128 startTimestamp;\\r\\n    }\\r\\n    uint256 public constant vestDuration = 5 * (6 * 6 * 24 * 3044); //5months, 13150080s\\r\\n    address public immutable crssToken;\\r\\n    address public immutable sCrssToken;\\r\\n    uint256 public compensationStartBlock; //cannot be changed once initialized\\r\\n    uint256 public compensationEndBlock; //derived from startBlock and lengthInBlocks\\r\\n    uint256 public immutable compensationLengthInBlocks;\\r\\n    uint256 public constant totalCompensationInCrss = 406338778562862 * 10**10; //total CRSS compensation amount - 2 instant claim wallets, CRSS/block = 0.358\\r\\n                                                        \\r\\n    address public accountant; //this is where instant claim fees go to\\r\\n    \\r\\n    UserCompensation[] public orderedCompensations; //this corresponds to our google sheet compensation list, so addresses can be checked by google sheet index\\r\\n    uint256 private totalVesting; //total non-withdrawn and non-minted CRSS that was claimed\\r\\n    uint256 private totalWithdrawn; //total withdrawn from vesting/minted\\r\\n    mapping(address => UserCompensation) private userCompensation;\\r\\n    mapping(address => VestingObject[]) private userVestingInstances;\\r\\n    mapping(address => uint256) private userWithdrawn;\\r\\n\\r\\n    constructor(\\r\\n        address _crssToken,\\r\\n        address _sCrssToken,\\r\\n        uint256 _compensationLength\\r\\n    ) Ownable() ReentrancyGuard() {\\r\\n        compensationLengthInBlocks = _compensationLength; //11 352 960, eq to 1y+1m(1.08y)\\r\\n        crssToken = _crssToken;\\r\\n        sCrssToken = _sCrssToken;\\r\\n        IERC20(_crssToken).approve(_sCrssToken, type(uint256).max); //make sure sCRSS enterFor() works \\r\\n    }\\r\\n\\r\\n    function getUserAmount() public view returns (uint256) {\\r\\n        return orderedCompensations.length;\\r\\n    }\\r\\n\\r\\n    function addUsers(CompensationObject[] memory _userCompensations)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(\\r\\n            compensationStartBlock == 0,\\r\\n            \\\"cCRSS:Can't add users after compensation started\\\"\\r\\n        );\\r\\n        for (uint256 i = 0; i < _userCompensations.length; i++) {\\r\\n            UserCompensation memory userObject = UserCompensation({\\r\\n                userAddress: _userCompensations[i].userAddress,\\r\\n                totalCrssOwed: _userCompensations[i].crssOwed,\\r\\n                crssClaimed: 0\\r\\n            });\\r\\n            orderedCompensations.push(userObject);\\r\\n            userCompensation[_userCompensations[i].userAddress] = userObject;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function startCompensation() public onlyOwner {\\r\\n        require(compensationStartBlock == 0, \\\"cCRSS:Already started\\\");\\r\\n        compensationStartBlock = block.number;\\r\\n        compensationEndBlock = block.number + compensationLengthInBlocks;\\r\\n    }\\r\\n\\r\\n    function claimCompensation(uint128 _amount, bool _vesting)\\r\\n        public\\r\\n        nonReentrant\\r\\n    {\\r\\n        address msg_sender = _msgSender();\\r\\n        uint256 percentageClaimable;\\r\\n        UserCompensation storage user = userCompensation[msg_sender];\\r\\n        if (compensationStartBlock == 0) return;\\r\\n        uint blockDifference = block.number - compensationStartBlock;\\r\\n        if (\\r\\n            compensationLengthInBlocks > blockDifference\\r\\n        ) {\\r\\n            percentageClaimable = \\r\\n                (blockDifference * 1e6) /\\r\\n                    compensationLengthInBlocks\\r\\n            ;\\r\\n        } else percentageClaimable = 1e6; //100%\\r\\n\\r\\n        uint128 crssClaimable = (user.totalCrssOwed * uint128(percentageClaimable)) /\\r\\n            1e6 -\\r\\n            user.crssClaimed;\\r\\n\\r\\n        if (_amount <= crssClaimable) {\\r\\n            uint256 amount0 = uint256(_amount);\\r\\n            user.crssClaimed += _amount;\\r\\n\\r\\n            if (_vesting) {\\r\\n                userVestingInstances[msg_sender].push(\\r\\n                    VestingObject({\\r\\n                        crssAmount: _amount,\\r\\n                        startTimestamp: uint128(block.timestamp)\\r\\n                    })\\r\\n                );\\r\\n                totalVesting += amount0;\\r\\n            } else {\\r\\n                ICRSS(crssToken).controlledMint(amount0);\\r\\n                uint256 adjustedAmount = (amount0 * 3) / 4;\\r\\n                userWithdrawn[msg_sender] += amount0;\\r\\n                totalWithdrawn += amount0;\\r\\n                ICRSS(crssToken).transfer(msg_sender, adjustedAmount);\\r\\n                ICRSS(crssToken).transfer(accountant, amount0 - adjustedAmount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimAll(bool _vesting) public nonReentrant {\\r\\n        address msg_sender = _msgSender();\\r\\n        UserCompensation storage user = userCompensation[msg_sender];\\r\\n        uint256 percentageClaimable;\\r\\n        if (compensationStartBlock == 0) return;\\r\\n        if (\\r\\n            compensationLengthInBlocks > block.number - compensationStartBlock\\r\\n        ) {\\r\\n            percentageClaimable = \\r\\n                ((block.number - compensationStartBlock) * 1e6) /\\r\\n                    compensationLengthInBlocks;\\r\\n        } else percentageClaimable = 1e6; //100%\\r\\n\\r\\n        uint128 crssClaimable = (user.totalCrssOwed * uint128(percentageClaimable)) /\\r\\n            1e6 - user.crssClaimed;\\r\\n\\r\\n        if (crssClaimable > 0) {\\r\\n            uint256 amount0 = uint256(crssClaimable);\\r\\n            user.crssClaimed += crssClaimable;\\r\\n\\r\\n            if (_vesting) {\\r\\n                userVestingInstances[msg_sender].push(\\r\\n                    VestingObject({\\r\\n                        crssAmount: crssClaimable,\\r\\n                        startTimestamp: uint128(block.timestamp)\\r\\n                    })\\r\\n                );\\r\\n                totalVesting += amount0;\\r\\n            } else {\\r\\n                ICRSS(crssToken).controlledMint(amount0);\\r\\n                uint256 adjustedAmount = (amount0 * 3) / 4;\\r\\n                userWithdrawn[msg_sender] += adjustedAmount;\\r\\n                totalWithdrawn += amount0;\\r\\n                ICRSS(crssToken).transfer(accountant, amount0 - adjustedAmount);\\r\\n                ICRSS(crssToken).transfer(msg_sender, adjustedAmount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function massWithdrawVested() public nonReentrant {\\r\\n        address msg_sender = _msgSender();\\r\\n        VestingObject[] storage userVestArray = userVestingInstances[\\r\\n            msg_sender\\r\\n        ];\\r\\n        uint128 totalCrss = 0;\\r\\n        for (uint256 i = 0; i < userVestArray.length; i) {\\r\\n            if (\\r\\n                userVestArray[i].startTimestamp + vestDuration <=\\r\\n                block.timestamp\\r\\n            ) {\\r\\n                totalCrss += userVestArray[i].crssAmount;\\r\\n                userVestingInstances[msg_sender][i] = userVestingInstances[\\r\\n                    msg_sender\\r\\n                ][userVestingInstances[msg_sender].length - 1];\\r\\n                userVestingInstances[msg_sender].pop();\\r\\n            } else i++;\\r\\n        }\\r\\n        if (totalCrss > 0) {\\r\\n            uint256 adjustedVestAmount = uint256(totalCrss);\\r\\n            userWithdrawn[msg_sender] += adjustedVestAmount;\\r\\n            totalWithdrawn += adjustedVestAmount;\\r\\n            totalVesting -= adjustedVestAmount;\\r\\n            ICRSS(crssToken).controlledMintTo(msg_sender, adjustedVestAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawVested(uint256 _id) public nonReentrant {\\r\\n        address msg_sender = _msgSender();\\r\\n        VestingObject memory vestingInstance = userVestingInstances[msg_sender][\\r\\n            _id\\r\\n        ];\\r\\n        require(\\r\\n            vestingInstance.startTimestamp + vestDuration <= block.timestamp,\\r\\n            \\\"cCRSS:Not unlocked yet\\\"\\r\\n        );\\r\\n\\r\\n        userVestingInstances[msg_sender][_id] = userVestingInstances[\\r\\n            msg_sender\\r\\n        ][userVestingInstances[msg_sender].length - 1];\\r\\n        userVestingInstances[msg_sender].pop();\\r\\n        uint256 adjustedVestAmount = uint256(vestingInstance.crssAmount);\\r\\n        userWithdrawn[msg_sender] += adjustedVestAmount;\\r\\n        totalWithdrawn += adjustedVestAmount;\\r\\n        totalVesting -= adjustedVestAmount;\\r\\n        ICRSS(crssToken).controlledMintTo(msg_sender, adjustedVestAmount);\\r\\n    }\\r\\n\\r\\n    function withdrawAndGetSCRSS(uint256 _id) public nonReentrant {\\r\\n        address msg_sender = _msgSender();\\r\\n\\r\\n        VestingObject memory vestingInstance = userVestingInstances[msg_sender][\\r\\n            _id\\r\\n        ];\\r\\n        require(\\r\\n            vestingInstance.startTimestamp + vestDuration <= block.timestamp,\\r\\n            \\\"cCRSS:Not unlocked yet\\\"\\r\\n        );\\r\\n\\r\\n        userVestingInstances[msg_sender][_id] = userVestingInstances[\\r\\n            msg_sender\\r\\n        ][userVestingInstances[msg_sender].length - 1];\\r\\n        userVestingInstances[msg_sender].pop();\\r\\n        uint256 adjustedVestAmount = uint256(vestingInstance.crssAmount);\\r\\n        userWithdrawn[msg_sender] += adjustedVestAmount;\\r\\n        totalWithdrawn += adjustedVestAmount;\\r\\n        totalVesting -= adjustedVestAmount;\\r\\n        ICRSS(crssToken).controlledMint(adjustedVestAmount);\\r\\n        IsCRSS(sCrssToken).enterFor(adjustedVestAmount, msg_sender);\\r\\n    }\\r\\n\\r\\n    function massWithdrawAndGetSCRSS() public nonReentrant {\\r\\n        address msg_sender = _msgSender();\\r\\n        VestingObject[] storage userVestArray = userVestingInstances[\\r\\n            msg_sender\\r\\n        ];\\r\\n        uint128 totalCrss = 0;\\r\\n        for (uint256 i = 0; i < userVestArray.length; i) {\\r\\n            if (\\r\\n                userVestArray[i].startTimestamp + vestDuration <=\\r\\n                block.timestamp\\r\\n            ) {\\r\\n                totalCrss += userVestArray[i].crssAmount;\\r\\n                userVestingInstances[msg_sender][i] = userVestingInstances[\\r\\n                    msg_sender\\r\\n                ][userVestingInstances[msg_sender].length - 1];\\r\\n                userVestingInstances[msg_sender].pop();\\r\\n            } else i++;\\r\\n        }\\r\\n        if (totalCrss > 0) {\\r\\n            uint256 adjustedVestAmount = uint256(totalCrss);\\r\\n            userWithdrawn[msg_sender] += adjustedVestAmount;\\r\\n            totalWithdrawn += adjustedVestAmount;\\r\\n            totalVesting -= adjustedVestAmount;\\r\\n            ICRSS(crssToken).controlledMint(adjustedVestAmount);\\r\\n            IsCRSS(sCrssToken).enterFor(adjustedVestAmount, msg_sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserInfo(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 userClaimed,\\r\\n            uint256 userClaimable,\\r\\n            uint256 userVested,\\r\\n            uint256 userWithdrawnAmount,\\r\\n            uint256 userTotalOwed\\r\\n        )\\r\\n    {\\r\\n        UserCompensation memory userComp = userCompensation[_user];\\r\\n        userClaimed = userComp.crssClaimed;\\r\\n        userClaimable = getUserClaimable(_user);\\r\\n        userTotalOwed = userComp.totalCrssOwed;\\r\\n        userWithdrawnAmount = getUserWithdrawn(_user);\\r\\n        userVested = getUserWithdrawable(_user);\\r\\n    }\\r\\n\\r\\n    function getGlobalCompensationData()\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 totalWithdrawnCRSS,\\r\\n            uint256 totalVestingCRSS,\\r\\n            uint256 totalCompensationCRSS,\\r\\n            uint256 secondsUntilCompEnd\\r\\n        )\\r\\n    {\\r\\n        totalWithdrawnCRSS = getTotalWithdrawn();\\r\\n        totalVestingCRSS = getTotalVesting();\\r\\n        totalCompensationCRSS = totalCompensationInCrss;\\r\\n        secondsUntilCompEnd = secondsUntilCompensationEnds();\\r\\n    }\\r\\n    \\r\\n    function blocksUntilCompensationEnds()public view returns(uint blockAmount){\\r\\n        uint timeElapsed = block.number - compensationStartBlock;\\r\\n        blockAmount = compensationLengthInBlocks > timeElapsed ? compensationLengthInBlocks - timeElapsed : 0;\\r\\n    }\\r\\n\\r\\n    function secondsUntilCompensationEnds()public view returns(uint timeInSeconds){\\r\\n        uint blocksRemaining = blocksUntilCompensationEnds();\\r\\n        timeInSeconds = blocksRemaining * 3;\\r\\n    }\\r\\n\\r\\n    function getUserVestingInstance(address _user, uint256 _id)\\r\\n        public\\r\\n        view\\r\\n        returns (VestingObject memory userObject)\\r\\n    {\\r\\n        return userVestingInstances[_user][_id];\\r\\n    }\\r\\n\\r\\n    function getAllUserVestingInstances(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (VestingObject[] memory vestingArray)\\r\\n    {\\r\\n        return userVestingInstances[_user];\\r\\n    }\\r\\n\\r\\n    function getUserCompensation(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (UserCompensation memory userObject)\\r\\n    {\\r\\n        return userCompensation[_user];\\r\\n    }\\r\\n\\r\\n    function getUserCompensationById(uint256 _id)\\r\\n        public\\r\\n        view\\r\\n        returns (UserCompensation memory userObject)\\r\\n    {\\r\\n        return orderedCompensations[_id];\\r\\n    }\\r\\n\\r\\n    function getUserClaimed(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 crssAmount)\\r\\n    {\\r\\n        crssAmount = uint256(userCompensation[_user].crssClaimed);\\r\\n    }\\r\\n\\r\\n    function getUserWithdrawn(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 withdrawnCrss)\\r\\n    {\\r\\n        return userWithdrawn[_user];\\r\\n    }\\r\\n\\r\\n    function getTotalWithdrawn()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 totalWithdrawnCrss)\\r\\n    {\\r\\n        return totalWithdrawn;\\r\\n    }\\r\\n\\r\\n    function getTotalVesting() public view returns (uint256 totalVestingCrss) {\\r\\n        return totalVesting;\\r\\n    }\\r\\n\\r\\n    function getUserWithdrawable(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 withdrawableCrss)\\r\\n    {\\r\\n        VestingObject[] memory userVestArray = userVestingInstances[_user];\\r\\n\\r\\n        for (uint256 i = 0; i < userVestArray.length; i++) {\\r\\n            if (\\r\\n                userVestArray[i].startTimestamp + vestDuration <=\\r\\n                block.timestamp\\r\\n            ) {\\r\\n                uint256 vestedAmount = uint256(userVestArray[i].crssAmount);\\r\\n                withdrawableCrss += vestedAmount;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserClaimable(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 crssClaimable)\\r\\n    {\\r\\n        UserCompensation memory user = userCompensation[_user];\\r\\n        uint128 percentageClaimable;\\r\\n        if (\\r\\n            compensationLengthInBlocks > block.number - compensationStartBlock\\r\\n        ) {\\r\\n            percentageClaimable = uint128(\\r\\n                ((block.number - compensationStartBlock) * 1000000) /\\r\\n                    compensationLengthInBlocks\\r\\n            );\\r\\n        } else percentageClaimable = 1000000;\\r\\n\\r\\n        crssClaimable = uint256(\\r\\n            (user.totalCrssOwed * percentageClaimable) /\\r\\n                1000000 -\\r\\n                user.crssClaimed\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getUserVesting(address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (uint128 crssVesting)\\r\\n    {\\r\\n        VestingObject[] memory userVestArray = userVestingInstances[_user];\\r\\n\\r\\n        for (uint256 i = 0; i < userVestArray.length; i++) {\\r\\n            crssVesting += userVestArray[i].crssAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setAccountant(address _accountant) external onlyOwner {\\r\\n        accountant = _accountant;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_crssToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sCrssToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_compensationLength\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accountant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"crssOwed\",\"type\":\"uint128\"}],\"internalType\":\"struct CRSSCompensator.CompensationObject[]\",\"name\":\"_userCompensations\",\"type\":\"tuple[]\"}],\"name\":\"addUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksUntilCompensationEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_vesting\",\"type\":\"bool\"}],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_vesting\",\"type\":\"bool\"}],\"name\":\"claimCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compensationEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compensationLengthInBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compensationStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crssToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllUserVestingInstances\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"crssAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"startTimestamp\",\"type\":\"uint128\"}],\"internalType\":\"struct CRSSCompensator.VestingObject[]\",\"name\":\"vestingArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalCompensationData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnCRSS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVestingCRSS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCompensationCRSS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsUntilCompEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalVestingCrss\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnCrss\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crssClaimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crssAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserCompensation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"totalCrssOwed\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"crssClaimed\",\"type\":\"uint128\"}],\"internalType\":\"struct CRSSCompensator.UserCompensation\",\"name\":\"userObject\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getUserCompensationById\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"totalCrssOwed\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"crssClaimed\",\"type\":\"uint128\"}],\"internalType\":\"struct CRSSCompensator.UserCompensation\",\"name\":\"userObject\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userClaimable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userTotalOwed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserVesting\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"crssVesting\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getUserVestingInstance\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"crssAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"startTimestamp\",\"type\":\"uint128\"}],\"internalType\":\"struct CRSSCompensator.VestingObject\",\"name\":\"userObject\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawableCrss\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawnCrss\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massWithdrawAndGetSCRSS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massWithdrawVested\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderedCompensations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"totalCrssOwed\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"crssClaimed\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sCrssToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsUntilCompensationEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountant\",\"type\":\"address\"}],\"name\":\"setAccountant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCompensationInCrss\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdrawAndGetSCRSS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdrawVested\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CRSSCompensator", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000faca2b369724e73cf29f0f60d9b0db579af006df000000000000000000000000c7ffc95a172c082b5971c973c52d4d5067af87530000000000000000000000000000000000000000000000000000000000ad3b80", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}