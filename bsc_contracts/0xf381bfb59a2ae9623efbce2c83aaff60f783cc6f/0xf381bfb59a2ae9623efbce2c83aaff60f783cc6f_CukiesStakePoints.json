{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CukiesStakePoints.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ITRC721.sol\\\";\\nimport \\\"./ICukie.sol\\\";\\nimport \\\"./ICukiesPoints.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract CukiesStakePoints is Ownable {\\n    using SafeMath for uint256;\\n\\n\\n    mapping(address => uint256[]) public userTokens;\\n    mapping(uint256 => address) public tokenOwner;\\n    mapping(uint256 => uint256) public cukiesDate;\\n\\n    mapping(uint256 => uint256) public pointsToType;\\n    \\n    uint256 public maxCukies;\\n\\n    event Stake(\\n        address indexed user,\\n        uint256 tokenId,\\n        uint256 date\\n    ); \\n\\n    event Unstake(\\n        address indexed user,\\n        uint256 tokenId,\\n        uint256 date,\\n        uint256 points\\n    ); \\n\\n    ICukie public cukieToken;\\n    ICukiesPoints public cukiePoints;\\n    bool pause = false;\\n    uint256 pause_at;\\n\\n    constructor() public {\\n        pause = false;\\n        maxCukies = 10;\\n    }\\n\\n    function changePointsToType(uint256 _type, uint256 _value) public onlyOwner {\\n        pointsToType[_type] = _value.mul(1e7).div(86400);\\n    }\\n    \\n\\n    function changeMaxCukies(uint256 _maxCukies) public onlyOwner {\\n        maxCukies = _maxCukies;\\n    }\\n\\n    function changeToken(ICukie _cukieToken) public onlyOwner {\\n        cukieToken = _cukieToken;\\n    }\\n\\n    function changePause(bool _pause) public onlyOwner {\\n        pause = _pause;\\n        if(pause) {\\n            pause_at = now;\\n        } else {\\n            pause_at = now + 365 days;\\n        }\\n    }\\n\\n    function changePoints(ICukiesPoints _cukiePoints) public onlyOwner {\\n        cukiePoints = _cukiePoints;\\n    }\\n\\n    function ownerCukie(uint256 _tokenId) view public returns(address) {\\n        return cukieToken.ownerOf(_tokenId);\\n    }\\n    // TODO: getTokensOwner\\n    function getTokensOwner(address _address) view public returns(uint256[] memory) {\\n        return userTokens[_address];\\n    }\\n\\n    function recovery(uint256 _tokenId) public onlyOwner {\\n        cukieToken.transferFrom(address(this), tokenOwner[_tokenId], _tokenId);\\n    }\\n\\n    function stake(uint256 _tokenId) public {\\n        require(pause == false);\\n        require(userTokens[msg.sender].length < maxCukies);\\n        require(cukieToken.ownerOf(_tokenId) == msg.sender);\\n        ( uint256 generacion1 , , , , , , , , ) = (cukieToken.getCukie(_tokenId));\\n        require(generacion1 == 1);\\n\\n        tokenOwner[_tokenId] = msg.sender;\\n        userTokens[msg.sender].push(_tokenId);\\n        cukiesDate[_tokenId] = now;\\n\\n        // Realizamos el transfer del token al contrato\\n        cukieToken.transferFrom(msg.sender, address(this), _tokenId);\\n\\n        emit Stake(msg.sender, _tokenId, now);\\n    }\\n\\n    function unstake(uint256 _tokenId) public {\\n        require(tokenOwner[_tokenId] == msg.sender);\\n\\n        // Devolvemos el cukie\\n        cukieToken.transferFrom(address(this), tokenOwner[_tokenId], _tokenId);\\n        \\n        // asignamos los puntos que le token\\n        uint256 points = calcPoints(_tokenId);\\n        cukiePoints.mint(tokenOwner[_tokenId], points);\\n\\n        delete tokenOwner[_tokenId];\\n        uint256[] memory newArray = remove(userTokens[msg.sender], _tokenId);\\n        delete(userTokens[msg.sender]);\\n        userTokens[msg.sender] = newArray;\\n        delete cukiesDate[_tokenId];\\n        \\n        emit Unstake(msg.sender, _tokenId, now, points);\\n    }\\n\\n    function remove(uint256[] memory array, uint _tokenId) private pure returns(uint256[] memory) {\\n        require(array.length > 0);\\n\\n        if(array.length-1 == 0) return new uint256[](0);\\n        \\n        uint256[] memory newArray = new uint256[](array.length-1);\\n        uint y = 0;\\n        for (uint i = 0; i<array.length; i++){\\n            if(array[i] != _tokenId) {\\n                newArray[y] = array[i];\\n                y = y + 1;\\n            }\\n        }\\n        return newArray;\\n    }\\n\\n    function calcPoints(uint256 _tokenId) public view returns (uint256) {\\n        // TODO: poner fecha de cierre si ya se ha acabado el pool\\n        uint256 ago;\\n        if(pause) {\\n            ago = pause_at.sub(cukiesDate[_tokenId]);\\n        } else {\\n            ago = now.sub(cukiesDate[_tokenId]);\\n        }\\n\\n        return ago.mul(pointsToType[getType(_tokenId)]).div(1e7);\\n    }\\n\\n    function getType(uint256 _tokenId) public pure returns (uint256) {\\n        return (_tokenId/1e12) - ((_tokenId/1e14) * (2));\\n    }\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/ITRC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\nimport './ITRC165.sol';\\n\\n/**\\n * @dev Required interface of an TRC721 compliant contract.\\n */\\ncontract ITRC721 is ITRC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\"\r\n    },\r\n    \"contracts/ICukie.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\n\\nimport './ITRC721.sol';\\nimport './ITRC721Metadata.sol';\\n\\n\\n/**\\n * @title TRC721MetadataMintable\\n * @dev TRC721 minting logic with metadata.\\n */\\ncontract ICukie is ITRC721, ITRC721Metadata {\\n    \\n    function mintWithTokenURI(address to, uint256 typeId, uint256 generation, uint8[6] memory skills, uint8 energy, uint8 health) public returns (bool);\\n    function mintWithTokenURI(address to, uint256 typeId, uint256 generation, uint8[6] memory skills, uint8 energy, uint8 health, uint256 tokenId) public returns (bool);\\n    function totalSupply() public view returns (uint256);\\n    function getType(uint256 _index)  view public returns (uint256 ,  \\n                                                    uint256 , \\n                                                    uint256 , \\n                                                    uint256 );\\n\\n    function addType(uint256 probability, uint256 tokenId) public;\\n    function burn(uint256 nftId) public;\\n\\n    function getCukie(uint256 index) view public returns (uint256, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8);\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ICukiesPoints.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\n\\ninterface ICukiesPoints {\\n\\n    function mint(address to, uint256 points) external;\\n\\n    function burn(address to, uint256 points) external;\\n\\n    function getPoints(address _address) external view returns(uint256);\\n\\n    function getTotalPointsEmited() external view returns(uint256);\\n    \\n    function getTotalPoints() external view returns(uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address private _owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    _owner = msg.sender;\\n  }\\n\\n  /**\\n   * @return the address of the owner.\\n   */\\n  function owner() public view returns(address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(isOwner());\\n    _;\\n  }\\n\\n  /**\\n   * @return true if `msg.sender` is the owner of the contract.\\n   */\\n  function isOwner() public view returns(bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(_owner);\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\"\r\n    },\r\n    \"contracts/ITRC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.4;\\n\\n/**\\n * @dev Interface of the TRC165 standard.\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({TRC165Checker}).\\n *\\n * For an implementation, see {TRC165}.\\n */\\ninterface ITRC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ITRC721Metadata.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.5.4;\\n/**\\n * @title TRC-721 Non-Fungible Token Standard, optional metadata extension\\n */\\nimport './ITRC721.sol';\\n \\ncontract ITRC721Metadata is ITRC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pointsToType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cukiePoints\",\"type\":\"address\"}],\"name\":\"changePoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxCukies\",\"type\":\"uint256\"}],\"name\":\"changeMaxCukies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changePointsToType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"changePause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cukieToken\",\"type\":\"address\"}],\"name\":\"changeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokensOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cukiesDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cukiePoints\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerCukie\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCukies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"calcPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cukieToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "CukiesStakePoints", "CompilerVersion": "v0.5.4+commit.9549d8ff", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}