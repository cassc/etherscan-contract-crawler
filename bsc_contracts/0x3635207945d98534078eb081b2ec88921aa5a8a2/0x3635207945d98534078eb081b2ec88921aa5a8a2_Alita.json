{"SourceCode": "pragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: SimPL-2.0\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns(bool);\r\n}\r\n\r\ninterface IERC721 /* is ERC165 */ {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns(uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns(address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns(address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns(bool);\r\n}\r\n\r\ninterface IERC721Metadata /* is ERC721 */ {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC721TokenReceiverEx is IERC721TokenReceiver {\r\n    function onERC721ExReceived(address operator, address from,\r\n        uint256[] memory tokenIds, bytes memory data)\r\n        external returns(bytes4);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Util {\r\n    bytes4 internal constant ERC721_RECEIVER_RETURN = 0x150b7a02;\r\n    bytes4 internal constant ERC721_RECEIVER_EX_RETURN = 0x0f7b88e3;\r\n    \r\n    uint256 public constant UDENO = 10 ** 10;\r\n    int256 public constant SDENO = 10 ** 10;\r\n    \r\n    uint256 public constant RARITY_WHITE = 0;\r\n    uint256 public constant RARITY_GREEN = 1;\r\n    uint256 public constant RARITY_BLUE = 2;\r\n    uint256 public constant RARITY_PURPLE = 3;\r\n    uint256 public constant RARITY_ORANGE = 4;\r\n    uint256 public constant RARITY_GOLD = 5;\r\n    \r\n    bytes public constant BASE64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\r\n    \r\n    function randomUint(bytes memory seed, uint256 min, uint256 max)\r\n        internal pure returns(uint256) {\r\n        \r\n        if (min >= max) {\r\n            return min;\r\n        }\r\n        \r\n        uint256 number = uint256(keccak256(seed));\r\n        return number % (max - min + 1) + min;\r\n    }\r\n    \r\n    function randomInt(bytes memory seed, int256 min, int256 max)\r\n        internal pure returns(int256) {\r\n        \r\n        if (min >= max) {\r\n            return min;\r\n        }\r\n        \r\n        int256 number = int256(keccak256(seed));\r\n        return number % (max - min + 1) + min;\r\n    }\r\n    \r\n    function randomWeight(bytes memory seed, uint256[] memory weights,\r\n        uint256 totalWeight) internal pure returns(uint256) {\r\n        \r\n        uint256 number = Util.randomUint(seed, 1, totalWeight);\r\n        \r\n        for (uint256 i = weights.length - 1; i != 0; --i) {\r\n            if (number <= weights[i]) {\r\n                return i;\r\n            }\r\n            \r\n            number -= weights[i];\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n    \r\n    function randomProb(bytes memory seed, uint256 nume, uint256 deno)\r\n        internal pure returns(bool) {\r\n        \r\n        uint256 rand = Util.randomUint(seed, 1, deno);\r\n        return rand <= nume;\r\n    }\r\n    \r\n    function base64Encode(bytes memory bs) internal pure returns(string memory) {\r\n        uint256 remain = bs.length % 3;\r\n        uint256 length = bs.length / 3 * 4;\r\n        bytes memory result = new bytes(length + (remain != 0 ? 4 : 0) + (3 - remain) % 3);\r\n        \r\n        uint256 i = 0;\r\n        uint256 j = 0;\r\n        while (i != length) {\r\n            result[i++] = Util.BASE64_CHARS[uint8(bs[j] >> 2)];\r\n            result[i++] = Util.BASE64_CHARS[uint8((bs[j] & 0x03) << 4 | bs[j + 1] >> 4)];\r\n            result[i++] = Util.BASE64_CHARS[uint8((bs[j + 1] & 0x0f) << 2 | bs[j + 2] >> 6)];\r\n            result[i++] = Util.BASE64_CHARS[uint8(bs[j + 2] & 0x3f)];\r\n            \r\n            j += 3;\r\n        }\r\n        \r\n        if (remain != 0) {\r\n            result[i++] = Util.BASE64_CHARS[uint8(bs[j] >> 2)];\r\n            \r\n            if (remain == 2) {\r\n                result[i++] = Util.BASE64_CHARS[uint8((bs[j] & 0x03) << 4 | bs[j + 1] >> 4)];\r\n                result[i++] = Util.BASE64_CHARS[uint8((bs[j + 1] & 0x0f) << 2)];\r\n                result[i++] = Util.BASE64_CHARS[0];\r\n                result[i++] = 0x3d;\r\n            } else {\r\n                result[i++] = Util.BASE64_CHARS[uint8((bs[j] & 0x03) << 4)];\r\n                result[i++] = Util.BASE64_CHARS[0];\r\n                result[i++] = Util.BASE64_CHARS[0];\r\n                result[i++] = 0x3d;\r\n                result[i++] = 0x3d;\r\n            }\r\n        }\r\n        \r\n        return string(result);\r\n    }\r\n}\r\n\r\nabstract contract ERC721 is IERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    \r\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    bytes4 private constant INTERFACE_ID_ERC721Metadata = 0x5b5e139f;\r\n    string public override name;\r\n    string public override symbol;\r\n    uint256 public totalSupply = 0;\r\n    string public uriPrefix = \"\";\r\n    mapping(address => uint256[]) internal ownerTokens;         //\u73a9\u5bb6\u62e5\u6709\u4ee3\u5e01\u6570\u7ec4\r\n    mapping(uint256 => uint256) internal tokenIndexs;            //\u73a9\u5bb6\u62e5\u6709nft\u4ee3\u5e01\u6570\u7ec4\u4e2d\u7684index\r\n    mapping(uint256 => address) internal tokenOwners;         //\u6839\u636etokenId\u67e5\u8be2\u73a9\u5bb6\u5730\u5740\r\n    mapping(uint256 => address) internal tokenApprovals;        //\u4ee3\u5e01\u6388\u6743\r\n    mapping(address => mapping(address => bool)) internal approvalForAlls;       //owner\u5bf9\u5176\u4ed6\u5730\u5740\u7684\u6388\u6743\r\n    \r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n    \r\n    function balanceOf(address owner) external view override returns(uint256) {\r\n        require(owner != address(0), \"owner is zero address\");\r\n        return ownerTokens[owner].length;\r\n    }\r\n    \r\n    // [startIndex, endIndex)\r\n    function tokensOf(address owner, uint256 startIndex, uint256 endIndex) external view returns(uint256[] memory) {\r\n        require(owner != address(0), \"owner is zero address\");\r\n        uint256[] storage tokens = ownerTokens[owner];\r\n        if (endIndex == 0) {\r\n            return tokens;\r\n        }\r\n        require(startIndex < endIndex, \"invalid index\");\r\n        uint256[] memory result = new uint256[](endIndex - startIndex);\r\n        for (uint256 i = startIndex; i != endIndex; ++i) {\r\n            result[i] = tokens[i];\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function ownerOf(uint256 tokenId) external view override returns(address) {\r\n        address owner = tokenOwners[tokenId];\r\n        require(owner != address(0), \"nobody own the token\");\r\n        return owner;\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable override { //\u5408\u7ea6\u8f6c\u8d26\r\n        _transferFrom(from, to, tokenId);\r\n        if (to.isContract()) {\r\n            require(IERC721TokenReceiver(to)\r\n                .onERC721Received(msg.sender, from, tokenId, data)\r\n                == Util.ERC721_RECEIVER_RETURN,\r\n                \"onERC721Received() return invalid\");\r\n        }\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 tokenId) external payable override { //\u666e\u901a\u4ee3\u7406\u8f6c\u8d26\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n    \r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(from != address(0), \"from is zero address\");\r\n        require(to != address(0), \"to is zero address\");\r\n        require(from == tokenOwners[tokenId], \"from must be owner\");\r\n        require(msg.sender == from\r\n            || msg.sender == tokenApprovals[tokenId]\r\n            || approvalForAlls[from][msg.sender],\r\n            \"sender must be owner or approvaled\");\r\n        \r\n        if (tokenApprovals[tokenId] != address(0)) {\r\n            delete tokenApprovals[tokenId];\r\n        }\r\n        _removeTokenFrom(from, tokenId);\r\n        _addTokenTo(to, tokenId);\r\n        \r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n    \r\n    // ensure everything is ok before call it\r\n    function _removeTokenFrom(address from, uint256 tokenId) internal {\r\n        uint256 index = tokenIndexs[tokenId];  //0\r\n        uint256[] storage tokens = ownerTokens[from];    \r\n        uint256 indexLast = tokens.length - 1;   \r\n        // save gas\r\n        // if (index != indexLast) {\r\n            uint256 tokenIdLast = tokens[indexLast];   //1\r\n            tokens[index] = tokenIdLast;                 \r\n            tokenIndexs[tokenIdLast] = index;   //tokenIndexs[1]=0\r\n        // }\r\n        tokens.pop();   //\u5220\u9664owner\u62e5\u6709nft\u4ee3\u5e01\u6570\u7ec4\r\n        // delete tokenIndexs[tokenId]; // save gas\r\n        delete tokenOwners[tokenId];         //\u5220\u9664\u6620\u5c04\u8868\u4e2downer\u7684nft\u8bb0\u5f55\r\n    }\r\n    \r\n    // ensure everything is ok before call it\r\n    function _addTokenTo(address to, uint256 tokenId) internal {\r\n        uint256[] storage tokens = ownerTokens[to];\r\n        tokenIndexs[tokenId] = tokens.length;\r\n        tokens.push(tokenId);\r\n        tokenOwners[tokenId] = to;\r\n    }\r\n    \r\n    function approve(address to, uint256 tokenId)\r\n        external payable override {\r\n        address owner = tokenOwners[tokenId];\r\n        require(msg.sender == owner\r\n            || approvalForAlls[owner][msg.sender],\r\n            \"sender must be owner or approved for all\"\r\n        );\r\n        tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n    \r\n    function setApprovalForAll(address to, bool approved) external override {\r\n        approvalForAlls[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n    \r\n    function getApproved(uint256 tokenId)\r\n        external view override returns(address) {\r\n        require(tokenOwners[tokenId] != address(0),\r\n            \"nobody own then token\");\r\n        return tokenApprovals[tokenId];\r\n    }\r\n    \r\n    function isApprovedForAll(address owner, address operator)\r\n        external view override returns(bool) {\r\n        return approvalForAlls[owner][operator];\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceID)\r\n        external pure override returns(bool) {\r\n        return interfaceID == INTERFACE_ID_ERC165\r\n            || interfaceID == INTERFACE_ID_ERC721\r\n            || interfaceID == INTERFACE_ID_ERC721Metadata;\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        _addTokenTo(to, tokenId);\r\n        ++totalSupply;\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n    \r\n    function _burn(uint256 tokenId) internal {\r\n        address owner = tokenOwners[tokenId];\r\n        _removeTokenFrom(owner, tokenId);\r\n        \r\n        if (tokenApprovals[tokenId] != address(0)) {\r\n            delete tokenApprovals[tokenId];\r\n        }\r\n        \r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n    \r\n    function safeBatchTransferFrom(address from, address to,\r\n        uint256[] memory tokenIds) external {                   //\u6279\u91cf\u8f6c\u8d26\r\n        \r\n        safeBatchTransferFrom(from, to, tokenIds, \"\");\r\n    }\r\n    \r\n    function safeBatchTransferFrom(address from, address to,\r\n        uint256[] memory tokenIds, bytes memory data) public {\r\n        \r\n        batchTransferFrom(from, to, tokenIds);\r\n        \r\n        if (to.isContract()) {\r\n            require(IERC721TokenReceiverEx(to)\r\n                .onERC721ExReceived(msg.sender, from, tokenIds, data)\r\n                == Util.ERC721_RECEIVER_EX_RETURN,\r\n                \"onERC721ExReceived() return invalid\");\r\n        }\r\n    }\r\n    \r\n    function batchTransferFrom(address from, address to,\r\n        uint256[] memory tokenIds) public {\r\n        \r\n        require(from != address(0), \"from is zero address\");\r\n        require(to != address(0), \"to is zero address\");\r\n        \r\n        uint256 length = tokenIds.length;\r\n        address sender = msg.sender;\r\n        \r\n        bool approval = from == sender || approvalForAlls[from][sender];\r\n        \r\n        for (uint256 i = 0; i != length; ++i) {\r\n            uint256 tokenId = tokenIds[i];\r\n            \r\n            require(from == tokenOwners[tokenId], \"from must be owner\");\r\n            require(approval || sender == tokenApprovals[tokenId],\r\n                \"sender must be owner or approvaled\");\r\n            \r\n            if (tokenApprovals[tokenId] != address(0)) {\r\n                delete tokenApprovals[tokenId];\r\n            }\r\n            \r\n            _removeTokenFrom(from, tokenId);\r\n            _addTokenTo(to, tokenId);\r\n            \r\n            emit Transfer(from, to, tokenId);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary String {\r\n    function equals(string memory a, string memory b)\r\n        internal pure returns(bool) {\r\n        \r\n        bytes memory ba = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        \r\n        uint256 la = ba.length;\r\n        uint256 lb = bb.length;\r\n        \r\n        for (uint256 i = 0; i != la && i != lb; ++i) {\r\n            if (ba[i] != bb[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return la == lb;\r\n    }\r\n    \r\n    function concat(string memory a, string memory b)\r\n        internal pure returns(string memory) {\r\n            \r\n        bytes memory ba = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        bytes memory bc = new bytes(ba.length + bb.length);\r\n        \r\n        uint256 bal = ba.length;\r\n        uint256 bbl = bb.length;\r\n        uint256 k = 0;\r\n        \r\n        for (uint256 i = 0; i != bal; ++i) {\r\n            bc[k++] = ba[i];\r\n        }\r\n        for (uint256 i = 0; i != bbl; ++i) {\r\n            bc[k++] = bb[i];\r\n        }\r\n        \r\n        return string(bc);\r\n    }\r\n}\r\n\r\ncontract Alita is ERC721 {\r\n\r\n    address public contractowner;\r\n\r\n    using String for string;\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public constant NFT_TotalSupply = 345;\r\n    \r\n    uint256 public NFT_Id = 0;\r\n\r\n    bool paused = false;\r\n\r\n    mapping(uint256 => starAttributesStruct) public starAttributes;\r\n    mapping(address => bool) public devOwner;\r\n\r\n    event OfficalMint(address indexed origin, address indexed owner, uint256 TokenId);\r\n    event NftTransfer(address indexed from, address to, uint256 tokenid);\r\n\r\n    struct starAttributesStruct{\r\n      address origin;\r\n      uint256 stampFee;\r\n      bool offical;\r\n      bool is_sale;\r\n    }\r\n\r\n    constructor() ERC721(\"Alita\", \"ALT\") {\r\n        contractowner = msg.sender;\r\n    }\r\n\r\n    modifier onlyDev() {\r\n        require(contractowner == msg.sender, \"only dev\");\r\n        _;\r\n    }\r\n\r\n    function transfer(address to,uint256 tokenId) external payable returns(bool) {\r\n        require(starAttributes[tokenId].is_sale==false,'on sold');\r\n        _transferFrom(msg.sender, to, tokenId);\r\n        emit NftTransfer(msg.sender, to, tokenId);\r\n        return true;\r\n    }\r\n\r\n    function pauseOfficalMint(bool _switch) public onlyDev{\r\n        paused = _switch;\r\n    }\r\n    \r\n    function mintinternal(address origin, address to,uint256 stampFee) internal {\r\n        NFT_Id++;\r\n        require(NFT_Id <= NFT_TotalSupply,\"Already Max\");\r\n        starAttributes[NFT_Id].origin = origin;\r\n        starAttributes[NFT_Id].stampFee = stampFee;\r\n        starAttributes[NFT_Id].offical = true;\r\n        starAttributes[NFT_Id].is_sale = true;\r\n        _mint(to, NFT_Id);\r\n    }\r\n    \r\n    function burn(uint256 Id) external {\r\n        address owner = tokenOwners[Id];\r\n        require(msg.sender == owner || msg.sender == tokenApprovals[Id] || approvalForAlls[owner][msg.sender], \"msg.sender must be owner or approved\");\r\n        _burn(Id);\r\n    }\r\n\r\n    function OfficeBurn(uint256 Id) external onlyDev {\r\n        _burn(Id);\r\n    }\r\n    \r\n    function tokenURI(uint256 NftId) external view override returns(string memory) {\r\n        bytes memory bs = abi.encodePacked(NftId);\r\n        return uriPrefix.concat(\"nft/\").concat(Util.base64Encode(bs));\r\n    }\r\n    \r\n    function setUriPrefix(string memory prefix) external onlyDev {\r\n        uriPrefix = prefix;\r\n    }\r\n\r\n    function officalMint(address _to) external returns(uint256){//officalMint\r\n        require(devOwner[msg.sender]==true,' not owner');\r\n        require(paused == false, \"offical mint is paused\");\r\n        mintinternal(address(this),_to,50);\r\n        emit OfficalMint(address(this),_to,NFT_Id);\r\n        return NFT_Id;\r\n    }\r\n\r\n    function takeOwnership(address _address,bool _Is) public onlyDev{\r\n        devOwner[_address] = _Is;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"NftTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokenId\",\"type\":\"uint256\"}],\"name\":\"OfficalMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT_Id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_TotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"}],\"name\":\"OfficeBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractowner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"devOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"officalMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_switch\",\"type\":\"bool\"}],\"name\":\"pauseOfficalMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"setUriPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"starAttributes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stampFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"offical\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"is_sale\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_Is\",\"type\":\"bool\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NftId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Alita", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3c0d5cdfd25d35b27208904bd05f0d6f016a6332b8a04cd454d3e11019860f3d"}