{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/*\r\n\r\nFLDB coin\r\nwww.fldbcoin.com\r\n\r\n*/\r\n\r\n// File: @openzeppelin\\contracts\\utils\\Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\access\\Ownable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\n// pragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\utils\\math\\SafeMath.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\n// pragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\security\\ReentrancyGuard.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\n// pragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts\\FLDBcoin.sol\r\n\r\n//pragma solidity ^0.8.0;\r\npragma abicoder v2;\r\ninterface IBEP2E {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the BEP20 token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IPancakeswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IPancakeSwapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeRouter02.sol\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n//TODO - Inherit from ReentrancyGuard\r\ncontract FLDBcoin is Ownable, IBEP2E,ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n\r\n  string public _name; //token name\r\n  string public _symbol; //token symbol \r\n  uint private _totalSupply; //total supply\r\n  uint256 private _rTotal;\r\n  uint8 public _decimals; //the total number of decimal represenations\r\n  bool private _paused;\r\n\r\n  mapping(address => uint) private balances; //how token much does this address have\r\n  mapping(address => mapping(address => uint)) private allowances; //the amount approved by the owner to be spent on their behalf\r\n  mapping (address => uint256) private _rOwned;\r\n\r\n  event Unpaused(address account); // Emitted when the pause is triggered by `account`.\r\n  event Paused(address account); //Emitted when the pause is lifted by `account`.\r\n  event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\r\n  event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n  event SwapAndLiquify(\r\n      uint256 tokensSwapped,\r\n      uint256 ethReceived,\r\n      uint256 tokensIntoLiqudity\r\n  );\r\n\r\n  modifier lockTheSwap {\r\n      inSwapAndLiquify = true;\r\n      _;\r\n      inSwapAndLiquify = false;\r\n  }\r\n\r\n  //Wallet Addresses\r\n  address payable private partnershipFundAddress;\r\n  address payable private airdropFundAddress;\r\n  address payable private marketingFundAddress;\r\n  address payable private staffFundAddress;\r\n  address payable private burnFundAddress;\r\n  address payable private holdersFundAddress;\r\n\r\n  //router address\r\n  IPancakeRouter02 public pancakeswapV2Router;\r\n  address public pancakeswapV2Pair;\r\n  address public pancakeFactory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\r\n  address public pancakeRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n  address public WETH = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c); //Wrapped BNB (WBNB)\r\n  uint256 internal minLiquidityAmount; // Minimum amount of FLDB to add liquidity with\r\n  uint256 private liquidityFee; // Liquidity fee to be deducted from each trade\r\n  uint256 private previousLiquidityFee = liquidityFee;\r\n  uint256 private txFee;\r\n  uint256 private previousTaxFee = txFee;\r\n  uint256 private constant MAX = ~uint256(0);\r\n\r\n  bool inSwapAndLiquify;\r\n  bool public swapAndLiquifyEnabled = true;\r\n\r\n  mapping (address => bool) private _isExcludedFromFee;\r\n  mapping (address => bool) private _isExcluded;\r\n  address[] private _excluded;\r\n\r\n  uint256 private _buyFee;\r\n  uint256 private _sellFee;\r\n\r\n  bool private isPairCreated = false;\r\n  address public routerAddress;\r\n\r\n  constructor(address _routerAddress ,address _marketingFundAddress,uint256 _txFee,uint256 _liquidityPoolFee,uint256 _lpBuyFee,uint256 _lpSellFee) { //payable\r\n      _name = \"FLDB Coin\"; \r\n      _symbol = \"FLDB\";\r\n      _decimals = 18;\r\n      _totalSupply = 10000000000 * 10 ** 18;\r\n      _paused = false;\r\n      marketingFundAddress = payable(_marketingFundAddress);\r\n      routerAddress = _routerAddress;\r\n      txFee = _txFee;\r\n      liquidityFee = _liquidityPoolFee;\r\n      _buyFee = _lpBuyFee;\r\n      _sellFee = _lpSellFee;\r\n      minLiquidityAmount = (_totalSupply * 2 / 10000) * 10 ** _decimals;\r\n      //exclude owner and this contract from fee\r\n      _isExcludedFromFee[msg.sender] = true;\r\n      _isExcludedFromFee[address(this)] = true;\r\n      balances[msg.sender] = balances[msg.sender].add(_totalSupply);\r\n      emit Transfer(address(0), msg.sender, _totalSupply);\r\n  }\r\n\r\n  /**\r\n  * @dev Modifier to make a function callable only when the contract is not paused.\r\n  *\r\n  * Requirements:\r\n  *\r\n  * - The contract must not be paused.\r\n  */\r\n  modifier whenNotPaused() {\r\n    require(!paused(), \"Pausable: paused\");\r\n     _;\r\n  }\r\n\r\n  /**\r\n  * @dev Modifier to make a function callable only when the contract is paused.\r\n  *\r\n  * Requirements:\r\n  *\r\n  * - The contract must be paused.\r\n  */\r\n  modifier whenPaused() {\r\n    require(paused(), \"Pausable: not paused\");\r\n    _;\r\n  }\r\n\r\n  modifier liquidityPairCreated(){\r\n    require(isPairCreated == true,\"BEP2E: Liquidity Pair Does Not Exist\");\r\n    _;\r\n  }\r\n\r\n  modifier liquidityPairNotCreated(){\r\n    require(isPairCreated == false,\"BEP2E: Liquity Pair Exists\");\r\n    _;\r\n  }\r\n\r\n    modifier swapIsenabled(){\r\n        require(swapAndLiquifyEnabled == true,\"Swap Is Not Enabled\");\r\n        _;\r\n    }\r\n\r\n    modifier swapIsNotEnabled(){\r\n        require(swapAndLiquifyEnabled == false,\"Swap Is Enabled\");\r\n        _;\r\n    }\r\n  /**\r\n  * @dev Returns true if the contract is paused, and false otherwise.\r\n  */\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n   \r\n  /**\r\n  * @notice Token Name\r\n  * @return string token name\r\n  */\r\n  function name() public view override returns(string memory){\r\n    return _name;\r\n  }\r\n\r\n  /** \r\n  * @notice Token Symbol\r\n  * @return string symbol. The Token Symbol\r\n  */\r\n  function symbol() public view override returns(string memory){\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n  * @notice Total number of decimals for the FLDB\r\n  * @return uint number of decimals\r\n  */\r\n  function decimals() public view override returns(uint){\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n  * @notice Total token supply in circulation\r\n  * @return uint total supply\r\n  */\r\n  function totalSupply() public view override returns(uint){\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @notice Should return the address of contract owner\r\n  * @return address the owner address specified in the Ownable contract\r\n  */\r\n  function getOwner() public view override returns (address){\r\n    return owner();\r\n  }\r\n  \r\n  /**\r\n  * @notice how much token balance does this address have\r\n  * @dev the account should not be the zero address , address(0)\r\n  * @param _account account the address to which we want to determine their token balance\r\n  * @return uint the total balance of the specied address\r\n  */\r\n  function balanceOf(address _account) public view override returns (uint256){\r\n      return balances[_account];\r\n  }\r\n\r\n  /**\r\n  * @notice tTransfer a specicied amount pf tokens to a recipient address\r\n  * @dev Recipient address should not be an empty address address(0)\r\n  * @dev Sender's total balance must be equal to or greater than the amount specified\r\n  * @dev nonReentrant modifier protects this function from reentrancy attacks\r\n  * @param _recipient address the person receiving the tokens\r\n  * @param _amount uint the amount of tokens to be sent to the specied address as the recepient\r\n  * @return bool success if the transfer was successfull otherwise false\r\n  */\r\n  function transfer(address _recipient, uint _amount) public override whenNotPaused returns (bool){ //nonReentrant\r\n      _transfer(msg.sender, _recipient, _amount);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n  * @notice Transfer the specidied amount of tokens from the sender address to the recipient address\r\n  * @dev Both the sender and recipient address should not be the empty address, address(0)\r\n  * @dev the amount of tokens being moved from the sender to the recipient address should \r\n  * @dev not be less than the sender's total balances\r\n  * @dev the nonReentrant modifier protects this function from reentrancy attacks\r\n  * @param _sender address\r\n  * @param _recipient address\r\n  * @param _amount uint\r\n  * @return bool if the transfer event was successfull\r\n  */\r\n  function transferFrom(address _sender, address _recipient, uint _amount) public override whenNotPaused returns (bool) {\r\n    _transfer(_sender, _recipient, _amount);\r\n    _approve(_sender, _msgSender(), allowances[_sender][msg.sender].sub(_amount, \"BEP2E: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @notice Returns the amount that owner appoved as allowance for the spender\r\n  * @dev both the owner and spender addresses should not be empty addresse address(0)\r\n  * @param _owner address the owner address\r\n  * @param _spender address the spender address\r\n  * @return uint, the amount approved for spending\r\n  */\r\n  function allowance(address _owner, address _spender) public override view returns (uint256) {\r\n    return allowances[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n  * @notice eEnables the token holder to add a new address than can spend the tokens on their behalf\r\n  * @dev Spender address should not be an empty address(0)\r\n  * @dev the amount to be approved should not be less than the sender's balance\r\n  * @param _spender address, the approved address\r\n  * @param _amount uint , the amount to approved by the token holder\r\n  * @return bool true if success otherwise false\r\n  */\r\n  function approve(address _spender, uint _amount) public override whenNotPaused returns (bool) {\r\n    _approve(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   * @param _spender address \r\n   * @param _addedValue uint \r\n   * @return bool true if success otherwise false\r\n   */\r\n  function increaseAllowance(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\r\n    _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to spender by the caller\r\n   * @param _spender address \r\n   * @param _subtractedValue uint\r\n   * @return bool true if success otherwise false\r\n   */\r\n  function decreaseAllowance(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\r\n    uint currentAllowance = allowances[msg.sender][_spender];\r\n    require(currentAllowance >= _subtractedValue,\"BEP2E: Insufficient Allowance\");\r\n    _approve(msg.sender, _spender, allowances[msg.sender][_spender].sub(_subtractedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys amount tokens from account, reducing the\r\n   * total supply.\r\n   * @dev account cannot be the zero address.\r\n   * @dev account must have at least amount tokens.\r\n   * @param _account address\r\n   * @param _amount uint\r\n   * @return bool true if success otherwise false\r\n   */\r\n  function burn(address _account, uint _amount) public onlyOwner whenNotPaused returns(bool){\r\n    _burn(_account, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Triggers stopped state.\r\n  *\r\n  * Requirements:\r\n  *\r\n  * - The contract must not be paused.\r\n  */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(msg.sender);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns to normal state.\r\n  *\r\n  * Requirements:\r\n  *\r\n  * - The contract must be paused.\r\n  */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(msg.sender);\r\n  }\r\n\r\n  /**\r\n  * @notice creates a liquidity pool pair for the FLDB/WBNB(BNB) tokens if not created yet\r\n  * @dev should be called before\r\n  */\r\n  function createLiquidityPoolPair() public liquidityPairNotCreated onlyOwner returns(bool success){\r\n    IPancakeRouter02 _pancakeSwapV2Router = IPancakeRouter02(routerAddress);\r\n    pancakeswapV2Pair = IPancakeswapV2Factory(_pancakeSwapV2Router.factory()).createPair(address(this), _pancakeSwapV2Router.WETH()); \r\n    pancakeswapV2Router = _pancakeSwapV2Router;\r\n    isPairCreated == true;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @notice sets a new pancakeswapv2 router address\r\n  * @dev can only be triggered by the contract owner\r\n  * @param _newRouter address\r\n  */\r\n  function setRouterAddress(address _newRouter) external liquidityPairCreated onlyOwner {\r\n    require(_newRouter != address(0),\"FLDB: Invalid Router Address\");\r\n    IPancakeRouter02 _pancakeSwapV2Router = IPancakeRouter02(_newRouter);\r\n    pancakeswapV2Pair = IPancakeswapV2Factory(_pancakeSwapV2Router.factory()).createPair(address(this), _pancakeSwapV2Router.WETH()); \r\n    pancakeswapV2Router = _pancakeSwapV2Router;\r\n    routerAddress = _newRouter;\r\n  }\r\n\r\n  /**\r\n  * @notice enables the contract owner to set the pancakeswap liquidityFee\r\n  * @param _liquidityFee uint256\r\n  */\r\n  function setLiquidityFee(uint256 _liquidityFee) external onlyOwner() {\r\n      require(_liquidityFee != 0,\"FLDB: Fee cannot be zero\");\r\n      liquidityFee = _liquidityFee;\r\n  }\r\n\r\n  function setLiquidityPoolBuyFee(uint256 _fee) external onlyOwner{\r\n    require(_fee != 0,\"FLDB: Fee cannot be zero\");\r\n    _buyFee = _fee;\r\n  }\r\n\r\n  function setLiquidityPoolSellFee(uint256 _fee) external onlyOwner{\r\n    require(_fee != 0,\"FLDB: Fee cannot be zero\");\r\n    _sellFee = _fee;\r\n  }\r\n\r\n  function setSwapAndLiquifyEnabled() public onlyOwner swapIsNotEnabled  {\r\n      swapAndLiquifyEnabled = true;\r\n      emit SwapAndLiquifyEnabledUpdated(true);\r\n  }\r\n\r\n  /**\r\n  * @notice Calculates the liquidity fee based on the provided amount\r\n  * @param _amount the amount to calculate the liquidity fee against\r\n  */\r\n  function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\r\n      return _amount.mul(liquidityFee).div(\r\n            10**2\r\n        );\r\n  }\r\n\r\n  function calculateTaxFee(uint256 _amount) private view returns (uint256) {\r\n      return _amount.mul(txFee).div(\r\n          10**2\r\n      );\r\n  }\r\n  \r\n  function removeAllFee() private {\r\n      if(txFee == 0 && liquidityFee == 0) return;\r\n\r\n      previousTaxFee = txFee;\r\n      previousLiquidityFee = liquidityFee;\r\n\r\n      txFee = 0;\r\n      liquidityFee = 0;\r\n  }\r\n\r\n  function restoreAllFee() private {\r\n      txFee = previousTaxFee;\r\n      liquidityFee = previousLiquidityFee;\r\n  }\r\n\r\n  //to recieve BNB from pancakeswapV2Router when swaping\r\n  receive() external payable {}\r\n\r\n  function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\r\n      uint256 half = contractTokenBalance.div(2);\r\n      uint256 otherHalf = contractTokenBalance.sub(half);\r\n      uint256 initialBalance = address(this).balance;\r\n      swapTokensForBnb(half); \r\n      uint256 newBalance = address(this).balance.sub(initialBalance);\r\n      addLiquidity(otherHalf, newBalance);\r\n      emit SwapAndLiquify(half, newBalance, otherHalf);\r\n  }\r\n\r\n  /**\r\n  * @dev swaps FLDB/WBNB tokens\r\n  * @param _tokenAmount uint256\r\n  */\r\n  function swapTokensForBnb(uint256 _tokenAmount) private {\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = pancakeswapV2Router.WETH();\r\n    _approve(address(this), address(pancakeswapV2Router), _tokenAmount);\r\n    pancakeswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n      _tokenAmount,\r\n      0, // accept any amount of BNB\r\n      path,\r\n      address(this),\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @dev Adds Liquidity for the FLDB/WBNB tokens\r\n  * @param _fldbTokenAmount uint256 the FLDB amount\r\n  * @param _bnbTokenAmount uint256 the WBNB token amount\r\n  */\r\n  function addLiquidity(uint256 _fldbTokenAmount, uint256 _bnbTokenAmount) private{\r\n    _approve(address(this), address(pancakeswapV2Router), _fldbTokenAmount);\r\n    pancakeswapV2Router.addLiquidityETH{value: _bnbTokenAmount}(\r\n        address(this),\r\n        _fldbTokenAmount,\r\n        0, // slippage is unavoidable\r\n        0, // slippage is unavoidable\r\n        owner(),\r\n        block.timestamp\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @notice removes FLDB/WBNB liquidity\r\n  * @param _liquidityAmountToRemove uint256 the amount to tokens to remove from the FLDB/BNB Liquidity pool\r\n  * @notice TO-DO check that the liquidity amount to remove is not greator than the amount addedd previously as liquidity\r\n  */\r\n  function removeLiquidity(uint256 _liquidityAmountToRemove) public onlyOwner{\r\n    pancakeswapV2Router.removeLiquidityETH(\r\n      address(this),\r\n      _liquidityAmountToRemove,\r\n      0,\r\n      0, \r\n      owner(),\r\n      block.timestamp\r\n      );\r\n  }\r\n\r\n  function excludeFromReward(address _account) public onlyOwner() {\r\n        require(!_isExcluded[_account], \"Account is already excluded\");\r\n        _isExcluded[_account] = true;\r\n        _excluded.push(_account);\r\n  }\r\n\r\n  function includeInReward(address _account) external onlyOwner() {\r\n      require(_isExcluded[_account], \"Account is already included\");\r\n      for (uint256 i = 0; i < _excluded.length; i++) {\r\n          if (_excluded[i] == _account) {\r\n              _excluded[i] = _excluded[_excluded.length - 1];\r\n              balances[_account] = 0;\r\n              _isExcluded[_account] = false;\r\n              _excluded.pop();\r\n              break;\r\n        }\r\n      }\r\n  }\r\n\r\n  function withdraw(uint256 _amount) public onlyOwner nonReentrant returns(bool success){\r\n    uint256 accountBalance= address(this).balance;\r\n    require(accountBalance >= _amount,\"FLDB: Insufficient Withdrawal Balance\");\r\n    payable(msg.sender).transfer(_amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * -- INTERNAL FUNCTIONS -- \r\n  */\r\n  function _getChainID() private view returns (uint256) {\r\n    uint256 id;\r\n    assembly {\r\n        id := chainid()\r\n    }\r\n    return id;\r\n}\r\n  /**\r\n  * @dev Moves tokens amount from sender to recipient.\r\n  * @dev _sender cannot be the zero address.\r\n  * @dev recipient cannot be the zero address.\r\n  * @dev sender must have a balance of at least amount\r\n  * @param _sender address thes account sending the tokens amount\r\n  * @param _recipient address the account receiving the tokens\r\n  * @param _amount uint the token amount to be sent\r\n  */\r\n  function _transfer(address _sender, address _recipient, uint _amount) internal virtual {\r\n    require(_sender != address(0), \"BEP2E: transfer from the zero address\");\r\n    require(_recipient != address(0), \"BEP2E: transfer to the zero address\");\r\n\r\n    _beforeTokenTransfer(_sender, _recipient, _amount);\r\n\r\n    uint senderBalance = balances[_sender];\r\n\r\n    require(senderBalance >= _amount, \"BEP2E: transfer amount exceeds balance\");\r\n\r\n    uint256 chainId = _getChainID(); //block.chainid\r\n    \r\n    if(chainId == 97) //bsc testnet\r\n    {\r\n      balances[_sender] = balances[_sender].sub(_amount);\r\n      balances[_recipient] = balances[_recipient].add(_amount);\r\n      emit Transfer(_sender, _recipient, _amount);\r\n    }\r\n    else if(chainId == 56){ //bsc mainnet\r\n      uint256 contractTokenBalance = balanceOf(address(this));\r\n      //is the token balance of this contract address over the min number of\r\n      // tokens that we need to initiate a swap + liquidity lock?\r\n      //also, don't get caught in a circular liquidity event.\r\n      //also, don't swap & liquify if sender is uniswap pair.\r\n      bool overMinTokenBalance = contractTokenBalance >= minLiquidityAmount;\r\n      if (\r\n          isPairCreated == true &&\r\n          overMinTokenBalance &&\r\n          !inSwapAndLiquify &&\r\n          _sender != pancakeswapV2Pair &&\r\n          swapAndLiquifyEnabled\r\n      ) {\r\n            contractTokenBalance = minLiquidityAmount;\r\n            swapAndLiquify(contractTokenBalance);\r\n        }\r\n          \r\n        bool takeFee = true;\r\n        if(_isExcludedFromFee[_sender] || _isExcludedFromFee[_recipient]){\r\n            takeFee = false;\r\n        }\r\n      //transfer amount, it will take tax, burn, liquidity fee\r\n        _transferTokens(_sender,_recipient,_amount,takeFee); \r\n      }   \r\n  }\r\n\r\n  function _takeLiquidity(uint256 _tLiquidity) private {\r\n      if(_isExcluded[address(this)]){\r\n        balances[address(this)] = balances[address(this)].add(_tLiquidity);\r\n      }\r\n  }\r\n\r\n  function _takeFee(uint256 tDev) private {\r\n        if(_isExcluded[marketingFundAddress]){\r\n          balances[marketingFundAddress] = balances[marketingFundAddress].add(tDev);\r\n        }\r\n  }\r\n\r\n  //handles final token transfer taking into consideration the liquidity fees\r\n  function _transferTokens(address _sender, address _recipient, uint256 _amount, bool takeFee) private returns(bool success){\r\n    balances[_sender] = balances[_sender].sub(_amount);\r\n    uint256 amountReceived = (takeFee) ? takeTaxes(_sender, _recipient, _amount) : _amount;\r\n    balances[_recipient] = balances[_recipient].add(amountReceived);\r\n\r\n    (,uint256 txFeeAmount,uint256 liquidityFeeAmount ) = _getFeeAmountValues(_amount);\r\n    _takeLiquidity(liquidityFeeAmount);\r\n    _takeFee(txFeeAmount);\r\n    emit Transfer(_sender, _recipient, amountReceived);\r\n    return true;\r\n  }\r\n  \r\n  function takeTaxes(address from, address to, uint256 amount) internal returns (uint256) {\r\n      uint256 currentFee;\r\n      if (from == pancakeswapV2Pair) {\r\n          currentFee = _buyFee;\r\n      } else if (to == pancakeswapV2Pair) {\r\n          currentFee = _sellFee;\r\n       } else {\r\n           currentFee = txFee;\r\n       }\r\n\r\n\r\n       uint256 feeAmount = amount * currentFee / 10000;\r\n\r\n\r\n       balances[address(this)] = balances[address(this)].add(feeAmount);\r\n       emit Transfer(from, address(this), feeAmount);\r\n\r\n\r\n       return amount - feeAmount;\r\n  }\r\n\r\n  function _getFeeAmountValues(uint256 _tAmount) private view returns (uint256, uint256, uint256) {\r\n      uint256 tFee = calculateTaxFee(_tAmount);\r\n      uint256 tLiquidity = calculateLiquidityFee(_tAmount);\r\n      uint256 tTransferAmount = _tAmount.sub(tFee).sub(tLiquidity);\r\n      return (tTransferAmount, tFee, tLiquidity);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys amount tokens from account, reducing the\r\n   * total supply.\r\n   * @dev account cannot be the zero address.\r\n   * @dev account must have at least amount tokens.\r\n   * @param _account address\r\n   * @param _amount uint \r\n   */\r\n  function _burn(address _account, uint _amount) internal virtual {\r\n    require(_account != address(0), \"BEP2E: burn from the zero address\");\r\n\r\n    _beforeTokenTransfer(_account, address(0), _amount);\r\n\r\n    uint accountBalance = balances[_account];\r\n    require(accountBalance >= _amount,\"BEP2E: burn amount exceeds balance\");\r\n\r\n    balances[_account] = balances[_account].sub(_amount);\r\n    _totalSupply = _totalSupply.sub(_amount);\r\n    emit Transfer(_account, address(0), _amount);\r\n    _afterTokenTransfer(_account, address(0), _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets amount as the allowance of spender over the owner`s tokens.\r\n   * @dev owner cannot be the zero address.\r\n   * @dev spender cannot be the zero address.\r\n   * @param _owner address\r\n   * @param _spender address\r\n   * @param _amount uint  \r\n   */\r\n  function _approve(address _owner, address _spender, uint _amount) internal virtual {\r\n    require(_owner != address(0), \"BEP2E: approve from the zero address\");\r\n    require(_spender != address(0), \"BEP2E: approve to the zero address\");\r\n\r\n    allowances[_owner][_spender] = _amount;\r\n    emit Approval(_owner, _spender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n   * from the caller's allowance.\r\n   * @param _account address\r\n   * @param _amount uint \r\n   */\r\n  function _burnFrom(address _account, uint _amount) internal virtual {\r\n    _burn(_account, _amount);\r\n    _approve(_account, msg.sender, allowances[_account][msg.sender].sub(_amount));\r\n  }\r\n\r\n  /**\r\n  * @dev Hook that is called before any transfer of tokens. This includes\r\n  * minting and burning.\r\n  *\r\n  * Calling conditions:\r\n  *\r\n  * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n  * will be transferred to `to`.\r\n  * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n  * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n  * - `from` and `to` are never both zero.\r\n  *\r\n  * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n  */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n\r\n\r\n  /**\r\n  * @dev Hook that is called after any transfer of tokens. This includes\r\n  * minting and burning.\r\n  *\r\n  * Calling conditions:\r\n  *\r\n  * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n  * has been transferred to `to`.\r\n  * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n  * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n  * - `from` and `to` are never both zero.\r\n  *\r\n  * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n  */\r\n  function _afterTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}  \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_txFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityPoolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpSellFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"MinTokensBeforeSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createLiquidityPoolPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeswapV2Router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityAmountToRemove\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityPoolBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityPoolSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRouter\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FLDBcoin", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000005bbbd1d1f8f7283daf4cb76f542dec68890a34080000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://26345fb6afb6d5dd293c094bc43d0934209faad964d5f21e2efc84a341f7cd6a"}