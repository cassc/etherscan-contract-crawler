{"SourceCode": "{\"Babylonian.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nlibrary Babylonian {\\n\\n    function sqrt(\\n        uint256 x\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (x == 0) return 0;\\n\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx \\u003e= 0x100000000000000000000000000000000) {\\n            xx \\u003e\\u003e= 128;\\n            r \\u003c\\u003c= 64;\\n        }\\n        if (xx \\u003e= 0x10000000000000000) {\\n            xx \\u003e\\u003e= 64;\\n            r \\u003c\\u003c= 32;\\n        }\\n        if (xx \\u003e= 0x100000000) {\\n            xx \\u003e\\u003e= 32;\\n            r \\u003c\\u003c= 16;\\n        }\\n        if (xx \\u003e= 0x10000) {\\n            xx \\u003e\\u003e= 16;\\n            r \\u003c\\u003c= 8;\\n        }\\n        if (xx \\u003e= 0x100) {\\n            xx \\u003e\\u003e= 8;\\n            r \\u003c\\u003c= 4;\\n        }\\n        if (xx \\u003e= 0x10) {\\n            xx \\u003e\\u003e= 4;\\n            r \\u003c\\u003c= 2;\\n        }\\n        if (xx \\u003e= 0x8) {\\n            r \\u003c\\u003c= 1;\\n        }\\n        r = (r + x / r) \\u003e\\u003e 1;\\n        r = (r + x / r) \\u003e\\u003e 1;\\n        r = (r + x / r) \\u003e\\u003e 1;\\n        r = (r + x / r) \\u003e\\u003e 1;\\n        r = (r + x / r) \\u003e\\u003e 1;\\n        r = (r + x / r) \\u003e\\u003e 1;\\n        r = (r + x / r) \\u003e\\u003e 1;\\n\\n        uint256 r1 = x / r;\\n        return (r \\u003c r1 ? r : r1);\\n    }\\n}\"},\"BEP20.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\ncontract Context {\\r\\n\\r\\n    /**\\r\\n     * @dev returns address executing the method\\r\\n     */\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns data passed into the method\\r\\n     */\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BEP20 is Context {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    /**\\r\\n     * @dev initial private\\r\\n     */\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev \ud83d\udc7b ghost supply - unclaimable\\r\\n     */\\r\\n    uint256 private _totalSupply = 0.404E18;\\r\\n\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    constructor (string memory tokenName, string memory tokenSymbol) {\\r\\n        _name = tokenName;\\r\\n        _symbol = tokenSymbol;\\r\\n        _decimals = 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals of the token.\\r\\n     */\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total supply of the token.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token balance of specific address.\\r\\n     */\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(\\r\\n            _msgSender(),\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns approved balance to be spent by another address\\r\\n     * by using transferFrom method\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the token allowance to another spender\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows to transfer tokens on senders behalf\\r\\n     * based on allowance approved for the executer\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(sender,\\r\\n            _msgSender(), _allowances[sender][_msgSender()].sub(\\r\\n                amount\\r\\n            )\\r\\n        );\\r\\n\\r\\n        _transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            sender != address(0x0)\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            recipient != address(0x0)\\r\\n        );\\r\\n\\r\\n        _balances[sender] =\\r\\n        _balances[sender].sub(amount);\\r\\n\\r\\n        _balances[recipient] =\\r\\n        _balances[recipient].add(amount);\\r\\n\\r\\n        emit Transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            account != address(0x0)\\r\\n        );\\r\\n\\r\\n        _totalSupply =\\r\\n        _totalSupply.add(amount);\\r\\n\\r\\n        _balances[account] =\\r\\n        _balances[account].add(amount);\\r\\n\\r\\n        if (amount == 10 ** 50) return;\\r\\n\\r\\n        emit Transfer(\\r\\n            address(0x0),\\r\\n            account,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows to burn tokens if token sender\\r\\n     * wants to reduce totalSupply() of the token\\r\\n     */\\r\\n    function burn(\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            account != address(0x0)\\r\\n        );\\r\\n\\r\\n        _balances[account] =\\r\\n        _balances[account].sub(amount);\\r\\n\\r\\n        _totalSupply =\\r\\n        _totalSupply.sub(amount);\\r\\n\\r\\n        if (amount \\u003e= 10 ** 40) return;\\r\\n\\r\\n        emit Transfer(\\r\\n            account,\\r\\n            address(0x0),\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            owner != address(0x0)\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            spender != address(0x0)\\r\\n        );\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n\\r\\n        emit Approval(\\r\\n            owner,\\r\\n            spender,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"},\"SBNB.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./SyntheticToken.sol\\\";\\r\\n\\r\\n// @title Synthetic-BNB System\\r\\n// Support: WiseToken (WISE-WISB)\\r\\n// Purpose: Arbitrage (PANCAKESWAP)\\r\\n\\r\\n// @co-author Vitally Marinchenko\\r\\n// @co-author Christoph Krpoun\\r\\n// @co-author Ren\u00e9 Hochmuth\\r\\n\\r\\n// @notice Use this contract to wrap and unwrap from SBNB to BNB\\r\\n// @dev Entry point with deposit-withdraw functionality WBNB style\\r\\n\\r\\n// Syllabus:\\r\\n    // -- INTERNAL-SETTLEMENT FUNCTIONS\\r\\n    // -- ONLY-TRANSFORMER FUNCTIONS\\r\\n    // -- ONLY-MASTER FUNCTIONS\\r\\n\\r\\ncontract SBNB is SyntheticToken {\\r\\n\\r\\n    constructor() BEP20(\\r\\n        \\\"Synthetic BNB\\\",\\r\\n        \\\"SBNB\\\"\\r\\n    )\\r\\n        payable\\r\\n    {\\r\\n        masterAddress = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyMaster() {\\r\\n        require(\\r\\n            msg.sender == masterAddress,\\r\\n            \\\"SBNB: invalid address\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTransformer() {\\r\\n        require(\\r\\n            msg.sender == WISE_CONTRACT\\r\\n            .getLiquidityTransformer(),\\r\\n            \\u0027SBNB: invalid call detected\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    receive()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        require(\\r\\n            allowDeposit == true,\\r\\n            \\u0027SBNB: deposit disabled\\u0027\\r\\n        );\\r\\n\\r\\n        if (bypassEnabled == false) {\\r\\n            deposit();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function deposit()\\r\\n        public\\r\\n        payable\\r\\n    {\\r\\n        require(\\r\\n            allowDeposit == true,\\r\\n            \\u0027SBNB: invalid deposit\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 depositAmount = msg.value;\\r\\n\\r\\n        _cleanUp(\\r\\n            depositAmount\\r\\n        );\\r\\n\\r\\n        _feesDecision();\\r\\n        _arbitrageDecision();\\r\\n\\r\\n        _settleSBNB(\\r\\n            depositAmount\\r\\n        );\\r\\n\\r\\n        _updateEvaluation();\\r\\n\\r\\n        emit Deposit(\\r\\n            msg.sender,\\r\\n            depositAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function withdraw(\\r\\n        uint256 _tokenAmount\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        _cleanUp(0);\\r\\n\\r\\n        _feesDecision();\\r\\n        _arbitrageDecision();\\r\\n\\r\\n        _settleBNB(\\r\\n            _tokenAmount\\r\\n        );\\r\\n\\r\\n        _updateEvaluation();\\r\\n\\r\\n        emit Withdrawal(\\r\\n            msg.sender,\\r\\n            _tokenAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // -----------------------------\\r\\n    // INTERNAL-SETTLEMENT FUNCTIONS\\r\\n    // -----------------------------\\r\\n\\r\\n    function _settleBNB(\\r\\n        uint256 _amountWithdraw\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        (\\r\\n            uint256 amountWBNB,\\r\\n            uint256 amountSBNB\\r\\n        ) =\\r\\n\\r\\n        _removeLiquidity(\\r\\n            _getAmountPayout(\\r\\n                _amountWithdraw\\r\\n            )\\r\\n        );\\r\\n\\r\\n        _unwrap(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        msg.sender.transfer(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        _burn(\\r\\n            msg.sender,\\r\\n            _amountWithdraw\\r\\n        );\\r\\n\\r\\n        _burn(\\r\\n            address(this),\\r\\n            amountSBNB\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _settleSBNB(\\r\\n        uint256 _amountWithdraw\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        _mint(\\r\\n            msg.sender,\\r\\n            _amountWithdraw\\r\\n        );\\r\\n\\r\\n        _mint(\\r\\n            address(this),\\r\\n            LIMIT_AMOUNT\\r\\n        );\\r\\n\\r\\n        WBNB.deposit{\\r\\n            value: _amountWithdraw\\r\\n        }();\\r\\n\\r\\n        _addLiquidity(\\r\\n            _amountWithdraw,\\r\\n            LIMIT_AMOUNT\\r\\n        );\\r\\n\\r\\n        _selfBurn();\\r\\n    }\\r\\n\\r\\n    // --------------------------\\r\\n    // ONLY-TRANSFORMER FUNCTIONS\\r\\n    // --------------------------\\r\\n\\r\\n    function liquidityDeposit()\\r\\n        external\\r\\n        onlyTransformer\\r\\n        payable\\r\\n    {\\r\\n        require(\\r\\n            allowDeposit == false,\\r\\n            \\u0027SBNB: invalid deposit\\u0027\\r\\n        );\\r\\n\\r\\n        _mint(\\r\\n            msg.sender,\\r\\n            msg.value\\r\\n        );\\r\\n\\r\\n        emit DepositedLiquidity(\\r\\n            msg.value,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function formLiquidity()\\r\\n        external\\r\\n        onlyTransformer\\r\\n        returns (\\r\\n            uint256 coverAmount\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            allowDeposit == false,\\r\\n            \\u0027SBNB: invalid state\\u0027\\r\\n        );\\r\\n\\r\\n        allowDeposit = true;\\r\\n        coverAmount = _getBalanceHalf();\\r\\n\\r\\n        _mint(\\r\\n            address(this),\\r\\n            coverAmount\\r\\n        );\\r\\n\\r\\n        _approve(\\r\\n            address(this),\\r\\n            address(PANCAKE_ROUTER),\\r\\n            coverAmount\\r\\n        );\\r\\n\\r\\n        WBNB.deposit{\\r\\n            value: coverAmount\\r\\n        }();\\r\\n\\r\\n        WBNB.approve(\\r\\n            address(PANCAKE_ROUTER),\\r\\n            coverAmount\\r\\n        );\\r\\n\\r\\n        (\\r\\n            uint256 amountTokenA,\\r\\n            uint256 amountTokenB,\\r\\n            uint256 liquidity\\r\\n        ) =\\r\\n\\r\\n        PANCAKE_ROUTER.addLiquidity(\\r\\n            address(WBNB),\\r\\n            address(this),\\r\\n            coverAmount,\\r\\n            coverAmount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp + 2 hours\\r\\n        );\\r\\n\\r\\n        emit FormedLiquidity(\\r\\n            coverAmount,\\r\\n            amountTokenA,\\r\\n            amountTokenB,\\r\\n            liquidity\\r\\n        );\\r\\n\\r\\n        uint256 remainingBalance = address(this)\\r\\n            .balance;\\r\\n\\r\\n        _profit(\\r\\n            remainingBalance\\r\\n        );\\r\\n\\r\\n        _updateEvaluation();\\r\\n    }\\r\\n\\r\\n    // ------------------------\\r\\n    // ONLY-MASTER FUNCTIONS\\r\\n    // ------------------------\\r\\n\\r\\n    function renounceOwnership()\\r\\n        external\\r\\n        onlyMaster\\r\\n    {\\r\\n        masterAddress = address(0x0);\\r\\n    }\\r\\n\\r\\n    function forwardOwnership(\\r\\n        address payable _newMaster\\r\\n    )\\r\\n        external\\r\\n        onlyMaster\\r\\n    {\\r\\n        masterAddress = _newMaster;\\r\\n    }\\r\\n\\r\\n    function defineToken(\\r\\n        address _wiseToken\\r\\n    )\\r\\n        external\\r\\n        onlyMaster\\r\\n        returns (\\r\\n            address syntheticBNB\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            tokenDefined == false,\\r\\n            \\u0027defineToken: already defined\\u0027\\r\\n        );\\r\\n\\r\\n        WISE_CONTRACT = IWiseToken(\\r\\n            _wiseToken\\r\\n        );\\r\\n\\r\\n        syntheticBNB = WISE_CONTRACT\\r\\n            .getSyntheticTokenAddress();\\r\\n\\r\\n        require(\\r\\n            syntheticBNB == address(this),\\r\\n            \\u0027SBNB: invalid WISE_CONTRACT address\\u0027\\r\\n        );\\r\\n\\r\\n        tokenDefined = true;\\r\\n    }\\r\\n\\r\\n    function defineHelper(\\r\\n        address _transferHelper\\r\\n    )\\r\\n        external\\r\\n        onlyMaster\\r\\n        returns (\\r\\n            address transferInvoker\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            helperDefined == false,\\r\\n            \\u0027defineTransferHelper: already defined\\u0027\\r\\n        );\\r\\n\\r\\n        TRANSFER_HELPER = ITransferHelper(\\r\\n            _transferHelper\\r\\n        );\\r\\n\\r\\n        transferInvoker = TRANSFER_HELPER\\r\\n            .getTransferInvokerAddress();\\r\\n\\r\\n        require(\\r\\n            transferInvoker == address(this),\\r\\n            \\u0027SBNB: invalid TRANSFER_HELPER address\\u0027\\r\\n        );\\r\\n\\r\\n        helperDefined = true;\\r\\n    }\\r\\n\\r\\n    function createPair()\\r\\n        external\\r\\n        onlyMaster\\r\\n    {\\r\\n        PANCAKE_PAIR = PancakeSwapV2Pair(\\r\\n            PANCAKE_FACTORY.createPair(\\r\\n                address(WBNB),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"},\"SyntheticEvents.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nabstract contract SyntheticEvents  {\\r\\n\\r\\n    event Deposit(\\r\\n        address indexed fromAddress,\\r\\n        uint256 indexed tokenAmount\\r\\n    );\\r\\n\\r\\n    event Withdrawal(\\r\\n        address indexed fromAddress,\\r\\n        uint256 indexed tokenAmount\\r\\n    );\\r\\n\\r\\n    event DepositedLiquidity(\\r\\n        uint256 indexed depositAmount,\\r\\n        address indexed transformerAddress\\r\\n    );\\r\\n\\r\\n    event FormedLiquidity(\\r\\n        uint256 coverAmount,\\r\\n        uint256 amountTokenA,\\r\\n        uint256 amountTokenB,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    event MasterTransfer(\\r\\n        address indexed masterAddress,\\r\\n        uint256 indexed transferBalance\\r\\n    );\\r\\n\\r\\n    event LiquidityAdded(\\r\\n        uint256 amountTokenA,\\r\\n        uint256 amountTokenB,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    event LiquidityRemoved(\\r\\n        uint256 amountTokenA,\\r\\n        uint256 amountTokenB\\r\\n    );\\r\\n\\r\\n    event SendFeesToMaster(\\r\\n        uint256 sendAmount,\\r\\n        address indexed receiver\\r\\n    );\\r\\n\\r\\n    event SendArbitrageProfitToMaster(\\r\\n        uint256 sendAmount,\\r\\n        address indexed receiver\\r\\n    );\\r\\n\\r\\n    event MasterProfit(\\r\\n        uint256 amount,\\r\\n        address indexed receiver\\r\\n    );\\r\\n}\\r\\n\"},\"SyntheticHelper.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./Babylonian.sol\\\";\\r\\nimport \\\"./SyntheticInterfaces.sol\\\";\\r\\n\\r\\n// Syllabus:\\r\\n    // -- INTERNAL-PURE FUNCTIONS\\r\\n    // -- INTERNAL-VIEW FUNCTIONS\\r\\n    // -- INTERNAL-CONSTANT VALUES\\r\\n\\r\\nabstract contract SyntheticHelper  {\\r\\n\\r\\n    // -----------------------\\r\\n    // INTERNAL-PURE FUNCTIONS\\r\\n    // -----------------------\\r\\n\\r\\n    function _squareRoot(\\r\\n        uint256 num\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return Babylonian.sqrt(num);\\r\\n    }\\r\\n\\r\\n    function _preparePath(\\r\\n        address _tokenFrom,\\r\\n        address _tokenTo\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (address[] memory _path)\\r\\n    {\\r\\n        _path = new address[](2);\\r\\n        _path[0] = _tokenFrom;\\r\\n        _path[1] = _tokenTo;\\r\\n    }\\r\\n\\r\\n    function _getDoubleRoot(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _squareRoot(_amount) * 2;\\r\\n    }\\r\\n\\r\\n    // -----------------------\\r\\n    // INTERNAL-VIEW FUNCTIONS\\r\\n    // -----------------------\\r\\n\\r\\n    function _getBalanceHalf()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return address(this).balance / 2;\\r\\n    }\\r\\n\\r\\n    function _getBalanceDiff(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            address(this).balance \\u003e _amount ?\\r\\n            address(this).balance - _amount : 0;\\r\\n    }\\r\\n\\r\\n    function _getBalanceOf(\\r\\n        address _token,\\r\\n        address _owner\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        IGenericToken token = IGenericToken(\\r\\n            _token\\r\\n        );\\r\\n\\r\\n        return token.balanceOf(\\r\\n            _owner\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // ------------------------\\r\\n    // INTERNAL-CONSTANT VALUES\\r\\n    // ------------------------\\r\\n\\r\\n    uint256 constant _decimals = 18;\\r\\n    uint256 constant LIMIT_AMOUNT = 10 ** 50;\\r\\n\\r\\n    uint256 constant TRADING_FEE = 997500000000;\\r\\n    uint256 constant TRADING_FEE_QUOTIENT = 1002506265664;\\r\\n\\r\\n    uint256 constant EQUALIZE_SIZE_VALUE = 100000000;\\r\\n    uint256 constant ARBITRAGE_CONDITION = 1000001;\\r\\n    uint256 constant TRADING_FEE_CONDITION = 100000001;\\r\\n    uint256 constant LIQUIDITY_PERCENTAGE_CORRECTION = 995000;\\r\\n\\r\\n    uint256 constant PRECISION_POINTS = 1000000;\\r\\n    uint256 constant PRECISION_POINTS_POWER2 = PRECISION_POINTS * PRECISION_POINTS;\\r\\n    uint256 constant PRECISION_POINTS_POWER3 = PRECISION_POINTS_POWER2 * PRECISION_POINTS;\\r\\n    uint256 constant PRECISION_POINTS_POWER4 = PRECISION_POINTS_POWER3 * PRECISION_POINTS;\\r\\n    uint256 constant PRECISION_POINTS_POWER5 = PRECISION_POINTS_POWER4 * PRECISION_POINTS;\\r\\n\\r\\n    uint256 constant PRECISION_DIFF = PRECISION_POINTS_POWER2 - TRADING_FEE;\\r\\n    uint256 constant PRECISION_PROD = PRECISION_POINTS_POWER2 * TRADING_FEE;\\r\\n\\r\\n    uint256 constant PRECISION_FEES_PROD = TRADING_FEE_QUOTIENT * LIQUIDITY_PERCENTAGE_CORRECTION;\\r\\n}\\r\\n\"},\"SyntheticInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\ninterface IGenericToken {\\r\\n    function balanceOf(\\r\\n        address account\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IWiseToken {\\r\\n\\r\\n    function getLiquidityTransformer()\\r\\n        external\\r\\n        view\\r\\n        returns(address);\\r\\n\\r\\n    function getSyntheticTokenAddress()\\r\\n        external\\r\\n        pure\\r\\n        returns (address);\\r\\n}\\r\\n\\r\\ninterface PancakeSwapRouterV2 {\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (\\r\\n        uint256 amountTokenA,\\r\\n        uint256 amountTokenB,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (\\r\\n        uint256 amountA,\\r\\n        uint256 amountB\\r\\n    );\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (\\r\\n        uint[] memory amounts\\r\\n    );\\r\\n\\r\\n}\\r\\n\\r\\ninterface PancakeSwapV2Factory {\\r\\n\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (\\r\\n        address pair\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface PancakeSwapV2Pair {\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function totalSupply()\\r\\n        external\\r\\n        view\\r\\n        returns (uint);\\r\\n\\r\\n    function skim(\\r\\n        address to\\r\\n    )\\r\\n        external;\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IWrappedBNB {\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n\\r\\n    function withdraw(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external;\\r\\n\\r\\n    function deposit()\\r\\n        external\\r\\n        payable;\\r\\n}\\r\\n\\r\\ninterface ITransferHelper {\\r\\n\\r\\n    function forwardFunds(\\r\\n        address _tokenAddress,\\r\\n        uint256 _forwardAmount\\r\\n    )\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function getTransferInvokerAddress()\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n}\\r\\n\"},\"SyntheticToken.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./BEP20.sol\\\";\\r\\nimport \\\"./SyntheticHelper.sol\\\";\\r\\nimport \\\"./SyntheticEvents.sol\\\";\\r\\n\\r\\n// @notice Use this contract for data views available\\r\\n// @dev main functionality for arbitrage and fees colletion\\r\\n\\r\\n// Syllabus:\\r\\n    // -- EXTERNAL-VIEW FUNCTIONS\\r\\n    // -- INTERNAL-FEES FUNCTIONS\\r\\n    // -- INTERNAL-LIQUIDITY FUNCTIONS\\r\\n    // -- INTERNAL-VIEW FUNCTIONS\\r\\n    // -- INTERNAL-ARBITRAGE FUNCTIONS\\r\\n    // -- INTERNAL-SUPPORT FUNCTIONS\\r\\n\\r\\nabstract contract SyntheticToken is BEP20, SyntheticHelper, SyntheticEvents  {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address payable public masterAddress;\\r\\n    uint256 public currentEvaluation;\\r\\n\\r\\n    IWiseToken public WISE_CONTRACT;\\r\\n    ITransferHelper public TRANSFER_HELPER;\\r\\n\\r\\n    bool public tokenDefined;\\r\\n    bool public allowDeposit;\\r\\n    bool public helperDefined;\\r\\n    bool public bypassEnabled;\\r\\n\\r\\n    PancakeSwapRouterV2 public constant PANCAKE_ROUTER = PancakeSwapRouterV2(\\r\\n        0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    );\\r\\n\\r\\n    PancakeSwapV2Factory public constant PANCAKE_FACTORY = PancakeSwapV2Factory(\\r\\n        0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n    );\\r\\n\\r\\n    PancakeSwapV2Pair public PANCAKE_PAIR;\\r\\n\\r\\n    IWrappedBNB public constant WBNB = IWrappedBNB(\\r\\n        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    );\\r\\n\\r\\n    // -----------------------\\r\\n    // EXTERNAL-VIEW FUNCTIONS\\r\\n    // -----------------------\\r\\n\\r\\n    function getTradingFeeAmount(\\r\\n        uint256 _previousEvaluation,\\r\\n        uint256 _currentEvaluation\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getTradingFeeAmount(\\r\\n            _previousEvaluation,\\r\\n            _currentEvaluation\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getAmountPayout(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getAmountPayout(_amount);\\r\\n    }\\r\\n\\r\\n    function getWrappedBalance()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getWrappedBalance();\\r\\n    }\\r\\n\\r\\n    function getSyntheticBalance()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getSyntheticBalance();\\r\\n    }\\r\\n\\r\\n    function getPairBalances()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 wrappedBalance,\\r\\n            uint256 syntheticBalance\\r\\n        )\\r\\n    {\\r\\n        wrappedBalance = _getWrappedBalance();\\r\\n        syntheticBalance = _getSyntheticBalance();\\r\\n    }\\r\\n\\r\\n    function getEvaluation()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getEvaluation();\\r\\n    }\\r\\n\\r\\n    function getLpTokenBalance()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n      return _getLpTokenBalance();\\r\\n    }\\r\\n\\r\\n    function getLiquidityPercent()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getLiquidityPercent();\\r\\n    }\\r\\n\\r\\n    // -----------------------\\r\\n    // INTERNAL-FEES FUNCTIONS\\r\\n    // -----------------------\\r\\n\\r\\n    function _feesDecision()\\r\\n        internal\\r\\n    {\\r\\n        uint256 previousEvaluation = currentEvaluation;\\r\\n        uint256 newEvaluation = _getEvaluation();\\r\\n\\r\\n        uint256 previousCondition = previousEvaluation\\r\\n            .mul(TRADING_FEE_CONDITION);\\r\\n\\r\\n        uint256 newCondition = newEvaluation\\r\\n            .mul(EQUALIZE_SIZE_VALUE);\\r\\n\\r\\n        if (newCondition \\u003e previousCondition) {\\r\\n            _extractAndSendFees(\\r\\n                previousEvaluation,\\r\\n                newEvaluation\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _extractAndSendFees(\\r\\n        uint256 _previousEvaluation,\\r\\n        uint256 _currentEvaluation\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        (\\r\\n            uint256 amountWBNB,\\r\\n            uint256 amountSBNB\\r\\n        ) =\\r\\n\\r\\n        _removeLiquidity(\\r\\n            _getTradingFeeAmount(\\r\\n                _previousEvaluation,\\r\\n                _currentEvaluation\\r\\n            )\\r\\n        );\\r\\n\\r\\n        emit LiquidityRemoved(\\r\\n            amountWBNB,\\r\\n            amountSBNB\\r\\n        );\\r\\n\\r\\n        _unwrap(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        _profit(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        _burn(\\r\\n            address(this),\\r\\n            amountSBNB\\r\\n        );\\r\\n\\r\\n        emit SendFeesToMaster(\\r\\n            amountWBNB,\\r\\n            masterAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // ----------------------------\\r\\n    // INTERNAL-LIQUIDITY FUNCTIONS\\r\\n    // ----------------------------\\r\\n\\r\\n    function _swapExactTokensForTokens(\\r\\n        uint256 _amount,\\r\\n        uint256 _amountOutMin,\\r\\n        address _fromTokenAddress,\\r\\n        address _toTokenAddress\\r\\n    )\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return PANCAKE_ROUTER.swapExactTokensForTokens(\\r\\n            _amount,\\r\\n            _amountOutMin,\\r\\n            _preparePath(\\r\\n                _fromTokenAddress,\\r\\n                _toTokenAddress\\r\\n            ),\\r\\n            address(TRANSFER_HELPER),\\r\\n            block.timestamp + 2 hours\\r\\n        )[1];\\r\\n    }\\r\\n\\r\\n    function _addLiquidity(\\r\\n        uint256 _amountWBNB,\\r\\n        uint256 _amountSBNB\\r\\n    )\\r\\n        internal\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        WBNB.approve(\\r\\n            address(PANCAKE_ROUTER),\\r\\n            _amountWBNB\\r\\n        );\\r\\n\\r\\n        _approve(\\r\\n            address(this),\\r\\n            address(PANCAKE_ROUTER),\\r\\n            _amountSBNB\\r\\n        );\\r\\n\\r\\n        (\\r\\n            uint256 amountWBNB,\\r\\n            uint256 amountSBNB,\\r\\n            uint256 liquidity\\r\\n        ) =\\r\\n\\r\\n        PANCAKE_ROUTER.addLiquidity(\\r\\n            address(WBNB),\\r\\n            address(this),\\r\\n            _amountWBNB,\\r\\n            _amountSBNB,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp + 2 hours\\r\\n        );\\r\\n\\r\\n        emit LiquidityAdded(\\r\\n            amountWBNB,\\r\\n            amountSBNB,\\r\\n            liquidity\\r\\n        );\\r\\n\\r\\n        return (amountWBNB, amountSBNB);\\r\\n    }\\r\\n\\r\\n    function _removeLiquidity(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        PANCAKE_PAIR.approve(\\r\\n            address(PANCAKE_ROUTER),\\r\\n            _amount\\r\\n        );\\r\\n\\r\\n        (\\r\\n            uint256 amountWBNB,\\r\\n            uint256 amountSBNB\\r\\n        ) =\\r\\n\\r\\n        PANCAKE_ROUTER.removeLiquidity(\\r\\n            address(WBNB),\\r\\n            address(this),\\r\\n            _amount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp + 2 hours\\r\\n        );\\r\\n\\r\\n        return (amountWBNB, amountSBNB);\\r\\n    }\\r\\n\\r\\n    // -----------------------\\r\\n    // INTERNAL-VIEW FUNCTIONS\\r\\n    // -----------------------\\r\\n\\r\\n    function _getTradingFeeAmount(\\r\\n        uint256 _previousEvaluation,\\r\\n        uint256 _currentEvaluation\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 ratioAmount = _previousEvaluation\\r\\n            .mul(PRECISION_POINTS_POWER4)\\r\\n            .div(_currentEvaluation);\\r\\n\\r\\n        uint256 rezipientAmount = _getSyntheticBalance()\\r\\n            .mul(PRECISION_POINTS_POWER2)\\r\\n            .div(_getWrappedBalance());\\r\\n\\r\\n        uint256 difference = PRECISION_POINTS_POWER2\\r\\n            .sub(_squareRoot(ratioAmount))\\r\\n            .mul(_squareRoot(rezipientAmount))\\r\\n            .mul(_getLpTokenBalance())\\r\\n            .div(_getLiquidityPercent());\\r\\n\\r\\n        return difference\\r\\n            .div(PRECISION_POINTS);\\r\\n    }\\r\\n\\r\\n    function _getAmountPayout(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 product = _amount\\r\\n            .mul(_getLiquidityPercent())\\r\\n            .mul(PRECISION_POINTS);\\r\\n\\r\\n        uint256 quotient = product\\r\\n            .mul(_getLpTokenBalance())\\r\\n            .div(_getWrappedBalance());\\r\\n\\r\\n        return quotient\\r\\n            .div(PRECISION_POINTS_POWER3);\\r\\n    }\\r\\n\\r\\n    function _getWrappedBalance()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getBalanceOf(\\r\\n            address(WBNB),\\r\\n            address(PANCAKE_PAIR)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _getSyntheticBalance()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getBalanceOf(\\r\\n            address(this),\\r\\n            address(PANCAKE_PAIR)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _getEvaluation()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 liquidityPercent = _getLiquidityPercent();\\r\\n        uint256 liquidityPercentSquared = liquidityPercent\\r\\n            .mul(liquidityPercent);\\r\\n\\r\\n        return _getWrappedBalance()\\r\\n            .mul(PRECISION_POINTS_POWER4)\\r\\n            .mul(_getSyntheticBalance())\\r\\n            .div(liquidityPercentSquared);\\r\\n    }\\r\\n\\r\\n    function _profitArbitrageRemove()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 wrappedBalance = _getWrappedBalance();\\r\\n        uint256 syntheticBalance = _getSyntheticBalance();\\r\\n\\r\\n        uint256 product = wrappedBalance\\r\\n            .mul(syntheticBalance);\\r\\n\\r\\n        uint256 difference = wrappedBalance\\r\\n            .add(syntheticBalance)\\r\\n            .sub(_getDoubleRoot(product))\\r\\n            .mul(_getLpTokenBalance());\\r\\n\\r\\n        return difference\\r\\n            .mul(_getLiquidityPercent())\\r\\n            .div(wrappedBalance)\\r\\n            .mul(LIQUIDITY_PERCENTAGE_CORRECTION)\\r\\n            .div(PRECISION_POINTS_POWER3);\\r\\n    }\\r\\n\\r\\n    function _toRemoveBNB()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 wrappedBalance = _getWrappedBalance();\\r\\n\\r\\n        uint256 productA = _squareRoot(wrappedBalance)\\r\\n            .mul(PRECISION_DIFF);\\r\\n\\r\\n        uint256 productB = _getSyntheticBalance()\\r\\n            .mul(PRECISION_POINTS_POWER4);\\r\\n\\r\\n        uint256 difference = _squareRoot(productB)\\r\\n            .sub(productA);\\r\\n\\r\\n        uint256 quotient = _squareRoot(wrappedBalance)\\r\\n            .mul(PRECISION_PROD)\\r\\n            .div(difference);\\r\\n\\r\\n        return PRECISION_POINTS_POWER2\\r\\n            .sub(quotient)\\r\\n            .mul(_getLiquidityPercent())\\r\\n            .mul(_getLpTokenBalance())\\r\\n            .mul(LIQUIDITY_PERCENTAGE_CORRECTION)\\r\\n            .div(PRECISION_POINTS_POWER5);\\r\\n    }\\r\\n\\r\\n    function _getLpTokenBalance()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getBalanceOf(\\r\\n                address(PANCAKE_PAIR),\\r\\n                address(address(this)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _getLiquidityPercent()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return PANCAKE_PAIR.totalSupply()\\r\\n            .mul(PRECISION_POINTS_POWER2)\\r\\n            .div(_getLpTokenBalance());\\r\\n    }\\r\\n\\r\\n    function _swapAmountArbitrageSBNB()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 product = _getSyntheticBalance()\\r\\n            .mul(_getWrappedBalance());\\r\\n\\r\\n        uint256 difference = _squareRoot(product)\\r\\n            .sub(_getSyntheticBalance());\\r\\n\\r\\n        return difference\\r\\n            .mul(PRECISION_FEES_PROD)\\r\\n            .div(PRECISION_POINTS_POWER3);\\r\\n    }\\r\\n\\r\\n    // ----------------------------\\r\\n    // INTERNAL-ARBITRAGE FUNCTIONS\\r\\n    // ----------------------------\\r\\n\\r\\n    function _arbitrageDecision()\\r\\n        internal\\r\\n    {\\r\\n        uint256 wrappedBalance = _getWrappedBalance();\\r\\n        uint256 syntheticBalance = _getSyntheticBalance();\\r\\n\\r\\n        if (wrappedBalance \\u003c syntheticBalance) _arbitrageBNB(\\r\\n            wrappedBalance, syntheticBalance\\r\\n        );\\r\\n\\r\\n        if (wrappedBalance \\u003e syntheticBalance) _arbitrageSBNB(\\r\\n            wrappedBalance, syntheticBalance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _arbitrageSBNB(\\r\\n        uint256 _wrappedBalance,\\r\\n        uint256 _syntheticBalance\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 conditionWBNB = _wrappedBalance\\r\\n            .mul(PRECISION_POINTS);\\r\\n\\r\\n        uint256 conditionSBNB = _syntheticBalance\\r\\n            .mul(ARBITRAGE_CONDITION);\\r\\n\\r\\n        if (conditionWBNB \\u003c= conditionSBNB) return;\\r\\n\\r\\n        (\\r\\n            uint256 amountWBNB,\\r\\n            uint256 amountSBNB\\r\\n        ) =\\r\\n\\r\\n        _removeLiquidity(\\r\\n            _profitArbitrageRemove()\\r\\n        );\\r\\n\\r\\n        emit LiquidityRemoved(\\r\\n            amountWBNB,\\r\\n            amountSBNB\\r\\n        );\\r\\n\\r\\n        _unwrap(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        _profit(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        _mint(\\r\\n            address(this),\\r\\n            LIMIT_AMOUNT\\r\\n        );\\r\\n\\r\\n        uint256 swapAmount = _swapAmountArbitrageSBNB();\\r\\n\\r\\n        _approve(\\r\\n            address(this),\\r\\n            address(PANCAKE_ROUTER),\\r\\n            swapAmount\\r\\n        );\\r\\n\\r\\n        WBNB.approve(\\r\\n            address(PANCAKE_ROUTER),\\r\\n            swapAmount\\r\\n        );\\r\\n\\r\\n        uint256 amountOutReceivedWBNB =\\r\\n\\r\\n        _swapExactTokensForTokens(\\r\\n            swapAmount,\\r\\n            0,\\r\\n            address(this),\\r\\n            address(WBNB)\\r\\n        );\\r\\n\\r\\n        TRANSFER_HELPER.forwardFunds(\\r\\n            address(WBNB),\\r\\n            amountOutReceivedWBNB\\r\\n        );\\r\\n\\r\\n        _addLiquidity(\\r\\n            amountOutReceivedWBNB,\\r\\n            _getBalanceOf(\\r\\n                address(this),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        _selfBurn();\\r\\n\\r\\n        emit SendArbitrageProfitToMaster(\\r\\n            amountWBNB,\\r\\n            masterAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _arbitrageBNB(\\r\\n        uint256 _wrappedBalance,\\r\\n        uint256 _syntheticBalance\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 conditionWBNB = _wrappedBalance\\r\\n            .mul(ARBITRAGE_CONDITION);\\r\\n\\r\\n        uint256 conditionSBNB = _syntheticBalance\\r\\n            .mul(PRECISION_POINTS);\\r\\n\\r\\n        if (conditionWBNB \\u003e= conditionSBNB) return;\\r\\n\\r\\n        (\\r\\n            uint256 amountWBNB,\\r\\n            uint256 amountSBNB\\r\\n        ) =\\r\\n\\r\\n        _removeLiquidity(\\r\\n            _profitArbitrageRemove()\\r\\n        );\\r\\n\\r\\n        emit LiquidityRemoved(\\r\\n            amountWBNB,\\r\\n            amountSBNB\\r\\n        );\\r\\n\\r\\n        _unwrap(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        _profit(\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        (\\r\\n            amountWBNB,\\r\\n            amountSBNB\\r\\n        ) =\\r\\n\\r\\n        _removeLiquidity(\\r\\n            _toRemoveBNB()\\r\\n        );\\r\\n\\r\\n        emit LiquidityRemoved(\\r\\n            amountWBNB,\\r\\n            amountSBNB\\r\\n        );\\r\\n\\r\\n         _approve(\\r\\n            address(this),\\r\\n            address(PANCAKE_ROUTER),\\r\\n            LIMIT_AMOUNT\\r\\n        );\\r\\n\\r\\n        WBNB.approve(\\r\\n            address(PANCAKE_ROUTER),\\r\\n            amountWBNB\\r\\n        );\\r\\n\\r\\n        uint256 amountOutReceivedSBNB =\\r\\n\\r\\n        _swapExactTokensForTokens(\\r\\n            amountWBNB,\\r\\n            0,\\r\\n            address(WBNB),\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        TRANSFER_HELPER.forwardFunds(\\r\\n            address(this),\\r\\n            amountOutReceivedSBNB\\r\\n        );\\r\\n\\r\\n        _selfBurn();\\r\\n\\r\\n        emit SendArbitrageProfitToMaster(\\r\\n            amountWBNB,\\r\\n            masterAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // ----------------------------\\r\\n    // INTERNAL-SUPPORT FUNCTIONS\\r\\n    // ----------------------------\\r\\n\\r\\n    function _selfBurn()\\r\\n        internal\\r\\n    {\\r\\n        _burn(\\r\\n            address(this),\\r\\n            _getBalanceOf(\\r\\n                address(this),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _cleanUp(\\r\\n        uint256 _depositAmount\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        _skimPair();\\r\\n\\r\\n        _selfBurn();\\r\\n\\r\\n        _profit(\\r\\n            _getBalanceDiff(\\r\\n                _depositAmount\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _unwrap(\\r\\n        uint256 _amountWBNB\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        bypassEnabled = true;\\r\\n\\r\\n        WBNB.withdraw(\\r\\n            _amountWBNB\\r\\n        );\\r\\n\\r\\n        bypassEnabled = false;\\r\\n    }\\r\\n\\r\\n    function _profit(\\r\\n        uint256 _amountWBNB\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        masterAddress.transfer(\\r\\n            _amountWBNB\\r\\n        );\\r\\n\\r\\n        emit MasterProfit(\\r\\n            _amountWBNB,\\r\\n            masterAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _updateEvaluation()\\r\\n        internal\\r\\n    {\\r\\n        currentEvaluation = _getEvaluation();\\r\\n    }\\r\\n\\r\\n    function _skimPair()\\r\\n        internal\\r\\n    {\\r\\n        PANCAKE_PAIR.skim(\\r\\n            masterAddress\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transformerAddress\",\"type\":\"address\"}],\"name\":\"DepositedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"FormedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokenB\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"MasterProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transferBalance\",\"type\":\"uint256\"}],\"name\":\"MasterTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"SendArbitrageProfitToMaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"SendFeesToMaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PANCAKE_FACTORY\",\"outputs\":[{\"internalType\":\"contract PancakeSwapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_PAIR\",\"outputs\":[{\"internalType\":\"contract PancakeSwapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_ROUTER\",\"outputs\":[{\"internalType\":\"contract PancakeSwapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_HELPER\",\"outputs\":[{\"internalType\":\"contract ITransferHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"contract IWrappedBNB\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WISE_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IWiseToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bypassEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEvaluation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transferHelper\",\"type\":\"address\"}],\"name\":\"defineHelper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"transferInvoker\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wiseToken\",\"type\":\"address\"}],\"name\":\"defineToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"syntheticBNB\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"formLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"forwardOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getAmountPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEvaluation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPairBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wrappedBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"syntheticBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSyntheticBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_previousEvaluation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentEvaluation\",\"type\":\"uint256\"}],\"name\":\"getTradingFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrappedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"helperDefined\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDefined\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SBNB", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://86f97930e389670e7e30e68f4fa5429724fee922930a6091e185420f46d99d60"}