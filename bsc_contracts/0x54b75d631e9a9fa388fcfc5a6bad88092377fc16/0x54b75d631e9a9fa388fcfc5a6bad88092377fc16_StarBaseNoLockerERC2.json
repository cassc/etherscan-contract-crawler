{"SourceCode": "//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@@&%&@&&&&@@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&@@@@&&@@&&@@@&&&&&&&#/(&%##&@&&&&&&&&@@@&&&&&&@@@@&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&@@@@@@@@@@@@@@@&&&%%%&&&&&&%/*(&%(/#&&&&&&&&&&&@@@@@@@@@@@@&&&@@&&&&&&&&&&&&\n//&&&&&&&&&&&&&@@@@@@@@@@@@@&&%%%%%%%&&&&@&#,,(&%(*(%@&&&%%%%%%%%&&@@@@@@@@@@@@&&&&&&&&&&&&&\n//&&&&&&&&&&@&&@@@@@@@@@@&&%###%%%%&&@@@@@&(.,(&%(**%@@@@&&&%%%%%%#%%&@@@@@@@@@&&&&&&&&&&&&&\n//&&&&&&&&&&&&&@@@@@@@@@#//#%%%%&@@@@@@@@@%* ,(&%(*,(@@@@@&&&&&&%%%%#/(&@@@&@@@&&&&&&&&&&&&&\n//&&&&&&&&&&&&@@@@@@@&%*,/#%%&&@@@@@@@@@@@#, ,(&&#*.(&@@@@@@@@@@@&%%%#/*#&@@@&@@@&&&&&&&&&&&\n//&&&&&&&&&&&@@@@@@@@(,,(%%%&@@@@@@@@@@@@@#. ,(&&#*./%@@@@@@@@@@@@&&%%%/,/%@@&@&&&&&&&&&&&&&\n//&&&&&&&&&&&&@@@@@@(,,(%%%&@@@@@@@@@@@@@@(. ,(&&#*.*%@@&@@@@@@@@@@&%&&%/*/&@@@&&&&&&&&&&&&&\n//&&&&&&&&&&&&@@@@&%,,(&%%&@@@@@@@@@@@@@@&/../#&&%/.*%@@@@@@@@@@&@@@&%%&%/.(&@@@@&&&&&&&&&&&\n//&&&&&&&&&&&@&&@@%*.*(%%&@@@@@@@@@@@@@@@%/.*/#&&%/.,(@@@@@@@&&&&&&@@&&&%(,,#@&@&&&&&&&&&&&&\n//&&&&&&&&&&&&&@&@#,,/%%%&@@@@@@@@@@@@@@@#*.#%%&&#/.,(&@@@@@@&&&&&&@@&&%%#*./&@@&&&&&&&&&&&&\n//&&&&&&&&&&&@@@&&#..(&%%&@@@@@@@@@@@@@&%#*  /%&@%/.*(%&@@@@@@@@@@@&&&%%&#* /%@&&&&&&&&&&&&&\n//&&&&&&&&&&&@@@@&#.,/%%%&@@@@@@@@@@@@&%%%(..*#%%&&,*#&%&@@@@@@@@@@@@&&%%#*./%@&&&&&&&&&&&&&\n//&&&&&&&&&&&@&&@@#. .*#%&@@@@@@@@@@@@%%%%(,,/#&&%#,/#&%%&@@@@&&&@@&@&&%(, .(&@@&&&&&&&&&&&&\n//&&&&&&&&&&&&&&@@%/,,*/#%@@@@@@@&@@@%%%%%(..*#&%#*.*#&%#%&@&&@@@@@@&%#(/***#@@@&&&&&&&&&&&&\n//&&&&&&&&&&&@@@@@&%*,,*#%&@@@@@@@@@&##%%%(*,*(##/*,/#%%##&&@@&@@&&&&%#(*,,(&@&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&@&@@@#/**(%&%&@@@@@@&%##%##(/,*/(//**(######&@&&&@&&%%%#(((#&@@&@@&&&&&&&&&&&\n//&&&&&&&&&&&@@@&@@@@%(*/(#%%&&&@@&%(%%####(**///***(%%##%##&@@@@&%%%####%&@@@@@@&&&&&&&&&&&\n//&&&&&&&&&&&@&&&@@@@@&#**(%%%%%&@%##%&&&%#(****/*,/#%&&&%%##&&&%%&&%%%%&&@@@@@@&&&&&&&&&&&&\n//&&&&&&&&&&&&&@@@@&@@@@&(,*(%%%%%%%%&&&%##((//(((/((#&&&&&&%%&&&&&%%%&@@@&@@@&&&&&&&&&&&&&&\n//&&&&&&&&&&&&@@@@@&@@&@@@&(/(%%&&%%%%%%##%%((###((%%##%&%%%&&&&&&%%&@@@@@@@@@@&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&@@@@@@@@@@@@@&###%&&&&&%%%%%#%%#####%%%%%&&&&&&&&&@@@@@@@@@@@@@@&&&&&&&&&&&&\n//&&&&&&&&&&&@@@&@@@&#(%&@@@@@&@@&&&&&&%%%%&&&%(%&&&%%%%&&&&&&&@@@@@@@@&%&@@@@&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&@@&&/,*%(/(%&&@@@@&&@&&&&%&&%%%%%%%&&&&&&@@@@@@@@@&%/##(.,#&@@@&&&&&&&&&&&&&\n//&&&&&&&&&&&&@@&@@@%#%#/(%**/%((%&&&&@@@@@@@@@&@@@&&@&&@@&&&####*/#/*/%##%&&&@@&&&&&&&&&&&&\n//&&&&&&&&&&&&&@@&&@&&&@@&(*/(*,*%**/#/*(###((%@&%(&@%//(#,,/(,*#/**%&&@@@&&@@&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&@&@&&&&&@&&%*/(/,,(//(,/#@&#*%@&(,,(/#&%%%&@@@&&&@@&&&@&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%&@&@&%&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%&&&%&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n \n\n\n// Jelly is Jelly \n//Telegram:  @Jellycommunitybsc \n// Website:   \n//Twitter:   \n  // SPDX-License-Identifier: None\r\npragma solidity ^0.8.21;\r\n\r\n\r\n\r\ninterface IERCBurn {\r\n    function burn(uint256 _amount) external;\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position is the index of the value in the `values` array plus 1.\r\n        // Position 0 is used to mean a value is not in the set.\r\n        mapping(bytes32 value => uint256) _positions;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._positions[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We cache the value's position to prevent multiple reads from the same storage slot\r\n        uint256 position = set._positions[value];\r\n\r\n        if (position != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 valueIndex = position - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (valueIndex != lastIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the lastValue to the index where the value to delete is\r\n                set._values[valueIndex] = lastValue;\r\n                // Update the tracked position of the lastValue (that was just moved)\r\n                set._positions[lastValue] = position;\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the tracked position for the deleted slot\r\n            delete set._positions[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._positions[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Locker {\r\n  struct UserInfo {\r\n    EnumerableSet.AddressSet lockedTokens; // records all tokens the user has locked\r\n    mapping(address => uint256[]) locksForToken; // map erc20 address to lock id for that token\r\n  }\r\n\r\n  struct TokenLock {\r\n    uint256 lockDate; // the date the token was locked\r\n    uint256 amount; // the amount of tokens still locked (initialAmount minus withdrawls)\r\n    uint256 initialAmount; // the initial lock amount\r\n    uint256 unlockDate; // the date the token can be withdrawn\r\n    uint256 lockID; // lockID nonce per uni pair\r\n    address owner;\r\n  }\r\n\r\n  struct FeeStruct {\r\n    uint256 ethFee; // Small eth fee to prevent spam on the platform\r\n    IERCBurn secondaryFeeToken; // UNCX or UNCL\r\n    uint256 secondaryTokenFee; // optional, UNCX or UNCL\r\n    uint256 secondaryTokenDiscount; // discount on liquidity fee for burning secondaryToken\r\n    uint256 liquidityFee; // fee on univ2 liquidity tokens\r\n    uint256 referralPercent; // fee for referrals\r\n    IERCBurn referralToken; // token the refferer must hold to qualify as a referrer\r\n    uint256 referralHold; // balance the referrer must hold to qualify as a referrer\r\n    uint256 referralDiscount; // discount on flatrate fees for using a valid referral address\r\n  }\r\n\r\n  function setDev(address payable _devaddr) external;\r\n\r\n\r\n\r\n  function setSecondaryFeeToken(address _secondaryFeeToken) external;\r\n\r\n  /**\r\n   * @notice referrers need to hold the specified token and hold amount to be elegible for referral fees\r\n   */\r\n  function setReferralTokenAndHold(\r\n    IERCBurn _referralToken,\r\n    uint256 _hold\r\n  ) external;\r\n\r\n  function setFees(\r\n    uint256 _referralPercent,\r\n    uint256 _referralDiscount,\r\n    uint256 _ethFee,\r\n    uint256 _secondaryTokenFee,\r\n    uint256 _secondaryTokenDiscount,\r\n    uint256 _liquidityFee\r\n  ) external;\r\n\r\n  /**\r\n   * @notice whitelisted accounts dont pay flatrate fees on locking\r\n   */\r\n  function whitelistFeeAccount(address _user, bool _add) external;\r\n\r\n  /**\r\n   * @notice Creates a new lock\r\n   * @param _lpToken the univ2 token address\r\n   * @param _amount amount of LP tokens to lock\r\n   * @param _unlock_date the unix timestamp (in seconds) until unlock\r\n   * @param _referral the referrer address if any or address(0) for none\r\n   * @param _fee_in_eth fees can be paid in eth or in a secondary token such as UNCX with a discount on univ2 tokens\r\n   * @param _withdrawer the user who can withdraw liquidity once the lock expires.\r\n   */\r\n  function lockLPToken(\r\n    address _lpToken,\r\n    uint256 _amount,\r\n    uint256 _unlock_date,\r\n    address payable _referral,\r\n    bool _fee_in_eth,\r\n    address payable _withdrawer\r\n  ) external payable;\r\n\r\n  /**\r\n   * @notice extend a lock with a new unlock date, _index and _lockID ensure the correct lock is changed\r\n   * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\r\n   */\r\n  function relock(\r\n    address _lpToken,\r\n    uint256 _index,\r\n    uint256 _lockID,\r\n    uint256 _unlock_date\r\n  ) external;\r\n\r\n  /**\r\n   * @notice withdraw a specified amount from a lock. _index and _lockID ensure the correct lock is changed\r\n   * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\r\n   */\r\n  function withdraw(\r\n    address _lpToken,\r\n    uint256 _index,\r\n    uint256 _lockID,\r\n    uint256 _amount\r\n  ) external;\r\n\r\n  /**\r\n   * @notice increase the amount of tokens per a specific lock, this is preferable to creating a new lock, less fees, and faster loading on our live block explorer\r\n   */\r\n  function incrementLock(\r\n    address _lpToken,\r\n    uint256 _index,\r\n    uint256 _lockID,\r\n    uint256 _amount\r\n  ) external;\r\n\r\n  /**\r\n   * @notice split a lock into two seperate locks, useful when a lock is about to expire and youd like to relock a portion\r\n   * and withdraw a smaller portion\r\n   */\r\n  function splitLock(\r\n    address _lpToken,\r\n    uint256 _index,\r\n    uint256 _lockID,\r\n    uint256 _amount\r\n  ) external payable;\r\n\r\n  /**\r\n   * @notice transfer a lock to a new owner, e.g. presale project -> project owner\r\n   */\r\n  function transferLockOwnership(\r\n    address _lpToken,\r\n    uint256 _index,\r\n    uint256 _lockID,\r\n    address payable _newOwner\r\n  ) external;\r\n\r\n  /**\r\n   * @notice migrates liquidity to uniswap v3\r\n   */\r\n  function migrate(\r\n    address _lpToken,\r\n    uint256 _index,\r\n    uint256 _lockID,\r\n    uint256 _amount\r\n  ) external;\r\n\r\n  function getNumLocksForToken(\r\n    address _lpToken\r\n  ) external view returns (uint256);\r\n\r\n  function getNumLockedTokens() external view returns (uint256);\r\n\r\n  function getLockedTokenAtIndex(\r\n    uint256 _index\r\n  ) external view returns (address);\r\n\r\n  // user functions\r\n  function getUserNumLockedTokens(\r\n    address _user\r\n  ) external view returns (uint256);\r\n\r\n  function getUserLockedTokenAtIndex(\r\n    address _user,\r\n    uint256 _index\r\n  ) external view returns (address);\r\n\r\n  function getUserNumLocksForToken(\r\n    address _user,\r\n    address _lpToken\r\n  ) external view returns (uint256);\r\n\r\n  function getUserLockForTokenAtIndex(\r\n    address _user,\r\n    address _lpToken,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, uint256, address);\r\n\r\n  // whitelist\r\n  function getWhitelistedUsersLength() external view returns (uint256);\r\n\r\n  function getWhitelistedUserAtIndex(\r\n    uint256 _index\r\n  ) external view returns (address);\r\n\r\n  function getUserWhitelistStatus(address _user) external view returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IAgoraERC20Config {\r\n\r\n    /**\r\n     * @dev information used to construct the token.\r\n     */\r\n    struct TokenConstructorParameters {\r\n        bytes baseParameters;\r\n        bytes taxParameters;\r\n        bytes tokenLPInfo;\r\n    }\r\n\r\n    /**\r\n     * @dev Basic info of the token\r\n     */\r\n    struct TokenInfoParameters {\r\n        string name;\r\n        string symbol;\r\n        bool autoCreateLiquidity;\r\n        uint256 maxSupply;\r\n        address tokensRecepient;\r\n        uint256 maxTokensWallet;\r\n        bool payInTax;\r\n        bool protectLiquidity;\r\n    }\r\n\r\n    /**\r\n     *  @dev This struct express the taxes on per 1000, to allow percetanges between 0 and 1. \r\n     */\r\n    struct TaxParameters {\r\n        uint256 buyTax;\r\n        uint256 sellTax;\r\n        uint256 lpBuyTax;\r\n        uint256 lpSellTax;\r\n        uint256 maxTxBuy;\r\n        uint256 maxTxSell;\r\n        address taxSwapRecepient;\r\n    }\r\n\r\n    /**\r\n     * @dev Liquidity pool supply information\r\n     */\r\n    struct TokenLpInfo {\r\n        uint256 lpTokensupply;\r\n        uint256 ethForSupply;\r\n        bool burnLP;\r\n        uint256 lockFee;\r\n        uint256 lpLockUpInDays;\r\n    }\r\n}\r\n\r\ninterface IAgoraERC20 is IAgoraERC20Config, IERC20, IERC20Metadata {\r\n    function addLiquidity() external payable returns (address);\r\n\r\n    event LiquidityLocked(uint256 lpTokens, uint256 daysLocked);\r\n    event TaxesLowered(\r\n        uint256 previousBuyTax,\r\n        uint256 previousSellTax,\r\n        uint256 newBuyTax,\r\n        uint256 newSellTax\r\n    );\r\n    event LPTaxLowered(\r\n        uint256 previousBuyTax,\r\n        uint256 previousSellTax,\r\n        uint256 newBuyTax,\r\n        uint256 newSellTax\r\n    );\r\n    event LiquidityAdded(\r\n        uint256 tokensSupplied,\r\n        uint256 ethSupplied,\r\n        uint256 lpTokensIssued\r\n    );\r\n    event LimitsRaised(\r\n        uint128 oldBuyLimit,\r\n        uint128 oldSellLimit,\r\n        uint128 oldMaxWallet,\r\n        uint128 newBuyLimit,\r\n        uint128 newSellLimit,\r\n        uint128 newMaxWallet\r\n    );\r\n    event LiquidityBurned(uint256 liquidityBurned);\r\n    event LiquiditySupplied(uint256 tokens, uint256 eth);\r\n    event ExternalCallError(uint256);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Revertible {\r\n    function Revert(bytes4 errorSelector) internal pure {\r\n        assembly {\r\n            mstore(0x00, errorSelector)\r\n            revert(0x00, 0x04)\r\n        }\r\n    }\r\n}\r\n\r\ninterface IAgoraErrors {\r\n\r\n    error NotEnoughBalance();\r\n\r\n    error CallerIsNotTheOwner();\r\n    error CannotSetNewOwnerToTheZeroAddress();\r\n    error TaxesCanNotBeRaised();\r\n    error ApproveFromTheZeroAddress();\r\n    error ApproveToTheZeroAddress();\r\n    error OperationNotAllowed();\r\n    error BurnFromTheZeroAddress();\r\n    error BurnExceedsBalance();\r\n    error MintToZeroAddress();\r\n    error LpTokensExceedsTotalSupply();\r\n    error TooFewLPTokens();\r\n    error LPAlreadyCreated();\r\n    error NotEnoughFundsForLP();\r\n    error HardCapIsTooHigh();\r\n    error LPNotInit();\r\n    error TransactionIsTooBig();\r\n    error LimitsLoweringIsNotAllowed();\r\n    error MaxWalletExceeded();\r\n    error InsufficientAllowance();\r\n}\r\n\r\nabstract contract Ownable is Revertible, Context, IAgoraErrors {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            Revert(CallerIsNotTheOwner.selector);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            Revert(CannotSetNewOwnerToTheZeroAddress.selector);\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract StarBaseAbstractERC20 is IAgoraERC20, Ownable {\r\n    bytes32 public constant ID_HASH =\r\n        0xa32639477286282825f7e467c431e6b392088bf1926006d3f8179cc67d5c5360;\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    /** @dev {_balances} Addresses balances */\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    /** @dev {_allowances} Addresses allocance details */\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /** @dev {_unlimited} Enumerable set for addresses where limits do not apply */\r\n    EnumerableSet.AddressSet internal _excludedFromLimits;\r\n\r\n    // Config\r\n    IUniswapV2Router02 internal immutable _uniswapRouter;\r\n    uint256 internal constant MAX_SWAP_THRESHOLD_MULTIPLE = 20;\r\n    uint256 internal constant CALL_GAS_LIMIT = 50000;\r\n    address public immutable factory;\r\n    address public immutable startShipVault;\r\n    address public taxRecepient;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    uint128 private _totalSupply;\r\n\r\n    // Tax\r\n    bool private _hasTax;\r\n    uint16 public buyTax;\r\n    uint16 public sellTax;\r\n    bool private _hasLPTax;\r\n    uint16 public buyLPTax;\r\n    uint16 public sellLPTax;\r\n    uint128 public accumulatedTax;\r\n    uint128 public starShipAccumulatedTax;\r\n    uint128 public lpAccumulatedTax;\r\n    bool public autoConversion;\r\n    uint16 public starShipTaxPoints = 5;\r\n    bool public shouldPayInTax;\r\n\r\n    // Liquidty info\r\n    uint32 public lpCreatedDate;\r\n    address public pairAddress;\r\n    bool public burnLiquidity;\r\n    bool internal _IsInConversion;\r\n    uint16 public pctForSwap; // Per thousands\r\n    uint128 public lockFee;\r\n    uint256 public liquidityLockedInDays;\r\n    uint128 public initialLiquidityFunds;\r\n    uint256 public lockedUntil;\r\n\r\n    // Caps\r\n    uint128 public buyMaxTx;\r\n    uint128 public sellMaxTx;\r\n    uint128 public maxWallet;\r\n\r\n    modifier onlyFactoryOrOwner() {\r\n        if (msg.sender != factory && msg.sender != owner()) {\r\n            Revert(OperationNotAllowed.selector);\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address[5] memory addresses,\r\n        bytes memory tokenInfo,\r\n        bytes memory taxesInfo,\r\n        bytes memory lpInfo\r\n    ) {\r\n        pctForSwap = 5;\r\n        transferOwnership(addresses[0]);\r\n        _uniswapRouter = IUniswapV2Router02(addresses[1]);\r\n        factory = addresses[3];\r\n        startShipVault = addresses[4];\r\n        TokenInfoParameters memory tokenParameters = abi.decode(\r\n            tokenInfo,\r\n            (TokenInfoParameters)\r\n        );\r\n\r\n        _name = tokenParameters.name;\r\n        _symbol = tokenParameters.symbol;\r\n\r\n        shouldPayInTax = tokenParameters.payInTax;\r\n\r\n        if (type(uint128).max < tokenParameters.maxTokensWallet) {\r\n            Revert(HardCapIsTooHigh.selector);\r\n        }\r\n\r\n        maxWallet = uint128(tokenParameters.maxTokensWallet);\r\n        TaxParameters memory taxParams = abi.decode(taxesInfo, (TaxParameters));\r\n        _processLimits(taxParams);\r\n\r\n        taxRecepient = taxParams.taxSwapRecepient;\r\n        TokenLpInfo memory tokenLpInfo = abi.decode(lpInfo, (TokenLpInfo));\r\n        _processSupply(tokenParameters, tokenLpInfo);\r\n        burnLiquidity = tokenLpInfo.burnLP;\r\n        lockFee = uint128(tokenLpInfo.lockFee);\r\n        liquidityLockedInDays = tokenLpInfo.lpLockUpInDays;\r\n        initialLiquidityFunds = uint128(tokenLpInfo.ethForSupply);\r\n\r\n        _excludedFromLimits.add(address(_uniswapRouter));\r\n        pairAddress = IUniswapV2Factory(_uniswapRouter.factory()).createPair(\r\n            address(this),\r\n            _uniswapRouter.WETH()\r\n        );\r\n        _excludedFromLimits.add(pairAddress);\r\n        _excludedFromLimits.add(address(this));\r\n        _excludedFromLimits.add(address(0));\r\n        _excludedFromLimits.add(owner());\r\n        _approve(address(this), address(_uniswapRouter), type(uint256).max);\r\n        _approve(address(this), pairAddress, type(uint256).max);\r\n    }\r\n\r\n    /**\r\n     * Reads and stores the relevant information about the taxes.\r\n     * @param taxParams Tax configuration\r\n     */\r\n    function _processLimits(TaxParameters memory taxParams) internal {\r\n        if (\r\n            type(uint128).max < taxParams.maxTxSell ||\r\n            type(uint128).max < taxParams.maxTxBuy\r\n        ) {\r\n            Revert(HardCapIsTooHigh.selector);\r\n        }\r\n\r\n        buyMaxTx = uint128(taxParams.maxTxBuy);\r\n        sellMaxTx = uint128(taxParams.maxTxSell);\r\n\r\n        if (taxParams.buyTax == 0 && taxParams.sellTax == 0) {\r\n            _hasTax = false;\r\n        } else {\r\n            _hasTax = true;\r\n            buyTax = uint16(taxParams.buyTax);\r\n            sellTax = uint16(taxParams.sellTax);\r\n        }\r\n\r\n        if (taxParams.lpBuyTax == 0 && taxParams.lpSellTax == 0) {\r\n            _hasLPTax = false;\r\n        } else {\r\n            _hasLPTax = true;\r\n            buyLPTax = uint16(taxParams.lpBuyTax);\r\n            sellLPTax = uint16(taxParams.lpSellTax);\r\n        }\r\n    }\r\n\r\n    function _processSupply(\r\n        TokenInfoParameters memory tokenParameters,\r\n        TokenLpInfo memory tokenLpInfo\r\n    ) internal virtual;\r\n\r\n    /**\r\n     * @dev Safeguard method to withdraw all the remaining eth to the project address\r\n     *\r\n     */\r\n    function withdrawNative() external {\r\n        transferNative(address(this).balance, taxRecepient);\r\n    }\r\n\r\n    function withdrawERC20() external {\r\n        this.transferFrom(\r\n            address(this),\r\n            taxRecepient,\r\n            this.balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function transferNative(\r\n        uint256 amount,\r\n        address to\r\n    ) internal returns (bool) {\r\n        uint256 gas = (CALL_GAS_LIMIT == 0 || CALL_GAS_LIMIT > gasleft())\r\n            ? gasleft()\r\n            : CALL_GAS_LIMIT;\r\n        (bool success, ) = to.call{value: amount, gas: gas}(\"\");\r\n        return success;\r\n    }\r\n\r\n    function isExcludedFromLimits(address who) external view returns (bool) {\r\n        return _excludedFromLimits.contains(who);\r\n    }\r\n\r\n    function excludedFromLimits(address who) external onlyOwner {\r\n        _excludedFromLimits.add(who);\r\n    }\r\n\r\n    function toggleConversion() external onlyOwner {\r\n        autoConversion = !autoConversion;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to change the buy and sell tax for marketing\r\n     * @param newBuyTax New buy tax in per thousand\r\n     * @param newSellTax New sell tax in per thousand\r\n     */\r\n    function changeTaxes(\r\n        uint256 newBuyTax,\r\n        uint256 newSellTax\r\n    ) external onlyOwner {\r\n        if (newBuyTax > buyTax) {\r\n            Revert(TaxesCanNotBeRaised.selector);\r\n        }\r\n\r\n        if (newSellTax > sellTax) {\r\n            Revert(TaxesCanNotBeRaised.selector);\r\n        }\r\n        uint16 oldBuyTax = buyTax;\r\n        uint16 oldSellTax = sellTax;\r\n        buyTax = uint16(newBuyTax);\r\n        sellTax = uint16(newSellTax);\r\n\r\n        _hasTax = buyTax > 0 && sellTax > 0;\r\n\r\n        emit TaxesLowered(oldBuyTax, oldSellTax, buyTax, sellTax);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the LP taxes\r\n     * @param newBuyLPTax New buy lp tax in per thousand\r\n     * @param newSellLPTax New sell LP tax in per thousand.\r\n     */\r\n    function changeLPTax(\r\n        uint256 newBuyLPTax,\r\n        uint256 newSellLPTax\r\n    ) external onlyOwner {\r\n        if (newBuyLPTax > buyLPTax) {\r\n            Revert(TaxesCanNotBeRaised.selector);\r\n        }\r\n\r\n        if (newSellLPTax > sellLPTax) {\r\n            Revert(TaxesCanNotBeRaised.selector);\r\n        }\r\n        uint16 oldBuyTax = buyLPTax;\r\n        uint16 oldSellTax = sellLPTax;\r\n        buyLPTax = uint16(newBuyLPTax);\r\n        sellLPTax = uint16(newSellLPTax);\r\n\r\n        _hasLPTax = buyLPTax > 0 && sellLPTax > 0;\r\n\r\n        emit LPTaxLowered(oldBuyTax, oldSellTax, buyLPTax, sellLPTax);\r\n    }\r\n\r\n    /**\r\n     * @dev Proxy function to change all the different taxes in one call to save gas, if tax are raised, tx will revert\r\n     * @param newBuyTax New buy tax in per thousand\r\n     * @param newSellTax New sell tax in per thousand\r\n     * @param newBuyLPTax New buy lp tax in per thousand\r\n     * @param newSellLPTax New sell LP tax in per thousand.\r\n     */\r\n    function changeAllTaxes(\r\n        uint256 newBuyTax,\r\n        uint256 newSellTax,\r\n        uint256 newBuyLPTax,\r\n        uint256 newSellLPTax\r\n    ) external onlyOwner {\r\n        this.changeLPTax(newBuyLPTax, newSellLPTax);\r\n        this.changeTaxes(newBuyTax, newSellTax);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        if (account == address(0)) {\r\n            Revert(MintToZeroAddress.selector);\r\n        }\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += uint128(amount);\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /** @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        // Approvals\r\n        _safeGuardAllowance(from, _msgSender(), amount);\r\n        return _transfer(from, to, amount);\r\n    }\r\n\r\n    function _shouldApplyTax() internal view returns (bool) {\r\n        return _hasTax || shouldPayInTax || _hasLPTax;\r\n    }\r\n\r\n    function _buyTax() internal view returns (uint16) {\r\n        return shouldPayInTax ? buyTax + starShipTaxPoints : buyTax;\r\n    }\r\n\r\n    function _sellTax() internal view returns (uint16) {\r\n        return shouldPayInTax ? sellTax + starShipTaxPoints : sellTax;\r\n    }\r\n\r\n    function _applyTaxes(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (uint128) {\r\n        uint128 taxedAmount = uint128(amount);\r\n        uint128 taxAmount = 0;\r\n        uint128 starshipTax = 0;\r\n        uint128 lpTax = 0;\r\n        if (_shouldApplyTax() && !_IsInConversion) {\r\n            if (from == pairAddress && !_excludedFromLimits.contains(to)) {\r\n                if (buyTax > 0) {\r\n                    taxAmount = (taxedAmount * buyTax) / 1000;\r\n                }\r\n\r\n                if (shouldPayInTax) {\r\n                    starshipTax = (taxedAmount * starShipTaxPoints) / 1000;\r\n                    starShipAccumulatedTax += starshipTax;\r\n                }\r\n\r\n                if (_hasLPTax && buyLPTax > 0) {\r\n                    lpTax += (taxedAmount * buyLPTax) / 1000;\r\n                    lpAccumulatedTax += lpTax;\r\n                }\r\n            } else if (\r\n                to == pairAddress && !_excludedFromLimits.contains(from)\r\n            ) {\r\n                if (sellTax > 0) {\r\n                    taxAmount = (taxedAmount * sellTax) / 1000;\r\n                }\r\n                if (shouldPayInTax) {\r\n                    starshipTax = (taxedAmount * starShipTaxPoints) / 1000;\r\n                    starShipAccumulatedTax += starshipTax;\r\n                }\r\n\r\n                if (_hasLPTax && sellLPTax > 0) {\r\n                    lpTax += (taxedAmount * sellLPTax) / 1000;\r\n                    lpAccumulatedTax += lpTax;\r\n                }\r\n            }\r\n\r\n            if (taxAmount > 0 || starshipTax > 0 || lpTax > 0) {\r\n                unchecked {\r\n                    accumulatedTax += taxAmount;\r\n                    _balances[address(this)] += taxAmount + starshipTax + lpTax;\r\n                }\r\n\r\n                emit Transfer(\r\n                    from,\r\n                    address(this),\r\n                    taxAmount + starshipTax + lpTax\r\n                );\r\n            }\r\n        }\r\n\r\n        return taxedAmount - starshipTax - taxAmount - lpTax;\r\n    }\r\n\r\n    function _safeGuardTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal view virtual {\r\n        uint256 fromBalance = _balances[from];\r\n\r\n        if (fromBalance < amount) {\r\n            Revert(NotEnoughBalance.selector);\r\n        }\r\n        if (\r\n            buyMaxTx > 0 &&\r\n            from == pairAddress &&\r\n            !_excludedFromLimits.contains(to) &&\r\n            amount > buyMaxTx\r\n        ) {\r\n            Revert(TransactionIsTooBig.selector);\r\n        }\r\n        if (\r\n            sellMaxTx > 0 &&\r\n            to == pairAddress &&\r\n            !_excludedFromLimits.contains(from) &&\r\n            amount > sellMaxTx\r\n        ) {\r\n            Revert(TransactionIsTooBig.selector);\r\n        }\r\n        uint256 toBalance = _balances[to];\r\n        if (\r\n            maxWallet > 0 &&\r\n            maxWallet < toBalance + amount &&\r\n            !_excludedFromLimits.contains(to)\r\n        ) {\r\n            Revert(MaxWalletExceeded.selector);\r\n        }\r\n    }\r\n\r\n    function changeTransactionHardCaps(\r\n        uint256 newBuyMaxTx,\r\n        uint256 newSellMaxTx,\r\n        uint256 newMaxWallet\r\n    ) external onlyOwner {\r\n        if (\r\n            newBuyMaxTx < buyMaxTx ||\r\n            newSellMaxTx < sellMaxTx ||\r\n            newMaxWallet < maxWallet\r\n        ) {\r\n            Revert(LimitsLoweringIsNotAllowed.selector);\r\n        }\r\n        uint128 oldMaxWallet = maxWallet;\r\n        uint128 oldMaxSellTx = sellMaxTx;\r\n        uint128 oldMaxBuyTx = buyMaxTx;\r\n        buyMaxTx = uint128(newBuyMaxTx);\r\n        sellMaxTx = uint128(newSellMaxTx);\r\n        maxWallet = uint128(newMaxWallet);\r\n\r\n        emit LimitsRaised(\r\n            oldMaxBuyTx,\r\n            oldMaxSellTx,\r\n            oldMaxWallet,\r\n            buyMaxTx,\r\n            sellMaxTx,\r\n            maxWallet\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if (owner == address(0)) {\r\n            Revert(ApproveFromTheZeroAddress.selector);\r\n        }\r\n\r\n        if (spender == address(0)) {\r\n            Revert(ApproveToTheZeroAddress.selector);\r\n        }\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _safeGuardAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = this.allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < amount) {\r\n                Revert(InsufficientAllowance.selector);\r\n            }\r\n\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        \r\n        _safeGuardTransfer(from, to, amount);\r\n\r\n        uint128 realAmount = _applyTaxes(from, to, amount);\r\n\r\n        _swapTaxes(from, to);\r\n\r\n        unchecked {\r\n            _balances[from] -= amount;\r\n            _balances[to] += realAmount;\r\n        }\r\n        emit Transfer(from, to, realAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool) {\r\n        return _transfer(msg.sender, to, amount);\r\n    }\r\n\r\n    function _swapTaxes(address from, address to) internal {\r\n        if (_shouldApplyTax() && autoConversion) {\r\n            uint256 swapBalance = accumulatedTax +\r\n                starShipAccumulatedTax +\r\n                lpAccumulatedTax;\r\n\r\n            uint256 swapThresholdInTokens = (_totalSupply * pctForSwap) / 1000;\r\n            if (\r\n                swapBalance >= swapThresholdInTokens &&\r\n                !_IsInConversion &&\r\n                from != pairAddress &&\r\n                from != address(_uniswapRouter) &&\r\n                to != address(_uniswapRouter)\r\n            ) {\r\n                _IsInConversion = true;\r\n                if (\r\n                    swapBalance >\r\n                    swapThresholdInTokens * MAX_SWAP_THRESHOLD_MULTIPLE\r\n                ) {\r\n                    swapBalance =\r\n                        swapThresholdInTokens *\r\n                        MAX_SWAP_THRESHOLD_MULTIPLE;\r\n                }\r\n                // Perform the auto swap to native token:\r\n                _doSwap(swapBalance, this.balanceOf(address(this)));\r\n\r\n                // Flag that the autoswap is complete:\r\n                _IsInConversion = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSwap(uint256 swapBalance_, uint256 contractBalance_) internal {\r\n        uint256 preSwapNativeBalance = address(this).balance;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _uniswapRouter.WETH();\r\n        uint256 lpTokensProportion = 0;\r\n        if (swapBalance_ < contractBalance_) {\r\n            lpTokensProportion =\r\n                (swapBalance_ * lpAccumulatedTax) /\r\n                contractBalance_;\r\n        } else {\r\n            lpTokensProportion = lpAccumulatedTax;\r\n        }\r\n\r\n        // Wrap external calls in try / catch to handle errors\r\n        try\r\n            _uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                swapBalance_ - (lpTokensProportion / 2),\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp + 600\r\n            )\r\n        {\r\n            \r\n            uint256 postSwapBalance = address(this).balance;\r\n            uint256 lpTokens = (lpTokensProportion / 2);\r\n            uint256 totalPendingSwap = accumulatedTax +\r\n                starShipAccumulatedTax +\r\n                lpTokens;\r\n            uint256 balanceToDistribute = postSwapBalance -\r\n                preSwapNativeBalance;\r\n            uint256 projectBalanceToDistribute = (balanceToDistribute *\r\n                accumulatedTax) / totalPendingSwap;\r\n            uint256 starShipBalance = (balanceToDistribute *\r\n                starShipAccumulatedTax) / totalPendingSwap;\r\n            \r\n            uint256 lpBalance = (balanceToDistribute * lpTokens) /\r\n                totalPendingSwap;\r\n\r\n            if (swapBalance_ < contractBalance_) {\r\n                accumulatedTax -= uint128(\r\n                    (accumulatedTax * swapBalance_) / contractBalance_\r\n                );\r\n                starShipAccumulatedTax -= uint128(\r\n                    (starShipAccumulatedTax * swapBalance_) / contractBalance_\r\n                );\r\n\r\n                lpAccumulatedTax -= uint128(\r\n                    (lpAccumulatedTax * swapBalance_) / contractBalance_\r\n                );\r\n            \r\n            } else {\r\n                (accumulatedTax, starShipAccumulatedTax, lpAccumulatedTax) = (\r\n                    0,\r\n                    0,\r\n                    0\r\n                );\r\n            }\r\n            if (_hasLPTax) {\r\n                try\r\n                    _uniswapRouter.addLiquidityETH{value: lpBalance}(\r\n                        address(this),\r\n                        lpTokens,\r\n                        0, // slippage is unavoidable\r\n                        0, // slippage is unavoidable\r\n                        owner(),\r\n                        block.timestamp\r\n                    )\r\n                {\r\n                    emit LiquiditySupplied(lpTokens, lpBalance);\r\n                } catch {\r\n                    \r\n                }\r\n            }\r\n\r\n            // Distribute to treasuries:\r\n            bool success;\r\n            uint256 gas;\r\n            if (projectBalanceToDistribute > 0) {\r\n                // If no gas limit was provided or provided gas limit greater than gas left, just use the remaining gas.\r\n                gas = (CALL_GAS_LIMIT == 0 || CALL_GAS_LIMIT > gasleft())\r\n                    ? gasleft()\r\n                    : CALL_GAS_LIMIT;\r\n                // We limit the gas passed so that a called address cannot cause a block out of gas error:\r\n                (success, ) = taxRecepient.call{\r\n                    value: projectBalanceToDistribute,\r\n                    gas: gas\r\n                }(\"\");\r\n            }\r\n\r\n            if (starShipBalance > 0) {\r\n                // If no gas limit was provided or provided gas limit greater than gas left, just use the remaining gas.\r\n                gas = (CALL_GAS_LIMIT == 0 || CALL_GAS_LIMIT > gasleft())\r\n                    ? gasleft()\r\n                    : CALL_GAS_LIMIT;\r\n\r\n                // We limit the gas passed so that a called address cannot cause a block out of gas error:\r\n                (success, ) = startShipVault.call{\r\n                    value: starShipBalance,\r\n                    gas: gas\r\n                }(\"\");\r\n            }\r\n        } catch {\r\n            // Dont allow a failed external call (in this case to uniswap) to stop a transfer.\r\n            // Emit that this has occured and continue.\r\n            emit ExternalCallError(5);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        if (account == address(0)) {\r\n            Revert(BurnFromTheZeroAddress.selector);\r\n        }\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        if (accountBalance < amount) {\r\n            Revert(BurnExceedsBalance.selector);\r\n        }\r\n\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= uint128(amount);\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 value) public virtual {\r\n        _burn(_msgSender(), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n}\r\n\r\ncontract StarBaseNoLockerERC20 is StarBaseAbstractERC20 {\r\n    constructor(\r\n        address[5] memory addresses,\r\n        bytes memory tokenInfo,\r\n        bytes memory taxesInfo,\r\n        bytes memory lpInfo\r\n    ) StarBaseAbstractERC20(addresses, tokenInfo, taxesInfo, lpInfo) {\r\n        autoConversion = true;\r\n    }\r\n\r\n    /**\r\n     * This will mint the balances for the liquidity pool, which will be minted to the\r\n     * contract and the rest will be minted to the caller. Also, transaction will revert\r\n     * if less than 25% of the tokens are not designated to the liquidity pool.\r\n     *\r\n     * @param tokenParameters Token info parameters where the total supply is\r\n     * @param tokenLpInfo The information about the liquidity pool\r\n     */\r\n    function _processSupply(\r\n        TokenInfoParameters memory tokenParameters,\r\n        TokenLpInfo memory tokenLpInfo\r\n    ) internal override {\r\n        _mint(owner(), tokenParameters.maxSupply);\r\n    }\r\n\r\n    function addLiquidity() external payable override returns (address) {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[5]\",\"name\":\"addresses\",\"type\":\"address[5]\"},{\"internalType\":\"bytes\",\"name\":\"tokenInfo\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"taxesInfo\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"lpInfo\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApproveFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewOwnerToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HardCapIsTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LPAlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LPNotInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitsLoweringIsNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LpTokensExceedsTotalSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxWalletExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughFundsForLP\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperationNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxesCanNotBeRaised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooFewLPTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransactionIsTooBig\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ExternalCallError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBuyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousSellTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBuyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSellTax\",\"type\":\"uint256\"}],\"name\":\"LPTaxLowered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"oldBuyLimit\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"oldSellLimit\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"oldMaxWallet\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newBuyLimit\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newSellLimit\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newMaxWallet\",\"type\":\"uint128\"}],\"name\":\"LimitsRaised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSupplied\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethSupplied\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokensIssued\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityBurned\",\"type\":\"uint256\"}],\"name\":\"LiquidityBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daysLocked\",\"type\":\"uint256\"}],\"name\":\"LiquidityLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"LiquiditySupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBuyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousSellTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBuyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSellTax\",\"type\":\"uint256\"}],\"name\":\"TaxesLowered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ID_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulatedTax\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoConversion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLPTax\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxTx\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyLPTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellLPTax\",\"type\":\"uint256\"}],\"name\":\"changeAllTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyLPTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellLPTax\",\"type\":\"uint256\"}],\"name\":\"changeLPTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellTax\",\"type\":\"uint256\"}],\"name\":\"changeTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyMaxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellMaxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxWallet\",\"type\":\"uint256\"}],\"name\":\"changeTransactionHardCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"excludedFromLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLiquidityFunds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isExcludedFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLockedInDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockFee\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpAccumulatedTax\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpCreatedDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pctForSwap\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLPTax\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMaxTx\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldPayInTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starShipAccumulatedTax\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starShipTaxPoints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startShipVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxRecepient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleConversion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StarBaseNoLockerERC20", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000068253cc4bbd0638d13c8f26cbaf24703d176517a00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000002a384fd9e2f27621a0b80d12974dd2aceb250e2e00000000000000000000000090c211733f61bb659a3ef2f529ffee7c55f5c4a10000000000000000000000002a384fd9e2f27621a0b80d12974dd2aceb250e2e000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000039cd5aea9ef9284979c3aba4a10e0e9c7aa627d700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054a454c4c5900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054a454c4c5900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003c00000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000039cd5aea9ef9284979c3aba4a10e0e9c7aa627d700000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000001f", "EVMVersion": "paris", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}