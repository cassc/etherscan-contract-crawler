{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.StakingContract/contracts/CheckDotStakingProtocolContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function burn(uint256 amount) external returns (bool);\\n}\\n\\nstruct Staking {\\n    address WALLET;\\n    uint256 STAKING_POOL;\\n    uint256 START;\\n    uint256 SLOTS;\\n    bool    LOCKED;\\n}\\n\\nstruct Pool {\\n    uint256 ID;\\n    address COIN_A;\\n    address COIN_B;\\n    uint256 SLOTS;\\n    uint256 LOCK_DURATION_IN_DAY;\\n    uint256 QUANTITY_OF_COIN_A_PER_SLOT;\\n    uint256 QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT;\\n    uint256 SLOTS_USED;\\n    uint256 SLOTS_FINISHED;\\n    uint256 MAX_NUMBER_OF_SLOTS_PER_STAKER;\\n    uint256 TSV;\\n    uint256 TVL;\\n    uint256 LIQUIDITY;\\n    bool    ENABLED;\\n    bool    STAKABLE;\\n    mapping(address => Staking) _stakers;\\n    uint256 _stakersCount;\\n    address OWNER;\\n}\\n\\nstruct PoolInformation {\\n    uint256 ID;\\n    address COIN_A;\\n    address COIN_B;\\n    uint256 SLOTS;\\n    uint256 LOCK_DURATION_IN_DAY;\\n    uint256 QUANTITY_OF_COIN_A_PER_SLOT;\\n    uint256 QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT;\\n    uint256 SLOTS_USED;\\n    uint256 SLOTS_FINISHED;\\n    uint256 MAX_NUMBER_OF_SLOTS_PER_STAKER;\\n    uint256 TSV;\\n    uint256 TVL;\\n    uint256 LIQUIDITY;\\n    bool    ENABLED;\\n    bool    STAKABLE;\\n    uint256 STACKER_COUNT;\\n    address OWNER;\\n}\\n\\n/**\\n * @dev Implementation of the {CheckDot Staking Protocol} Contract Version 1.0.3\\n * \\n * 1. Simple schema works representation:\\n *\\n * o------------o       o--------------------o                 o----------------------o\\n * |  New Pool  | ----> | Authorized staking | --- Waiting --> | Unstake with rewards |\\n * o------------o       o--------------------o                 o----------------------o\\n *     1 BNB\\n * (Default Cost)\\n *\\n * 2. Pool owner can:\\n *\\n * - Disable Stakes (can be activated is deactivated (Only if Pool is enabled))\\n * - Disable Pool (Only if Pool is enabled (Not reversible))\\n * - Take remaining (Only if Pool is disabled, No remove funds from stakers still in the staking)\\n *\\n * 3. Stakers can:\\n *\\n * - Stake (Only if Pool is enabled), (One time per pool)\\n * - Unstake (All the time even if a pool is deactivated)\\n */\\ncontract CheckDotStakingProtocolContract {\\n\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    /*\\n    ** owner of the contract to add/remove Pools into the staking contract\\n    */\\n    address private _owner;\\n\\n    /*\\n    ** List of staking pools\\n    */\\n    mapping(uint256 => Pool) private _pools;\\n    uint256 private _poolsCount;\\n\\n    /*\\n    ** Pool Creation Cost\\n    */\\n    uint256 private _poolCreationCost;\\n    \\n    /*\\n    ** Decimal point of alloued tokens\\n    */\\n    uint256 private _coinDecimal = 18;\\n\\n    event NewPool(uint256 ID, address LOCK_COIN, address EARN_COIN);\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        _poolsCount = 1;\\n        _poolCreationCost = 1 * (10 ** uint256(_coinDecimal)); // Default: 1 BNB\\n    }\\n\\n    /*\\n    ** @dev Check that the transaction sender is the Contract owner\\n    */\\n    modifier onlyContractOwner() {\\n        require(msg.sender == _owner, \\\"Only the owner can do this action\\\");\\n        _;\\n    }\\n\\n    /*\\n    ** @dev Check that the transaction sender is the Contract owner or pool Owner\\n    */\\n    modifier onlyPoolOwner(uint256 poolId) {\\n        Pool storage pool = _pools[poolId];\\n\\n        require(msg.sender == pool.OWNER || msg.sender == _owner, \\\"Only the owner can do this action\\\");\\n        _;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function getPoolsLength() public view returns (uint256) {\\n        return _poolsCount;\\n    }\\n\\n    function getPoolCreationCost() public view returns (uint256) {\\n        return _poolCreationCost;\\n    }\\n\\n    function getPool(uint256 poolId) public view returns (PoolInformation memory) {\\n        PoolInformation memory result;\\n        Pool storage pool = _pools[poolId];\\n                \\n        result.ID = pool.ID;\\n        result.COIN_A = pool.COIN_A;\\n        result.COIN_B = pool.COIN_B;\\n        result.SLOTS = pool.SLOTS;\\n        result.LOCK_DURATION_IN_DAY = pool.LOCK_DURATION_IN_DAY;\\n        result.QUANTITY_OF_COIN_A_PER_SLOT = pool.QUANTITY_OF_COIN_A_PER_SLOT;\\n        result.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT = pool.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT;\\n        result.SLOTS_USED = pool.SLOTS_USED;\\n        result.SLOTS_FINISHED = pool.SLOTS_FINISHED;\\n        result.MAX_NUMBER_OF_SLOTS_PER_STAKER = pool.MAX_NUMBER_OF_SLOTS_PER_STAKER;\\n        result.TSV = pool.TSV;\\n        result.TVL = pool.TVL;\\n        result.LIQUIDITY = pool.LIQUIDITY;\\n        result.ENABLED = pool.ENABLED;\\n        result.STAKABLE = pool.STAKABLE;\\n        result.STACKER_COUNT = pool._stakersCount;\\n        result.OWNER = pool.OWNER;\\n        return result;\\n    }\\n\\n    function getPoolStaker(uint256 poolId, address wallet) public view returns (Staking memory) {\\n        Staking memory result;\\n        Pool storage pool = _pools[poolId];\\n        Staking storage staker = pool._stakers[wallet];\\n\\n        result.WALLET = staker.WALLET;\\n        result.STAKING_POOL = staker.STAKING_POOL;\\n        result.START = staker.START;\\n        result.SLOTS = staker.SLOTS;\\n        result.LOCKED = staker.LOCKED;\\n        return result;\\n    }\\n\\n    function getPools(int256 page, int256 pageSize) public view returns (PoolInformation[] memory) {\\n        uint256 poolLength = getPoolsLength();\\n        int256 queryStartPoolIndex = int256(poolLength).sub(pageSize.mul(page)).add(pageSize).sub(1);\\n        require(queryStartPoolIndex >= 0, \\\"Out of bounds\\\");\\n        int256 queryEndPoolIndex = queryStartPoolIndex.sub(pageSize);\\n        if (queryEndPoolIndex < 0) {\\n            queryEndPoolIndex = 0;\\n        }\\n        int256 currentPoolIndex = queryStartPoolIndex;\\n        require(uint256(currentPoolIndex) <= poolLength.sub(1), \\\"Out of bounds\\\");\\n        PoolInformation[] memory results = new PoolInformation[](uint256(currentPoolIndex - queryEndPoolIndex));\\n        uint256 index = 0;\\n\\n        for (currentPoolIndex; currentPoolIndex > queryEndPoolIndex; currentPoolIndex--) {\\n            uint256 currentVerificationIndexAsUnsigned = uint256(currentPoolIndex);\\n            if (currentVerificationIndexAsUnsigned <= poolLength.sub(1)) {\\n                results[index] = getPool(currentVerificationIndexAsUnsigned);\\n            }\\n            index++;\\n        }\\n        return results;\\n    }\\n\\n    /*\\n    ** deposit 1000 CDT (5% in USDT) = ((1000 * 5 / 100) / 365) * lockDurationInDay = (slot rewards when the unlock date is finished in CDT)\\n    ** createPool(0x, 0x, coinRatio = 1000, slots = 100, lockDurationInDay = 30, 0.03 ** 18);\\n    */\\n    function createPool(address coinA, address coinB, uint256 slots, uint256 lockDurationInDay, uint256 quantityOfCoinAPerSlot, uint256 quantityOfCoinBRewardablePerSlot, uint256 maxNumberOfSlotsPerStaker) public payable {\\n\\n        require(msg.value >= _poolCreationCost || msg.sender == _owner,\\n            \\\"Cost of pool creation not received\\\"\\n        );\\n        require(quantityOfCoinBRewardablePerSlot > 0\\n            && quantityOfCoinAPerSlot > 0\\n            && slots > 0,\\n            \\\"Nullable number not allowed\\\"\\n        );\\n        require(IERC20(coinA).decimals() == IERC20(coinB).decimals(),\\n            \\\"Only equals Decimals\\\"\\n        );\\n        uint256 quantityOfCoinB = quantityOfCoinBRewardablePerSlot.mul(slots);\\n\\n        require(IERC20(coinB).transferFrom(msg.sender, address(this), quantityOfCoinB) == true,\\n            \\\"Balance empty\\\"\\n        );\\n\\n        uint256 index = _poolsCount++;\\n        Pool storage pool = _pools[index];\\n\\n        pool.TVL = 0;\\n        pool.TSV = 0;\\n        pool.ID = index;\\n        pool.COIN_A = coinA;\\n        pool.COIN_B = coinB;\\n        pool.SLOTS = slots;\\n        pool.LOCK_DURATION_IN_DAY = lockDurationInDay;\\n        pool.QUANTITY_OF_COIN_A_PER_SLOT = quantityOfCoinAPerSlot;\\n        pool.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT = quantityOfCoinBRewardablePerSlot;\\n        pool.SLOTS_USED = 0;\\n        pool.SLOTS_FINISHED = 0;\\n        pool.MAX_NUMBER_OF_SLOTS_PER_STAKER = maxNumberOfSlotsPerStaker;\\n        pool.LIQUIDITY = quantityOfCoinB;\\n        pool.ENABLED = true;\\n        pool.STAKABLE = true;\\n        pool.OWNER = msg.sender;\\n\\n        emit NewPool(pool.ID, pool.COIN_A, pool.COIN_B);\\n    }\\n\\n    /*\\n    ** Stake coins in the staking contract.\\n    */\\n    function stake(uint256 poolId, uint256 slots, bool lock) public {\\n        Pool storage pool = _pools[poolId];\\n        require(slots > 0,\\n            \\\"Slots required\\\"\\n        );\\n        require(pool.STAKABLE == true,\\n            \\\"Pool unstakable\\\"\\n        );\\n        require(\\n            pool.ENABLED == true,\\n            \\\"Pool disabled\\\"\\n        );\\n        require(\\n            slots <= pool.MAX_NUMBER_OF_SLOTS_PER_STAKER,\\n            \\\"Slots limit exceeded\\\"\\n        );\\n        require(pool.SLOTS_USED.add(pool.SLOTS_FINISHED).add(slots) <= pool.SLOTS,\\n            \\\"Pool is fully filled\\\"\\n        );\\n        require(\\n            pool._stakers[msg.sender].WALLET != msg.sender,\\n            \\\"Slot already taken\\\"\\n        );\\n        uint256 participationAmount = pool.QUANTITY_OF_COIN_A_PER_SLOT.mul(slots);\\n\\n        require(IERC20(pool.COIN_A).transferFrom(msg.sender, address(this), participationAmount) == true,\\n            \\\"Balance empty\\\"\\n        );\\n\\n        if (lock) {\\n            pool.TVL += participationAmount;\\n        }\\n        pool.SLOTS_USED += slots;\\n        pool.TSV += participationAmount;\\n        pool._stakersCount += 1;\\n        pool._stakers[msg.sender].WALLET = msg.sender;\\n        pool._stakers[msg.sender].SLOTS = slots;\\n        pool._stakers[msg.sender].START = block.timestamp;\\n        pool._stakers[msg.sender].LOCKED = lock;\\n    }\\n\\n    /*\\n    ** UnStake coins in the staking contract optionnal claimable.\\n    */\\n    function unStake(uint256 poolId, bool claim) public {\\n        Pool storage pool = _pools[poolId];\\n        Staking storage staker = pool._stakers[msg.sender];\\n\\n        require(\\n            staker.WALLET == msg.sender,\\n            \\\"No stake\\\"\\n        );\\n        bool lockDurationIsExceeded = staker.START.add(86400 * pool.LOCK_DURATION_IN_DAY) <= block.timestamp;\\n        require(\\n            staker.LOCKED == false || lockDurationIsExceeded,\\n            \\\"Stake locked\\\"\\n        );\\n        uint256 stakedAmount = pool.QUANTITY_OF_COIN_A_PER_SLOT.mul(staker.SLOTS);\\n        require(IERC20(pool.COIN_A).transfer(msg.sender, stakedAmount) == true,\\n            \\\"Balance Coin A empty\\\"\\n        );\\n        if (claim == true && lockDurationIsExceeded) {\\n            uint256 rewardAmount = pool.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT.mul(staker.SLOTS);\\n\\n            require(IERC20(pool.COIN_B).transfer(msg.sender, rewardAmount) == true,\\n                \\\"Balance Coin A empty\\\"\\n            );\\n            pool.SLOTS_FINISHED += staker.SLOTS;\\n            pool.LIQUIDITY -= rewardAmount;\\n        }\\n        if (staker.LOCKED) {\\n            staker.LOCKED = false;\\n            pool.TVL -= stakedAmount;\\n        }\\n        pool.TSV -= stakedAmount;\\n        pool.SLOTS_USED -= staker.SLOTS;\\n        pool._stakersCount -= 1;\\n        staker.WALLET = 0x0000000000000000000000000000000000000000;\\n        staker.START = 0;\\n        staker.SLOTS = 0;\\n    }\\n\\n    /*\\n    ** @dev Add pool Slots only for the pool owner.\\n    */\\n    function setPoolMaxNumberOfSlotsPerStaker(uint256 poolId, uint256 maxNumberOfSlotsPerStaker) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        \\n        require(\\n            pool.ENABLED == true,\\n            \\\"Pool disabled\\\"\\n        );\\n        require(\\n            maxNumberOfSlotsPerStaker > 0,\\n            \\\"Nullable number not allowed\\\"\\n        );\\n        require(\\n            maxNumberOfSlotsPerStaker <= pool.SLOTS,\\n            \\\"Exceeded limit\\\"\\n        );\\n        pool.MAX_NUMBER_OF_SLOTS_PER_STAKER = maxNumberOfSlotsPerStaker;\\n    }\\n\\n    /*\\n    ** @dev Add pool Slots only for the pool owner.\\n    */\\n    function addPoolSlots(uint256 poolId, uint256 slots) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        \\n        require(\\n            pool.ENABLED == true,\\n            \\\"Pool disabled\\\"\\n        );\\n        require(slots > 0,\\n            \\\"Nullable number not allowed\\\"\\n        );\\n        uint256 quantityOfCoinB = pool.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT.mul(slots);\\n\\n        require(IERC20(pool.COIN_B).transferFrom(msg.sender, address(this), quantityOfCoinB) == true,\\n            \\\"Balance empty\\\"\\n        );\\n\\n        pool.SLOTS += slots;\\n        pool.LIQUIDITY += quantityOfCoinB;\\n    }\\n\\n    /*\\n    ** @dev Disabling pool if slots is empty only the pool owner can disable.\\n    */\\n    function disablePool(uint256 poolId) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        \\n        require(\\n            pool.ENABLED == true,\\n            \\\"Pool disabled\\\"\\n        );\\n        pool.ENABLED = false;\\n        pool.STAKABLE = false;\\n    }\\n\\n    /*\\n    ** @dev Unused tokens recovery function of the pool deactivated.\\n    ** Can be called by the contract owner, but the funds go only to the pool creator.\\n    ** The pool must be deactivated beforehand.\\n    */\\n    function takeRemainingPool(uint256 poolId) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        \\n        require(\\n            pool.ENABLED == false,\\n            \\\"Pool disabled\\\"\\n        );\\n        IERC20 coinB = IERC20(pool.COIN_B);\\n        uint256 balance = coinB.balanceOf(address(this));\\n        uint256 poolRemainingSlots = pool.SLOTS.sub(pool.SLOTS_FINISHED).sub(pool.SLOTS_USED);\\n        uint256 poolRemainingAmount = pool.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT.mul(poolRemainingSlots);\\n\\n        pool.SLOTS = pool.SLOTS_FINISHED.add(pool.SLOTS_USED);\\n        if (balance >= poolRemainingAmount) {\\n            require(coinB.transfer(pool.OWNER, poolRemainingAmount) == true, \\\"Error transfer\\\");\\n            pool.LIQUIDITY -= poolRemainingAmount;\\n        }\\n    }\\n\\n    /*\\n    ** @dev Enable stakes in pool only for pool owner.\\n    */\\n    function enablePoolStakes(uint256 poolId) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        \\n        require(\\n            pool.ENABLED == true,\\n            \\\"Pool disabled\\\"\\n        );\\n        require(\\n            pool.STAKABLE == false,\\n            \\\"Pool actually usable\\\"\\n        );\\n\\n        pool.STAKABLE = true;\\n    }\\n\\n    /*\\n    ** @dev Disable stakes in pool only for pool owner.\\n    */\\n    function disablePoolStakes(uint256 poolId) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        \\n        require(\\n            pool.ENABLED == true,\\n            \\\"Pool disabled\\\"\\n        );\\n        require(\\n            pool.STAKABLE == true,\\n            \\\"Pool actually unusable\\\"\\n        );\\n\\n        pool.STAKABLE = false;\\n    }\\n\\n    /*\\n    ** @dev Unlock Staker option if necessary.\\n    */\\n    function unlockStaker(uint256 poolId, address stakerAddress) public onlyPoolOwner(poolId) {\\n        Pool storage pool = _pools[poolId];\\n        Staking storage staker = pool._stakers[stakerAddress];\\n\\n        require(\\n            staker.WALLET == stakerAddress,\\n            \\\"No stake\\\"\\n        );\\n        staker.LOCKED = false;\\n    }\\n\\n    /*\\n    ** @dev set pool creation cost only for contract owner\\n    */\\n    function setPoolCreationCost(uint256 cost) public onlyContractOwner {\\n        _poolCreationCost = cost;\\n    }\\n\\n    /*\\n    ** @dev transfer natives BNB of the contract to the owner of the contract\\n    */\\n    function transferBNB(address payable _to, uint _amount) public onlyContractOwner {\\n        (bool success, ) = _to.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Failed to send BNB\\\");\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"LOCK_COIN\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"EARN_COIN\",\"type\":\"address\"}],\"name\":\"NewPool\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slots\",\"type\":\"uint256\"}],\"name\":\"addPoolSlots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coinA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coinB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDurationInDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantityOfCoinAPerSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantityOfCoinBRewardablePerSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumberOfSlotsPerStaker\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"disablePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"disablePoolStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"enablePoolStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"COIN_A\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"COIN_B\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LOCK_DURATION_IN_DAY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"QUANTITY_OF_COIN_A_PER_SLOT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS_USED\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS_FINISHED\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MAX_NUMBER_OF_SLOTS_PER_STAKER\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TSV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TVL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LIQUIDITY\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ENABLED\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"STAKABLE\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"STACKER_COUNT\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"OWNER\",\"type\":\"address\"}],\"internalType\":\"struct PoolInformation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolCreationCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getPoolStaker\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"WALLET\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"STAKING_POOL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"START\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"LOCKED\",\"type\":\"bool\"}],\"internalType\":\"struct Staking\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"page\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"pageSize\",\"type\":\"int256\"}],\"name\":\"getPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"COIN_A\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"COIN_B\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LOCK_DURATION_IN_DAY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"QUANTITY_OF_COIN_A_PER_SLOT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS_USED\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SLOTS_FINISHED\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MAX_NUMBER_OF_SLOTS_PER_STAKER\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TSV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TVL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LIQUIDITY\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ENABLED\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"STAKABLE\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"STACKER_COUNT\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"OWNER\",\"type\":\"address\"}],\"internalType\":\"struct PoolInformation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"setPoolCreationCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumberOfSlotsPerStaker\",\"type\":\"uint256\"}],\"name\":\"setPoolMaxNumberOfSlotsPerStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slots\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"takeRemainingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claim\",\"type\":\"bool\"}],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"unlockStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CheckDotStakingProtocolContract", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}