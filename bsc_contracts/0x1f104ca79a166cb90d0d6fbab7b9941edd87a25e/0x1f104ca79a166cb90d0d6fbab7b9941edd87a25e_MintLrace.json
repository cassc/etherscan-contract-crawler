{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/eip/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interface/IERC1155.sol\\\";\\nimport \\\"./interface/IERC1155Metadata.sol\\\";\\nimport \\\"./interface/IERC1155Receiver.sol\\\";\\n\\ncontract ERC1155 is IERC1155, IERC1155Metadata {\\n    /*//////////////////////////////////////////////////////////////\\n                        State variables\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n    string public symbol;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Mappings\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    mapping(uint256 => string) internal _uri;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Constructor\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            View functions\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\\n        return _uri[tokenId];\\n    }\\n\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf[accounts[i]][ids[i]];\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC1155 logic\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        address owner = msg.sender;\\n        require(owner != operator, \\\"APPROVING_SELF\\\");\\n        isApprovedForAll[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(from == msg.sender || isApprovedForAll[from][msg.sender], \\\"!OWNER_OR_APPROVED\\\");\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(from == msg.sender || isApprovedForAll[from][msg.sender], \\\"!OWNER_OR_APPROVED\\\");\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Internal logic\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"TO_ZERO_ADDR\\\");\\n\\n        address operator = msg.sender;\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = balanceOf[from][id];\\n        require(fromBalance >= amount, \\\"INSUFFICIENT_BAL\\\");\\n        unchecked {\\n            balanceOf[from][id] = fromBalance - amount;\\n        }\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n        require(to != address(0), \\\"TO_ZERO_ADDR\\\");\\n\\n        address operator = msg.sender;\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = balanceOf[from][id];\\n            require(fromBalance >= amount, \\\"INSUFFICIENT_BAL\\\");\\n            unchecked {\\n                balanceOf[from][id] = fromBalance - amount;\\n            }\\n            balanceOf[to][id] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    function _setTokenURI(uint256 tokenId, string memory newuri) internal virtual {\\n        _uri[tokenId] = newuri;\\n    }\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"TO_ZERO_ADDR\\\");\\n\\n        address operator = msg.sender;\\n\\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        balanceOf[to][id] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"TO_ZERO_ADDR\\\");\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        address operator = msg.sender;\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"FROM_ZERO_ADDR\\\");\\n\\n        address operator = msg.sender;\\n\\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 fromBalance = balanceOf[from][id];\\n        require(fromBalance >= amount, \\\"INSUFFICIENT_BAL\\\");\\n        unchecked {\\n            balanceOf[from][id] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n    }\\n\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"FROM_ZERO_ADDR\\\");\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        address operator = msg.sender;\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = balanceOf[from][id];\\n            require(fromBalance >= amount, \\\"INSUFFICIENT_BAL\\\");\\n            unchecked {\\n                balanceOf[from][id] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.code.length > 0) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"TOKENS_REJECTED\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"!ERC1155RECEIVER\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.code.length > 0) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"TOKENS_REJECTED\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"!ERC1155RECEIVER\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/eip/interface/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\n/**\\n    @title ERC-1155 Multi Token Standard\\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\\n */\\ninterface IERC1155 {\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be msg.sender.\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_id` argument MUST be the token type being transferred.\\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferSingle(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _id,\\n        uint256 _value\\n    );\\n\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be msg.sender.\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_ids` argument MUST be the list of tokens being transferred.\\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferBatch(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256[] _ids,\\n        uint256[] _values\\n    );\\n\\n    /**\\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\\n    */\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /**\\n        @dev MUST emit when the URI is updated for a token ID.\\n        URIs are defined in RFC 3986.\\n        The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".\\n    */\\n    event URI(string _value, uint256 indexed _id);\\n\\n    /**\\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\\n        MUST revert on any other error.\\n        MUST emit the `TransferSingle` event to reflect the balance change (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _id      ID of the token type\\n        @param _value   Transfer amount\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\\n    */\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if length of `_ids` is not the same as length of `_values`.\\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\\n        MUST revert on any other error.\\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _ids     IDs of each token type (order and length must match _values array)\\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\\n    */\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n        @notice Get the balance of an account's Tokens.\\n        @param _owner  The address of the token holder\\n        @param _id     ID of the Token\\n        @return        The _owner's balance of the Token type requested\\n     */\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n    /**\\n        @notice Get the balance of multiple account/token pairs\\n        @param _owners The addresses of the token holders\\n        @param _ids    ID of the Tokens\\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n     */\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n        @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\n        @dev MUST emit the ApprovalForAll event on success.\\n        @param _operator  Address to add to the set of authorized operators\\n        @param _approved  True if the operator is approved, false to revoke approval\\n    */\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /**\\n        @notice Queries the approval status of an operator for a given owner.\\n        @param _owner     The owner of the Tokens\\n        @param _operator  Address of authorized operator\\n        @return           True if the operator is approved, false if not\\n    */\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/eip/interface/IERC1155Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\n/**\\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\\n*/\\ninterface IERC1155Metadata {\\n    /**\\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\\n        @dev URIs are defined in RFC 3986.\\n        The URI may point to a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".\\n        @return URI string\\n    */\\n    function uri(uint256 _id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/eip/interface/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/eip/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.12;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/extension/BatchMintMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\n/**\\n *  @title   Batch-mint Metadata\\n *  @notice  The `BatchMintMetadata` is a contract extension for any base NFT contract. It lets the smart contract\\n *           using this extension set metadata for `n` number of NFTs all at once. This is enabled by storing a single\\n *           base URI for a batch of `n` NFTs, where the metadata for each NFT in a relevant batch is `baseURI/tokenId`.\\n */\\n\\ncontract BatchMintMetadata {\\n    /// @dev Largest tokenId of each batch of tokens with the same baseURI.\\n    uint256[] private batchIds;\\n\\n    /// @dev Mapping from id of a batch of tokens => to base URI for the respective batch of tokens.\\n    mapping(uint256 => string) private baseURI;\\n\\n    /**\\n     *  @notice         Returns the count of batches of NFTs.\\n     *  @dev            Each batch of tokens has an in ID and an associated `baseURI`.\\n     *                  See {batchIds}.\\n     */\\n    function getBaseURICount() public view returns (uint256) {\\n        return batchIds.length;\\n    }\\n\\n    /**\\n     *  @notice         Returns the ID for the batch of tokens the given tokenId belongs to.\\n     *  @dev            See {getBaseURICount}.\\n     *  @param _index   ID of a token.\\n     */\\n    function getBatchIdAtIndex(uint256 _index) public view returns (uint256) {\\n        if (_index >= getBaseURICount()) {\\n            revert(\\\"Invalid index\\\");\\n        }\\n        return batchIds[_index];\\n    }\\n\\n    /// @dev Returns the id for the batch of tokens the given tokenId belongs to.\\n    function _getBatchId(uint256 _tokenId) internal view returns (uint256 batchId, uint256 index) {\\n        uint256 numOfTokenBatches = getBaseURICount();\\n        uint256[] memory indices = batchIds;\\n\\n        for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\\n            if (_tokenId < indices[i]) {\\n                index = i;\\n                batchId = indices[i];\\n\\n                return (batchId, index);\\n            }\\n        }\\n\\n        revert(\\\"Invalid tokenId\\\");\\n    }\\n\\n    /// @dev Returns the baseURI for a token. The intended metadata URI for the token is baseURI + tokenId.\\n    function _getBaseURI(uint256 _tokenId) internal view returns (string memory) {\\n        uint256 numOfTokenBatches = getBaseURICount();\\n        uint256[] memory indices = batchIds;\\n\\n        for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\\n            if (_tokenId < indices[i]) {\\n                return baseURI[indices[i]];\\n            }\\n        }\\n        revert(\\\"Invalid tokenId\\\");\\n    }\\n\\n    /// @dev Sets the base URI for the batch of tokens with the given batchId.\\n    function _setBaseURI(uint256 _batchId, string memory _baseURI) internal {\\n        baseURI[_batchId] = _baseURI;\\n    }\\n\\n    /// @dev Mints a batch of tokenIds and associates a common baseURI to all those Ids.\\n    function _batchMintMetadata(\\n        uint256 _startId,\\n        uint256 _amountToMint,\\n        string memory _baseURIForTokens\\n    ) internal returns (uint256 nextTokenIdToMint, uint256 batchId) {\\n        batchId = _startId + _amountToMint;\\n        nextTokenIdToMint = batchId;\\n\\n        batchIds.push(batchId);\\n\\n        baseURI[batchId] = _baseURIForTokens;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extension/ContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./interface/IContractMetadata.sol\\\";\\n\\n/**\\n *  @title   Contract Metadata\\n *  @notice  `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *           for you contract.\\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\nabstract contract ContractMetadata is IContractMetadata {\\n    /// @notice Returns the contract metadata URI.\\n    string public override contractURI;\\n\\n    /**\\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\\n     *                  See {_canSetContractURI}.\\n     *                  Emits {ContractURIUpdated Event}.\\n     *\\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     */\\n    function setContractURI(string memory _uri) external override {\\n        if (!_canSetContractURI()) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n\\n        _setupContractURI(_uri);\\n    }\\n\\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\\n    function _setupContractURI(string memory _uri) internal {\\n        string memory prevURI = contractURI;\\n        contractURI = _uri;\\n\\n        emit ContractURIUpdated(prevURI, _uri);\\n    }\\n\\n    /// @dev Returns whether contract metadata can be set in the given execution context.\\n    function _canSetContractURI() internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/extension/interface/IContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\n/**\\n *  `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *  for you contract.\\n *\\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\ninterface IContractMetadata {\\n    /// @dev Returns the metadata URI of the contract.\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\\n     *       Only module admin can call this function.\\n     */\\n    function setContractURI(string calldata _uri) external;\\n\\n    /// @dev Emitted when the contract URI is updated.\\n    event ContractURIUpdated(string prevURI, string newURI);\\n}\\n\"\r\n    },\r\n    \"contracts/extension/interface/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.12;\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\ninterface IMulticall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/extension/interface/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\n/**\\n *  `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\\n *  who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\\n *  information about who the contract's owner is.\\n */\\n\\ninterface IOwnable {\\n    /// @dev Returns the owner of the contract.\\n    function owner() external view returns (address);\\n\\n    /// @dev Lets a module admin set a new owner for the contract. The new owner must be a module admin.\\n    function setOwner(address _newOwner) external;\\n\\n    /// @dev Emitted when a new Owner is set.\\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\\n}\\n\"\r\n    },\r\n    \"contracts/extension/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"../lib/IAddress.sol\\\";\\nimport \\\"./interface/IMulticall.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\ncontract Multicall is IMulticall {\\n    /**\\n     *  @notice Receives and executes a batch of function calls on this contract.\\n     *  @dev Receives and executes a batch of function calls on this contract.\\n     *\\n     *  @param data The bytes data that makes up the batch of function calls to execute.\\n     *  @return results The bytes data that makes up the result of the batch of function calls executed.\\n     */\\n    function multicall(bytes[] calldata data) external virtual override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = IAddress.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extension/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./interface/IOwnable.sol\\\";\\n\\n/**\\n *  @title   Ownable\\n *  @notice  `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\\n *           who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\\n *           information about who the contract's owner is.\\n */\\n\\nabstract contract Ownable is IOwnable {\\n    /// @dev Owner of the contract (purpose: OpenSea compatibility)\\n    address private _owner;\\n\\n    /// @dev Reverts if caller is not the owner.\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n        _;\\n    }\\n\\n    /**\\n     *  @notice Returns the owner of the contract.\\n     */\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     *  @notice Lets an authorized wallet set a new owner for the contract.\\n     *  @param _newOwner The address to set as the new owner of the contract.\\n     */\\n    function setOwner(address _newOwner) external override {\\n        if (!_canSetOwner()) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n        _setupOwner(_newOwner);\\n    }\\n\\n    /// @dev Lets a contract admin set a new owner for the contract. The new owner must be a contract admin.\\n    function _setupOwner(address _newOwner) internal {\\n        address _prevOwner = _owner;\\n        _owner = _newOwner;\\n\\n        emit OwnerUpdated(_prevOwner, _newOwner);\\n    }\\n\\n    /// @dev Returns whether owner can be set in the given execution context.\\n    function _canSetOwner() internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.12;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary IAddress {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * [EIP1884](https://eips.ethereum.org/EIPS/eip-1884) increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary IStrings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MintLrace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\nimport {ERC1155} from \\\"./eip/ERC1155.sol\\\";\\n// import \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n\\nimport \\\"./extension/ContractMetadata.sol\\\";\\nimport \\\"./extension/Multicall.sol\\\";\\nimport \\\"./extension/Ownable.sol\\\";\\nimport \\\"./extension/BatchMintMetadata.sol\\\";\\n\\nimport \\\"./lib/IStrings.sol\\\";\\n\\ncontract MintLrace is\\n    ERC1155,\\n    ContractMetadata,\\n    Ownable,\\n    Multicall,\\n    BatchMintMetadata\\n{\\n    using IStrings for uint256;\\n    using Counters for Counters.Counter;\\n\\n    event Minted(\\n        uint256 _tokenId,\\n        address _to,\\n        string _tokenURI,\\n        uint256 _amount,\\n        address _tokenAddress\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        State variables\\n    //////////////////////////////////////////////////////////////*/\\n\\n    Counters.Counter private tokenIdCounter;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        Mappings\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => uint256) public totalSupply;\\n    mapping(uint256 => uint256[]) private _capability;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Constructor\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC1155(_name, _symbol) {\\n        _setupOwner(msg.sender);\\n    }\\n\\n    modifier onlyTokenOwner(uint256 _tokenId) {\\n        require(balanceOf[msg.sender][_tokenId] > 0, \\\"!OWNER\\\");\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    Overridden metadata logic\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(\\n        uint256 _tokenId\\n    ) public view virtual override returns (string memory) {\\n        string memory uriForToken = _uri[_tokenId];\\n        if (bytes(uriForToken).length > 0) {\\n            return uriForToken;\\n        }\\n\\n        string memory batchUri = _getBaseURI(_tokenId);\\n        return string(abi.encodePacked(batchUri, _tokenId.toString()));\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        Mint / burn logic\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mintTo(\\n        address _to,\\n        uint256[] memory capabilities,\\n        string memory _tokenURI,\\n        uint256 _amount\\n    ) public virtual onlyOwner {\\n        require(capabilities.length == 4, \\\"Invalid capability length\\\");\\n        for (uint256 i = 0; i < 4; i++) {\\n            require(\\n                capabilities[i] >= 10 && capabilities[i] <= 100,\\n                \\\"Invalid capability\\\"\\n            );\\n        }\\n        uint256 tokenIdToMint = getNextTokenIdToMint();\\n        _mint(_to, tokenIdToMint, _amount, \\\"\\\");\\n        _setTokenURI(tokenIdToMint, _tokenURI);\\n        _capability[tokenIdToMint] = capabilities;\\n        emit Minted(tokenIdToMint, _to, _tokenURI, _amount, address(this));\\n    }\\n\\n    function batchMintTo(\\n        address _to,\\n        uint256 _nftCount,\\n        uint256[] memory _amounts,\\n        string memory _baseURI\\n    ) public virtual {\\n        require(_amounts.length > 0, \\\"Minting zero tokens.\\\");\\n        require(_nftCount == _amounts.length, \\\"Length mismatch.\\\");\\n\\n        uint256[] memory _tokenIds;\\n\\n        for (uint256 i = 0; i < _nftCount; i += 1) {\\n            _tokenIds[i] = getNextTokenIdToMint();\\n        }\\n\\n        if (_nftCount > 0) {\\n            _batchMintMetadata(_tokenIds[0], _nftCount, _baseURI);\\n        }\\n\\n        _mintBatch(_to, _tokenIds, _amounts, \\\"\\\");\\n    }\\n\\n    function burn(\\n        address _owner,\\n        uint256 _tokenId,\\n        uint256 _amount\\n    ) external virtual {\\n        address caller = msg.sender;\\n\\n        require(\\n            caller == _owner || isApprovedForAll[_owner][caller],\\n            \\\"Unapproved caller\\\"\\n        );\\n        require(\\n            balanceOf[_owner][_tokenId] >= _amount,\\n            \\\"Not enough tokens owned\\\"\\n        );\\n\\n        _burn(_owner, _tokenId, _amount);\\n    }\\n\\n    function burnBatch(\\n        address _owner,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _amounts\\n    ) external virtual {\\n        address caller = msg.sender;\\n\\n        require(\\n            caller == _owner || isApprovedForAll[_owner][caller],\\n            \\\"Unapproved caller\\\"\\n        );\\n        require(_tokenIds.length == _amounts.length, \\\"Length mismatch\\\");\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i += 1) {\\n            require(\\n                balanceOf[_owner][_tokenIds[i]] >= _amounts[i],\\n                \\\"Not enough tokens owned\\\"\\n            );\\n        }\\n\\n        _burnBatch(_owner, _tokenIds, _amounts);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            View functions\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getCurrentTokenId() public view virtual returns (uint) {\\n        return tokenIdCounter.current();\\n    }\\n\\n    function getCapability(uint256 id) public view returns (uint256[] memory) {\\n        uint256[] memory _capabilities = new uint256[](4);\\n        _capabilities[0] = _capability[id][0];\\n        _capabilities[1] = _capability[id][1];\\n        _capabilities[2] = _capability[id][2];\\n        _capabilities[3] = _capability[id][3];\\n        return _capabilities;\\n    }\\n\\n    function getUserBalance(\\n        address _user,\\n        uint256 _tokenId\\n    ) public view virtual returns (uint256) {\\n        return balanceOf[_user][_tokenId];\\n    }\\n\\n    struct Token {\\n        uint256 tokenId;\\n        address tokenAddress;\\n        uint256 balance;\\n        string uri;\\n        address walletAddress;\\n        uint256[] capability;\\n    }\\n\\n    function getUserTokens(\\n        address user\\n    ) public view virtual returns (Token[] memory) {\\n        uint256 index = 0;\\n        uint256 lastTokenId = tokenIdCounter.current();\\n        Token[] memory tokens = new Token[](lastTokenId);\\n        for (uint i = 1; i <= lastTokenId; i++) {\\n            uint256 balance = balanceOf[user][i];\\n            if (balance > 0) {\\n                tokens[index] = Token(\\n                    i,\\n                    address(this),\\n                    balance,\\n                    uri(i),\\n                    user,\\n                    getCapability(i)\\n                );\\n                index += 1;\\n            }\\n        }\\n        return tokens;\\n    }\\n\\n    function getUserTokenById(\\n        address _userAddress,\\n        uint256 _tokenId\\n    ) public view virtual returns (Token memory) {\\n        return\\n            Token(\\n                _tokenId,\\n                address(this),\\n                balanceOf[_userAddress][_tokenId],\\n                uri(_tokenId),\\n                _userAddress,\\n                getCapability(_tokenId)\\n            );\\n    }\\n\\n    function getNextTokenIdToMint() private returns (uint) {\\n        tokenIdCounter.increment();\\n        return tokenIdCounter.current();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    Internal (overrideable) functions\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _canSetContractURI()\\n        internal\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return msg.sender == owner();\\n    }\\n\\n    function _canMint() internal view virtual returns (bool) {\\n        return msg.sender == owner();\\n    }\\n\\n    function _canSetOwner() internal view virtual override returns (bool) {\\n        return msg.sender == owner();\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                totalSupply[ids[i]] += amounts[i];\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                totalSupply[ids[i]] -= amounts[i];\\n            }\\n        }\\n    }\\n\\n    function editCapability(\\n        uint256 id,\\n        uint256[] memory capabilities\\n    ) external onlyOwner {\\n        require(capabilities.length == 4, \\\"Invalid capability length\\\");\\n        for (uint256 i = 0; i < 4; i++) {\\n            require(\\n                capabilities[i] >= 10 && capabilities[i] <= 100,\\n                \\\"Invalid capability\\\"\\n            );\\n        }\\n\\n        _capability[id] = capabilities;\\n    }\\n\\n    function transferAny(uint256 _tokenId, uint256 amount) external onlyOwner {\\n        _safeTransferFrom(address(this), msg.sender, _tokenId, amount, \\\"\\\");\\n    }\\n\\n    function transferTo(\\n        uint256 _tokenId,\\n        address _to,\\n        uint256 amount\\n    ) external onlyTokenOwner(_tokenId) {\\n        require(\\n            amount <= balanceOf[msg.sender][_tokenId],\\n            \\\"Insufficient funds\\\"\\n        );\\n        _safeTransferFrom(msg.sender, _to, _tokenId, amount, \\\"\\\");\\n    }\\n\\n    function updateUri(\\n        uint256 _tokenId,\\n        string memory _newUri\\n    ) external virtual onlyOwner {\\n        _uri[_tokenId] = _newUri;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"prevURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"batchMintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"capabilities\",\"type\":\"uint256[]\"}],\"name\":\"editCapability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseURICount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getBatchIdAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getCapability\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUserTokenById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"capability\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MintLrace.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"capability\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MintLrace.Token[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"capabilities\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newUri\",\"type\":\"string\"}],\"name\":\"updateUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MintLrace", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000084c7573745261636500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024c52000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}