{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/proxy-p2p/ProxyP2P.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport './bets/custom/CustomProcessor.sol';\\nimport './bets/jackpot/JackpotProcessor.sol';\\nimport './event/EventProcessor.sol';\\nimport './security/Security.sol';\\n\\ncontract ProxyP2P is CustomProcessor, JackpotProcessor, EventProcessor {\\n\\n    constructor(address[] memory owners) {\\n        for (uint i = 0; i < owners.length; i++) {\\n            addOwner(owners[i]);\\n        }\\n    }\\n\\n    function closeCustomBet(uint betId, string calldata finalValue, bool targetSideWon) external onlyController {\\n        ProxyCustomDTOs.CustomBet memory customBet = getCustomBet(betId);\\n\\n        EventDTOs.EventResult memory eventData = getChainlinkResult(customBet.expirationTime, customBet.eventId);\\n\\n        closeCustomBet(betId, finalValue, targetSideWon, eventData, customBet);\\n    }\\n\\n    function createJackpotBet(ProxyJackpotDTOs.CreateJackpotRequest calldata createRequest) external onlyController returns (uint) {\\n        require(eventMapping[createRequest.eventId].alive, \\\"ProxyP2P.createJackpotBet: eventId not present\\\");\\n\\n        return callCreateJackpotBet(createRequest);\\n    }\\n\\n    function closeJackpotBet(uint betId) external onlyController {\\n        (ProxyJackpotDTOs.JackpotBet memory jackpotBet,) = getJackpotBet(betId);\\n\\n        EventDTOs.EventResult memory eventData = getChainlinkResult(jackpotBet.expirationTime, jackpotBet.eventId);\\n\\n        closeJackpotBet(betId, eventData);\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/bets/custom/CustomProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport './api/CustomApi.sol';\\nimport '../../security/Security.sol';\\nimport '../../event/EventDTOs.sol';\\nimport '../../utils/StringConverter.sol';\\n\\ncontract CustomProcessor is Security {\\n    SecurityDTOs.SetCustomAdapter public setCustomAdapter;\\n    CustomApi public customBetAdapter;\\n\\n    event CustomAdapterSet(address customBetAdapter);\\n\\n    event ProxyCustomResultChanged (\\n        bool targetSideWon,\\n        string finalValue,\\n        address oracleAddress,\\n        uint oracleRoundId\\n    );\\n\\n    function startSetCustomAdapter(address customBetAddress) external onlyOwner() {\\n        uint votingCode = startVoting(\\\"SET_CUSTOM_ADAPTER\\\");\\n        setCustomAdapter = SecurityDTOs.SetCustomAdapter(\\n            customBetAddress,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireSetCustomAdapter() external onlyOwner {\\n        pass(setCustomAdapter.votingCode);\\n        customBetAdapter = CustomApi(setCustomAdapter.customAdapter);\\n        emit CustomAdapterSet(setCustomAdapter.customAdapter);\\n    }\\n\\n    function getCustomBet(uint betId) internal view returns (ProxyCustomDTOs.CustomBet memory) {\\n        (ProxyCustomDTOs.CustomBet memory customBet,,,,) = customBetAdapter.getCustomBet(betId);\\n        return customBet;\\n    }\\n\\n    function closeCustomBet(\\n        uint betId,\\n        string calldata finalValue,\\n        bool targetSideWon,\\n        EventDTOs.EventResult memory eventData,\\n        ProxyCustomDTOs.CustomBet memory customBet) internal {\\n        if (!eventData.isEventPresent) {\\n            customBetAdapter.closeCustomBet(betId, finalValue, targetSideWon);\\n            return;\\n        }\\n\\n        uint targetValue = StringConverter.convertToUint(customBet.targetValue, eventData.decimals);\\n\\n        bool chainlinkTargetSideWon = (targetValue < eventData.result) == customBet.targetSide;\\n\\n        string memory chainlinkFinalValue = StringConverter.convertToString(eventData.result, eventData.resultScale, eventData.decimals);\\n\\n        emit ProxyCustomResultChanged(chainlinkTargetSideWon, chainlinkFinalValue, eventData.oracleAddress, eventData.roundId);\\n\\n        customBetAdapter.closeCustomBet(betId, chainlinkFinalValue, chainlinkTargetSideWon);\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/bets/jackpot/JackpotProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport './api/JackpotApi.sol';\\nimport '../../security/Security.sol';\\nimport '../../event/EventDTOs.sol';\\nimport '../../utils/StringConverter.sol';\\n\\ncontract JackpotProcessor is Security {\\n    SecurityDTOs.SetJackpotAdapter public setJackpotAdapter;\\n    JackpotApi public jackpotBetAdapter;\\n\\n    event JackpotAdapterSet(address jackpotBetAdapter);\\n\\n    event ProxyJackpotResult (\\n        string finalValue,\\n        address oracleAddress,\\n        uint oracleRoundId\\n    );\\n\\n    function startSetJackpotAdapter(address jackpotBetAddress) external onlyOwner() {\\n        uint votingCode = startVoting(\\\"SET_JACKPOT_ADAPTER\\\");\\n        setJackpotAdapter = SecurityDTOs.SetJackpotAdapter(\\n            jackpotBetAddress,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireSetJackpotAdapter() external onlyOwner {\\n        pass(setJackpotAdapter.votingCode);\\n        jackpotBetAdapter = JackpotApi(setJackpotAdapter.jackpotAdapter);\\n        emit JackpotAdapterSet(setJackpotAdapter.jackpotAdapter);\\n    }\\n\\n    function getJackpotBet(uint betId) public view returns (ProxyJackpotDTOs.JackpotBet memory, uint) {\\n        return jackpotBetAdapter.getJackpotBet(betId);\\n    }\\n\\n    function callCreateJackpotBet(ProxyJackpotDTOs.CreateJackpotRequest calldata createRequest) internal returns (uint) {\\n        return jackpotBetAdapter.createJackpotBet(createRequest);\\n    }\\n\\n    function closeJackpotBet(uint betId, EventDTOs.EventResult memory eventData) internal {\\n        require(eventData.isEventPresent, \\\"JackpotProcessor.closeJackpotBet: oracle result not present\\\");\\n\\n        string memory finalValue = StringConverter.convertToString(eventData.result, eventData.resultScale, eventData.decimals);\\n\\n        emit ProxyJackpotResult(finalValue, eventData.oracleAddress, eventData.roundId);\\n\\n        jackpotBetAdapter.closeJackpotBet(betId, finalValue);\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/event/EventProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport './EventController.sol';\\nimport './chainlink/AggregatorInterface.sol';\\n\\ncontract EventProcessor is EventController {\\n\\n    // returns (uint result, uint decimals, bool isEventPresent)\\n    function getChainlinkResult(uint expirationTime, string memory eventId) internal view returns (EventDTOs.EventResult memory) {\\n        if (!eventMapping[eventId].alive) {\\n            return EventDTOs.EventResult(0, 0, false, 0, address(0), 0);\\n        }\\n\\n        return findClosestResult(expirationTime, eventId);\\n    }\\n\\n    function getResult(uint expirationTime, string memory eventId) external view returns (bool, uint, uint) {\\n        EventDTOs.EventResult memory result = findClosestResult(expirationTime, eventId);\\n        return (result.isEventPresent, result.result, result.decimals);\\n    }\\n\\n    function findClosestResult(uint expirationTime, string memory eventId) private view returns (EventDTOs.EventResult memory) {\\n        AggregatorInterface aggregator = AggregatorInterface(eventMapping[eventId].chainlinkAggregatorProxy);\\n\\n        uint lastRoundId = aggregator.latestRound();\\n        require(aggregator.getTimestamp(lastRoundId) > expirationTime, \\\"EventProcessor.findClosestResult: result not present\\\");\\n\\n        while (aggregator.getTimestamp(lastRoundId) > expirationTime) {\\n            lastRoundId--;\\n        }\\n\\n        uint answer = uint(aggregator.getAnswer(lastRoundId + 1));\\n        uint8 decimal = aggregator.decimals();\\n\\n        return EventDTOs.EventResult(answer, decimal, true, eventMapping[eventId].resultScale, eventMapping[eventId].chainlinkAggregatorProxy, lastRoundId + 1);\\n\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/security/Security.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./Voting.sol\\\";\\n\\nabstract contract Security is Voting {\\n    SecurityDTOs.AddOwner public addOwnerVoting;\\n    SecurityDTOs.AddController public addControllerVoting;\\n    SecurityDTOs.RemoveOwner public removeOwnerVoting;\\n    SecurityDTOs.RemoveController public removeControllerVoting;\\n\\n\\n    // Start voting for add owner\\n    function ownerAddStart(address newOwner) external onlyOwner {\\n        require(!owners[newOwner], \\\"Security.ownerAddStart: already owner\\\");\\n\\n        uint votingCode = startVoting(\\\"ADD_OWNER\\\");\\n        addOwnerVoting = SecurityDTOs.AddOwner(\\n            newOwner,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireNewOwner() external onlyOwner {\\n        pass(addOwnerVoting.votingCode);\\n        addOwner(addOwnerVoting.newOwner);\\n    }\\n\\n    function controllerAddStart(address newController) public virtual onlyOwner {\\n        require(!controllers[newController], \\\"Security.controllerAddStart: already controller\\\");\\n        require(newController != address(0), \\\"Security.controllerAddStart: new controller is the zero address\\\");\\n\\n        uint votingCode = startVoting(\\\"TRANSFER_COMPANY\\\");\\n        addControllerVoting = SecurityDTOs.AddController(\\n            newController,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireAddController() external onlyOwner {\\n        pass(addControllerVoting.votingCode);\\n        addController(addControllerVoting.newController);\\n    }\\n\\n    function controllerToRemoveStart(address controllerToRemove) external onlyOwner {\\n        require(controllers[controllerToRemove], \\\"Security: is not controller\\\");\\n\\n        uint votingCode = startVoting(\\\"REMOVE_CONTROLLER\\\");\\n        removeControllerVoting = SecurityDTOs.RemoveController(\\n            controllerToRemove,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireRemoveController() external onlyOwner {\\n        pass(removeControllerVoting.votingCode);\\n        removeController(removeControllerVoting.controllerToRemove);\\n    }\\n\\n    // Start voting removing owner\\n    function ownerToRemoveStart(address ownerToRemove) external onlyOwner {\\n        require(owners[ownerToRemove], \\\"Security: is not owner\\\");\\n\\n        uint votingCode = startVoting(\\\"REMOVE_OWNER\\\");\\n        removeOwnerVoting = SecurityDTOs.RemoveOwner(\\n            ownerToRemove,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireOwnerToRemove() external onlyOwner {\\n        pass(removeOwnerVoting.votingCode);\\n        removeOwner(removeOwnerVoting.ownerToRemove);\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/bets/custom/api/CustomApi.sol\": {\r\n      \"content\": \"pragma solidity 0.8.2;\\n\\nimport './ProxyCustomDTOs.sol';\\n\\ninterface CustomApi {\\n    function closeCustomBet(uint betId, string calldata finalValue, bool targetSideWon) external;\\n\\n    function getCustomBet(uint betId) external view returns (ProxyCustomDTOs.CustomBet memory, uint, uint, uint, uint);\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/event/EventDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\n\\nlibrary EventDTOs {\\n    struct Event {\\n        string eventId;\\n        address chainlinkAggregatorProxy;\\n        uint8 resultScale;\\n        bool alive;\\n    }\\n\\n    struct EventResult {\\n        uint result;\\n        uint8 decimals;\\n        bool isEventPresent;\\n        uint8 resultScale;\\n        address oracleAddress;\\n        uint roundId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/utils/StringConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport './strings.sol';\\n\\nlibrary StringConverter {\\n    using strings for *;\\n\\n    function convertToString(uint value, uint8 resultScale, uint8 decimals) internal pure returns (string memory) {\\n        string memory integerPart = uintToString(value / (10 ** decimals));\\n        string memory fractionalPart = uintToString((value % (10 ** decimals)) / (10 ** (decimals - resultScale)));\\n\\n        strings.slice memory fractionalSlicePart = addZeros(fractionalPart, resultScale);\\n\\n        return integerPart.toSlice().concat(\\\".\\\".toSlice()).toSlice().concat(fractionalSlicePart);\\n    }\\n\\n    function addZeros(string memory fractionalPart, uint8 resultScale) private pure returns (strings.slice memory) {\\n        strings.slice memory fractionalSlicePart = fractionalPart.toSlice();\\n\\n        if (fractionalSlicePart._len == resultScale) {\\n            return fractionalSlicePart;\\n        }\\n\\n        while (fractionalSlicePart._len != resultScale) {\\n            fractionalSlicePart = \\\"0\\\".toSlice().concat(fractionalSlicePart).toSlice();\\n        }\\n\\n        return fractionalSlicePart;\\n    }\\n\\n    function convertToUint(string memory value, uint8 decimals) internal pure returns (uint) {\\n        strings.slice memory slicedValue = value.toSlice();\\n        strings.slice memory delimiter = \\\".\\\".toSlice();\\n\\n        strings.slice[] memory parts = new strings.slice[](slicedValue.count(delimiter) + 1);\\n\\n        require(parts.length == 2, \\\"StringConverter.convertToUint: wrong value\\\");\\n\\n        parts[0] = slicedValue.split(delimiter);\\n        parts[1] = slicedValue;\\n\\n        uint integerPart = st2num(parts[0].toString());\\n        uint fractionalPart = st2num(parts[1].toString());\\n\\n        return integerPart * (10 ** decimals) + fractionalPart * (10 ** (decimals - parts[1]._len));\\n    }\\n\\n    function st2num(string memory numString) private pure returns (uint) {\\n        uint val = 0;\\n        bytes   memory stringBytes = bytes(numString);\\n        for (uint i = 0; i < stringBytes.length; i++) {\\n            uint exp = stringBytes.length - i;\\n            bytes1 ival = stringBytes[i];\\n            uint8 uval = uint8(ival);\\n            uint jval = uval - uint(0x30);\\n\\n            val += (uint(jval) * (10 ** (exp - 1)));\\n        }\\n        return val;\\n    }\\n\\n    function uintToString(uint value) private pure returns (string memory) {\\n        bytes16 _SYMBOLS = \\\"0123456789abcdef\\\";\\n    unchecked {\\n        uint256 length = log10(value) + 1;\\n        string memory buffer = new string(length);\\n        uint256 ptr;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            ptr := add(buffer, add(32, length))\\n        }\\n        while (true) {\\n            ptr--;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n            }\\n            value /= 10;\\n            if (value == 0) break;\\n        }\\n        return buffer;\\n    }\\n    }\\n\\n    function log10(uint256 value) private pure returns (uint256) {\\n        uint256 result = 0;\\n    unchecked {\\n        if (value >= 10 ** 64) {\\n            value /= 10 ** 64;\\n            result += 64;\\n        }\\n        if (value >= 10 ** 32) {\\n            value /= 10 ** 32;\\n            result += 32;\\n        }\\n        if (value >= 10 ** 16) {\\n            value /= 10 ** 16;\\n            result += 16;\\n        }\\n        if (value >= 10 ** 8) {\\n            value /= 10 ** 8;\\n            result += 8;\\n        }\\n        if (value >= 10 ** 4) {\\n            value /= 10 ** 4;\\n            result += 4;\\n        }\\n        if (value >= 10 ** 2) {\\n            value /= 10 ** 2;\\n            result += 2;\\n        }\\n        if (value >= 10 ** 1) {\\n            result += 1;\\n        }\\n    }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/bets/custom/api/ProxyCustomDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\n\\nlibrary ProxyCustomDTOs {\\n    struct CustomBet {\\n        uint id;\\n        string eventId;\\n        bool hidden;\\n        uint lockTime;\\n        uint expirationTime;\\n        string targetValue;\\n        bool targetSide;\\n        uint coefficient;\\n\\n        string finalValue;\\n        bool targetSideWon;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/security/Voting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\nabstract contract Voting is Ownable {\\n    event VotingStarted(string code, uint votingNumber, address indexed initiator);\\n    event VotingResult(string code, uint votingNumber, bool passed);\\n\\n    bool public votingActive;\\n    SecurityDTOs.VotingInfo public votingInfo;\\n    uint private votingNumber;\\n    mapping(uint => mapping(address => bool)) public voted;\\n\\n\\n    function startVoting(string memory votingCode) internal returns (uint) {\\n        require(!votingActive, \\\"Voting: there is active voting already\\\");\\n        require(totalOwners >= 3, \\\"Voting: not enough owners for starting new vote\\\");\\n        votingInfo = SecurityDTOs.VotingInfo(\\n            _msgSender(),\\n            0,\\n            0,\\n            block.timestamp,\\n            votingCode\\n        );\\n        votingActive = true;\\n        votingNumber++;\\n\\n        votePositive();\\n        emit VotingStarted(\\n            votingCode,\\n            votingNumber,\\n            _msgSender()\\n        );\\n\\n        return votingNumber;\\n    }\\n\\n    // End voting with success\\n    function pass(uint toCheckVotingNumber) internal {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(toCheckVotingNumber == votingNumber, \\\"Voting: old voting found\\\");\\n        require(votingInfo.currentNumberOfVotesPositive > totalOwners / 2, \\\"Voting: not enough positive votes\\\");\\n        require(votingInfo.startedDate + 60 * 60 * 72 < block.timestamp || votingInfo.currentNumberOfVotesPositive == totalOwners, \\\"Voting: 72 hours have not yet passed\\\");\\n\\n        votingActive = false;\\n        emit VotingResult(\\n            votingInfo.votingCode,\\n            votingNumber,\\n            true\\n        );\\n    }\\n\\n\\n    // Close voting\\n    function close() external onlyOwner {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(votingInfo.startedDate + 144 * 60 * 60 < block.timestamp || votingInfo.currentNumberOfVotesNegative > totalOwners / 2, \\\"Voting: condition close error\\\");\\n        votingActive = false;\\n        emit VotingResult(\\n            votingInfo.votingCode,\\n            votingNumber,\\n            false\\n        );\\n    }\\n\\n    function votePositive() public onlyOwner {\\n        vote();\\n        votingInfo.currentNumberOfVotesPositive++;\\n    }\\n\\n    function voteNegative() external onlyOwner {\\n        vote();\\n        votingInfo.currentNumberOfVotesNegative++;\\n    }\\n\\n    function vote() private {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(!voted[votingNumber][_msgSender()], \\\"Voting: already voted\\\");\\n        voted[votingNumber][_msgSender()] = true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/security/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./SecurityDTOs.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    mapping(address => bool) public owners;\\n    mapping(address => bool) public controllers;\\n    address private _company;\\n    uint public totalOwners;\\n    uint public totalControllers;\\n\\n    event AddOwner(address indexed newOwner);\\n    event RemoveOwner(address indexed ownerToRemove);\\n\\n    event AddController(address indexed newController);\\n    event RemoveController(address indexed controllerToRemove);\\n\\n    modifier onlyOwner() {\\n        require(owners[_msgSender()], \\\"Security: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyController() {\\n        require(controllers[_msgSender()], \\\"Security: caller is not the controller\\\");\\n        _;\\n    }\\n\\n    function removeController(address controllerToRemove) internal {\\n        require(controllers[controllerToRemove], \\\"Security.removeController: not controller\\\");\\n\\n        controllers[controllerToRemove] = false;\\n        totalControllers--;\\n        emit RemoveController(controllerToRemove);\\n    }\\n\\n    function addController(address newController) internal {\\n        require(newController != address(0), \\\"Security.addController: new controller is the zero address\\\");\\n        require(!controllers[newController], \\\"Security.addController: already controller\\\");\\n\\n        controllers[newController] = true;\\n        totalControllers++;\\n        emit AddController(newController);\\n    }\\n\\n    function removeOwner(address ownerToRemove) internal {\\n        require(owners[ownerToRemove], \\\"Security.removeOwner: not owner\\\");\\n\\n        owners[ownerToRemove] = false;\\n        totalOwners--;\\n        emit RemoveOwner(ownerToRemove);\\n    }\\n\\n    function addOwner(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Security.addOwner: new owner is the zero address\\\");\\n        require(!owners[newOwner], \\\"Security.addOwner: already owner\\\");\\n\\n        owners[newOwner] = true;\\n        totalOwners++;\\n        emit AddOwner(newOwner);\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/security/SecurityDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nlibrary SecurityDTOs {\\n    struct AddEvent {\\n        string eventId;\\n        address chainlinkAggregatorProxy;\\n        uint8 resultScale;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct RemoveEvent {\\n        string eventId;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct SetJackpotAdapter {\\n        address jackpotAdapter;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct SetCustomAdapter {\\n        address customAdapter;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct AddOwner {\\n        address newOwner;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct RemoveOwner {\\n        address ownerToRemove;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct AddController {\\n        address newController;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct RemoveController {\\n        address controllerToRemove;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct VotingInfo {\\n        address initiator;\\n        uint currentNumberOfVotesPositive;\\n        uint currentNumberOfVotesNegative;\\n        uint startedDate;\\n        string votingCode;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.2;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/utils/strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.2;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = type(uint).max;\\n        if (len > 0) {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice's text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly {retptr := add(ret, 32)}\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly {b := and(mload(ptr), 0xFF)}\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if (b < 0xE0) {\\n                ptr += 2;\\n            } else if (b < 0xF0) {\\n                ptr += 3;\\n            } else if (b < 0xF8) {\\n                ptr += 4;\\n            } else if (b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly {b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)}\\n        if (b < 0x80) {\\n            l = 1;\\n        } else if (b < 0xE0) {\\n            l = 2;\\n        } else if (b < 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l > self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask;\\n                if (needlelen > 0) {\\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n                }\\n\\n                bytes32 needledata;\\n                assembly {needledata := and(mload(needleptr), mask)}\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly {ptrdata := and(mload(ptr), mask)}\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly {ptrdata := and(mload(ptr), mask)}\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly {hash := keccak256(needleptr, needlelen)}\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly {testHash := keccak256(ptr, needlelen)}\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr <= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly {retptr := add(ret, 32)}\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/bets/jackpot/api/JackpotApi.sol\": {\r\n      \"content\": \"pragma solidity 0.8.2;\\n\\nimport './ProxyJackpotDTOs.sol';\\n\\ninterface JackpotApi {\\n    function createJackpotBet(ProxyJackpotDTOs.CreateJackpotRequest calldata createRequest) external returns (uint);\\n\\n    function closeJackpotBet(uint betId, string calldata finalValue) external;\\n\\n    function getJackpotBet(uint betId) external view returns (ProxyJackpotDTOs.JackpotBet memory, uint);\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/bets/jackpot/api/ProxyJackpotDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\n\\nlibrary ProxyJackpotDTOs {\\n    struct CreateJackpotRequest {\\n        string eventId;\\n        uint lockTime;\\n        uint expirationTime;\\n        uint requestAmount;\\n    }\\n\\n\\n    struct JackpotBet {\\n        uint id;\\n        string eventId;\\n        uint requestAmount;\\n        uint lockTime;\\n        uint expirationTime;\\n        uint startBank;\\n\\n        uint finalBank;\\n        string finalJackpotValue;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy-p2p/event/EventController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport '../security/Security.sol';\\nimport './EventDTOs.sol';\\n\\ncontract EventController is Security {\\n    SecurityDTOs.AddEvent public addEvent;\\n    SecurityDTOs.RemoveEvent public removeEvent;\\n\\n    mapping(string => EventDTOs.Event) public eventMapping;\\n\\n    event AddEventMapping(string eventId, address chainlinkAggregatorProxy, uint8 resultScale);\\n    event RemoveMapping(string eventId);\\n\\n    function startAddEvent(string calldata eventId, address chainlinkAggregatorProxy, uint8 resultScale) external onlyOwner() {\\n        require(eventMapping[eventId].alive == false, \\\"RemoveEvent: already alive\\\");\\n\\n        uint votingCode = startVoting(\\\"ADD_EVENT\\\");\\n        addEvent = SecurityDTOs.AddEvent(\\n            eventId,\\n            chainlinkAggregatorProxy,\\n            resultScale,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireAddEvent() external onlyOwner {\\n        pass(addEvent.votingCode);\\n        eventMapping[addEvent.eventId] = EventDTOs.Event(addEvent.eventId, addEvent.chainlinkAggregatorProxy, addEvent.resultScale, true);\\n        emit AddEventMapping(addEvent.eventId, addEvent.chainlinkAggregatorProxy, addEvent.resultScale);\\n    }\\n\\n    function startRemoveEvent(string calldata eventId) external onlyOwner() {\\n        require(eventMapping[eventId].alive == true, \\\"RemoveEvent: not alive\\\");\\n\\n        uint votingCode = startVoting(\\\"REMOVE_EVENT\\\");\\n        removeEvent = SecurityDTOs.RemoveEvent(\\n            eventId,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireRemoveEvent() external onlyOwner {\\n        pass(removeEvent.votingCode);\\n        eventMapping[removeEvent.eventId].alive = false;\\n        emit RemoveMapping(removeEvent.eventId);\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxy-p2p/event/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\ninterface AggregatorInterface {\\n    function decimals() external view returns (uint8);\\n\\n    function getAnswer(uint256 roundId) external view returns (int256);\\n\\n    function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n    function latestRound() external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"AddController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"chainlinkAggregatorProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"resultScale\",\"type\":\"uint8\"}],\"name\":\"AddEventMapping\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"customBetAdapter\",\"type\":\"address\"}],\"name\":\"CustomAdapterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"jackpotBetAdapter\",\"type\":\"address\"}],\"name\":\"JackpotAdapterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"targetSideWon\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oracleRoundId\",\"type\":\"uint256\"}],\"name\":\"ProxyCustomResultChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oracleRoundId\",\"type\":\"uint256\"}],\"name\":\"ProxyJackpotResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controllerToRemove\",\"type\":\"address\"}],\"name\":\"RemoveController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"}],\"name\":\"RemoveMapping\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"}],\"name\":\"RemoveOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"}],\"name\":\"VotingResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"VotingStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acquireAddController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireAddEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireOwnerToRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireRemoveController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireRemoveEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireSetCustomAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireSetJackpotAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addControllerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addEvent\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"chainlinkAggregatorProxy\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"resultScale\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addOwnerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"targetSideWon\",\"type\":\"bool\"}],\"name\":\"closeCustomBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"closeJackpotBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"controllerAddStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controllerToRemove\",\"type\":\"address\"}],\"name\":\"controllerToRemoveStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ProxyJackpotDTOs.CreateJackpotRequest\",\"name\":\"createRequest\",\"type\":\"tuple\"}],\"name\":\"createJackpotBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customBetAdapter\",\"outputs\":[{\"internalType\":\"contract CustomApi\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"eventMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"chainlinkAggregatorProxy\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"resultScale\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"alive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getJackpotBet\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalBank\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"finalJackpotValue\",\"type\":\"string\"}],\"internalType\":\"struct ProxyJackpotDTOs.JackpotBet\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"}],\"name\":\"getResult\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBetAdapter\",\"outputs\":[{\"internalType\":\"contract JackpotApi\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerAddStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"}],\"name\":\"ownerToRemoveStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeControllerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"controllerToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeEvent\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeOwnerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setCustomAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"customAdapter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setJackpotAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"jackpotAdapter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"chainlinkAggregatorProxy\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"resultScale\",\"type\":\"uint8\"}],\"name\":\"startAddEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"}],\"name\":\"startRemoveEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"customBetAddress\",\"type\":\"address\"}],\"name\":\"startSetCustomAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"jackpotBetAddress\",\"type\":\"address\"}],\"name\":\"startSetJackpotAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalControllers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteNegative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votePositive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNumberOfVotesPositive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentNumberOfVotesNegative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedDate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"votingCode\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ProxyP2P", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dead534fbe89db1c7be8c5fb843c0c6e2f1c4999000000000000000000000000deada2d08f6cfef0c4a89ef919194cfbc0c2a922000000000000000000000000dead072f03d78bcc9cf693f25190ee5914776d97", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}