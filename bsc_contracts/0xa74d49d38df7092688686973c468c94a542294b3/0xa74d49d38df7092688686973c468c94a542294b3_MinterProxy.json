{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IERC20Permit {\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                0,\r\n                \"Address: low-level call failed\"\r\n            );\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal view returns (bytes memory) {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                oldAllowance + value\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(\r\n                oldAllowance >= value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    oldAllowance - value\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function forceApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(\r\n            token.approve.selector,\r\n            spender,\r\n            value\r\n        );\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(token.approve.selector, spender, 0)\r\n            );\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(\r\n            nonceAfter == nonceBefore + 1,\r\n            \"SafeERC20: permit did not succeed\"\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        require(\r\n            returndata.length == 0 || abi.decode(returndata, (bool)),\r\n            \"SafeERC20: ERC20 operation did not succeed\"\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturnBool(\r\n        IERC20 token,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success &&\r\n            (returndata.length == 0 || abi.decode(returndata, (bool))) &&\r\n            Address.isContract(address(token));\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Controller is Ownable {\r\n    event ControllerAdded(address controller);\r\n    event ControllerRemoved(address controller);\r\n    mapping(address => bool) controllers;\r\n    uint8 public controllerCnt = 0;\r\n\r\n    modifier onlyController() {\r\n        require(isController(_msgSender()), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function isController(address _controller) public view returns (bool) {\r\n        return _controller == owner() || controllers[_controller];\r\n    }\r\n\r\n    function addController(address _controller) public onlyOwner {\r\n        if (controllers[_controller] == false) {\r\n            controllers[_controller] = true;\r\n            controllerCnt++;\r\n        }\r\n        emit ControllerAdded(_controller);\r\n    }\r\n\r\n    function removeController(address _controller) public onlyOwner {\r\n        if (controllers[_controller] == true) {\r\n            controllers[_controller] = false;\r\n            controllerCnt--;\r\n        }\r\n        emit ControllerRemoved(_controller);\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransferNative(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: NATIVE_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\ncontract MinterProxy is Controller {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    address public immutable NATIVE;\r\n\r\n    uint256 MAX_UINT256 =\r\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    mapping(uint256 => bool) public completedOrder;\r\n\r\n    address public liquidpool;\r\n\r\n    event LogVaultIn(\r\n        address indexed token,\r\n        uint256 indexed orderID,\r\n        address indexed receiver,\r\n        uint256 amount\r\n    );\r\n    event LogVaultOut(\r\n        address indexed token,\r\n        address indexed from,\r\n        uint256 fromChainID,\r\n        uint256 amount,\r\n        string toChain,\r\n        string toAddr\r\n    );\r\n\r\n    event LogVaultCall(\r\n        address indexed target,\r\n        uint256 amount,\r\n        bool success,\r\n        bytes reason\r\n    );\r\n\r\n    constructor(address _NATIVE, address _liquidpool) {\r\n        require(_NATIVE != address(0), \"MP: NATIVE is empty\");\r\n        require(_liquidpool != address(0), \"MP: Liquidpool is empty\");\r\n        NATIVE = _NATIVE;\r\n        liquidpool = _liquidpool;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    function chainID() public view returns (uint) {\r\n        return block.chainid;\r\n    }\r\n\r\n    function setLiquidpool(address _liquidpool) external onlyOwner {\r\n        require(_liquidpool != address(0), \"MP: Liquidpool is empty\");\r\n        liquidpool = _liquidpool;\r\n    }\r\n\r\n    function isUUIDCompleted(uint256 uuid) external view returns (bool) {\r\n        return completedOrder[uuid];\r\n    }\r\n\r\n    function _registerOrder(uint256 uuid) internal {\r\n        require(!completedOrder[uuid], \"MP: already completed\");\r\n        completedOrder[uuid] = true;\r\n    }\r\n\r\n    function _balanceOf(address receiveToken) internal view returns (uint256) {\r\n        uint256 _balance;\r\n        if (receiveToken == NATIVE) {\r\n            _balance = address(this).balance;\r\n        } else {\r\n            _balance = IERC20(receiveToken).balanceOf(address(liquidpool));\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    function _balanceOfSelf(\r\n        address receiveToken\r\n    ) internal view returns (uint256) {\r\n        uint256 _balance;\r\n        if (receiveToken == NATIVE) {\r\n            _balance = address(this).balance;\r\n        } else {\r\n            _balance = IERC20(receiveToken).balanceOf(address(this));\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    function vaultIn(\r\n        uint256 orderID,\r\n        address tokenAddr,\r\n        address toAddr,\r\n        uint256 amount\r\n    ) external onlyController {\r\n        _registerOrder(orderID);\r\n        require(_balanceOf(tokenAddr) >= amount, \"MP: insufficient balance\");\r\n        if (tokenAddr == NATIVE) {\r\n            TransferHelper.safeTransferNative(toAddr, amount);\r\n        } else {\r\n            IERC20(tokenAddr).safeTransferFrom(liquidpool, toAddr, amount);\r\n        }\r\n        emit LogVaultIn(tokenAddr, orderID, toAddr, amount);\r\n    }\r\n\r\n    function vaultInAndCall(\r\n        uint256 orderID,\r\n        address tokenAddr,\r\n        address toAddr,\r\n        uint256 amount,\r\n        bool isNative,\r\n        address receiver,\r\n        address receiveToken,\r\n        bytes calldata data\r\n    ) external onlyController {\r\n        require(_balanceOf(tokenAddr) >= amount, \"MP: insufficient balance\");\r\n        require(\r\n            (receiveToken == NATIVE) == isNative,\r\n            \"MP: insufficient balance\"\r\n        );\r\n        require(data.length > 0, \"MP: data empty\");\r\n        _registerOrder(orderID);\r\n        bool fromTokenNative = tokenAddr == NATIVE;\r\n        if (!fromTokenNative) {\r\n            IERC20(tokenAddr).safeTransferFrom(\r\n                liquidpool,\r\n                address(this),\r\n                amount\r\n            );\r\n            if (IERC20(tokenAddr).allowance(address(this), toAddr) < amount) {\r\n                IERC20(tokenAddr).approve(toAddr, MAX_UINT256);\r\n            }\r\n        }\r\n\r\n        uint256 amountOut = _callAndTransfer(\r\n            toAddr,\r\n            fromTokenNative ? amount : 0,\r\n            isNative,\r\n            receiver,\r\n            receiveToken,\r\n            data\r\n        );\r\n\r\n        emit LogVaultIn(receiveToken, orderID, receiver, amountOut);\r\n    }\r\n\r\n    function call(\r\n        address _target,\r\n        bytes calldata _data\r\n    ) external payable onlyController {\r\n        (bool success, bytes memory result) = _target.call{value: msg.value}(\r\n            _data\r\n        );\r\n        emit LogVaultCall(_target, msg.value, success, result);\r\n    }\r\n\r\n    function _callAndTransfer(\r\n        address contractAddr,\r\n        uint256 fromNativeAmount,\r\n        bool isNative,\r\n        address receiver,\r\n        address receiveToken,\r\n        bytes calldata data\r\n    ) internal returns (uint256) {\r\n        uint256 old_balance = _balanceOfSelf(receiveToken);\r\n\r\n        if (fromNativeAmount > 0) {\r\n            // address payable to = payable(contractAddr);\r\n            contractAddr.functionCallWithValue(\r\n                data,\r\n                fromNativeAmount,\r\n                \"MP: callAndTransfer failed\"\r\n            );\r\n        } else {\r\n            contractAddr.functionCall(data, \"MP: callAndTransfer failed\");\r\n        }\r\n\r\n        uint256 new_balance = _balanceOfSelf(receiveToken);\r\n        require(new_balance > old_balance, \"MP: receiver should get assets\");\r\n        uint256 amountOut = new_balance - old_balance;\r\n\r\n        if (receiver != address(this)) {\r\n            if (isNative) {\r\n                TransferHelper.safeTransferNative(receiver, amountOut);\r\n            } else {\r\n                IERC20(receiveToken).safeTransfer(receiver, amountOut);\r\n            }\r\n        }\r\n        return amountOut;\r\n    }\r\n\r\n    function withdrawFee(\r\n        address token,\r\n        uint256 amount\r\n    ) external onlyController {\r\n        if (token == NATIVE) {\r\n            uint256 balance = address(this).balance;\r\n            uint256 tmp = balance > amount ? amount : balance;\r\n            TransferHelper.safeTransferNative(owner(), tmp);\r\n        } else {\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\r\n            uint256 tmp = balance > amount ? amount : balance;\r\n            IERC20(token).safeTransfer(owner(), tmp);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NATIVE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidpool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"ControllerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"ControllerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"LogVaultCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogVaultIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"toChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"toAddr\",\"type\":\"string\"}],\"name\":\"LogVaultOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"completedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controllerCnt\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uuid\",\"type\":\"uint256\"}],\"name\":\"isUUIDCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidpool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"removeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidpool\",\"type\":\"address\"}],\"name\":\"setLiquidpool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"vaultInAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MinterProxy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000456325f2ac7067234dd71e01bebe032b0255e039", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b9106d96c88bbc36f00594aee681db139522d7a0f5bf12ad405c9bead525d7d4"}