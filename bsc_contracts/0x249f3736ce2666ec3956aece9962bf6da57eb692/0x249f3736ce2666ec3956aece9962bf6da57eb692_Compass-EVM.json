{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title Compass-EVM\r\n@author Volume.Finance\r\n\"\"\"\r\n\r\nMAX_VALIDATORS: constant(uint256) = 320\r\nMAX_PAYLOAD: constant(uint256) = 20480\r\nMAX_BATCH: constant(uint256) = 64\r\n\r\nPOWER_THRESHOLD: constant(uint256) = 2_863_311_530 # 2/3 of 2^32, Validator powers will be normalized to sum to 2 ^ 32 in every valset update.\r\nCOMPASS_ID: immutable(bytes32)\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\nstruct Valset:\r\n    validators: DynArray[address, MAX_VALIDATORS] # Validator addresses\r\n    powers: DynArray[uint256, MAX_VALIDATORS] # Powers of given validators, in the same order as validators array\r\n    valset_id: uint256 # nonce of this validator set\r\n\r\nstruct Signature:\r\n    v: uint256\r\n    r: uint256\r\n    s: uint256\r\n\r\nstruct Consensus:\r\n    valset: Valset # Valset data\r\n    signatures: DynArray[Signature, MAX_VALIDATORS] # signatures in the same order as validator array in valset\r\n\r\nstruct LogicCallArgs:\r\n    logic_contract_address: address # the arbitrary contract address to external call\r\n    payload: Bytes[MAX_PAYLOAD] # payloads\r\n\r\nstruct TokenSendArgs:\r\n    receiver: DynArray[address, MAX_BATCH]\r\n    amount: DynArray[uint256, MAX_BATCH]\r\n\r\nevent ValsetUpdated:\r\n    checkpoint: bytes32\r\n    valset_id: uint256\r\n\r\nevent LogicCallEvent:\r\n    logic_contract_address: address\r\n    payload: Bytes[MAX_PAYLOAD]\r\n    message_id: uint256\r\n\r\nevent SendToPalomaEvent:\r\n    token: address\r\n    sender: address\r\n    receiver: String[64]\r\n    amount: uint256\r\n\r\nevent BatchSendEvent:\r\n    token: address\r\n    message_id: uint256\r\n\r\nevent ERC20DeployedEvent:\r\n    paloma_denom: String[64]\r\n    token_contract: address\r\n    name: String[64]\r\n    symbol: String[32]\r\n    decimals: uint8\r\n\r\nlast_checkpoint: public(bytes32)\r\nlast_valset_id: public(uint256)\r\nmessage_id_used: public(HashMap[uint256, bool])\r\n\r\n# compass_id: unique identifier for compass instance\r\n# valset: initial validator set\r\n@external\r\ndef __init__(compass_id: bytes32, valset: Valset):\r\n    COMPASS_ID = compass_id\r\n    cumulative_power: uint256 = 0\r\n    i: uint256 = 0\r\n    # check cumulative power is enough\r\n    for validator in valset.validators:\r\n        cumulative_power += valset.powers[i]\r\n        if cumulative_power >= POWER_THRESHOLD:\r\n            break\r\n        i += 1\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n    new_checkpoint: bytes32 = keccak256(_abi_encode(valset.validators, valset.powers, valset.valset_id, compass_id, method_id=method_id(\"checkpoint(address[],uint256[],uint256,bytes32)\")))\r\n    self.last_checkpoint = new_checkpoint\r\n    self.last_valset_id = valset.valset_id\r\n    log ValsetUpdated(new_checkpoint, valset.valset_id)\r\n\r\n@external\r\n@pure\r\ndef compass_id() -> bytes32:\r\n    return COMPASS_ID\r\n\r\n# utility function to verify EIP712 signature\r\n@internal\r\n@pure\r\ndef verify_signature(signer: address, hash: bytes32, sig: Signature) -> bool:\r\n    message_digest: bytes32 = keccak256(concat(convert(\"\\x19Ethereum Signed Message:\\n32\", Bytes[28]), hash))\r\n    return signer == ecrecover(message_digest, sig.v, sig.r, sig.s)\r\n\r\n# consensus: validator set and signatures\r\n# hash: what we are checking they have signed\r\n@internal\r\ndef check_validator_signatures(consensus: Consensus, hash: bytes32):\r\n    i: uint256 = 0\r\n    cumulative_power: uint256 = 0\r\n    for sig in consensus.signatures:\r\n        if sig.v != 0:\r\n            assert self.verify_signature(consensus.valset.validators[i], hash, sig), \"Invalid Signature\"\r\n            cumulative_power += consensus.valset.powers[i]\r\n            if cumulative_power >= POWER_THRESHOLD:\r\n                break\r\n        i += 1\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n\r\n# Make a new checkpoint from the supplied validator set\r\n# A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\r\n# instead of storing the information directly. This saves on storage and gas.\r\n# The format of the checkpoint is:\r\n# keccak256 hash of abi_encoded checkpoint(validators[], powers[], valset_id, compass_id)\r\n# The validator powers must be decreasing or equal. This is important for checking the signatures on the\r\n# next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\r\n@internal\r\n@view\r\ndef make_checkpoint(valset: Valset) -> bytes32:\r\n    return keccak256(_abi_encode(valset.validators, valset.powers, valset.valset_id, COMPASS_ID, method_id=method_id(\"checkpoint(address[],uint256[],uint256,bytes32)\")))\r\n\r\n# This updates the valset by checking that the validators in the current valset have signed off on the\r\n# new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\r\n# generated from the new valset.\r\n# Anyone can call this function, but they must supply valid signatures of constant_powerThreshold of the current valset over\r\n# the new valset.\r\n# valset: new validator set to update with\r\n# consensus: current validator set and signatures\r\n@external\r\ndef update_valset(consensus: Consensus, new_valset: Valset):\r\n    # check if new valset_id is greater than current valset_id\r\n    assert new_valset.valset_id > consensus.valset.valset_id, \"Invalid Valset ID\"\r\n    cumulative_power: uint256 = 0\r\n    i: uint256 = 0\r\n    # check cumulative power is enough\r\n    for validator in new_valset.validators:\r\n        cumulative_power += new_valset.powers[i]\r\n        if cumulative_power >= POWER_THRESHOLD:\r\n            break\r\n        i += 1\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # calculate the new checkpoint\r\n    new_checkpoint: bytes32 = self.make_checkpoint(new_valset)\r\n    # check if enough validators signed new validator set (new checkpoint)\r\n    self.check_validator_signatures(consensus, new_checkpoint)\r\n    self.last_checkpoint = new_checkpoint\r\n    self.last_valset_id = new_valset.valset_id\r\n    log ValsetUpdated(new_checkpoint, new_valset.valset_id)\r\n\r\n# This makes calls to contracts that execute arbitrary logic\r\n# message_id is to prevent replay attack and every message_id can be used only once\r\n@external\r\ndef submit_logic_call(consensus: Consensus, args: LogicCallArgs, message_id: uint256, deadline: uint256):\r\n    assert block.timestamp <= deadline, \"Timeout\"\r\n    assert not self.message_id_used[message_id], \"Used Message_ID\"\r\n    self.message_id_used[message_id] = True\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # signing data is keccak256 hash of abi_encoded logic_call(args, message_id, compass_id, deadline)\r\n    args_hash: bytes32 = keccak256(_abi_encode(args, message_id, COMPASS_ID, deadline, method_id=method_id(\"logic_call((address,bytes),uint256,bytes32,uint256)\")))\r\n    # check if enough validators signed args_hash\r\n    self.check_validator_signatures(consensus, args_hash)\r\n    # make call to logic contract\r\n    raw_call(args.logic_contract_address, args.payload)\r\n    log LogicCallEvent(args.logic_contract_address, args.payload, message_id)\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(\r\n            _from, _to, _value,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"TransferFrom failed\"\r\n\r\n@external\r\ndef send_token_to_paloma(token: address, receiver: String[64], amount: uint256):\r\n    _balance: uint256 = ERC20(token).balanceOf(self)\r\n    self._safe_transfer_from(token, msg.sender, self, amount)\r\n    _balance = ERC20(token).balanceOf(self) - _balance\r\n    assert _balance > 0, \"Zero Transfer\"\r\n    log SendToPalomaEvent(token, msg.sender, receiver, amount)\r\n\r\n@internal\r\ndef _safe_transfer(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(\r\n            _to, _value,\r\n            method_id=method_id(\"transfer(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"TransferFrom failed\"\r\n\r\n@external\r\ndef submit_batch(consensus: Consensus, token: address, args: TokenSendArgs, message_id: uint256, deadline: uint256):\r\n    assert block.timestamp <= deadline, \"Timeout\"\r\n    assert not self.message_id_used[message_id], \"Used Message_ID\"\r\n    length: uint256 = len(args.receiver)\r\n    assert length == len(args.amount), \"Unmatched Params\"\r\n    self.message_id_used[message_id] = True\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # signing data is keccak256 hash of abi_encoded logic_call(args, message_id, compass_id, deadline)\r\n    args_hash: bytes32 = keccak256(_abi_encode(token, args, message_id, COMPASS_ID, deadline, method_id=method_id(\"batch_call(address,(address[],uint256[]),uint256,bytes32,uint256)\")))\r\n    # check if enough validators signed args_hash\r\n    self.check_validator_signatures(consensus, args_hash)\r\n    # make call to logic contract\r\n    for i in range(MAX_BATCH):\r\n        if  i >= length:\r\n            break\r\n        self._safe_transfer(token, args.receiver[i], args.amount[i])\r\n    log BatchSendEvent(token, message_id)\r\n\r\n@external\r\ndef deploy_erc20(_paloma_denom: String[64], _name: String[64], _symbol: String[32], _decimals: uint8, _blueprint: address):\r\n    assert msg.sender == self, \"Invalid\"\r\n    erc20: address = create_from_blueprint(_blueprint, self, _name, _symbol, _decimals, code_offset=3)\r\n    log ERC20DeployedEvent(_paloma_denom, erc20, _name, _symbol, _decimals)", "ABI": "[{\"name\":\"ValsetUpdated\",\"inputs\":[{\"name\":\"checkpoint\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"valset_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LogicCallEvent\",\"inputs\":[{\"name\":\"logic_contract_address\",\"type\":\"address\",\"indexed\":false},{\"name\":\"payload\",\"type\":\"bytes\",\"indexed\":false},{\"name\":\"message_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SendToPalomaEvent\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":false},{\"name\":\"receiver\",\"type\":\"string\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BatchSendEvent\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"message_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ERC20DeployedEvent\",\"inputs\":[{\"name\":\"paloma_denom\",\"type\":\"string\",\"indexed\":false},{\"name\":\"token_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"name\",\"type\":\"string\",\"indexed\":false},{\"name\":\"symbol\",\"type\":\"string\",\"indexed\":false},{\"name\":\"decimals\",\"type\":\"uint8\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"compass_id\",\"type\":\"bytes32\"},{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"compass_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_valset\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"new_valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"submit_logic_call\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"args\",\"type\":\"tuple\",\"components\":[{\"name\":\"logic_contract_address\",\"type\":\"address\"},{\"name\":\"payload\",\"type\":\"bytes\"}]},{\"name\":\"message_id\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"send_token_to_paloma\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"submit_batch\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"args\",\"type\":\"tuple\",\"components\":[{\"name\":\"receiver\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"}]},{\"name\":\"message_id\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_erc20\",\"inputs\":[{\"name\":\"_paloma_denom\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_blueprint\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_valset_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"message_id_used\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]", "ContractName": "Compass-EVM", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "31353000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000e3cd54d29cbf35648edcf53d6a344bd4b88da059000000000000000000000000fd023da749b075d0ce861c37228df5a0939a2d1b00000000000000000000000095220a2aa8d839888cde5cc89e7a94675c97e9ec0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}