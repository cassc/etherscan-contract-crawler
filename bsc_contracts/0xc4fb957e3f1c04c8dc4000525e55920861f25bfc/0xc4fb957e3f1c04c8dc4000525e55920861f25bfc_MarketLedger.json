{"SourceCode": "{\"Libraries.sol\":{\"content\":\"  // SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n  interface IBEP20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function name() external view returns (string memory);\\r\\n  function getOwner() external view returns (address);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IPancakeFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ninterface IDexRouter{\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n        function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n}\\r\\nabstract contract Ownable {\\r\\n    address internal _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = msg.sender;\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary EnumerableSet {\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue\\u0027s index to valueIndex\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\"},\"ML.sol\":{\"content\":\"//\\t                                                                                                                                                 \\r\\n//                                                               .....\\u0027\\u0027\\u0027\\u0027,,,,,,,\\u0027\\u0027\\u0027.....                                                               \\r\\n//                                                       ...\\u0027,;:clllooooooooooooooooooollc::;,\\u0027..                                                       \\r\\n//                                                  ..,;:llooooooooooooooooooooooooooooooooooooolc:,\\u0027.                                                  \\r\\n//                                              .\\u0027;cloooooooooollc::;;,,,\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027,,,,;;:clloooooooooolc:,..                                             \\r\\n//                                          .\\u0027;cloooooooolc;,\\u0027...                        ...\\u0027,;:clooooooool:,.                                          \\r\\n//                                       .,:loooooool:;\\u0027..                                      ..\\u0027,:cooooooolc;..                                      \\r\\n//                                    .,:looooool:,..                                                ..,;coooooooc;.                                    \\r\\n//                                  \\u0027:looooooc;\\u0027.                                                        ..,cloooool:\\u0027.                                 \\r\\n//                               .,cooooool;..                                                               .,cooooooc;.                               \\r\\n//                             .,loooool:\\u0027.                                                                     .;loooool;.                             \\r\\n//                           .,loooool;.                                                                          .,coooool;.                           \\r\\n//                          \\u0027coooool,.                                                                              .\\u0027coooool;.                         \\r\\n//                        .:oooool,.    .d000000000000000k;                                       \\u0027:::::::::::::\\u0027     .\\u0027coooooc\\u0027                        \\r\\n//                      .,looool;.      \\u00270MMMMMMMMMMMMMMMMX:                                    .;loooooooooooo;.       .,looool:.                      \\r\\n//                     .:oooooc.        \\u00270MMMMMMMMMMMMMMMMMXl                                  .:ooooooooooool,           .:oooooc\\u0027                     \\r\\n//                    \\u0027cooool;.         \\u00270MMMMMMMMMMMMMMMMMMNo.                               .:ooooooooooool\\u0027              ,looool,                    \\r\\n//                   ,looool\\u0027           \\u00270MMMMMMMMMMMMMMMMMMMWd.                             .cooooooooooool\\u0027                .cooooo;.                  \\r\\n//                  ,looooc.            \\u00270MMMMMMMMMMMMMMMMMMMMWx.                           .cooooooooooooc.                  .:ooooo:.                 \\r\\n//                 ;ooooo:.             \\u00270MMMMMMMMMMMMMMMMMMMMMWk\\u0027                         \\u0027loooooooooooo:.     ..             .;ooooo:.                \\r\\n//                ,loooo:.              \\u00270MMMMMMMMMMMMMMMMMMMMMMWO,                       ,loooooooooooo:.     ;O:               ;ooooo:.               \\r\\n//               \\u0027loooo:.               \\u00270MMMMMMMMMMMMMMMMMMMMMMMM0;                    .;loooooooooool;.     :KN:                ;ooooo;               \\r\\n//              .cooooc.                \\u00270MMMMMMMMMMMMMMMMMMMMMMMMMK:                  .:ooooooooooool,     .lNMN:                .:ooool\\u0027              \\r\\n//             .:ooool\\u0027                 \\u00270MMMMMMMMMMMMMMMMMMMMMMMMMMXc                .:ooooooooooool,     .dNMMX:                 .cooooc.             \\r\\n//             \\u0027loooo;                  \\u00270MMMMMMMMMMMMMMMMMMMMMMMMMMMXl.             .cooooooooooool\\u0027     .xWMMMN:                  \\u0027loooo;             \\r\\n//            .cooooc.                  \\u00270MMMMMMMMMMMMWXNMMMMMMMMMMMMMNo.           \\u0027cooooooooooooc.     \\u0027OWMMMMN:                  .:ooool.            \\r\\n//            \\u0027loooo,                   \\u00270MMMMMMMMMMMMWd:KMMMMMMMMMMMMMWd.         \\u0027looooooooooooc.     ;0MMMMMMN:                   .loooo;            \\r\\n//           .:ooooc.                   \\u00270MMMMMMMMMMMMWo ,OWMMMMMMMMMMMMWk.       ,loooooooooooo:.     cXMMMMMMMN:                   .:ooooc.           \\r\\n//           .loooo:                    \\u00270MMMMMMMMMMMMWo  .xWMMMMMMMMMMMMWO\\u0027     ;loooooooooooo;.    .lNMMMMMMMMN:                    ,loooo\\u0027           \\r\\n//           \\u0027loooo,                    \\u00270MMMMMMMMMMMMWo   .dNMMMMMMMMMMMMW0,  .:ooooooooooool;     .dNMMMMMMMMMN:                    .loooo;           \\r\\n//           ;ooool.                    \\u00270MMMMMMMMMMMMWo     lXMMMMMMMMMMMMM0oc:ooooooooooool,      :NMMMMMMMMMMN:                    .cooooc.          \\r\\n//           :ooooc.                    \\u00270MMMMMMMMMMMMWo      ;KMMMMMMMMMMMW0xdooooooooooool\\u0027       cWMMMMMMMMMMN:                    .:ooooc.          \\r\\n//          .:ooooc.                    \\u00270MMMMMMMMMMMMWo       ,OWMMMMMMMWXkooooooooooooooc\\u0027        cWMMMMMMMMMMN:                     ;ooool.          \\r\\n//          .:ooooc.                    \\u00270MMMMMMMMMMMMWo        .xWMMMMMWKxooooooooooooooc.         cWMMMMMMMMMMN:                     ;ooool.          \\r\\n//          .:ooooc.                    \\u00270MMMMMMMMMMMMWo         .dNMMMNOdoooooooooooooo:.          cWMMMMMMMMMMN:                     ;ooooc.          \\r\\n//           ;ooool.                    \\u00270MMMMMMMMMMMMWo          .lXWKxooooooooooooooo:.           cWMMMMMMMMMMN:                    .:ooooc.          \\r\\n//           ,ooool\\u0027                    \\u00270MMMMMMMMMMMMWo            :xdooooooooooooooo;.            cWMMMMMMMMMMN:                    .coooo:.          \\r\\n//           \\u0027loooo,                    \\u00270MMMMMMMMMMMMWo            ,looooooooooooool,              cWMMMMMMMMMMN:                    .loooo,           \\r\\n//           .coooo:.                   \\u00270MMMMMMMMMMMMWo          .;oooooooooooooool,               cWMMMMMMMMMMN:                    ;ooool.           \\r\\n//            ;ooool\\u0027                   \\u00270MMMMMMMMMMMMWo         .:looooooooooooooc\\u0027                cWMMMMMMMMMMN:                   .coooo:.           \\r\\n//            .loooo:.                  \\u00270MMMMMMMMMMMMWo        .:oooooooooooooooc.                 cWMMMMMMMMMMN:                   ,ooooo,            \\r\\n//             ;ooool\\u0027                  \\u00270MMMMMMMMMMMMWo       .coooooooooooooooc.                  cWMMMMMMMMMMN:                  .cooooc.            \\r\\n//             .cooooc.                 \\u00270WWWWWWWWWWWWWl      .cooooooooooooooo:.                   cNWWWWWWWWWWX:                  ;ooool\\u0027             \\r\\n//              ,loooo;                  \\u0027;;;;;;;;;;;;;.     \\u0027loooooooooooooll;.                    .,;;;;;;;;;;,.                 ,loooo:.             \\r\\n//              .:ooool,                                    ,loooooooooooool,.                                                    .looooc.              \\r\\n//               .:ooool\\u0027                                  ,loooooooooooool,                                                     .cooool.               \\r\\n//                .cooool\\u0027                               .;looooooooooooool:;,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,;;;,.              .cooool\\u0027                \\r\\n//                 .cooool,                             .:ooooooooooooooooooooooooooooooooooooooooooooooooooooool.             .cooool\\u0027                 \\r\\n//                  .cooool;.                          .:oooooooooooooooooooooooooooooooooooooooooooooooooooooool.            \\u0027looool\\u0027                  \\r\\n//                   .:ooooo:.                        .cooooooooooooooooooooooooooooooooooooooooooooooooooooooool.          .;looooc.                   \\r\\n//                    .;looool,                      .coooooooooooooooooooooooooooooooooooooooooooooooooooooooool.         .cooooo:.                    \\r\\n//                      \\u0027cooool:.                   \\u0027looooooooooooooooooooooooooooooooooooooooooooooooooooooooool.       .;looool;.                     \\r\\n//                       .:oooool;.                \\u0027loooooooooooooooooooooooooooooooooooooooooooooooooooooooooool.      \\u0027coooooc.                       \\r\\n//                         \\u0027coooooc,.              ..............................................................     \\u0027coooool,.                        \\r\\n//                          .,loooooc,.                                                                            .\\u0027coooool;.                          \\r\\n//                            .;loooool;.                                                                        .,coooool:.                            \\r\\n//                              .,cooooolc,.                                                                  .\\u0027:loooool;.                              \\r\\n//                                .\\u0027cloooool:\\u0027.                                                            .\\u0027;looooooc,.                                \\r\\n//                                   .;cooooool:,..                                                     .,:looooool:\\u0027.                                  \\r\\n//                                     .\\u0027:loooooool:,..                                            ..\\u0027;clooooool:,.                                     \\r\\n//                                        .\\u0027;clooooooolc;,...                                 ..\\u0027;:looooooool:\\u0027.                                        \\r\\n//                                            .,:cloooooooollc:;,\\u0027......          ......\\u0027,,;:cloooooooool:,..                                           \\r\\n//                                               ..\\u0027;:looooooooooooolllccccc:::cccclllooooooooooooolc;,..                                               \\r\\n//                                                    ..\\u0027,;clloooooooooooooooooooooooooooooollc:;\\u0027..                                                    \\r\\n//                                                          ...\\u0027\\u0027,;;::cccllllllllccc::;;,,\\u0027...                                                          \\r\\n//            \\r\\n//\\r\\n//                                                            \\r\\n// https://t.me/MarketLedgerOfficial\\r\\n// https://marketledger.co.uk\\r\\n//\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\nimport \\\"./Libraries.sol\\\";\\r\\n\\r\\n\\r\\n\\r\\n////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n//ML Contract /////////////////////////////////////////////////////////////////////////////////\\r\\n////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\ncontract MarketLedger is IBEP20, Ownable\\r\\n{\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    \\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n    mapping (address=\\u003euint) customTransferTaxes;\\r\\n\\r\\n    mapping(address=\\u003ebool) private _excluded;\\r\\n    mapping(address=\\u003ebool) private _excludedFromStaking;\\r\\n\\r\\n    mapping(address=\\u003ebool) private _automatedMarketMakers;\\r\\n    \\r\\n    //Token Info\\r\\n    string private constant _name = \\u0027MarketLedger\\u0027;\\r\\n    string private constant _symbol = \\u0027ML\\u0027;\\r\\n    uint8 private constant _decimals = 18;\\r\\n    uint256 public constant InitialSupply= 5 * 10**6 * 10**_decimals;//equals 5,000,000 token\\r\\n\\r\\n    //The time Liquidity gets locked at start and prolonged once it gets released\\r\\n    uint256 private constant DefaultLiquidityLockTime=7 days;\\r\\n\\r\\n    //variables that track balanceLimit and sellLimit,\\r\\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\\r\\n    uint256 private _circulatingSupply;\\r\\n\\r\\n    //Limits max tax, only gets applied for tax changes, doesn\\u0027t affect inital Tax\\r\\n    uint public constant MaxTax=250;\\r\\n    //Tracks the current Taxes, different Taxes can be applied for buy/sell/transfer\\r\\n    //Taxes can never exceed MaxTax\\r\\n    uint private _buyTax=15;\\r\\n    uint private _sellTax=300;\\r\\n    uint private _transferTax=0;\\r\\n    //The shares of the specific Taxes, always needs to equal 100%\\r\\n    uint private _liquidityTax=200;\\r\\n    uint private _stakingTax=400;\\r\\n    uint private _burnTax=200;\\r\\n    uint private _marketingTax=200;\\r\\n    uint private constant TaxDenominator=1000;\\r\\n    //determines the permille of the pancake pair needed to trigger Liquify\\r\\n    uint8 public LiquifyTreshold=2;\\r\\n    \\r\\n    //_pancakePairAddress is also equal to the liquidity token address\\r\\n    //LP token are locked in the contract\\r\\n    address private _pancakePairAddress; \\r\\n    IDexRouter private  _pancakeRouter; \\r\\n    //TestNet\\r\\n    //address private constant PancakeRouter=0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\\r\\n    //MainNet\\r\\n    address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    address public MarketingWallet;\\r\\n    //modifier for functions only the team can call\\r\\n    modifier onlyTeam() {\\r\\n        require(_isTeam(msg.sender), \\\"Caller not in Team\\\");\\r\\n        _;\\r\\n    }\\r\\n    bool _isInFunction;\\r\\n    modifier isInFunction(){\\r\\n        require(!_isInFunction);\\r\\n        _isInFunction=true;\\r\\n        _;\\r\\n        _isInFunction=false;\\r\\n\\r\\n    }\\r\\n\\r\\n    function _isTeam(address addr) private view returns (bool){\\r\\n        return addr==owner()||addr==MarketingWallet;\\r\\n    }\\r\\n\\r\\n    constructor () {\\r\\n        //Creates a Pancake Pair\\r\\n        _pancakeRouter = IDexRouter(PancakeRouter);\\r\\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\r\\n        _automatedMarketMakers[_pancakePairAddress]=true;\\r\\n        //excludes Pancake Pair and contract from staking\\r\\n        _excludedFromStaking[_pancakePairAddress]=true;\\r\\n        _excludedFromStaking[address(this)]=true;\\r\\n        //deployer gets 100% of the supply to create LP\\r\\n        _addToken(msg.sender,InitialSupply);\\r\\n        emit Transfer(address(0), msg.sender, InitialSupply);\\r\\n        //Team wallet deployer and contract are excluded from Taxes\\r\\n        //contract can\\u0027t be included to taxes\\r\\n        MarketingWallet=msg.sender;\\r\\n\\r\\n        _excluded[MarketingWallet]=true;\\r\\n        _excluded[msg.sender]=true;\\r\\n        _excluded[address(this)]=true;\\r\\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);\\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //picks the transfer function\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private{\\r\\n        require(sender != address(0), \\\"from zero\\\");\\r\\n        require(recipient != address(0), \\\"to zero\\\");\\r\\n\\r\\n        //excluded adresses are transfering tax and lock free\\r\\n        if(_excluded[sender] || _excluded[recipient]){\\r\\n            _feelessTransfer(sender, recipient, amount);\\r\\n            return;\\r\\n        }\\r\\n        //once trading is enabled, it can\\u0027t be turned off again\\r\\n        require(tradingEnabled,\\\"trading not yet enabled\\\"); \\r\\n        _regularTransfer(sender,recipient,amount);\\r\\n        //AutoPayout\\r\\n\\r\\n    }\\r\\n    //applies taxes, checks for limits, locks generates autoLP and stakingBNB, and autostakes\\r\\n    function _regularTransfer(address sender, address recipient, uint256 amount) private{\\r\\n        require(_balances[sender] \\u003e= amount, \\\"exceeds balance\\\");\\r\\n        //checks all registered AMM if it\\u0027s a buy or sell.\\r\\n        bool isBuy=_automatedMarketMakers[sender];\\r\\n        bool isSell=_automatedMarketMakers[recipient];\\r\\n        uint tax;\\r\\n        if(isSell)tax=_sellTax;\\r\\n        else if(isBuy)tax=_buyTax;\\r\\n        else {\\r\\n            tax=customTransferTaxes[recipient]\\u003ecustomTransferTaxes[sender]\\r\\n                ?customTransferTaxes[recipient]:customTransferTaxes[sender];\\r\\n            tax=tax==0?_transferTax:tax;\\r\\n        }     \\r\\n        \\r\\n        //Swapping AutoLP and MarketingBNB is only possible if sender is not pancake pair, \\r\\n        //if its not manually disabled, if its not already swapping\\r\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!swapAndLiquifyDisabled)\\u0026\\u0026(!_isSwappingContractModifier))\\r\\n            _swapContractToken(LiquifyTreshold,false);\\r\\n            \\r\\n        _transferTaxed(sender,recipient,amount,tax);\\r\\n    }\\r\\n    function _transferTaxed(address sender, address recipient, uint256 amount, uint tax) private{\\r\\n        uint totalTaxedToken=_calculateFee(amount, tax, TaxDenominator);\\r\\n        uint burnedToken=_calculateFee(amount,tax,_burnTax);\\r\\n        uint256 taxedAmount=amount-totalTaxedToken;\\r\\n        //Removes token and handles staking\\r\\n        _removeToken(sender,amount);\\r\\n        //Adds the taxed tokens -burnedToken to the contract\\r\\n        _addToken(address(this), totalTaxedToken-burnedToken);\\r\\n        //Burns token\\r\\n        _circulatingSupply-=burnedToken;\\r\\n        //Adds token and handles staking\\r\\n        _addToken(recipient, taxedAmount);\\r\\n        emit Transfer(sender,recipient,taxedAmount);\\r\\n        if(!autoPayoutDisabled) _autoPayout();\\r\\n\\r\\n    }\\r\\n    //Feeless transfer only transfers and autostakes\\r\\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\\r\\n        require(_balances[sender] \\u003e= amount, \\\"\\u003ebalance\\\");\\r\\n        //Removes token and handles staking\\r\\n        _removeToken(sender,amount);\\r\\n        //Adds token and handles staking\\r\\n        _addToken(recipient, amount);\\r\\n        \\r\\n        emit Transfer(sender,recipient,amount);\\r\\n\\r\\n    }\\r\\n\\r\\n    //Calculates the token that should be taxed\\r\\n    function _calculateFee(uint256 amount, uint tax, uint taxPercent) private pure returns (uint256) {\\r\\n        return (amount*tax*taxPercent) / (TaxDenominator*TaxDenominator);\\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //BNB Autostake/////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \\r\\n    //Autostake uses the balances of each holder to redistribute auto generated BNB.\\r\\n    //Each transaction _addToken and _removeToken gets called for the transaction amount\\r\\n    EnumerableSet.AddressSet private _autoPayoutList;\\r\\n    function isAutoPayout(address account) public view returns(bool){\\r\\n        return _autoPayoutList.contains(account);\\r\\n    }\\r\\n    uint AutoPayoutCount=15;\\r\\n    uint MinPayout=10**17/2;//0,05 BNB\\r\\n    uint256 currentPayoutIndex;\\r\\n\\r\\n    bool public autoPayoutDisabled;\\r\\n\\r\\n    event OnDisableAutoPayout(bool disabled);\\r\\n    function TeamDisableAutoPayout(bool disabled) public onlyTeam{\\r\\n        autoPayoutDisabled=disabled;\\r\\n        emit  OnDisableAutoPayout(disabled);\\r\\n    }\\r\\n    event OnChangeAutoPayoutCount(uint count); \\r\\n    function TeamChangeAutoPayoutCount(uint count) public onlyTeam{\\r\\n        require(count\\u003c=50);\\r\\n        AutoPayoutCount=count;\\r\\n        emit OnChangeAutoPayoutCount(count);\\r\\n    }\\r\\n    event OnChangeMinPayout(uint treshold); \\r\\n    function TeamChangeMinPayout(uint minPayout) public onlyTeam{\\r\\n        MinPayout=minPayout;\\r\\n        emit OnChangeAutoPayoutCount(minPayout);\\r\\n    }\\r\\n    function TeamSetAutoPayoutAccount(address account, bool enable) public onlyTeam{\\r\\n        if(enable)_autoPayoutList.add(account);\\r\\n        else _autoPayoutList.remove(account);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    function _autoPayout() private{\\r\\n        //resets payout counter and moves to next payout token if last holder is reached\\r\\n        if(currentPayoutIndex\\u003e=_autoPayoutList.length()) currentPayoutIndex=0;\\r\\n        for(uint i=0;i\\u003cAutoPayoutCount;i++){\\r\\n            address current=_autoPayoutList.at(currentPayoutIndex);\\r\\n            currentPayoutIndex++; \\r\\n            if(getDividents(current)\\u003e=MinPayout){\\r\\n                _claimBNB(current);\\r\\n                i+=3;//if payout happens, increase the counter faster  \\r\\n            }\\r\\n            if(currentPayoutIndex\\u003e=_autoPayoutList.length()){\\r\\n                currentPayoutIndex=0;\\r\\n                return;\\r\\n            }\\r\\n\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Multiplier to add some accuracy to profitPerShare\\r\\n    uint256 private constant DistributionMultiplier = 2**64;\\r\\n    //profit for each share a holder holds, a share equals a decimal.\\r\\n    uint256 public profitPerShare;\\r\\n    //totalShares in circulation +InitialSupply to avoid underflow \\r\\n    //getTotalShares returns the correct amount\\r\\n    uint256 private _totalShares=InitialSupply;\\r\\n    //the total reward distributed through staking, for tracking purposes\\r\\n    uint256 public totalStakingReward;\\r\\n    //the total payout through staking, for tracking purposes\\r\\n    uint256 public totalPayouts;\\r\\n    //Mapping of the already paid out(or missed) shares of each staker\\r\\n    mapping(address =\\u003e uint256) private alreadyPaidShares;\\r\\n    //Mapping of shares that are reserved for payout\\r\\n    mapping(address =\\u003e uint256) private toBePaid;\\r\\n    mapping(address =\\u003e uint256) public totalPayout;\\r\\n\\r\\n    //adds Token to balances, adds new BNB to the toBePaid mapping and resets staking\\r\\n    function _addToken(address addr, uint256 amount) private {\\r\\n        //the amount of token after transfer\\r\\n        uint256 newAmount=_balances[addr]+amount;\\r\\n        _circulatingSupply+=amount;\\r\\n        //if excluded, don\\u0027t change staking amount\\r\\n        if(_excludedFromStaking[addr]){\\r\\n           _balances[addr]=newAmount;\\r\\n           return;\\r\\n        }\\r\\n        _totalShares+=amount;\\r\\n        //gets the payout before the change\\r\\n        uint256 payment=_newDividentsOf(addr);\\r\\n        //resets dividents to 0 for newAmount\\r\\n        alreadyPaidShares[addr] = profitPerShare * newAmount;\\r\\n        //adds dividents to the toBePaid mapping\\r\\n        toBePaid[addr]+=payment; \\r\\n        //sets newBalance\\r\\n        _balances[addr]=newAmount;\\r\\n        _autoPayoutList.add(addr);\\r\\n\\r\\n    }\\r\\n    \\r\\n    //removes Token, adds BNB to the toBePaid mapping and resets staking\\r\\n    function _removeToken(address addr, uint256 amount) private {\\r\\n        //the amount of token after transfer\\r\\n        uint256 newAmount=_balances[addr]-amount;\\r\\n        _circulatingSupply-=amount;\\r\\n        if(_excludedFromStaking[addr]){\\r\\n           _balances[addr]=newAmount;\\r\\n           return;\\r\\n        }\\r\\n\\r\\n        //gets the payout before the change\\r\\n        uint256 payment=_newDividentsOf(addr);\\r\\n        //sets newBalance\\r\\n        _balances[addr]=newAmount;\\r\\n        //resets dividents to 0 for newAmount\\r\\n        alreadyPaidShares[addr] = profitPerShare * getShares(addr);\\r\\n        //adds dividents to the toBePaid mapping\\r\\n        toBePaid[addr]+=payment; \\r\\n        _totalShares-=amount;\\r\\n        if(newAmount==0)\\r\\n        _autoPayoutList.remove(addr);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    //gets the dividents of a staker that aren\\u0027t in the toBePaid mapping \\r\\n    function _newDividentsOf(address staker) private view returns (uint256) {\\r\\n        uint256 fullPayout = profitPerShare * getShares(staker);\\r\\n        //if excluded from staking or some error return 0\\r\\n        if(fullPayout\\u003c=alreadyPaidShares[staker]) return 0;\\r\\n        return (fullPayout - alreadyPaidShares[staker]) / DistributionMultiplier;\\r\\n    }\\r\\n    \\r\\n    //distributes bnb between marketing share and dividents \\r\\n    function _distributeStake(uint256 AmountWei) private {\\r\\n        // Deduct marketing Tax\\r\\n        if(AmountWei==0) return;      \\r\\n\\r\\n        uint256 totalShares=getTotalShares();\\r\\n        //when there are 0 shares, add everything to marketing budget\\r\\n        if (totalShares == 0) {\\r\\n            (bool sent,)=MarketingWallet.call{value:AmountWei}(\\\"\\\");\\r\\n            sent=true;\\r\\n        }else{\\r\\n            totalStakingReward += AmountWei;\\r\\n            //Increases profit per share based on current total shares\\r\\n            profitPerShare += ((AmountWei * DistributionMultiplier) / totalShares);\\r\\n        }\\r\\n    }\\r\\n    function AddFunds() public payable isInFunction{\\r\\n        _distributeStake(msg.value);\\r\\n    }\\r\\n    function AddFundsTo(address Account) public payable isInFunction{\\r\\n        toBePaid[Account]+=msg.value;\\r\\n        totalStakingReward += msg.value;\\r\\n    } \\r\\n    //Sets dividents to 0 returns dividents\\r\\n    function _substractDividents(address addr) private returns (uint256){\\r\\n        uint256 amount=getDividents(addr);\\r\\n        if(amount==0) return 0;\\r\\n        if(!_excludedFromStaking[addr]){\\r\\n            alreadyPaidShares[addr] = profitPerShare * getShares(addr);\\r\\n        }\\r\\n        toBePaid[addr]=0;\\r\\n        totalPayout[addr]+=amount;\\r\\n        return amount;\\r\\n    }\\r\\n    //Manually claimRewards\\r\\n    function ClaimRewards() public isInFunction{\\r\\n        _claimBNB(msg.sender);\\r\\n    }\\r\\n    function _claimBNB(address account) private{\\r\\n        uint256 amount=_substractDividents(account);\\r\\n        if(amount==0) return;\\r\\n        //Substracts the amount from the dividents\\r\\n        totalPayouts+=amount;  \\r\\n        (bool sent,)=account.call{value:amount,gas:30000}(\\\"\\\");\\r\\n        if(!sent){\\r\\n            //if payout fails, revert payment\\r\\n            toBePaid[account]+=amount;\\r\\n            totalPayouts-=amount;\\r\\n         }\\r\\n        \\r\\n \\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    \\r\\n    //tracks auto generated BNB, useful for ticker etc\\r\\n    uint256 public totalLPBNB;\\r\\n    //Locks the swap if already swapping\\r\\n    bool private _isSwappingContractModifier;\\r\\n    modifier lockTheSwap {\\r\\n        _isSwappingContractModifier = true;\\r\\n        _;\\r\\n        _isSwappingContractModifier = false;\\r\\n    }\\r\\n    uint public overLiquifyTreshold=100; \\r\\n    function isOverLiquified() public view returns(bool){\\r\\n        return _balances[_pancakePairAddress]\\u003e_circulatingSupply*overLiquifyTreshold/TaxDenominator;\\r\\n    }\\r\\n    function _swapContractToken(uint16 PancakeTreshold,bool ignoreLimits) private lockTheSwap{\\r\\n        uint contractBalance=_balances[address(this)];\\r\\n        uint totalTax=_liquidityTax+_stakingTax+_marketingTax;\\r\\n        if(totalTax==0) return;\\r\\n\\r\\n            \\r\\n        uint256 tokenToSwap=_balances[_pancakePairAddress]*PancakeTreshold/TaxDenominator;\\r\\n        \\r\\n        //only swap if contractBalance is larger than tokenToSwap or ignore limits\\r\\n        bool NotEnoughToken=contractBalance\\u003ctokenToSwap;\\r\\n        if(NotEnoughToken){\\r\\n            if(ignoreLimits)\\r\\n                tokenToSwap=contractBalance;\\r\\n            else return;\\r\\n        }\\r\\n        uint tokenForLiquidity;\\r\\n        //if over Liquified, then use 100% of the token for LP\\r\\n        if(isOverLiquified())tokenForLiquidity=0;\\r\\n        else tokenForLiquidity=(tokenToSwap*_liquidityTax)/totalTax;\\r\\n\\r\\n        uint tokenForBNB=tokenToSwap-tokenForLiquidity;\\r\\n\\r\\n\\r\\n        //splits tokenForLiquidity in 2 halves\\r\\n        uint liqToken=tokenForLiquidity/2;\\r\\n        uint liqBNBToken=tokenForLiquidity-liqToken;\\r\\n\\r\\n        //swaps marktetingToken and the liquidity token half for BNB\\r\\n        uint swapToken=liqBNBToken+tokenForBNB;\\r\\n        //Gets the initial BNB balance, so swap won\\u0027t touch any staked BNB\\r\\n        uint initialBNBBalance = address(this).balance;\\r\\n        _swapTokenForBNB(swapToken);\\r\\n        uint newBNB=(address(this).balance - initialBNBBalance);\\r\\n        //calculates the amount of BNB belonging to the LP-Pair and converts them to LP\\r\\n        uint liqBNB = (newBNB*liqBNBToken)/swapToken;\\r\\n        if(liqBNB\\u003e0) _addLiquidity(liqToken, liqBNB);\\r\\n        //Get the BNB balance after LP generation to get the\\r\\n        //exact amount of token left for Staking, as LP generation leaves some BNB untouched\\r\\n        uint distributeBNB=(address(this).balance - initialBNBBalance);\\r\\n\\r\\n        uint marketingBNB=distributeBNB*_marketingTax/(_marketingTax+_stakingTax);\\r\\n        uint stakingBNB=distributeBNB-marketingBNB;\\r\\n        //distributes BNB between stakers\\r\\n        _distributeStake(stakingBNB);\\r\\n    }\\r\\n    //swaps tokens on the contract for BNB\\r\\n    function _swapTokenForBNB(uint256 amount) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n\\r\\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    //Adds Liquidity directly to the contract where LP are locked(unlike safemoon forks, that transfer it to the owner)\\r\\n    function _addLiquidity(uint256 tokenamount, uint256 bnbamount) private {\\r\\n        totalLPBNB+=bnbamount;\\r\\n        try _pancakeRouter.addLiquidityETH{value: bnbamount}(\\r\\n            address(this),\\r\\n            tokenamount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        ){}\\r\\n        catch{}\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        //gets shares of an address, returns 0 if excluded\\r\\n    function getShares(address addr) public view returns(uint256){\\r\\n        if(_excludedFromStaking[addr]) return 0;\\r\\n        return _balances[addr];\\r\\n    }\\r\\n\\r\\n    //Total shares equals circulating supply minus excluded Balances\\r\\n    function getTotalShares() public view returns (uint256){\\r\\n        return _totalShares-InitialSupply;\\r\\n    }\\r\\n\\r\\n    function getLiquidityLockSeconds() public view returns (uint256 LockedSeconds){\\r\\n        if(block.timestamp\\u003c_liquidityUnlockTime)\\r\\n            return _liquidityUnlockTime-block.timestamp;\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function getTaxes() public view returns(\\r\\n    uint256 buyTax, \\r\\n    uint256 sellTax, \\r\\n    uint256 transferTax, \\r\\n    uint256 liquidityTax,\\r\\n    uint256 stakingTax,\\r\\n    uint256 marketingTax,\\r\\n    uint burnTax){\\r\\n            buyTax=_buyTax;\\r\\n            sellTax=_sellTax;\\r\\n            transferTax=_transferTax;\\r\\n            liquidityTax=_liquidityTax;\\r\\n            stakingTax=_stakingTax;\\r\\n            marketingTax=_marketingTax;\\r\\n            burnTax=_burnTax;\\r\\n\\r\\n\\r\\n    }\\r\\n    \\r\\n    function getStatus(address account) public view returns(\\r\\n        bool Excluded, \\r\\n        bool ExcludedFromStaking\\r\\n        ){\\r\\n        return(\\r\\n            _excluded[account],\\r\\n            _excludedFromStaking[account]\\r\\n            );\\r\\n    }\\r\\n    \\r\\n    //Returns the not paid out dividents of an address in wei\\r\\n    function getDividents(address addr) public view returns (uint256){\\r\\n        return _newDividentsOf(addr)+toBePaid[addr];\\r\\n    }\\r\\n    \\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    bool public swapAndLiquifyDisabled;\\r\\n    event  OnAddAMM(address AMM,bool Add);\\r\\n    function TeamAddOrRemoveAMM(address AMMPairAddress, bool Add) public onlyTeam{\\r\\n        require(AMMPairAddress!=_pancakePairAddress,\\\"can\\u0027t change Pancake\\\");\\r\\n        if(Add){\\r\\n            if(!_excludedFromStaking[AMMPairAddress])\\r\\n                TeamSetStakingExcluded(AMMPairAddress, true);\\r\\n            _automatedMarketMakers[AMMPairAddress]=true;\\r\\n        } \\r\\n        else{\\r\\n            _automatedMarketMakers[AMMPairAddress]=false;\\r\\n        }\\r\\n        emit OnAddAMM(AMMPairAddress, Add);\\r\\n    }\\r\\n\\r\\n    function SetCustomTransferTaxes(uint taxes, address account) public onlyTeam{\\r\\n        require(taxes\\u003cMaxTax);\\r\\n        customTransferTaxes[account]=taxes;\\r\\n    }\\r\\n    function TeamChangeTeamWallet(address newTeamWallet) public{\\r\\n        require(msg.sender==MarketingWallet);\\r\\n        MarketingWallet=newTeamWallet;\\r\\n    }\\r\\n    event  OnChangeLiquifyTreshold(uint8 TresholdPermille);\\r\\n    function TeamSetLiquifyTreshold(uint8 TresholdPermille) public onlyTeam{\\r\\n        require(TresholdPermille\\u003c=50);\\r\\n        require(TresholdPermille\\u003e0);\\r\\n        LiquifyTreshold=TresholdPermille;\\r\\n        emit OnChangeLiquifyTreshold(TresholdPermille);\\r\\n    }\\r\\n\\r\\n    event  OnChangeOverLiquifyTreshold(uint8 TresholdPermille);\\r\\n    function TeamSetOverLiquifyTreshold(uint8 TresholdPermille) public onlyTeam{\\r\\n        \\r\\n        require(TresholdPermille\\u003c=TaxDenominator);\\r\\n        overLiquifyTreshold=TresholdPermille;\\r\\n        emit OnChangeOverLiquifyTreshold(TresholdPermille);\\r\\n    }\\r\\n\\r\\n    \\r\\n    \\r\\n    event  OnSwitchSwapAndLiquify(bool Disabled);\\r\\n    //switches autoLiquidity and marketing BNB generation during transfers\\r\\n    function TeamSwitchSwapAndLiquify(bool disabled) public onlyTeam{\\r\\n        swapAndLiquifyDisabled=disabled;\\r\\n        emit OnSwitchSwapAndLiquify(disabled);\\r\\n    }\\r\\n    event OnChangeTaxes(uint liquidityTaxes, uint stakingTaxes,uint buyTaxes,uint marketingTaxes,uint burn, uint sellTaxes, uint transferTaxes);\\r\\n    //Sets Taxes, is limited by MaxTax(25%) to make it impossible to create honeypot\\r\\n    function TeamSetTaxes(uint liquidityTaxes, uint stakingTaxes,uint marketingTax,uint burnTax, uint buyTax, uint sellTax, uint transferTax) public onlyTeam{\\r\\n        uint totalTax=liquidityTaxes+stakingTaxes+marketingTax+burnTax;\\r\\n        require(totalTax==TaxDenominator);\\r\\n        require(buyTax\\u003c=MaxTax\\u0026\\u0026sellTax\\u003c=MaxTax\\u0026\\u0026transferTax\\u003c=MaxTax);\\r\\n    \\r\\n        _marketingTax=marketingTax;\\r\\n        _burnTax=burnTax;\\r\\n        _liquidityTax=liquidityTaxes;\\r\\n        _stakingTax=stakingTaxes;\\r\\n        \\r\\n        _buyTax=buyTax;\\r\\n        _sellTax=sellTax;\\r\\n        _transferTax=transferTax;\\r\\n        emit OnChangeTaxes(liquidityTaxes, stakingTaxes, marketingTax, burnTax, buyTax, sellTax, transferTax);\\r\\n    }\\r\\n\\r\\n    //manually converts contract token to LP and staking BNB\\r\\n    function TeamTriggerLiquify(uint16 pancakePermille, bool ignoreLimits) public onlyTeam{\\r\\n        _swapContractToken(pancakePermille,ignoreLimits);\\r\\n    }\\r\\n    \\r\\n    event OnExcludeFromStaking(address addr, bool exclude);\\r\\n    //Excludes account from Staking\\r\\n    function TeamSetStakingExcluded(address addr, bool exclude) public onlyTeam{\\r\\n        uint256 shares;\\r\\n        if(exclude){\\r\\n            require(!_excludedFromStaking[addr]);\\r\\n            uint256 newDividents=_newDividentsOf(addr);\\r\\n            shares=getShares(addr);\\r\\n            _excludedFromStaking[addr]=true; \\r\\n            _totalShares-=shares;\\r\\n            alreadyPaidShares[addr]=shares*profitPerShare;\\r\\n            toBePaid[addr]+=newDividents;\\r\\n            _autoPayoutList.remove(addr);\\r\\n\\r\\n        } else _includeToStaking(addr);\\r\\n        emit OnExcludeFromStaking(addr, exclude);\\r\\n    }    \\r\\n\\r\\n    //function to Include own account to staking, should it be excluded\\r\\n    function IncludeMeToStaking() public{\\r\\n        _includeToStaking(msg.sender);\\r\\n    }\\r\\n    function _includeToStaking(address addr) private{\\r\\n        require(_excludedFromStaking[addr]);\\r\\n        _excludedFromStaking[addr]=false;\\r\\n        uint256 shares=getShares(addr);\\r\\n        _totalShares+=shares;\\r\\n        //sets alreadyPaidShares to the current amount\\r\\n        alreadyPaidShares[addr]=shares*profitPerShare;\\r\\n        _autoPayoutList.add(addr);\\r\\n    }\\r\\n    event OnExclude(address addr, bool exclude);\\r\\n    //Exclude/Include account from fees and locks (eg. CEX)\\r\\n    function TeamSetExcludedStatus(address account,bool excluded) public onlyTeam {\\r\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");   \\r\\n        _excluded[account]=excluded;\\r\\n        emit OnExclude(account, excluded);\\r\\n    }\\r\\n    event ContractBurn(uint256 amount);\\r\\n    //Burns token on the contract, like when there is a very large backlog of token\\r\\n    //or for scheudled BurnEvents\\r\\n    function TeamBurnContractToken(uint8 percent) public onlyTeam{\\r\\n        require(percent\\u003c=100);\\r\\n        uint256 burnAmount=_balances[address(this)]*percent/100;\\r\\n        _removeToken(address(this),burnAmount);\\r\\n        emit Transfer(address(this), address(0), burnAmount);\\r\\n        emit ContractBurn(burnAmount);\\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Setup Functions///////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //Creates LP using Payable Amount, LP automatically land on the contract where they get locked\\r\\n    //once Trading gets enabled\\r\\n    bool public tradingEnabled;    \\r\\n    event OnTradingOpen();\\r\\n    //Enables trading. Turns on bot protection and Locks LP for default Lock time\\r\\n    function SetupEnableTrading() public onlyTeam{\\r\\n        require(!tradingEnabled);\\r\\n        tradingEnabled=true;\\r\\n        _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime; \\r\\n        emit OnTradingOpen();\\r\\n    }\\r\\n    \\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Liquidity Lock////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //the timestamp when Liquidity unlocks\\r\\n    uint256 private _liquidityUnlockTime;\\r\\n    bool public liquidityRelease20Percent;\\r\\n    event  LimitReleaseTo20Percent();\\r\\n    //Sets Liquidity Release to 20% at a time and prolongs liquidity Lock for a Week after Release. \\r\\n    //Should be called once start was successful.\\r\\n    function TeamlimitLiquidityReleaseTo20Percent() public onlyTeam{\\r\\n        liquidityRelease20Percent=true;\\r\\n        emit LimitReleaseTo20Percent();\\r\\n    }\\r\\n    \\r\\n    //Prolongs the Liquidity Lock. Lock can\\u0027t be reduced\\r\\n    event ProlongLiquidityLock(uint256 secondsUntilUnlock);\\r\\n    function TeamLockLiquidityForSeconds(uint256 secondsUntilUnlock) public onlyTeam{\\r\\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\\r\\n        emit ProlongLiquidityLock(secondsUntilUnlock);\\r\\n    }\\r\\n    function _prolongLiquidityLock(uint256 newUnlockTime) private{\\r\\n        // require new unlock time to be longer than old one\\r\\n        require(newUnlockTime\\u003e_liquidityUnlockTime);\\r\\n        _liquidityUnlockTime=newUnlockTime;\\r\\n    }\\r\\n    event OnRemoveRemainingBNB();\\r\\n    function TeamRemoveRemainingBNB() public onlyTeam{\\r\\n        require(block.timestamp \\u003e= _liquidityUnlockTime+30 days, \\\"Locked\\\");\\r\\n        _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\\r\\n        (bool sent,)=MarketingWallet.call{value:address(this).balance}(\\\"\\\");\\r\\n        sent=true;\\r\\n        emit OnRemoveRemainingBNB();\\r\\n    }\\r\\n\\r\\n    event OnReleaseLP();\\r\\n    //Release Liquidity Tokens once unlock time is over\\r\\n    function LiquidityRelease() public onlyTeam {\\r\\n        //Only callable if liquidity Unlock time is over\\r\\n        require(block.timestamp \\u003e= _liquidityUnlockTime, \\\"Not yet unlocked\\\");\\r\\n\\r\\n        IBEP20 liquidityToken = IBEP20(_pancakePairAddress);\\r\\n        uint amount = liquidityToken.balanceOf(address(this));\\r\\n        if(liquidityRelease20Percent)\\r\\n        {\\r\\n            _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\\r\\n            //regular liquidity release, only releases 20% at a time and locks liquidity for another week\\r\\n            amount=amount*2/10;\\r\\n        }\\r\\n        liquidityToken.transfer(msg.sender, amount);\\r\\n        emit OnReleaseLP();\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    //Allows the team to withdraw token that get\\u0027s accidentally sent to the contract(happens way too often)\\r\\n    //Can\\u0027t withdraw the LP token, this token or the promotion token\\r\\n    function TeamWithdrawStrandedToken(address strandedToken) public onlyTeam{\\r\\n        require((strandedToken!=_pancakePairAddress)\\u0026\\u0026strandedToken!=address(this));\\r\\n        IBEP20 token=IBEP20(strandedToken);\\r\\n        token.transfer(MarketingWallet,token.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    \\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    receive() external payable {\\r\\n        //only allow pancakeRouter to send BNB\\r\\n        require(msg.sender==address(PancakeRouter));\\r\\n    }\\r\\n    // IBEP20\\r\\n\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _circulatingSupply;\\r\\n    }\\r\\n    function balanceOf(address account) external view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function allowance(address _owner, address spender) external view override returns (uint256) {\\r\\n        return _allowances[_owner][spender];\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require(owner != address(0));\\r\\n        require(spender != address(0));\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\r\\n        require(currentAllowance \\u003e= amount);\\r\\n\\r\\n        _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        return true;\\r\\n    }\\r\\n    // IBEP20 - Helpers\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[msg.sender][spender];\\r\\n        require(currentAllowance \\u003e= subtractedValue);\\r\\n\\r\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContractBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LimitReleaseTo20Percent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"OnAddAMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"OnChangeAutoPayoutCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"TresholdPermille\",\"type\":\"uint8\"}],\"name\":\"OnChangeLiquifyTreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treshold\",\"type\":\"uint256\"}],\"name\":\"OnChangeMinPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"TresholdPermille\",\"type\":\"uint8\"}],\"name\":\"OnChangeOverLiquifyTreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTaxes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingTaxes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTaxes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingTaxes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellTaxes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferTaxes\",\"type\":\"uint256\"}],\"name\":\"OnChangeTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"OnDisableAutoPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"OnExclude\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"OnExcludeFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnReleaseLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnRemoveRemainingBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Disabled\",\"type\":\"bool\"}],\"name\":\"OnSwitchSwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnTradingOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"ProlongLiquidityLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AddFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Account\",\"type\":\"address\"}],\"name\":\"AddFundsTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IncludeMeToStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taxes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SetCustomTransferTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SetupEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMMPairAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"TeamAddOrRemoveAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"name\":\"TeamBurnContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"TeamChangeAutoPayoutCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPayout\",\"type\":\"uint256\"}],\"name\":\"TeamChangeMinPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTeamWallet\",\"type\":\"address\"}],\"name\":\"TeamChangeTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"TeamDisableAutoPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"TeamLockLiquidityForSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TeamRemoveRemainingBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"TeamSetAutoPayoutAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"TeamSetExcludedStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"TresholdPermille\",\"type\":\"uint8\"}],\"name\":\"TeamSetLiquifyTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"TresholdPermille\",\"type\":\"uint8\"}],\"name\":\"TeamSetOverLiquifyTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"TeamSetStakingExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTaxes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTaxes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferTax\",\"type\":\"uint256\"}],\"name\":\"TeamSetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"TeamSwitchSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"pancakePermille\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"TeamTriggerLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strandedToken\",\"type\":\"address\"}],\"name\":\"TeamWithdrawStrandedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TeamlimitLiquidityReleaseTo20Percent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoPayoutDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDividents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityLockSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LockedSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"Excluded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ExcludedFromStaking\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnTax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAutoPayout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityRelease20Percent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overLiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLPBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MarketLedger", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6403b8927d4fca2c4918080a366a72b2e5b5b29c13b4c15b0c814944b4788b69"}