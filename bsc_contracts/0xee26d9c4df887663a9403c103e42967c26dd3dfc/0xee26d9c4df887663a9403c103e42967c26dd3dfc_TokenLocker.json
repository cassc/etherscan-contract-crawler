{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract TokenLocker {\r\n    IBEP20 public token;\r\n    struct Lock {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n        string username; // New field to store username\r\n        uint256 lockTime; // New field to store the time of locking tokens\r\n\r\n    }\r\n    address public owner;\r\n    uint256 public constant LOCK_FEE = 8200000000000000; // 0.0082 ether in Wei\r\n    uint256 public totalLockedTokens; // State variable to store total locked tokens\r\n    enum LockPeriod { Minutes2, Days7, Days14, Days30, Months3, Months6 }\r\n    uint256 constant DAY_IN_SECONDS = 86400;\r\n    uint256 constant MINUTE_IN_SECONDS = 60;\r\n\r\n    mapping(address => Lock[]) public locks;\r\n    mapping(address => bool) public lockStatus; // Mapping to track lock status\r\n    address[] private lockOwners;\r\n\r\n    // Hardcoded token address\r\n    address private constant TOKEN_ADDRESS = 0xA52b848cd514049C91AD77Fd2A2979dd9F5909E0;\r\n\r\n    constructor() {\r\n        token = IBEP20(TOKEN_ADDRESS);\r\n         owner = msg.sender; // Set contract deployer as the owner\r\n\r\n    }\r\n\r\n    // Modifier to restrict function access to the owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Function to withdraw accumulated fees\r\n    function withdrawFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n\r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n\r\n        function lockTokens(uint256 _amount, LockPeriod _lockPeriod, string memory _username) external payable {\r\n        require(msg.value == LOCK_FEE, \"Insufficient fee\");\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        \r\n        uint256 lockDuration;\r\n           if (_lockPeriod == LockPeriod.Minutes2) {\r\n        lockDuration = 2 * MINUTE_IN_SECONDS;\r\n    } else if (_lockPeriod == LockPeriod.Days7) {\r\n        lockDuration = 7 * DAY_IN_SECONDS;\r\n    } else if (_lockPeriod == LockPeriod.Days14) {\r\n        lockDuration = 14 * DAY_IN_SECONDS;\r\n    } else if (_lockPeriod == LockPeriod.Days30) {\r\n        lockDuration = 30 * DAY_IN_SECONDS;\r\n    } else if (_lockPeriod == LockPeriod.Months3) {\r\n        lockDuration = 90 * DAY_IN_SECONDS; \r\n    } else if (_lockPeriod == LockPeriod.Months6) {\r\n        lockDuration = 180 * DAY_IN_SECONDS; \r\n    } else {\r\n        revert(\"Invalid lock period\");\r\n    }\r\n\r\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\r\n        // Update total locked tokens\r\n        totalLockedTokens += _amount;\r\n\r\n        uint256 unlockTime = block.timestamp + lockDuration;\r\n    locks[msg.sender].push(Lock(_amount, unlockTime, _username, block.timestamp)); // Set lockTime to current timestamp\r\n        lockStatus[msg.sender] = true;\r\n\r\n        if (!_isAlreadyAdded(msg.sender)) {\r\n            lockOwners.push(msg.sender);\r\n        }\r\n    }\r\n\r\n    function releaseTokens(uint256 _lockIndex) external payable {\r\n    require(msg.value == LOCK_FEE, \"Insufficient fee\");        Lock storage lock = locks[msg.sender][_lockIndex];\r\n        require(block.timestamp >= lock.unlockTime, \"Tokens are still locked\");\r\n        totalLockedTokens -= lock.amount;\r\n        require(token.transfer(msg.sender, lock.amount), \"Transfer failed\");\r\n        delete locks[msg.sender][_lockIndex];\r\n        lockStatus[msg.sender] = false; // Set lock status to false\r\n    }\r\n\r\n   function getLockInfo(address _user, uint256 _lockIndex) external view returns (uint256 amount, uint256 unlockTime, string memory username, uint256 lockTime) {\r\n    Lock storage lock = locks[_user][_lockIndex];\r\n    return (lock.amount, lock.unlockTime, lock.username, lock.lockTime);\r\n    }\r\n\r\n\r\n    function _isAlreadyAdded(address _user) private view returns (bool) {\r\n        for (uint i = 0; i < lockOwners.length; i++) {\r\n            if (lockOwners[i] == _user) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\nfunction getAllLockOwners() external view returns (address[] memory, uint256[] memory, uint256[] memory, string[] memory, uint256[] memory) {\r\n    uint256[] memory totalLockedAmounts = new uint256[](lockOwners.length);\r\n    uint256[] memory unlockTimes = new uint256[](lockOwners.length);\r\n    string[] memory usernames = new string[](lockOwners.length);\r\n    uint256[] memory lockTimes = new uint256[](lockOwners.length);\r\n\r\n    for (uint i = 0; i < lockOwners.length; i++) {\r\n        uint256 totalLocked = 0;\r\n        Lock[] storage userLocks = locks[lockOwners[i]];\r\n        uint256 lastUnlockTime = 0;\r\n        string memory lastUsername = \"\";\r\n        uint256 lastLockTime = 0;\r\n\r\n        for (uint j = 0; j < userLocks.length; j++) {\r\n            if (block.timestamp < userLocks[j].unlockTime) {\r\n                totalLocked += userLocks[j].amount;\r\n                lastUnlockTime = userLocks[j].unlockTime;\r\n                lastUsername = userLocks[j].username;\r\n                lastLockTime = userLocks[j].lockTime;\r\n            }\r\n        }\r\n        totalLockedAmounts[i] = totalLocked;\r\n        unlockTimes[i] = lastUnlockTime;\r\n        usernames[i] = lastUsername;\r\n        lockTimes[i] = lastLockTime;\r\n    }\r\n\r\n    return (lockOwners, totalLockedAmounts, unlockTimes, usernames, lockTimes);\r\n}\r\n\r\n\r\n\r\n    function getLockCount(address _user) external view returns (uint256) {\r\n    return locks[_user].length;\r\n}\r\n\r\n\r\n    function approveToken(IBEP20 _token, uint256 _amount) external {\r\n    require(_token.approve(address(this), _amount), \"Token approval failed\");\r\n}\r\n\r\nfunction _removeLockOwner(address _user) private {\r\n    for (uint i = 0; i < lockOwners.length; i++) {\r\n        if (lockOwners[i] == _user) {\r\n            lockOwners[i] = lockOwners[lockOwners.length - 1];\r\n            lockOwners.pop();\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LOCK_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllLockOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum TokenLocker.LockPeriod\",\"name\":\"_lockPeriod\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"releaseTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenLocker", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1aa627b069fadf20b7340e373d8bb31545798546bad4e870bbf0e938d17d6c90"}