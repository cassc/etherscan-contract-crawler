{"SourceCode": "/*\r\n    SPDX-License-Identifier: MIT\r\n    A Bankteller Production\r\n    Bankroll Network\r\n    Copyright 2021\r\n*/\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract Token {\r\n    \r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    \r\n}\r\n\r\ncontract BankrollNetworkStack {\r\n\r\n    function donatePool(uint amount) public returns (uint256);\r\n    function buy(uint buy_amount) public returns (uint256);\r\n    function balanceOf(address _customerAddress) public view returns (uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) public returns (bool);\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Stack is a perpetual rewards contract the collects 8% fee on buys/sells for a dividend pool that drips 2% daily.\r\n * A 2% fee is paid instantly to token holders on buys/sells as well\r\n*/\r\n\r\n\r\ncontract BankrollNetworkStackProxy  {\r\n\r\n    uint256 public constant MAX_UINT = 2**256 - 1;\r\n\r\n    address public tokenAddress;\r\n\r\n    address public stackAddress;\r\n\r\n    BankrollNetworkStack private stack;\r\n\r\n    Token private token;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(address _tokenAddress, address _stackAddress) public {\r\n\r\n        tokenAddress = _tokenAddress;\r\n        token = Token(_tokenAddress);\r\n\r\n        stackAddress = _stackAddress;\r\n        stack = BankrollNetworkStack(_stackAddress);\r\n\r\n    }\r\n\r\n\r\n    /// @dev This is how you pump pure \"drip\" dividends into the system\r\n    function donatePool(uint amount) public returns (uint256) {\r\n        require(token.transferFrom(msg.sender, address(this),amount));\r\n\r\n        //any residual tokens from a previous tx will be captured in addition to the transfer\r\n        uint _balance = token.balanceOf(address(this));\r\n\r\n        //approve tokens to move\r\n        token.approve(stackAddress, _balance);\r\n\r\n        return stack.donatePool(_balance);\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy(uint _buy_amount) public returns (uint256)  {\r\n        return buyFor(msg.sender, _buy_amount);\r\n    }\r\n\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress, uint _buy_amount) public returns (uint256)  {\r\n        \r\n        //zero check\r\n        require(_buy_amount > 0, \"amount must be greater than zero\");\r\n\r\n        //approval and proper balance required.  USE SENDER'S TOKENS\r\n        require(token.transferFrom(msg.sender, address(this), _buy_amount), \"sender requires adequate balance and approvals\");\r\n        \r\n        //any residual tokens from a previous tx will be captured in addition to the transfer\r\n        uint _balance = token.balanceOf(address(this));\r\n\r\n        //approve tokens to move\r\n        token.approve(stackAddress, _balance);\r\n\r\n        //buy tokens\r\n        stack.buy(_balance);\r\n\r\n        //get the balance\r\n        uint _stack_balance = stack.balanceOf(address(this));\r\n\r\n        //transfer balance \r\n        require(stack.transfer(_customerAddress, _stack_balance), \"Stack transfer failed\");\r\n\r\n\r\n        return _stack_balance;\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev Fallback function to return any TRX/ETH/BNB accidentally sent to the contract\r\n     */\r\n    function() payable public {\r\n        require(false);\r\n    }\r\n\r\n   \r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_buy_amount\",\"type\":\"uint256\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buy_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donatePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stackAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_stackAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "BankrollNetworkStackProxy", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000190b589cf9fb8ddeabbfeae36a813ffb2a702454000000000000000000000000d397f06eecd4eb9af0492874be0d24d67560ff69", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://eb942b07e0fb1b329c339adff0fe5ba29a176067e9737c9dbb0ed994ee7c7bd0"}