{"SourceCode": "// Sources flattened with hardhat v2.17.2 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// End consumer library.\r\nlibrary Client {\r\n  struct EVMTokenAmount {\r\n    address token; // token address on the local chain.\r\n    uint256 amount; // Amount of tokens.\r\n  }\r\n\r\n  struct Any2EVMMessage {\r\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\r\n    uint64 sourceChainSelector; // Source chain selector.\r\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\r\n    bytes data; // payload sent in original message.\r\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\r\n  }\r\n\r\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\r\n  struct EVM2AnyMessage {\r\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\r\n    bytes data; // Data payload\r\n    EVMTokenAmount[] tokenAmounts; // Token transfers\r\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\r\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\r\n  }\r\n\r\n  // extraArgs will evolve to support new features\r\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\r\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\r\n  struct EVMExtraArgsV1 {\r\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\r\n    bool strict; // See strict sequencing details below.\r\n  }\r\n\r\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\r\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol@v0.7.6\r\n\r\n/// @notice Application contracts that intend to receive messages from\r\n/// the router should implement this interface.\r\ninterface IAny2EVMMessageReceiver {\r\n  /// @notice Called by the Router to deliver a message.\r\n  /// If this reverts, any token transfers also revert. The message\r\n  /// will move to a FAILED state and become available for manual execution.\r\n  /// @param message CCIP Message\r\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol@v0.7.6\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n    * @dev Returns true if this contract implements the interface defined by\r\n    * `interfaceId`. See the corresponding\r\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n    * to learn more about how these ids are created.\r\n    *\r\n    * This function call must use less than 30 000 gas.\r\n    */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol@v0.7.6\r\n\r\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\r\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\r\n  address internal i_router;\r\n\r\n  constructor(address router) {\r\n    if (router == address(0)) revert InvalidRouter(address(0));\r\n    i_router = router;\r\n  }\r\n\r\n  /// @notice IERC165 supports an interfaceId\r\n  /// @param interfaceId The interfaceId to check\r\n  /// @return true if the interfaceId is supported\r\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n  }\r\n\r\n  /// @inheritdoc IAny2EVMMessageReceiver\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\r\n    _ccipReceive(message);\r\n  }\r\n\r\n  /// @notice Override this function in your implementation.\r\n  /// @param message Any2EVMMessage\r\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\r\n\r\n  /////////////////////////////////////////////////////////////////////\r\n  // Plumbing\r\n  /////////////////////////////////////////////////////////////////////\r\n\r\n  /// @notice Return the current router\r\n  /// @return i_router address\r\n  function getRouter() public view returns (address) {\r\n    return address(i_router);\r\n  }\r\n\r\n  error InvalidRouter(address router);\r\n\r\n  /// @dev only calls from the set router are accepted.\r\n  modifier onlyRouter() {\r\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol@v0.7.6\r\n\r\ninterface IRouterClient {\r\n  error UnsupportedDestinationChain(uint64 destChainSelector);\r\n  error InsufficientFeeTokenAmount();\r\n  error InvalidMsgValue();\r\n\r\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\r\n  /// @param chainSelector The chain to check.\r\n  /// @return supported is true if it is supported, false if not.\r\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\r\n\r\n  /// @notice Gets a list of all supported tokens which can be sent or received\r\n  /// to/from a given chain id.\r\n  /// @param chainSelector The chainSelector.\r\n  /// @return tokens The addresses of all tokens that are supported.\r\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\r\n\r\n  /// @param destinationChainSelector The destination chainSelector\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return fee returns guaranteed execution fee for the specified message\r\n  /// delivery to destination chain\r\n  /// @dev returns 0 fee on invalid message.\r\n  function getFee(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage memory message\r\n  ) external view returns (uint256 fee);\r\n\r\n  /// @notice Request a message to be sent to the destination chain\r\n  /// @param destinationChainSelector The destination chain ID\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return messageId The message ID\r\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\r\n  /// the overpayment with no refund.\r\n  function ccipSend(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage calldata message\r\n  ) external payable returns (bytes32);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/IAccessControl.sol@v4.9.3\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.9.3\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.9.3\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.9.3\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/SignedMath.sol@v4.9.3\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.9.3\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/AccessControl.sol@v4.9.3\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```solidity\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```solidity\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\r\n * to enforce additional security measures for this role.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     *\r\n     * Format of the revert message is described in {_checkRole}.\r\n     *\r\n     * _Available since v4.6._\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(account),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.9.3\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interface/IERC1271.sol\r\n\r\ninterface IERC1271 {\r\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n  // bytes4 constant internal MAGICVALUE = 0x1626ba7e;\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\n// File contracts/interface/IKlasterGatewayWallet.sol\r\n\r\ninterface IKlasterGatewayWallet {\r\n\r\n    function execute(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bool, address);\r\n\r\n    function executeWithData(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes32 extraData\r\n    ) external returns (bool, address);\r\n\r\n}\r\n\r\n\r\n// File contracts/gateway/KlasterGatewayWallet.sol\r\n\r\ncontract KlasterGatewayWallet is Ownable, IERC1271, IKlasterGatewayWallet {\r\n\r\n    address public klasterGatewaySingleton;\r\n\r\n    mapping (bytes32 => bool) public signatures;\r\n\r\n    constructor(address _owner) {\r\n        klasterGatewaySingleton = msg.sender;\r\n        _transferOwnership(_owner);\r\n    }\r\n\r\n    function executeWithData(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes32 extraData\r\n    ) external returns (bool, address) {\r\n        if (destination == address(0)) { // contract deployment\r\n            if (extraData == \"\") { // deploy using create()\r\n                return (true, _performCreate(value, data));\r\n            } else { // deploy using create2()\r\n                return (true, _performCreate2(value, data, extraData));\r\n            }\r\n        } else { // transaction execution (use extra data as contract wallet signature as per ERC-1271)\r\n            if (extraData != \"\") { signatures[extraData] = true; }\r\n            return execute(destination, value, data);\r\n        }\r\n    }\r\n\r\n    function execute(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) public returns (bool, address) {\r\n        require(\r\n            msg.sender == klasterGatewaySingleton || msg.sender == owner(),\r\n            \"Not an owner!\"\r\n        );\r\n        bool result;\r\n        uint dataLength = data.length;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return (result, address(0));\r\n    }\r\n\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4 magicValue) {\r\n        if (signatures[_hash]) {\r\n            magicValue = 0x1626ba7e; // ERC1271: valid signature = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n        }\r\n    }\r\n\r\n    function _performCreate(\r\n        uint256 value,\r\n        bytes memory deploymentData\r\n    ) internal returns (address newContract) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        require(newContract != address(0), \"Could not deploy contract\");\r\n    }\r\n\r\n    function _performCreate2(\r\n        uint256 value,\r\n        bytes memory deploymentData,\r\n        bytes32 salt\r\n    ) internal returns (address newContract) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            newContract := create2(value, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        require(newContract != address(0), \"Could not deploy contract\");\r\n    }\r\n\r\n    /// @notice Fallback function to allow the contract to receive Ether.\r\n    /// @dev This function has no function body, making it a default function for receiving Ether.\r\n    /// It is automatically called when Ether is sent to the contract without any data.\r\n    receive() external payable {}\r\n\r\n}\r\n\r\n\r\n// File contracts/interface/IKlasterGatewaySingleton.sol\r\n\r\ninterface IKlasterGatewaySingleton {\r\n\r\n    /************************** EVENTS **************************/\r\n\r\n    // Event emitted when a new gateway wallet instance has been deployed.\r\n    event WalletDeploy(\r\n        address indexed owner,\r\n        address gatewayWallet\r\n    );\r\n    \r\n    // Event emitted when a message is sent to another chain.\r\n    event SendRTC(\r\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\r\n        address indexed caller, // Wallet initiating the RTC\r\n        uint64 destinationChainSelector, // The chain selector of the destination chain.\r\n        uint64 execChainSelector, // The chain selector of the execution chain.\r\n        address targetContract, // Remote contract to execute on dest chain\r\n        bytes32 extraData, // Message hash used for ERC-1271 or salt used for create2\r\n        address feeToken, // the token address used to pay CCIP fees.\r\n        uint256 ccipfees, // The fees paid for sending the CCIP message.\r\n        uint256 totalFees // Total fees (ccip + platform fee)\r\n    );\r\n\r\n    // Event emitted when a message is received from another chain.\r\n    event ReceiveRTC(\r\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\r\n        uint64 indexed sourceChainSelector, // The chain selector of the destination chain.\r\n        address caller, // Wallet initiating the RTC.\r\n        address targetContract, // Remote contract to execute on dest chain,\r\n        bytes32 extraData // Message hash used for ERC-1271 or salt used for create2\r\n    );\r\n\r\n    // Event emitted when any gateway wallet action gets executed\r\n    event Execute(\r\n        address indexed caller,\r\n        address indexed gatewayWallet,\r\n        address indexed destination,\r\n        bool status,\r\n        address contractDeployed,\r\n        bytes32 extraData\r\n    );\r\n\r\n    /************************** WRITE **************************/\r\n\r\n    function deploy(string memory salt) external returns (address);\r\n\r\n    function batchExecute(\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external payable returns (bool[] memory, address[] memory, bytes32[] memory);\r\n\r\n    function execute(\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) external payable returns (bool, address, bytes32);\r\n\r\n    /************************** READ **************************/\r\n\r\n    function getDeployedWallets(address owner) external view returns (address[] memory);\r\n    \r\n    function calculateBatchExecuteFee(\r\n        address caller,\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external view returns (uint256);\r\n\r\n    function calculateExecuteFee(\r\n        address caller,\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) external view returns (uint256);\r\n\r\n    function calculateAddress(address owner, string memory salt) external view returns (address);\r\n\r\n    function calculateCreate2Address(\r\n        address owner,\r\n        string memory salt,\r\n        bytes memory byteCode,\r\n        bytes32 create2Salt\r\n    ) external view returns (address);\r\n\r\n}\r\n\r\n\r\n// File contracts/interface/IOwnable.sol\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/gateway/KlasterGatewaySingleton.sol\r\n\r\ncontract KlasterGatewaySingleton is IKlasterGatewaySingleton, CCIPReceiver, AccessControl {\r\n\r\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\r\n    bytes32 public constant HARVEST_MANAGER_ROLE = keccak256(\"HARVEST_MANAGER_ROLE\");\r\n    bytes32 public constant CCIP_MANAGER_ROLE = keccak256(\"CCIP_MANAGER_ROLE\");\r\n\r\n    uint256 public feePercentage; // percentage fee on top of the ccip fees (modifiable by the owner)\r\n    uint64 public thisChainSelector; // current chain selector\r\n    uint64 public relayerChainSelector; // relayer chain selector (sepolia for testnet, eth for mainnet)\r\n    \r\n    mapping (address => bool) public deployed;\r\n    mapping (address => uint64) public controllingChains; // gateway wallet => controlling chain id\r\n    mapping (address => string) public salts; // gateway wallet => salt\r\n    mapping (address => address[]) public instances; // user => gateway wallet[]\r\n\r\n    constructor(\r\n        address _sourceRouter,\r\n        uint64 _thisChainSelector,\r\n        uint64 _relayerChainSelector,\r\n        address _roleManager,\r\n        address _ccipManager,\r\n        address _harvestManager,\r\n        address _feeManager,\r\n        uint256 _feePercentage\r\n    ) CCIPReceiver(_sourceRouter) {\r\n        thisChainSelector = _thisChainSelector;\r\n        relayerChainSelector = _relayerChainSelector;\r\n        feePercentage = _feePercentage;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, _roleManager);\r\n        _grantRole(FEE_MANAGER_ROLE, _feeManager);\r\n        _grantRole(HARVEST_MANAGER_ROLE, _harvestManager);\r\n        _grantRole(CCIP_MANAGER_ROLE, _ccipManager);\r\n\r\n        // sanity checks\r\n        require(\r\n            _relayerChainSelector == _thisChainSelector ||\r\n            IRouterClient(getRouter()).isChainSupported(relayerChainSelector),\r\n            \"Invalid relayer chain configuration.\"\r\n        );\r\n        require(_feeManager != address(0), \"Fee manager is 0x0\");\r\n        require(_ccipManager != address(0), \"CCIP manager is 0x0\");\r\n    }\r\n\r\n    function deploy(string memory salt) public override returns (address) {\r\n       return _deploy(msg.sender, salt, thisChainSelector);\r\n    }\r\n\r\n    /***\r\n     * FEE_MANAGER FUNCTIONS (SENSITIVE)\r\n     * \r\n     * Append only. Cant break anything or shut down the service.\r\n     * KlasterGatewayWallet wallets will always work and in that sense it's permissionless.\r\n     * The only two things a fee manager can affect and change post deployment are:\r\n     *     1) Update platform fee - CAPPED TO 100% of the CCIP fee (!)\r\n     *     2) Withdraw platform fee earnings\r\n     */\r\n    function updateFee(uint256 _feePercentage) external {\r\n        require(hasRole(FEE_MANAGER_ROLE, msg.sender), \"Caller is not a fee manager.\");\r\n        require(_feePercentage <= 100, \"Platform fee is capped to 100% of the CCIP fee.\");\r\n        feePercentage = _feePercentage;\r\n    }\r\n\r\n    function withdraw(uint256 amount) external {\r\n        require(hasRole(HARVEST_MANAGER_ROLE, msg.sender), \"Caller is not a harvest manager.\");\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /***\r\n     * CCIP_MANAGER FUNCTIONS (SENSITIVE)\r\n     * \r\n     * CCIP manager is the only address that can update the router addresses.\r\n     * This is a temporary role to be used only once. Chainlink's CCIP team is going to deploy\r\n     * new router addresses after the GA launch, and this function will be used to store the new\r\n     * router address and replace the old ones. After the update is complete, CCIP manager will renounce\r\n     * its role.\r\n     */\r\n    function updateRouter(address _newRouterAddress) external {\r\n        require(hasRole(CCIP_MANAGER_ROLE, msg.sender), \"Caller is not a ccip manager.\");\r\n        i_router = _newRouterAddress;\r\n    }\r\n\r\n    /************ PUBLIC WRITE FUNCTIONS ************/\r\n\r\n    function batchExecute(\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external payable override returns (bool[] memory success, address[] memory contractDeployed, bytes32[] memory messageId) {\r\n        success = new bool[](execChainSelectors.length);\r\n        contractDeployed = new address[](execChainSelectors.length);\r\n        messageId = new bytes32[](execChainSelectors.length);\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            (success[i], contractDeployed[i], messageId[i]) = execute(\r\n                execChainSelectors[i],\r\n                salt[i],\r\n                destination[i],\r\n                value[i],\r\n                data[i],\r\n                gasLimit[i],\r\n                extraData[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function execute(\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) public payable override returns (bool success, address contractDeployed, bytes32 messageId) {\r\n        \r\n        if (destination != address(0) && extraData != \"\") { // if executing contract call (destination != 0) and extra data exists, then verify if the extra data is a valid signature\r\n            require(\r\n                IERC1271(msg.sender).isValidSignature(\r\n                    extraData,\r\n                    \"\"\r\n                ) == 0x1626ba7e, // ERC1271: valid signature = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n                \"Invalid signature.\"\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            (success, contractDeployed, messageId) = _execute(\r\n                ExecutionData(\r\n                    msg.sender,\r\n                    thisChainSelector,\r\n                    execChainSelectors[i],\r\n                    salt,\r\n                    destination,\r\n                    value,\r\n                    data,\r\n                    gasLimit,\r\n                    extraData,\r\n                    true\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /************ PUBLIC READ FUNCTIONS ************/\r\n\r\n    function getDeployedWallets(address owner) external view override returns (address[] memory) {\r\n        return instances[owner];\r\n    }\r\n\r\n    function calculateBatchExecuteFee(\r\n        address caller,\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external view override returns (uint256 totalFee) {\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            totalFee += calculateExecuteFee(\r\n                caller,\r\n                execChainSelectors[i],\r\n                salt[i],\r\n                destination[i],\r\n                value[i],\r\n                data[i],\r\n                gasLimit[i],\r\n                extraData[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function calculateExecuteFee(\r\n        address caller,\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) public view override returns (uint256 totalFee) {\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            uint64 execChainSelector = execChainSelectors[i];\r\n            if (execChainSelector != thisChainSelector) {\r\n                // Get available lane    \r\n                uint64 destChainSelector = _getDestChainSelector(execChainSelector);\r\n        \r\n                // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n                Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\r\n                    address(this),\r\n                    abi.encode(caller, thisChainSelector, execChainSelector, salt, destination, value, data, gasLimit, extraData),\r\n                    address(0),\r\n                    gasLimit\r\n                );\r\n\r\n                (, uint256 fee) = _getFees(destChainSelector, execChainSelector, evm2AnyMessage);\r\n                totalFee += fee;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateAddress(address owner, string memory salt) public view override returns (address) {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff), address(this), keccak256(abi.encodePacked(owner, salt)), keccak256(_getBytecode(owner))\r\n            )\r\n        );\r\n        return address(uint160(uint(hash)));\r\n    }\r\n\r\n    function calculateCreate2Address(\r\n        address owner,\r\n        string memory salt,\r\n        bytes memory byteCode,\r\n        bytes32 create2Salt\r\n    ) external view override returns (address) {\r\n        bytes32 hash_ = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff),\r\n                calculateAddress(owner, salt),\r\n                create2Salt,\r\n                keccak256(byteCode)\r\n            )\r\n        );\r\n        return address(uint160(uint256(hash_)));\r\n    }\r\n\r\n    /************ INTERNAL FUNCTIONS ************/\r\n    \r\n    struct ExecutionData {\r\n        address caller;\r\n        uint64 sourceChainSelector;\r\n        uint64 execChainSelector;\r\n        string salt;\r\n        address destination;\r\n        uint256 value;\r\n        bytes data;\r\n        uint256 gasLimit;\r\n        bytes32 extraData;\r\n        bool feeEnabled;\r\n    }\r\n    function _execute(\r\n        ExecutionData memory execData\r\n    ) internal returns (bool success, address contractDeployed, bytes32 messageId) {\r\n        if (execData.execChainSelector == thisChainSelector) { // execute on this chain\r\n            (success, contractDeployed) = _executeOnWallet(\r\n                execData.sourceChainSelector,\r\n                execData.caller,\r\n                execData.salt,\r\n                execData.destination,\r\n                execData.value,\r\n                execData.data,\r\n                execData.extraData\r\n            );\r\n        } else { // remote execution on target chain via CCIP\r\n\r\n            // Get available lane  \r\n            uint64 destChainSelector = _getDestChainSelector(execData.execChainSelector);\r\n\r\n            // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n            Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\r\n                address(this),\r\n                abi.encode(\r\n                    execData.caller,\r\n                    execData.sourceChainSelector,\r\n                    execData.execChainSelector,\r\n                    execData.salt,\r\n                    execData.destination,\r\n                    execData.value,\r\n                    execData.data,\r\n                    execData.gasLimit,\r\n                    execData.extraData\r\n                ),\r\n                address(0),\r\n                execData.gasLimit\r\n            );\r\n\r\n            (uint256 ccipFees, uint256 totalFee) = _getFees(\r\n                destChainSelector,\r\n                execData.execChainSelector,\r\n                evm2AnyMessage\r\n            );\r\n\r\n            // Take into account platform fee\r\n            if (execData.feeEnabled) {\r\n                require(msg.value >= totalFee, \"Ether amount too low. Send more ether to execute call.\");\r\n            }\r\n            \r\n            success = true;\r\n            messageId = IRouterClient(getRouter()).ccipSend{value: ccipFees}(\r\n                destChainSelector,\r\n                evm2AnyMessage\r\n            );\r\n\r\n            emit SendRTC(\r\n                    messageId,\r\n                    execData.caller,\r\n                    destChainSelector,\r\n                    execData.execChainSelector,\r\n                    execData.destination,\r\n                    execData.extraData,\r\n                    address(0),\r\n                    ccipFees,\r\n                    totalFee\r\n            );\r\n        }\r\n    }\r\n\r\n    // executes given action on the callers gateway wallet\r\n    function _executeOnWallet(\r\n        uint64 sourceChainSelector,\r\n        address caller,\r\n        string memory salt,\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes32 extraData\r\n    ) internal returns (bool status, address contractDeployed) {\r\n        address walletInstanceAddress = calculateAddress(caller, salt);\r\n        if (!deployed[walletInstanceAddress]) {\r\n            _deploy(caller, salt, sourceChainSelector);\r\n        } else {\r\n            require(\r\n                sourceChainSelector == controllingChains[walletInstanceAddress],\r\n                \"Can only execute from controlling chain.\"\r\n            );\r\n        }\r\n        \r\n        IKlasterGatewayWallet walletInstance = IKlasterGatewayWallet(walletInstanceAddress);\r\n        \r\n        require(IOwnable(walletInstanceAddress).owner() == caller, \"Not an owner!\");\r\n        (status, contractDeployed) = walletInstance.executeWithData(destination, value, data, extraData);\r\n        \r\n        emit Execute(caller, walletInstanceAddress, destination, status, contractDeployed, extraData);\r\n    }\r\n\r\n    // deploys new gateway wallet for given owner and salt\r\n    function _deploy(\r\n        address owner,\r\n        string memory salt,\r\n        uint64 sourceChainSelector\r\n    ) private returns (address walletInstance) {\r\n        require(!deployed[calculateAddress(owner, salt)], \"Already deployed! Use different salt!\");\r\n        \r\n        bytes memory bytecode = _getBytecode(owner);\r\n        bytes32 calculatedSalt = keccak256(abi.encodePacked(owner, salt));\r\n        assembly {\r\n            walletInstance := create2(0, add(bytecode, 32), mload(bytecode), calculatedSalt)\r\n        }\r\n        deployed[walletInstance] = true;\r\n        salts[walletInstance] = salt;\r\n        controllingChains[walletInstance] = sourceChainSelector;\r\n        instances[owner].push(walletInstance);\r\n        \r\n        emit WalletDeploy(owner, walletInstance);\r\n    }\r\n\r\n    // get the bytecode of the contract KlasterGatewayWallet with encoded constructor\r\n    function _getBytecode(address owner) private pure returns (bytes memory) {\r\n        bytes memory bytecode = type(KlasterGatewayWallet).creationCode;\r\n        return abi.encodePacked(bytecode, abi.encode(owner));\r\n    }\r\n\r\n    // @notice Construct a CCIP message.\r\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for sending arbitrary bytes cross chain.\r\n    /// @param _receiver The address of the receiver.\r\n    /// @param _message The bytes data to be sent.\r\n    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.\r\n    /// @param _gasLimit Gas limit.\r\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\r\n    function _buildCCIPMessage(\r\n        address _receiver,\r\n        bytes memory _message,\r\n        address _feeTokenAddress,\r\n        uint256 _gasLimit\r\n    ) internal pure returns (Client.EVM2AnyMessage memory) {\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(_receiver), // ABI-encoded receiver address\r\n            data: _message, // ABI-encoded string\r\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array aas no tokens are transferred\r\n            extraArgs: Client._argsToBytes(\r\n                // Additional arguments, setting gas limit and non-strict sequencing mode\r\n                Client.EVMExtraArgsV1({gasLimit: _gasLimit, strict: false})\r\n            ),\r\n            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\r\n            feeToken: _feeTokenAddress\r\n        });\r\n        return evm2AnyMessage;\r\n    }\r\n\r\n    /// handle received execution message\r\n    function _ccipReceive(\r\n        Client.Any2EVMMessage memory any2EvmMessage\r\n    )\r\n        internal\r\n        override\r\n    {\r\n        require(\r\n            abi.decode(any2EvmMessage.sender, (address)) == address(this),\r\n            \"Only official KlasterGatewaySingleton can send CCIP messages.\"\r\n        );\r\n\r\n        (\r\n            address caller,\r\n            uint64 sourceChainSelector,\r\n            uint64 execChainSelector,\r\n            string memory salt,\r\n            address destination,\r\n            uint256 value,\r\n            bytes memory data,\r\n            uint256 gasLimit,\r\n            bytes32 extraData\r\n        ) = abi.decode(\r\n            any2EvmMessage.data,\r\n            (\r\n                address,\r\n                uint64,\r\n                uint64,\r\n                string,\r\n                address,\r\n                uint256,\r\n                bytes,\r\n                uint256,\r\n                bytes32\r\n            )\r\n        );\r\n\r\n        _execute(\r\n            ExecutionData(\r\n                caller,\r\n                sourceChainSelector,\r\n                execChainSelector,\r\n                salt,\r\n                destination,\r\n                value,\r\n                data,\r\n                gasLimit,\r\n                extraData,\r\n                false\r\n            )\r\n        );\r\n\r\n        emit ReceiveRTC(\r\n            any2EvmMessage.messageId,\r\n            any2EvmMessage.sourceChainSelector,\r\n            caller,\r\n            destination,\r\n            extraData\r\n        );\r\n    }\r\n\r\n    function _getFees(\r\n        uint64 destChainSelector,\r\n        uint64 execChainSelector,\r\n        Client.EVM2AnyMessage memory message\r\n    ) internal view returns (uint256 ccipFee, uint256 totalFee) {\r\n        // Multiply fees by 2 if not a direct lane\r\n        uint256 laneMultiplier = (destChainSelector == execChainSelector) ? 1 : 2;\r\n        ccipFee = IRouterClient(getRouter()).getFee(destChainSelector, message);\r\n        totalFee = (ccipFee + (ccipFee * feePercentage / 100)) * laneMultiplier;\r\n    }\r\n\r\n    function _directLaneExists(uint64 execChainSelector) internal view returns (bool) {\r\n        return IRouterClient(getRouter()).isChainSupported(execChainSelector);\r\n    }\r\n    \r\n    function _getDestChainSelector(uint64 execChainSelector) internal view returns (uint64 selector) {\r\n        selector = _directLaneExists(execChainSelector) ? execChainSelector : relayerChainSelector;\r\n    }\r\n\r\n    /// @notice Fallback function to allow the contract to receive Ether.\r\n    /// @dev This function has no function body, making it a default function for receiving Ether.\r\n    /// It is automatically called when Ether is sent to the contract without any data.\r\n    receive() external payable {}\r\n\r\n    /// ERC165\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view override(CCIPReceiver, AccessControl) returns (bool) {\r\n        return CCIPReceiver.supportsInterface(interfaceId) || AccessControl.supportsInterface(interfaceId);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sourceRouter\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_thisChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_relayerChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_roleManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ccipManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_harvestManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gatewayWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractDeployed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"ReceiveRTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"execChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ccipfees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"name\":\"SendRTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gatewayWallet\",\"type\":\"address\"}],\"name\":\"WalletDeploy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CCIP_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARVEST_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[][]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[][]\"},{\"internalType\":\"string[]\",\"name\":\"salt\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"destination\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"gasLimit\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraData\",\"type\":\"bytes32[]\"}],\"name\":\"batchExecute\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"success\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"contractDeployed\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"messageId\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"calculateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint64[][]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[][]\"},{\"internalType\":\"string[]\",\"name\":\"salt\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"destination\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"gasLimit\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraData\",\"type\":\"bytes32[]\"}],\"name\":\"calculateBatchExecuteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"byteCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"create2Salt\",\"type\":\"bytes32\"}],\"name\":\"calculateCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"calculateExecuteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"controllingChains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"contractDeployed\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getDeployedWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"instances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayerChainSelector\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"salts\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thisChainSelector\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRouterAddress\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KlasterGatewaySingleton", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000536d7e53d0adeb1f20e7c81fea45d02ec9dbd6980000000000000000000000000000000000000000000000009d70576d8e253bcf00000000000000000000000000000000000000000000000045849994fc9c7b15000000000000000000000000cab92d81c9c60955794c09da80e4bae939ac7017000000000000000000000000cab92d81c9c60955794c09da80e4bae939ac7017000000000000000000000000cab92d81c9c60955794c09da80e4bae939ac7017000000000000000000000000cab92d81c9c60955794c09da80e4bae939ac70170000000000000000000000000000000000000000000000000000000000000019", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0322c853cf2005918976253b0b9e50d25fdcf53549046b221b62a4959d5bb9a1"}