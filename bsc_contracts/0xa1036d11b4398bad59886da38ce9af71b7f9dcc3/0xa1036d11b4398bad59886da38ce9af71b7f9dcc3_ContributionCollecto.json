{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ContributionCollectorFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IContributionCollectorFactory.sol\\\";\\nimport \\\"./interfaces/IPledgeContributionCollector.sol\\\";\\nimport \\\"./interfaces/IFlashContributionCollector.sol\\\";\\n\\nerror ZeroAddressImplementation();\\nerror ZeroAddressContributionToken();\\nerror InvalidContributionCap();\\nerror InvalidMerkleRoot();\\nerror InvalidTierCaps();\\n\\n/**\\n * @title ContributionCollectorFactory\\n * @dev ContributionCollectorFactory contract\\n * @author Federico Luzzi - <fedeluzzi00@gmail.com>\\n * SPDX-License-Identifier: GPL-3.0\\n */\\ncontract ContributionCollectorFactory is\\n    IContributionCollectorFactory,\\n    Ownable\\n{\\n    address public pledgeContributionImplementation;\\n    address public flashContributionImplementation;\\n    mapping(address => bool) public contributionCollectorCreated;\\n\\n    event PledgeContributionCollectorCreated(address collector);\\n    event FlashContributionCollectorCreated(address collector);\\n    event PledgeImplementationUpgraded(address implementation);\\n    event FlashImplementationUpgraded(address implementation);\\n\\n    constructor(\\n        address _initialPledgeImplementation,\\n        address _initialFlashImplementation\\n    ) {\\n        if (_initialPledgeImplementation == address(0))\\n            revert ZeroAddressImplementation();\\n        if (_initialFlashImplementation == address(0))\\n            revert ZeroAddressImplementation();\\n        pledgeContributionImplementation = _initialPledgeImplementation;\\n        flashContributionImplementation = _initialFlashImplementation;\\n    }\\n\\n    function upgradePledgeImplementation(address _upgradedImplementation)\\n        external\\n        onlyOwner\\n    {\\n        if (_upgradedImplementation == address(0))\\n            revert ZeroAddressImplementation();\\n        pledgeContributionImplementation = _upgradedImplementation;\\n        emit PledgeImplementationUpgraded(_upgradedImplementation);\\n    }\\n\\n    function upgradeFlashImplementation(address _upgradedImplementation)\\n        external\\n        onlyOwner\\n    {\\n        if (_upgradedImplementation == address(0))\\n            revert ZeroAddressImplementation();\\n        flashContributionImplementation = _upgradedImplementation;\\n        emit FlashImplementationUpgraded(_upgradedImplementation);\\n    }\\n\\n    function createPledgeContributionCollector(\\n        address _token,\\n        uint256 _contributionCap,\\n        bytes32 _merkleRoot,\\n        uint256 _collectionTimeLimit,\\n        address[] calldata _allowedRecipients\\n    ) external onlyOwner {\\n        // all input checks are performed by the contribution collector itself\\n        IPledgeContributionCollector _collector = IPledgeContributionCollector(\\n            ClonesUpgradeable.cloneDeterministic(\\n                pledgeContributionImplementation,\\n                keccak256(\\n                    abi.encodePacked(_token, _contributionCap, _merkleRoot)\\n                )\\n            )\\n        );\\n        _collector.initialize(\\n            _token,\\n            _contributionCap,\\n            _merkleRoot,\\n            _collectionTimeLimit,\\n            _allowedRecipients\\n        );\\n        _collector.transferOwnership(msg.sender);\\n        contributionCollectorCreated[address(_collector)] = true;\\n        emit PledgeContributionCollectorCreated(address(_collector));\\n    }\\n\\n    function createFlashContributionCollector(\\n        address _token,\\n        uint256[] calldata _tierCaps,\\n        bytes32 _merkleRoot,\\n        uint256 _collectionTimeLimit,\\n        address[] calldata _allowedRecipients\\n    ) external onlyOwner {\\n        // all input checks are performed by the contribution collector itself\\n        IFlashContributionCollector _collector = IFlashContributionCollector(\\n            ClonesUpgradeable.cloneDeterministic(\\n                flashContributionImplementation,\\n                keccak256(abi.encodePacked(_token, _tierCaps, _merkleRoot))\\n            )\\n        );\\n        _collector.initialize(\\n            _token,\\n            _merkleRoot,\\n            _tierCaps,\\n            _collectionTimeLimit,\\n            _allowedRecipients\\n        );\\n        _collector.transferOwnership(msg.sender);\\n        contributionCollectorCreated[address(_collector)] = true;\\n        emit FlashContributionCollectorCreated(address(_collector));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IContributionCollectorFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n/**\\n * @title IContributionCollectorFactory\\n * @dev IContributionCollectorFactory interface\\n * @author Federico Luzzi - <fedeluzzi00@gmail.com>\\n * SPDX-License-Identifier: GPL-3.0\\n */\\ninterface IContributionCollectorFactory {\\n    function contributionCollectorCreated(address _collector)\\n        external\\n        view\\n        returns (bool);\\n\\n    function upgradePledgeImplementation(address _upgradedImplementation)\\n        external;\\n\\n    function upgradeFlashImplementation(address _upgradedImplementation)\\n        external;\\n\\n    function createPledgeContributionCollector(\\n        address _token,\\n        uint256 _contributionCap,\\n        bytes32 _merkleRoot,\\n        uint256 _collectionTimeLimit,\\n        address[] calldata _allowedRecipients\\n    ) external;\\n\\n    function createFlashContributionCollector(\\n        address _token,\\n        uint256[] calldata _tierCaps,\\n        bytes32 _merkleRoot,\\n        uint256 _collectionTimeLimit,\\n        address[] calldata _allowedRecipients\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPledgeContributionCollector.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n/**\\n * @title IPledgeContributionCollector\\n * @dev PledgeContributionCollector interface\\n * @author Federico Luzzi - <fedeluzzi00@gmail.com>\\n * SPDX-License-Identifier: GPL-3.0\\n */\\ninterface IPledgeContributionCollector {\\n    enum State {\\n        ACTIVE,\\n        CANCELED,\\n        FINALIZED\\n    }\\n\\n    struct Contributor {\\n        uint256 contributed;\\n        mapping(bytes32 => uint256) contributionWithMerkleRoot;\\n        bool recovered;\\n    }\\n\\n    struct Contribution {\\n        uint256 cap;\\n        uint256 amount;\\n    }\\n\\n    function state() external view returns (State);\\n\\n    function merkleRoot() external view returns (bytes32);\\n\\n    function token() external view returns (address);\\n\\n    function contributedWithMerkleRoot(address _account, bytes32 _merkleRoot)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function contributed(address _account) external view returns (uint256);\\n\\n    function recovered(address _account) external view returns (bool);\\n\\n    function initialize(\\n        address _token,\\n        uint256 _contributionCap,\\n        bytes32 _merkleRoot,\\n        uint256 _expirationTimestamp,\\n        address[] calldata _allowedRecipients\\n    ) external;\\n\\n    function transferOwnership(address _owner) external;\\n\\n    function updateMerkleRoot(bytes32 _merkleRoot) external;\\n\\n    function cancel() external;\\n\\n    function finalize(address _recipient) external;\\n\\n    function updateCap(uint256 _newCap) external;\\n\\n    function contribute(\\n        address _account,\\n        uint256 _amount,\\n        uint256 _maximumAmount,\\n        bytes32[] calldata _proof\\n    ) external;\\n\\n    function recover() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashContributionCollector.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n/**\\n * @title IFlashContributionCollector\\n * @dev IFlashContributionCollector interface\\n * @author Federico Luzzi - <fedeluzzi00@gmail.com>\\n * SPDX-License-Identifier: GPL-3.0\\n */\\ninterface IFlashContributionCollector {\\n    enum State {\\n        ACTIVE,\\n        CANCELED,\\n        FINALIZED\\n    }\\n\\n    struct Contributor {\\n        uint256 contributed;\\n        mapping(bytes32 => uint256) contributionWithMerkleRoot;\\n        bool recovered;\\n    }\\n\\n    struct Contribution {\\n        uint256[] tierCaps;\\n        uint256[] amounts;\\n        uint256 totalAmount;\\n    }\\n\\n    function state() external view returns (State);\\n\\n    function merkleRoot() external view returns (bytes32);\\n\\n    function token() external view returns (address);\\n\\n    function contributedWithMerkleRoot(address _account, bytes32 _merkleRoot)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function contributed(address _account) external view returns (uint256);\\n\\n    function recovered(address _account) external view returns (bool);\\n\\n    function initialize(\\n        address _token,\\n        bytes32 _merkleRoot,\\n        uint256[] calldata _tierCaps,\\n        uint256 _collectionTimeLimit,\\n        address[] calldata _allowedRecipients\\n    ) external;\\n\\n    function transferOwnership(address _owner) external;\\n\\n    function updateMerkleRoot(bytes32 _merkleRoot) external;\\n\\n    function cancel() external;\\n\\n    function finalize(address _recipient) external;\\n\\n    function updateTierCaps(uint256[] calldata _newTierCaps) external;\\n\\n    function contribute(\\n        address _account,\\n        uint256 _amount,\\n        uint256 _tier,\\n        uint256 _maximumAmount,\\n        bytes32[] calldata _proof\\n    ) external;\\n\\n    function recover() external;\\n\\n    function contributionAmount(uint256 _tier) external view returns (uint256);\\n\\n    function contributionTierCap(uint256 _tier) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialPledgeImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initialFlashImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ZeroAddressImplementation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"FlashContributionCollectorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"FlashImplementationUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"PledgeContributionCollectorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"PledgeImplementationUpgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributionCollectorCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tierCaps\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collectionTimeLimit\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_allowedRecipients\",\"type\":\"address[]\"}],\"name\":\"createFlashContributionCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_contributionCap\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_collectionTimeLimit\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_allowedRecipients\",\"type\":\"address[]\"}],\"name\":\"createPledgeContributionCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashContributionImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pledgeContributionImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upgradedImplementation\",\"type\":\"address\"}],\"name\":\"upgradeFlashImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upgradedImplementation\",\"type\":\"address\"}],\"name\":\"upgradePledgeImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ContributionCollectorFactory", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006e9eeb3bccc03dc48ae82f122c1fa7d710348d510000000000000000000000004409ccbfb560e8799a9528753ff9d8a6ba371d16", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}