{"SourceCode": "//SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Owner {\r\n    address public owner;\r\n    constructor () {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function isOwner() internal view returns (bool) {\r\n        return owner == msg.sender;\r\n    }\r\n\r\n    function setOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ActiveAdmin is Owner {\r\n\r\n    mapping(address => bool) private _activeAdmins;\r\n\r\n    modifier onlyActiveAdmin() {\r\n        require(isActiveAdmin(msg.sender));\r\n        _;\r\n    }\r\n    function isActiveAdmin(address account) internal view returns (bool) {\r\n        return _activeAdmins[account];\r\n    }\r\n\r\n    function addActiveAdmin(address account) public onlyOwner {\r\n        require(account != address(0));\r\n        _activeAdmins[account] = true;\r\n    }\r\n\r\n    function removeActiveAdmin(address account) public onlyOwner {\r\n        require(account != address(0));\r\n        delete _activeAdmins[account];\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20, ActiveAdmin{\r\n\r\n    struct SwapTerm {\r\n        uint termId;\r\n        uint termStartTime;\r\n        uint termEndTime;\r\n        uint amount;\r\n        bool stop;\r\n        uint timePerAdd;\r\n    }\r\n    \r\n    using SafeMath for uint256;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply = 0;\r\n    uint256 private _totalBurn = 0;\r\n    uint256 private _remainRewardFreeze = 121000000000000; \r\n    uint256 private _remainPoolFreeze = 10000000000000;\r\n    uint256 private _gameMintFreeze = 50000000000000;\r\n    uint256 private planTotalSupply = 198000000000000;\r\n    \r\n    address[] private sysCreators; \r\n    address[] private sysGenesises; \r\n    address[] private sysNodes; \r\n    mapping(address => uint) private upgradeTimes; \r\n    mapping(address => address) private creators; \r\n    mapping(address => address) private genesises; \r\n    mapping(address => address) private nodes; \r\n    mapping(address => address) private parents;\r\n    mapping(address => address[]) private children;\r\n\r\n    mapping(address => bool) private swapMainAddresses; \r\n    mapping(uint256 => SwapTerm) private swapTerms;\r\n    uint private constant initSwapTermTime = 24 hours;\r\n    uint private currSwapTermId = 0;\r\n    mapping(uint => address[]) private swapTermJoinAddresses;\r\n\r\n    bool private supportActive = true;\r\n    mapping(address => uint) private activeTimes;\r\n    mapping(address => uint) private blindBoxTimes;\r\n    mapping(address => uint) private levels;\r\n    uint private constant blindBoxFee = 3000000000;\r\n    uint private constant feeGainTotal = 3000000000;\r\n    uint private constant freeGainTotal = 1000000000;\r\n \r\n    struct JoinInfo {\r\n        address account;\r\n        uint num;  \r\n        uint amount;\r\n    }\r\n    \r\n    mapping(uint => JoinInfo[]) private joinInfos;\r\n    uint private constant startTime = 1644508800;\r\n\r\n    \r\n    struct FreezeInfo {\r\n        address account; \r\n        uint freezeAmount;\r\n        uint freezeTime;\r\n    }\r\n    FreezeInfo[] private freezeInfos;\r\n\r\n    address public bonusAddress = address(0x5922d0a4E664A307B392bE7cA7ee8cC16E0386d1);\r\n    address public swapPoolAddress = address(0xb6fF62A5598C8C9812255a33919915Ad222CBf08);\r\n    address public freezeAdminAddress = address(0x38b56C0c4EaC205972C4736c9D357d21458D0852);\r\n    address public totalAddress = address(0x6AC22e7198BDfC869106D0565096965A22e9aE0D);\r\n\r\n    function isFreezeAccount(address account) public view returns (bool){\r\n        if(getFreezeTime(account) > 0 && blockTime().sub(getFreezeTime(account)) < 1096 days){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getTotalFreezeAmount() public view returns (uint){\r\n        uint total = 0;\r\n        if(freezeInfos.length > 0){\r\n            for (uint256 i = 0; i < freezeInfos.length; i++) {\r\n                if(isFreezeAccount(freezeInfos[i].account)){\r\n                    total = total.add(freezeInfos[i].freezeAmount);\r\n                }\r\n            }\r\n        }\r\n        return 0; \r\n    }\r\n\r\n    function getFreezeAmount(address account) public view returns (uint){\r\n        if(freezeInfos.length > 0){\r\n            for (uint256 i = 0; i < freezeInfos.length; i++) {\r\n                if(account == freezeInfos[i].account){\r\n                    return freezeInfos[i].freezeAmount;\r\n                }\r\n            }\r\n        }\r\n        return 0; \r\n    }\r\n\r\n    function getFreezeTime(address account) public view returns (uint){\r\n        if(freezeInfos.length > 0){\r\n            for (uint256 i = 0; i < freezeInfos.length; i++) {\r\n                if(account == freezeInfos[i].account){\r\n                    return freezeInfos[i].freezeTime;\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getUpgradeTime(address account) public view returns (uint){\r\n        return upgradeTimes[account];\r\n    }\r\n\r\n    function getCreators() public view returns (address[] memory){\r\n        return sysCreators;\r\n    }\r\n\r\n    function getGenesises() public view returns (address[] memory){\r\n        return sysGenesises;\r\n    }\r\n\r\n    function getNodes() public view returns (address[] memory){\r\n        return sysNodes;\r\n    }\r\n\r\n    function isCreator(address addr) public view returns (bool){\r\n        if(sysCreators.length > 0){\r\n            for (uint256 i = 0; i < sysCreators.length; i++) {\r\n                if(addr == sysCreators[i]){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false; \r\n    }\r\n\r\n    function isGenesis(address addr) public view returns (bool){\r\n        if(sysGenesises.length > 0){\r\n            for (uint256 i = 0; i < sysGenesises.length; i++) {\r\n                if(addr == sysGenesises[i]){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false; \r\n    }\r\n\r\n    function isNode(address addr) public view returns (bool){\r\n        if(sysNodes.length > 0){\r\n            for (uint256 i = 0; i < sysNodes.length; i++) {\r\n                if(addr == sysNodes[i]){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false; \r\n    }\r\n\r\n    function blockTime() public view returns (uint){\r\n        return block.timestamp;\r\n    }\r\n    \r\n    function swapTermIsValid(uint swapTermId) internal view returns (bool){\r\n        SwapTerm memory swapTerm = swapTerms[swapTermId];\r\n        return block.timestamp > swapTerm.termStartTime && block.timestamp < swapTerm.termEndTime;\r\n    }\r\n\r\n    function setSwapMainAddress(address account) public onlyOwner returns (bool success) {\r\n        swapMainAddresses[account] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeSwapMainAddress(address account) public onlyOwner returns (bool success) {\r\n        delete swapMainAddresses[account];\r\n        return true;\r\n    }\r\n\r\n    function isSwapMainAddress(address account) public view returns(bool){\r\n        return swapMainAddresses[account];\r\n    }\r\n    \r\n    function getSwapPoolAddress() public view returns(address){\r\n        return swapPoolAddress;\r\n    }\r\n\r\n    function getCurrSwapTermId() internal view returns (uint){\r\n        return currSwapTermId;\r\n    }\r\n\r\n    event NewSwapTerm(uint256 indexed swapTermId);\r\n\r\n    event StopSwapTerm(uint256 indexed swapTermId);\r\n\r\n    constructor (string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) {\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = tokenDecimals;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function totalBurn() public view returns (uint256) {\r\n        return _totalBurn;\r\n    }\r\n\r\n    function totalRewardFreeze() public view returns (uint256) {\r\n        return _remainRewardFreeze;\r\n    }\r\n\r\n    function totalPoolFreeze() public view returns (uint256) {\r\n        return _remainPoolFreeze;\r\n    }\r\n\r\n    function totalGameMintFreeze() public view returns (uint256) {\r\n        return _gameMintFreeze;\r\n    }\r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        require(msg.sender != swapPoolAddress);\r\n        _transfer(msg.sender, recipient, amount);\r\n        if(isActiveAdmin(msg.sender)){\r\n            if(amount == 50000000000){\r\n                internalUpgrade(1, recipient);\r\n            } \r\n            if(amount == 10000000000){\r\n                internalUpgrade(2, recipient);\r\n            }  \r\n            if(amount == 2000000000){\r\n                internalUpgrade(3, recipient);  \r\n            }                            \r\n        } \r\n        if(msg.sender == freezeAdminAddress){\r\n            if(getFreezeTime(recipient) == 0){\r\n                freezeInfos.push(FreezeInfo(recipient, amount, blockTime()));\r\n            }                              \r\n        }\r\n        if (recipient != swapPoolAddress && msg.sender != swapPoolAddress) {\r\n            if (isCreator(msg.sender) || isGenesis(msg.sender) || isNode(msg.sender)) {\r\n                if (parents[recipient] == address(0)) {\r\n                    if(isCreator(msg.sender)){\r\n                        creators[recipient] = msg.sender;\r\n                    } else {\r\n                        if (creators[msg.sender] != address(0)) {\r\n                            creators[recipient] = creators[msg.sender];\r\n                        }\r\n                    }\r\n                    if(isGenesis(msg.sender)){\r\n                        genesises[recipient] = msg.sender;\r\n                    } else {\r\n                        if (genesises[msg.sender] != address(0)) {\r\n                            genesises[recipient] = genesises[msg.sender];\r\n                        }\r\n                    }\r\n                    if(isNode(msg.sender)){\r\n                        nodes[recipient] = msg.sender;\r\n                    } else {\r\n                        if (nodes[msg.sender] != address(0)) {\r\n                            nodes[recipient] = nodes[msg.sender];\r\n                        }\r\n                    }\r\n                    parents[recipient] = msg.sender;\r\n                    children[msg.sender].push(recipient);                      \r\n                }\r\n            }       \r\n        }\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        require(msg.sender != swapPoolAddress);\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        require(msg.sender != swapPoolAddress);\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(msg.sender != swapPoolAddress);\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require( msg.sender != swapPoolAddress);\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0) && spender != address(0));\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function internalUpgrade(uint8 _type, address account) internal returns (bool) {\r\n        if (_type == 1 && upgradeTimes[account] == 0 && _balances[account] >= 50000000000) {\r\n            if(!isCreator(account)){\r\n                creators[account] = account;\r\n                sysCreators.push(account);\r\n            }  \r\n            if(!isGenesis(account)){\r\n                genesises[account] = account;\r\n                sysGenesises.push(account);\r\n            }\r\n            if(!isNode(account)){\r\n                nodes[account] = account;\r\n                sysNodes.push(account);\r\n            }\r\n            upgradeTimes[account] = block.timestamp;\r\n            return true;                  \r\n        }\r\n        if (_type == 2 && upgradeTimes[account] == 0 && _balances[account] >= 10000000000) {\r\n            if(!isGenesis(account)){\r\n                genesises[account] = account;\r\n                sysGenesises.push(account);\r\n            }\r\n            if(!isNode(account)){\r\n                nodes[account] = account;\r\n                sysNodes.push(account);\r\n            }\r\n            upgradeTimes[account] = block.timestamp;\r\n            return true;                  \r\n        }\r\n        if (_type == 3 && !isNode(account) && upgradeTimes[account] == 0 && _balances[account] >= 2000000000) {\r\n            nodes[account] = account;\r\n            sysNodes.push(account);\r\n            upgradeTimes[account] = block.timestamp;\r\n            return true;           \r\n        }\r\n        return false;\r\n    }\r\n\r\n    function upgrade(uint8 _type) public returns (bool) {\r\n        return internalUpgrade(_type, msg.sender);\r\n    }\r\n\r\n    function gameMint(address account, uint amount) public onlyOwner returns (bool success) {\r\n        return _gameMint(account, amount);\r\n    }\r\n\r\n    function _gameMint(address account, uint256 amount) internal returns (bool){\r\n        if (_gameMintFreeze > amount) {\r\n            _gameMintFreeze = _gameMintFreeze.sub(amount);\r\n            return _mint(account, amount);\r\n        }\r\n        return false;\r\n    }\r\n     \r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0) && recipient != address(0));\r\n        if (sender != swapPoolAddress && !isSwapMainAddress(sender)) {\r\n            require(_balances[sender] >= amount.add(getUserFreeze(sender)), \"Insufficient balance...\");\r\n        } else {\r\n            require(_balances[sender] >= amount, \"balance not enough revert...\");\r\n        }\r\n        if(currSwapTermId > 0){\r\n            SwapTerm memory swapTerm = swapTerms[currSwapTermId];\r\n            if(isSwapMainAddress(sender) && amount >= swapTerm.amount){\r\n                successSwapPoolBiz(recipient);\r\n            }\r\n        }\r\n        if(isSwapMainAddress(recipient)){\r\n            require(amount >= 10);\r\n            _burn(sender, amount.mul(10).div(100));\r\n            uint actAmount = amount.mul(90).div(100);\r\n            _balances[sender] = _balances[sender].sub(actAmount);\r\n            _balances[recipient] = _balances[recipient].add(actAmount);\r\n            emit Transfer(sender, recipient, actAmount);\r\n        } else {\r\n            _balances[sender] = _balances[sender].sub(amount);\r\n            _balances[recipient] = _balances[recipient].add(amount);\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    function doOpenBlindbox() public returns (bool){\r\n        if(_balances[msg.sender] >= getUserFreeze(msg.sender).add(blindBoxFee)){\r\n            _rewardMint(msg.sender, feeGainTotal);\r\n            openBlindbox(msg.sender);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _batchTransfer(address[] memory addresses, uint256[] memory amounts) public returns (bool){\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            _transfer(msg.sender, addresses[i], amounts[i]);\r\n        }\r\n        return true; \r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal returns (bool){\r\n        if (_totalSupply.add(amount) <= planTotalSupply) {\r\n            _totalSupply = _totalSupply.add(amount);\r\n            _balances[account] = _balances[account].add(amount);\r\n            emit Transfer(address(0), account, amount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        if (account != swapPoolAddress && !isSwapMainAddress(account)) {\r\n            require(_balances[account] >= value.add(getUserFreeze(account)), \"Insufficient balance...\");\r\n        } else {\r\n            require(_balances[account] >= value, \"balance not enough revert...\");\r\n        }\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _totalBurn = _totalBurn.add(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n    \r\n\r\n    function _rewardMint(address account, uint256 amount) internal returns (bool){\r\n        if (_remainRewardFreeze > amount) {\r\n            _remainRewardFreeze = _remainRewardFreeze.sub(amount);\r\n            return _mint(account, amount);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _poolMint(address account, uint256 amount) internal returns (bool){\r\n        if (_remainPoolFreeze > amount) {\r\n            _remainPoolFreeze = _remainPoolFreeze.sub(amount);\r\n            return _mint(account, amount);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function userInfo(address addr) public view returns (uint _balance, address _creator, address _genesis, address _node, address _parent, bool _isCreator, bool _isGenesis, bool _isNode){\r\n        _balance = _balances[addr];\r\n        _creator = creators[addr];\r\n        _genesis = genesises[addr];\r\n        _node = nodes[addr];\r\n        _parent = parents[addr];\r\n        _isCreator = isCreator(addr);\r\n        _isGenesis = isGenesis(addr);\r\n        _isNode = isNode(addr);\r\n    }\r\n\r\n    function userChildren(address addr) public view returns (address[] memory _children){\r\n        _children = children[addr];\r\n    }\r\n\r\n    function addSwapTerm(uint amount, uint timePerAdd, uint poolAmount) public onlyOwner returns (bool success) {\r\n        if (currSwapTermId >= 1) {\r\n            require(swapTerms[currSwapTermId].stop);\r\n        }\r\n        currSwapTermId++;\r\n        uint currTime = blockTime();\r\n        SwapTerm storage swapTerm = swapTerms[currSwapTermId];\r\n        swapTerm.termId = currSwapTermId;\r\n        swapTerm.termStartTime = currTime;\r\n        swapTerm.termEndTime = currTime.add(initSwapTermTime);\r\n        swapTerm.amount = amount;\r\n        swapTerm.timePerAdd = timePerAdd;\r\n        emit NewSwapTerm(currSwapTermId);\r\n        _poolMint(swapPoolAddress, poolAmount);\r\n        return true;\r\n    }\r\n    \r\n    function stopSwapTerm() public onlyOwner returns (bool success) {\r\n        SwapTerm storage swapTerm = swapTerms[currSwapTermId];\r\n        if (!swapTerm.stop && blockTime() > swapTerm.termEndTime) {\r\n            swapTerm.termEndTime = blockTime();\r\n            swapTerm.stop = true;\r\n            emit StopSwapTerm(currSwapTermId);\r\n            if (_balances[swapPoolAddress] > 0) {\r\n                uint length = swapTermJoinAddresses[currSwapTermId].length;\r\n                if (length > 10) {\r\n                    uint swapPoolBalance = _balances[swapPoolAddress];\r\n                    for (uint256 i = length - 1; i >= length - 10; i--) {\r\n                        if (i == length - 1) {\r\n                            _transfer(swapPoolAddress, swapTermJoinAddresses[currSwapTermId][i], swapPoolBalance.mul(50).div(100));\r\n                        } else if (i == length - 2) {\r\n                            _transfer(swapPoolAddress, swapTermJoinAddresses[currSwapTermId][i], swapPoolBalance.mul(10).div(100));\r\n                        } else {\r\n                            _transfer(swapPoolAddress, swapTermJoinAddresses[currSwapTermId][i], swapPoolBalance.mul(5).div(100));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function successSwapPoolBiz(address account) internal {\r\n        if (swapTermIsValid(currSwapTermId)) {\r\n            SwapTerm storage storageSwapTerm = swapTerms[currSwapTermId];\r\n            swapTermJoinAddresses[currSwapTermId].push(account);\r\n            if (storageSwapTerm.termEndTime.add(storageSwapTerm.timePerAdd).sub(blockTime()) < initSwapTermTime) {\r\n                storageSwapTerm.termEndTime = storageSwapTerm.termEndTime.add(storageSwapTerm.timePerAdd);\r\n            } else {\r\n                storageSwapTerm.termEndTime = blockTime() + initSwapTermTime;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function currSwapTermInfo() public view returns (uint _swapTermId, uint _startTime, uint _endTime, uint _blockTime, uint _amount, bool _stop){\r\n        SwapTerm memory swapTerm = swapTerms[currSwapTermId];\r\n        _swapTermId = currSwapTermId;\r\n        _startTime = swapTerm.termStartTime;\r\n        _endTime = swapTerm.termEndTime;\r\n        _amount = swapTerm.amount;\r\n        _blockTime = blockTime();\r\n        _stop = swapTerm.stop;\r\n    }\r\n\r\n    function swapTermInfo(uint swapTermId) public view returns (uint _startTime, uint _endTime, uint _blockTime, uint _amount, bool _stop){\r\n        SwapTerm memory swapTerm = swapTerms[swapTermId];\r\n        _startTime = swapTerm.termStartTime;\r\n        _endTime = swapTerm.termEndTime;\r\n        _amount = swapTerm.amount;\r\n        _blockTime = blockTime();\r\n        _stop = swapTerm.stop;\r\n    }\r\n    \r\n    function getUserFreeze(address account) public view returns(uint){\r\n        uint total = 1000000;\r\n        if(userIsOpen(account) && calcBlindboxReward(account) < feeGainTotal){\r\n            total = total.add(blindBoxFee).add(feeGainTotal.sub(calcBlindboxReward(account)));\r\n        }\r\n        if(activeTimes[account] > 0 && calcFreeMinerReward(account) < freeGainTotal){\r\n            total = total.add(freeGainTotal.sub(calcFreeMinerReward(account)));\r\n        }\r\n        if(upgradeTimes[account] > 0){\r\n            uint totalSeconds = blockTime().sub(upgradeTimes[account]);\r\n            if(isCreator(account) && totalSeconds > 0 && totalSeconds.mul(800) < 50000000000){\r\n                total = total.add(uint(50000000000).sub(totalSeconds.mul(800)));\r\n            } else if(!isCreator(account) && isGenesis(account) && totalSeconds > 0 && totalSeconds.mul(400) < 10000000000){\r\n                total = total.add(uint(10000000000).sub(totalSeconds.mul(400)));\r\n            } else if(!isCreator(account) && !isGenesis(account) && isNode(account) && totalSeconds > 0 && totalSeconds.mul(128) < 2000000000){\r\n                total = total.add(uint(2000000000).sub(totalSeconds.mul(128)));\r\n            }\r\n        }\r\n        if(isFreezeAccount(account)){\r\n            total = total.add(getFreezeAmount(account));\r\n        }  \r\n        return total;\r\n    }\r\n    \r\n    function getSwapTermJoinTimes(uint swapTermId, address account) public view returns (uint) {\r\n        uint sum = 0;\r\n        uint length = swapTermJoinAddresses[swapTermId].length;\r\n        if(length > 0){\r\n            for (uint256 i = 0; i < length; i++) {\r\n                if (account == swapTermJoinAddresses[swapTermId][i]) {\r\n                    sum += 1;\r\n                }\r\n            }   \r\n        }\r\n        return sum;\r\n    }\r\n    \r\n    function getSwapWinners(uint swapTermId) public view returns (address winner1, address winner2, address winner3, address winner4, address winner5, address winner6, address winner7, address winner8, address winner9, address winner10){\r\n        uint length = swapTermJoinAddresses[swapTermId].length;\r\n        if (length >= 1) {\r\n            winner1 = swapTermJoinAddresses[swapTermId][length-1];\r\n        }\r\n        if (length >= 2) {\r\n            winner2 = swapTermJoinAddresses[swapTermId][length-2];\r\n        }\r\n        if (length >= 3) {\r\n            winner3 = swapTermJoinAddresses[swapTermId][length-3];\r\n        }\r\n        if (length >= 4) {\r\n            winner4 = swapTermJoinAddresses[swapTermId][length-4];\r\n        }\r\n        if (length >= 5) {\r\n            winner5 = swapTermJoinAddresses[swapTermId][length-5];\r\n        }\r\n        if (length >= 6) {\r\n            winner6 = swapTermJoinAddresses[swapTermId][length-6];\r\n        }\r\n        if (length >= 7) {\r\n            winner7 = swapTermJoinAddresses[swapTermId][length-7];\r\n        }\r\n        if (length >= 8) {\r\n            winner8 = swapTermJoinAddresses[swapTermId][length-8];\r\n        }\r\n        if (length >= 9) {\r\n            winner9 = swapTermJoinAddresses[swapTermId][length-9];\r\n        }\r\n        if (length >= 10) {\r\n            winner10 = swapTermJoinAddresses[swapTermId][length-10];\r\n        }\r\n    }\r\n    \r\n    function updateSupportActive() public onlyOwner returns (bool) {\r\n        supportActive = !supportActive;\r\n        return true;\r\n    }\r\n    \r\n\r\n    function getSupportActive() public view returns (bool) {\r\n        return supportActive;\r\n    }\r\n    \r\n    function doActive(address account) public onlyActiveAdmin returns (bool) {\r\n        require(supportActive);\r\n        require(activeTimes[account] == 0);\r\n        activeTimes[account] = block.timestamp;\r\n        _rewardMint(account, freeGainTotal);\r\n        return true;\r\n    }\r\n\r\n    function getGameUserInfo(address addr) public view returns (uint activeTime, uint blindBoxTime, uint level, bool open, uint feeMinerSpeed, uint freeMinerSpeed, uint freeTotal, uint feeTotal) {\r\n        activeTime = activeTimes[addr];\r\n        blindBoxTime = blindBoxTimes[addr];\r\n        level = levels[addr];\r\n        open = blindBoxTimes[addr] > 0;\r\n        freeTotal = calcFreeMinerReward(addr);\r\n        feeTotal = calcBlindboxReward(addr);\r\n        if(blindBoxTimes[addr] > 0 && feeTotal < feeGainTotal){\r\n            feeMinerSpeed = getMinerSpeed(level);\r\n        }\r\n        if(activeTimes[addr] > 0 && freeTotal < freeGainTotal){\r\n            freeMinerSpeed = getMinerSpeed(1);\r\n        }\r\n    }\r\n\r\n    function getBlindBoxNumber() internal view returns (uint8) {\r\n        uint8 randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 100) + 1;\r\n        if(randomNumber <= 3){\r\n            return 2;\r\n        } else if(randomNumber > 3 && randomNumber <= 8){\r\n            return 3;\r\n        } else if(randomNumber > 8 && randomNumber <= 18){\r\n            return 4;\r\n        } else if(randomNumber > 18 && randomNumber <= 38){\r\n            return 5;\r\n        } else if(randomNumber > 38 && randomNumber <= 78){\r\n            return 6;\r\n        } else if(randomNumber > 78 && randomNumber <= 88){\r\n            return 7;\r\n        } else if(randomNumber > 88 && randomNumber <= 95){\r\n            return 8;\r\n        } else if(randomNumber > 95 && randomNumber <= 98){\r\n            return 9;\r\n        } else if(randomNumber > 98 && randomNumber <= 100){\r\n            return 10;\r\n        }\r\n        return randomNumber;\r\n    }\r\n\r\n\r\n    function updateGameUserLevel(address addr, uint level) internal returns (bool){\r\n        require(blindBoxTimes[addr] == 0);\r\n        blindBoxTimes[addr] = block.timestamp;\r\n        levels[addr] = level;\r\n        return true;\r\n    }\r\n\r\n\r\n    function userIsOpen(address addr) internal view returns (bool){\r\n        return blindBoxTimes[addr] > 0;\r\n    }\r\n\r\n    function getMinerSpeed(uint level) internal pure returns (uint){\r\n        if(level == 1){\r\n            return 23;\r\n        } else if (level == 2){\r\n            return 231;\r\n        } else if (level == 3){\r\n            return 248;\r\n        } else if (level == 4){\r\n            return 267;\r\n        } else if (level == 5){\r\n            return 289;\r\n        } else if (level == 6){\r\n            return 315;\r\n        } else if (level == 7){\r\n            return 347;\r\n        } else if (level == 8){\r\n            return 385;\r\n        } else if (level == 9){\r\n            return 496;\r\n        } else if (level == 10){\r\n            return 694;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function calcBlindboxReward(address addr) public view returns(uint){\r\n        if(blindBoxTimes[addr] > 0){\r\n            uint level = levels[addr];\r\n            uint totalTime = block.timestamp - blindBoxTimes[addr];\r\n            uint total = totalTime.mul(getMinerSpeed(level));\r\n            return total > feeGainTotal ? feeGainTotal : total;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function calcFreeMinerReward(address addr) public view returns(uint){\r\n        if(activeTimes[addr] > 0){\r\n            uint totalTime = block.timestamp - activeTimes[addr];\r\n            uint total = totalTime.mul(getMinerSpeed(1));\r\n            return total > freeGainTotal ? freeGainTotal : total;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function openBlindbox(address account) internal returns(uint){\r\n        uint level = getBlindBoxNumber();\r\n        updateGameUserLevel(account, level);\r\n        return level;\r\n    }\r\n    \r\n    function join(uint8 num, uint amount) public returns (bool){\r\n        require(num>=0 && num<=13);\r\n        uint termId = getCurrJoinTermId();\r\n        require(!hasJoin(msg.sender, termId));\r\n        joinInfos[termId].push(JoinInfo(msg.sender, num, amount));\r\n        _transfer(msg.sender, bonusAddress, amount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function getJoinTermId(uint timestamp) public pure returns (uint){\r\n        uint sub = timestamp.sub(startTime);\r\n        uint termId = sub.div(1 days) + 1;\r\n        return termId;\r\n    }\r\n    \r\n    function getCurrJoinTermId() public view returns (uint){\r\n        return getJoinTermId(blockTime());\r\n    }\r\n    \r\n    function hasJoin(address account, uint termId) public view returns (bool){\r\n        JoinInfo[] memory info = joinInfos[termId];\r\n        if(info.length > 0){\r\n            for (uint256 i = 0; i < info.length; i++) {\r\n                if(info[i].account == account){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n     }\r\n     \r\n     function joinInfo(uint termId, address account) public view returns (uint num, uint amount){\r\n        JoinInfo[] memory info = joinInfos[termId];\r\n        if(info.length > 0){\r\n            for (uint256 i = 0; i < info.length; i++) {\r\n                if(info[i].account == account){\r\n                    num = info[i].num;\r\n                    amount = info[i].amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcTotal(uint8 termId, uint8 number) public view returns (uint){\r\n        JoinInfo[] memory info = joinInfos[termId];\r\n        if(info.length > 0){\r\n            uint total = 0;\r\n            for (uint256 i = 0; i < info.length; i++) {\r\n                if(info[i].num == number){\r\n                    total += info[i].amount;\r\n                } \r\n            }\r\n            return total;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function calcPartTotal(uint8 termId, uint8 _type) public view returns (uint){\r\n        JoinInfo[] memory info = joinInfos[termId]; \r\n        if(info.length > 0){\r\n            uint total = 0;\r\n            for (uint256 i = 0; i < info.length; i++) {\r\n                if(_type == 1){\r\n                    if(info[i].num == 1 || info[i].num == 3){\r\n                        total += info[i].amount.mul(5);\r\n                    }\r\n                    if(info[i].num == 11 || info[i].num == 13){\r\n                        total += info[i].amount;\r\n                    }  \r\n                } else if(_type == 2){\r\n                    if(info[i].num == 0 || info[i].num == 2 || info[i].num == 4){\r\n                        total += info[i].amount.mul(5);\r\n                    } \r\n                    if(info[i].num == 10 || info[i].num == 13){\r\n                        total += info[i].amount;\r\n                    } \r\n                } else if(_type == 3){\r\n                    if(info[i].num == 6 || info[i].num == 8){\r\n                        total += info[i].amount.mul(5);\r\n                    } \r\n                    if(info[i].num == 10 || info[i].num == 12){\r\n                        total += info[i].amount;\r\n                    } \r\n                } else if(_type == 4){\r\n                    if(info[i].num == 5 || info[i].num == 7 || info[i].num == 9){\r\n                        total += info[i].amount.mul(5);\r\n                    }\r\n                    if(info[i].num == 11 || info[i].num == 12){\r\n                        total += info[i].amount;\r\n                    }\r\n                }\r\n            }\r\n            return total;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getMin(uint a, uint b) internal pure returns (uint){\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function getNumber(uint8 termId) public view returns (uint){\r\n        JoinInfo[] memory info = joinInfos[termId];\r\n        if(info.length > 0){\r\n            uint singleSmall = calcPartTotal(termId, 1); \r\n            uint doubleSmall = calcPartTotal(termId, 2); \r\n            uint doubleBig = calcPartTotal(termId, 3);\r\n            uint singleBig = calcPartTotal(termId, 4);\r\n            uint minPartTotal = getMin(getMin(singleSmall, doubleSmall), getMin(doubleBig, singleBig));\r\n            if(minPartTotal == singleSmall){\r\n                return calcTotal(termId, 1) <= calcTotal(termId, 3) ? 1 : 3;\r\n            }\r\n            if(minPartTotal == doubleSmall){\r\n                uint total0 = calcTotal(termId, 0);\r\n                uint total2 = calcTotal(termId, 2);\r\n                uint total4 = calcTotal(termId, 4);\r\n                if(total0 <= total2 && total0 <= total4){\r\n                    return 0;\r\n                } else if(total2 <= total0 && total2 <= total4){\r\n                    return 2;\r\n                } else if(total4 <= total0 && total4 <= total2){\r\n                    return 4;\r\n                } \r\n            }\r\n            if(minPartTotal == doubleBig){\r\n                return calcTotal(termId, 6) <= calcTotal(termId, 8) ? 6 : 8;\r\n            }\r\n            if(minPartTotal == singleBig){\r\n                uint total5 = calcTotal(termId, 5);\r\n                uint total7 = calcTotal(termId, 7);\r\n                uint total9 = calcTotal(termId, 9);\r\n                if(total5 <= total7 && total5 <= total9){\r\n                    return 5;\r\n                } else if(total7 <= total5 && total7 <= total9){\r\n                    return 7;\r\n                } else if(total9 <= total5 && total9 <= total7){\r\n                    return 9;\r\n                } \r\n            }\r\n        }\r\n        return 100;\r\n    }\r\n\r\n    function getSystemInfo() public view returns (uint totalCreator, uint totalSuperNode, uint totalNode, uint totalFreezeAmount, uint totalBurnAmount){\r\n        totalCreator = getCreators().length;\r\n        totalSuperNode = getGenesises().length;\r\n        totalNode = getNodes().length;\r\n        totalFreezeAmount = getTotalFreezeAmount();\r\n        totalBurnAmount = totalBurn();\r\n    }\r\n\r\n    \r\n}\r\n\r\ncontract HEGEToken is ERC20 {\r\n    constructor () \r\n        ERC20(\"HEGE Coin\", \"HEGE\", 6) {\r\n        _mint(totalAddress, 8000000 * (10 ** uint256(decimals())));\r\n        _mint(freezeAdminAddress, 9000000 * (10 ** uint256(decimals())));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"swapTermId\",\"type\":\"uint256\"}],\"name\":\"NewSwapTerm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"swapTermId\",\"type\":\"uint256\"}],\"name\":\"StopSwapTerm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"_batchTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addActiveAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePerAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmount\",\"type\":\"uint256\"}],\"name\":\"addSwapTerm\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"calcBlindboxReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"calcFreeMinerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"termId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"calcPartTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"termId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"}],\"name\":\"calcTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currSwapTermInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapTermId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_stop\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doOpenBlindbox\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeAdminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"gameMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrJoinTermId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getFreezeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getFreezeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getGameUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blindBoxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feeMinerSpeed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeMinerSpeed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGenesises\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getJoinTermId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"termId\",\"type\":\"uint8\"}],\"name\":\"getNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapTermId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSwapTermJoinTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapTermId\",\"type\":\"uint256\"}],\"name\":\"getSwapWinners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"winner1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner4\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner5\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner6\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner7\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner8\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner9\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winner10\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCreator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuperNode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalNode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBurnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalFreezeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUpgradeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserFreeze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"termId\",\"type\":\"uint256\"}],\"name\":\"hasJoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isCreator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isFreezeAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isGenesis\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSwapMainAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"num\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"termId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"joinInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeActiveAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeSwapMainAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setSwapMainAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopSwapTerm\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapTermId\",\"type\":\"uint256\"}],\"name\":\"swapTermInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_stop\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGameMintFreeze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolFreeze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardFreeze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateSupportActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"upgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userChildren\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_children\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_genesis\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCreator\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isGenesis\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isNode\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HEGEToken", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://de1ada3179601729769483d76e3cb2ec879a7a7d826aaf48fe0faff6e451f507"}