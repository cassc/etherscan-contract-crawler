{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Employer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ITimeToken.sol\\\";\\n\\n/**\\n * @title TIME Token Employer contract\\n * @dev Smart contract used to model the first Use Case for TIME Token - The Employer. It pays some interest over the native cryptocurrency deposited from investors\\n **/\\ncontract Employer {\\n\\n    bool private _isOperationLocked;\\n\\n    address public constant DEVELOPER_ADDRESS = 0x731591207791A93fB0Ec481186fb086E16A7d6D0;\\n    address public immutable TIME_TOKEN_ADDRESS;\\n\\n    uint256 public constant D = 10**18;\\n    uint256 public constant FACTOR = 10**18;\\n    uint256 public immutable FIRST_BLOCK;\\n    uint256 public immutable ONE_YEAR;\\n    uint256 public availableNative;\\n    uint256 public currentDepositedNative;\\n    uint256 public totalAnticipatedTime;\\n    uint256 public totalBurnedTime;\\n    uint256 public totalDepositedNative;\\n    uint256 public totalDepositedTime;\\n    uint256 public totalEarnedNative;\\n    uint256 public totalTimeSaved;\\n    \\n    mapping (address => bool) public anticipationEnabled;\\n\\n    mapping (address => uint256) public deposited;\\n    mapping (address => uint256) public earned;\\n    mapping (address => uint256) public lastBlock;\\n    mapping (address => uint256) public remainingTime;\\n\\n    constructor(address timeTokenAddress_) {\\n        FIRST_BLOCK = block.number;\\n        TIME_TOKEN_ADDRESS = timeTokenAddress_;\\n        ONE_YEAR = ITimeToken(timeTokenAddress_).TIME_BASE_LIQUIDITY() * 52;\\n    }\\n\\n    /**\\n     * @dev Implement security to avoid reentrancy attacks\\n     **/\\n    modifier nonReentrant() {\\n        require(!_isOperationLocked, \\\"Operation is locked\\\");\\n        _isOperationLocked = true;\\n        _;\\n        _isOperationLocked = false;\\n\\t}\\n    \\n    /**\\n     * @dev Update the blocks from caller (msg.sender), contract address, and burn TIME tokens accordingly. It also extracts ETH from TIME contract, compounds and transfer earnings to depositants\\n     **/\\n    modifier update(bool mustCompound) {\\n        if (lastBlock[address(this)] == 0 && block.number != 0)\\n            lastBlock[address(this)] = block.number;\\n        if ((lastBlock[msg.sender] == 0 && block.number != 0) || remainingTime[msg.sender] == 0)\\n            lastBlock[msg.sender] = block.number;\\n        uint256 timeToBurn = (block.number - lastBlock[address(this)]) * D;\\n        uint256 timeToBurnDepositant = (block.number - lastBlock[msg.sender]) * D;\\n        earned[msg.sender] += queryEarnings(msg.sender);\\n        _;\\n        if (mustCompound)\\n            _compoundDepositantEarnings(msg.sender);\\n        else\\n            _transferDepositantEarnings(msg.sender);\\n        ITimeToken timeToken = ITimeToken(TIME_TOKEN_ADDRESS);\\n        _earnInterestAndAllocate(timeToken);\\n        if (timeToBurn > remainingTime[address(this)])\\n            timeToBurn = remainingTime[address(this)];\\n        if (timeToBurnDepositant > remainingTime[msg.sender])\\n            timeToBurnDepositant = remainingTime[msg.sender];\\n        if (timeToBurn > 0)\\n            _burnTime(timeToken, address(this), timeToBurn);\\n        if (timeToBurnDepositant > 0)\\n            _burnTime(timeToken, msg.sender, timeToBurnDepositant);\\n        lastBlock[address(this)] = block.number;\\n        lastBlock[msg.sender] = block.number;\\n    }\\n\\n    fallback() external payable {\\n        require(msg.data.length == 0);\\n    }\\n\\n    receive() external payable {\\n        if (msg.sender != TIME_TOKEN_ADDRESS) {\\n            require(msg.value > 0, \\\"Please deposit some amount\\\");\\n            availableNative += msg.value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Common function to anticipate gains earned from investments from deposited amount\\n     * @param timeAmount TIME token amount used to anticipate the earnings in terms of blocks\\n     **/\\n    function _anticipateEarnings(uint256 timeAmount) private {\\n        earned[msg.sender] += queryAnticipatedEarnings(msg.sender, timeAmount);\\n        totalAnticipatedTime += timeAmount;\\n        remainingTime[address(this)] += timeAmount;\\n    }\\n\\n    /**\\n     * @dev Burn TIME according to the amount set from selected depositant\\n     * @param timeToken The instance of TIME Token contract\\n     * @param depositant Address of depositant account\\n     * @param amount Amount to be burned\\n     **/\\n    function _burnTime(ITimeToken timeToken, address depositant, uint256 amount) private {\\n        if (amount > timeToken.balanceOf(address(this)))\\n            amount = timeToken.balanceOf(address(this));\\n        try timeToken.burn(amount) {\\n            totalBurnedTime += amount;\\n            remainingTime[depositant] -= amount;\\n        } catch {\\n            revert(\\\"Unable to burn TIME\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Claim the withdrawable amount earned from the TIME Community Pool\\n     * @param timeToken The instance of TIME Token contract\\n     * @return earnings The amount earned from TIME Token Community Pool\\n     **/\\n    function _claimEarningsFromTime(ITimeToken timeToken) private returns (uint256 earnings) {\\n        uint256 currentBalance = address(this).balance;\\n        if (timeToken.withdrawableShareBalance(address(this)) > 0) {\\n            try timeToken.withdrawShare() {\\n                earnings = (address(this).balance - currentBalance);\\n                _payComission(earnings / 2);\\n                earnings /= 2;\\n                return earnings;\\n            } catch {\\n                return earnings;\\n            }\\n        } else {\\n            return earnings;\\n        }\\n    }\\n\\n    /**\\n     * @dev Compound earned amount from selected depositant\\n     * @param depositant Address of depositant account\\n     **/\\n    function _compoundDepositantEarnings(address depositant) private {\\n        if (earned[depositant] > 0) {\\n            require(availableNative >= earned[depositant], \\\"Not enough amount to transfer\\\");\\n            availableNative -= earned[depositant];\\n            deposited[depositant] += earned[depositant];\\n            currentDepositedNative += earned[depositant];\\n            earned[depositant] = 0;\\n        }        \\n    }\\n\\n    /**\\n     * @dev Claim earnings from TIME contract and buy 10% of them in TIME tokens \\n     * @param timeToken The instance of TIME Token contract\\n     **/\\n    function _earnInterestAndAllocate(ITimeToken timeToken) private {\\n        uint256 earnedNative = _claimEarningsFromTime(timeToken);\\n        totalEarnedNative += earnedNative;\\n        _saveTime(timeToken, earnedNative / 10);\\n        availableNative += (earnedNative - (earnedNative / 10));\\n    }\\n\\n    /**\\n     * @notice Called when need to pay comission for miner (block.coinbase) and developer\\n     * @param comissionAmount The total comission amount in ETH which will be paid\\n    **/\\n    function _payComission(uint256 comissionAmount) private {\\n        if (comissionAmount > 0) {\\n            uint256 share = comissionAmount / 4;\\n            _saveTime(ITimeToken(TIME_TOKEN_ADDRESS), share);\\n            payable(DEVELOPER_ADDRESS).transfer(share);\\n            availableNative += share;\\n            totalEarnedNative += share;\\n            if (block.coinbase == address(0))\\n                payable(DEVELOPER_ADDRESS).transfer(share);\\n            else\\n                payable(block.coinbase).transfer(share);\\n        }\\n    }\\n\\n    /**\\n     * @dev Buy (save) TIME tokens from the TIME Token contract and update the amount to be burned\\n     * @param timeToken The instance of TIME Token contract\\n     * @param amountToSave Amount to be bought\\n     **/\\n    function _saveTime(ITimeToken timeToken, uint256 amountToSave) private {\\n        if (amountToSave > 0) {\\n            require(address(this).balance >= amountToSave, \\\"Not enough amount to save TIME\\\");\\n            uint256 currentTime = timeToken.balanceOf(address(this));\\n            try timeToken.saveTime{value: amountToSave}() {\\n                uint256 timeSaved = (timeToken.balanceOf(address(this)) - currentTime);\\n                remainingTime[address(this)] += timeSaved;\\n                totalTimeSaved += timeSaved;\\n            } catch { \\n                revert(\\\"Not able to save TIME\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw all available earnings to the depositant address\\n     * @param depositant Address of depositant account\\n     **/\\n    function _transferDepositantEarnings(address depositant) private {\\n        if (earned[depositant] > 0) {\\n            require(availableNative >= earned[depositant], \\\"Not enough amount to transfer\\\");\\n            availableNative -= earned[depositant];\\n            payable(depositant).transfer(earned[depositant]);\\n            earned[depositant] = 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw all deposited amount to the depositant address and transfer the deposited TIME from depositant to the Employer account\\n     **/\\n    function _withdraw() private {\\n        require(deposited[msg.sender] > 0, \\\"Depositant does not have any amount to withdraw\\\");\\n        require(currentDepositedNative >= deposited[msg.sender], \\\"Not enough in contract to withdraw\\\");\\n        remainingTime[address(this)] += remainingTime[msg.sender];\\n        remainingTime[msg.sender] = 0;\\n        currentDepositedNative -= deposited[msg.sender];\\n        payable(msg.sender).transfer(deposited[msg.sender]);\\n        deposited[msg.sender] = 0;       \\n    }\\n\\n    /**\\n     * @dev Deposit only TIME in order to anticipate interest over previous deposited ETH\\n     * @notice Pre-condition: the depositant must have previous deposited ETH and also should approve (allow to spend) the TIME tokens to deposit. Anticipation is mandatory in this case\\n     * @param timeAmount The amount in TIME an investor should deposit to anticipate\\n     **/\\n    function anticipate(uint256 timeAmount) public payable nonReentrant update(false) {\\n        require(deposited[msg.sender] > 0, \\\"Depositant does not have any amount to anticipate\\\");\\n        require(timeAmount > 0, \\\"Please deposit some TIME amount\\\");\\n        ITimeToken timeToken = ITimeToken(TIME_TOKEN_ADDRESS);\\n        require(timeToken.allowance(msg.sender, address(this)) >= timeAmount, \\\"Should allow TIME to be spent\\\");\\n        try timeToken.transferFrom(msg.sender, address(this), timeAmount) {\\n            totalDepositedTime += timeAmount;\\n            _anticipateEarnings(timeAmount);\\n        } catch {\\n            revert(\\\"Problem when transferring TIME\\\");\\n        }\\n    }      \\n\\n    /**\\n     * @dev Calculate the anticipation fee an investor needs to pay in order to anticipate TIME Tokens in the Employer contract\\n     * @return fee The fee amount calculated\\n     **/\\n    function anticipationFee() public view returns (uint256) {\\n        return (ITimeToken(TIME_TOKEN_ADDRESS).fee() * 11);\\n    }\\n\\n    /**\\n     * @dev Compound available earnings into the depositant account\\n     * @notice Pre-condition: the depositant should approve (allow to spend) the TIME tokens to deposit. Also, if they want to anticipate yield, they must enabled anticipation before the function call\\n     * @param timeAmount (Optional. Can be zero) The amount of TIME Tokens an investor wants to continue receiveing or anticipating earnings \\n     * @param mustAnticipateTime Informs whether an investor wants to anticipate earnings to be compounded\\n     **/\\n    function compound(uint256 timeAmount, bool mustAnticipateTime) public nonReentrant update(true) {\\n        require(deposited[msg.sender] > 0, \\\"Depositant does not have any amount to compound\\\");\\n        if (mustAnticipateTime) \\n            require(anticipationEnabled[msg.sender], \\\"Depositant is not enabled to anticipate TIME\\\");\\n        if (timeAmount > 0) {\\n            ITimeToken timeToken = ITimeToken(TIME_TOKEN_ADDRESS);\\n            require(timeToken.allowance(msg.sender, address(this)) >= timeAmount, \\\"Should allow TIME to be spent\\\");\\n            try timeToken.transferFrom(msg.sender, address(this), timeAmount) {\\n                totalDepositedTime += timeAmount;\\n                if (mustAnticipateTime) {\\n                    _anticipateEarnings(timeAmount);\\n                } else {\\n                    remainingTime[msg.sender] += timeAmount;               \\n                }\\n            } catch {\\n                revert(\\\"Problem when transferring TIME\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Deposit ETH and TIME in order to earn interest over them\\n     * @notice Pre-condition: the depositant should approve (allow to spend) the TIME tokens to deposit. Also, if they want to anticipate yield, they must enabled anticipation before the function call\\n     * @param timeAmount The amount in TIME an investor should deposit\\n     * @param mustAnticipateTime Informs if the depositant wants to anticipate the yield or not\\n     **/\\n    function deposit(uint256 timeAmount, bool mustAnticipateTime) public payable nonReentrant update(false) {\\n        require(msg.value > 0, \\\"Please deposit some amount\\\");\\n        require(timeAmount > 0, \\\"Please deposit some TIME amount\\\");\\n        if (mustAnticipateTime)\\n            require(anticipationEnabled[msg.sender], \\\"Depositant is not enabled to anticipate TIME\\\");\\n        ITimeToken timeToken = ITimeToken(TIME_TOKEN_ADDRESS);\\n        require(timeToken.allowance(msg.sender, address(this)) >= timeAmount, \\\"Should allow TIME to be spent\\\");\\n\\n        uint256 comission = msg.value / 50;\\n        uint256 depositAmount = msg.value - comission;\\n        deposited[msg.sender] += depositAmount;\\n        currentDepositedNative += depositAmount;\\n        totalDepositedNative += msg.value;\\n        try timeToken.transferFrom(msg.sender, address(this), timeAmount) {\\n            totalDepositedTime += timeAmount;\\n            if (mustAnticipateTime) {\\n                _anticipateEarnings(timeAmount);\\n            } else {\\n                remainingTime[msg.sender] += timeAmount;               \\n            }\\n            _payComission(comission);\\n        } catch {\\n            revert(\\\"Problem when transferring TIME\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Public call for earning interest for Employer (if it has any to receive)\\n     **/\\n    function earn() public nonReentrant {\\n        _earnInterestAndAllocate(ITimeToken(TIME_TOKEN_ADDRESS));\\n    }\\n\\n    /**\\n     * @dev Enable an investor to anticipate yields using TIME tokens\\n     **/\\n    function enableAnticipation() public payable nonReentrant update(false) {\\n        require(!anticipationEnabled[msg.sender], \\\"Address is already enabled for TIME anticipation\\\");\\n        uint256 fee = ITimeToken(TIME_TOKEN_ADDRESS).fee() * 10;\\n        require(msg.value >= fee, \\\"Please provide the enough fee amount to enable TIME anticipation\\\");\\n        uint256 comission = fee / 5;\\n        _payComission(comission);\\n        totalEarnedNative += msg.value;\\n        availableNative += (msg.value - comission);\\n        anticipationEnabled[msg.sender] = true;\\n    }\\n\\n    /**\\n     * @dev Inform the current Return Of Investment the Employer contract is giving\\n     * @return roi The current amount returned to investors\\n     **/\\n    function getCurrentROI() public view returns (uint256) {\\n        if (availableNative == 0)\\n            return 0;\\n        if (currentDepositedNative == 0)\\n            return 10**50;\\n        return ((availableNative * FACTOR) / currentDepositedNative);\\n    }\\n\\n    /**\\n     * @dev Inform the current Return Of Investment per Block the Employer contract is giving\\n     * @return roi The current amount per block returned to investors\\n     **/\\n    function getCurrentROIPerBlock() public view returns (uint256) {\\n        return ((getCurrentROI() * FACTOR) / ONE_YEAR);\\n    }\\n\\n    /**\\n     * @dev Inform the historical Return Of Investment the Employer contract is giving\\n     * @return roi The historical amount returned to investors\\n     **/\\n    function getROI() public view returns (uint256) {\\n        if (totalEarnedNative == 0)\\n            return 0;\\n        if (totalDepositedNative == 0)\\n            return 10**50;\\n        return ((totalEarnedNative * FACTOR) / totalDepositedNative); \\n    }\\n\\n    /**\\n     * @dev Inform the historical Return Of Investment per Block the Employer contract is giving\\n     * @return roi The historical amount per block returned to investors\\n     **/\\n    function getROIPerBlock() public view returns (uint256) {\\n        return ((getROI() * FACTOR) / ONE_YEAR);\\n    }\\n\\n    /**\\n     * @dev Inform the earnings an investor can anticipate (without waiting for a given time) according to the informed TIME amount\\n     * @param depositant Address of the depositant account\\n     * @param anticipatedTime Amount of TIME informed by a depositant as anticipation\\n     * @return earnings Amount a depositant can anticipate\\n     **/\\n    function queryAnticipatedEarnings(address depositant, uint256 anticipatedTime) public view returns (uint256) {\\n        return ((availableNative * anticipatedTime * deposited[depositant]) / ((ONE_YEAR * currentDepositedNative) + 1));\\n    }\\n\\n    /**\\n     * @dev Inform the earnings an investor can currently receive\\n     * @param depositant Address of the depositant account\\n     * @return earnings Amount a depositant can receive\\n     **/\\n    function queryEarnings(address depositant) public view returns (uint256) {\\n        uint256 numberOfBlocks = (block.number - lastBlock[depositant]) * D;\\n        if (numberOfBlocks <= remainingTime[depositant]) {       \\n            return ((availableNative * numberOfBlocks * deposited[depositant]) / ((ONE_YEAR * currentDepositedNative) + 1));\\n        } else {\\n            return ((availableNative * remainingTime[depositant] * deposited[depositant]) / ((ONE_YEAR * currentDepositedNative) + 1));\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw earnings (only) of a depositant (msg.sender)\\n     * @notice All functions are in modifiers. It only checks if the depositant has earning something\\n     **/\\n    function withdrawEarnings() public nonReentrant update(false) {\\n        require(earned[msg.sender] > 0, \\\"Depositant does not have any earnings to withdraw\\\");\\n    }\\n\\n    /**\\n     * @dev Withdraw all deposited values of a depositant (msg.sender)\\n     **/\\n    function withdrawDeposit() public nonReentrant update(false) {\\n        _withdraw();\\n    }\\n\\n    /**\\n     * @dev Withdraw all deposited values of a depositant (msg.sender) without any check for earnings (emergency)\\n     **/\\n    function withdrawDepositEmergency() public nonReentrant {\\n        _withdraw();\\n    }\\n}\"\r\n    },\r\n    \"contracts/ITimeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITimeToken {\\n    function DEVELOPER_ADDRESS() external returns (address);\\n    function BASE_FEE() external returns (uint256);\\n    function COMISSION_RATE() external returns (uint256);\\n    function SHARE_RATE() external returns (uint256);\\n    function TIME_BASE_LIQUIDITY() external returns (uint256);\\n    function TIME_BASE_FEE() external returns (uint256);\\n    function TOLERANCE() external returns (uint256);\\n    function dividendPerToken() external returns (uint256);\\n    function firstBlock() external returns (uint256);\\n    function liquidityFactorNative() external returns (uint256);\\n    function liquidityFactorTime() external returns (uint256);\\n    function numberOfHolders() external returns (uint256);\\n    function numberOfMiners() external returns (uint256);\\n    function sharedBalance() external returns (uint256);\\n    function poolBalance() external returns (uint256);\\n    function totalMinted() external returns (uint256);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function burn(uint256 amount) external;\\n    function transfer(address to, uint256 amount) external returns (bool success);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success);\\n    function averageMiningRate() external view returns (uint256);\\n    function donateEth() external payable;\\n    function enableMining() external payable;\\n    function enableMiningWithTimeToken() external;\\n    function fee() external view returns (uint256);\\n    function feeInTime() external view returns (uint256);\\n    function mining() external;\\n    function saveTime() external payable returns (bool success);\\n    function spendTime(uint256 timeAmount) external returns (bool success);\\n    function swapPriceNative(uint256 amountNative) external view returns (uint256);\\n    function swapPriceTimeInverse(uint256 amountTime) external view returns (uint256);\\n    function accountShareBalance(address account) external view returns (uint256);\\n    function withdrawableShareBalance(address account) external view returns (uint256);\\n    function withdrawShare() external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"byzantium\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timeTokenAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"D\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEVELOPER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FIRST_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeAmount\",\"type\":\"uint256\"}],\"name\":\"anticipate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"anticipationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anticipationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mustAnticipateTime\",\"type\":\"bool\"}],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDepositedNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mustAnticipateTime\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAnticipation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentROIPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getROIPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"anticipatedTime\",\"type\":\"uint256\"}],\"name\":\"queryAnticipatedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositant\",\"type\":\"address\"}],\"name\":\"queryEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"remainingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAnticipatedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositedNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEarnedNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTimeSaved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDepositEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Employer", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "0000000000000000000000000f8f39b92776d9136408280c7209bebe4351123b", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}