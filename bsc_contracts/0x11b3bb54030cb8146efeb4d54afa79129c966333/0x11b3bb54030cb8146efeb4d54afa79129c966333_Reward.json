{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Reward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.16;\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor() {}\\r\\n\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external;\\r\\n\\r\\n    function mint(address account, uint amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function burn(uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract's constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256('')`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            codehash := extcodehash(account)\\r\\n        }\\r\\n        return (codehash != 0x0 && codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * Available since v2.4.0.\\r\\n     */\\r\\n    function toPayable(\\r\\n        address account\\r\\n    ) internal pure returns (address payable) {\\r\\n        return payable(address(uint160(account)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * Available since v2.4.0.\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        // (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contractsStrings.sol\\r\\n\\r\\nlibrary Strings {\\r\\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b,\\r\\n        string memory _c,\\r\\n        string memory _d,\\r\\n        string memory _e\\r\\n    ) internal pure returns (string memory) {\\r\\n        bytes memory _ba = bytes(_a);\\r\\n        bytes memory _bb = bytes(_b);\\r\\n        bytes memory _bc = bytes(_c);\\r\\n        bytes memory _bd = bytes(_d);\\r\\n        bytes memory _be = bytes(_e);\\r\\n        string memory abcde = new string(\\r\\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\\r\\n        );\\r\\n        bytes memory babcde = bytes(abcde);\\r\\n        uint k = 0;\\r\\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\\r\\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\\r\\n        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\\r\\n        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\\r\\n        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\\r\\n        return string(babcde);\\r\\n    }\\r\\n\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b,\\r\\n        string memory _c,\\r\\n        string memory _d\\r\\n    ) internal pure returns (string memory) {\\r\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b,\\r\\n        string memory _c\\r\\n    ) internal pure returns (string memory) {\\r\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b\\r\\n    ) internal pure returns (string memory) {\\r\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Index Of\\r\\n     *\\r\\n     * Locates and returns the position of a character within a string\\r\\n     *\\r\\n     * @param _base When being used for a data type this is the extended object\\r\\n     *              otherwise this is the string acting as the haystack to be\\r\\n     *              searched\\r\\n     * @param _value The needle to search for, at present this is currently\\r\\n     *               limited to one character\\r\\n     * @return int The position of the needle starting from 0 and returning -1\\r\\n     *             in the case of no matches found\\r\\n     */\\r\\n    function indexOf(\\r\\n        string memory _base,\\r\\n        string memory _value\\r\\n    ) internal pure returns (int) {\\r\\n        return _indexOf(_base, _value, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Index Of\\r\\n     *\\r\\n     * Locates and returns the position of a character within a string starting\\r\\n     * from a defined offset\\r\\n     *\\r\\n     * @param _base When being used for a data type this is the extended object\\r\\n     *              otherwise this is the string acting as the haystack to be\\r\\n     *              searched\\r\\n     * @param _value The needle to search for, at present this is currently\\r\\n     *               limited to one character\\r\\n     * @param _offset The starting point to start searching from which can start\\r\\n     *                from 0, but must not exceed the length of the string\\r\\n     * @return int The position of the needle starting from 0 and returning -1\\r\\n     *             in the case of no matches found\\r\\n     */\\r\\n    function _indexOf(\\r\\n        string memory _base,\\r\\n        string memory _value,\\r\\n        uint _offset\\r\\n    ) internal pure returns (int) {\\r\\n        bytes memory _baseBytes = bytes(_base);\\r\\n        bytes memory _valueBytes = bytes(_value);\\r\\n\\r\\n        assert(_valueBytes.length == 1);\\r\\n\\r\\n        for (uint i = _offset; i < _baseBytes.length; i++) {\\r\\n            if (_baseBytes[i] == _valueBytes[0]) {\\r\\n                return int(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return -1;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter {\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] memory path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\ncontract Reward is Ownable {\\r\\n    using Address for address;\\r\\n\\r\\n    bool public Pause = false;\\r\\n    bool public EnableTimeLimit = false;\\r\\n    mapping(string => bool) public SwapKey;\\r\\n\\r\\n    address private signerAddress = 0x1421833E2476C555bD47Bfa6b1264235d313E9a0;\\r\\n    IPancakeRouter public pancakeRouter =\\r\\n    IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n    IERC20 public eBTT = IERC20(0xDCF47F2EE0ba516911B8335D45c2AC3E89130957);\\r\\n    IERC20 public USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\\r\\n\\r\\n    address public coldWallet1 = 0x023aeC2438e61DAee34b6B0FFdC724FC89323626;\\r\\n    address public coldWallet2 = 0x8d01b7a8F554d7242BA16331451094b244F36A95;\\r\\n\\r\\n    uint public timeLimit = 5 minutes;\\r\\n    uint public claimMaxEBTT = 100000 * 10 ** 18;\\r\\n    uint public claimMaxUSDT = 100000 * 10 ** 18;\\r\\n    uint public claimedUSDT = 0;\\r\\n    uint public claimedEBTT = 0;\\r\\n\\r\\n    uint public burnTax = 3;\\r\\n    uint public tax1 = 5;\\r\\n    uint public tax2 = 2;\\r\\n    uint public denominator = 100;\\r\\n\\r\\n    event UserInvest(string _rawdata);\\r\\n    event UserClaimHashUSDT(string _rawdata);\\r\\n    event UserClaimHashEBTT(string _rawdata);\\r\\n    event UserMiningHash(string _rawdata, uint _receiveAmount);\\r\\n    event UserLottery(string _rawdata);\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function InvestHash(\\r\\n        bytes calldata _sig,\\r\\n        uint _timestamp,\\r\\n        uint _receiveAmount,\\r\\n        string memory _userid\\r\\n    ) external {\\r\\n        require(Pause == false, \\\"Paused\\\");\\r\\n        if (EnableTimeLimit) {\\r\\n            require(\\r\\n                block.timestamp < _timestamp + timeLimit,\\r\\n                \\\"Signature Expired\\\"\\r\\n            );\\r\\n        }\\r\\n        string memory data = _uint2str(_timestamp);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(_receiveAmount));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _userid);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"0x\\\");\\r\\n        data = Strings.strConcat(data, addressToString(msg.sender));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(block.chainid));\\r\\n        require(isValidData(data, _sig), \\\"Invalid Signature\\\");\\r\\n\\r\\n        require(SwapKey[data] == false, \\\"Key Already Claimed\\\");\\r\\n        SwapKey[data] = true;\\r\\n\\r\\n        USDT.transferFrom(msg.sender, address(this), _receiveAmount);\\r\\n\\r\\n        emit UserInvest(data);\\r\\n    }\\r\\n\\r\\n    function MiningHash(\\r\\n        bytes calldata _sig,\\r\\n        uint _timestamp,\\r\\n        uint _amount,\\r\\n        string memory _investmentid\\r\\n    ) external {\\r\\n        require(Pause == false, \\\"Paused\\\");\\r\\n        if (EnableTimeLimit) {\\r\\n            require(\\r\\n                block.timestamp < _timestamp + timeLimit,\\r\\n                \\\"Signature Expired\\\"\\r\\n            );\\r\\n        }\\r\\n        string memory data = _uint2str(_timestamp);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(_amount));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _investmentid);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"0x\\\");\\r\\n        data = Strings.strConcat(data, addressToString(msg.sender));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(block.chainid));\\r\\n        require(isValidData(data, _sig), \\\"Invalid Signature\\\");\\r\\n\\r\\n        require(SwapKey[data] == false, \\\"Key Already Claimed\\\");\\r\\n        SwapKey[data] = true;\\r\\n\\r\\n        uint receiveAmount = getPriceUSDT2EBTT(_amount);\\r\\n\\r\\n        require(eBTT.balanceOf(msg.sender) >= receiveAmount, \\\"Insufficient eBTT to transfer to Reward Pool\\\");\\r\\n\\r\\n        eBTT.transferFrom(msg.sender, address(this), receiveAmount);\\r\\n\\r\\n        emit UserMiningHash(data, receiveAmount);\\r\\n    }\\r\\n\\r\\n    function ClaimHashUSDT(\\r\\n        bytes calldata _sig,\\r\\n        uint _timestamp,\\r\\n        uint _amount,\\r\\n        string memory _userid\\r\\n    ) external {\\r\\n        require(Pause == false, \\\"Paused\\\");\\r\\n        require(\\r\\n            claimMaxUSDT > claimedUSDT + _amount,\\r\\n            \\\"Exceeded Claim USDT Limit\\\"\\r\\n        );\\r\\n        if (EnableTimeLimit) {\\r\\n            require(\\r\\n                block.timestamp < _timestamp + timeLimit,\\r\\n                \\\"Signature Expired\\\"\\r\\n            );\\r\\n        }\\r\\n        string memory data = _uint2str(_timestamp);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(_amount));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _userid);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"0x\\\");\\r\\n        data = Strings.strConcat(data, addressToString(msg.sender));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(block.chainid));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"USDT\\\");\\r\\n\\r\\n        require(isValidData(data, _sig), \\\"Invalid Signature\\\");\\r\\n        require(SwapKey[data] == false, \\\"Key Already Claimed\\\");\\r\\n\\r\\n        claimedUSDT += _amount;\\r\\n\\r\\n        SwapKey[data] = true;\\r\\n\\r\\n        (\\r\\n            uint burnAmount,\\r\\n            uint amount1,\\r\\n            uint amount2,\\r\\n            uint userAmount\\r\\n        ) = calculateDistribution(_amount);\\r\\n\\r\\n        uint balance = eBTT.balanceOf(address(this));\\r\\n        SwapEBTTInternal(burnAmount);\\r\\n        uint ebttBurnAmount = eBTT.balanceOf(address(this)) - balance;\\r\\n\\r\\n        bool status = eBTT.burn(ebttBurnAmount);\\r\\n        require(status == true, \\\"Burn failed\\\");\\r\\n        USDT.transfer(coldWallet1, amount1);\\r\\n        USDT.transfer(coldWallet2, amount2);\\r\\n        USDT.transfer(msg.sender, userAmount);\\r\\n\\r\\n        emit UserClaimHashUSDT(data);\\r\\n    }\\r\\n\\r\\n    function ClaimHashEBTT(\\r\\n        bytes calldata _sig,\\r\\n        uint _timestamp,\\r\\n        uint _amount,\\r\\n        string memory _userid\\r\\n    ) external {\\r\\n        require(Pause == false, \\\"Paused\\\");\\r\\n        require(\\r\\n            claimMaxEBTT > claimedEBTT + _amount,\\r\\n            \\\"Exceeded Claim EBTT Limit\\\"\\r\\n        );\\r\\n        if (EnableTimeLimit) {\\r\\n            require(\\r\\n                block.timestamp < _timestamp + timeLimit,\\r\\n                \\\"Signature Expired\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        claimedEBTT += _amount;\\r\\n\\r\\n        string memory data = _uint2str(_timestamp);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(_amount));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _userid);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"0x\\\");\\r\\n        data = Strings.strConcat(data, addressToString(msg.sender));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(block.chainid));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"EBTT\\\");\\r\\n        require(isValidData(data, _sig), \\\"Invalid Signature\\\");\\r\\n\\r\\n        require(SwapKey[data] == false, \\\"Key Already Claimed\\\");\\r\\n        SwapKey[data] = true;\\r\\n\\r\\n        require(eBTT.balanceOf(address(this)) >= _amount, \\\"Insufficient eBTT in Reward Pool\\\");\\r\\n\\r\\n        (\\r\\n            uint burnAmount,\\r\\n            uint amount1,\\r\\n            uint amount2,\\r\\n            uint userAmount\\r\\n        ) = calculateDistribution(_amount);\\r\\n\\r\\n        eBTT.burn(burnAmount);\\r\\n        eBTT.transfer(coldWallet1, amount1);\\r\\n        eBTT.transfer(coldWallet2, amount2);\\r\\n        eBTT.transfer(msg.sender, userAmount);\\r\\n\\r\\n        emit UserClaimHashEBTT(data);\\r\\n    }\\r\\n\\r\\n    function calculateDistribution(\\r\\n        uint _amount\\r\\n    ) public view returns (uint, uint, uint, uint) {\\r\\n        uint burnAmount = (_amount * burnTax) / denominator;\\r\\n        uint coldWallet1Amount = (_amount * tax1) / denominator;\\r\\n        uint coldWallet2Amount = (_amount * tax2) / denominator;\\r\\n        uint userAmount = _amount -\\r\\n            burnAmount -\\r\\n            coldWallet1Amount -\\r\\n            coldWallet2Amount;\\r\\n\\r\\n        return (burnAmount, coldWallet1Amount, coldWallet2Amount, userAmount);\\r\\n    }\\r\\n\\r\\n    function getPriceUSDT2EBTT(uint amountIn) public view returns (uint) {\\r\\n        require(\\r\\n            msg.sender == tx.origin,\\r\\n            \\\"Only externally owned accounts (EOAs) are allowed to call this function.\\\"\\r\\n        );\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(USDT);\\r\\n        path[1] = address(eBTT);\\r\\n\\r\\n        uint[] memory amountOutMins = pancakeRouter.getAmountsOut(\\r\\n            amountIn,\\r\\n            path\\r\\n        );\\r\\n\\r\\n        return amountOutMins[1];\\r\\n    }\\r\\n\\r\\n    function getPriceEBTT2USDT(uint amountIn) public view returns (uint) {\\r\\n        require(\\r\\n            msg.sender == tx.origin,\\r\\n            \\\"Only externally owned accounts (EOAs) are allowed to call this function.\\\"\\r\\n        );\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(eBTT);\\r\\n        path[1] = address(USDT);\\r\\n\\r\\n        uint[] memory amountOutMins = pancakeRouter.getAmountsOut(\\r\\n            amountIn,\\r\\n            path\\r\\n        );\\r\\n\\r\\n        return amountOutMins[1];\\r\\n    }\\r\\n\\r\\n    function lottery(\\r\\n        bytes calldata _sig,\\r\\n        uint _timestamp,\\r\\n        uint _amount,\\r\\n        string memory _userid\\r\\n    ) external {\\r\\n        require(Pause == false, \\\"Paused\\\");\\r\\n        if (EnableTimeLimit) {\\r\\n            require(\\r\\n                block.timestamp < _timestamp + timeLimit,\\r\\n                \\\"Signature Expired\\\"\\r\\n            );\\r\\n        }\\r\\n        string memory data = _uint2str(_timestamp);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(_amount));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _userid);\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, \\\"0x\\\");\\r\\n        data = Strings.strConcat(data, addressToString(msg.sender));\\r\\n        data = Strings.strConcat(data, \\\"_\\\");\\r\\n        data = Strings.strConcat(data, _uint2str(block.chainid));\\r\\n        require(isValidData(data, _sig), \\\"Invalid Signature\\\");\\r\\n\\r\\n        require(SwapKey[data] == false, \\\"Key Already Claimed\\\");\\r\\n        SwapKey[data] = true;\\r\\n\\r\\n        USDT.transferFrom(msg.sender, address(this), _amount);\\r\\n\\r\\n        emit UserLottery(data);\\r\\n    }\\r\\n\\r\\n    function SwapEBTTInternal(uint _amount) internal {\\r\\n        if (_amount != 0) {\\r\\n            USDT.approve(address(pancakeRouter), _amount);\\r\\n\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = address(USDT);\\r\\n            path[1] = address(eBTT);\\r\\n\\r\\n            IERC20(eBTT).approve(address(pancakeRouter), _amount);\\r\\n\\r\\n            uint[] memory amountOut = pancakeRouter.swapExactTokensForTokens(\\r\\n                _amount,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp + 1200\\r\\n            );\\r\\n\\r\\n            require(amountOut[1] > 0, \\\"No amount returned.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function SwapEBTT(uint _amount) external onlyOwner {\\r\\n        USDT.transferFrom(msg.sender, address(this), _amount);\\r\\n        USDT.approve(address(pancakeRouter), _amount);\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(USDT);\\r\\n        path[1] = address(eBTT);\\r\\n\\r\\n        IERC20(eBTT).approve(address(pancakeRouter), _amount);\\r\\n\\r\\n        uint[] memory amountOut = pancakeRouter.swapExactTokensForTokens(\\r\\n            _amount,\\r\\n            0,\\r\\n            path,\\r\\n            msg.sender,\\r\\n            block.timestamp + 1200\\r\\n        );\\r\\n        require(amountOut[1] > 0, \\\"No amount returned.\\\");\\r\\n    }\\r\\n\\r\\n    function SetEnableTimeLimit(bool _enable) external onlyOwner {\\r\\n        EnableTimeLimit = _enable;\\r\\n    }\\r\\n\\r\\n    function setTimeLimit(uint _newTimeLimit) external onlyOwner {\\r\\n        timeLimit = _newTimeLimit;\\r\\n    }\\r\\n\\r\\n    function SetToken(address _ebbt, address _usdt) external onlyOwner {\\r\\n        eBTT = IERC20(_ebbt);\\r\\n        USDT = IERC20(_usdt);\\r\\n    }\\r\\n\\r\\n    function SetSigner(address _address) external onlyOwner {\\r\\n        signerAddress = _address;\\r\\n    }\\r\\n\\r\\n    function SetPlatform(address _cold1, address _cold2) external onlyOwner {\\r\\n        coldWallet1 = _cold1;\\r\\n        coldWallet2 = _cold2;\\r\\n    }\\r\\n\\r\\n    function SetUSDTMaxClaim(uint _amount) external onlyOwner {\\r\\n        claimMaxUSDT = _amount;\\r\\n    }\\r\\n\\r\\n    function SetEBTTMaxClaim(uint _amount) external onlyOwner {\\r\\n        claimMaxEBTT = _amount;\\r\\n    }\\r\\n\\r\\n    function SetTax(uint _burnTax, uint _tax1, uint _tax2, uint _denominator) public onlyOwner {\\r\\n        burnTax = _burnTax;\\r\\n        tax1 = _tax1;\\r\\n        tax2 = _tax2;\\r\\n        denominator = _denominator;\\r\\n    }\\r\\n\\r\\n    function SetPause(bool _status) external onlyOwner {\\r\\n        Pause = _status;\\r\\n    }\\r\\n\\r\\n    function toBytes(address a) public pure returns (bytes memory b) {\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n            mstore(\\r\\n                add(m, 20),\\r\\n                xor(0x140000000000000000000000000000000000000000, a)\\r\\n            )\\r\\n            mstore(0x40, add(m, 52))\\r\\n            b := m\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addressToString(address x) public pure returns (string memory) {\\r\\n        bytes memory s = new bytes(40);\\r\\n        for (uint i = 0; i < 20; i++) {\\r\\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\r\\n            bytes1 hi = bytes1(uint8(b) / 16);\\r\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\r\\n            s[2 * i] = char(hi);\\r\\n            s[2 * i + 1] = char(lo);\\r\\n        }\\r\\n        return string(s);\\r\\n    }\\r\\n\\r\\n    function char(bytes1 b) internal pure returns (bytes1 c) {\\r\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\r\\n        else return bytes1(uint8(b) + 0x57);\\r\\n    }\\r\\n\\r\\n    function bytes32ToString(\\r\\n        bytes32 _bytes32\\r\\n    ) public pure returns (string memory) {\\r\\n        uint8 i = 0;\\r\\n        bytes memory bytesArray = new bytes(64);\\r\\n        for (i = 0; i < bytesArray.length; i++) {\\r\\n            uint8 _f = uint8(_bytes32[i / 2] & 0x0f);\\r\\n            uint8 _l = uint8(_bytes32[i / 2] >> 4);\\r\\n\\r\\n            bytesArray[i] = toByte(_f);\\r\\n            i = i + 1;\\r\\n            bytesArray[i] = toByte(_l);\\r\\n        }\\r\\n        return string(bytesArray);\\r\\n    }\\r\\n\\r\\n    function stringToBytes32(\\r\\n        string memory source\\r\\n    ) public pure returns (bytes32 result) {\\r\\n        bytes memory tempEmptyStringTest = bytes(source);\\r\\n        if (tempEmptyStringTest.length == 0) {\\r\\n            return 0x0;\\r\\n        }\\r\\n\\r\\n        assembly {\\r\\n            result := mload(add(source, 32))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function splitSignature(\\r\\n        bytes memory sig\\r\\n    ) public pure returns (uint8, bytes32, bytes32) {\\r\\n        require(sig.length == 65);\\r\\n\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        assembly {\\r\\n            // first 32 bytes, after the length prefix\\r\\n            r := mload(add(sig, 32))\\r\\n            // second 32 bytes\\r\\n            s := mload(add(sig, 64))\\r\\n            // final byte (first byte of the next 32 bytes)\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n        }\\r\\n\\r\\n        return (v, r, s);\\r\\n    }\\r\\n\\r\\n    function recoverSigner(\\r\\n        bytes32 message,\\r\\n        bytes memory sig\\r\\n    ) public pure returns (address) {\\r\\n        uint8 v;\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n\\r\\n        (v, r, s) = splitSignature(sig);\\r\\n        return ecrecover(message, v, r, s);\\r\\n    }\\r\\n\\r\\n    function isValidData(\\r\\n        string memory _word,\\r\\n        bytes memory sig\\r\\n    ) public view returns (bool) {\\r\\n        bytes32 message = keccak256(abi.encodePacked(_word));\\r\\n        return (recoverSigner(message, sig) == signerAddress);\\r\\n    }\\r\\n\\r\\n    function toByte(uint8 _uint8) public pure returns (bytes1) {\\r\\n        if (_uint8 < 10) {\\r\\n            return bytes1(_uint8 + 48);\\r\\n        } else {\\r\\n            return bytes1(_uint8 + 87);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /***********************************|\\r\\n  |    Utility Internal Functions     |\\r\\n  |__________________________________*/\\r\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    function _uint2str(uint256 value) public pure returns (string memory) {\\r\\n        uint256 length = Math.log10(value) + 1;\\r\\n        string memory buffer = new string(length);\\r\\n        uint256 ptr;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            ptr := add(buffer, add(32, length))\\r\\n        }\\r\\n        while (true) {\\r\\n            ptr--;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\r\\n            }\\r\\n            value /= 10;\\r\\n            if (value == 0) break;\\r\\n        }\\r\\n        return buffer;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_rawdata\",\"type\":\"string\"}],\"name\":\"UserClaimHashEBTT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_rawdata\",\"type\":\"string\"}],\"name\":\"UserClaimHashUSDT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_rawdata\",\"type\":\"string\"}],\"name\":\"UserInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_rawdata\",\"type\":\"string\"}],\"name\":\"UserLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_rawdata\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_receiveAmount\",\"type\":\"uint256\"}],\"name\":\"UserMiningHash\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_userid\",\"type\":\"string\"}],\"name\":\"ClaimHashEBTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_userid\",\"type\":\"string\"}],\"name\":\"ClaimHashUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EnableTimeLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_receiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_userid\",\"type\":\"string\"}],\"name\":\"InvestHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_investmentid\",\"type\":\"string\"}],\"name\":\"MiningHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SetEBTTMaxClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"SetEnableTimeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cold1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cold2\",\"type\":\"address\"}],\"name\":\"SetPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SetSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burnTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tax1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tax2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"SetTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ebbt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"}],\"name\":\"SetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SetUSDTMaxClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SwapEBTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"SwapKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_uint2str\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimMaxEBTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimMaxUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedEBTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coldWallet1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coldWallet2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eBTT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getPriceEBTT2USDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getPriceUSDT2EBTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_word\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"isValidData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_userid\",\"type\":\"string\"}],\"name\":\"lottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTimeLimit\",\"type\":\"uint256\"}],\"name\":\"setTimeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_uint8\",\"type\":\"uint8\"}],\"name\":\"toByte\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"toBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"b\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Reward", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}