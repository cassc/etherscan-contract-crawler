{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/pool/Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.15;\\n\\nimport {OwnableUpgradeable} from \\\"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"openzeppelin-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"openzeppelin/interfaces/IERC20Metadata.sol\\\";\\nimport {IERC20} from \\\"openzeppelin/interfaces/IERC20.sol\\\";\\nimport {Initializable} from \\\"openzeppelin-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {SignedIntOps} from \\\"../lib/SignedInt.sol\\\";\\nimport {MathUtils} from \\\"../lib/MathUtils.sol\\\";\\nimport {PositionUtils} from \\\"../lib/PositionUtils.sol\\\";\\nimport {ILevelOracle} from \\\"../interfaces/ILevelOracle.sol\\\";\\nimport {ILPToken} from \\\"../interfaces/ILPToken.sol\\\";\\nimport {IPool, Side, TokenWeight} from \\\"../interfaces/IPool.sol\\\";\\nimport {\\n    PoolStorage,\\n    Position,\\n    PoolTokenInfo,\\n    Fee,\\n    AssetInfo,\\n    PRECISION,\\n    LP_INITIAL_PRICE,\\n    MAX_BASE_SWAP_FEE,\\n    MAX_TAX_BASIS_POINT,\\n    MAX_POSITION_FEE,\\n    MAX_LIQUIDATION_FEE,\\n    MAX_INTEREST_RATE,\\n    MAX_ASSETS,\\n    MAX_MAINTENANCE_MARGIN\\n} from \\\"./PoolStorage.sol\\\";\\nimport {PoolErrors} from \\\"./PoolErrors.sol\\\";\\nimport {IPoolHook} from \\\"../interfaces/IPoolHook.sol\\\";\\nimport {SafeCast} from \\\"../lib/SafeCast.sol\\\";\\n\\nuint256 constant USD_VALUE_DECIMAL = 30;\\nuint256 constant MIN_SWAP_FEE = 10000000; // 0.1%\\n\\nstruct IncreasePositionVars {\\n    uint256 reserveAdded;\\n    uint256 collateralAmount;\\n    uint256 collateralValueAdded;\\n    uint256 feeValue;\\n    uint256 daoFee;\\n    uint256 indexPrice;\\n    uint256 sizeChanged;\\n    uint256 feeAmount;\\n    uint256 totalLpFee;\\n}\\n\\n/// @notice common variable used accross decrease process\\nstruct DecreasePositionVars {\\n    /// @notice santinized input: collateral value able to be withdraw\\n    uint256 collateralReduced;\\n    /// @notice santinized input: position size to decrease, capped to position's size\\n    uint256 sizeChanged;\\n    /// @notice current price of index\\n    uint256 indexPrice;\\n    /// @notice current price of collateral\\n    uint256 collateralPrice;\\n    /// @notice postion's remaining collateral value in USD after decrease position\\n    uint256 remainingCollateral;\\n    /// @notice reserve reduced due to reducion process\\n    uint256 reserveReduced;\\n    /// @notice total value of fee to be collect (include dao fee and LP fee)\\n    uint256 feeValue;\\n    /// @notice amount of collateral taken as fee\\n    uint256 daoFee;\\n    /// @notice real transfer out amount to user\\n    uint256 payout;\\n    /// @notice 'net' PnL (fee not counted)\\n    int256 pnl;\\n    int256 poolAmountReduced;\\n    uint256 totalLpFee;\\n}\\n\\n/// @dev the only sender can add liquidity to closed tranche\\naddress constant WHITELISTED_LIQUIDITY_PROVIDER = 0x6442b001c5AcCE8cb71986ad65B22684821A927A;\\n/// @dev the choosen tranche which remain\\naddress constant TARGET_TRANCHE = 0xB5C42F84Ab3f786bCA9761240546AA9cEC1f8821;\\n\\ncontract Pool is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, PoolStorage, IPool {\\n    using SignedIntOps for int256;\\n    using SafeERC20 for IERC20;\\n    using SafeCast for uint256;\\n    using SafeCast for int256;\\n\\n    /* =========== MODIFIERS ========== */\\n    modifier onlyOrderManager() {\\n        _requireOrderManager();\\n        _;\\n    }\\n\\n    modifier onlyAsset(address _token) {\\n        _validateAsset(_token);\\n        _;\\n    }\\n\\n    modifier onlyListedToken(address _token) {\\n        _requireListedToken(_token);\\n        _;\\n    }\\n\\n    modifier onlyController() {\\n        _onlyController();\\n        _;\\n    }\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /* ======== INITIALIZERS ========= */\\n    // function initialize(\\n    //     uint256 _maxLeverage,\\n    //     uint256 _positionFee,\\n    //     uint256 _liquidationFee,\\n    //     uint256 _interestRate,\\n    //     uint256 _accrualInterval,\\n    //     uint256 _maintainanceMargin\\n    // ) external initializer {\\n    //     __Ownable_init();\\n    //     __ReentrancyGuard_init();\\n    //     _setMaxLeverage(_maxLeverage);\\n    //     _setPositionFee(_positionFee, _liquidationFee);\\n    //     _setInterestRate(_interestRate, _accrualInterval);\\n    //     _setMaintenanceMargin(_maintainanceMargin);\\n    //     fee.daoFee = PRECISION;\\n    // }\\n\\n    // ========= View functions =========\\n\\n    function validateToken(address _indexToken, address _collateralToken, Side _side, bool _isIncrease)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return _validateToken(_indexToken, _collateralToken, _side, _isIncrease);\\n    }\\n\\n    function getPoolAsset(address _token) external view returns (AssetInfo memory) {\\n        return _getPoolAsset(_token);\\n    }\\n\\n    function getAllTranchesLength() external view returns (uint256) {\\n        return allTranches.length;\\n    }\\n\\n    function getPoolValue(bool _max) external view returns (uint256) {\\n        return _getPoolValue(_max);\\n    }\\n\\n    function getTrancheValue(address _tranche, bool _max) external view returns (uint256 sum) {\\n        return _getTrancheValue(_tranche, _max);\\n    }\\n\\n    function calcSwapOutput(address _tokenIn, address _tokenOut, uint256 _amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut, uint256 feeAmount)\\n    {\\n        return _calcSwapOutput(_tokenIn, _tokenOut, _amountIn);\\n    }\\n\\n    function calcRemoveLiquidity(address _tranche, address _tokenOut, uint256 _lpAmount)\\n        external\\n        view\\n        returns (uint256 outAmount, uint256 outAmountAfterFee, uint256 feeAmount)\\n    {\\n        (outAmount, outAmountAfterFee, feeAmount,) = _calcRemoveLiquidity(_tranche, _tokenOut, _lpAmount);\\n    }\\n\\n    // ============= Mutative functions =============\\n\\n    function addLiquidity(address _tranche, address _token, uint256 _amountIn, uint256 _minLpAmount, address _to)\\n        external\\n        nonReentrant\\n        onlyListedToken(_token)\\n    {\\n        _validateTranche(_tranche);\\n        _accrueInterest(_token);\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amountIn);\\n        _amountIn = _requireAmount(_getAmountIn(_token));\\n\\n        (uint256 amountInAfterDaoFee, uint256 daoFee, uint256 lpAmount) = _calcAddLiquidity(_tranche, _token, _amountIn);\\n        if (lpAmount < _minLpAmount) {\\n            revert PoolErrors.SlippageExceeded();\\n        }\\n\\n        poolTokens[_token].feeReserve += daoFee;\\n        trancheAssets[_tranche][_token].poolAmount += amountInAfterDaoFee;\\n        _validateMaxLiquidity(_token);\\n        refreshVirtualPoolValue();\\n\\n        ILPToken(_tranche).mint(_to, lpAmount);\\n        emit LiquidityAdded(_tranche, msg.sender, _token, _amountIn, lpAmount, daoFee);\\n    }\\n\\n    function removeLiquidity(address _tranche, address _tokenOut, uint256 _lpAmount, uint256 _minOut, address _to)\\n        external\\n        nonReentrant\\n        onlyAsset(_tokenOut)\\n    {\\n        _validateTranche(_tranche);\\n        _accrueInterest(_tokenOut);\\n        _requireAmount(_lpAmount);\\n        ILPToken lpToken = ILPToken(_tranche);\\n\\n        (, uint256 outAmountAfterFee, uint256 daoFee,) = _calcRemoveLiquidity(_tranche, _tokenOut, _lpAmount);\\n        if (outAmountAfterFee < _minOut) {\\n            revert PoolErrors.SlippageExceeded();\\n        }\\n\\n        poolTokens[_tokenOut].feeReserve += daoFee;\\n        _decreaseTranchePoolAmount(_tranche, _tokenOut, outAmountAfterFee + daoFee);\\n        refreshVirtualPoolValue();\\n\\n        lpToken.burnFrom(msg.sender, _lpAmount);\\n        _doTransferOut(_tokenOut, _to, outAmountAfterFee);\\n\\n        emit LiquidityRemoved(_tranche, msg.sender, _tokenOut, _lpAmount, outAmountAfterFee, daoFee);\\n    }\\n\\n    function migrateLP(address _fromTranche, uint256 _lpAmount, address _viaToken, uint256 _minOut, address _to)\\n        external\\n        nonReentrant\\n    {\\n        _validateTranche(_fromTranche);\\n        _accrueInterest(_viaToken);\\n        _requireAmount(_lpAmount);\\n\\n        uint256 viaTokenPrice = _getPrice(_viaToken, true);\\n        uint256 fromTrancheValue = _getTrancheValue(_fromTranche, true);\\n        uint256 targetTrancheValue = _getTrancheValue(TARGET_TRANCHE, true);\\n\\n        uint256 valueChange = (_lpAmount * fromTrancheValue) / ILPToken(_fromTranche).totalSupply();\\n        uint256 viaTokenOut = valueChange / viaTokenPrice;\\n        // skip zero check\\n        uint256 targetLpOut = valueChange * ILPToken(TARGET_TRANCHE).totalSupply() / targetTrancheValue;\\n\\n        if (targetLpOut < _minOut) revert PoolErrors.SlippageExceeded();\\n\\n        _decreaseTranchePoolAmount(_fromTranche, _viaToken, viaTokenOut);\\n        trancheAssets[TARGET_TRANCHE][_viaToken].poolAmount += viaTokenOut;\\n\\n        ILPToken(_fromTranche).burnFrom(msg.sender, _lpAmount);\\n        ILPToken(TARGET_TRANCHE).mint(_to, targetLpOut);\\n\\n        emit LiquidityRemoved(_fromTranche, msg.sender, _viaToken, _lpAmount, viaTokenOut, 0);\\n        emit LiquidityAdded(TARGET_TRANCHE, msg.sender, _viaToken, viaTokenOut, targetLpOut, 0);\\n    }\\n\\n    function swap(address _tokenIn, address _tokenOut, uint256 _minOut, address _to, bytes calldata extradata)\\n        external\\n        nonReentrant\\n        onlyListedToken(_tokenIn)\\n        onlyAsset(_tokenOut)\\n    {\\n        if (msg.sender != orderManager && !allowSwap[msg.sender]) {\\n            revert PoolErrors.SwapNotAllowed();\\n        }\\n        if (_tokenIn == _tokenOut) {\\n            revert PoolErrors.SameTokenSwap(_tokenIn);\\n        }\\n        _accrueInterest(_tokenIn);\\n        _accrueInterest(_tokenOut);\\n        uint256 amountIn = _requireAmount(_getAmountIn(_tokenIn));\\n        (uint256 amountOutAfterFee, uint256 swapFee) = _calcSwapOutput(_tokenIn, _tokenOut, amountIn);\\n        if (amountOutAfterFee < _minOut) {\\n            revert PoolErrors.SlippageExceeded();\\n        }\\n        {\\n            (uint256 daoFee, uint256 lpFee) = _calcDaoFee(swapFee);\\n            poolTokens[_tokenIn].feeReserve += daoFee;\\n            _rebalanceTranches(_tokenIn, amountIn - swapFee, _tokenOut, amountOutAfterFee, lpFee);\\n        }\\n        _validateMaxLiquidity(_tokenIn);\\n        _doTransferOut(_tokenOut, _to, amountOutAfterFee);\\n        emit Swap(msg.sender, _tokenIn, _tokenOut, amountIn, amountOutAfterFee, swapFee);\\n        if (address(poolHook) != address(0)) {\\n            poolHook.postSwap(_to, _tokenIn, _tokenOut, abi.encode(amountIn, amountOutAfterFee, swapFee, extradata));\\n        }\\n    }\\n\\n    function increasePosition(\\n        address _owner,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _sizeChanged,\\n        Side _side\\n    ) external onlyOrderManager {\\n        _requireValidTokenPair(_indexToken, _collateralToken, _side, true);\\n        IncreasePositionVars memory vars;\\n        vars.collateralAmount = _requireAmount(_getAmountIn(_collateralToken));\\n        uint256 collateralPrice = _getCollateralPrice(_collateralToken, true);\\n        vars.collateralValueAdded = collateralPrice * vars.collateralAmount;\\n        uint256 borrowIndex = _accrueInterest(_collateralToken);\\n        bytes32 key = _getPositionKey(_owner, _indexToken, _collateralToken, _side);\\n        Position memory position = positions[key];\\n\\n        if (position.size == 0) {\\n            positionOpenTimestamp[key] = block.timestamp;\\n        } else if (positionOpenTimestamp[key] == 0) {\\n            // disable increase old position due to trache collapsing\\n            revert(\\\"Increase position disabled\\\");\\n        }\\n\\n        vars.indexPrice = _getIndexPrice(_indexToken, _side, true);\\n        vars.sizeChanged = _sizeChanged;\\n\\n        // update position\\n        vars.feeValue = _calcPositionFee(position, vars.sizeChanged, borrowIndex);\\n        vars.feeValue = feeDiscount.tryDiscount(_owner, _calcPositionFee(position, vars.sizeChanged, borrowIndex));\\n        vars.feeAmount = vars.feeValue / collateralPrice;\\n        (vars.daoFee, vars.totalLpFee) = _calcDaoFee(vars.feeAmount);\\n        vars.reserveAdded = vars.sizeChanged / collateralPrice;\\n\\n        position.entryPrice = PositionUtils.calcAveragePrice(\\n            _side, position.size, position.size + vars.sizeChanged, position.entryPrice, vars.indexPrice, 0\\n        );\\n        position.collateralValue =\\n            MathUtils.zeroCapSub(position.collateralValue + vars.collateralValueAdded, vars.feeValue);\\n        position.size = position.size + vars.sizeChanged;\\n        position.borrowIndex = borrowIndex;\\n        position.reserveAmount += vars.reserveAdded;\\n\\n        if (vars.sizeChanged != 0 && (position.size > position.collateralValue * maxLeverage)) {\\n            revert PoolErrors.InvalidLeverage(position.size, position.collateralValue, maxLeverage);\\n        }\\n\\n        _validatePosition(position, _collateralToken, _side, vars.indexPrice);\\n\\n        // update pool assets\\n        _reservePoolAsset(key, vars, _indexToken, _collateralToken, _side);\\n        positions[key] = position;\\n\\n        emit IncreasePosition(\\n            key,\\n            _owner,\\n            _collateralToken,\\n            _indexToken,\\n            vars.collateralAmount,\\n            vars.sizeChanged,\\n            _side,\\n            vars.indexPrice,\\n            vars.feeValue\\n        );\\n\\n        emit UpdatePosition(\\n            key,\\n            position.size,\\n            position.collateralValue,\\n            position.entryPrice,\\n            position.borrowIndex,\\n            position.reserveAmount,\\n            vars.indexPrice\\n        );\\n\\n        if (address(poolHook) != address(0)) {\\n            poolHook.postIncreasePosition(\\n                _owner,\\n                _indexToken,\\n                _collateralToken,\\n                _side,\\n                abi.encode(_sizeChanged, vars.collateralValueAdded, vars.feeValue)\\n            );\\n        }\\n    }\\n\\n    function decreasePosition(\\n        address _owner,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _collateralChanged,\\n        uint256 _sizeChanged,\\n        Side _side,\\n        address _receiver\\n    ) external onlyOrderManager {\\n        _requireValidTokenPair(_indexToken, _collateralToken, _side, false);\\n        uint256 borrowIndex = _accrueInterest(_collateralToken);\\n        bytes32 key = _getPositionKey(_owner, _indexToken, _collateralToken, _side);\\n        Position memory position = positions[key];\\n\\n        if (position.size == 0) {\\n            revert PoolErrors.PositionNotExists(_owner, _indexToken, _collateralToken, _side);\\n        }\\n\\n        DecreasePositionVars memory vars =\\n            _calcDecreasePayout(position, _owner, _indexToken, _collateralToken, _side, _sizeChanged, _collateralChanged, false);\\n\\n        // reset to actual reduced value instead of user input\\n        vars.collateralReduced = position.collateralValue - vars.remainingCollateral;\\n        _releasePoolAsset(key, vars, _indexToken, _collateralToken, _side);\\n        position.size = position.size - vars.sizeChanged;\\n        position.borrowIndex = borrowIndex;\\n        position.reserveAmount = position.reserveAmount - vars.reserveReduced;\\n        position.collateralValue = vars.remainingCollateral;\\n\\n        _validatePosition(position, _collateralToken, _side, vars.indexPrice);\\n\\n        emit DecreasePosition(\\n            key,\\n            _owner,\\n            _collateralToken,\\n            _indexToken,\\n            vars.collateralReduced,\\n            vars.sizeChanged,\\n            _side,\\n            vars.indexPrice,\\n            vars.pnl.asTuple(),\\n            vars.feeValue\\n        );\\n        if (position.size == 0) {\\n            emit ClosePosition(\\n                key,\\n                position.size,\\n                position.collateralValue,\\n                position.entryPrice,\\n                position.borrowIndex,\\n                position.reserveAmount\\n            );\\n            // delete position when closed\\n            delete positions[key];\\n        } else {\\n            emit UpdatePosition(\\n                key,\\n                position.size,\\n                position.collateralValue,\\n                position.entryPrice,\\n                position.borrowIndex,\\n                position.reserveAmount,\\n                vars.indexPrice\\n            );\\n            positions[key] = position;\\n        }\\n        _doTransferOut(_collateralToken, _receiver, vars.payout);\\n\\n        if (address(poolHook) != address(0)) {\\n            poolHook.postDecreasePosition(\\n                _owner,\\n                _indexToken,\\n                _collateralToken,\\n                _side,\\n                abi.encode(vars.sizeChanged, vars.collateralReduced, vars.feeValue)\\n            );\\n        }\\n    }\\n\\n    function liquidatePosition(address _account, address _indexToken, address _collateralToken, Side _side) external {\\n        _requireValidTokenPair(_indexToken, _collateralToken, _side, false);\\n        uint256 borrowIndex = _accrueInterest(_collateralToken);\\n\\n        bytes32 key = _getPositionKey(_account, _indexToken, _collateralToken, _side);\\n        Position memory position = positions[key];\\n        uint256 markPrice = oracle.getReferencePrice(_indexToken);\\n        if (!_liquidatePositionAllowed(position, _side, markPrice, borrowIndex)) {\\n            revert PoolErrors.PositionNotLiquidated(key);\\n        }\\n\\n        DecreasePositionVars memory vars = _calcDecreasePayout(\\n            position, _account, _indexToken, _collateralToken, _side, position.size, position.collateralValue, true\\n        );\\n\\n        _releasePoolAsset(key, vars, _indexToken, _collateralToken, _side);\\n\\n        emit LiquidatePosition(\\n            key,\\n            _account,\\n            _collateralToken,\\n            _indexToken,\\n            _side,\\n            position.size,\\n            position.collateralValue - vars.remainingCollateral,\\n            position.reserveAmount,\\n            vars.indexPrice,\\n            vars.pnl.asTuple(),\\n            vars.feeValue\\n        );\\n\\n        delete positions[key];\\n        _doTransferOut(_collateralToken, _account, vars.payout);\\n        _doTransferOut(_collateralToken, msg.sender, fee.liquidationFee / vars.collateralPrice);\\n\\n        if (address(poolHook) != address(0)) {\\n            poolHook.postLiquidatePosition(\\n                _account,\\n                _indexToken,\\n                _collateralToken,\\n                _side,\\n                abi.encode(position.size, position.collateralValue, vars.feeValue)\\n            );\\n        }\\n    }\\n\\n    function refreshVirtualPoolValue() public {\\n        virtualPoolValue = (_getPoolValue(true) + _getPoolValue(false)) / 2;\\n    }\\n\\n    // ========= ADMIN FUNCTIONS ========\\n    struct RiskConfig {\\n        address tranche;\\n        uint256 riskFactor;\\n    }\\n\\n    function addToken(address _token, bool _isStableCoin) external onlyOwner {\\n        if (!isAsset[_token]) {\\n            isAsset[_token] = true;\\n            isListed[_token] = true;\\n            allAssets.push(_token);\\n            isStableCoin[_token] = _isStableCoin;\\n            if (allAssets.length > MAX_ASSETS) {\\n                revert PoolErrors.TooManyTokenAdded(allAssets.length, MAX_ASSETS);\\n            }\\n            emit TokenWhitelisted(_token);\\n            return;\\n        }\\n\\n        if (isListed[_token]) {\\n            revert PoolErrors.DuplicateToken(_token);\\n        }\\n\\n        // token is added but not listed\\n        isListed[_token] = true;\\n        emit TokenWhitelisted(_token);\\n    }\\n\\n    function setMaxLiquidity(address _asset, uint256 _value) external onlyController onlyAsset(_asset) {\\n        maxLiquidity[_asset] = _value;\\n        emit MaxLiquiditySet(_asset, _value);\\n    }\\n\\n    function withdrawFee(address _token, address _recipient) external onlyAsset(_token) {\\n        if (msg.sender != feeDistributor) {\\n            revert PoolErrors.FeeDistributorOnly();\\n        }\\n        uint256 amount = poolTokens[_token].feeReserve;\\n        poolTokens[_token].feeReserve = 0;\\n        _doTransferOut(_token, _recipient, amount);\\n        emit DaoFeeWithdrawn(_token, _recipient, amount);\\n    }\\n\\n    function setTargetWeight(TokenWeight[] memory tokens) external onlyController {\\n        uint256 nTokens = tokens.length;\\n        if (nTokens != allAssets.length) {\\n            revert PoolErrors.RequireAllTokens();\\n        }\\n        uint256 total;\\n        for (uint256 i = 0; i < nTokens; ++i) {\\n            TokenWeight memory item = tokens[i];\\n            assert(isAsset[item.token]);\\n            // unlisted token always has zero weight\\n            uint256 weight = isListed[item.token] ? item.weight : 0;\\n            targetWeights[item.token] = weight;\\n            total += weight;\\n        }\\n        totalWeight = total;\\n        emit TokenWeightSet(tokens);\\n    }\\n\\n    function setMaxGlobalPositionSize(address _token, uint256 _maxGlobalLongRatio, uint256 _maxGlobalShortSize)\\n        external\\n        onlyController\\n        onlyAsset(_token)\\n    {\\n        if (isStableCoin[_token]) {\\n            revert PoolErrors.NotApplicableForStableCoin();\\n        }\\n\\n        _validateMaxValue(_maxGlobalLongRatio, PRECISION);\\n        maxGlobalLongSizeRatios[_token] = _maxGlobalLongRatio;\\n        maxGlobalShortSizes[_token] = _maxGlobalShortSize;\\n        emit MaxGlobalPositionSizeSet(_token, _maxGlobalLongRatio, _maxGlobalShortSize);\\n    }\\n\\n    /// @notice move assets between tranches without breaking constrants. Called by controller in rebalance process\\n    /// to mitigate tranche LP exposure\\n    function rebalanceAsset(\\n        address _fromTranche,\\n        address _fromToken,\\n        uint256 _fromAmount,\\n        address _toTranche,\\n        address _toToken\\n    ) external onlyController {\\n        uint256 toAmount = MathUtils.frac(_fromAmount, _getPrice(_fromToken, true), _getPrice(_toToken, true));\\n        _decreaseTranchePoolAmount(_fromTranche, _fromToken, _fromAmount);\\n        _decreaseTranchePoolAmount(_toTranche, _toToken, toAmount);\\n        trancheAssets[_fromTranche][_toToken].poolAmount += toAmount;\\n        trancheAssets[_toTranche][_fromToken].poolAmount += _fromAmount;\\n        emit AssetRebalanced();\\n    }\\n\\n    // ======== internal functions =========\\n    function _setMaxLeverage(uint256 _maxLeverage) internal {\\n        if (_maxLeverage == 0) {\\n            revert PoolErrors.InvalidMaxLeverage();\\n        }\\n        maxLeverage = _maxLeverage;\\n        emit MaxLeverageChanged(_maxLeverage);\\n    }\\n\\n    function _setMaintenanceMargin(uint256 _ratio) internal {\\n        _validateMaxValue(_ratio, MAX_MAINTENANCE_MARGIN);\\n        maintenanceMargin = _ratio;\\n        emit MaintenanceMarginChanged(_ratio);\\n    }\\n\\n    function _setInterestRate(uint256 _interestRate, uint256 _accrualInterval) internal {\\n        if (_accrualInterval == 0) {\\n            revert PoolErrors.InvalidInterval();\\n        }\\n        _validateMaxValue(_interestRate, MAX_INTEREST_RATE);\\n        interestRate = _interestRate;\\n        accrualInterval = _accrualInterval;\\n        emit InterestRateSet(_interestRate, _accrualInterval);\\n    }\\n\\n    function _validateToken(address _indexToken, address _collateralToken, Side _side, bool _isIncrease)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (!isAsset[_indexToken] || !isAsset[_collateralToken] || isStableCoin[_indexToken]) {\\n            return false;\\n        }\\n\\n        if (_isIncrease && (!isListed[_indexToken] || !isListed[_collateralToken])) {\\n            return false;\\n        }\\n\\n        return _side == Side.LONG ? _indexToken == _collateralToken : isStableCoin[_collateralToken];\\n    }\\n\\n    function _calcAddLiquidity(address _tranche, address _token, uint256 _amountIn)\\n        internal\\n        view\\n        returns (uint256 amountInAfterDaoFee, uint256 daoFee, uint256 lpAmount)\\n    {\\n        if (\\n            (_tranche != TARGET_TRANCHE && msg.sender != WHITELISTED_LIQUIDITY_PROVIDER)\\n                || (!isStableCoin[_token] && riskFactor[_token][_tranche] == 0)\\n        ) {\\n            revert PoolErrors.AddLiquidityNotAllowed(_tranche, _token);\\n        }\\n        uint256 tokenPrice = _getPrice(_token, false);\\n        uint256 valueChange = _amountIn * tokenPrice;\\n\\n        uint256 _fee = _calcFeeRate(_token, tokenPrice, valueChange, addRemoveLiquidityFee, fee.taxBasisPoint, true);\\n        uint256 userAmount = MathUtils.frac(_amountIn, PRECISION - _fee, PRECISION);\\n        (daoFee,) = _calcDaoFee(_amountIn - userAmount);\\n        amountInAfterDaoFee = _amountIn - daoFee;\\n\\n        uint256 trancheValue = _getTrancheValue(_tranche, true);\\n        uint256 lpSupply = ILPToken(_tranche).totalSupply();\\n        if (lpSupply == 0 || trancheValue == 0) {\\n            lpAmount = MathUtils.frac(userAmount, tokenPrice, LP_INITIAL_PRICE);\\n        } else {\\n            lpAmount = userAmount * tokenPrice * lpSupply / trancheValue;\\n        }\\n    }\\n\\n    function _calcRemoveLiquidity(address _tranche, address _tokenOut, uint256 _lpAmount)\\n        internal\\n        view\\n        returns (uint256 outAmount, uint256 outAmountAfterFee, uint256 daoFee, uint256 tokenPrice)\\n    {\\n        tokenPrice = _getPrice(_tokenOut, true);\\n        uint256 trancheValue = _getTrancheValue(_tranche, false);\\n        uint256 valueChange = (_lpAmount * trancheValue) / ILPToken(_tranche).totalSupply();\\n        uint256 _fee = _calcFeeRate(_tokenOut, tokenPrice, valueChange, addRemoveLiquidityFee, fee.taxBasisPoint, false);\\n        outAmount = valueChange / tokenPrice;\\n        outAmountAfterFee = MathUtils.frac(outAmount, PRECISION - _fee, PRECISION);\\n        (daoFee,) = _calcDaoFee(outAmount - outAmountAfterFee);\\n    }\\n\\n    function _calcSwapOutput(address _tokenIn, address _tokenOut, uint256 _amountIn)\\n        internal\\n        view\\n        returns (uint256 amountOutAfterFee, uint256 feeAmount)\\n    {\\n        uint256 priceIn = _getPrice(_tokenIn, false);\\n        uint256 priceOut = _getPrice(_tokenOut, true);\\n        uint256 valueChange = _amountIn * priceIn;\\n        bool isStableSwap = isStableCoin[_tokenIn] && isStableCoin[_tokenOut];\\n        uint256 feeIn = _calcSwapFee(isStableSwap, _tokenIn, priceIn, valueChange, true);\\n        uint256 feeOut = _calcSwapFee(isStableSwap, _tokenOut, priceOut, valueChange, false);\\n        uint256 _fee = feeIn > feeOut ? feeIn : feeOut;\\n\\n        amountOutAfterFee = valueChange * (PRECISION - _fee) / priceOut / PRECISION;\\n        feeAmount = (valueChange * _fee) / priceIn / PRECISION;\\n    }\\n\\n    function _getPositionKey(address _owner, address _indexToken, address _collateralToken, Side _side)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_owner, _indexToken, _collateralToken, _side));\\n    }\\n\\n    function _validatePosition(Position memory _position, address _collateralToken, Side _side, uint256 _indexPrice)\\n        internal\\n        view\\n    {\\n        if (_position.size != 0 && _position.collateralValue == 0) {\\n            revert PoolErrors.InvalidPositionSize();\\n        }\\n\\n        if (_position.size < _position.collateralValue) {\\n            revert PoolErrors.InvalidLeverage(_position.size, _position.collateralValue, maxLeverage);\\n        }\\n\\n        uint256 borrowIndex = poolTokens[_collateralToken].borrowIndex;\\n        if (_liquidatePositionAllowed(_position, _side, _indexPrice, borrowIndex)) {\\n            revert PoolErrors.UpdateCauseLiquidation();\\n        }\\n    }\\n\\n    function _requireValidTokenPair(address _indexToken, address _collateralToken, Side _side, bool _isIncrease)\\n        internal\\n        view\\n    {\\n        if (!_validateToken(_indexToken, _collateralToken, _side, _isIncrease)) {\\n            revert PoolErrors.InvalidTokenPair(_indexToken, _collateralToken);\\n        }\\n    }\\n\\n    function _validateAsset(address _token) internal view {\\n        if (!isAsset[_token]) {\\n            revert PoolErrors.UnknownToken(_token);\\n        }\\n    }\\n\\n    function _validateTranche(address _tranche) internal view {\\n        if (!isTranche[_tranche]) {\\n            revert PoolErrors.InvalidTranche(_tranche);\\n        }\\n    }\\n\\n    function _requireAddress(address _address) internal pure {\\n        if (_address == address(0)) {\\n            revert PoolErrors.ZeroAddress();\\n        }\\n    }\\n\\n    function _onlyController() internal view {\\n        require(msg.sender == controller || msg.sender == owner(), \\\"onlyController\\\");\\n    }\\n\\n    function _requireAmount(uint256 _amount) internal pure returns (uint256) {\\n        if (_amount == 0) {\\n            revert PoolErrors.ZeroAmount();\\n        }\\n\\n        return _amount;\\n    }\\n\\n    function _requireListedToken(address _token) internal view {\\n        if (!isListed[_token]) {\\n            revert PoolErrors.AssetNotListed(_token);\\n        }\\n    }\\n\\n    function _requireOrderManager() internal view {\\n        if (msg.sender != orderManager) {\\n            revert PoolErrors.OrderManagerOnly();\\n        }\\n    }\\n\\n    function _validateMaxValue(uint256 _input, uint256 _max) internal pure {\\n        if (_input > _max) {\\n            revert PoolErrors.ValueTooHigh(_max);\\n        }\\n    }\\n\\n    function _getAmountIn(address _token) internal returns (uint256 amount) {\\n        uint256 balance = IERC20(_token).balanceOf(address(this));\\n        amount = balance - poolTokens[_token].poolBalance;\\n        poolTokens[_token].poolBalance = balance;\\n    }\\n\\n    function _doTransferOut(address _token, address _to, uint256 _amount) internal {\\n        if (_amount != 0) {\\n            IERC20 token = IERC20(_token);\\n            token.safeTransfer(_to, _amount);\\n            poolTokens[_token].poolBalance = token.balanceOf(address(this));\\n        }\\n    }\\n\\n    function _accrueInterest(address _token) internal returns (uint256) {\\n        PoolTokenInfo memory tokenInfo = poolTokens[_token];\\n        AssetInfo memory asset = _getPoolAsset(_token);\\n        uint256 _now = block.timestamp;\\n        if (tokenInfo.lastAccrualTimestamp == 0 || asset.poolAmount == 0) {\\n            tokenInfo.lastAccrualTimestamp = (_now / accrualInterval) * accrualInterval;\\n        } else {\\n            uint256 nInterval = (_now - tokenInfo.lastAccrualTimestamp) / accrualInterval;\\n            if (nInterval == 0) {\\n                return tokenInfo.borrowIndex;\\n            }\\n\\n            tokenInfo.borrowIndex += (nInterval * interestRate * asset.reservedAmount) / asset.poolAmount;\\n            tokenInfo.lastAccrualTimestamp += nInterval * accrualInterval;\\n        }\\n\\n        poolTokens[_token] = tokenInfo;\\n        emit InterestAccrued(_token, tokenInfo.borrowIndex);\\n        return tokenInfo.borrowIndex;\\n    }\\n\\n    /// @notice calculate adjusted fee rate\\n    /// fee is increased or decreased based on action's effect to pool amount\\n    /// each token has their target weight set by gov\\n    /// if action make the weight of token far from its target, fee will be increase, vice versa\\n    function _calcSwapFee(bool _isStableSwap, address _token, uint256 _tokenPrice, uint256 _valueChange, bool _isSwapIn)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 baseSwapFee, uint256 taxBasisPoint) = _isStableSwap\\n            ? (fee.stableCoinBaseSwapFee, fee.stableCoinTaxBasisPoint)\\n            : (fee.baseSwapFee, fee.taxBasisPoint);\\n        return _calcFeeRate(_token, _tokenPrice, _valueChange, baseSwapFee, taxBasisPoint, _isSwapIn);\\n    }\\n\\n    function _calcFeeRate(\\n        address _token,\\n        uint256 _tokenPrice,\\n        uint256 _valueChange,\\n        uint256 _baseFee,\\n        uint256 _taxBasisPoint,\\n        bool _isIncrease\\n    ) internal view returns (uint256) {\\n        uint256 _targetValue = totalWeight == 0 ? 0 : (targetWeights[_token] * virtualPoolValue) / totalWeight;\\n        if (_targetValue == 0) {\\n            return _baseFee;\\n        }\\n        uint256 _currentValue = _tokenPrice * _getPoolAsset(_token).poolAmount;\\n        uint256 _nextValue = _isIncrease ? _currentValue + _valueChange : _currentValue - _valueChange;\\n        uint256 initDiff = MathUtils.diff(_currentValue, _targetValue);\\n        uint256 nextDiff = MathUtils.diff(_nextValue, _targetValue);\\n        if (nextDiff < initDiff) {\\n            uint256 feeAdjust = (_taxBasisPoint * initDiff) / _targetValue;\\n            uint256 rate = MathUtils.zeroCapSub(_baseFee, feeAdjust);\\n            return rate > MIN_SWAP_FEE ? rate : MIN_SWAP_FEE;\\n        } else {\\n            uint256 avgDiff = (initDiff + nextDiff) / 2;\\n            uint256 feeAdjust = avgDiff > _targetValue ? _taxBasisPoint : (_taxBasisPoint * avgDiff) / _targetValue;\\n            return _baseFee + feeAdjust;\\n        }\\n    }\\n\\n    function _getPoolValue(bool _max) internal view returns (uint256 sum) {\\n        uint256[] memory prices = _getAllPrices(_max);\\n        for (uint256 i = 0; i < allTranches.length;) {\\n            sum += _getTrancheValue(allTranches[i], prices);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _getAllPrices(bool _max) internal view returns (uint256[] memory) {\\n        return oracle.getMultiplePrices(allAssets, _max);\\n    }\\n\\n    function _getTrancheValue(address _tranche, bool _max) internal view returns (uint256 sum) {\\n        return _getTrancheValue(_tranche, _getAllPrices(_max));\\n    }\\n\\n    function _getTrancheValue(address _tranche, uint256[] memory prices) internal view returns (uint256 sum) {\\n        int256 aum;\\n\\n        for (uint256 i = 0; i < allAssets.length;) {\\n            address token = allAssets[i];\\n            assert(isAsset[token]); // double check\\n            AssetInfo memory asset = trancheAssets[_tranche][token];\\n            uint256 price = prices[i];\\n            if (isStableCoin[token]) {\\n                aum = aum + (price * asset.poolAmount).toInt256();\\n            } else {\\n                uint256 averageShortPrice = averageShortPrices[_tranche][token];\\n                int256 shortPnl = PositionUtils.calcPnl(Side.SHORT, asset.totalShortSize, averageShortPrice, price);\\n                aum = aum + ((asset.poolAmount - asset.reservedAmount) * price + asset.guaranteedValue).toInt256()\\n                    - shortPnl;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // aum MUST not be negative. If it is, please debug\\n        return aum.toUint256();\\n    }\\n\\n    function _decreaseTranchePoolAmount(address _tranche, address _token, uint256 _amount) internal {\\n        AssetInfo memory asset = trancheAssets[_tranche][_token];\\n        asset.poolAmount -= _amount;\\n        if (asset.poolAmount < asset.reservedAmount) {\\n            revert PoolErrors.InsufficientPoolAmount(_token);\\n        }\\n        trancheAssets[_tranche][_token] = asset;\\n    }\\n\\n    /// @notice return pseudo pool asset by sum all tranches asset\\n    function _getPoolAsset(address _token) internal view returns (AssetInfo memory asset) {\\n        for (uint256 i = 0; i < allTranches.length;) {\\n            address tranche = allTranches[i];\\n            asset.poolAmount += trancheAssets[tranche][_token].poolAmount;\\n            asset.reservedAmount += trancheAssets[tranche][_token].reservedAmount;\\n            asset.totalShortSize += trancheAssets[tranche][_token].totalShortSize;\\n            asset.guaranteedValue += trancheAssets[tranche][_token].guaranteedValue;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice reserve asset when open position\\n    function _reservePoolAsset(\\n        bytes32 _key,\\n        IncreasePositionVars memory _vars,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side\\n    ) internal {\\n        AssetInfo memory collateral = _getPoolAsset(_collateralToken);\\n\\n        uint256 maxReserve = collateral.poolAmount;\\n\\n        if (_vars.sizeChanged > 0) {\\n            if (_side == Side.LONG) {\\n                uint256 maxReserveRatio = maxGlobalLongSizeRatios[_indexToken];\\n                if (maxReserveRatio != 0) {\\n                    maxReserve = MathUtils.frac(maxReserve, maxReserveRatio, PRECISION);\\n                }\\n            } else {\\n                uint256 maxGlobalShortSize = maxGlobalShortSizes[_indexToken];\\n                uint256 globalShortSize = collateral.totalShortSize + _vars.sizeChanged;\\n                if (maxGlobalShortSize != 0 && maxGlobalShortSize < globalShortSize) {\\n                    revert PoolErrors.MaxGlobalShortSizeExceeded(_indexToken, globalShortSize);\\n                }\\n            }\\n        }\\n\\n        if (collateral.reservedAmount + _vars.reserveAdded > maxReserve) {\\n            revert PoolErrors.InsufficientPoolAmount(_collateralToken);\\n        }\\n\\n        poolTokens[_collateralToken].feeReserve += _vars.daoFee;\\n        _reserveTranchesAsset(_key, _vars, _indexToken, _collateralToken, _side);\\n    }\\n\\n    /// @notice release asset and take or distribute realized PnL when close position\\n    function _releasePoolAsset(\\n        bytes32 _key,\\n        DecreasePositionVars memory _vars,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side\\n    ) internal {\\n        AssetInfo memory collateral = _getPoolAsset(_collateralToken);\\n\\n        if (collateral.reservedAmount < _vars.reserveReduced) {\\n            revert PoolErrors.ReserveReduceTooMuch(_collateralToken);\\n        }\\n\\n        poolTokens[_collateralToken].feeReserve += _vars.daoFee;\\n        _releaseTranchesAsset(_key, _vars, _indexToken, _collateralToken, _side);\\n    }\\n\\n    function _reserveTranchesAsset(\\n        bytes32 _key,\\n        IncreasePositionVars memory _vars,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side\\n    ) internal {\\n        uint256[] memory shares;\\n        uint256 totalShare;\\n        if (_vars.reserveAdded != 0) {\\n            totalShare = _vars.reserveAdded;\\n            shares = _calcTrancheSharesAmount(_indexToken, _collateralToken, totalShare, false);\\n        } else {\\n            totalShare = _vars.collateralAmount;\\n            shares = _calcTrancheSharesAmount(_indexToken, _collateralToken, totalShare, true);\\n        }\\n\\n        for (uint256 i = 0; i < shares.length;) {\\n            address tranche = allTranches[i];\\n            uint256 share = shares[i];\\n            AssetInfo memory collateral = trancheAssets[tranche][_collateralToken];\\n\\n            uint256 reserveAmount = MathUtils.frac(_vars.reserveAdded, share, totalShare);\\n            tranchePositionReserves[tranche][_key] += reserveAmount;\\n            collateral.reservedAmount += reserveAmount;\\n            collateral.poolAmount +=\\n                MathUtils.frac(_vars.totalLpFee, riskFactor[_indexToken][tranche], totalRiskFactor[_indexToken]);\\n\\n            if (_side == Side.LONG) {\\n                collateral.poolAmount = MathUtils.addThenSubWithFraction(\\n                    collateral.poolAmount, _vars.collateralAmount, _vars.feeAmount, share, totalShare\\n                );\\n                // ajust guaranteed\\n                // guaranteed value = total(size - (collateral - fee))\\n                // delta_guaranteed value = sizechange + fee - collateral\\n                collateral.guaranteedValue = MathUtils.addThenSubWithFraction(\\n                    collateral.guaranteedValue,\\n                    _vars.sizeChanged + _vars.feeValue,\\n                    _vars.collateralValueAdded,\\n                    share,\\n                    totalShare\\n                );\\n            } else {\\n                uint256 sizeChanged = MathUtils.frac(_vars.sizeChanged, share, totalShare);\\n                uint256 indexPrice = _vars.indexPrice;\\n                _updateGlobalShortPosition(tranche, _indexToken, sizeChanged, true, indexPrice, 0);\\n            }\\n\\n            trancheAssets[tranche][_collateralToken] = collateral;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _releaseTranchesAsset(\\n        bytes32 _key,\\n        DecreasePositionVars memory _vars,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side\\n    ) internal {\\n        uint256 totalShare = positions[_key].reserveAmount;\\n\\n        for (uint256 i = 0; i < allTranches.length;) {\\n            address tranche = allTranches[i];\\n            uint256 share = tranchePositionReserves[tranche][_key];\\n            AssetInfo memory collateral = trancheAssets[tranche][_collateralToken];\\n\\n            {\\n                uint256 reserveReduced = MathUtils.frac(_vars.reserveReduced, share, totalShare);\\n                tranchePositionReserves[tranche][_key] -= reserveReduced;\\n                collateral.reservedAmount -= reserveReduced;\\n            }\\n\\n            uint256 lpFee =\\n                MathUtils.frac(_vars.totalLpFee, riskFactor[_indexToken][tranche], totalRiskFactor[_indexToken]);\\n            collateral.poolAmount = (\\n                (collateral.poolAmount + lpFee).toInt256() - _vars.poolAmountReduced.frac(share, totalShare)\\n            ).toUint256();\\n\\n            if (collateral.poolAmount < collateral.reservedAmount) {\\n                revert PoolErrors.InsufficientPoolAmount(_collateralToken);\\n            }\\n\\n            int256 pnl = _vars.pnl.frac(share, totalShare);\\n            if (_side == Side.LONG) {\\n                collateral.guaranteedValue = MathUtils.addThenSubWithFraction(\\n                    collateral.guaranteedValue, _vars.collateralReduced, _vars.sizeChanged, share, totalShare\\n                );\\n            } else {\\n                uint256 sizeChanged = MathUtils.frac(_vars.sizeChanged, share, totalShare);\\n                uint256 indexPrice = _vars.indexPrice;\\n                _updateGlobalShortPosition(tranche, _indexToken, sizeChanged, false, indexPrice, pnl);\\n            }\\n            trancheAssets[tranche][_collateralToken] = collateral;\\n            emit PnLDistributed(_collateralToken, tranche, pnl.abs(), pnl >= 0);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice distributed amount of token to all tranches\\n    /// @param _indexToken the token of which risk factors is used to calculate ratio\\n    /// @param _collateralToken pool amount or reserve of this token will be changed. So we must cap the amount to be changed to the\\n    /// max available value of this token (pool amount - reserve) when _isIncreasePoolAmount set to false\\n    /// @param _isIncreasePoolAmount set to true when \\\"increase pool amount\\\" or \\\"decrease reserve amount\\\"\\n    function _calcTrancheSharesAmount(\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _amount,\\n        bool _isIncreasePoolAmount\\n    ) internal view returns (uint256[] memory reserves) {\\n        uint256 nTranches = allTranches.length;\\n        reserves = new uint256[](nTranches);\\n        uint256[] memory factors = new uint256[](nTranches);\\n        uint256[] memory maxShare = new uint256[](nTranches);\\n\\n        for (uint256 i = 0; i < nTranches;) {\\n            address tranche = allTranches[i];\\n            AssetInfo memory asset = trancheAssets[tranche][_collateralToken];\\n            factors[i] = isStableCoin[_indexToken] ? 1 : riskFactor[_indexToken][tranche];\\n            maxShare[i] = _isIncreasePoolAmount ? type(uint256).max : asset.poolAmount - asset.reservedAmount;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 totalFactor = isStableCoin[_indexToken] ? nTranches : totalRiskFactor[_indexToken];\\n\\n        for (uint256 k = 0; k < nTranches;) {\\n            unchecked {\\n                ++k;\\n            }\\n            uint256 totalRiskFactor_ = totalFactor;\\n            for (uint256 i = 0; i < nTranches;) {\\n                uint256 riskFactor_ = factors[i];\\n                if (riskFactor_ != 0) {\\n                    uint256 shareAmount = MathUtils.frac(_amount, riskFactor_, totalRiskFactor_);\\n                    uint256 availableAmount = maxShare[i] - reserves[i];\\n                    if (shareAmount >= availableAmount) {\\n                        // skip this tranche on next rounds since it's full\\n                        shareAmount = availableAmount;\\n                        totalFactor -= riskFactor_;\\n                        factors[i] = 0;\\n                    }\\n\\n                    reserves[i] += shareAmount;\\n                    _amount -= shareAmount;\\n                    totalRiskFactor_ -= riskFactor_;\\n                    if (_amount == 0) {\\n                        return reserves;\\n                    }\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        revert PoolErrors.CannotDistributeToTranches(_indexToken, _collateralToken, _amount, _isIncreasePoolAmount);\\n    }\\n\\n    /// @notice rebalance fund between tranches after swap token\\n    function _rebalanceTranches(\\n        address _tokenIn,\\n        uint256 _amountInAfterFee,\\n        address _tokenOut,\\n        uint256 _amountOut,\\n        uint256 _lpFee\\n    ) internal {\\n        // amount devided to each tranche\\n        uint256[] memory outAmounts;\\n        uint256[] memory lpFeeAmounts;\\n        address indexToken = isStableCoin[_tokenIn] && !isStableCoin[_tokenOut] ? _tokenOut : _tokenIn;\\n        outAmounts = _calcTrancheSharesAmount(indexToken, _tokenOut, _amountOut, false);\\n        lpFeeAmounts = _calcTrancheSharesAmount(indexToken, _tokenIn, _lpFee, true);\\n\\n        for (uint256 i = 0; i < allTranches.length;) {\\n            address tranche = allTranches[i];\\n            trancheAssets[tranche][_tokenOut].poolAmount -= outAmounts[i];\\n            trancheAssets[tranche][_tokenIn].poolAmount +=\\n                MathUtils.frac(_amountInAfterFee, outAmounts[i], _amountOut) + lpFeeAmounts[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _liquidatePositionAllowed(Position memory _position, Side _side, uint256 _indexPrice, uint256 _borrowIndex)\\n        internal\\n        view\\n        returns (bool allowed)\\n    {\\n        if (_position.size == 0) {\\n            return false;\\n        }\\n        // calculate fee needed when close position\\n        uint256 feeValue = _calcPositionFee(_position, _position.size, _borrowIndex);\\n        int256 pnl = PositionUtils.calcPnl(_side, _position.size, _position.entryPrice, _indexPrice);\\n        int256 collateral = pnl + _position.collateralValue.toInt256();\\n\\n        // liquidation occur when collateral cannot cover margin fee or lower than maintenance margin\\n        return collateral < 0 || uint256(collateral) * PRECISION < _position.size * maintenanceMargin\\n            || uint256(collateral) < (feeValue + fee.liquidationFee);\\n    }\\n\\n    function _calcDecreasePayout(\\n        Position memory _position,\\n        address _owner,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side,\\n        uint256 _sizeChanged,\\n        uint256 _collateralChanged,\\n        bool isLiquidate\\n    ) internal returns (DecreasePositionVars memory vars) {\\n        // clean user input\\n        vars.sizeChanged = MathUtils.min(_position.size, _sizeChanged);\\n        vars.collateralReduced = _position.collateralValue < _collateralChanged || _position.size == vars.sizeChanged\\n            ? _position.collateralValue\\n            : _collateralChanged;\\n\\n        vars.indexPrice = _getIndexPrice(_indexToken, _side, false);\\n        vars.collateralPrice = _getCollateralPrice(_collateralToken, false);\\n\\n        // vars is santinized, only trust these value from now on\\n        vars.reserveReduced = (_position.reserveAmount * vars.sizeChanged) / _position.size;\\n        vars.pnl = PositionUtils.calcPnl(_side, vars.sizeChanged, _position.entryPrice, vars.indexPrice);\\n        vars.feeValue = _calcPositionFee(_position, vars.sizeChanged, poolTokens[_collateralToken].borrowIndex);\\n        if (!isLiquidate) {\\n            vars.feeValue = feeDiscount.tryDiscount(_owner, vars.feeValue);\\n        }\\n\\n        // first try to deduct fee and lost (if any) from withdrawn collateral\\n        int256 payoutValue = vars.pnl + vars.collateralReduced.toInt256() - vars.feeValue.toInt256();\\n        if (isLiquidate) {\\n            payoutValue = payoutValue - fee.liquidationFee.toInt256();\\n        }\\n        int256 remainingCollateral = (_position.collateralValue - vars.collateralReduced).toInt256(); // subtraction never overflow, checked above\\n        // if the deduction is too much, try to deduct from remaining collateral\\n        if (payoutValue < 0) {\\n            remainingCollateral = remainingCollateral + payoutValue;\\n            payoutValue = 0;\\n        }\\n        vars.payout = uint256(payoutValue) / vars.collateralPrice;\\n\\n        int256 poolValueReduced = vars.pnl;\\n        if (remainingCollateral < 0) {\\n            if (!isLiquidate) {\\n                revert PoolErrors.UpdateCauseLiquidation();\\n            }\\n            // if liquidate too slow, pool must take the lost\\n            poolValueReduced = poolValueReduced - remainingCollateral;\\n            vars.remainingCollateral = 0;\\n        } else {\\n            vars.remainingCollateral = uint256(remainingCollateral);\\n        }\\n\\n        if (_side == Side.LONG) {\\n            poolValueReduced = poolValueReduced + vars.collateralReduced.toInt256();\\n        } else if (poolValueReduced < 0) {\\n            // in case of SHORT, trader can lost unlimited value but pool can only increase at most collateralValue - liquidationFee\\n            poolValueReduced = poolValueReduced.lowerCap(\\n                MathUtils.zeroCapSub(_position.collateralValue, vars.feeValue + fee.liquidationFee)\\n            );\\n        }\\n        vars.poolAmountReduced = poolValueReduced / vars.collateralPrice.toInt256();\\n        (vars.daoFee, vars.totalLpFee) = _calcDaoFee(vars.feeValue / vars.collateralPrice);\\n    }\\n\\n    function _calcPositionFee(Position memory _position, uint256 _sizeChanged, uint256 _borrowIndex)\\n        internal\\n        view\\n        returns (uint256 feeValue)\\n    {\\n        uint256 borrowFee = ((_borrowIndex - _position.borrowIndex) * _position.size) / PRECISION;\\n        uint256 positionFee = (_sizeChanged * fee.positionFee) / PRECISION;\\n        feeValue = borrowFee + positionFee;\\n    }\\n\\n    function _getIndexPrice(address _token, Side _side, bool _isIncrease) internal view returns (uint256) {\\n        // max == (_isIncrease & _side = LONG) | (!_increase & _side = SHORT)\\n        // max = _isIncrease == (_side == Side.LONG);\\n        return _getPrice(_token, _isIncrease == (_side == Side.LONG));\\n    }\\n\\n    function _getCollateralPrice(address _token, bool _isIncrease) internal view returns (uint256) {\\n        return (isStableCoin[_token])\\n            // force collateral price = 1 incase of using stablecoin as collateral\\n            ? 10 ** (USD_VALUE_DECIMAL - IERC20Metadata(_token).decimals())\\n            : _getPrice(_token, !_isIncrease);\\n    }\\n\\n    function _getPrice(address _token, bool _max) internal view returns (uint256) {\\n        return oracle.getPrice(_token, _max);\\n    }\\n\\n    function _validateMaxLiquidity(address _token) internal view {\\n        uint256 max = maxLiquidity[_token];\\n        if (max == 0) {\\n            return;\\n        }\\n\\n        uint256 poolAmount = _getPoolAsset(_token).poolAmount;\\n        if (max < poolAmount) {\\n            revert PoolErrors.MaxLiquidityReach();\\n        }\\n    }\\n\\n    function _updateGlobalShortPosition(\\n        address _tranche,\\n        address _indexToken,\\n        uint256 _sizeChanged,\\n        bool _isIncrease,\\n        uint256 _indexPrice,\\n        int256 _realizedPnl\\n    ) internal {\\n        uint256 lastSize = trancheAssets[_tranche][_indexToken].totalShortSize;\\n        uint256 nextSize = _isIncrease ? lastSize + _sizeChanged : MathUtils.zeroCapSub(lastSize, _sizeChanged);\\n        uint256 entryPrice = averageShortPrices[_tranche][_indexToken];\\n        uint256 shortPrice =\\n            PositionUtils.calcAveragePrice(Side.SHORT, lastSize, nextSize, entryPrice, _indexPrice, _realizedPnl);\\n        averageShortPrices[_tranche][_indexToken] = shortPrice;\\n        trancheAssets[_tranche][_indexToken].totalShortSize = nextSize;\\n    }\\n\\n    function _calcDaoFee(uint256 _feeAmount) internal view returns (uint256 daoFee, uint256 lpFee) {\\n        daoFee = MathUtils.frac(_feeAmount, fee.daoFee, PRECISION);\\n        lpFee = _feeAmount - daoFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/SignedInt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.0;\\n\\nimport {SafeCast} from \\\"../lib/SafeCast.sol\\\";\\n\\nuint256 constant POS = 1;\\nuint256 constant NEG = 0;\\n\\n/// SignedInt is integer number with sign. It value range is -(2 ^ 256 - 1) to (2 ^ 256 - 1)\\nstruct SignedInt {\\n    /// @dev sig = 1 -> positive, sig = 0 is negative\\n    /// using uint256 which take up full word to optimize gas and contract size\\n    uint256 sig;\\n    uint256 abs;\\n}\\n\\nlibrary SignedIntOps {\\n    using SafeCast for uint256;\\n\\n    function frac(int256 a, uint256 num, uint256 denom) internal pure returns (int256) {\\n        return a * num.toInt256() / denom.toInt256();\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return x < 0 ? uint256(-x) : uint256(x);\\n    }\\n\\n    function asTuple(int256 x) internal pure returns (SignedInt memory) {\\n        return SignedInt({abs: abs(x), sig: x < 0 ? NEG : POS});\\n    }\\n\\n    function lowerCap(int256 x, uint256 maxAbs) internal pure returns (int256) {\\n        int256 min = -maxAbs.toInt256();\\n        return x > min ? x : min;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/MathUtils.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nlibrary MathUtils {\\n    function diff(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a > b ? a - b : b - a;\\n        }\\n    }\\n\\n    function zeroCapSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a > b ? a - b : 0;\\n        }\\n    }\\n\\n    function frac(uint256 amount, uint256 num, uint256 denom) internal pure returns (uint256) {\\n        return amount * num / denom;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @dev a + (b - c) * x / y\\n    function addThenSubWithFraction(uint256 orig, uint256 add, uint256 sub, uint256 num, uint256 denum)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return zeroCapSub(orig + MathUtils.frac(add, num, denum), MathUtils.frac(sub, num, denum));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/PositionUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLCIENSED\\n\\npragma solidity >=0.8.0;\\n\\nimport {Side} from \\\"../interfaces/IPool.sol\\\";\\nimport {SignedInt, SignedIntOps} from \\\"./SignedInt.sol\\\";\\nimport {SafeCast} from \\\"../lib/SafeCast.sol\\\";\\n\\nlibrary PositionUtils {\\n    using SafeCast for uint256;\\n    using SignedIntOps for int256;\\n\\n    function calcPnl(Side _side, uint256 _positionSize, uint256 _entryPrice, uint256 _indexPrice)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        if (_positionSize == 0 || _entryPrice == 0) {\\n            return 0;\\n        }\\n        int256 entryPrice = _entryPrice.toInt256();\\n        int256 positionSize = _positionSize.toInt256();\\n        int256 indexPrice = _indexPrice.toInt256();\\n        if (_side == Side.LONG) {\\n            return (indexPrice - entryPrice) * positionSize / entryPrice;\\n        } else {\\n            return (entryPrice - indexPrice) * positionSize / entryPrice;\\n        }\\n    }\\n\\n    /// @notice calculate new avg entry price when increase position\\n    /// @dev for longs: nextAveragePrice = (nextPrice * nextSize)/ (nextSize + delta)\\n    ///      for shorts: nextAveragePrice = (nextPrice * nextSize) / (nextSize - delta)\\n    function calcAveragePrice(\\n        Side _side,\\n        uint256 _lastSize,\\n        uint256 _nextSize,\\n        uint256 _entryPrice,\\n        uint256 _nextPrice,\\n        int256 _realizedPnL\\n    ) internal pure returns (uint256) {\\n        if (_nextSize == 0) {\\n            return 0;\\n        }\\n        if (_lastSize == 0) {\\n            return _nextPrice;\\n        }\\n        int256 pnl = calcPnl(_side, _lastSize, _entryPrice, _nextPrice) - _realizedPnL;\\n        int256 nextSize = _nextSize.toInt256();\\n        int256 divisor = _side == Side.LONG ? nextSize + pnl : nextSize - pnl;\\n        return divisor <= 0 ? 0 : _nextSize * _nextPrice / uint256(divisor);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILevelOracle.sol\": {\r\n      \"content\": \"pragma solidity >= 0.8.0;\\n\\ninterface ILevelOracle {\\n    /**\\n     * @notice get price of single token\\n     * @param token address of token to consult\\n     * @param max if true returns max price and vice versa\\n     */\\n    function getPrice(address token, bool max) external view returns (uint256);\\n\\n    function getMultiplePrices(address[] calldata tokens, bool max) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice returns chainlink price used when liquidate\\n     */\\n    function getReferencePrice(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice returns timestamp of last posted price\\n     */\\n    function lastAnswerTimestamp(address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.15;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface ILPToken is IERC20 {\\n    function mint(address to, uint amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport {SignedInt} from \\\"../lib/SignedInt.sol\\\";\\n\\nenum Side {\\n    LONG,\\n    SHORT\\n}\\n\\nstruct TokenWeight {\\n    address token;\\n    uint256 weight;\\n}\\n\\ninterface IPool {\\n    function increasePosition(\\n        address _account,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _sizeChanged,\\n        Side _side\\n    ) external;\\n\\n    function decreasePosition(\\n        address _account,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _desiredCollateralReduce,\\n        uint256 _sizeChanged,\\n        Side _side,\\n        address _receiver\\n    ) external;\\n\\n    function liquidatePosition(address _account, address _indexToken, address _collateralToken, Side _side) external;\\n\\n    function validateToken(address indexToken, address collateralToken, Side side, bool isIncrease)\\n        external\\n        view\\n        returns (bool);\\n\\n    function swap(address _tokenIn, address _tokenOut, uint256 _minOut, address _to, bytes calldata extradata)\\n        external;\\n\\n    function addLiquidity(address _tranche, address _token, uint256 _amountIn, uint256 _minLpAmount, address _to)\\n        external;\\n\\n    function removeLiquidity(address _tranche, address _tokenOut, uint256 _lpAmount, uint256 _minOut, address _to)\\n        external;\\n\\n    // =========== EVENTS ===========\\n    event SetOrderManager(address indexed orderManager);\\n    event IncreasePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        uint256 collateralValue,\\n        uint256 sizeChanged,\\n        Side side,\\n        uint256 indexPrice,\\n        uint256 feeValue\\n    );\\n    event UpdatePosition(\\n        bytes32 indexed key,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 entryPrice,\\n        uint256 entryInterestRate,\\n        uint256 reserveAmount,\\n        uint256 indexPrice\\n    );\\n    event DecreasePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        uint256 collateralChanged,\\n        uint256 sizeChanged,\\n        Side side,\\n        uint256 indexPrice,\\n        SignedInt pnl,\\n        uint256 feeValue\\n    );\\n    event ClosePosition(\\n        bytes32 indexed key,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 entryPrice,\\n        uint256 entryInterestRate,\\n        uint256 reserveAmount\\n    );\\n    event LiquidatePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        Side side,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 reserveAmount,\\n        uint256 indexPrice,\\n        SignedInt pnl,\\n        uint256 feeValue\\n    );\\n    event DaoFeeWithdrawn(address indexed token, address recipient, uint256 amount);\\n    event DaoFeeReduced(address indexed token, uint256 amount);\\n    event FeeDistributorSet(address indexed feeDistributor);\\n    event LiquidityAdded(\\n        address indexed tranche, address indexed sender, address token, uint256 amount, uint256 lpAmount, uint256 fee\\n    );\\n    event LiquidityRemoved(\\n        address indexed tranche, address indexed sender, address token, uint256 lpAmount, uint256 amountOut, uint256 fee\\n    );\\n    event TokenWeightSet(TokenWeight[]);\\n    event Swap(\\n        address indexed sender, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, uint256 fee\\n    );\\n    event PositionFeeSet(uint256 positionFee, uint256 liquidationFee);\\n    event DaoFeeSet(uint256 value);\\n    event SwapFeeSet(\\n        uint256 baseSwapFee, uint256 taxBasisPoint, uint256 stableCoinBaseSwapFee, uint256 stableCoinTaxBasisPoint\\n    );\\n    event InterestAccrued(address indexed token, uint256 borrowIndex);\\n    event MaxLeverageChanged(uint256 maxLeverage);\\n    event TokenWhitelisted(address indexed token);\\n    event TokenDelisted(address indexed token);\\n    event OracleChanged(address indexed oldOracle, address indexed newOracle);\\n    event InterestRateSet(uint256 interestRate, uint256 interval);\\n    event PoolHookChanged(address indexed hook);\\n    event TrancheAdded(address indexed lpToken);\\n    event TokenRiskFactorUpdated(address indexed token);\\n    event PnLDistributed(address indexed asset, address indexed tranche, uint256 amount, bool hasProfit);\\n    event MaintenanceMarginChanged(uint256 ratio);\\n    event AddRemoveLiquidityFeeSet(uint256 value);\\n    event MaxGlobalPositionSizeSet(address indexed token, uint256 maxLongRatios, uint256 maxShortSize);\\n    event PoolControllerChanged(address controller);\\n    event AssetRebalanced();\\n    event MaxLiquiditySet(address token, uint256 maxLiquidity);\\n}\\n\"\r\n    },\r\n    \"src/pool/PoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport {ILevelOracle} from \\\"../interfaces/ILevelOracle.sol\\\";\\nimport {ILPToken} from \\\"../interfaces/ILPToken.sol\\\";\\nimport {IPoolHook} from \\\"../interfaces/IPoolHook.sol\\\";\\nimport {IFeeDiscount} from \\\"../interfaces/IFeeDiscount.sol\\\";\\n\\n// common precision for fee, tax, interest rate, maintenace margin ratio\\nuint256 constant PRECISION = 1e10;\\nuint256 constant LP_INITIAL_PRICE = 1e12; // fix to 1$\\nuint256 constant MAX_BASE_SWAP_FEE = 1e8; // 1%\\nuint256 constant MAX_TAX_BASIS_POINT = 1e8; // 1%\\nuint256 constant MAX_POSITION_FEE = 1e8; // 1%\\nuint256 constant MAX_LIQUIDATION_FEE = 10e30; // 10$\\nuint256 constant MAX_TRANCHES = 3;\\nuint256 constant MAX_ASSETS = 10;\\nuint256 constant MAX_INTEREST_RATE = 1e7; // 0.1%\\nuint256 constant MAX_MAINTENANCE_MARGIN = 5e8; // 5%\\n\\nstruct Fee {\\n    /// @notice charge when changing position size\\n    uint256 positionFee;\\n    /// @notice charge when liquidate position (in dollar)\\n    uint256 liquidationFee;\\n    /// @notice swap fee used when add/remove liquidity, swap token\\n    uint256 baseSwapFee;\\n    /// @notice tax used to adjust swapFee due to the effect of the action on token's weight\\n    /// It reduce swap fee when user add some amount of a under weight token to the pool\\n    uint256 taxBasisPoint;\\n    /// @notice swap fee used when add/remove liquidity, swap token\\n    uint256 stableCoinBaseSwapFee;\\n    /// @notice tax used to adjust swapFee due to the effect of the action on token's weight\\n    /// It reduce swap fee when user add some amount of a under weight token to the pool\\n    uint256 stableCoinTaxBasisPoint;\\n    /// @notice part of fee will be kept for DAO, the rest will be distributed to pool amount, thus\\n    /// increase the pool value and the price of LP token\\n    uint256 daoFee;\\n}\\n\\nstruct Position {\\n    /// @dev contract size is evaluated in dollar\\n    uint256 size;\\n    /// @dev collateral value in dollar\\n    uint256 collateralValue;\\n    /// @dev contract size in indexToken\\n    uint256 reserveAmount;\\n    /// @dev average entry price\\n    uint256 entryPrice;\\n    /// @dev last cumulative interest rate\\n    uint256 borrowIndex;\\n}\\n\\nstruct PoolTokenInfo {\\n    /// @notice amount reserved for fee\\n    uint256 feeReserve;\\n    /// @notice recorded balance of token in pool\\n    uint256 poolBalance;\\n    /// @notice last borrow index update timestamp\\n    uint256 lastAccrualTimestamp;\\n    /// @notice accumulated interest rate\\n    uint256 borrowIndex;\\n    /// @notice average entry price of all short position\\n    /// @deprecated avg short price must be calculate per tranche\\n    uint256 ___averageShortPrice;\\n}\\n\\nstruct AssetInfo {\\n    /// @notice amount of token deposited (via add liquidity or increase long position)\\n    uint256 poolAmount;\\n    /// @notice amount of token reserved for paying out when user decrease long position\\n    uint256 reservedAmount;\\n    /// @notice total borrowed (in USD) to leverage\\n    uint256 guaranteedValue;\\n    /// @notice total size of all short positions\\n    uint256 totalShortSize;\\n}\\n\\nabstract contract PoolStorage {\\n    Fee public fee;\\n\\n    address public feeDistributor;\\n\\n    ILevelOracle public oracle;\\n\\n    address public orderManager;\\n\\n    // ========= Assets management =========\\n    mapping(address => bool) public isAsset;\\n    /// @notice A list of all configured assets\\n    /// @dev use a pseudo address for ETH\\n    /// Note that token will not be removed from this array when it was delisted. We keep this\\n    /// list to calculate pool value properly\\n    address[] public allAssets;\\n\\n    mapping(address => bool) public isListed;\\n\\n    mapping(address => bool) public isStableCoin;\\n\\n    mapping(address => PoolTokenInfo) public poolTokens;\\n\\n    /// @notice target weight for each tokens\\n    mapping(address => uint256) public targetWeights;\\n\\n    mapping(address => bool) public isTranche;\\n    /// @notice risk factor of each token in each tranche\\n    /// @dev token => tranche => risk factor\\n    mapping(address => mapping(address => uint256)) public riskFactor;\\n    /// @dev token => total risk score\\n    mapping(address => uint256) public totalRiskFactor;\\n\\n    address[] public allTranches;\\n    /// @dev tranche => token => asset info\\n    mapping(address => mapping(address => AssetInfo)) public trancheAssets;\\n    /// @notice position reserve in each tranche\\n    mapping(address => mapping(bytes32 => uint256)) public tranchePositionReserves;\\n\\n    /// @notice interest rate model\\n    uint256 public interestRate;\\n\\n    uint256 public accrualInterval;\\n\\n    uint256 public totalWeight;\\n    // ========= Positions management =========\\n    /// @notice max leverage for each token\\n    uint256 public maxLeverage;\\n    /// @notice positions tracks all open positions\\n    mapping(bytes32 => Position) public positions;\\n\\n    IPoolHook public poolHook;\\n\\n    uint256 public maintenanceMargin;\\n\\n    uint256 public addRemoveLiquidityFee;\\n\\n    mapping(address => mapping(address => uint256)) public averageShortPrices;\\n    /// @notice cached pool value for faster computation\\n    uint256 public virtualPoolValue;\\n    /// @notice index token => max global short size\\n    mapping(address => uint256) public maxGlobalShortSizes;\\n    mapping(address => uint256) public maxGlobalLongSizeRatios;\\n    address public controller;\\n    mapping(address => uint256) public maxLiquidity;\\n\\n    mapping(address => bool) public allowSwap;\\n    mapping(bytes32 => uint256) public positionOpenTimestamp;\\n    IFeeDiscount public feeDiscount;\\n}\\n\"\r\n    },\r\n    \"src/pool/PoolErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.15;\\n\\nimport {Side} from \\\"../interfaces/IPool.sol\\\";\\n\\nlibrary PoolErrors {\\n    error UpdateCauseLiquidation();\\n    error InvalidTokenPair(address index, address collateral);\\n    error InvalidLeverage(uint256 size, uint256 margin, uint256 maxLeverage);\\n    error InvalidPositionSize();\\n    error OrderManagerOnly();\\n    error UnknownToken(address token);\\n    error AssetNotListed(address token);\\n    error InsufficientPoolAmount(address token);\\n    error ReserveReduceTooMuch(address token);\\n    error SlippageExceeded();\\n    error ValueTooHigh(uint256 maxValue);\\n    error InvalidInterval();\\n    error PositionNotLiquidated(bytes32 key);\\n    error ZeroAmount();\\n    error ZeroAddress();\\n    error RequireAllTokens();\\n    error DuplicateToken(address token);\\n    error FeeDistributorOnly();\\n    error InvalidMaxLeverage();\\n    error SameTokenSwap(address token);\\n    error InvalidTranche(address tranche);\\n    error TrancheAlreadyAdded(address tranche);\\n    error RemoveLiquidityTooMuch(address tranche, uint256 outAmount, uint256 trancheBalance);\\n    error CannotDistributeToTranches(\\n        address indexToken, address collateralToken, uint256 amount, bool CannotDistributeToTranches\\n    );\\n    error CannotSetRiskFactorForStableCoin(address token);\\n    error PositionNotExists(address owner, address indexToken, address collateralToken, Side side);\\n    error MaxNumberOfTranchesReached();\\n    error TooManyTokenAdded(uint256 number, uint256 max);\\n    error AddLiquidityNotAllowed(address tranche, address token);\\n    error MaxGlobalShortSizeExceeded(address token, uint256 globalShortSize);\\n    error NotApplicableForStableCoin();\\n    error MaxLiquidityReach();\\n    error SwapNotAllowed();\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPoolHook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {Side, IPool} from \\\"./IPool.sol\\\";\\n\\ninterface IPoolHook {\\n    function postIncreasePosition(\\n        address owner,\\n        address indexToken,\\n        address collateralToken,\\n        Side side,\\n        bytes calldata extradata\\n    ) external;\\n\\n    function postDecreasePosition(\\n        address owner,\\n        address indexToken,\\n        address collateralToken,\\n        Side side,\\n        bytes calldata extradata\\n    ) external;\\n\\n    function postLiquidatePosition(\\n        address owner,\\n        address indexToken,\\n        address collateralToken,\\n        Side side,\\n        bytes calldata extradata\\n    ) external;\\n\\n    function postSwap(address user, address tokenIn, address tokenOut, bytes calldata data) external;\\n\\n    event PreIncreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PostIncreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PreDecreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PostDecreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PreLiquidatePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PostLiquidatePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n\\n    event PostSwapExecuted(address pool, address user, address tokenIn, address tokenOut, bytes data);\\n}\\n\"\r\n    },\r\n    \"src/lib/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/ma/SafeCast.solth)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Extract from OpenZeppelin SafeCast to shorten revert message\\n */\\nlibrary SafeCast {\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value < 0\\\");\\n        return uint256(value);\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value > int256.max\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >= 0.8.0;\\n\\ninterface IFeeDiscount {\\n    function tryDiscount(address _user, uint256 _amount) external returns (uint256 remaining);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tranche\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AddLiquidityNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AssetNotListed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"CannotDistributeToTranches\",\"type\":\"bool\"}],\"name\":\"CannotDistributeToTranches\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"DuplicateToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeDistributorOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"InsufficientPoolAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"name\":\"InvalidLeverage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPositionSize\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"index\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"InvalidTokenPair\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tranche\",\"type\":\"address\"}],\"name\":\"InvalidTranche\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"globalShortSize\",\"type\":\"uint256\"}],\"name\":\"MaxGlobalShortSizeExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxLiquidityReach\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApplicableForStableCoin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderManagerOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"PositionNotExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"PositionNotLiquidated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequireAllTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"ReserveReduceTooMuch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SameTokenSwap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlippageExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"TooManyTokenAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"UnknownToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpdateCauseLiquidation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"}],\"name\":\"ValueTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddRemoveLiquidityFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AssetRebalanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryInterestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"}],\"name\":\"ClosePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DaoFeeReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DaoFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DaoFeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralChanged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sizeChanged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sig\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"abs\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SignedInt\",\"name\":\"pnl\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeValue\",\"type\":\"uint256\"}],\"name\":\"DecreasePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeDistributor\",\"type\":\"address\"}],\"name\":\"FeeDistributorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sizeChanged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeValue\",\"type\":\"uint256\"}],\"name\":\"IncreasePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"}],\"name\":\"InterestAccrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"InterestRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sig\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"abs\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SignedInt\",\"name\":\"pnl\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeValue\",\"type\":\"uint256\"}],\"name\":\"LiquidatePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tranche\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tranche\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"MaintenanceMarginChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLongRatios\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxShortSize\",\"type\":\"uint256\"}],\"name\":\"MaxGlobalPositionSizeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"name\":\"MaxLeverageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLiquidity\",\"type\":\"uint256\"}],\"name\":\"MaxLiquiditySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tranche\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hasProfit\",\"type\":\"bool\"}],\"name\":\"PnLDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"PoolControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hook\",\"type\":\"address\"}],\"name\":\"PoolHookChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationFee\",\"type\":\"uint256\"}],\"name\":\"PositionFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"orderManager\",\"type\":\"address\"}],\"name\":\"SetOrderManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseSwapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taxBasisPoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stableCoinBaseSwapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stableCoinTaxBasisPoint\",\"type\":\"uint256\"}],\"name\":\"SwapFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRiskFactorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct TokenWeight[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"TokenWeightSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"name\":\"TrancheAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryInterestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatePosition\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accrualInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tranche\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addRemoveLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isStableCoin\",\"type\":\"bool\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allAssets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTranches\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"averageShortPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tranche\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"}],\"name\":\"calcRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmountAfterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"calcSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralChanged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeChanged\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"decreasePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxBasisPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableCoinBaseSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableCoinTaxBasisPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDiscount\",\"outputs\":[{\"internalType\":\"contract IFeeDiscount\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllTranchesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPoolAsset\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guaranteedValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShortSize\",\"type\":\"uint256\"}],\"internalType\":\"struct AssetInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_max\",\"type\":\"bool\"}],\"name\":\"getPoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tranche\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_max\",\"type\":\"bool\"}],\"name\":\"getTrancheValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sizeChanged\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"}],\"name\":\"increasePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStableCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTranche\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"}],\"name\":\"liquidatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maintenanceMargin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxGlobalLongSizeRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxGlobalShortSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromTranche\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_viaToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"migrateLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract ILevelOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolHook\",\"outputs\":[{\"internalType\":\"contract IPoolHook\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAccrualTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"___averageShortPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"positionOpenTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromTranche\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fromAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toTranche\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"rebalanceAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshVirtualPoolValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tranche\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"riskFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxGlobalLongRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxGlobalShortSize\",\"type\":\"uint256\"}],\"name\":\"setMaxGlobalPositionSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMaxLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenWeight[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"name\":\"setTargetWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"targetWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRiskFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"trancheAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guaranteedValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShortSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tranchePositionReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_isIncrease\",\"type\":\"bool\"}],\"name\":\"validateToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualPoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pool", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}