{"SourceCode": "// \"SPDX-License-Identifier: UNLICENSED\"\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function burn(uint256 amount) external;\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IPancakeFactory {\r\nfunction getPair (address token1, address token2) external pure returns (address);\r\n}\r\n\r\n\r\ncontract WhalesCandy {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address payable public _dev = payable (0x9a27Da147a89871171c06b98944cB4AE6d5Eca43); // receives ETH and Token\r\n    address public _setterDev =  0x2096aFDaA68EEaE1EbF95DFdf565eE6d9B1fbA37; // address that can help to set user stakings\r\n    address payable public _dev1 = payable (0x35626C1771769F4c851ABCCCE640c426feE5da3B); // receives USDC\r\n    bool public settingDone = false;\r\n    uint8 public devAuctionFee = 30;\r\n    uint8 public devDiscountedBuyFee = 30;\r\n\r\n    address public contrAddr;\r\n\r\n    address public constant USDCaddress =  0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\r\n    address public constant _pancakeRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    IPancakeRouter02 _pancakeRouter;\r\n    address public constant _pancakeFactoryAddress = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\r\n    IPancakeFactory _pancakeFactory;\r\n    address public tradingPair = address(0);\r\n\r\n    uint256 public usedETHforBuyBack;\r\n    uint256 public lpBal;\r\n\r\n    uint256 public overallStakedToken;\r\n    uint256 public overallCollectedDividends;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Sake(address indexed user, uint256 stakeAmount, uint256 stakeTime);\r\n    event EnterAuction (address indexed user, uint256 rawAmount, uint256 entryTime);\r\n    event ClaimRewards (address indexed user, uint256 rewardAmount, uint256 claimTime);\r\n\r\n    modifier onlyDev() {\r\n        require(_dev == msg.sender, \"Ownable: caller is not the dev\");\r\n        _;\r\n    }\r\n\r\n    string public constant name = \"WhalesCandyToken.com\";\r\n    string public constant symbol = \"WC\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    mapping(address => uint256) private _Balances;\r\n\r\n    /* Time of contract launch */\r\n    uint256 public LAUNCH_TIME = 1680152461; // Sets Starttime of Auctions, Days and Weeks // TODO\r\n    uint256 public oneDay = 1 days;  // TODO\r\n    uint256 public oneWeek = 7 days; // TODO\r\n    uint32 public offDays = 10 days; \r\n    uint256 public currentDay;\r\n    uint256 public lastBUYINday;\r\n    uint8 public buyBackPerecent = 40;\r\n    uint8 public taxFactor = 100;\r\n    uint8 public percentToReceive = 20; // percentage of tokens to be received when buying from PancakeSwap\r\n    \r\n    struct StakeData{\r\n      uint256 stakeTime;\r\n      uint256 amount;\r\n      uint256 claimed;\r\n      uint256 lastUpdate;\r\n      uint256 collected;\r\n      bool freeClaiming;\r\n      uint256 claimingStartFee;\r\n      uint256 feePaid;\r\n    }\r\n\r\n    uint256 public feePerWeek = 2 ether;\r\n    uint256 private maxTotlFee = 52*2 ether;\r\n\r\n    uint256 private weiPerSfor1perDay = 11574074074074;  // this token/wei amount need to be accounted per second to have 1 ETH per day\r\n\r\n    uint256 private dayliAvailableToken = 2000000 ether;\r\n\r\n    mapping(address => mapping(uint256 => StakeData)) public stakes;\r\n    mapping(address => uint256) public stakeNumber;\r\n    mapping(address => uint256) public refAddresstoCode;\r\n    mapping(uint256 => address) public refCodeToAddress;\r\n    mapping(address => address) public myRef;\r\n\r\n    /* day's total auction entry */ \r\n    mapping(uint256 => uint256) public auctionEntry;\r\n    /* day's liq already added? */ \r\n    mapping(uint256 => bool) public liqAdded;\r\n    // total auction entry  \r\n    uint256 public auctionEntry_allDays;\r\n\r\n    // counting unique (unique for every day only) Auction enteries for each day\r\n    mapping(uint256 => uint256) public usersCountDaily;\r\n    // counting unique (unique for every day only) users\r\n    uint256 public usersCount = 0;\r\n\r\n    uint256 public refCount = 6110000;\r\n\r\n    // mapping for allowance\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n\r\n    \r\n    // Auction memebrs overall data \r\n    struct memberAuction_overallData{\r\n        uint256 overall_collectedTokens;\r\n        uint256 total_auctionEnteries;\r\n        uint256 overall_stakedTokens;\r\n    }\r\n    // new map for every user's overall data  \r\n    mapping(address => memberAuction_overallData) public mapMemberAuction_overallData;\r\n    \r\n    /* Auction memebrs data */ \r\n    struct memberAuction{\r\n        uint256 memberAuctionValue;\r\n        uint256 memberAuctionEntryDay;\r\n        bool hasChangedShareToToken;\r\n        address referrer;\r\n    }\r\n    /* new map for every entry (users are allowed to enter multiple times a day) */ \r\n    mapping(address => mapping(uint256 => memberAuction)) public mapMemberAuction;\r\n\r\n    /* new map for the referrers tokens */\r\n    struct refData{\r\n      uint256 refEarnedTokens;\r\n    }\r\n    mapping(address => mapping(uint256 => refData)) public mapRefData;\r\n    \r\n    // Addresses that excluded from transferTax when receiving\r\n    mapping(address => bool) private _excludedFromTaxReceiver;\r\n\r\n\r\n\r\n\r\n    constructor() {\r\n        _pancakeRouter = IPancakeRouter02(_pancakeRouterAddress);\r\n        _pancakeFactory = IPancakeFactory(_pancakeFactoryAddress);\r\n\r\n        contrAddr = address(this);\r\n\r\n        _excludedFromTaxReceiver[msg.sender] = true;\r\n        _excludedFromTaxReceiver[contrAddr] = true;\r\n        _excludedFromTaxReceiver[_pancakeRouterAddress] = true;\r\n        _excludedFromTaxReceiver[_dev] = true;\r\n        _excludedFromTaxReceiver[_dev1] = true;  \r\n\r\n        _mint(contrAddr, 1 ether);\r\n    }\r\n    \r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _Balances[account];\r\n    }\r\n\r\n    function allowance(address owner_, address spender) external view returns (uint256) {\r\n        return _allowance[owner_][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _allowance[msg.sender][spender] =\r\n        _allowance[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowance[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowance[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    // Set addresses of dev ad dev1\r\n    function setDevs(address payable dev, address payable dev1) external onlyDev {\r\n        _dev = dev;\r\n        _dev1 = dev1;\r\n     }\r\n\r\n    // Set the setting Done boolean to true (after all userstakes are set and all needed WC are minted!)\r\n    function setSettingDone() external onlyDev {\r\n        settingDone = true;\r\n     }\r\n\r\n    // Set the fee that goes to dev with each auction entry\r\n    function setDevAuctionFee(uint8 _devAuctionFee) external onlyDev {\r\n      require(_devAuctionFee <= 30, \"setDevAuctionFee: Dev Auction Fee cant be above 30%\" );\r\n        devAuctionFee = _devAuctionFee;\r\n     }\r\n\r\n    // Set the fee that goes to dev with each ussage of the discounted BUY function\r\n    function setDevDiscountedBuyFee(uint8 _devDiscountedBuyFee) external onlyDev {\r\n      require(_devDiscountedBuyFee <= 30, \"setDevDiscountedBuyFee: Dev Auction Fee cant be above 30%\" );\r\n        devDiscountedBuyFee = _devDiscountedBuyFee;\r\n     }\r\n\r\n\r\n    // Set the Buyback Percentage\r\n    function setBuyBackPerecent(uint8 _buyBackPerecent) external onlyDev {\r\n        require (10 <= _buyBackPerecent, \"Value to small, use at least 10!\");\r\n        require (_buyBackPerecent <= 40, \"Value to big, use at max 40!\");\r\n        buyBackPerecent = _buyBackPerecent;\r\n     }\r\n\r\n    // Set the Tax Factor for the discounted buy from Pancake\r\n     function setTaxFactor(uint8 _taxFactor) external onlyDev {\r\n        require (20 <= _taxFactor, \"Value to small, use at least 20!\");\r\n        require (_taxFactor <= 200, \"Value to big, use at max 200!\");\r\n        taxFactor = _taxFactor;\r\n     }\r\n\r\n\r\n    // Set the percentage to be received when buying from PancakeSwap\r\n     function setPercentToReceive(uint8 _percentToReceive) external onlyDev {\r\n        require (20 <= _percentToReceive, \"Value to small, use at least 20!\");\r\n        require (_percentToReceive <= 100, \"Value to big, use at max 100!\");\r\n        percentToReceive = _percentToReceive;\r\n     }\r\n\r\n     \r\n     \r\n    // Set address to be in- or excluded from Tax when receiving\r\n    function setExcludedFromTaxReceiver(address _account, bool _excluded) external onlyDev {\r\n        _excludedFromTaxReceiver[_account] = _excluded;\r\n     }\r\n    \r\n    // Returns if the address is excluded from Tax or not when receiving.    \r\n    function isExcludedFromTaxReceiver(address _account) public view returns (bool) {\r\n        return _excludedFromTaxReceiver[_account];\r\n    }\r\n    \r\n   function transferToZero(uint256 amount) internal returns (bool) {\r\n        _Balances[contrAddr] = _Balances[contrAddr].sub(amount, \"Token: transfer amount exceeds balance\");\r\n        _Balances[address(0)] = _Balances[address(0)].add(amount);\r\n        emit Transfer(contrAddr, address(0), amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }  \r\n\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\r\n        if( msg.sender != contrAddr ) {\r\n          _allowance[from][msg.sender] = _allowance[from][msg.sender].sub(amount);\r\n        }\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // internal transfer function to apply the transfer tax ONLY for buys from liquidity\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        // For Taxed Transfer (if pair is sender (token BUY) tax of 80% applies)\r\n        bool _isTaxedRecipient = !isExcludedFromTaxReceiver(to);\r\n        if ( from == tradingPair && _isTaxedRecipient ) {   // if sender is pair (its a buy tx) AND is a TaxedRecipient  \r\n        _Balances[from] = _Balances[from].sub(amount, \"transfer amount exceeds balance\");\r\n        uint256 taxedAmount = amount.mul(percentToReceive).div(100);\r\n        _Balances[to] = _Balances[to].add(taxedAmount);\r\n        _Balances[address(0)] = _Balances[address(0)].add(amount.sub(taxedAmount));\r\n        emit Transfer(from, to, taxedAmount);\r\n        emit Transfer(from, address(0), amount.sub(taxedAmount));\r\n        } else {\r\n        _Balances[from] = _Balances[from].sub(amount, \"transfer amount exceeds balance\");\r\n        _Balances[to] = _Balances[to].add(amount);\r\n        emit Transfer(from, to, amount);\r\n        }\r\n    }\r\n\r\n    function _mint(address _user, uint256 _amount) internal { \r\n      _Balances[_user] = _Balances[_user].add(_amount);\r\n      _totalSupply = _totalSupply.add(_amount);\r\n      emit Transfer(address(0), _user, _amount);\r\n    }\r\n\r\n    function _devMint(uint256 _amount) external onlyDev { \r\n      require (settingDone == false, \"devMint: dev can not mint any more!\");\r\n      _Balances[_dev] = _Balances[_dev].add(_amount);\r\n      _totalSupply = _totalSupply.add(_amount);\r\n      emit Transfer(address(0), _dev, _amount);\r\n    }\r\n\r\n    function _burn(address _user, uint256 _amount) internal {\r\n      _Balances[_user] = _Balances[_user].sub(_amount);\r\n      _totalSupply = _totalSupply.sub(_amount);\r\n      emit Transfer(_user, address(0), _amount);\r\n    }\r\n    \r\n    // function for users to create theri ref code\r\n    function createRefCode() external returns (uint256) {\r\n      require (refAddresstoCode[msg.sender] == 0);\r\n      refAddresstoCode[msg.sender] = refCount;\r\n      refCodeToAddress[refCount] = msg.sender;\r\n      refCount++;\r\n      return refAddresstoCode[msg.sender];\r\n    }\r\n\r\n    // function for users to stake Token they have in their wallet\r\n    function stake (uint256 _amount) public {\r\n      require(_Balances[msg.sender] >= _amount, \"not Enoght token to stake\");\r\n\r\n      _Balances[msg.sender] = _Balances[msg.sender].sub(_amount, \"transfer amount exceeds balance\");      \r\n      _Balances[contrAddr] = _Balances[contrAddr].add(_amount);\r\n      emit Transfer(msg.sender, contrAddr, _amount);\r\n\r\n      stakes[msg.sender][stakeNumber[msg.sender]].amount = _amount;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].stakeTime = block.timestamp;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].lastUpdate = block.timestamp;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].freeClaiming = false;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].claimingStartFee = feePerWeek;\r\n\r\n      stakeNumber[msg.sender]++;\r\n      overallStakedToken += _amount;\r\n      emit Sake(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    // internal function for to stake user Token\r\n    function stakeInt (uint256 _amount) internal {\r\n      stakes[msg.sender][stakeNumber[msg.sender]].amount = _amount;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].stakeTime = block.timestamp;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].lastUpdate = block.timestamp;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].freeClaiming = false;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].claimingStartFee = feePerWeek;\r\n\r\n      stakeNumber[msg.sender]++;\r\n      overallStakedToken += _amount;\r\n      emit Sake(msg.sender, _amount, block.timestamp);\r\n    }\r\n \r\n    // internal function to stake refferal earnings with no claim fee\r\n    function refStake (uint256 _amount) internal {      \r\n      stakes[msg.sender][stakeNumber[msg.sender]].amount = _amount;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].stakeTime = block.timestamp;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].lastUpdate = block.timestamp;\r\n      stakes[msg.sender][stakeNumber[msg.sender]].freeClaiming = true;\r\n\r\n      stakeNumber[msg.sender]++;\r\n      overallStakedToken += _amount;\r\n      emit Sake(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    // function to set the right amount of userstakes for UI ( in case errors occur when setting stakes)\r\n    function setUsersStakeNumber (address user, uint8 _stakeNumber) external {\r\n      require (settingDone == false, \"setStakesUser: dev can not set any more!\");\r\n      require (msg.sender == _dev1 || msg.sender == _setterDev, \"setStakesUser: you are not allowed to set Stakes!\");\r\n\r\n      stakeNumber[user] = _stakeNumber;\r\n    }\r\n\r\n    // function to set the right amount of overallStakedToken for UI (in case errors occur when setting stakes)\r\n    function setOverallStakedToken (uint256 _amount) external {\r\n      require (settingDone == false, \"setStakesUser: dev can not set any more!\");\r\n      require (msg.sender == _dev1 || msg.sender == _setterDev, \"setStakesUser: you are not allowed to set Stakes!\");\r\n      \r\n      overallStakedToken = _amount;\r\n    }\r\n\r\n    // function to set the right amount of auctionEntry_allDays (total ETH collected) for UI (in case errors occur when setting stakes)\r\n    function setAuctionEntry_allDays (uint256 _auctionEntry_allDays) external {\r\n      require (settingDone == false, \"setStakesUser: dev can not set any more!\");\r\n      require (msg.sender == _dev1 || msg.sender == _setterDev, \"setStakesUser: you are not allowed to set Stakes!\");\r\n      \r\n      auctionEntry_allDays = _auctionEntry_allDays;\r\n    }\r\n    \r\n\r\n    // function for devs to set previous contracts userstakings\r\n    function setStakesUser (address user, uint8 _stakeNumber, uint256 _stakeTime, uint256 _amount, uint256 _claimed, uint256 _lastUpdate, uint256 _feePaid) external {\r\n      require (settingDone == false, \"setStakesUser: dev can not set any more!\");\r\n      require (msg.sender == _dev1 || msg.sender == _setterDev, \"setStakesUser: you are not allowed to set Stakes!\");\r\n      stakes[user][_stakeNumber].stakeTime = _stakeTime;\r\n      stakes[user][_stakeNumber].amount = _amount;\r\n      stakes[user][_stakeNumber].claimed = _claimed;\r\n      stakes[user][_stakeNumber].lastUpdate = _lastUpdate;\r\n      stakes[user][_stakeNumber].collected = _claimed;\r\n      stakes[user][_stakeNumber].freeClaiming = false;\r\n      stakes[user][_stakeNumber].claimingStartFee = feePerWeek;\r\n      stakes[user][_stakeNumber].feePaid = _feePaid;\r\n\r\n      stakeNumber[user]++;\r\n      overallStakedToken += _amount;\r\n      emit Sake(user, _amount, _stakeTime);\r\n    }\r\n\r\n    // function for devs to set previous contracts userstakings\r\n    function setStakesRefs (address user, uint8 _stakeNumber, uint256 _stakeTime, uint256 _amount, uint256 _claimed, uint256 _lastUpdate) external {\r\n      require (settingDone == false, \"setStakesUser: dev can not set any more!\");\r\n      require (msg.sender == _dev1 || msg.sender == _setterDev, \"setStakesUser: you are not allowed to set Stakes!\");\r\n      stakes[user][_stakeNumber].stakeTime = _stakeTime;\r\n      stakes[user][_stakeNumber].amount = _amount;\r\n      stakes[user][_stakeNumber].claimed = _claimed;\r\n      stakes[user][_stakeNumber].lastUpdate = _lastUpdate;\r\n      stakes[user][_stakeNumber].collected = _claimed;\r\n      stakes[user][_stakeNumber].freeClaiming = true;\r\n\r\n      stakeNumber[user]++;\r\n      overallStakedToken += _amount;\r\n      emit Sake(user, _amount, _stakeTime);\r\n    }\r\n\r\n    // function to set launchtime\r\n    function setLaunchTime (uint256 newTime) external onlyDev {\r\n      require(newTime > block.timestamp);\r\n      LAUNCH_TIME = newTime;\r\n    }\r\n\r\n    // function to see which dy it is\r\n    function thisDay() public view returns (uint256) {\r\n        return 1 + ((block.timestamp - LAUNCH_TIME) / oneDay);\r\n    }\r\n\r\n    // function to get amount out from buying from LP\r\n    function getAmountFromLiq (uint256 amountIn) public view returns (uint256) {\r\n      address[] memory path;\r\n      path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = contrAddr;\r\n      uint256[] memory amountOutMins = _pancakeRouter.getAmountsOut(amountIn, path);\r\n      return amountOutMins[path.length -1];\r\n    }\r\n\r\n    // function to do a \"discounted\" buy from liq and do a stake for the user\r\n    // \"discounted\" buy means that the tax will be less than if users busy in pancake\r\n    function buyAndStake () external payable returns (bool) {\r\n      uint256 rawAmount = msg.value;\r\n      require(rawAmount > 0, \"No ETH to buy Token!\");\r\n\r\n      uint256 devFee = rawAmount.mul(devDiscountedBuyFee).div(100);\r\n      _dev.transfer(devFee); // transfer dev share of ETH to dev\r\n\r\n      uint256 stakeAmount = getAmountFromLiq(rawAmount.mul(taxFactor).div(100));\r\n\r\n      address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = contrAddr;\r\n\r\n          // Buy and Burn Token from LP with ETH\r\n          _pancakeRouter.swapExactETHForTokens { value: rawAmount.sub(devFee) } (\r\n          0,\r\n          path,\r\n          address(0),\r\n          block.timestamp +100\r\n          );\r\n        \r\n        stakeInt(stakeAmount);\r\n        return true;\r\n    }\r\n\r\n    // function to add last days collected ETH to new liquiity and update the day\r\n    function updateDaily() public {\r\n      // this is true once per day\r\n      if (currentDay != thisDay()) {\r\n\r\n          uint256 contractETHBalance = contrAddr.balance;\r\n          if (contractETHBalance > 1000){\r\n            \r\n            uint256 collectedThatDay = auctionEntry[lastBUYINday].mul(70).div(100);\r\n            if (collectedThatDay != 0 && !liqAdded[lastBUYINday] ) {\r\n                uint256 ETHtoAdd;\r\n                if (collectedThatDay < contractETHBalance) {\r\n                  ETHtoAdd = collectedThatDay;\r\n                } else { ETHtoAdd = contractETHBalance;}\r\n\r\n                uint256 tokenToAdd = dayliAvailableToken.mul(63).div(100);\r\n                _mint(contrAddr, tokenToAdd);\r\n                _mint(_dev, dayliAvailableToken.mul(5).div(100));\r\n\r\n                if (IERC20(contrAddr).allowance( contrAddr, _pancakeRouterAddress ) == 0) {\r\n                    approve(_pancakeRouterAddress, type(uint256).max);\r\n                    IERC20(contrAddr).approve(_pancakeRouterAddress, type(uint256).max);\r\n                }\r\n\r\n                 (uint256 addedToken, uint256 addedEth,) = \r\n                 _pancakeRouter.addLiquidityETH {value: ETHtoAdd} (\r\n                  contrAddr,\r\n                  tokenToAdd,\r\n                  0,\r\n                  0,\r\n                  contrAddr,\r\n                  block.timestamp + 100\r\n                  );\r\n\r\n                liqAdded[lastBUYINday] = true; \r\n                  \r\n                uint256 ethBal = contrAddr.balance;\r\n                \r\n                if (ethBal > 0.01 ether) {\r\n                  uint256 currentLiqRatio = addedToken.mul(1e18).div(addedEth);\r\n                  uint256 neededToken = currentLiqRatio.mul(ethBal).div(1e18);\r\n\r\n                  _mint(contrAddr, neededToken);\r\n\r\n                    _pancakeRouter.addLiquidityETH {value: ethBal} (\r\n                    contrAddr,\r\n                    neededToken,\r\n                    0,\r\n                    0,\r\n                    contrAddr,\r\n                    block.timestamp + 100\r\n                    );\r\n\r\n                uint256 leftOverToken = IERC20(contrAddr).balanceOf(contrAddr);\r\n\r\n                if (leftOverToken > 1000 ether){\r\n                    transferToZero(leftOverToken.sub(1 ether));\r\n                }\r\n\r\n                }                \r\n\r\n            }\r\n          }\r\n\r\n          currentDay = thisDay();\r\n\r\n          if (tradingPair == address(0)){\r\n            tradingPair = _pancakeFactory.getPair(_pancakeRouter.WETH(), contrAddr);\r\n          }\r\n\r\n          lpBal = IERC20(tradingPair).balanceOf(contrAddr);\r\n\r\n          if (lpBal > 1000) { \r\n            burnAndBuyback();    \r\n          }\r\n      }\r\n    }\r\n\r\n    // to make the contract being able to receive ETH from Router\r\n    receive() external payable {}\r\n\r\n    // function to remove some of the collected LP, and use funds to buyback and burn token, daily\r\n    function burnAndBuyback () internal {   \r\n\r\n        if( IERC20(tradingPair).allowance(contrAddr, _pancakeRouterAddress ) == 0) {\r\n         IERC20(tradingPair).approve(_pancakeRouterAddress, type(uint256).max);\r\n        }\r\n\r\n        uint256 lpBalToRemove = lpBal.mul(buyBackPerecent).div(1000);\r\n\r\n        uint256 ethBalBefore = contrAddr.balance;\r\n\r\n        // remove X% of the colected Liq daily to buyback Token\r\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n          contrAddr,\r\n          lpBalToRemove,\r\n          0,\r\n          0,\r\n          contrAddr,\r\n          block.timestamp +100\r\n        );\r\n\r\n        uint256 ethGain = contrAddr.balance.sub(ethBalBefore);\r\n        usedETHforBuyBack += ethGain;\r\n\r\n          address[] memory path = new address[](2);\r\n          path[0] = _pancakeRouter.WETH();\r\n          path[1] = contrAddr;\r\n\r\n          // Buyback token from LP from received ETH\r\n          _pancakeRouter.swapExactETHForTokens { value: ethGain } (\r\n          0,\r\n          path,\r\n          address(0),\r\n          block.timestamp +100\r\n        );\r\n\r\n        // Burn Token received from Liq removal\r\n        uint256 receivedToken = IERC20(contrAddr).balanceOf(contrAddr);\r\n            if (receivedToken > 1000 ether){\r\n              transferToZero(receivedToken);\r\n            }      \r\n    }\r\n\r\n    // function to set the amount of days that need to pass after laucnch to allow new auction entries\r\n    function setOffDays (uint32 _offDays) external onlyDev {\r\n      offDays = _offDays;\r\n    }\r\n\r\n    // function for users to participate in the daily auctions\r\n    function buyShareFromAuction () external payable returns (bool) {\r\n        uint256 rawAmount = msg.value;\r\n        require(rawAmount > 0, \"No ETH to buy Shares!\");\r\n        require(block.timestamp >= LAUNCH_TIME + offDays, \"Auctions have not starded now!\");\r\n\r\n        _dev.transfer(rawAmount.mul(devAuctionFee).div(100)); // transfer dev share of ETH to dev\r\n\r\n        if ( currentDay == 0) {\r\n          currentDay = thisDay();\r\n        }\r\n\r\n        updateDaily();\r\n\r\n        auctionEntry[currentDay] += rawAmount;\r\n        auctionEntry_allDays += rawAmount;\r\n        lastBUYINday = currentDay;\r\n        liqAdded[currentDay] = false;\r\n    \r\n        if (mapMemberAuction[msg.sender][currentDay].memberAuctionValue == 0) {\r\n            usersCount++;\r\n            usersCountDaily[currentDay]++;\r\n        }\r\n\r\n        mapMemberAuction_overallData[msg.sender].total_auctionEnteries += rawAmount;\r\n\r\n        mapMemberAuction[msg.sender][currentDay].memberAuctionValue += rawAmount; \r\n        mapMemberAuction[msg.sender][currentDay].memberAuctionEntryDay = currentDay;\r\n        mapMemberAuction[msg.sender][currentDay].hasChangedShareToToken = false;      \r\n\r\n        emit EnterAuction (msg.sender, rawAmount, block.timestamp);\r\n        return true;        \r\n    }\r\n\r\n\r\n    function calculateTokenPerShareOnDay (uint256 _day) public view returns (uint256) {\r\n      uint256 collectedThatDay = auctionEntry[_day];\r\n      uint256 tokenPerShare = dayliAvailableToken.mul(1e18).div(collectedThatDay);\r\n      return tokenPerShare;\r\n    }\r\n\r\n    // function for users to change their shares from last day into token and immediately stakeInt\r\n    function claimTokenFromSharesAndStake (uint256 _day, uint256 _referer) external returns (bool) {\r\n      require(_day < currentDay, \"Day must be over to claim!\");\r\n      require(mapMemberAuction[msg.sender][_day].hasChangedShareToToken == false, \"User has already Changed his shares to Token that Day!\");\r\n      uint256 userShares = mapMemberAuction[msg.sender][_day].memberAuctionValue; \r\n\r\n      uint256 amountUserTokens = calculateTokenPerShareOnDay(_day).mul(userShares).div(1e18);      \r\n\r\n        if(refCodeToAddress[_referer] != address(0) || myRef[msg.sender] != address(0)){\r\n            if(myRef[msg.sender] == address(0)){\r\n            myRef[msg.sender] = refCodeToAddress[_referer];\r\n            }\r\n            // eared ref token are accounted for the next day so be sure ref can claim all past days token at once\r\n            mapRefData[myRef[msg.sender]][_day + 1].refEarnedTokens += amountUserTokens.mul(5).div(100);\r\n        }\r\n\r\n      stakeInt(amountUserTokens);\r\n\r\n      mapMemberAuction[msg.sender][_day].hasChangedShareToToken = true;\r\n\r\n      updateDaily();\r\n\r\n      return true;\r\n    }\r\n\r\n    // function for refs to claim the past days tokens and stakeInt them fee free\r\n    function claimRefTokensAndStake (uint256 _day) external returns (bool) {\r\n      require(_day < currentDay, \"Refs Day must be over to claim!\");\r\n      require(mapRefData[msg.sender][_day].refEarnedTokens != 0, \"Ref has not earned Token that day!\");\r\n\r\n      uint256 refTokens = mapRefData[msg.sender][_day].refEarnedTokens;\r\n\r\n      refStake(refTokens);\r\n\r\n      mapRefData[msg.sender][_day].refEarnedTokens = 0;\r\n\r\n      updateDaily();\r\n\r\n      return true;\r\n    }\r\n\r\n\r\n    // only called when claim (collect) is called\r\n    // calculates the earned rewards since LAST UPDATE\r\n    // earning is 1% per day\r\n    // earning stopps after 365 days\r\n    function calcReward (address _user, uint256 _stakeIndex) public view returns (uint256) {\r\n      if(stakes[_user][_stakeIndex].stakeTime == 0){\r\n        return 0;\r\n      }\r\n      // value 11574074074074 gives 1 ether per day as multiplier!\r\n      uint256 multiplier = (block.timestamp - stakes[_user][_stakeIndex].lastUpdate).mul(weiPerSfor1perDay);\r\n      // for example: if user amount is 100 and user has staked for 365 days and not collected so far,\r\n      // reward would be 365, if 365 was already collected reward will be 0\r\n      if(stakes[_user][_stakeIndex].amount.mul(multiplier).div(100 ether).add(stakes[_user][_stakeIndex].collected) > \r\n         stakes[_user][_stakeIndex].amount.mul(365).div(100)) {\r\n        return(stakes[_user][_stakeIndex].amount.mul(365).div(100).sub(stakes[_user][_stakeIndex].collected));\r\n      }\r\n      // in same example: below 365 days of stakeInt the reward is stakes.amount * days/100\r\n      return stakes[_user][_stakeIndex].amount.mul(multiplier).div(100 ether);\r\n    }\r\n\r\n\r\n    // (not called internally) Only for viewing the earned rewards in UI\r\n    // caculates claimable rewards\r\n    function calcClaim (address _user, uint256 _stakeIndex) external view returns (uint256) {\r\n      if (stakes[_user][_stakeIndex].stakeTime == 0){\r\n        return 0;\r\n      }\r\n      // value 11574074074074 gives 1 ether per day as multiplier!\r\n      uint256 multiplier = (block.timestamp - stakes[_user][_stakeIndex].lastUpdate).mul(weiPerSfor1perDay);\r\n\r\n      if (multiplier.mul(stakes[_user][_stakeIndex].amount).div(100 ether).add(stakes[_user][_stakeIndex].collected) >\r\n        stakes[_user][_stakeIndex].amount.mul(365).div(100)){\r\n        return(stakes[_user][_stakeIndex].amount.mul(365).div(100).sub(stakes[_user][_stakeIndex].claimed));\r\n      }\r\n      return stakes[_user][_stakeIndex].amount.mul(multiplier).div(100 ether).add(stakes[_user][_stakeIndex].collected)\r\n      .sub(stakes[_user][_stakeIndex].claimed);\r\n    }\r\n\r\n    // calculate the Fee in to pe paid to be able to claim the rewards\r\n    function calcClaimFee (address _user, uint256 _stakeIndex) public view returns (uint256) {\r\n      if (stakes[_user][_stakeIndex].stakeTime == 0 || stakes[_user][_stakeIndex].freeClaiming == true) {\r\n        return 0;\r\n      }\r\n      uint256 weeksOfStake = (block.timestamp - stakes[_user][_stakeIndex].stakeTime) / oneWeek;\r\n      uint256 additionalClaimFee = weeksOfStake.mul(feePerWeek);\r\n      uint256 totalClaimFee = stakes[_user][_stakeIndex].claimingStartFee.add(additionalClaimFee);\r\n      // if stakeInt is older than 52 weeks, fee will be 2*52 - feePaid.\r\n      if (totalClaimFee > maxTotlFee) {\r\n        return maxTotlFee.sub(stakes[_user][_stakeIndex].feePaid);\r\n      }\r\n      return stakes[_user][_stakeIndex].claimingStartFee.add(additionalClaimFee).sub(stakes[_user][_stakeIndex].feePaid);\r\n    }\r\n\r\n    // function to update the collected rewards to user stakeInt collected value and update the last updated value\r\n    function _collect (address _user, uint256 _stakeIndex) internal {\r\n      stakes[_user][_stakeIndex].collected = stakes[_user][_stakeIndex].collected.add(calcReward(_user, _stakeIndex));\r\n      stakes[_user][_stakeIndex].lastUpdate = block.timestamp;\r\n    }\r\n\r\n    // function for users to claim rewards and also pay claim fee\r\n    function claimRewards (uint256 _stakeIndex) external {\r\n       uint256 feeToPay = calcClaimFee(msg.sender,_stakeIndex);\r\n      // if fee for staking has to be paid AND there is fee to be paid\r\n      if (feeToPay > 0) {\r\n        require(IERC20(USDCaddress).allowance(msg.sender, contrAddr) >= feeToPay, \"Approval to spend USDC is needed!\");\r\n        require(IERC20(USDCaddress).balanceOf(msg.sender) >= feeToPay, \"Not enough USDC in wallet!\");\r\n        IERC20(USDCaddress).transferFrom(msg.sender, _dev1, feeToPay);\r\n        stakes[msg.sender][_stakeIndex].feePaid = stakes[msg.sender][_stakeIndex].feePaid.add(feeToPay);        \r\n      }\r\n\r\n      _collect(msg.sender, _stakeIndex);\r\n      uint256 reward = stakes[msg.sender][_stakeIndex].collected.sub(stakes[msg.sender][_stakeIndex].claimed);\r\n      stakes[msg.sender][_stakeIndex].claimed = stakes[msg.sender][_stakeIndex].collected;\r\n      _mint(msg.sender, reward);\r\n      overallCollectedDividends += reward;\r\n\r\n      emit ClaimRewards (msg.sender, reward, block.timestamp);\r\n    }\r\n\r\n    // function for users to create a new stakeInt from earnings of another stakeInt\r\n    function reinvest(uint256 _stakeIndex) external {\r\n      uint256 feeToPay = calcClaimFee(msg.sender,_stakeIndex);\r\n      // if fee for staking has to be paid AND there is fee to be paid\r\n      if (feeToPay > 0) {\r\n        require(IERC20(USDCaddress).allowance(msg.sender, contrAddr) >= feeToPay, \"Approval to spend USDC is needed!\");\r\n        require(IERC20(USDCaddress).balanceOf(msg.sender) >= feeToPay, \"Not enough USDC in wallet!\");\r\n        IERC20(USDCaddress).transferFrom(msg.sender, _dev1, feeToPay);\r\n        stakes[msg.sender][_stakeIndex].feePaid = stakes[msg.sender][_stakeIndex].feePaid.add(feeToPay);        \r\n      }\r\n\r\n      _collect(msg.sender, _stakeIndex); // collected amount and lastUpdate gets updated\r\n      // calculate Reward = _amount\r\n      uint256 _amount = stakes[msg.sender][_stakeIndex].collected.sub(stakes[msg.sender][_stakeIndex].claimed);\r\n      \r\n      // new stakeInt is opened with reward = _amount of \"old\" stakeInt!\r\n      stakeInt(_amount);\r\n      overallCollectedDividends += _amount;\r\n      // the the \"old\" stakeInt of which the rewards were reinvested in a new stakeInt gets updated!\r\n      stakes[msg.sender][_stakeIndex].claimed = stakes[msg.sender][_stakeIndex].collected;\r\n\r\n      if(myRef[msg.sender] != address(0)){\r\n        _mint(_dev, _amount.mul(5).div(100)); // 5% for dev\r\n        // eared ref token are accounted for the next day so be sure ref can claim all past days token at once\r\n        mapRefData[myRef[msg.sender]][currentDay + 1].refEarnedTokens += _amount.mul(5).div(100); // 5% for referrer\r\n      }\r\n      else{\r\n        _mint(_dev, _amount.mul(5).div(100)); // 5% for dev\r\n      }\r\n\r\n      updateDaily();\r\n      emit ClaimRewards (msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryTime\",\"type\":\"uint256\"}],\"name\":\"EnterAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"}],\"name\":\"Sake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LAUNCH_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDCaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_dev1\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_devMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_setterDev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionEntry_allDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyAndStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackPerecent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyShareFromAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calcClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calcClaimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calcReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"calculateTokenPerShareOnDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"claimRefTokensAndStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referer\",\"type\":\"uint256\"}],\"name\":\"claimTokenFromSharesAndStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contrAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createRefCode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAuctionFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devDiscountedBuyFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePerWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountFromLiq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isExcludedFromTaxReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBUYINday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liqAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapMemberAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"memberAuctionValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memberAuctionEntryDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasChangedShareToToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapMemberAuction_overallData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"overall_collectedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_auctionEnteries\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overall_stakedTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapRefData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"refEarnedTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"myRef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offDays\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overallCollectedDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overallStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentToReceive\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refAddresstoCode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refCodeToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_auctionEntry_allDays\",\"type\":\"uint256\"}],\"name\":\"setAuctionEntry_allDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_buyBackPerecent\",\"type\":\"uint8\"}],\"name\":\"setBuyBackPerecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_devAuctionFee\",\"type\":\"uint8\"}],\"name\":\"setDevAuctionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_devDiscountedBuyFee\",\"type\":\"uint8\"}],\"name\":\"setDevDiscountedBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dev\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"dev1\",\"type\":\"address\"}],\"name\":\"setDevs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromTaxReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"setLaunchTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_offDays\",\"type\":\"uint32\"}],\"name\":\"setOffDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setOverallStakedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_percentToReceive\",\"type\":\"uint8\"}],\"name\":\"setPercentToReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSettingDone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_stakeNumber\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastUpdate\",\"type\":\"uint256\"}],\"name\":\"setStakesRefs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_stakeNumber\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feePaid\",\"type\":\"uint256\"}],\"name\":\"setStakesUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_taxFactor\",\"type\":\"uint8\"}],\"name\":\"setTaxFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_stakeNumber\",\"type\":\"uint8\"}],\"name\":\"setUsersStakeNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settingDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collected\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"freeClaiming\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimingStartFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxFactor\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thisDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDaily\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usedETHforBuyBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersCountDaily\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WhalesCandy", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://de68258a4e4c2fa41d182f23be029f7b5bb1c732876f2d6527a60b98b54480f4"}