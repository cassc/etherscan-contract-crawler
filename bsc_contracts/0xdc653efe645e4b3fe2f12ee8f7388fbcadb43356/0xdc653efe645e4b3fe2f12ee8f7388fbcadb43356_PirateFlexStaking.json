{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PirateFlexStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.11;\\n// SPDX-License-Identifier: MIT\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\ncontract PirateFlexStaking is Ownable {\\n    IERC20 public rewardToken;\\n    uint256 intervalBetweenBlocksInseconds = 3;\\n\\n    // Info of each user\\n    struct UserInfo {\\n        uint256 start;\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // This number always increases to counterwaight always increasing \\\"accTokenPerShare\\\"\\n        bool isStaking;\\n    }\\n\\n    // Info of a pool\\n    struct PoolInfo {\\n        uint256 rate;\\n        uint256 lastRewardBlock; // Last block number that CAKEs distribution occurs.\\n        uint256 accTokenPerShare; // Accumulated CAKEs per share, times 1e12. See below.\\n        uint256 totalStaked;\\n        uint256 rewardPool;\\n        uint256 poolAddedBlockNumber;\\n        uint256 blocksAmount;\\n    }\\n\\n    PoolInfo public pool;\\n    mapping(address => UserInfo) public userInfo;\\n    uint256 public amountOfUsers = 0;\\n\\n    event Stake(address indexed user, uint256 amount);\\n    event Unstake(address indexed user, uint256 amount);\\n\\n    constructor(address _rewardToken) {\\n        rewardToken = IERC20(_rewardToken);\\n        _initPool();\\n    }\\n\\n    /// @dev Receives tokens and sets parameters\\n    /// @param amount amount of staking tokens\\n    function stake(uint256 amount) external {\\n        UserInfo storage user = userInfo[msg.sender];\\n        require(user.amount == 0, 'already staking');\\n        require(amount > 0, 'Nothing to stake');\\n        require(pool.rewardPool > 0, 'reward pool is empty'); // rates did not set\\n        updatePool();\\n        require(rewardToken.transferFrom(msg.sender, address(this), amount));\\n        pool.totalStaked += amount; // 2)\\n        userInfo[msg.sender] = UserInfo({\\n            start: block.timestamp,\\n            amount: amount,\\n            rewardDebt: ((amount * pool.accTokenPerShare)) / 1e12,\\n            isStaking: true\\n        });\\n        amountOfUsers++;\\n        emit Stake(msg.sender, amount);\\n    }\\n\\n    /// @dev Transfers tokens to user with reward\\n    function unstake() external {\\n        UserInfo storage user = userInfo[msg.sender];\\n        require(user.isStaking, 'User did not stake tokens');\\n        updatePool();\\n        uint256 reward = ((user.amount * pool.accTokenPerShare) / 1e12) - user.rewardDebt;\\n        pool.totalStaked -= user.amount;\\n        require(rewardToken.transfer(msg.sender, reward + user.amount));\\n\\n        delete userInfo[msg.sender];\\n        amountOfUsers--;\\n        emit Unstake(msg.sender, reward);\\n    }\\n\\n    /// @dev Updates reward variables of the given pool to be up-to-date.\\n    function updatePool() public {\\n        if (block.number <= pool.lastRewardBlock) return;\\n        if (pool.totalStaked == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        pool.accTokenPerShare +=\\n            (((block.number - pool.lastRewardBlock) * pool.rate * 1e12 * 1e18) / 1000) /\\n            pool.totalStaked;\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    /// @dev Receives reward token and increasing reward pool of selected pool\\n    /// @param blocksAmount amount of blocks to airdrop all pool\\n    /// @param amount amount of reward tokens to increase the pool\\n    function increaseRewardPool(uint256 blocksAmount, uint256 amount) external onlyOwner {\\n        require(rewardToken.transferFrom(msg.sender, address(this), amount));\\n        require(blocksAmount != 0, 'zero period');\\n        /* if reward pool and period did not pass\\n       and owner wants to add liquidity,\\n       than calculates ramaning current reward pool\\n       and adding it to reward pool owner wants to add\\n       */\\n\\n        if (block.number < (pool.blocksAmount + pool.poolAddedBlockNumber)) {\\n            // adding new added amount to not airdroped reward pool\\n            amount +=\\n                pool.rewardPool -\\n                ((pool.rate * 10**18 * (block.number - pool.poolAddedBlockNumber)) /\\n                    1000);\\n        }\\n\\n        pool.rewardPool = amount;\\n        pool.poolAddedBlockNumber = block.number;\\n        pool.blocksAmount = blocksAmount;\\n        // new period starts from now with not airdropped pool and new added amount\\n        _set(blocksAmount, amount);\\n    }\\n\\n    /// @dev Changes rates of selected pool\\n    /// @param blocksAmount amount of blocks to airdrop all pool\\n    /// @param rewardPool amount of reward pool\\n    function _set(uint256 blocksAmount, uint256 rewardPool) internal {\\n        updatePool();\\n        pool.rate = _calcRate(blocksAmount, rewardPool);\\n        require(pool.rate < 1e6, 'Overflow prevention');\\n    }\\n\\n    /// @dev Calculates lp tokens reward\\n    /// @param who staking user\\n    /// @return lp token reward amount\\n    function pendingReward(address who) external view returns (uint256) {\\n        UserInfo storage user = userInfo[who];\\n        uint256 accTokenPerShare = pool.accTokenPerShare;\\n        if (block.number > pool.lastRewardBlock && pool.totalStaked != 0) {\\n            accTokenPerShare +=\\n                ((block.number - pool.lastRewardBlock) * pool.rate * 1e12 * 1e18) /\\n                1000 /\\n                pool.totalStaked;\\n        }\\n        return ((user.amount * accTokenPerShare) / 1e12) - user.rewardDebt;\\n    }\\n\\n    /// @dev Creates pool\\n    function _initPool() internal {\\n        pool = PoolInfo({\\n            rate: 0,\\n            lastRewardBlock: block.number,\\n            accTokenPerShare: 0,\\n            totalStaked: 0,\\n            rewardPool: 0,\\n            poolAddedBlockNumber: 0,\\n            blocksAmount: 0\\n        });\\n    }\\n\\n    /// @dev Calculates token reward per block based on reward pool and airdrop blocksAmount\\n    /// @param blocksAmount amount of block for which all rewards will be airdroped\\n    /// @param rewardPool reward token to be airdroped during period\\n    /// @return token per block nomerator, where denominator is always 1000\\n    function _calcRate(uint256 blocksAmount, uint256 rewardPool)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(\\n            (rewardPool * 1000) / blocksAmount > 100 * 10**18,\\n            'To low rewards pool or to short period'\\n        );\\n        return (rewardPool * 1000) / (blocksAmount) / 10**18;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"amountOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocksAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAddedBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocksAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStaking\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PirateFlexStaking", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000093c27727e72ec7510a06ea450366c1418c4ce547", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}