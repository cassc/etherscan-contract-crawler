{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BridgeOutInterface.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBridgeOut {\\n    function deposit(\\n        bytes32 swapHashId,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function withdraw(\\n        bytes32 swapHashId,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function restart() external;\\n\\n    function pause() external;\\n\\n    function getSwapId(\\n        address token,\\n        string calldata fromChainId\\n    ) external view returns(bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BridgeInLibrary.sol\": {\r\n      \"content\": \"pragma solidity 0.8.9;\\n\\nimport './StringHex.sol';\\n\\nlibrary BridgeInLibrary {\\n  using StringHex for bytes32;\\n\\n  function _generateTokenKey(address token, string memory chainId) public pure returns (bytes32) {\\n    return sha256(abi.encodePacked(token, chainId));\\n  }\\n\\n  function _generateReceiptId(\\n    bytes32 tokenKey,\\n    string memory suffix\\n  ) public pure returns (string memory) {\\n    string memory prefix = tokenKey.toHex();\\n    string memory separator = '.';\\n    return string(abi.encodePacked(prefix, separator, suffix));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DailyLimiter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.9;\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\nlibrary DailyLimiter {\\n  using SafeMath for uint256;\\n\\n  error DailyLimitExceeded(uint256 dailyLimit, uint256 amount);\\n  event DailyLimitSet(DailyLimitConfig config);\\n  event TokenDailyLimitConsumed(address tokenAddress, uint256 amount);\\n\\n  struct DailyLimitTokenInfo {\\n    uint256 tokenAmount;\\n    uint32 refreshTime;\\n    uint256 defaultTokenAmount;\\n  }\\n\\n  struct DailyLimitConfig {\\n    bytes32 dailyLimitId; //tokenKey/swapId\\n    uint32 refreshTime;\\n    uint256 defaultTokenAmount;\\n  }\\n\\n  uint32 constant DefaultRefreshTime = 86400;\\n\\n  function _setDailyLimit(\\n    DailyLimitTokenInfo storage _dailyLimitTokenInfo,\\n    DailyLimitConfig memory _config\\n  ) internal {\\n    require((uint256)(_config.refreshTime).mod(DefaultRefreshTime) == 0, 'Invalid refresh time.');\\n    require(\\n      block.timestamp >= _config.refreshTime &&\\n        (block.timestamp.sub(_config.refreshTime)) <= DefaultRefreshTime,\\n      'Only daily limits are supported within the contract.'\\n    );\\n    if (\\n      _dailyLimitTokenInfo.refreshTime != 0 &&\\n      (block.timestamp.sub(_dailyLimitTokenInfo.refreshTime)).div(DefaultRefreshTime) < 1\\n    ) {\\n      uint256 defaultTokenAmount = _dailyLimitTokenInfo.defaultTokenAmount;\\n      uint256 currentTokenAmount = _dailyLimitTokenInfo.tokenAmount;\\n      uint256 useAmount = defaultTokenAmount.sub(currentTokenAmount);\\n      _dailyLimitTokenInfo.tokenAmount = _config.defaultTokenAmount <= useAmount\\n        ? 0\\n        : _config.defaultTokenAmount.sub(useAmount);\\n    } else {\\n      _dailyLimitTokenInfo.tokenAmount = _config.defaultTokenAmount;\\n    }\\n    _dailyLimitTokenInfo.defaultTokenAmount = _config.defaultTokenAmount;\\n    _dailyLimitTokenInfo.refreshTime = _config.refreshTime;\\n    emit DailyLimitSet(_config);\\n  }\\n\\n  function _consume(\\n    DailyLimitTokenInfo storage _dailyLimitTokenInfo,\\n    address _tokenAddress,\\n    uint256 _amount\\n  ) internal {\\n    (uint32 _refreshTime, uint256 _tokenAmount) = _refreshCurrentTokenAmount(\\n      _dailyLimitTokenInfo.refreshTime,\\n      _dailyLimitTokenInfo.tokenAmount,\\n      _dailyLimitTokenInfo.defaultTokenAmount\\n    );\\n    _dailyLimitTokenInfo.refreshTime = _refreshTime;\\n    if (_amount > _tokenAmount) {\\n      revert DailyLimitExceeded(_tokenAmount, _amount);\\n    }\\n    _tokenAmount = _tokenAmount.sub(_amount);\\n    _dailyLimitTokenInfo.tokenAmount = _tokenAmount;\\n    emit TokenDailyLimitConsumed(_tokenAddress, _amount);\\n  }\\n\\n  function _currentDailyLimit(\\n    DailyLimitTokenInfo memory _dailyLimitTokenInfo\\n  ) internal view returns (DailyLimitTokenInfo memory) {\\n    (uint32 _refreshTime, uint256 _tokenAmount) = _refreshCurrentTokenAmount(\\n      _dailyLimitTokenInfo.refreshTime,\\n      _dailyLimitTokenInfo.tokenAmount,\\n      _dailyLimitTokenInfo.defaultTokenAmount\\n    );\\n    _dailyLimitTokenInfo.refreshTime = _refreshTime;\\n    _dailyLimitTokenInfo.tokenAmount = _tokenAmount;\\n    return _dailyLimitTokenInfo;\\n  }\\n\\n  function _refreshCurrentTokenAmount(\\n    uint256 _lastRefreshTime,\\n    uint256 _tokenAmount,\\n    uint256 _defaultAmount\\n  ) private view returns (uint32, uint256) {\\n    uint256 count = (block.timestamp.sub(_lastRefreshTime)).div(DefaultRefreshTime);\\n    uint32 lastRefreshTime = uint32(_lastRefreshTime);\\n    uint256 tokenAmount = _tokenAmount;\\n    if (count > 0) {\\n      lastRefreshTime = uint32(_lastRefreshTime.add((uint256)(DefaultRefreshTime).mul(count)));\\n      tokenAmount = _defaultAmount;\\n    }\\n    return (lastRefreshTime, tokenAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RateLimiter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.9;\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\nlibrary RateLimiter {\\n  using SafeMath for uint256;\\n\\n  error BucketOverfilled();\\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\\n  error MaxCapacityExceeded(uint256 capacity, uint256 amount);\\n  event TokensConsumed(address tokenAddress, uint256 amount);\\n  event ConfigChanged(TokenBucketConfig config);\\n\\n  struct TokenBucket {\\n    uint128 currentTokenAmount;\\n    uint32 lastUpdatedTime;\\n    bool isEnabled;\\n    uint128 tokenCapacity;\\n    uint128 rate;\\n  }\\n\\n  struct TokenBucketConfig {\\n    bytes32 bucketId; //tokenKey/swapId\\n    bool isEnabled;\\n    uint128 tokenCapacity;\\n    uint128 rate;\\n  }\\n\\n  function _consume(\\n    TokenBucket storage _tokenBucket,\\n    address _tokenAddress,\\n    uint256 _amount\\n  ) internal {\\n    if (!_tokenBucket.isEnabled) {\\n      return;\\n    }\\n    uint256 currentTokenAmount = _tokenBucket.currentTokenAmount;\\n    uint256 capacity = _tokenBucket.tokenCapacity;\\n    uint256 timeDiff = block.timestamp.sub(_tokenBucket.lastUpdatedTime);\\n    if (timeDiff != 0) {\\n      if (currentTokenAmount > capacity) revert BucketOverfilled();\\n      currentTokenAmount = _calculateTokenRefill(\\n        capacity,\\n        currentTokenAmount,\\n        _tokenBucket.rate,\\n        timeDiff\\n      );\\n      _tokenBucket.lastUpdatedTime = uint32(block.timestamp);\\n    }\\n    if (capacity < _amount) {\\n      revert MaxCapacityExceeded(capacity, _amount);\\n    }\\n    if (currentTokenAmount < _amount) {\\n      uint256 rate = _tokenBucket.rate;\\n      uint256 minWaitInSeconds = ((_amount.sub(currentTokenAmount)).add(rate.sub(1))).div(rate);\\n      revert TokenRateLimitReached(minWaitInSeconds, _amount, _tokenAddress);\\n    }\\n    currentTokenAmount = currentTokenAmount.sub(_amount);\\n\\n    _tokenBucket.currentTokenAmount = uint128(currentTokenAmount);\\n    emit TokensConsumed(_tokenAddress, _amount);\\n  }\\n\\n  function _configTokenBucket(\\n    TokenBucket storage _tokenBucket,\\n    TokenBucketConfig memory _config\\n  ) internal {\\n    if (_tokenBucket.lastUpdatedTime != 0) {\\n      uint256 timeDiff = block.timestamp.sub(_tokenBucket.lastUpdatedTime);\\n      if (timeDiff != 0) {\\n        _tokenBucket.currentTokenAmount = uint128(\\n          _calculateTokenRefill(\\n            _tokenBucket.tokenCapacity,\\n            _tokenBucket.currentTokenAmount,\\n            _tokenBucket.rate,\\n            timeDiff\\n          )\\n        );\\n        _tokenBucket.lastUpdatedTime = uint32(block.timestamp);\\n      }\\n      _tokenBucket.currentTokenAmount = uint128(\\n        _min(_config.tokenCapacity, _tokenBucket.currentTokenAmount)\\n      );\\n    } else {\\n      _tokenBucket.currentTokenAmount = _config.tokenCapacity;\\n      _tokenBucket.lastUpdatedTime = uint32(block.timestamp);\\n    }\\n    _tokenBucket.tokenCapacity = _config.tokenCapacity;\\n    _tokenBucket.isEnabled = _config.isEnabled;\\n    _tokenBucket.rate = _config.rate;\\n    emit ConfigChanged(_config);\\n  }\\n\\n  function _currentTokenBucketState(\\n    TokenBucket memory _tokenBucket\\n  ) internal view returns (TokenBucket memory) {\\n    _tokenBucket.currentTokenAmount = uint128(\\n      _calculateTokenRefill(\\n        _tokenBucket.tokenCapacity,\\n        _tokenBucket.currentTokenAmount,\\n        _tokenBucket.rate,\\n        block.timestamp.sub(_tokenBucket.lastUpdatedTime)\\n      )\\n    );\\n    _tokenBucket.lastUpdatedTime = uint32(block.timestamp);\\n    return _tokenBucket;\\n  }\\n\\n  function _calculateTokenRefill(\\n    uint256 capacity,\\n    uint256 currentTokenAmount,\\n    uint256 rate,\\n    uint256 timeDiff\\n  ) private pure returns (uint256) {\\n    return _min(capacity, currentTokenAmount.add(timeDiff.mul(rate)));\\n  }\\n\\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StringHex.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringHex {\\n    function toHex16(bytes16 data) internal pure returns (bytes32 result) {\\n        result =\\n            (bytes32(data) &\\n                0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000) |\\n            ((bytes32(data) &\\n                0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >>\\n                64);\\n        result =\\n            (result &\\n                0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000) |\\n            ((result &\\n                0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >>\\n                32);\\n        result =\\n            (result &\\n                0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000) |\\n            ((result &\\n                0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >>\\n                16);\\n        result =\\n            (result &\\n                0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000) |\\n            ((result &\\n                0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >>\\n                8);\\n        result =\\n            ((result &\\n                0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >>\\n                4) |\\n            ((result &\\n                0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >>\\n                8);\\n        result = bytes32(\\n            0x3030303030303030303030303030303030303030303030303030303030303030 +\\n                uint256(result) +\\n                (((uint256(result) +\\n                    0x0606060606060606060606060606060606060606060606060606060606060606) >>\\n                    4) &\\n                    0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) *\\n                39\\n        );\\n    }\\n\\n    function toHex(bytes32 data) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"0x\\\",\\n                    toHex16(bytes16(data)),\\n                    toHex16(bytes16(data << 128))\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LimiterImplementation.sol\": {\r\n      \"content\": \"pragma solidity 0.8.9;\\n\\nimport {RateLimiter} from './libraries/RateLimiter.sol';\\nimport {DailyLimiter} from './libraries/DailyLimiter.sol';\\nimport './libraries/BridgeInLibrary.sol';\\nimport './Proxy.sol';\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport './interfaces/BridgeOutInterface.sol';\\n\\ncontract LimiterImplementation is ProxyStorage {\\n  using DailyLimiter for DailyLimiter.DailyLimitTokenInfo;\\n  using RateLimiter for RateLimiter.TokenBucket;\\n  using SafeMath for uint256;\\n\\n  // key: tokenKey / swapId\\n  mapping(bytes32 => RateLimiter.TokenBucket) private tokenBucket;\\n  mapping(bytes32 => DailyLimiter.DailyLimitTokenInfo) private dailyLimit;\\n  address public admin;\\n  address public bridgeIn;\\n  address public bridgeOut;\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == admin, 'no permission');\\n    _;\\n  }\\n  modifier onlyBridge() {\\n    require(msg.sender == bridgeIn || msg.sender == bridgeOut, 'no permission');\\n    _;\\n  }\\n\\n  function changeAdmin(address _admin) external onlyAdmin{\\n    require(_admin != address(0), \\\"invalid input\\\");\\n    admin = _admin;\\n  }\\n\\n  function initialize(address _bridgeIn, address _bridgeOut, address _admin) external onlyOwner {\\n    require(bridgeIn == address(0), 'already initialized');\\n    bridgeIn = _bridgeIn;\\n    bridgeOut = _bridgeOut;\\n    admin = _admin;\\n  }\\n\\n  function consumeDailyLimit(\\n    bytes32 dailyLimitId,\\n    address tokenAddress,\\n    uint256 amount\\n  ) external onlyBridge {\\n    dailyLimit[dailyLimitId]._consume(tokenAddress, amount);\\n  }\\n\\n  function consumeTokenBucket(\\n    bytes32 bucketId,\\n    address tokenAddress,\\n    uint256 amount\\n  ) external onlyBridge {\\n    tokenBucket[bucketId]._consume(tokenAddress, amount);\\n  }\\n\\n  function setDailyLimit(\\n    DailyLimiter.DailyLimitConfig[] memory dailyLimitConfigs\\n  ) external onlyAdmin {\\n    for (uint i = 0; i < dailyLimitConfigs.length; i++) {\\n      DailyLimiter.DailyLimitConfig memory dailyLimitConfig = dailyLimitConfigs[i];\\n      dailyLimit[dailyLimitConfig.dailyLimitId]._setDailyLimit(dailyLimitConfig);\\n    }\\n  }\\n\\n  function getReceiptDailyLimit(\\n    address token,\\n    string memory targetChainId\\n  ) public view returns (DailyLimiter.DailyLimitTokenInfo memory) {\\n    bytes32 dailyLimitId = BridgeInLibrary._generateTokenKey(token, targetChainId);\\n    return dailyLimit[dailyLimitId]._currentDailyLimit();\\n  }\\n\\n  function getSwapDailyLimit(\\n    bytes32 swapId\\n  ) public view returns (DailyLimiter.DailyLimitTokenInfo memory) {\\n        return dailyLimit[swapId]._currentDailyLimit();\\n  }\\n\\n  function setTokenBucketConfig(RateLimiter.TokenBucketConfig[] memory configs) external onlyAdmin {\\n    for (uint i = 0; i < configs.length; i++) {\\n      RateLimiter.TokenBucketConfig memory config = configs[i];\\n      tokenBucket[config.bucketId]._configTokenBucket(configs[i]);\\n    }\\n  }\\n\\n  function getCurrentReceiptTokenBucketState(\\n    address token,\\n    string memory targetChainId\\n  ) public view returns (RateLimiter.TokenBucket memory) {\\n    bytes32 bucketId = BridgeInLibrary._generateTokenKey(token, targetChainId);\\n    return tokenBucket[bucketId]._currentTokenBucketState();\\n  }\\n\\n  function getCurrentReceiptTokenBucketStates(\\n    address[] memory tokens,\\n    string[] memory targetChainIds\\n  ) public view returns (RateLimiter.TokenBucket[] memory _tokenBuckets) {\\n    _tokenBuckets = new RateLimiter.TokenBucket[](tokens.length);\\n    for (uint i = 0; i < tokens.length; i++) {\\n      bytes32 bucketId = BridgeInLibrary._generateTokenKey(tokens[i], targetChainIds[i]);\\n      _tokenBuckets[i] = tokenBucket[bucketId]._currentTokenBucketState();\\n    }\\n    return _tokenBuckets;\\n  }\\n\\n  function getCurrentSwapTokenBucketState(\\n    address token,\\n    string memory fromChainId\\n  ) public view returns (RateLimiter.TokenBucket memory) {\\n    bytes32 swapId = IBridgeOut(bridgeOut).getSwapId(token, fromChainId);\\n    return tokenBucket[swapId]._currentTokenBucketState();\\n  }\\n\\n    function getCurrentSwapTokenBucketStates(\\n    address[] memory tokens,\\n    string[] memory fromChainIds\\n  ) public view returns (RateLimiter.TokenBucket[] memory _tokenBuckets) {\\n    _tokenBuckets = new RateLimiter.TokenBucket[](tokens.length);\\n    for (uint i = 0; i < tokens.length; i++) {\\n      bytes32 swapId = IBridgeOut(bridgeOut).getSwapId(tokens[i], fromChainIds[i]);\\n      _tokenBuckets[i] = tokenBucket[swapId]._currentTokenBucketState();\\n    }\\n    return _tokenBuckets;\\n  }\\n\\n  function getReceiptBucketMinWaitSeconds(\\n    uint256 amount,\\n    address token,\\n    string memory targetChainId\\n  ) public view returns (uint256) {\\n    bytes32 bucketId = BridgeInLibrary._generateTokenKey(token, targetChainId);\\n    return getMinWaitSeconds(bucketId,amount);\\n  }\\n\\n  function getSwapBucketMinWaitSeconds(\\n    uint256 amount,\\n    address token,\\n    string memory fromChainId\\n  ) public view returns (uint256) {\\n    bytes32 swapId = IBridgeOut(bridgeOut).getSwapId(token, fromChainId);\\n    return getMinWaitSeconds(swapId,amount);\\n  }\\n\\n  function getMinWaitSeconds(bytes32 bucketId,uint256 amount) private view returns (uint256) {\\n     RateLimiter.TokenBucket memory bucket = tokenBucket[bucketId]._currentTokenBucketState();\\n    if (amount > bucket.currentTokenAmount) {\\n      return\\n        ((amount.sub(bucket.currentTokenAmount)).add(((uint256)(bucket.rate).sub(1)))).div(\\n          bucket.rate\\n        );\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Proxy.sol\": {\r\n      \"content\": \"import \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\npragma solidity 0.8.9;\\n\\ncontract ProxyStorage is Ownable {\\n    address internal _implementation;\\n}\\n\\ncontract Proxy is ProxyStorage {\\n    event ProxyUpdated(address indexed _new, address indexed _old);\\n    event OwnerUpdate(address _prevOwner, address _newOwner);\\n\\n    constructor(address _proxyTo) {\\n        updateImplementation(_proxyTo);\\n    }\\n\\n    function updateImplementation(address _newImplementation) public onlyOwner {\\n        require(_newImplementation != address(0x0), \\\"INVALID_PROXY_ADDRESS\\\");\\n        require(\\n            isContract(_newImplementation),\\n            \\\"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\\\"\\n        );\\n        emit ProxyUpdated(_newImplementation, _implementation);\\n        _implementation = _newImplementation;\\n    }\\n\\n    function implementation() external view returns (address) {\\n        return _implementation;\\n    }\\n\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_target)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/BridgeInLibrary.sol\": {\r\n        \"BridgeInLibrary\": \"0xc473ac86cc41b3b473e4a0d8e84c04fd71d0e71e\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BucketOverfilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dailyLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DailyLimitExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxCapacityExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWaitInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenRateLimitReached\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeIn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeOut\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dailyLimitId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"consumeDailyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bucketId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"consumeTokenBucket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"targetChainId\",\"type\":\"string\"}],\"name\":\"getCurrentReceiptTokenBucketState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"currentTokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"tokenCapacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.TokenBucket\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"targetChainIds\",\"type\":\"string[]\"}],\"name\":\"getCurrentReceiptTokenBucketStates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"currentTokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"tokenCapacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.TokenBucket[]\",\"name\":\"_tokenBuckets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"fromChainId\",\"type\":\"string\"}],\"name\":\"getCurrentSwapTokenBucketState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"currentTokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"tokenCapacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.TokenBucket\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"fromChainIds\",\"type\":\"string[]\"}],\"name\":\"getCurrentSwapTokenBucketStates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"currentTokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdatedTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"tokenCapacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.TokenBucket[]\",\"name\":\"_tokenBuckets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"targetChainId\",\"type\":\"string\"}],\"name\":\"getReceiptBucketMinWaitSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"targetChainId\",\"type\":\"string\"}],\"name\":\"getReceiptDailyLimit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"refreshTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"defaultTokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DailyLimiter.DailyLimitTokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"fromChainId\",\"type\":\"string\"}],\"name\":\"getSwapBucketMinWaitSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapId\",\"type\":\"bytes32\"}],\"name\":\"getSwapDailyLimit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"refreshTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"defaultTokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DailyLimiter.DailyLimitTokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bridgeIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridgeOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"dailyLimitId\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"refreshTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"defaultTokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DailyLimiter.DailyLimitConfig[]\",\"name\":\"dailyLimitConfigs\",\"type\":\"tuple[]\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"bucketId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"tokenCapacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"struct RateLimiter.TokenBucketConfig[]\",\"name\":\"configs\",\"type\":\"tuple[]\"}],\"name\":\"setTokenBucketConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LimiterImplementation", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}