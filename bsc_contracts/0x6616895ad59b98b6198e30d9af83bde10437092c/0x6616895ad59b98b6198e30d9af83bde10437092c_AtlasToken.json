{"SourceCode": "{\"atlas.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender); // added payable\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IEqnoxUtils {\\r\\n    function calcTaxDiscount(address account, uint256 amount) external view returns (uint256);\\r\\n    function isEqnoxStakeValid(address account, bytes16 stakeId) external view returns (bool, string memory);\\r\\n    function userBestEqnoxStake(address account) external view returns(bytes16);\\r\\n}\\r\\n\\r\\ninterface IAtlasPoolMgmt {\\r\\n    function poolReserves() external view returns (uint256 tokenAmount, uint256 busdAmount);\\r\\n    function updatePoolPriceAvgs() external;\\r\\n    function tryIncreasePoolDepth() external;\\r\\n    function addTokensForPoolAccounting(uint256 numTokens) external;\\r\\n    function trySwapTokenFeesForBusd() external;\\r\\n    function tryBuyFromEqnoxAndIncreasePool() external;\\r\\n    function startPool(uint256 busdAmount) external;\\r\\n    function calcOutputAmountSwapAtlasToBusd(uint256 amountAtlas, uint256 taxNum) external view returns (uint256 amountBusd);\\r\\n    function TRADE_TAX() external view returns (uint256);\\r\\n}\\r\\n\\r\\nstruct MAddress {\\r\\n    address account;\\r\\n    uint256 num;\\r\\n    uint256 den;\\r\\n}\\r\\n\\r\\ninterface IAtlasMAddressMgmt {\\r\\n    function addTokensForMktAccounting(uint256 numTokens) external;\\r\\n    function transferMkt() external;\\r\\n}\\r\\n\\r\\nimport \\\"./pool.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract to manage owner access to contract\\r\\n */\\r\\nabstract contract Owner is Context {\\r\\n    address public CONTRACT_DEFINER;\\r\\n    address public POOL_MNGR;\\r\\n\\r\\n    modifier mod_onlyContractDefiner() {\\r\\n        require(msg.sender == CONTRACT_DEFINER, \\\"Wrong sender.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier mod_onlyPoolMngr() {\\r\\n        require(msg.sender == POOL_MNGR, \\\"Wrong sender.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external mod_onlyContractDefiner {\\r\\n        CONTRACT_DEFINER = address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * External function to change the pool manager owner\\r\\n     */\\r\\n    function changePoolMngrOwnership(address newOwner) external mod_onlyPoolMngr {\\r\\n        POOL_MNGR = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract base contract with contract references and addresses\\r\\n */\\r\\nabstract contract Base is Owner {\\r\\n    address public UNISWAP_ROUTER;\\r\\n\\r\\n    IERC20 public BUSD_CONTRACT;\\r\\n    IEqnoxUtils public EQNOX_UTILS_CONTRACT;\\r\\n    IAtlasPoolMgmt public ATLAS_POOL_MGMT;\\r\\n    IAtlasMAddressMgmt public MADDRESS_CONTRACT;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract ERC20Base contract\\r\\n */\\r\\nabstract contract ERC20Base is Base {\\r\\n    mapping(address =\\u003e uint256) internal _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\r\\n    mapping(address =\\u003e bool) internal _isExcluded;\\r\\n    mapping(address =\\u003e bool) internal _isPool;\\r\\n    mapping(address =\\u003e bool) internal _isBanned;\\r\\n\\r\\n    uint256 public extraSupplyForMcapBoost = 0;\\r\\n    uint256 public extraSupplyForInterestBoost = 0;\\r\\n    uint256 public TokensStakedAccounting = 0;\\r\\n\\r\\n    uint256 internal _totalSupply = 0;\\r\\n    uint8 internal _decimals = 18;\\r\\n    string internal _symbol;\\r\\n    string internal _name;\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\nabstract contract ERC20 is ERC20Base {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor(string memory tokenName, string memory tokenSymbol) {\\r\\n        _name = tokenName;\\r\\n        _symbol = tokenSymbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token decimals.\\r\\n     */\\r\\n    function decimals() external view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token name.\\r\\n     */\\r\\n    function name() external view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-totalSupply}.\\r\\n     */\\r\\n    //adds to the internal total supply the extra supply the DAO can establish for marketcap boost\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply \\r\\n        + TokensStakedAccounting\\r\\n        + extraSupplyForMcapBoost;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {BEP20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender].add(addedValue)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {BEP20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender].sub(\\r\\n                subtractedValue,\\r\\n                \\\"BEP20: decreased allowance below zero\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\r\\n\\r\\n        _balances[account] = _balances[account].sub(\\r\\n            amount,\\r\\n            \\\"BEP20: burn amount exceeds balance\\\"\\r\\n        );\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\r\\n     * from the caller\\u0027s allowance.\\r\\n     *\\r\\n     * See {_burn} and {_approve}.\\r\\n     */\\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _burn(account, amount);\\r\\n        _approve(\\r\\n            account,\\r\\n            _msgSender(),\\r\\n            _allowances[account][_msgSender()].sub(\\r\\n                amount,\\r\\n                \\\"BEP20: burn amount exceeds allowance\\\"\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract Data contract with some variables\\r\\n */\\r\\nabstract contract Data is ERC20 {\\r\\n\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e bool)) public userStakes;\\r\\n\\r\\n    //5% buy tax\\r\\n    uint256 public buyTaxNum = 5;\\r\\n    uint256 public buyTaxDen = 100;\\r\\n    //10% sell tax\\r\\n    uint256 public sellTaxNum = 10;\\r\\n    uint256 public sellTaxDen = 100;\\r\\n\\r\\n    uint256 public totalTokensTaxedOnBuys = 0;\\r\\n    uint256 public totalTokenTaxedOnSells = 0;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract with remaining Transfer implementation of ERC20\\r\\n */\\r\\nabstract contract TaxableTransfer is Data {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    bool public IS_TRADING_ACTIVE = false;\\r\\n    bool public IS_BYPASS_ACTIVE = false;\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to call all main accounting functions related to pool mgmt\\r\\n     */ \\r\\n    function updatePoolDepthAndAvgs() public {\\r\\n        if (!IS_BYPASS_ACTIVE) {\\r\\n\\r\\n            bool isTradingActive = IS_TRADING_ACTIVE;\\r\\n            if(!isTradingActive) IS_TRADING_ACTIVE = true;\\r\\n\\r\\n            IS_BYPASS_ACTIVE = true;\\r\\n            ATLAS_POOL_MGMT.updatePoolPriceAvgs();\\r\\n            try ATLAS_POOL_MGMT.trySwapTokenFeesForBusd() {} catch {}\\r\\n            try ATLAS_POOL_MGMT.tryIncreasePoolDepth() {} catch {}\\r\\n            try ATLAS_POOL_MGMT.tryBuyFromEqnoxAndIncreasePool() {} catch {}\\r\\n            IS_BYPASS_ACTIVE = false;\\r\\n\\r\\n            if(!isTradingActive) IS_TRADING_ACTIVE = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function transferMkt() public {\\r\\n        IS_BYPASS_ACTIVE = true;\\r\\n        try MADDRESS_CONTRACT.transferMkt() {} catch {}\\r\\n        IS_BYPASS_ACTIVE = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {BEP20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\r\\n        \\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            _msgSender(),\\r\\n            _allowances[sender][_msgSender()].sub(\\r\\n                amount,\\r\\n                \\\"BEP20: transfer amount exceeds allowance\\\"\\r\\n            )\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n\\r\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\r\\n        \\r\\n        //trading will be disabled for a few days\\r\\n        require(IS_TRADING_ACTIVE, \\\"Trading is not active\\\");\\r\\n\\r\\n        //check if sender or recipient are banned pools\\r\\n        require(!_isBanned[sender] \\u0026\\u0026 !_isBanned[recipient], \\\"Pool banned\\\");\\r\\n\\r\\n        //set the receive amount, which can be affected if the sender or recipient aren\\u0027t excluded\\r\\n        uint256 receiveAmount = amount;\\r\\n\\r\\n        //main exclusions: the contract, the auctions contract, the pool mgmt contract\\r\\n        //tax bypass may be enabled for specific operations\\r\\n        if (!_isExcluded[sender] \\u0026\\u0026 !_isExcluded[recipient] \\u0026\\u0026 !IS_BYPASS_ACTIVE) {\\r\\n            IS_BYPASS_ACTIVE = true;\\r\\n\\r\\n            //this is a buy - taxes are used for pool mgmt\\r\\n            if (_isPool[sender]) {\\r\\n                \\r\\n                //update price averages\\r\\n                ATLAS_POOL_MGMT.updatePoolPriceAvgs();\\r\\n            \\r\\n                //calculate the buy tax\\r\\n                uint256 buyTax = receiveAmount.mul(buyTaxNum).div(buyTaxDen);\\r\\n\\r\\n                //apply the reduction in tax the recipient has according to his eqnox stake\\r\\n                uint256 buyTaxDeduction = EQNOX_UTILS_CONTRACT.calcTaxDiscount(recipient, buyTax);\\r\\n                //deduct the taxDeduction from the tax\\r\\n                buyTax = buyTax.sub(buyTaxDeduction);\\r\\n\\r\\n                //deduct the buy tax from the amount to transfer\\r\\n                receiveAmount = receiveAmount.sub(buyTax);\\r\\n                totalTokensTaxedOnBuys = totalTokensTaxedOnBuys.add(buyTax);\\r\\n\\r\\n                //90% for pool\\r\\n                uint256 poolTax = buyTax.mul(9).div(10);\\r\\n                ATLAS_POOL_MGMT.addTokensForPoolAccounting(poolTax);\\r\\n                //instead of doing a full transfer, just affect the balances\\r\\n                _balances[address(ATLAS_POOL_MGMT)] = _balances[address(ATLAS_POOL_MGMT)].add(poolTax);\\r\\n                emit Transfer(address(this), address(ATLAS_POOL_MGMT), poolTax);\\r\\n\\r\\n                //10% for mkt\\r\\n                uint256 mktTax = buyTax.mul(1).div(10);\\r\\n                MADDRESS_CONTRACT.addTokensForMktAccounting(mktTax);\\r\\n                //instead of doing a full transfer, just affect the balances\\r\\n                _balances[address(MADDRESS_CONTRACT)] = _balances[address(MADDRESS_CONTRACT)].add(mktTax);\\r\\n                emit Transfer(address(this), address(MADDRESS_CONTRACT), mktTax);\\r\\n            }\\r\\n            //this is a sell - taxes are used for token burning\\r\\n            else if (_isPool[recipient]) {\\r\\n               \\r\\n                //update price averages\\r\\n                ATLAS_POOL_MGMT.updatePoolPriceAvgs();\\r\\n                //sell pool tokens for BUSD\\r\\n                try ATLAS_POOL_MGMT.trySwapTokenFeesForBusd() {} catch {}\\r\\n                //increase pool depth if needed\\r\\n                try ATLAS_POOL_MGMT.tryIncreasePoolDepth() {} catch {}\\r\\n\\r\\n                //calculate the sell tax\\r\\n                uint256 sellTax = receiveAmount.mul(sellTaxNum).div(sellTaxDen);\\r\\n\\r\\n                //apply the reduction in tax the user has according to his eqnox stake\\r\\n                uint256 sellTaxDeduction = EQNOX_UTILS_CONTRACT.calcTaxDiscount(sender, sellTax);\\r\\n                //deduct the taxDeduction from the tax\\r\\n                sellTax = sellTax.sub(sellTaxDeduction);\\r\\n\\r\\n                //deduct the sell tax from the amount to transfer\\r\\n                receiveAmount = receiveAmount.sub(sellTax);\\r\\n                totalTokenTaxedOnSells = totalTokenTaxedOnSells.add(sellTax);\\r\\n\\r\\n                //90% for burning\\r\\n                uint256 burnTax = sellTax.mul(9).div(10);\\r\\n\\r\\n                //10% for mkt\\r\\n                uint256 mktTax = sellTax.mul(1).div(10);\\r\\n                \\r\\n                //remove taxes from total supply - this is the burn\\r\\n                _totalSupply = _totalSupply.sub(burnTax);\\r\\n\\r\\n                MADDRESS_CONTRACT.addTokensForMktAccounting(mktTax);\\r\\n                //instead of doing a full transfer, just affect the balances\\r\\n                _balances[address(MADDRESS_CONTRACT)] = _balances[address(MADDRESS_CONTRACT)].add(mktTax);\\r\\n                \\r\\n                emit Transfer(address(this), address(0), burnTax);\\r\\n                emit Transfer(address(this), address(MADDRESS_CONTRACT), mktTax);\\r\\n                \\r\\n            }\\r\\n            IS_BYPASS_ACTIVE = false;\\r\\n        }\\r\\n\\r\\n        //fallback\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(receiveAmount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract that contains all required BokkyPooBah\\u0027s library functions\\r\\n */\\r\\nabstract contract DateTime is TaxableTransfer{\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get the current timestamp\\r\\n     */\\r\\n    function _now() internal view returns (uint timestamp) {\\r\\n        timestamp = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to add days to a timestamp\\r\\n     */\\r\\n    function _addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to calculate the number of days between timestamps\\r\\n     */\\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint256) {\\r\\n        // require(fromTimestamp \\u003c= toTimestamp);\\r\\n        if(fromTimestamp \\u003e toTimestamp) return 0;\\r\\n        return (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract for updating the day, and accounting inflation\\r\\n */\\r\\nabstract contract DayMgmt is DateTime {\\r\\n    uint256 public InflationRegUntil = 0;\\r\\n    mapping(uint256 =\\u003e Inflation) public dailyInflations;\\r\\n\\r\\n    uint256 public CurrentSharePrice = 0;\\r\\n    uint256 public SharesAccounting = 0;\\r\\n    \\r\\n    uint256 public ActiveStakesAccounting = 0;\\r\\n\\r\\n    struct Inflation {\\r\\n        uint256 numerator;\\r\\n        uint256 denominator;\\r\\n        uint256 totalShares;\\r\\n        uint256 totalSupply;\\r\\n        uint256 tokensStakedAccounting;\\r\\n    }\\r\\n\\r\\n    uint256 public TokenStartTimestamp;\\r\\n    uint256 private _currentTokenDay = 1;\\r\\n\\r\\n    function CurrentTokenDay() public view returns (uint256) {\\r\\n        return _currentTokenDay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to trigger the update of the day, is triggered by almost all stake related functions in the contract\\r\\n     */\\r\\n    modifier mod_opTrigger() {\\r\\n        updateDay();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to try and update the current day\\r\\n     */\\r\\n    function updateDay() public {\\r\\n\\r\\n        \\r\\n        uint256 _NOW = _now();\\r\\n\\r\\n        //get the number of days elapsed\\r\\n        uint256 elapsedDays = diffDays(_addDays(TokenStartTimestamp, CurrentTokenDay()-1), _NOW);\\r\\n\\r\\n        //checks if at least one full day has ellapsed since the last update\\r\\n        if(elapsedDays == 0) return;\\r\\n\\r\\n        //register the new day target\\r\\n        uint256 currentTokenDay = CurrentTokenDay() + elapsedDays;\\r\\n\\r\\n        //update the internal record of the current day\\r\\n        _currentTokenDay = currentTokenDay;\\r\\n\\r\\n        //check if inflation needs to be registered\\r\\n        //this should never return true, since elapsed days is already being checked\\r\\n        if (InflationRegUntil \\u003e= currentTokenDay) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        //cycle through all missing days and register the inflation observed\\r\\n        while (InflationRegUntil \\u003c currentTokenDay) {\\r\\n            _registerTodaysInflation(InflationRegUntil++);\\r\\n        }\\r\\n\\r\\n        transferMkt();\\r\\n\\r\\n        //update everything related to pool mgmt\\r\\n        updatePoolDepthAndAvgs();\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function that returns a fixed daily inflation derived from a 4% yearly inflation\\r\\n     */\\r\\n    function calculateInflation() public pure returns (uint256 num, uint256 den) {\\r\\n        return (109589041096, 1000000000000000); // 4% year - 4/36500 = 0.000109589041096 = (109589041096, 1000000000000000)\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to register the daily inflation and existing shares right before updating the day to the next day.\\r\\n     */\\r\\n    function _registerTodaysInflation(uint256 tokenDay) private {\\r\\n        (uint256 numerator, uint256 denominator) = calculateInflation();\\r\\n        Inflation memory newInflation;\\r\\n        newInflation.numerator = numerator;\\r\\n        newInflation.denominator = denominator;\\r\\n        newInflation.totalShares = SharesAccounting;\\r\\n        newInflation.totalSupply = _totalSupply + extraSupplyForInterestBoost;\\r\\n        newInflation.tokensStakedAccounting = TokensStakedAccounting;\\r\\n        dailyInflations[tokenDay] = newInflation;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract with helper functions\\r\\n */\\r\\nabstract contract StakeMgmtHelper is DayMgmt {\\r\\n    function _toBytes16(uint256 x) internal pure returns (bytes16 b) {\\r\\n        return bytes16(bytes32(x));\\r\\n    }\\r\\n\\r\\n    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\\r\\n        b = _toBytes16(uint256(keccak256(abi.encodePacked(x, y, z))));\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IAtlasAuction {\\r\\n    function LAST_DIVIDEND_DAY() external view returns (uint256);\\r\\n}\\r\\n\\r\\nenum VoteOperationEnum {\\r\\n    AddVotes,\\r\\n    RemoveVotes\\r\\n}\\r\\n\\r\\nenum RequestStatusEnum {\\r\\n    Pending,\\r\\n    Approved,\\r\\n    Rejected\\r\\n}\\r\\n\\r\\nstruct SupplyChangeRequestData {\\r\\n    uint256 id;\\r\\n    uint8 supplyChangeRequestType;\\r\\n    RequestStatusEnum requestStatus;\\r\\n    uint256 extraSupplyAmount;\\r\\n    uint256 totalVotesRequired;\\r\\n    uint256 totalVotes;\\r\\n    uint256 expirationDate;\\r\\n}\\r\\n\\r\\ninterface IAtlasSupplyMgmt {\\r\\n    function updateVotesByUser(address account, bytes16 stakeId, uint256 voteAmount, VoteOperationEnum voteOperation, uint256 supplyChangeRequestId) external;\\r\\n    function SupplyChangeRequestsData(uint256) external view returns (SupplyChangeRequestData memory);\\r\\n    function StakesLockedToRequests(bytes16) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IAtlasStakeMath {\\r\\n    function calcBonus(address account, uint256 tokenAmount, bytes16 stakeId, uint256 numDays, uint256 totalSupply, uint256 tokensStakedAccounting) external view returns (uint256);\\r\\n    function calculatePrincipalAndInterestIfClosingStakeToday(address addr, bytes16 stakeId, uint256 numDaysToAccountFor) external view returns (uint256 principal, uint256 interest);\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract for stake management\\r\\n */\\r\\nabstract contract StakeMgmt is StakeMgmtHelper {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event stakeCreated(\\r\\n        bytes16 indexed stakeId,\\r\\n        address indexed stakerAddress,\\r\\n        uint256 stakeAmount,\\r\\n        uint256 stakingBonus,\\r\\n        uint256 indexed stakeTokenDay\\r\\n    );\\r\\n\\r\\n    event stakeMoved(\\r\\n        bytes16 indexed stakeId,\\r\\n        bytes16 newStakeId,\\r\\n        address indexed sender,\\r\\n        address indexed receiver,\\r\\n        uint256 tokenDay\\r\\n    );\\r\\n\\r\\n    event stakeEnded(\\r\\n        bytes16 indexed stakeId,\\r\\n        address indexed stackerAddress,\\r\\n        uint256 mintedTokens,\\r\\n        uint256 indexed tokenDay\\r\\n    );\\r\\n\\r\\n    event sharePriceUpdated(\\r\\n        bytes16 indexed stakeId,\\r\\n        uint256 indexed tokenDay,\\r\\n        uint256 newSharePrice\\r\\n    );\\r\\n\\r\\n    enum StakeState {\\r\\n        Active,\\r\\n        Moved,\\r\\n        Closed,\\r\\n        LockedForVoting\\r\\n    }\\r\\n\\r\\n    struct Stake {\\r\\n        bytes16 stakeId;\\r\\n        uint256 stakeAmount;\\r\\n        uint256 stakingBonus;\\r\\n        uint256 shares;\\r\\n        StakeState stakeState;\\r\\n        uint256 interestAmount;\\r\\n        uint256 stakeStartTokenDay;\\r\\n        uint256 stakeDuration;\\r\\n        uint256 numDaysAccountedFor;\\r\\n        uint256 accountingStartTokenDay;\\r\\n        uint256 stakeAmountAfterPenalties;\\r\\n        uint256 amountClaimed;\\r\\n        bool auctionCreatedStake;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e Stake)) public stakes;\\r\\n    mapping(address =\\u003e uint256) public stakeCount;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public totalStakedByAccounts;\\r\\n    mapping(address =\\u003e uint256) public totalSharesHeldByAccounts;\\r\\n\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public sharesHeldByAccountsAccounting;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(bytes16 =\\u003e bool))) public approvedStakesForMoving;\\r\\n\\r\\n    uint256 public MAX_STAKE_DURATION_IN_DAYS = 365 * 10; //10 years\\r\\n\\r\\n    uint256 public MIN_STAKE_DURATION_IN_DAYS = 30; //30 days\\r\\n\\r\\n    uint256 public MIN_STAKE_DURATION_TO_AVOID_TAXES = 180; //180 days\\r\\n\\r\\n    uint256 public SHARE_PRICE_PRECISION = 1E5;\\r\\n    uint256 public INITIAL_SHARE_PRICE = 1E5;\\r\\n    uint256 public SHARE_PRICE_MAX = 1E40;\\r\\n\\r\\n    //Total auctioned supply considering a daily taper of 2% daily\\r\\n    uint256 public SUPPLY_AFTER_AUCTIONS = 418844718 * 1e18; //418,844,718\\r\\n\\r\\n    IAtlasAuction public AUCTION_CONTRACT;\\r\\n    IAtlasSupplyMgmt public SUPPLYMGMT_CONTRACT;\\r\\n    IAtlasStakeMath public ATLAS_STAKE_MATH;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Check if auction shares should be accounted for\\r\\n     */\\r\\n    function ShouldAccountSharesForAuctions() public view returns (bool) {\\r\\n        return CurrentTokenDay() \\u003c= AUCTION_CONTRACT.LAST_DIVIDEND_DAY();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to clone an origin stake into destination stake. \\r\\n     */\\r\\n    function _cloneStake(Stake memory origin, Stake memory destination) private pure {\\r\\n        destination.stakeId = origin.stakeId;\\r\\n        destination.stakeAmount = origin.stakeAmount;\\r\\n        destination.stakingBonus = origin.stakingBonus;\\r\\n        destination.shares = origin.shares;\\r\\n        destination.stakeState = origin.stakeState;\\r\\n        destination.interestAmount = origin.interestAmount;\\r\\n        destination.stakeDuration = origin.stakeDuration;\\r\\n        destination.stakeStartTokenDay = origin.stakeStartTokenDay;\\r\\n        destination.numDaysAccountedFor = origin.numDaysAccountedFor;\\r\\n        destination.accountingStartTokenDay = origin.accountingStartTokenDay;\\r\\n        destination.auctionCreatedStake = origin.auctionCreatedStake;\\r\\n        destination.amountClaimed = origin.amountClaimed;\\r\\n        destination.stakeAmountAfterPenalties = origin.stakeAmountAfterPenalties;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function for the auctions contract to create stakes\\r\\n     */\\r\\n    function createAuctionStake(address account, uint256 amountToStake, uint256 stakeDuration) external {\\r\\n        require(msg.sender == address(AUCTION_CONTRACT), \\\"Not authorized\\\");\\r\\n        _createStake(account, amountToStake, stakeDuration, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to create stakes\\r\\n     */\\r\\n    function createStake(uint256 amountToStake, uint256 stakeDuration) external mod_opTrigger {\\r\\n        _createStake(msg.sender, amountToStake, stakeDuration, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev private function to create a stake.\\r\\n     */\\r\\n    function _createStake(address account, uint256 amountToStake, uint256 stakeDuration, bool auctionCreatedStake) private {\\r\\n        require(amountToStake \\u003e 100000, \\\"Cannot stake less than 100000 millis\\\");\\r\\n\\r\\n        //check if the user has enough tokens to stake\\r\\n        require(_balances[account] \\u003e= amountToStake, \\\"Account does not have enough tokens\\\");\\r\\n\\r\\n        //check if the stake duration is correct\\r\\n        require(stakeDuration \\u003e= MIN_STAKE_DURATION_IN_DAYS \\u0026\\u0026 stakeDuration \\u003c= MAX_STAKE_DURATION_IN_DAYS, \\\"Stake duration incorrect\\\");\\r\\n\\r\\n        //calculate the amount bonus in tokens the user will get\\r\\n        uint256 tokenBonus = ATLAS_STAKE_MATH.calcBonus(account, amountToStake, EQNOX_UTILS_CONTRACT.userBestEqnoxStake(account), stakeDuration, _totalSupply, TokensStakedAccounting);\\r\\n\\r\\n        //shares = (stakeAmount + bonus) * precision / sharePrice\\r\\n        uint256 newStakeShares = amountToStake\\r\\n            .add(tokenBonus)\\r\\n            .mul(SHARE_PRICE_PRECISION)\\r\\n            //the CurrentSharePrice only increases therefore it will never be 0\\r\\n            .div(CurrentSharePrice);\\r\\n        require(newStakeShares \\u003e 0, \\\"Staked amount is not enough to buy shares\\\");\\r\\n\\r\\n        //burn stake amount\\r\\n        _burn(account, amountToStake);\\r\\n\\r\\n        //1.increase the total number of tokens staked\\r\\n        TokensStakedAccounting = TokensStakedAccounting.add(amountToStake);\\r\\n        //2.increase the total staked by the account\\r\\n        totalStakedByAccounts[account] = totalStakedByAccounts[account].add(amountToStake);\\r\\n        //3.increase the total shares held by the account\\r\\n        totalSharesHeldByAccounts[account] = totalSharesHeldByAccounts[account].add(newStakeShares);\\r\\n        //4.increase total shares\\r\\n        SharesAccounting = SharesAccounting.add(newStakeShares);\\r\\n\\r\\n        //if this is an auction created stake, we need to account the shares that the user got\\r\\n        //this amount of shares will be used by the auctions contract to calculate dividends\\r\\n        if (auctionCreatedStake) {\\r\\n            sharesHeldByAccountsAccounting[account][CurrentTokenDay()] = sharesHeldByAccountsAccounting[account][CurrentTokenDay()].add(newStakeShares);\\r\\n        }\\r\\n\\r\\n        //create the stake\\r\\n        Stake memory newStake;\\r\\n\\r\\n        newStake.stakeId = generateID(account, stakeCount[account], 0x01);\\r\\n        newStake.stakeAmount = amountToStake;\\r\\n        newStake.stakingBonus = tokenBonus;\\r\\n        newStake.interestAmount = 0;\\r\\n        newStake.shares = newStakeShares;\\r\\n        newStake.stakeState = StakeState.Active;\\r\\n        newStake.stakeDuration = stakeDuration;\\r\\n\\r\\n        newStake.stakeStartTokenDay = CurrentTokenDay();\\r\\n        newStake.accountingStartTokenDay = 0;\\r\\n        newStake.numDaysAccountedFor = 0;\\r\\n        newStake.amountClaimed = 0;\\r\\n\\r\\n        newStake.auctionCreatedStake = auctionCreatedStake;\\r\\n\\r\\n        //5.increase the total stake count\\r\\n        ActiveStakesAccounting = ActiveStakesAccounting + 1;\\r\\n\\r\\n        //register the new stake\\r\\n        stakes[account][newStake.stakeId] = newStake;\\r\\n        //increase the stake count of the user\\r\\n        stakeCount[account] = stakeCount[account] + 1;\\r\\n        \\r\\n\\r\\n        emit stakeCreated(\\r\\n            newStake.stakeId,\\r\\n            account,\\r\\n            newStake.stakeAmount,\\r\\n            newStake.stakingBonus,\\r\\n            newStake.stakeStartTokenDay\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to claim the stake value. This function is used to claim as tokens the stake contents\\r\\n     */\\r\\n    function claimStakeValue(bytes16 stakeId, uint256 amountToClaim) external mod_opTrigger {\\r\\n        require(stakeCount[msg.sender] \\u003e 0, \\\"Sender does not contain stakes\\\");\\r\\n\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Closed, \\\"Stake is not closed\\\");\\r\\n\\r\\n        //the user can claim up to the principal after penalties + accrued interest\\r\\n        require(stake.amountClaimed + amountToClaim \\u003c= stake.stakeAmountAfterPenalties + stake.interestAmount, \\\"Amount to claim is higher than amount available\\\");\\r\\n\\r\\n        //increase the amount claimed\\r\\n        stake.amountClaimed = stake.amountClaimed.add(amountToClaim);\\r\\n\\r\\n        //mint back principal (with possible penalties) plus accrued interest\\r\\n        _mint(msg.sender, amountToClaim);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to sell directly to the dex the stake value without paying taxes. Only for stakes longer than 180 days\\r\\n     */\\r\\n    function sellStakeValue(bytes16 stakeId, uint256 amountToSell) external mod_opTrigger {\\r\\n        require(stakeCount[msg.sender] \\u003e 0, \\\"Sender does not contain stakes\\\");\\r\\n\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Closed, \\\"Stake is not closed\\\");\\r\\n\\r\\n        //the stake must have been longer than 180 days\\r\\n        require(stake.numDaysAccountedFor \\u003e= MIN_STAKE_DURATION_TO_AVOID_TAXES, \\\"Stake not eligible to avoid taxes\\\");\\r\\n\\r\\n        //the user can claim up to the principal after penalties + accrued interest\\r\\n        require(stake.amountClaimed + amountToSell \\u003c= stake.stakeAmountAfterPenalties + stake.interestAmount,\\\"Amount to sell is higher than amount available\\\");\\r\\n\\r\\n        stake.amountClaimed = stake.amountClaimed.add(amountToSell);\\r\\n\\r\\n        //mint back principal (with possible penalties) plus accrued interest\\r\\n        _mint(address(this), amountToSell);\\r\\n\\r\\n        //bypass taxes\\r\\n        IS_BYPASS_ACTIVE = true;\\r\\n         _approve(address(this), UNISWAP_ROUTER, amountToSell);\\r\\n        \\r\\n        uint256 minOutputBusdAmount = ATLAS_POOL_MGMT.calcOutputAmountSwapAtlasToBusd(amountToSell, ATLAS_POOL_MGMT.TRADE_TAX());\\r\\n        pool.swapTokens(\\r\\n            msg.sender,\\r\\n            amountToSell,\\r\\n            minOutputBusdAmount,\\r\\n            address(this),\\r\\n            address(BUSD_CONTRACT),\\r\\n            UNISWAP_ROUTER,\\r\\n            block.timestamp + 10000\\r\\n        );\\r\\n        IS_BYPASS_ACTIVE = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to end a stake. Applies the penalties (if any) on the principal, calculates the accrued interest, and closes the stake. Principal and interest can be claimed through another function.\\r\\n     */\\r\\n    function endStake(bytes16 stakeId) public mod_opTrigger {\\r\\n        require(stakeCount[msg.sender] \\u003e 0, \\\"Sender does not contain stakes\\\");\\r\\n\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active, \\\"Stake is not active\\\");\\r\\n\\r\\n        //if the stake was created from auctions, it can\\u0027t benefit from an undo operation\\r\\n        if(stake.auctionCreatedStake) require(stake.stakeStartTokenDay \\u003c CurrentTokenDay(), \\\"Undoing a stake created from auctions isn\\u0027t authorized\\\");\\r\\n\\r\\n        //if the stake has already matured, account until maturity date, otherwise account to the current day\\r\\n        uint256 accountUntilTokenDay = stake.stakeStartTokenDay.add(stake.stakeDuration) \\u003c CurrentTokenDay() ? stake.stakeStartTokenDay.add(stake.stakeDuration) : CurrentTokenDay();\\r\\n        \\r\\n        //calculate the number of days that will be accounted\\r\\n        uint256 numDaysToAccountFor = accountUntilTokenDay.sub(stake.stakeStartTokenDay);\\r\\n\\r\\n        //calculate the principal and interest\\r\\n        (uint256 principal, uint256 interest) = ATLAS_STAKE_MATH.calculatePrincipalAndInterestIfClosingStakeToday(msg.sender, stakeId, numDaysToAccountFor);\\r\\n\\r\\n        //register the principal after penalties applied\\r\\n        stake.stakeAmountAfterPenalties = principal;\\r\\n        //register the interest\\r\\n        stake.interestAmount = interest;\\r\\n        //mark the stake as closed\\r\\n        stake.stakeState = StakeState.Closed;\\r\\n\\r\\n        //register the number of days that were accounted for\\r\\n        stake.numDaysAccountedFor = numDaysToAccountFor;\\r\\n        //register the day the accounting was done\\r\\n        stake.accountingStartTokenDay = CurrentTokenDay();\\r\\n\\r\\n\\r\\n        //1.decrease the total number of tokens staked\\r\\n        TokensStakedAccounting = TokensStakedAccounting.sub(stake.stakeAmount);\\r\\n        //2.decrease the number of tokens staked\\r\\n        totalStakedByAccounts[msg.sender] = totalStakedByAccounts[msg.sender].sub(stake.stakeAmount);\\r\\n        //3.decrease the number of shares held by user\\r\\n        totalSharesHeldByAccounts[msg.sender] = totalSharesHeldByAccounts[msg.sender].sub(stake.shares);\\r\\n\\r\\n        //if the user ends a stake before the full auction period has ended, he will lose his share of dividends\\r\\n        if (ShouldAccountSharesForAuctions() \\u0026\\u0026 stake.auctionCreatedStake) {\\r\\n            sharesHeldByAccountsAccounting[msg.sender][stake.stakeStartTokenDay] = sharesHeldByAccountsAccounting[msg.sender][stake.stakeStartTokenDay].sub(stake.shares);\\r\\n        }\\r\\n\\r\\n        //4.decrease total shares\\r\\n        SharesAccounting = SharesAccounting.sub(stake.shares);\\r\\n\\r\\n        //5.decrease total active stakes\\r\\n        ActiveStakesAccounting = ActiveStakesAccounting - 1;\\r\\n\\r\\n\\r\\n        //calculate tokens to mint\\r\\n        uint256 tokensToMint = principal.add(interest);\\r\\n\\r\\n        //update the share price\\r\\n        _updateSharePrice(stakeId, stake.numDaysAccountedFor, stake.stakeAmount, stake.shares, tokensToMint.add(stake.stakingBonus));\\r\\n\\r\\n        emit stakeEnded(stakeId, msg.sender, tokensToMint, CurrentTokenDay());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to approve a third party to move a stake. Useful for external contracts integration\\r\\n     */\\r\\n    function approveMoveStake(bytes16 stakeId, address account, bool approve) public mod_opTrigger {\\r\\n        Stake memory stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active, \\\"Stake can only be approved for moving if it is active\\\");\\r\\n\\r\\n        approvedStakesForMoving[msg.sender][account][stakeId] = approve;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to move a stake to another address\\r\\n     */\\r\\n    function moveStake(bytes16 stakeId, address toAddress) public mod_opTrigger\\r\\n    {\\r\\n        _moveStake(msg.sender, stakeId, toAddress);\\r\\n    }\\r\\n\\r\\n    function moveStakeFrom(address account, bytes16 stakeId, address destination) public mod_opTrigger {\\r\\n        require(approvedStakesForMoving[account][destination][stakeId], \\\"Move from not authorized\\\");\\r\\n        _moveStake(account, stakeId, destination);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to move a stake.\\r\\n     * Marks the provided stake as moved, and creates a new stake equal to the moved one for the receiver address.\\r\\n     * Total tokens staked remains unchanged.\\r\\n     * No new shares are generated from this operations.\\r\\n     * The stake marked as moved has all it\\u0027s accounting closed.\\r\\n     */\\r\\n    function _moveStake(address account, bytes16 stakeId, address toAddress) private {\\r\\n        \\r\\n        require(toAddress != account, \\\"Sender and receiver cannot be the same\\\");\\r\\n\\r\\n        Stake storage stake = stakes[account][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active, \\\"Stake can only be moved if it is active\\\");\\r\\n        require(!stake.auctionCreatedStake, \\\"Auction created stakes can\\u0027t be moved\\\");\\r\\n\\r\\n        Stake memory newStake;\\r\\n        _cloneStake(stake, newStake);\\r\\n\\r\\n        //mark the old stake as moved\\r\\n        stake.stakeState = StakeState.Moved;\\r\\n        stake.numDaysAccountedFor = CurrentTokenDay().sub(stake.stakeStartTokenDay);\\r\\n        stake.accountingStartTokenDay = CurrentTokenDay();\\r\\n\\r\\n        //save the new stake for the new staker (toAddress)\\r\\n        bytes16 newReceiverStakeID = generateID(toAddress, stakeCount[toAddress], 0x01);\\r\\n        newStake.stakeId = newReceiverStakeID;\\r\\n        stakes[toAddress][newReceiverStakeID] = newStake;\\r\\n        stakeCount[toAddress] = stakeCount[toAddress] + 1;\\r\\n\\r\\n        //2.update accounting of total staked\\r\\n        totalStakedByAccounts[account] = totalStakedByAccounts[account].sub(stake.stakeAmount);\\r\\n        totalStakedByAccounts[toAddress] = totalStakedByAccounts[toAddress].add(stake.stakeAmount);\\r\\n        //3.update accounting of total shares held\\r\\n        totalSharesHeldByAccounts[account] = totalSharesHeldByAccounts[account].sub(stake.shares);\\r\\n        totalSharesHeldByAccounts[toAddress] = totalSharesHeldByAccounts[toAddress].add(stake.shares);\\r\\n\\r\\n        emit stakeMoved(stakeId, newReceiverStakeID, account, toAddress, CurrentTokenDay());\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev External function to lock multiple stakes for voting\\r\\n     */\\r\\n    function lockStakesForVoting(bytes16[] memory stakeIds, uint256 supplyChangeRequestId) external mod_opTrigger {\\r\\n        for(uint256 i = 0; i \\u003c stakeIds.length; i++) {\\r\\n            //if the request changes status in the meanwhile, return - this is an optimization\\r\\n            if(SUPPLYMGMT_CONTRACT.SupplyChangeRequestsData(supplyChangeRequestId-1).requestStatus != RequestStatusEnum.Pending) return;\\r\\n            lockStakeForVoting(stakeIds[i], supplyChangeRequestId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to lock one stake for voting\\r\\n     */\\r\\n    function lockStakeForVoting(bytes16 stakeId, uint256 supplyChangeRequestId) public mod_opTrigger {\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.Active, \\\"Stake can only be used for voting if it is active\\\");\\r\\n\\r\\n        //lock the stake\\r\\n        stake.stakeState = StakeState.LockedForVoting;\\r\\n        //update the votes\\r\\n        SUPPLYMGMT_CONTRACT.updateVotesByUser(msg.sender, stakeId, stake.shares, VoteOperationEnum.AddVotes, supplyChangeRequestId);\\r\\n    }\\r\\n\\r\\n    function unlockStakeFromVoting(bytes16 stakeId) public mod_opTrigger {\\r\\n        Stake storage stake = stakes[msg.sender][stakeId];\\r\\n        bool stakeFound = stake.stakeId == stakeId;\\r\\n        require(stakeFound, \\\"Sender does not contain stake with provided id\\\");\\r\\n        require(stake.stakeState == StakeState.LockedForVoting, \\\"Stake isn\\u0027t locked\\\");\\r\\n        \\r\\n        uint256 requestId = SUPPLYMGMT_CONTRACT.StakesLockedToRequests(stakeId);\\r\\n        //if the request id is 0 means the stake isn\\u0027t associated to any request\\r\\n        require(requestId \\u003e 0, \\\"Request id mapping not found for stake\\\");\\r\\n\\r\\n        //update the votes\\r\\n        SUPPLYMGMT_CONTRACT.updateVotesByUser(msg.sender, stakeId, stake.shares, VoteOperationEnum.RemoveVotes, requestId);\\r\\n        //mark the stake as active\\r\\n        stake.stakeState = StakeState.Active;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to update the share price. Calculations are similar to the HEX model.\\r\\n     */\\r\\n    function _updateSharePrice(bytes16 stakeId, uint256 stakeDays, uint256 stakedAmount, uint256 stakeShares, uint256 stakeReturn) private {\\r\\n        if (stakeReturn \\u003e stakedAmount) {\\r\\n            //we want to avoid very sharp share price increases\\r\\n            //this should happen only when there is much more unstaked tokens than staked tokens\\r\\n            //as such we should assume a maximum share price increase that is aligned with the average stake interest growth in normal situations\\r\\n            //let us therefore assume a maximum daily interest of 1%\\r\\n            //as such, the average return a stake should have is stakedAmount + (0.01 x stakedAmount x stakeDays)\\r\\n            //let us then cap the max stake return to that\\r\\n            uint256 stakeReturnCap = stakedAmount +\\r\\n                stakedAmount.mul(stakeDays).div(100);\\r\\n\\r\\n            if (stakeReturn \\u003e stakeReturnCap) {\\r\\n                stakeReturn = stakeReturnCap;\\r\\n            }\\r\\n\\r\\n            //since a stake needs to have a positive amount of shares this division is never by zero\\r\\n            uint256 newSharePrice = stakeReturn.mul(SHARE_PRICE_PRECISION).div(stakeShares);\\r\\n\\r\\n            if (newSharePrice \\u003e SHARE_PRICE_MAX) {\\r\\n                newSharePrice = SHARE_PRICE_MAX;\\r\\n            }\\r\\n\\r\\n            if (newSharePrice \\u003e CurrentSharePrice) {\\r\\n                CurrentSharePrice = newSharePrice;\\r\\n                emit sharePriceUpdated(\\r\\n                    stakeId,\\r\\n                    CurrentTokenDay(),\\r\\n                    CurrentSharePrice\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IContractsManager {\\r\\n    function find(string memory contractName) external view returns (address, bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Main ATLAS contract\\r\\n */\\r\\ncontract AtlasToken is StakeMgmt {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev External function manage an account exclusion from a fee\\r\\n     */\\r\\n    function excludeFromFee(address account, bool exclude) external mod_onlyPoolMngr {\\r\\n        _isExcluded[account] = exclude;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to register a pool\\r\\n     */\\r\\n    function registerPool(address poolAddress, bool isPool) external {\\r\\n        require(msg.sender == POOL_MNGR || msg.sender == address(ATLAS_POOL_MGMT));\\r\\n        _isPool[poolAddress] = isPool;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to ban other pools\\r\\n     */\\r\\n    function banPool(address poolAddress, bool isBanned) mod_onlyPoolMngr external {\\r\\n        _isBanned[poolAddress] = isBanned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to change the extra supply for mcap\\r\\n     */\\r\\n    function changeExtraSupplyForMarketcap(uint256 extraSupply) external {\\r\\n        require(msg.sender == address(SUPPLYMGMT_CONTRACT), \\\"Not authorized\\\");\\r\\n        extraSupplyForMcapBoost = extraSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to change the extra supply for interest\\r\\n     */\\r\\n    function changeExtraSupplyForInterest(uint256 extraSupply) external {\\r\\n        require(msg.sender == address(SUPPLYMGMT_CONTRACT), \\\"Not authorized\\\");\\r\\n        extraSupplyForInterestBoost = extraSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to mint new ATLAS supply\\r\\n     */\\r\\n    function mintSupply(address account, uint256 amount) external {\\r\\n        require(msg.sender == address(AUCTION_CONTRACT) || msg.sender == address(ATLAS_POOL_MGMT), \\\"Not authorized\\\");\\r\\n        _mint(account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to burn ATLAS supply\\r\\n     */\\r\\n    function burnSupply(uint256 amount) external {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to manage taxing\\r\\n     */\\r\\n    function setIsByPassActive(bool value) external mod_onlyPoolMngr {\\r\\n        IS_BYPASS_ACTIVE = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to manage trading activity\\r\\n     */\\r\\n    function setIsTradingActive(bool value) public {\\r\\n        require(msg.sender == address(AUCTION_CONTRACT) || msg.sender == address(ATLAS_POOL_MGMT) || msg.sender == CONTRACT_DEFINER, \\\"Not authorized\\\");\\r\\n        IS_TRADING_ACTIVE = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to manage trading activity\\r\\n     */\\r\\n    function startPool(uint256 busdAmount) external mod_onlyContractDefiner {\\r\\n        \\r\\n        //check if trading isn\\u0027t active\\r\\n        bool isTradingActive = IS_TRADING_ACTIVE;\\r\\n        //if it isn\\u0027t activate it\\r\\n        if(!isTradingActive) setIsTradingActive(true);\\r\\n        \\r\\n        IS_BYPASS_ACTIVE = true;\\r\\n\\r\\n        BUSD_CONTRACT.approve(address(ATLAS_POOL_MGMT), busdAmount);\\r\\n        ATLAS_POOL_MGMT.startPool(busdAmount);\\r\\n        IS_BYPASS_ACTIVE = false;\\r\\n\\r\\n        //if trading wasn\\u0027t active, deactivate it again\\r\\n        if(!isTradingActive) setIsTradingActive(false);\\r\\n\\r\\n        updatePoolDepthAndAvgs();\\r\\n    }\\r\\n\\r\\n    function setContracts(address contractsManager) external mod_onlyContractDefiner {\\r\\n        //Auction contract\\r\\n        (address ctr, bool found) = IContractsManager(contractsManager).find(\\\"AUCTION_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        AUCTION_CONTRACT = IAtlasAuction(ctr);\\r\\n        _isExcluded[address(AUCTION_CONTRACT)] = true;\\r\\n\\r\\n        //Atlas Stake Math\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"ATLAS_STAKE_MATH\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        ATLAS_STAKE_MATH = IAtlasStakeMath(ctr);\\r\\n\\r\\n        //Atlas Supply Mgmt\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"SUPPLYMGMT_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        SUPPLYMGMT_CONTRACT = IAtlasSupplyMgmt(ctr);\\r\\n\\r\\n        //Atlas Pool Mgmt\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"ATLAS_POOL_MGMT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        ATLAS_POOL_MGMT = IAtlasPoolMgmt(ctr);\\r\\n        _isExcluded[address(ATLAS_POOL_MGMT)] = true;\\r\\n\\r\\n        //Eqnox Utils contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"EQNOX_UTILS_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        EQNOX_UTILS_CONTRACT = IEqnoxUtils(ctr);\\r\\n\\r\\n        //MAddress contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"MADDRESS_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        MADDRESS_CONTRACT = IAtlasMAddressMgmt(ctr);\\r\\n\\r\\n        //Uniswap Router\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"UNISWAP_ROUTER\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        UNISWAP_ROUTER = ctr;\\r\\n\\r\\n        //Busd contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"BUSD_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        BUSD_CONTRACT = IERC20(ctr);\\r\\n    }\\r\\n\\r\\n\\r\\n    //launch timestamp = 1681059600 - April 9th 2023 17h UTC\\r\\n    constructor(uint256 timestamp) ERC20(\\\"Atlas\\\", \\\"ATLAS\\\") {\\r\\n        CONTRACT_DEFINER = msg.sender;\\r\\n        POOL_MNGR = msg.sender;\\r\\n\\r\\n        _isExcluded[address(this)] = true;\\r\\n\\r\\n        CurrentSharePrice = INITIAL_SHARE_PRICE;\\r\\n        InflationRegUntil = CurrentTokenDay();\\r\\n\\r\\n        TokenStartTimestamp = timestamp;\\r\\n    }\\r\\n}\\r\\n\"},\"pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ninterface IPoolToken {\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n}\\r\\n\\r\\nlibrary pool {\\r\\n\\r\\n    function getPairWithWETH(address router, address tokenAddress) internal view returns (address pair) {\\r\\n        IUniswapV2Factory factory = IUniswapV2Factory((IUniswapV2Router02(router)).factory());\\r\\n        return factory.getPair(IUniswapV2Router02(router).WETH(), tokenAddress);\\r\\n    }\\r\\n\\r\\n    function getPair(address router, address tokenAddress, address otherTokenAddress) internal view returns (address pair) {\\r\\n        return\\r\\n            IUniswapV2Factory((IUniswapV2Router02(router)).factory()).getPair(\\r\\n                tokenAddress,\\r\\n                otherTokenAddress\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function hasPoolBeenCreated(\\r\\n        address router,\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress\\r\\n    ) internal view returns (bool) {\\r\\n        return\\r\\n            IUniswapV2Factory((IUniswapV2Router02(router)).factory()).getPair(\\r\\n                tokenAddress,\\r\\n                otherTokenAddress\\r\\n            ) != address(0x0);\\r\\n    }\\r\\n\\r\\n    function createPool(\\r\\n        address router,\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress\\r\\n    ) internal returns (address) {\\r\\n        return\\r\\n            IUniswapV2Factory((IUniswapV2Router02(router)).factory())\\r\\n                .createPair(tokenAddress, otherTokenAddress);\\r\\n    }\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress,\\r\\n        address lpTokensReceiver,\\r\\n        address router,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 otherTokenAmount,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        IPoolToken(tokenAddress).approve(router, tokenAmount);\\r\\n        IPoolToken(otherTokenAddress).approve(router, otherTokenAmount);\\r\\n\\r\\n        IUniswapV2Router02(router).addLiquidity(\\r\\n            tokenAddress,\\r\\n            otherTokenAddress,\\r\\n            tokenAmount,\\r\\n            otherTokenAmount,\\r\\n            0,\\r\\n            0,\\r\\n            lpTokensReceiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress,\\r\\n        address liquidityReceiver,\\r\\n        address router,\\r\\n        address pair,\\r\\n        uint256 lpTokens,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        IUniswapV2Pair(pair).approve(router, lpTokens);\\r\\n\\r\\n        IUniswapV2Router02(router).removeLiquidity(\\r\\n            tokenAddress,\\r\\n            otherTokenAddress,\\r\\n            lpTokens,\\r\\n            0,\\r\\n            0,\\r\\n            liquidityReceiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokens(\\r\\n        address receiver,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 outputMinAmount,\\r\\n        address originTokenAddress,\\r\\n        address destinationTokenAddress,\\r\\n        address router,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = originTokenAddress;\\r\\n        path[1] = destinationTokenAddress;\\r\\n\\r\\n        IUniswapV2Router02(router).swapExactTokensForTokens(\\r\\n            tokenAmount,\\r\\n            outputMinAmount,\\r\\n            path,\\r\\n            receiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        address receiver,\\r\\n        uint256 tokenAmount,\\r\\n        address originTokenAddress,\\r\\n        address destinationTokenAddress,\\r\\n        address router,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = originTokenAddress;\\r\\n        path[1] = destinationTokenAddress;\\r\\n\\r\\n        IUniswapV2Router02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            receiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapEthForTokens(\\r\\n        uint256 MESSAGE_VALUE,\\r\\n        uint256 outputMinAmount,\\r\\n        address receiver,\\r\\n        address originAddress,\\r\\n        address destinationAddress,\\r\\n        address router,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = originAddress;\\r\\n        path[1] = destinationAddress;\\r\\n\\r\\n        IUniswapV2Router02(router).swapExactETHForTokens{value: MESSAGE_VALUE}(\\r\\n            outputMinAmount,\\r\\n            path,\\r\\n            receiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getPoolReserves(address tokenAddress, address pair)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 tokenAmount, uint256 otherTokenAmount)\\r\\n    {\\r\\n        IUniswapV2Pair uniswapPair = IUniswapV2Pair(pair);\\r\\n        (uint256 reserveIn, uint256 reserveOut, ) = uniswapPair.getReserves(); // reserveIn SHOULD be TOKEN, may be BUSD\\r\\n\\r\\n        if (uniswapPair.token0() == tokenAddress) {\\r\\n            tokenAmount = reserveIn;\\r\\n            otherTokenAmount = reserveOut;\\r\\n        } else {\\r\\n            tokenAmount = reserveOut;\\r\\n            otherTokenAmount = reserveIn;\\r\\n        }\\r\\n\\r\\n        return (tokenAmount, otherTokenAmount);\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSharePrice\",\"type\":\"uint256\"}],\"name\":\"sharePriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingBonus\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeTokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stackerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"newStakeId\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"}],\"name\":\"stakeMoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ATLAS_POOL_MGMT\",\"outputs\":[{\"internalType\":\"contract IAtlasPoolMgmt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ATLAS_STAKE_MATH\",\"outputs\":[{\"internalType\":\"contract IAtlasStakeMath\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AUCTION_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IAtlasAuction\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ActiveStakesAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTRACT_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentTokenDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EQNOX_UTILS_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IEqnoxUtils\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_SHARE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IS_BYPASS_ACTIVE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IS_TRADING_ACTIVE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InflationRegUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MADDRESS_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IAtlasMAddressMgmt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_STAKE_DURATION_IN_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_STAKE_DURATION_IN_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_STAKE_DURATION_TO_AVOID_TAXES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_MNGR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHARE_PRICE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHARE_PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLYMGMT_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IAtlasSupplyMgmt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLY_AFTER_AUCTIONS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SharesAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ShouldAccountSharesForAuctions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokensStakedAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approve\",\"type\":\"bool\"}],\"name\":\"approveMoveStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"approvedStakesForMoving\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBanned\",\"type\":\"bool\"}],\"name\":\"banPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxDen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateInflation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"den\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"extraSupply\",\"type\":\"uint256\"}],\"name\":\"changeExtraSupplyForInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"extraSupply\",\"type\":\"uint256\"}],\"name\":\"changeExtraSupplyForMarketcap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changePoolMngrOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amountToClaim\",\"type\":\"uint256\"}],\"name\":\"claimStakeValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeDuration\",\"type\":\"uint256\"}],\"name\":\"createAuctionStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeDuration\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyInflations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensStakedAccounting\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraSupplyForInterestBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraSupplyForMcapBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"z\",\"type\":\"bytes1\"}],\"name\":\"generateID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"b\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"supplyChangeRequestId\",\"type\":\"uint256\"}],\"name\":\"lockStakeForVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"stakeIds\",\"type\":\"bytes16[]\"},{\"internalType\":\"uint256\",\"name\":\"supplyChangeRequestId\",\"type\":\"uint256\"}],\"name\":\"lockStakesForVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"moveStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"moveStakeFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPool\",\"type\":\"bool\"}],\"name\":\"registerPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amountToSell\",\"type\":\"uint256\"}],\"name\":\"sellStakeValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxDen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractsManager\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setIsByPassActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setIsTradingActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sharesHeldByAccountsAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"enum StakeMgmt.StakeState\",\"name\":\"stakeState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeStartTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numDaysAccountedFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountingStartTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmountAfterPenalties\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auctionCreatedStake\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"}],\"name\":\"startPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSharesHeldByAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalStakedByAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenTaxedOnSells\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensTaxedOnBuys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferMkt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"}],\"name\":\"unlockStakeFromVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePoolDepthAndAvgs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"userStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AtlasToken", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006432ef10", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://62e8cb7452e73aa4e98d53cb4c8db5925e4cceb9536a854d7f30d9a698aaa19a"}