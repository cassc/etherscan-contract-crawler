{"SourceCode": "// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/utils/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: hub2bsc.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n// This is being used purely to avoid stack too deep errors\r\nstruct LogicCallArgs {\r\n\t// Transfers out to the logic contract\r\n\tuint256[] transferAmounts;\r\n\taddress[] transferTokenContracts;\r\n\t// The fees (transferred to msg.sender)\r\n\tuint256[] feeAmounts;\r\n\taddress[] feeTokenContracts;\r\n\t// The arbitrary logic call\r\n\taddress logicContractAddress;\r\n\tbytes payload;\r\n\t// Invalidation metadata\r\n\tuint256 timeOut;\r\n\tbytes32 invalidationId;\r\n\tuint256 invalidationNonce;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract Hub2Bsc is ReentrancyGuard {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath for uint;\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\t// These are updated often\r\n\tbytes32 public state_lastValsetCheckpoint;\r\n\tmapping(address => uint256) public state_lastBatchNonces;\r\n\tmapping(bytes32 => uint256) public state_invalidationMapping;\r\n\tuint256 public state_lastValsetNonce = 0;\r\n\t// event nonce zero is reserved by the Cosmos module as a special\r\n\t// value indicating that no events have yet been submitted\r\n\tuint256 public state_lastEventNonce = 1;\r\n\r\n\t// These are set once at initialization\r\n\tbytes32 public state_gravityId;\r\n\tuint256 public state_powerThreshold;\r\n\r\n\taddress public wethAddress;\r\n\r\n\taddress public guardian;\r\n\r\n\t// TransactionBatchExecutedEvent and TransferToChain both include the field _eventNonce.\r\n\t// This is incremented every time one of these events is emitted. It is checked by the\r\n\t// Cosmos module to ensure that all events are received in order, and that none are lost.\r\n\t//\r\n\t// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos\r\n\t// module. It is purely for the use of relayers to allow them to successfully submit batches.\r\n\tevent TransactionBatchExecutedEvent(\r\n\t\tuint256 indexed _batchNonce,\r\n\t\taddress indexed _token,\r\n\t\tuint256 _eventNonce\r\n\t);\r\n\tevent TransferToChainEvent(\r\n\t\taddress indexed _tokenContract,\r\n\t\taddress indexed _sender,\r\n\t\tbytes32 indexed _destinationChain,\r\n\t\tbytes32 _destination,\r\n\t\tuint256 _amount,\r\n\t\tuint256 _fee,\r\n\t\tuint256 _eventNonce\r\n\t);\r\n\tevent ValsetUpdatedEvent(\r\n\t\tuint256 indexed _newValsetNonce,\r\n\t\tuint256 _eventNonce,\r\n\t\taddress[] _validators,\r\n\t\tuint256[] _powers\r\n\t);\r\n\tevent LogicCallEvent(\r\n\t\tbytes32 _invalidationId,\r\n\t\tuint256 _invalidationNonce,\r\n\t\tuint256 _eventNonce,\r\n\t\tbytes _returnData\r\n\t);\r\n\r\n\treceive() external payable {\r\n        assert(msg.sender == wethAddress); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\r\n\t\treturn state_lastBatchNonces[_erc20Address];\r\n\t}\r\n\r\n\tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\r\n\t\treturn state_invalidationMapping[_invalidation_id];\r\n\t}\r\n\r\n\t// Utility function to verify geth style signatures\r\n\tfunction verifySig(\r\n\t\taddress _signer,\r\n\t\tbytes32 _theHash,\r\n\t\tuint8 _v,\r\n\t\tbytes32 _r,\r\n\t\tbytes32 _s\r\n\t) private pure returns (bool) {\r\n\t\tbytes32 messageDigest =\r\n\t\t\tkeccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash));\r\n\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\r\n\t}\r\n\r\n\t// Make a new checkpoint from the supplied validator set\r\n\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\r\n\t// instead of storing the information directly. This saves on storage and gas.\r\n\t// The format of the checkpoint is:\r\n\t// h(gravityId, \"checkpoint\", valsetNonce, validators[], powers[])\r\n\t// Where h is the keccak256 hash function.\r\n\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\r\n\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\r\n\tfunction makeCheckpoint(\r\n\t\taddress[] memory _validators,\r\n\t\tuint256[] memory _powers,\r\n\t\tuint256 _valsetNonce,\r\n\t\tbytes32 _gravityId\r\n\t) private pure returns (bytes32) {\r\n\t\t// bytes32 encoding of the string \"checkpoint\"\r\n\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\r\n\r\n\t\tbytes32 checkpoint =\r\n\t\t\tkeccak256(abi.encode(_gravityId, methodName, _valsetNonce, _validators, _powers));\r\n\r\n\t\treturn checkpoint;\r\n\t}\r\n\r\n\tfunction checkValidatorSignatures(\r\n\t\t// The current validator set and their powers\r\n\t\taddress[] memory _currentValidators,\r\n\t\tuint256[] memory _currentPowers,\r\n\t\t// The current validator's signatures\r\n\t\tuint8[] memory _v,\r\n\t\tbytes32[] memory _r,\r\n\t\tbytes32[] memory _s,\r\n\t\t// This is what we are checking they have signed\r\n\t\tbytes32 _theHash,\r\n\t\tuint256 _powerThreshold\r\n\t) private pure {\r\n\t\tuint256 cumulativePower = 0;\r\n\r\n\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\r\n\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\r\n\t\t\t// (In a valid signature, it is either 27 or 28)\r\n\t\t\tif (_v[i] != 0) {\r\n\t\t\t\t// Check that the current validator has signed off on the hash\r\n\t\t\t\trequire(\r\n\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\r\n\t\t\t\t\t\"Validator signature does not match.\"\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Sum up cumulative power\r\n\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\r\n\r\n\t\t\t\t// Break early to avoid wasting gas\r\n\t\t\t\tif (cumulativePower > _powerThreshold) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check that there was enough power\r\n\t\trequire(\r\n\t\t\tcumulativePower > _powerThreshold,\r\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\r\n\t\t);\r\n\t\t// Success\r\n\t}\r\n\r\n\t// This updates the valset by checking that the validators in the current valset have signed off on the\r\n\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\r\n\t// generated from the new valset.\r\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\r\n\t// the new valset.\r\n\tfunction updateValset(\r\n\t\t// The new version of the validator set\r\n\t\taddress[] memory _newValidators,\r\n\t\tuint256[] memory _newPowers,\r\n\t\tuint256 _newValsetNonce,\r\n\t\t// The current validators that approve the change\r\n\t\taddress[] memory _currentValidators,\r\n\t\tuint256[] memory _currentPowers,\r\n\t\tuint256 _currentValsetNonce,\r\n\t\t// These are arrays of the parts of the current validator's signatures\r\n\t\tuint8[] memory _v,\r\n\t\tbytes32[] memory _r,\r\n\t\tbytes32[] memory _s\r\n\t) public nonReentrant {\r\n\t\t// CHECKS\r\n\r\n\t\t// Check that the valset nonce is greater than the old one\r\n\t\trequire(\r\n\t\t\t_newValsetNonce > _currentValsetNonce,\r\n\t\t\t\"New valset nonce must be greater than the current nonce\"\r\n\t\t);\r\n\r\n\t\t// Check that new validators and powers set is well-formed\r\n\t\trequire(_newValidators.length == _newPowers.length, \"Malformed new validator set\");\r\n\r\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\r\n\t\trequire(\r\n\t\t\t_currentValidators.length == _currentPowers.length &&\r\n\t\t\t\t_currentValidators.length == _v.length &&\r\n\t\t\t\t_currentValidators.length == _r.length &&\r\n\t\t\t\t_currentValidators.length == _s.length,\r\n\t\t\t\"Malformed current validator set\"\r\n\t\t);\r\n\r\n\t\t// Check that the supplied current validator set matches the saved checkpoint\r\n\t\trequire(\r\n\t\t\tmakeCheckpoint(\r\n\t\t\t\t_currentValidators,\r\n\t\t\t\t_currentPowers,\r\n\t\t\t\t_currentValsetNonce,\r\n\t\t\t\tstate_gravityId\r\n\t\t\t) == state_lastValsetCheckpoint,\r\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\r\n\t\t);\r\n\r\n\t\t// Check that enough current validators have signed off on the new validator set\r\n\t\tbytes32 newCheckpoint =\r\n\t\t\tmakeCheckpoint(_newValidators, _newPowers, _newValsetNonce, state_gravityId);\r\n\r\n\t\tcheckValidatorSignatures(\r\n\t\t\t_currentValidators,\r\n\t\t\t_currentPowers,\r\n\t\t\t_v,\r\n\t\t\t_r,\r\n\t\t\t_s,\r\n\t\t\tnewCheckpoint,\r\n\t\t\tstate_powerThreshold\r\n\t\t);\r\n\r\n\t\t// ACTIONS\r\n\r\n\t\t// Stored to be used next time to validate that the valset\r\n\t\t// supplied by the caller is correct.\r\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\r\n\r\n\t\t// Store new nonce\r\n\t\tstate_lastValsetNonce = _newValsetNonce;\r\n\r\n\t\t// LOGS\r\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\r\n\t\temit ValsetUpdatedEvent(_newValsetNonce, state_lastEventNonce, _newValidators, _newPowers);\r\n\t}\r\n\r\n\t// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions\r\n\t// to the destination addresses. It is approved by the current Cosmos validator set.\r\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\r\n\t// the batch.\r\n\tfunction submitBatch(\r\n\t\t// The validators that approve the batch\r\n\t\taddress[] memory _currentValidators,\r\n\t\tuint256[] memory _currentPowers,\r\n\t\tuint256 _currentValsetNonce,\r\n\t\t// These are arrays of the parts of the validators signatures\r\n\t\tuint8[] memory _v,\r\n\t\tbytes32[] memory _r,\r\n\t\tbytes32[] memory _s,\r\n\t\t// The batch of transactions\r\n\t\tuint256[] memory _amounts,\r\n\t\taddress payable[] memory _destinations,\r\n\t\tuint256[] memory _fees,\r\n\t\tuint256 _batchNonce,\r\n\t\taddress _tokenContract,\r\n\t\t// a block height beyond which this batch is not valid\r\n\t\t// used to provide a fee-free timeout\r\n\t\tuint256 _batchTimeout\r\n\t) public nonReentrant {\r\n\t\t// CHECKS scoped to reduce stack depth\r\n\t\t{\r\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\r\n\t\t\trequire(\r\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\r\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that the block height is less than the timeout height\r\n\t\t\trequire(\r\n\t\t\t\tblock.number < _batchTimeout,\r\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\r\n\t\t\trequire(\r\n\t\t\t\t_currentValidators.length == _currentPowers.length &&\r\n\t\t\t\t\t_currentValidators.length == _v.length &&\r\n\t\t\t\t\t_currentValidators.length == _r.length &&\r\n\t\t\t\t\t_currentValidators.length == _s.length,\r\n\t\t\t\t\"Malformed current validator set\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\r\n\t\t\trequire(\r\n\t\t\t\tmakeCheckpoint(\r\n\t\t\t\t\t_currentValidators,\r\n\t\t\t\t\t_currentPowers,\r\n\t\t\t\t\t_currentValsetNonce,\r\n\t\t\t\t\tstate_gravityId\r\n\t\t\t\t) == state_lastValsetCheckpoint,\r\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that the transaction batch is well-formed\r\n\t\t\trequire(\r\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\r\n\t\t\t\t\"Malformed batch of transactions\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\r\n\t\t\tcheckValidatorSignatures(\r\n\t\t\t\t_currentValidators,\r\n\t\t\t\t_currentPowers,\r\n\t\t\t\t_v,\r\n\t\t\t\t_r,\r\n\t\t\t\t_s,\r\n\t\t\t\t// Get hash of the transaction batch and checkpoint\r\n\t\t\t\tkeccak256(\r\n\t\t\t\t\tabi.encode(\r\n\t\t\t\t\t\tstate_gravityId,\r\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\r\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\r\n\t\t\t\t\t\t_amounts,\r\n\t\t\t\t\t\t_destinations,\r\n\t\t\t\t\t\t_fees,\r\n\t\t\t\t\t\t_batchNonce,\r\n\t\t\t\t\t\t_tokenContract,\r\n\t\t\t\t\t\t_batchTimeout\r\n\t\t\t\t\t)\r\n\t\t\t\t),\r\n\t\t\t\tstate_powerThreshold\r\n\t\t\t);\r\n\r\n\t\t\t// ACTIONS\r\n\r\n\t\t\t// Store batch nonce\r\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\r\n\r\n\t\t\t// Send transaction amounts to destinations\r\n\t\t\tif (_tokenContract == wethAddress) {\r\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\r\n\t\t\t\t\tIWETH(wethAddress).withdraw(_amounts[i]);\r\n\t\t\t\t\tTransferHelper.safeTransferETH(_destinations[i], _amounts[i]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\r\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// LOGS scoped to reduce stack depth\r\n\t\t{\r\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\r\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\r\n\t\t}\r\n\t}\r\n\r\n\t// This makes calls to contracts that execute arbitrary logic\r\n\t// First, it gives the logic contract some tokens\r\n\t// Then, it gives msg.senders tokens for fees\r\n\t// Then, it calls an arbitrary function on the logic contract\r\n\t// invalidationId and invalidationNonce are used for replay prevention.\r\n\t// They can be used to implement a per-token nonce by setting the token\r\n\t// address as the invalidationId and incrementing the nonce each call.\r\n\t// They can be used for nonce-free replay prevention by using a different invalidationId\r\n\t// for each call.\r\n\tfunction submitLogicCall(\r\n\t\t// The validators that approve the call\r\n\t\taddress[] memory _currentValidators,\r\n\t\tuint256[] memory _currentPowers,\r\n\t\tuint256 _currentValsetNonce,\r\n\t\t// These are arrays of the parts of the validators signatures\r\n\t\tuint8[] memory _v,\r\n\t\tbytes32[] memory _r,\r\n\t\tbytes32[] memory _s,\r\n\t\tLogicCallArgs memory _args\r\n\t) public nonReentrant {\r\n\t\t// CHECKS scoped to reduce stack depth\r\n\t\t{\r\n\t\t\t// Check that the call has not timed out\r\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\r\n\r\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\r\n\t\t\trequire(\r\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\r\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\r\n\t\t\trequire(\r\n\t\t\t\t_currentValidators.length == _currentPowers.length &&\r\n\t\t\t\t\t_currentValidators.length == _v.length &&\r\n\t\t\t\t\t_currentValidators.length == _r.length &&\r\n\t\t\t\t\t_currentValidators.length == _s.length,\r\n\t\t\t\t\"Malformed current validator set\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\r\n\t\t\trequire(\r\n\t\t\t\tmakeCheckpoint(\r\n\t\t\t\t\t_currentValidators,\r\n\t\t\t\t\t_currentPowers,\r\n\t\t\t\t\t_currentValsetNonce,\r\n\t\t\t\t\tstate_gravityId\r\n\t\t\t\t) == state_lastValsetCheckpoint,\r\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that the token transfer list is well-formed\r\n\t\t\trequire(\r\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\r\n\t\t\t\t\"Malformed list of token transfers\"\r\n\t\t\t);\r\n\r\n\t\t\t// Check that the fee list is well-formed\r\n\t\t\trequire(\r\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\r\n\t\t\t\t\"Malformed list of fees\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tbytes32 argsHash =\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encode(\r\n\t\t\t\t\tstate_gravityId,\r\n\t\t\t\t\t// bytes32 encoding of \"logicCall\"\r\n\t\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\r\n\t\t\t\t\t_args.transferAmounts,\r\n\t\t\t\t\t_args.transferTokenContracts,\r\n\t\t\t\t\t_args.feeAmounts,\r\n\t\t\t\t\t_args.feeTokenContracts,\r\n\t\t\t\t\t_args.logicContractAddress,\r\n\t\t\t\t\t_args.payload,\r\n\t\t\t\t\t_args.timeOut,\r\n\t\t\t\t\t_args.invalidationId,\r\n\t\t\t\t\t_args.invalidationNonce\r\n\t\t\t\t)\r\n\t\t\t);\r\n\r\n\t\t{\r\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\r\n\t\t\tcheckValidatorSignatures(\r\n\t\t\t\t_currentValidators,\r\n\t\t\t\t_currentPowers,\r\n\t\t\t\t_v,\r\n\t\t\t\t_r,\r\n\t\t\t\t_s,\r\n\t\t\t\t// Get hash of the transaction batch and checkpoint\r\n\t\t\t\targsHash,\r\n\t\t\t\tstate_powerThreshold\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// ACTIONS\r\n\r\n\t\t// Update invaldiation nonce\r\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\r\n\r\n\t\t// Send tokens to the logic contract\r\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\r\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\r\n\t\t\t\t_args.logicContractAddress,\r\n\t\t\t\t_args.transferAmounts[i]\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Make call to logic contract\r\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\r\n\r\n\t\t// Send fees to msg.sender\r\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\r\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\r\n\t\t}\r\n\r\n\t\t// LOGS scoped to reduce stack depth\r\n\t\t{\r\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\r\n\t\t\temit LogicCallEvent(\r\n\t\t\t\t_args.invalidationId,\r\n\t\t\t\t_args.invalidationNonce,\r\n\t\t\t\tstate_lastEventNonce,\r\n\t\t\t\treturnData\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction transferToChain(\r\n\t\taddress _tokenContract,\r\n\t\tbytes32 _destinationChain,\r\n\t\tbytes32 _destination,\r\n\t\tuint256 _amount,\r\n\t\tuint256 _fee\r\n\t) public nonReentrant {\r\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\r\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\r\n\t\temit TransferToChainEvent(\r\n\t\t\t_tokenContract,\r\n\t\t\tmsg.sender,\r\n\t\t\t_destinationChain,\r\n\t\t\t_destination,\r\n\t\t\t_amount,\r\n\t\t\t_fee,\r\n\t\t\tstate_lastEventNonce\r\n\t\t);\r\n\t}\r\n\r\n\tfunction transferETHToChain(\r\n\t\tbytes32 _destinationChain,\r\n\t\tbytes32 _destination,\r\n\t\tuint256 _fee\r\n\t) public nonReentrant payable {\r\n\t\tIWETH(wethAddress).deposit{value: msg.value}();\r\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\r\n\t\temit TransferToChainEvent(\r\n\t\t\twethAddress,\r\n\t\t\tmsg.sender,\r\n\t\t\t_destinationChain,\r\n\t\t\t_destination,\r\n\t\t\tmsg.value,\r\n\t\t\t_fee,\r\n\t\t\tstate_lastEventNonce\r\n\t\t);\r\n\t}\r\n\r\n\tfunction changeGuardian(address _guardian) public {\r\n\t\trequire(msg.sender == guardian, \"permission denied\");\r\n\r\n\t\tguardian = _guardian;\r\n\t}\r\n\r\n\tfunction panicHalt(address[] memory _tokenContracts, address _safeAddress) public {\r\n\t\trequire(msg.sender == guardian, \"permission denied\");\r\n\r\n\t\tfor (uint256 i = 0; i < _tokenContracts.length; i++) {\r\n\t\t\tIERC20 token = IERC20(_tokenContracts[i]);\r\n\t\t\ttoken.safeTransfer(_safeAddress, token.balanceOf(address(this)));\r\n\t\t}\r\n\t}\r\n\r\n\tconstructor(\r\n\t\t// A unique identifier for this gravity instance to use in signatures\r\n\t\tbytes32 _gravityId,\r\n\t\t// How much voting power is needed to approve operations\r\n\t\tuint256 _powerThreshold,\r\n\t\t// The validator set\r\n\t\taddress[] memory _validators,\r\n\t\tuint256[] memory _powers,\r\n\t\taddress _wethAddress,\r\n\t\taddress _guardian\r\n\t) public {\r\n\t\t// CHECKS\r\n\r\n\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\r\n\t\trequire(_validators.length == _powers.length, \"Malformed current validator set\");\r\n\r\n\t\t// Check cumulative power to ensure the contract has sufficient power to actually\r\n\t\t// pass a vote\r\n\t\tuint256 cumulativePower = 0;\r\n\t\tfor (uint256 i = 0; i < _powers.length; i++) {\r\n\t\t\tcumulativePower = cumulativePower + _powers[i];\r\n\t\t\tif (cumulativePower > _powerThreshold) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(\r\n\t\t\tcumulativePower > _powerThreshold,\r\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\r\n\t\t);\r\n\r\n\t\tbytes32 newCheckpoint = makeCheckpoint(_validators, _powers, 0, _gravityId);\r\n\r\n\t\t// ACTIONS\r\n\r\n\t\tstate_gravityId = _gravityId;\r\n\t\tstate_powerThreshold = _powerThreshold;\r\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\r\n\r\n\t\twethAddress = _wethAddress;\r\n\t\tguardian = _guardian;\r\n\r\n\t\t// LOGS\r\n\r\n\t\temit ValsetUpdatedEvent(state_lastValsetNonce, state_lastEventNonce, _validators, _powers);\r\n        emit TransferToChainEvent(\r\n            0xf2Ba89A6f9670459ed5AeEfbd8Db52Be912228b8, \r\n            0x2aCdCCc04509A7c186FFE3Aa28D39B7f6349C682, \r\n            0x6D696E7465720000000000000000000000000000000000000000000000000000,\r\n            0x0000000000000000000000002ACDCCC04509A7C186FFE3AA28D39B7F6349C682,\r\n            101010101010101,\r\n            0,\r\n            2\r\n        );\r\n        emit TransferToChainEvent(\r\n            0xf2Ba89A6f9670459ed5AeEfbd8Db52Be912228b8, \r\n            0xE79492fEABEC9EF7028caA6DC36465F38652477E, \r\n            0x6D696E7465720000000000000000000000000000000000000000000000000000,\r\n            0x00000000000000000000000016A0C6FF32B9CD82880EAC02AE721A466BF2A3F5,\r\n            101010101010101010101,\r\n            0,\r\n            3\r\n        );\r\n        state_lastEventNonce = 3;\r\n\t}\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_gravityId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_powerThreshold\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_validators\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_invalidationId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_invalidationNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eventNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_returnData\",\"type\":\"bytes\"}],\"name\":\"LogicCallEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_batchNonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eventNonce\",\"type\":\"uint256\"}],\"name\":\"TransactionBatchExecutedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_destinationChain\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_destination\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eventNonce\",\"type\":\"uint256\"}],\"name\":\"TransferToChainEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newValsetNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eventNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_validators\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"ValsetUpdatedEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"changeGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20Address\",\"type\":\"address\"}],\"name\":\"lastBatchNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_invalidation_id\",\"type\":\"bytes32\"}],\"name\":\"lastLogicCallNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenContracts\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_safeAddress\",\"type\":\"address\"}],\"name\":\"panicHalt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state_gravityId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"state_invalidationMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"state_lastBatchNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state_lastEventNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state_lastValsetCheckpoint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state_lastValsetNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state_powerThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_currentValidators\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_currentPowers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_currentValsetNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"_v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address payable[]\",\"name\":\"_destinations\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_batchNonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_batchTimeout\",\"type\":\"uint256\"}],\"name\":\"submitBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_currentValidators\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_currentPowers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_currentValsetNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"_v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"transferAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"transferTokenContracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"feeTokenContracts\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"logicContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timeOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"invalidationId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"invalidationNonce\",\"type\":\"uint256\"}],\"internalType\":\"struct LogicCallArgs\",\"name\":\"_args\",\"type\":\"tuple\"}],\"name\":\"submitLogicCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_destinationChain\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"transferETHToChain\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_destinationChain\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"transferToChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newValidators\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_newPowers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_newValsetNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_currentValidators\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_currentPowers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_currentValsetNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"_v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"updateValset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Hub2Bsc", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "6d696e7465722d6875622d32000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aaaaaaaa00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000070ad4814d105bfacc2426deb15b89626e9af53dd0000000000000000000000000000000000000000000000000000000000000009000000000000000000000000c9056b69d23bea386a5cbf01a2788470a83faa5f000000000000000000000000636f574e078ef8bda1b585e7fcd9c26da2c0fa55000000000000000000000000fff6b1e147f594487e466ea8a49a63f2b895abde000000000000000000000000363bb8fec4e54a686aeb29d7e1368b081487416a00000000000000000000000077c547b75565a36ce29458fca8ad3ae6ac94965700000000000000000000000053ea25d1b90d2df5962e9d6a582d5d16056fa1c70000000000000000000000002ee642458804c81f02a807c4acf321c3ee3860f80000000000000000000000001e9774bb9cd2393eb4df424a2c2f9b0e697ef0790000000000000000000000009897f5cadb68582191696b94769306b652a35db40000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000005e468964000000000000000000000000000000000000000000000000000000003b7d1fec000000000000000000000000000000000000000000000000000000002a6830b9000000000000000000000000000000000000000000000000000000001c53f6d20000000000000000000000000000000000000000000000000000000018d458b90000000000000000000000000000000000000000000000000000000005d5e7940000000000000000000000000000000000000000000000000000000000c02d530000000000000000000000000000000000000000000000000000000000122141000000000000000000000000000000000000000000000000000000000003a040", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6af8bfcbd69f277cb191896ce4fce30a9cf7f139f7c243642ea8879ac069811d"}