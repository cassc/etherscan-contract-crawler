{"SourceCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISwapRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ninterface ISwapFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"new is 0\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract TokenDistributor {\n    constructor (address token) {\n        IERC20(token).approve(msg.sender, uint(~uint256(0)));\n    }\n}\n\ninterface ISwapPair {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function token0() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\ncontract Abs is IERC20, Ownable {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    address public deadWallet = address(0xdEaD);\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    mapping(address => bool) public _feeWhiteList;\n    mapping(address => bool) public _blackList;\n    mapping(address => uint256) private _withdrawableBalances;\n    \n    uint256 private _tTotal;\n\n    ISwapRouter public _swapRouter;\n    address public _fist;\n    address public _burnToken;\n    mapping(address => bool) public _swapPairList;\n\n    bool private inSwap;\n\n    uint256 private constant MAX = ~uint256(0);\n    TokenDistributor public  _tokenDistributor;\n    TokenDistributor public _burnTokenDistributor;\n    TokenDistributor public _lpRewardTokenDistributor;\n\n    uint256 public _buyLPDividendFee = 100;\n    uint256 public _buyDeadFee = 100;\n    uint256 public _buyMarketingFee = 100;\n    uint256 public _buyFundFee = 0;\n\n    uint256 public _sellLPDividendFee = 300;\n    uint256 public _sellDeadFee = 100;\n    uint256 public _sellMarketingFee = 100;\n    uint256 public _sellFundFee = 2000;\n\n    uint256 public startTradeBlock;\n\n    address public _mainPair;\n    address public _lpReceiver;\n    address public _marketingWallet;\n    address public _fundWallet;\n\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor (\n        address RouterAddress, address FISTAddress,\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,\n        address ReceiveAddress, address LpReceiver, address MarketingWallet, address FundWallet\n    ){\n        _name = Name;\n        _symbol = Symbol;\n        _decimals = Decimals;\n\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\n        IERC20(FISTAddress).approve(address(swapRouter), MAX);\n\n        _fist = FISTAddress;\n        _lpReceiver = LpReceiver;\n        _marketingWallet = MarketingWallet;\n        _fundWallet = FundWallet;\n        _swapRouter = swapRouter;\n        _allowances[address(this)][address(swapRouter)] = MAX;\n\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\n        address swapPair = swapFactory.createPair(address(this), FISTAddress);\n        _mainPair = swapPair;\n        _swapPairList[swapPair] = true;\n\n        uint256 total = Supply * 10 ** Decimals;\n        _tTotal = total;\n\n        _balances[ReceiveAddress] = total;\n        emit Transfer(address(0), ReceiveAddress, total);\n\n        _feeWhiteList[ReceiveAddress] = true;\n        _feeWhiteList[address(this)] = true;\n        _feeWhiteList[address(swapRouter)] = true;\n        _feeWhiteList[msg.sender] = true;\n        _feeWhiteList[LpReceiver] = true;\n        _feeWhiteList[MarketingWallet] = true;\n\n        excludeHolder[address(0x000000000000000000000000000000000000dEaD)] = true;\n        excludeHolder[msg.sender] = true;\n        excludeHolder[ReceiveAddress] = true;\n        excludeHolder[_marketingWallet] = true;\n        excludeHolder[_fundWallet] = true;\n\n        holderRewardCondition = 10 * 10 ** IERC20(FISTAddress).decimals();\n        _tokenDistributor = new TokenDistributor(FISTAddress);\n        _lpRewardTokenDistributor = new TokenDistributor(FISTAddress);\n    }\n\n    function setBurnToken(address burnToken) external onlyOwner {\n        _burnToken = burnToken;\n        _burnTokenDistributor = new TokenDistributor(burnToken);\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (_allowances[sender][msg.sender] != MAX) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        }\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    bool public isAddV2;\n    bool public isRemoveV2;\n\n    function _isAddLiquidity(uint256 amount) internal view returns (bool isAdd){\n        ISwapPair mainPair = ISwapPair(_mainPair);\n        (uint r0, uint256 r1,) = mainPair.getReserves();\n\n        address tokenOther = _fist;\n        uint256 r;\n        uint256 rToken;\n        if (tokenOther < address(this)) {\n            r = r0;\n            rToken = r1;\n        } else {\n            r = r1;\n            rToken = r0;\n        }\n\n        uint bal = IERC20(tokenOther).balanceOf(address(mainPair));\n        if (rToken == 0) {\n            isAdd = bal > r;\n        } else {\n            isAdd = bal >= r + r * amount / rToken;\n        }\n    }\n\n    function _isRemoveLiquidity() internal view returns (bool isRemove){\n        ISwapPair mainPair = ISwapPair(_mainPair);\n        (uint r0,uint256 r1,) = mainPair.getReserves();\n\n        address tokenOther = _fist;\n        uint256 r;\n        if (tokenOther < address(this)) {\n            r = r0;\n        } else {\n            r = r1;\n        }\n\n        uint bal = IERC20(tokenOther).balanceOf(address(mainPair));\n        isRemove = r >= bal;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        uint256 balance = balanceOf(from);\n        require(balance >= amount, \"balanceNotEnough\");\n        require(!_blackList[to], \"The user is in black list\");\n\n        if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n            uint256 maxSellAmount = balance * 9999 / 10000;\n            if (amount > maxSellAmount) {\n                amount = maxSellAmount;\n            }\n        }\n\n        bool takeFee;\n        bool isSell;\n\n        bool isRemove;\n        bool isAdd;\n\n        if (_swapPairList[to]) {\n            isAdd = _isAddLiquidity(amount);\n            isAddV2 = isAdd;\n        } else if (_swapPairList[from]) {\n            isRemove = _isRemoveLiquidity();\n            isRemoveV2 = isRemove;\n        }\n\n        if (_swapPairList[from] || _swapPairList[to]) {\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n                if (0 == startTradeBlock) {\n                    require(0 < startAddLPBlock && _swapPairList[to], \"!startAddLP\");\n                }\n\n                if (block.number < startTradeBlock + 10) {\n                    _blackList[to] = true;\n                    _marketTransfer(from, to, amount);\n                    return;\n                }\n\n                if (_swapPairList[from] && !inSwap && !isRemove) {\n                    uint totalFee = _buyDeadFee + _buyLPDividendFee + _buyMarketingFee + _buyFundFee;\n                    uint amountBuyFee = amount * totalFee / 10000;\n                    _withdrawableBalances[to] += amount - amountBuyFee;\n                }\n\n                if (_swapPairList[to] && !inSwap && balanceOf(address(this)) > 0 && !isAdd && !isRemove) {\n                    swapTokenForFee();\n                }\n            }\n            \n            if (!isAdd && !isRemove) takeFee = true; // just swap fee\n        }\n\n        if (_swapPairList[to]) {\n            isSell = true;\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isSell);\n        if (from != address(this)) {\n            if (isSell) {\n                addHolder(from);\n            }\n            processReward(500000);\n        }\n    }\n\n    function _marketTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount = tAmount * 75 / 100;\n        _takeTransfer(\n            sender,\n            _marketingWallet,\n            feeAmount\n        );\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount,\n        bool takeFee,\n        bool isSell\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount;\n\n        if (takeFee) {\n            uint256 swapFee;\n            if (isSell) {\n                swapFee =  _sellLPDividendFee + _sellDeadFee + _sellMarketingFee + _sellFundFee;\n            } else {\n                swapFee =  _buyLPDividendFee + _buyDeadFee + _buyMarketingFee + _buyFundFee;\n            }\n\n            uint256 swapAmount = (tAmount * swapFee) / 10000;\n            if (swapAmount > 0) {\n                feeAmount += swapAmount;\n                _takeTransfer(\n                    sender,\n                    address(this),\n                    swapAmount\n                );\n            }\n        }\n\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    event Failed_swapExactTokensForETHSupportingFeeOnTransferTokens();\n\n    function swapTokenForFee() private lockTheSwap {\n        uint256 taxAmount = balanceOf(address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _fist;\n        \n        bool success = false;\n        try _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            taxAmount,\n            0,\n            path,\n            address(_tokenDistributor),\n            block.timestamp\n        ) {\n            success = true;\n        } catch { emit Failed_swapExactTokensForETHSupportingFeeOnTransferTokens(); }\n         \n        IERC20 FIST = IERC20(_fist);\n        uint256 fistBalance = FIST.balanceOf(address(_tokenDistributor));\n        uint256 totalFee = _buyDeadFee + \n            _buyLPDividendFee + \n            _buyMarketingFee + \n            _buyFundFee +\n            _sellDeadFee +\n            _sellLPDividendFee +\n            _sellMarketingFee +\n            _sellFundFee;\n        uint256 amountBurn = (fistBalance) * (_buyDeadFee + _sellDeadFee) / (totalFee);\n        uint256 amountMarketing = (fistBalance) * (_buyMarketingFee + _sellMarketingFee) / (totalFee);\n        uint256 amountFund = (fistBalance) * (_buyFundFee + _sellFundFee) / (totalFee);\n\n        FIST.transferFrom(address(_tokenDistributor), _marketingWallet, amountMarketing);\n        FIST.transferFrom(address(_tokenDistributor), _fundWallet, amountFund);\n        FIST.transferFrom(address(_tokenDistributor), address(this), amountBurn);\n        FIST.transferFrom(address(_tokenDistributor), address(_lpRewardTokenDistributor), fistBalance - amountMarketing - amountFund - amountBurn);\n\n        // swap back token to burn\n        swapBack();\n\n        if (!success) {\n            return;\n        }\n    }\n\n    function swapBack() private {\n        address[] memory path = new address[](2);\n        path[0] = _fist;\n        path[1] = _burnToken;\n\n        bool success = false;\n        try _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            IERC20(_fist).balanceOf(address(this)),\n            0,\n            path,\n            address(_burnTokenDistributor),\n            block.timestamp\n        ) {\n            success = true;\n        } catch { emit Failed_swapExactTokensForETHSupportingFeeOnTransferTokens(); }\n        \n        IERC20 FIST = IERC20(_burnToken);\n        uint256 deadFeeAmount = FIST.balanceOf(address(_burnTokenDistributor));\n        FIST.transferFrom(address(_burnTokenDistributor), deadWallet, deadFeeAmount);\n\n        if (!success) {\n            return;\n        }\n    }\n\n    function _takeTransfer(\n        address sender,\n        address to,\n        uint256 tAmount\n    ) private {\n        _balances[to] = _balances[to] + tAmount;\n        emit Transfer(sender, to, tAmount);\n    }\n\n    function multi_bclist(\n        address[] calldata addresses,\n        bool value\n    ) public onlyOwner {\n        require(addresses.length < 201);\n        for (uint256 i; i < addresses.length; ++i) {\n            _blackList[addresses[i]] = value;\n        }\n    }\n\n    function setBuyMarketingFee(uint256 fee) external onlyOwner {\n        _buyMarketingFee = fee;\n    }\n\n    function setSellMarketingFee(uint256 fee) external onlyOwner {\n        _sellMarketingFee = fee;\n    }\n\n    function setBuyDeadFee(uint256 fee) external onlyOwner {\n        _buyDeadFee = fee;\n    }\n\n    function setSellDeadFee(uint256 fee) external onlyOwner {\n        _sellDeadFee = fee;\n    }\n\n    function setBuyLPDividendFee(uint256 fee) external onlyOwner {\n        _buyLPDividendFee = fee;\n    }\n\n    function setSellLPDividendFee(uint256 fee) external onlyOwner {\n        _sellLPDividendFee = fee;\n    }\n\n    function setBuyFundFee(uint256 fee) external onlyOwner {\n        _buyFundFee = fee;\n    }\n\n    function setSellFundFee(uint256 fee) external onlyOwner {\n        _sellFundFee = fee;\n    }\n\n    function setLpReceiver(address addr) external onlyOwner {\n         _lpReceiver = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function setMarketingWallet(address addr) external onlyOwner {\n         _marketingWallet = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function setFundWallet(address addr) external onlyOwner {\n        _fundWallet = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function getWithdrawableBalances(address to) external view returns(uint256) {\n        return _withdrawableBalances[to];\n    }\n\n    uint256 public startAddLPBlock;\n\n    function startAddLP() external onlyOwner {\n        require(0 == startAddLPBlock, \"startedAddLP\");\n        startAddLPBlock = block.number;\n    }\n\n    function closeAddLP() external onlyOwner {\n        startAddLPBlock = 0;\n    }\n\n    function startTrade() external onlyOwner {\n        require(0 == startTradeBlock, \"trading\");\n        startTradeBlock = block.number;\n    }\n\n    function setFeeWhiteList(address addr, bool enable) external onlyOwner {\n        _feeWhiteList[addr] = enable;\n    }\n\n    function setSwapPairList(address addr, bool enable) external onlyOwner {\n        _swapPairList[addr] = enable;\n    }\n\n    function claimBalance() external {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function claimToken(address token, uint256 amount) external {\n        IERC20(token).transfer(owner(), amount);\n    }\n\n    receive() external payable {}\n\n    address[] private holders;\n    mapping(address => uint256) holderIndex;\n    mapping(address => bool) excludeHolder;\n\n    function addHolder(address adr) private {\n        uint256 size;\n        assembly {size := extcodesize(adr)}\n        if (size > 0) {\n            return;\n        }\n        if (0 == holderIndex[adr]) {\n            if (0 == holders.length || holders[0] != adr) {\n                holderIndex[adr] = holders.length;\n                holders.push(adr);\n            }\n        }\n    }\n\n    uint256 private currentIndex;\n    uint256 private holderRewardCondition;\n    uint256 private progressRewardBlock;\n    uint256 public  rewardTime = 100;\n\n    function processReward(uint256 gas) private {\n        if (progressRewardBlock + rewardTime > block.number) {\n            return;\n        }\n\n        IERC20 FIST = IERC20(_fist);\n\n        uint256 balance = FIST.balanceOf(address(_lpRewardTokenDistributor));\n        if (balance < holderRewardCondition) {\n            return;\n        }\n\n        IERC20 holdToken = IERC20(_mainPair);\n        uint holdTokenTotal = holdToken.totalSupply();\n\n        address shareHolder;\n        uint256 tokenBalance;\n        uint256 amount;\n\n        uint256 shareholderCount = holders.length;\n\n        uint256 gasUsed = 0;\n        uint256 iterations = 0;\n        uint256 gasLeft = gasleft();\n\n        while (gasUsed < gas && iterations < shareholderCount) {\n            if (currentIndex >= shareholderCount) {\n                currentIndex = 0;\n            }\n            shareHolder = holders[currentIndex];\n            tokenBalance = holdToken.balanceOf(shareHolder);\n            if (tokenBalance > 0 && !excludeHolder[shareHolder]) {\n                amount = balance * tokenBalance / holdTokenTotal;\n                if (amount > 0) {\n                    FIST.transferFrom(address(_lpRewardTokenDistributor), _lpReceiver, amount);\n                }\n            }\n\n            gasUsed = gasUsed + (gasLeft - gasleft());\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n\n        progressRewardBlock = block.number;\n    }\n\n    function setRewardTime(uint256 time) external onlyOwner {\n        rewardTime = time;\n    }\n\n    function getHolderReward(address shareHolder) external view returns (uint256) {\n        IERC20 FIST = IERC20(_fist);\n        uint256 balance = FIST.balanceOf(address(this));\n\n        uint256 tokenBalance;\n        IERC20 holdToken = IERC20(_mainPair);\n        uint holdTokenTotal = holdToken.totalSupply();\n        uint256 shareholderCount = holders.length;\n        for (uint i = 0; i < shareholderCount; ++i) {\n            if (shareHolder == holders[i]) {\n                tokenBalance = holdToken.balanceOf(shareHolder);\n                if (tokenBalance > 0 && !excludeHolder[shareHolder]) {\n                    uint256 amount = balance * tokenBalance / holdTokenTotal;\n                    if (amount > 0) return amount;\n                }\n            }\n        }\n        return 0;\n    }\n\n    function setHolderRewardCondition(uint256 amount) external onlyOwner {\n        holderRewardCondition = amount * 10 ** IERC20(_fist).decimals();\n    }\n\n    function setExcludeHolder(address addr, bool enable) external onlyOwner {\n        excludeHolder[addr] = enable;\n    }\n}\n\ncontract GDS is Abs {\n    constructor() Abs (\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),    // router\n        address(0x55d398326f99059fF775485246999027B3197955),    // usdt\n        \"GDS\",\n        \"GDS\",\n        18,\n        1500000,\n        address(0xCC608d3b9B991c55D54d8e089f73d1dad695eef6),    // receiver\n        address(0xFE1CF9B53613b41D000BfC2f43C36ef32045F877),    // lpReceiver\n        address(0xf9FA93Ff4f7f2C5151E30AA8fD753b423EB9363a),    // marketingWallet\n        address(0xE14e7236aEFd9541039EF4aAC1721CE8efd11a8e)     // fundAddress\n    ) {}\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Failed_swapExactTokensForETHSupportingFeeOnTransferTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnTokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyDeadFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyLPDividendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fundWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpRewardTokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellDeadFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLPDividendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeAddLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareHolder\",\"type\":\"address\"}],\"name\":\"getHolderReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getWithdrawableBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAddV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRemoveV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"multi_bclist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"}],\"name\":\"setBurnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setBuyDeadFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setBuyFundFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setBuyLPDividendFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setBuyMarketingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setExcludeHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setHolderRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setLpReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setRewardTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setSellDeadFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setSellFundFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setSellLPDividendFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setSellMarketingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAddLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAddLPBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GDS", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}