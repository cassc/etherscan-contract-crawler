{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary ZOSLibAddress {\r\n    function isContract(address account) internal view returns (bool x) {\r\n        assembly { \r\n          let size := extcodesize(account)\r\n          x := gt(size, 0)\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Proxy{\r\n  constructor(){}\r\n  fallback () payable external {\r\n    _fallback();\r\n  }\r\n\r\n  receive() external payable {\r\n    _fallback();\r\n  }\r\n\r\n  function _implementation() internal view virtual returns (address);\r\n\r\n  function _delegate(address implementation) internal {\r\n    assembly {\r\n      calldatacopy(0, 0, calldatasize())\r\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n      returndatacopy(0, 0, returndatasize())\r\n      switch result\r\n      case 0 { revert(0, returndatasize()) }\r\n      default { return(0, returndatasize()) }\r\n    }\r\n  }\r\n\r\n  function _willFallback() internal virtual {}\r\n\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n\r\n\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n  event Upgraded(address indexed implementation);\r\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n  function _implementation() override internal view returns (address impl) {\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  function _setImplementation(address newImplementation) internal {\r\n    require(ZOSLibAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    assembly {\r\n      sstore(slot, newImplementation)\r\n    }\r\n  }\r\n}\r\n\r\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  event AdminChanged(address previousAdmin, address newAdmin);\r\n  bytes32 internal constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  modifier ifAdmin() {\r\n    if (msg.sender == _admin()) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  function admin() external ifAdmin returns (address _adminAddr) {\r\n    _adminAddr = _admin();\r\n    return _adminAddr;\r\n  }\r\n\r\n  function implementation() external ifAdmin returns (address _imp) {\r\n    _imp = _implementation();\r\n    return _imp;\r\n  }\r\n\r\n  function changeAdmin(address newAdmin) external ifAdmin {\r\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n    emit AdminChanged(_admin(), newAdmin);\r\n    _setAdmin(newAdmin);\r\n  }\r\n\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n    (bool success,) = newImplementation.delegatecall(data);\r\n    require(success);\r\n  }\r\n\r\n  function _admin() internal view returns (address adm) {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    assembly {\r\n      adm := sload(slot)\r\n    }\r\n  }\r\n\r\n  function _setAdmin(address newAdmin) internal {\r\n    bytes32 slot = ADMIN_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newAdmin)\r\n    }\r\n  }\r\n\r\n  // function _willFallback() override virtual internal {\r\n  //   require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n  //   super._willFallback();\r\n  // }\r\n}\r\n\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  constructor(address _logic, bytes memory _data) payable {\r\n    assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\r\n    _setImplementation(_logic);\r\n    if(_data.length > 0) {\r\n      (bool success,) = _logic.delegatecall(_data);\r\n      require(success);\r\n    }\r\n  }\r\n}\r\n\r\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\r\n\r\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) payable {\r\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n    _setAdmin(_admin);\r\n  }\r\n\r\n  function _willFallback() override virtual internal {\r\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n    super._willFallback();\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_imp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AdminUpgradeabilityProxy", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b91efaf1f8fcd34d772e662c9d918dbe6554b1280000000000000000000000001746a861a0ca10feeffff8f62cccc6ef67f73204000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c44cd88b7600000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b5348454c4c20544f4b454e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055348454c4c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x70d451dd6f68d9a5f33990e04058bc85de34daa7", "SwarmSource": "ipfs://b19e98ed56f7105d9dba7a9a58dd948e28cf216e3bcd6e9150295d65848fcd04"}