{"SourceCode": "//SPDX-License-Identifier:MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 amount) external;\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event ApprovalForAll(\r\n        address indexed account,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n\r\n    function balanceOf(\r\n        address account,\r\n        uint256 id\r\n    ) external view returns (uint256);\r\n\r\n    function isApprovedForAll(\r\n        address account,\r\n        address operator\r\n    ) external view returns (bool);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IMasterNFT {\r\n    function transferHelper(\r\n        address[] memory _addresses,\r\n        uint256[] memory _tokenIds\r\n    ) external;\r\n}\r\n\r\nerror PaymentTokenIsNotApproved();\r\nerror PaymentError();\r\nerror AlreadyStakeHolder();\r\nerror StakePeriodNotCompleted();\r\nerror NotStakeHolder();\r\nerror LRNT_Transfer_Failed();\r\nerror LRN_Transfer_Failed();\r\nerror No_LRN_BALANCE_PleaseContactAdmin();\r\nerror LRN_Not_Approved_PleaseContactAdmin();\r\nerror Not_LRNT_Holder();\r\nerror No_LRNT_Remains();\r\nerror Please_Wait_Till(uint256 deadline);\r\nerror NotEnabled();\r\nerror ConversionIsNotAvailable();\r\n\r\ncontract GMETokenSystem is Ownable {\r\n    IERC20 private wisdomToken;\r\n    IERC20 private LRNToken;\r\n    IERC20 private LRNTToken;\r\n\r\n    IERC1155 private nftToken;\r\n    IMasterNFT private masterContract;\r\n\r\n    address[] private approvedPaymentTokenList;\r\n    address[] private approvedSellTokenList;\r\n    address private multisigWallet;\r\n\r\n    mapping(address => bool) private isApprovedToken;\r\n    mapping(address => bool) private isApprovedSellToken;\r\n    mapping(address => StakeInfo) private stakeInfo;\r\n    mapping(address => UserInfo) private addressToUserInfo;\r\n\r\n    uint256 private startTime;\r\n    uint256 private months = 2629743;\r\n    uint256 private tokenId;\r\n    uint256 private SMReward = 3;\r\n    uint256 private SMRewardWL = 9;\r\n    uint256 private TMReward = 7;\r\n    uint256 private TMRewardWL = 186;\r\n\r\n    uint256 private stableToLRNPrice;\r\n\r\n    uint256 private minNFTRewardPerk;\r\n    bool private isNFTRewardEnable;\r\n    bool private isBuyLRNEnable;\r\n    bool private isSellWisdomEnable;\r\n    bool private isConversionEnable;\r\n    mapping(address => bool) private isListed;\r\n\r\n    enum Stake {\r\n        WIS,\r\n        WISLRN,\r\n        LRN\r\n    }\r\n\r\n    enum Month {\r\n        Six,\r\n        Twelve\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 LRNTToken;\r\n        uint256 claimedLRNTToken;\r\n        uint256 unclaimedLRNTToken;\r\n        uint256 lastClaimedAt;\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint256 stakedAt;\r\n        uint256 unstakedAt;\r\n        uint256 stakeWISAmount;\r\n        uint256 stakeLRNAmount;\r\n        uint256 rewardWISAmount;\r\n        uint256 totalWISAmount;\r\n        Stake stake;\r\n        Month month;\r\n    }\r\n\r\n    constructor(\r\n        address _wisdom,\r\n        address _lrn,\r\n        address _lrnt,\r\n        address _nftToken,\r\n        address _masterContract,\r\n        address[] memory _tokens,\r\n        address _multiSig,\r\n        uint256 _stlPrice\r\n    ) {\r\n        wisdomToken = IERC20(_wisdom);\r\n        LRNToken = IERC20(_lrn);\r\n        LRNTToken = IERC20(_lrnt);\r\n        stableToLRNPrice = _stlPrice;\r\n        nftToken = IERC1155(_nftToken);\r\n        masterContract = IMasterNFT(_masterContract);\r\n        minNFTRewardPerk = 300000 * 10 ** 18;\r\n        multisigWallet = _multiSig;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            isApprovedToken[_tokens[i]] = true;\r\n            approvedPaymentTokenList.push(_tokens[i]);\r\n        }\r\n        startTime = block.timestamp;\r\n    }\r\n\r\n    function _transferNFT(address _to) internal {\r\n        address[] memory toAddresses = new address[](1);\r\n        toAddresses[0] = _to;\r\n        uint256[] memory ids = new uint256[](1);\r\n        ids[0] = tokenId;\r\n        if (nftToken.balanceOf(address(this), tokenId) > 0) {\r\n            if (\r\n                nftToken.isApprovedForAll(\r\n                    address(this),\r\n                    address(masterContract)\r\n                ) == true\r\n            ) {\r\n                masterContract.transferHelper(toAddresses, ids);\r\n            } else {\r\n                nftToken.setApprovalForAll(address(masterContract), true);\r\n                masterContract.transferHelper(toAddresses, ids);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsNFTRewardEnable(bool _isEnable) public onlyOwner {\r\n        isNFTRewardEnable = _isEnable;\r\n    }\r\n\r\n    function setMinNFTRewardPark(uint256 _park) public onlyOwner {\r\n        minNFTRewardPerk = _park;\r\n    }\r\n\r\n    function updateNFTToken(address _new) public onlyOwner {\r\n        nftToken = IERC1155(_new);\r\n    }\r\n\r\n    function updateMasterContract(address _new) public onlyOwner {\r\n        masterContract = IMasterNFT(_new);\r\n    }\r\n\r\n    function updateTokenId(uint256 _id) public onlyOwner {\r\n        tokenId = _id;\r\n    }\r\n\r\n    function setWisdomTokenn(address _wisdom) public onlyOwner {\r\n        wisdomToken = IERC20(_wisdom);\r\n    }\r\n\r\n    function setLRNToken(address _lrn) public onlyOwner {\r\n        LRNToken = IERC20(_lrn);\r\n    }\r\n\r\n    function setLRNTToken(address _token) public onlyOwner {\r\n        LRNTToken = IERC20(_token);\r\n    }\r\n\r\n    function setMultiSigWallet(address _new) public onlyOwner {\r\n        multisigWallet = _new;\r\n    }\r\n\r\n    function setStartTime() public onlyOwner {\r\n        startTime = block.timestamp;\r\n    }\r\n\r\n    function setConversionEnable(bool _mode) public onlyOwner {\r\n        isConversionEnable = _mode;\r\n    }\r\n\r\n    function setStableToLRNPrice(uint256 _newPrice) public onlyOwner {\r\n        stableToLRNPrice = _newPrice;\r\n    }\r\n\r\n    function UpdateRewardAmount(\r\n        uint256 _smReward,\r\n        uint256 _smRewardWL,\r\n        uint256 _tmReward,\r\n        uint256 _tmRewardWL\r\n    ) public onlyOwner {\r\n        SMReward = _smReward;\r\n        SMRewardWL = _smRewardWL;\r\n        TMReward = _tmReward;\r\n        TMRewardWL = _tmRewardWL;\r\n    }\r\n\r\n    function addPaymentToken(address[] memory _tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            isApprovedToken[_tokens[i]] = true;\r\n            approvedPaymentTokenList.push(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    function addSellToken(address[] memory _tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            isApprovedSellToken[_tokens[i]] = true;\r\n            approvedSellTokenList.push(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    function removePaymentToken(address _token) public onlyOwner {\r\n        isApprovedToken[_token] = false;\r\n\r\n        for (uint256 i = 0; i < approvedPaymentTokenList.length; i++) {\r\n            if (approvedPaymentTokenList[i] == _token) {\r\n                approvedPaymentTokenList[i] = approvedPaymentTokenList[\r\n                    approvedPaymentTokenList.length - 1\r\n                ];\r\n                approvedPaymentTokenList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeSellToken(address _token) public onlyOwner {\r\n        isApprovedSellToken[_token] = false;\r\n\r\n        for (uint256 i = 0; i < approvedSellTokenList.length; i++) {\r\n            if (approvedSellTokenList[i] == _token) {\r\n                approvedSellTokenList[i] = approvedSellTokenList[\r\n                    approvedSellTokenList.length - 1\r\n                ];\r\n                approvedSellTokenList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(address _token) public onlyOwner {\r\n        IERC20 token = IERC20(_token);\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n\r\n    function convertion() public returns (bool) {\r\n        if (!isConversionEnable) {\r\n            revert ConversionIsNotAvailable();\r\n        }\r\n        UserInfo storage user = addressToUserInfo[msg.sender];\r\n        uint256 tAmount;\r\n        uint256 interval;\r\n        uint256 calculatedDays;\r\n        if (isListed[msg.sender]) {\r\n            interval = block.timestamp - user.lastClaimedAt;\r\n            calculatedDays += interval / 1 days;\r\n            tAmount = (user.LRNTToken * calculatedDays * 5) / 1000;\r\n        } else {\r\n            isListed[msg.sender] = true;\r\n            uint256 bal = LRNTToken.balanceOf(msg.sender);\r\n            user.LRNTToken = bal;\r\n            user.unclaimedLRNTToken = bal;\r\n            user.claimedLRNTToken = 0;\r\n            interval = block.timestamp - startTime;\r\n            calculatedDays = interval > 1 days ? interval / 1 days : 1;\r\n            tAmount = (user.LRNTToken * calculatedDays * 5) / 1000;\r\n        }\r\n\r\n        if (interval < 1 days) {\r\n            if (user.lastClaimedAt != 0) {\r\n                revert Please_Wait_Till(user.lastClaimedAt + 1 days);\r\n            }\r\n        }\r\n\r\n        if (user.LRNTToken == 0) {\r\n            revert Not_LRNT_Holder();\r\n        }\r\n\r\n        if (user.unclaimedLRNTToken == 0) {\r\n            revert No_LRNT_Remains();\r\n        }\r\n        uint256 lrnWBal = LRNToken.balanceOf(multisigWallet);\r\n        if (lrnWBal < tAmount) {\r\n            revert No_LRN_BALANCE_PleaseContactAdmin();\r\n        }\r\n\r\n        uint256 allow = LRNToken.allowance(multisigWallet, address(this));\r\n        if (allow < tAmount) {\r\n            revert LRN_Not_Approved_PleaseContactAdmin();\r\n        }\r\n\r\n        user.claimedLRNTToken += tAmount;\r\n        user.unclaimedLRNTToken -= tAmount;\r\n        user.lastClaimedAt = block.timestamp;\r\n\r\n        bool success = LRNTToken.transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            tAmount\r\n        );\r\n        if (!success) {\r\n            revert LRNT_Transfer_Failed();\r\n        }\r\n        bool successTwo = LRNToken.transferFrom(\r\n            multisigWallet,\r\n            msg.sender,\r\n            tAmount\r\n        );\r\n        if (!successTwo) {\r\n            revert LRN_Transfer_Failed();\r\n        }\r\n        LRNTToken.burn(tAmount);\r\n        return true;\r\n    }\r\n\r\n    function buyWisdom(address _paymentToken, uint256 _amount) public {\r\n        if (!isApprovedToken[_paymentToken]) {\r\n            revert PaymentTokenIsNotApproved();\r\n        }\r\n\r\n        bool success = IERC20(_paymentToken).transferFrom(\r\n            msg.sender,\r\n            multisigWallet,\r\n            _amount\r\n        );\r\n        if (!success) {\r\n            revert PaymentError();\r\n        }\r\n\r\n        wisdomToken.transferFrom(multisigWallet, msg.sender, _amount);\r\n    }\r\n\r\n    function buyWisdomWithLRN(uint256 _wAmount) public {\r\n        uint256 lAmount = (_wAmount * stableToLRNPrice) / 10 ** 18;\r\n        bool success = LRNToken.transferFrom(\r\n            msg.sender,\r\n            multisigWallet,\r\n            lAmount\r\n        );\r\n        if (!success) {\r\n            revert PaymentError();\r\n        }\r\n        wisdomToken.transferFrom(multisigWallet, msg.sender, _wAmount);\r\n    }\r\n\r\n    function sellWisdom(address _token, uint256 _amount) public {\r\n        if (!isSellWisdomEnable) {\r\n            revert NotEnabled();\r\n        }\r\n        if (!isApprovedSellToken[_token]) {\r\n            revert PaymentTokenIsNotApproved();\r\n        }\r\n\r\n        bool success = wisdomToken.transferFrom(\r\n            msg.sender,\r\n            multisigWallet,\r\n            _amount\r\n        );\r\n        if (!success) {\r\n            revert PaymentError();\r\n        }\r\n        IERC20(_token).transferFrom(multisigWallet, msg.sender, _amount);\r\n    }\r\n\r\n    function buyLRN(address _paymentToken, uint256 _amount) public {\r\n        if (!isBuyLRNEnable) {\r\n            revert NotEnabled();\r\n        }\r\n        if (!isApprovedToken[_paymentToken]) {\r\n            revert PaymentTokenIsNotApproved();\r\n        }\r\n        uint256 lAmount = (_amount * stableToLRNPrice) / 10 ** 18;\r\n        bool success = IERC20(_paymentToken).transferFrom(\r\n            msg.sender,\r\n            multisigWallet,\r\n            _amount\r\n        );\r\n        if (!success) {\r\n            revert PaymentError();\r\n        }\r\n\r\n        LRNToken.transferFrom(multisigWallet, msg.sender, lAmount);\r\n    }\r\n\r\n    function stake(Stake _stake, Month _month, uint256 _amount) public {\r\n        if (stakeInfo[msg.sender].stakedAt != 0) {\r\n            revert AlreadyStakeHolder();\r\n        }\r\n        uint256 unstakeTime;\r\n        uint256 WISReward;\r\n        uint256 totalWIS;\r\n\r\n        if (_stake == Stake.WIS) {\r\n            if (_month == Month.Six) {\r\n                unstakeTime = block.timestamp + (6 * months);\r\n                WISReward = (_amount * SMReward) / 100;\r\n                totalWIS = _amount + WISReward;\r\n            } else if (_month == Month.Twelve) {\r\n                unstakeTime = block.timestamp + (12 * months);\r\n                WISReward = (_amount * TMReward) / 100;\r\n                totalWIS = _amount + WISReward;\r\n            }\r\n            stakeInfo[msg.sender] = StakeInfo(\r\n                block.timestamp,\r\n                unstakeTime,\r\n                _amount,\r\n                0,\r\n                WISReward,\r\n                totalWIS,\r\n                _stake,\r\n                _month\r\n            );\r\n            bool success = wisdomToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _amount\r\n            );\r\n            if (!success) {\r\n                revert PaymentError();\r\n            }\r\n        } else if (_stake == Stake.WISLRN) {\r\n            if (_month == Month.Six) {\r\n                unstakeTime = block.timestamp + (6 * months);\r\n                WISReward = (_amount * SMRewardWL) / 100;\r\n                totalWIS = _amount + WISReward;\r\n            } else {\r\n                unstakeTime = block.timestamp + (12 * months);\r\n                WISReward = (_amount * TMRewardWL) / 1000;\r\n                totalWIS = _amount + WISReward;\r\n            }\r\n            stakeInfo[msg.sender] = StakeInfo(\r\n                block.timestamp,\r\n                unstakeTime,\r\n                _amount,\r\n                _amount,\r\n                WISReward,\r\n                totalWIS,\r\n                _stake,\r\n                _month\r\n            );\r\n            bool success = wisdomToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _amount\r\n            );\r\n            if (!success) {\r\n                revert PaymentError();\r\n            }\r\n            uint256 lAmount = (_amount * stableToLRNPrice) / 10 ** 18;\r\n            bool successT = LRNToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                lAmount\r\n            );\r\n            if (!successT) {\r\n                revert PaymentError();\r\n            }\r\n        } else if (_stake == Stake.LRN) {\r\n            if (_month == Month.Six) {\r\n                unstakeTime = block.timestamp + (6 * months);\r\n                WISReward = (_amount * SMReward) / 100;\r\n                totalWIS = WISReward;\r\n            } else {\r\n                unstakeTime = block.timestamp + (12 * months);\r\n                WISReward = (_amount * TMReward) / 100;\r\n                totalWIS = WISReward;\r\n            }\r\n            stakeInfo[msg.sender] = StakeInfo(\r\n                block.timestamp,\r\n                unstakeTime,\r\n                0,\r\n                _amount,\r\n                WISReward,\r\n                totalWIS,\r\n                _stake,\r\n                _month\r\n            );\r\n            bool success = LRNToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _amount\r\n            );\r\n            if (!success) {\r\n                revert PaymentError();\r\n            }\r\n        }\r\n\r\n        if (isNFTRewardEnable == true) {\r\n            if (_amount >= minNFTRewardPerk) {\r\n                _transferNFT(msg.sender);\r\n            }\r\n        }\r\n    }\r\n\r\n    function unstake() public returns (bool) {\r\n        StakeInfo storage _stake = stakeInfo[msg.sender];\r\n        if (_stake.stakedAt == 0) {\r\n            revert NotStakeHolder();\r\n        }\r\n        if (block.timestamp < _stake.unstakedAt) {\r\n            revert StakePeriodNotCompleted();\r\n        }\r\n\r\n        if (_stake.stakeLRNAmount != 0) {\r\n            LRNToken.transfer(msg.sender, _stake.stakeLRNAmount);\r\n        }\r\n        if (_stake.totalWISAmount != 0) {\r\n            wisdomToken.transfer(msg.sender, _stake.totalWISAmount);\r\n        }\r\n        delete stakeInfo[msg.sender];\r\n        return true;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external pure returns (bytes4) {\r\n        return\r\n            bytes4(\r\n                keccak256(\r\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\r\n                )\r\n            );\r\n    }\r\n\r\n    function getWisdomToken() public view returns (address) {\r\n        return address(wisdomToken);\r\n    }\r\n\r\n    function getLRNToken() public view returns (address) {\r\n        return address(wisdomToken);\r\n    }\r\n\r\n    function getRewardInfo()\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256, uint256)\r\n    {\r\n        return (SMReward, TMReward, SMRewardWL, TMRewardWL);\r\n    }\r\n\r\n    function getStakeInfo(\r\n        address _user\r\n    ) public view returns (StakeInfo memory) {\r\n        return stakeInfo[_user];\r\n    }\r\n\r\n    function getApprovedPaymentTokenList()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return approvedPaymentTokenList;\r\n    }\r\n\r\n    function getApprovedSellTokenList() public view returns (address[] memory) {\r\n        return approvedSellTokenList;\r\n    }\r\n\r\n    function getIsApprovedToken(address _token) public view returns (bool) {\r\n        return isApprovedToken[_token];\r\n    }\r\n\r\n    function getIsApprovedSellToken(address _token) public view returns (bool) {\r\n        return isApprovedSellToken[_token];\r\n    }\r\n\r\n    function getMinNFTRewardPark() public view returns (uint256) {\r\n        return minNFTRewardPerk;\r\n    }\r\n\r\n    function getIsNFTRewardEnable() public view returns (bool) {\r\n        return isNFTRewardEnable;\r\n    }\r\n\r\n    function getWISToLRNPrice() public view returns (uint256) {\r\n        return stableToLRNPrice;\r\n    }\r\n\r\n    function updateBuySellStatus(\r\n        bool _sellWisdom,\r\n        bool _buyLRN\r\n    ) public onlyOwner {\r\n        isSellWisdomEnable = _sellWisdom;\r\n        isBuyLRNEnable = _buyLRN;\r\n    }\r\n\r\n    function getAddressToUserInfo(\r\n        address _user\r\n    ) public view returns (UserInfo memory userInfo, uint256 cAmount) {\r\n        UserInfo memory user = addressToUserInfo[_user];\r\n        if (user.LRNTToken == 0) {\r\n            uint256 bal = LRNTToken.balanceOf(_user);\r\n            user.LRNTToken = bal;\r\n            user.unclaimedLRNTToken = bal;\r\n        }\r\n\r\n        uint256 tAmount;\r\n        uint256 interval;\r\n        uint256 calculatedDays;\r\n        if (isListed[_user]) {\r\n            interval = block.timestamp - user.lastClaimedAt;\r\n            calculatedDays += interval / 1 days;\r\n            tAmount = (user.LRNTToken * calculatedDays * 5) / 1000;\r\n        } else {\r\n            uint256 bal = LRNTToken.balanceOf(_user);\r\n            user.LRNTToken = bal;\r\n            user.unclaimedLRNTToken = bal;\r\n            user.claimedLRNTToken = 0;\r\n            interval = block.timestamp - startTime;\r\n            calculatedDays = interval > 1 days ? interval / 1 days : 1;\r\n            tAmount = (user.LRNTToken * calculatedDays * 5) / 1000;\r\n        }\r\n\r\n        return (user, tAmount);\r\n    }\r\n\r\n    function getAdminDetails()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (address, address, address, uint256)\r\n    {\r\n        return (\r\n            address(LRNTToken),\r\n            address(LRNToken),\r\n            multisigWallet,\r\n            startTime\r\n        );\r\n    }\r\n\r\n    function getNFTDetails()\r\n        public\r\n        view\r\n        returns (address tokenContract, address mContract, uint256 id)\r\n    {\r\n        return (address(nftToken), address(masterContract), tokenId);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wisdom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lrn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lrnt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_masterContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_multiSig\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stlPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyStakeHolder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConversionIsNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LRNT_Transfer_Failed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LRN_Not_Approved_PleaseContactAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LRN_Transfer_Failed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"No_LRNT_Remains\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"No_LRN_BALANCE_PleaseContactAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStakeHolder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Not_LRNT_Holder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentTokenIsNotApproved\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"Please_Wait_Till\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakePeriodNotCompleted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_smReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_smRewardWL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tmReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tmRewardWL\",\"type\":\"uint256\"}],\"name\":\"UpdateRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"addPaymentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"addSellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyLRN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyWisdom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wAmount\",\"type\":\"uint256\"}],\"name\":\"buyWisdomWithLRN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convertion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAddressToUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"LRNTToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedLRNTToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaimedLRNTToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct GMETokenSystem.UserInfo\",\"name\":\"userInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"cAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdminDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApprovedPaymentTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApprovedSellTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getIsApprovedSellToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getIsApprovedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIsNFTRewardEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLRNToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinNFTRewardPark\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNFTDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeWISAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeLRNAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardWISAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWISAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum GMETokenSystem.Stake\",\"name\":\"stake\",\"type\":\"uint8\"},{\"internalType\":\"enum GMETokenSystem.Month\",\"name\":\"month\",\"type\":\"uint8\"}],\"internalType\":\"struct GMETokenSystem.StakeInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWISToLRNPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWisdomToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removePaymentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeSellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellWisdom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_mode\",\"type\":\"bool\"}],\"name\":\"setConversionEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnable\",\"type\":\"bool\"}],\"name\":\"setIsNFTRewardEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setLRNTToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lrn\",\"type\":\"address\"}],\"name\":\"setLRNToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_park\",\"type\":\"uint256\"}],\"name\":\"setMinNFTRewardPark\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setMultiSigWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setStableToLRNPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wisdom\",\"type\":\"address\"}],\"name\":\"setWisdomTokenn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum GMETokenSystem.Stake\",\"name\":\"_stake\",\"type\":\"uint8\"},{\"internalType\":\"enum GMETokenSystem.Month\",\"name\":\"_month\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sellWisdom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_buyLRN\",\"type\":\"bool\"}],\"name\":\"updateBuySellStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"updateMasterContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"updateNFTToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"updateTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GMETokenSystem", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000516fd028824399d69722d8abc5929b5eb1815b89000000000000000000000000f3a672f68a6f750a17a199d32fe22f48088b8408000000000000000000000000621516ff5c687cdede8ff6216d509b94177699a90000000000000000000000002c047eefbebffb9fda3fa1e10d08e7fafaeb42540000000000000000000000003eb8e3fd786f367ad7b3ba2251c5a6d85ca793950000000000000000000000000000000000000000000000000000000000000100000000000000000000000000b815e3dc864e2886b4758b01beb3a3bdf02cf5700000000000000000000000000000000000000000000000015af1d78b58c400000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1117a5782be601c9683a312845c83289421318598622ea9e1066755b84645b07"}