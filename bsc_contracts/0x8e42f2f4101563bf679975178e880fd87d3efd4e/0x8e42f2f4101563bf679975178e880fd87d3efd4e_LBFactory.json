{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n        return map._keys.values();\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {EnumerableSet} from \\\"openzeppelin/utils/structs/EnumerableSet.sol\\\";\\nimport {EnumerableMap} from \\\"openzeppelin/utils/structs/EnumerableMap.sol\\\";\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport {PairParameterHelper} from \\\"./libraries/PairParameterHelper.sol\\\";\\nimport {Encoded} from \\\"./libraries/math/Encoded.sol\\\";\\nimport {ImmutableClone} from \\\"./libraries/ImmutableClone.sol\\\";\\nimport {PendingOwnable} from \\\"./libraries/PendingOwnable.sol\\\";\\nimport {PriceHelper} from \\\"./libraries/PriceHelper.sol\\\";\\nimport {SafeCast} from \\\"./libraries/math/SafeCast.sol\\\";\\n\\nimport {ILBFactory} from \\\"./interfaces/ILBFactory.sol\\\";\\nimport {ILBPair} from \\\"./interfaces/ILBPair.sol\\\";\\n\\n/**\\n * @title Liquidity Book Factory\\n * @author Trader Joe\\n * @notice Contract used to deploy and register new LBPairs.\\n * Enables setting fee parameters, flashloan fees and LBPair implementation.\\n * Unless the `isOpen` is `true`, only the owner of the factory can create pairs.\\n */\\ncontract LBFactory is PendingOwnable, ILBFactory {\\n    using SafeCast for uint256;\\n    using Encoded for bytes32;\\n    using PairParameterHelper for bytes32;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToUintMap;\\n\\n    uint256 private constant _OFFSET_IS_PRESET_OPEN = 255;\\n\\n    uint256 private constant _MIN_BIN_STEP = 1; // 0.001%\\n\\n    uint256 private constant _MAX_FLASHLOAN_FEE = 0.1e18; // 10%\\n\\n    address private _feeRecipient;\\n    uint256 private _flashLoanFee;\\n\\n    address private _lbPairImplementation;\\n\\n    ILBPair[] private _allLBPairs;\\n\\n    /**\\n     * @dev Mapping from a (tokenA, tokenB, binStep) to a LBPair. The tokens are ordered to save gas, but they can be\\n     * in the reverse order in the actual pair.\\n     * Always query one of the 2 tokens of the pair to assert the order of the 2 tokens\\n     */\\n    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => LBPairInformation))) private _lbPairsInfo;\\n\\n    EnumerableMap.UintToUintMap private _presets;\\n    EnumerableSet.AddressSet private _quoteAssetWhitelist;\\n\\n    /**\\n     * @dev Mapping from a (tokenA, tokenB) to a set of available bin steps, this is used to keep track of the\\n     * bin steps that are already used for a pair.\\n     * The tokens are ordered to save gas, but they can be in the reverse order in the actual pair.\\n     * Always query one of the 2 tokens of the pair to assert the order of the 2 tokens\\n     */\\n    mapping(IERC20 => mapping(IERC20 => EnumerableSet.UintSet)) private _availableLBPairBinSteps;\\n\\n    /**\\n     * @notice Constructor\\n     * @param feeRecipient The address of the fee recipient\\n     * @param flashLoanFee The value of the fee for flash loan\\n     */\\n    constructor(address feeRecipient, uint256 flashLoanFee) {\\n        if (flashLoanFee > _MAX_FLASHLOAN_FEE) revert LBFactory__FlashLoanFeeAboveMax(flashLoanFee, _MAX_FLASHLOAN_FEE);\\n\\n        _setFeeRecipient(feeRecipient);\\n\\n        _flashLoanFee = flashLoanFee;\\n        emit FlashLoanFeeSet(0, flashLoanFee);\\n    }\\n\\n    /**\\n     * @notice Get the minimum bin step a pair can have\\n     * @return minBinStep\\n     */\\n    function getMinBinStep() external pure override returns (uint256 minBinStep) {\\n        return _MIN_BIN_STEP;\\n    }\\n\\n    /**\\n     * @notice Get the protocol fee recipient\\n     * @return feeRecipient\\n     */\\n    function getFeeRecipient() external view override returns (address feeRecipient) {\\n        return _feeRecipient;\\n    }\\n\\n    /**\\n     * @notice Get the maximum fee percentage for flashLoans\\n     * @return maxFee\\n     */\\n    function getMaxFlashLoanFee() external pure override returns (uint256 maxFee) {\\n        return _MAX_FLASHLOAN_FEE;\\n    }\\n\\n    /**\\n     * @notice Get the fee for flash loans, in 1e18\\n     * @return flashLoanFee The fee for flash loans, in 1e18\\n     */\\n    function getFlashLoanFee() external view override returns (uint256 flashLoanFee) {\\n        return _flashLoanFee;\\n    }\\n\\n    /**\\n     * @notice Get the address of the LBPair implementation\\n     * @return lbPairImplementation\\n     */\\n    function getLBPairImplementation() external view override returns (address lbPairImplementation) {\\n        return _lbPairImplementation;\\n    }\\n\\n    /**\\n     * @notice View function to return the number of LBPairs created\\n     * @return lbPairNumber\\n     */\\n    function getNumberOfLBPairs() external view override returns (uint256 lbPairNumber) {\\n        return _allLBPairs.length;\\n    }\\n\\n    /**\\n     * @notice View function to return the LBPair created at index `index`\\n     * @param index The index\\n     * @return lbPair The address of the LBPair at index `index`\\n     */\\n    function getLBPairAtIndex(uint256 index) external view override returns (ILBPair lbPair) {\\n        return _allLBPairs[index];\\n    }\\n\\n    /**\\n     * @notice View function to return the number of quote assets whitelisted\\n     * @return numberOfQuoteAssets The number of quote assets\\n     */\\n    function getNumberOfQuoteAssets() external view override returns (uint256 numberOfQuoteAssets) {\\n        return _quoteAssetWhitelist.length();\\n    }\\n\\n    /**\\n     * @notice View function to return the quote asset whitelisted at index `index`\\n     * @param index The index\\n     * @return asset The address of the quoteAsset at index `index`\\n     */\\n    function getQuoteAssetAtIndex(uint256 index) external view override returns (IERC20 asset) {\\n        return IERC20(_quoteAssetWhitelist.at(index));\\n    }\\n\\n    /**\\n     * @notice View function to return whether a token is a quotedAsset (true) or not (false)\\n     * @param token The address of the asset\\n     * @return isQuote Whether the token is a quote asset or not\\n     */\\n    function isQuoteAsset(IERC20 token) external view override returns (bool isQuote) {\\n        return _quoteAssetWhitelist.contains(address(token));\\n    }\\n\\n    /**\\n     * @notice Returns the LBPairInformation if it exists,\\n     * if not, then the address 0 is returned. The order doesn't matter\\n     * @param tokenA The address of the first token of the pair\\n     * @param tokenB The address of the second token of the pair\\n     * @param binStep The bin step of the LBPair\\n     * @return lbPairInformation The LBPairInformation\\n     */\\n    function getLBPairInformation(IERC20 tokenA, IERC20 tokenB, uint256 binStep)\\n        external\\n        view\\n        override\\n        returns (LBPairInformation memory lbPairInformation)\\n    {\\n        return _getLBPairInformation(tokenA, tokenB, binStep);\\n    }\\n\\n    /**\\n     * @notice View function to return the different parameters of the preset\\n     * Will revert if the preset doesn't exist\\n     * @param binStep The bin step of the preset\\n     * @return baseFactor The base factor\\n     * @return filterPeriod The filter period of the preset\\n     * @return decayPeriod The decay period of the preset\\n     * @return reductionFactor The reduction factor of the preset\\n     * @return variableFeeControl The variable fee control of the preset\\n     * @return protocolShare The protocol share of the preset\\n     * @return maxVolatilityAccumulator The max volatility accumulator of the preset\\n     * @return isOpen Whether the preset is open or not\\n     */\\n    function getPreset(uint256 binStep)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 baseFactor,\\n            uint256 filterPeriod,\\n            uint256 decayPeriod,\\n            uint256 reductionFactor,\\n            uint256 variableFeeControl,\\n            uint256 protocolShare,\\n            uint256 maxVolatilityAccumulator,\\n            bool isOpen\\n        )\\n    {\\n        if (!_presets.contains(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\\n\\n        bytes32 preset = bytes32(_presets.get(binStep));\\n\\n        baseFactor = preset.getBaseFactor();\\n        filterPeriod = preset.getFilterPeriod();\\n        decayPeriod = preset.getDecayPeriod();\\n        reductionFactor = preset.getReductionFactor();\\n        variableFeeControl = preset.getVariableFeeControl();\\n        protocolShare = preset.getProtocolShare();\\n        maxVolatilityAccumulator = preset.getMaxVolatilityAccumulator();\\n\\n        isOpen = preset.decodeBool(_OFFSET_IS_PRESET_OPEN);\\n    }\\n\\n    /**\\n     * @notice View function to return the list of available binStep with a preset\\n     * @return binStepWithPreset The list of binStep\\n     */\\n    function getAllBinSteps() external view override returns (uint256[] memory binStepWithPreset) {\\n        return _presets.keys();\\n    }\\n\\n    /**\\n     * @notice View function to return the list of open binSteps\\n     * @return openBinStep The list of open binSteps\\n     */\\n    function getOpenBinSteps() external view override returns (uint256[] memory openBinStep) {\\n        uint256 length = _presets.length();\\n\\n        if (length > 0) {\\n            openBinStep = new uint256[](length);\\n\\n            uint256 index;\\n\\n            for (uint256 i; i < length; ++i) {\\n                (uint256 binStep, uint256 preset) = _presets.at(i);\\n\\n                if (_isPresetOpen(bytes32(preset))) {\\n                    openBinStep[index] = binStep;\\n                    index++;\\n                }\\n            }\\n\\n            if (index < length) {\\n                assembly {\\n                    mstore(openBinStep, index)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice View function to return all the LBPair of a pair of tokens\\n     * @param tokenX The first token of the pair\\n     * @param tokenY The second token of the pair\\n     * @return lbPairsAvailable The list of available LBPairs\\n     */\\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\\n        external\\n        view\\n        override\\n        returns (LBPairInformation[] memory lbPairsAvailable)\\n    {\\n        unchecked {\\n            (IERC20 tokenA, IERC20 tokenB) = _sortTokens(tokenX, tokenY);\\n\\n            EnumerableSet.UintSet storage addressSet = _availableLBPairBinSteps[tokenA][tokenB];\\n\\n            uint256 length = addressSet.length();\\n\\n            if (length > 0) {\\n                lbPairsAvailable = new LBPairInformation[](length);\\n\\n                mapping(uint256 => LBPairInformation) storage lbPairsInfo = _lbPairsInfo[tokenA][tokenB];\\n\\n                for (uint256 i = 0; i < length; ++i) {\\n                    uint16 binStep = addressSet.at(i).safe16();\\n\\n                    lbPairsAvailable[i] = LBPairInformation({\\n                        binStep: binStep,\\n                        LBPair: lbPairsInfo[binStep].LBPair,\\n                        createdByOwner: lbPairsInfo[binStep].createdByOwner,\\n                        ignoredForRouting: lbPairsInfo[binStep].ignoredForRouting\\n                    });\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the LBPair implementation address\\n     * @dev Needs to be called by the owner\\n     * @param newLBPairImplementation The address of the implementation\\n     */\\n    function setLBPairImplementation(address newLBPairImplementation) external override onlyOwner {\\n        if (ILBPair(newLBPairImplementation).getFactory() != this) {\\n            revert LBFactory__LBPairSafetyCheckFailed(newLBPairImplementation);\\n        }\\n\\n        address oldLBPairImplementation = _lbPairImplementation;\\n        if (oldLBPairImplementation == newLBPairImplementation) {\\n            revert LBFactory__SameImplementation(newLBPairImplementation);\\n        }\\n\\n        _lbPairImplementation = newLBPairImplementation;\\n\\n        emit LBPairImplementationSet(oldLBPairImplementation, newLBPairImplementation);\\n    }\\n\\n    /**\\n     * @notice Create a liquidity bin LBPair for tokenX and tokenY\\n     * @param tokenX The address of the first token\\n     * @param tokenY The address of the second token\\n     * @param activeId The active id of the pair\\n     * @param binStep The bin step in basis point, used to calculate log(1 + binStep / 10_000)\\n     * @return pair The address of the newly created LBPair\\n     */\\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\\n        external\\n        override\\n        returns (ILBPair pair)\\n    {\\n        if (!_presets.contains(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\\n\\n        bytes32 preset = bytes32(_presets.get(binStep));\\n        bool isOwner = msg.sender == owner();\\n\\n        if (!_isPresetOpen(preset) && !isOwner) {\\n            revert LBFactory__PresetIsLockedForUsers(msg.sender, binStep);\\n        }\\n\\n        if (!_quoteAssetWhitelist.contains(address(tokenY))) revert LBFactory__QuoteAssetNotWhitelisted(tokenY);\\n\\n        if (tokenX == tokenY) revert LBFactory__IdenticalAddresses(tokenX);\\n\\n        // safety check, making sure that the price can be calculated\\n        PriceHelper.getPriceFromId(activeId, binStep);\\n\\n        // We sort token for storage efficiency, only one input needs to be stored because they are sorted\\n        (IERC20 tokenA, IERC20 tokenB) = _sortTokens(tokenX, tokenY);\\n        // single check is sufficient\\n        if (address(tokenA) == address(0)) revert LBFactory__AddressZero();\\n        if (address(_lbPairsInfo[tokenA][tokenB][binStep].LBPair) != address(0)) {\\n            revert LBFactory__LBPairAlreadyExists(tokenX, tokenY, binStep);\\n        }\\n\\n        {\\n            address implementation = _lbPairImplementation;\\n\\n            if (implementation == address(0)) revert LBFactory__ImplementationNotSet();\\n\\n            pair = ILBPair(\\n                ImmutableClone.cloneDeterministic(\\n                    implementation,\\n                    abi.encodePacked(tokenX, tokenY, binStep),\\n                    keccak256(abi.encode(tokenA, tokenB, binStep))\\n                )\\n            );\\n        }\\n\\n        pair.initialize(\\n            preset.getBaseFactor(),\\n            preset.getFilterPeriod(),\\n            preset.getDecayPeriod(),\\n            preset.getReductionFactor(),\\n            preset.getVariableFeeControl(),\\n            preset.getProtocolShare(),\\n            preset.getMaxVolatilityAccumulator(),\\n            activeId\\n        );\\n\\n        _lbPairsInfo[tokenA][tokenB][binStep] =\\n            LBPairInformation({binStep: binStep, LBPair: pair, createdByOwner: isOwner, ignoredForRouting: false});\\n\\n        _allLBPairs.push(pair);\\n        _availableLBPairBinSteps[tokenA][tokenB].add(binStep);\\n\\n        emit LBPairCreated(tokenX, tokenY, binStep, pair, _allLBPairs.length - 1);\\n    }\\n\\n    /**\\n     * @notice Function to set whether the pair is ignored or not for routing, it will make the pair unusable by the router\\n     * @param tokenX The address of the first token of the pair\\n     * @param tokenY The address of the second token of the pair\\n     * @param binStep The bin step in basis point of the pair\\n     * @param ignored Whether to ignore (true) or not (false) the pair for routing\\n     */\\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external override onlyOwner {\\n        (IERC20 tokenA, IERC20 tokenB) = _sortTokens(tokenX, tokenY);\\n\\n        LBPairInformation memory pairInformation = _lbPairsInfo[tokenA][tokenB][binStep];\\n        if (address(pairInformation.LBPair) == address(0)) {\\n            revert LBFactory__LBPairDoesNotExist(tokenX, tokenY, binStep);\\n        }\\n\\n        if (pairInformation.ignoredForRouting == ignored) revert LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\\n\\n        _lbPairsInfo[tokenA][tokenB][binStep].ignoredForRouting = ignored;\\n\\n        emit LBPairIgnoredStateChanged(pairInformation.LBPair, ignored);\\n    }\\n\\n    /**\\n     * @notice Sets the preset parameters of a bin step\\n     * @param binStep The bin step in basis point, used to calculate the price\\n     * @param baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\\n     * @param filterPeriod The period where the accumulator value is untouched, prevent spam\\n     * @param decayPeriod The period where the accumulator value is decayed, by the reduction factor\\n     * @param reductionFactor The reduction factor, used to calculate the reduction of the accumulator\\n     * @param variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable it\\n     * @param protocolShare The share of the fees received by the protocol\\n     * @param maxVolatilityAccumulator The max value of the volatility accumulator\\n     */\\n    function setPreset(\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator,\\n        bool isOpen\\n    ) external override onlyOwner {\\n        if (binStep < _MIN_BIN_STEP) revert LBFactory__BinStepTooLow(binStep);\\n\\n        bytes32 preset = bytes32(0).setStaticFeeParameters(\\n            baseFactor,\\n            filterPeriod,\\n            decayPeriod,\\n            reductionFactor,\\n            variableFeeControl,\\n            protocolShare,\\n            maxVolatilityAccumulator\\n        );\\n\\n        if (isOpen) {\\n            preset = preset.setBool(true, _OFFSET_IS_PRESET_OPEN);\\n        }\\n\\n        _presets.set(binStep, uint256(preset));\\n\\n        emit PresetSet(\\n            binStep,\\n            baseFactor,\\n            filterPeriod,\\n            decayPeriod,\\n            reductionFactor,\\n            variableFeeControl,\\n            protocolShare,\\n            maxVolatilityAccumulator\\n            );\\n\\n        emit PresetOpenStateChanged(binStep, isOpen);\\n    }\\n\\n    /**\\n     * @notice Sets if the preset is open or not to be used by users\\n     * @param binStep The bin step in basis point, used to calculate the price\\n     * @param isOpen Whether the preset is open or not\\n     */\\n    function setPresetOpenState(uint16 binStep, bool isOpen) external override onlyOwner {\\n        if (!_presets.contains(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\\n\\n        bytes32 preset = bytes32(_presets.get(binStep));\\n\\n        if (preset.decodeBool(_OFFSET_IS_PRESET_OPEN) == isOpen) {\\n            revert LBFactory__PresetOpenStateIsAlreadyInTheSameState();\\n        }\\n\\n        _presets.set(binStep, uint256(preset.setBool(isOpen, _OFFSET_IS_PRESET_OPEN)));\\n\\n        emit PresetOpenStateChanged(binStep, isOpen);\\n    }\\n\\n    /**\\n     * @notice Remove the preset linked to a binStep\\n     * @param binStep The bin step to remove\\n     */\\n    function removePreset(uint16 binStep) external override onlyOwner {\\n        if (!_presets.remove(binStep)) revert LBFactory__BinStepHasNoPreset(binStep);\\n\\n        emit PresetRemoved(binStep);\\n    }\\n\\n    /**\\n     * @notice Function to set the fee parameter of a LBPair\\n     * @param tokenX The address of the first token\\n     * @param tokenY The address of the second token\\n     * @param binStep The bin step in basis point, used to calculate the price\\n     * @param baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\\n     * @param filterPeriod The period where the accumulator value is untouched, prevent spam\\n     * @param decayPeriod The period where the accumulator value is decayed, by the reduction factor\\n     * @param reductionFactor The reduction factor, used to calculate the reduction of the accumulator\\n     * @param variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable it\\n     * @param protocolShare The share of the fees received by the protocol\\n     * @param maxVolatilityAccumulator The max value of volatility accumulator\\n     */\\n    function setFeesParametersOnPair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    ) external override onlyOwner {\\n        ILBPair lbPair = _getLBPairInformation(tokenX, tokenY, binStep).LBPair;\\n\\n        if (address(lbPair) == address(0)) revert LBFactory__LBPairNotCreated(tokenX, tokenY, binStep);\\n\\n        lbPair.setStaticFeeParameters(\\n            baseFactor,\\n            filterPeriod,\\n            decayPeriod,\\n            reductionFactor,\\n            variableFeeControl,\\n            protocolShare,\\n            maxVolatilityAccumulator\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to set the recipient of the fees. This address needs to be able to receive ERC20s\\n     * @param feeRecipient The address of the recipient\\n     */\\n    function setFeeRecipient(address feeRecipient) external override onlyOwner {\\n        _setFeeRecipient(feeRecipient);\\n    }\\n\\n    /**\\n     * @notice Function to set the flash loan fee\\n     * @param flashLoanFee The value of the fee for flash loan\\n     */\\n    function setFlashLoanFee(uint256 flashLoanFee) external override onlyOwner {\\n        uint256 oldFlashLoanFee = _flashLoanFee;\\n\\n        if (oldFlashLoanFee == flashLoanFee) revert LBFactory__SameFlashLoanFee(flashLoanFee);\\n        if (flashLoanFee > _MAX_FLASHLOAN_FEE) revert LBFactory__FlashLoanFeeAboveMax(flashLoanFee, _MAX_FLASHLOAN_FEE);\\n\\n        _flashLoanFee = flashLoanFee;\\n        emit FlashLoanFeeSet(oldFlashLoanFee, flashLoanFee);\\n    }\\n\\n    /**\\n     * @notice Function to add an asset to the whitelist of quote assets\\n     * @param quoteAsset The quote asset (e.g: NATIVE, USDC...)\\n     */\\n    function addQuoteAsset(IERC20 quoteAsset) external override onlyOwner {\\n        if (!_quoteAssetWhitelist.add(address(quoteAsset))) {\\n            revert LBFactory__QuoteAssetAlreadyWhitelisted(quoteAsset);\\n        }\\n\\n        emit QuoteAssetAdded(quoteAsset);\\n    }\\n\\n    /**\\n     * @notice Function to remove an asset from the whitelist of quote assets\\n     * @param quoteAsset The quote asset (e.g: NATIVE, USDC...)\\n     */\\n    function removeQuoteAsset(IERC20 quoteAsset) external override onlyOwner {\\n        if (!_quoteAssetWhitelist.remove(address(quoteAsset))) revert LBFactory__QuoteAssetNotWhitelisted(quoteAsset);\\n\\n        emit QuoteAssetRemoved(quoteAsset);\\n    }\\n\\n    function _isPresetOpen(bytes32 preset) internal pure returns (bool) {\\n        return preset.decodeBool(_OFFSET_IS_PRESET_OPEN);\\n    }\\n\\n    /**\\n     * @notice Internal function to set the recipient of the fee\\n     * @param feeRecipient The address of the recipient\\n     */\\n    function _setFeeRecipient(address feeRecipient) internal {\\n        if (feeRecipient == address(0)) revert LBFactory__AddressZero();\\n\\n        address oldFeeRecipient = _feeRecipient;\\n        if (oldFeeRecipient == feeRecipient) revert LBFactory__SameFeeRecipient(_feeRecipient);\\n\\n        _feeRecipient = feeRecipient;\\n        emit FeeRecipientSet(oldFeeRecipient, feeRecipient);\\n    }\\n\\n    function forceDecay(ILBPair pair) external override onlyOwner {\\n        pair.forceDecay();\\n    }\\n\\n    /**\\n     * @notice Returns the LBPairInformation if it exists,\\n     * if not, then the address 0 is returned. The order doesn't matter\\n     * @param tokenA The address of the first token of the pair\\n     * @param tokenB The address of the second token of the pair\\n     * @param binStep The bin step of the LBPair\\n     * @return The LBPairInformation\\n     */\\n    function _getLBPairInformation(IERC20 tokenA, IERC20 tokenB, uint256 binStep)\\n        private\\n        view\\n        returns (LBPairInformation memory)\\n    {\\n        (tokenA, tokenB) = _sortTokens(tokenA, tokenB);\\n        return _lbPairsInfo[tokenA][tokenB][binStep];\\n    }\\n\\n    /**\\n     * @notice Private view function to sort 2 tokens in ascending order\\n     * @param tokenA The first token\\n     * @param tokenB The second token\\n     * @return The sorted first token\\n     * @return The sorted second token\\n     */\\n    function _sortTokens(IERC20 tokenA, IERC20 tokenB) private pure returns (IERC20, IERC20) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n        return (tokenA, tokenB);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport {ILBPair} from \\\"./ILBPair.sol\\\";\\nimport {IPendingOwnable} from \\\"./IPendingOwnable.sol\\\";\\n\\n/**\\n * @title Liquidity Book Factory Interface\\n * @author Trader Joe\\n * @notice Required interface of LBFactory contract\\n */\\ninterface ILBFactory is IPendingOwnable {\\n    error LBFactory__IdenticalAddresses(IERC20 token);\\n    error LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\\n    error LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\\n    error LBFactory__AddressZero();\\n    error LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\\n    error LBFactory__LBPairDoesNotExist(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\\n    error LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\\n    error LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\\n    error LBFactory__BinStepTooLow(uint256 binStep);\\n    error LBFactory__PresetIsLockedForUsers(address user, uint256 binStep);\\n    error LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\\n    error LBFactory__BinStepHasNoPreset(uint256 binStep);\\n    error LBFactory__PresetOpenStateIsAlreadyInTheSameState();\\n    error LBFactory__SameFeeRecipient(address feeRecipient);\\n    error LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\\n    error LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\\n    error LBFactory__SameImplementation(address LBPairImplementation);\\n    error LBFactory__ImplementationNotSet();\\n\\n    /**\\n     * @dev Structure to store the LBPair information, such as:\\n     * binStep: The bin step of the LBPair\\n     * LBPair: The address of the LBPair\\n     * createdByOwner: Whether the pair was created by the owner of the factory\\n     * ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\\n     */\\n    struct LBPairInformation {\\n        uint16 binStep;\\n        ILBPair LBPair;\\n        bool createdByOwner;\\n        bool ignoredForRouting;\\n    }\\n\\n    event LBPairCreated(\\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBPair LBPair, uint256 pid\\n    );\\n\\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\\n\\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\\n\\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\\n\\n    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\\n\\n    event PresetSet(\\n        uint256 indexed binStep,\\n        uint256 baseFactor,\\n        uint256 filterPeriod,\\n        uint256 decayPeriod,\\n        uint256 reductionFactor,\\n        uint256 variableFeeControl,\\n        uint256 protocolShare,\\n        uint256 maxVolatilityAccumulator\\n    );\\n\\n    event PresetOpenStateChanged(uint256 indexed binStep, bool indexed isOpen);\\n\\n    event PresetRemoved(uint256 indexed binStep);\\n\\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\\n\\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\\n\\n    function getMinBinStep() external pure returns (uint256);\\n\\n    function getFeeRecipient() external view returns (address);\\n\\n    function getMaxFlashLoanFee() external pure returns (uint256);\\n\\n    function getFlashLoanFee() external view returns (uint256);\\n\\n    function getLBPairImplementation() external view returns (address);\\n\\n    function getNumberOfLBPairs() external view returns (uint256);\\n\\n    function getLBPairAtIndex(uint256 id) external returns (ILBPair);\\n\\n    function getNumberOfQuoteAssets() external view returns (uint256);\\n\\n    function getQuoteAssetAtIndex(uint256 index) external view returns (IERC20);\\n\\n    function isQuoteAsset(IERC20 token) external view returns (bool);\\n\\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\\n        external\\n        view\\n        returns (LBPairInformation memory);\\n\\n    function getPreset(uint256 binStep)\\n        external\\n        view\\n        returns (\\n            uint256 baseFactor,\\n            uint256 filterPeriod,\\n            uint256 decayPeriod,\\n            uint256 reductionFactor,\\n            uint256 variableFeeControl,\\n            uint256 protocolShare,\\n            uint256 maxAccumulator,\\n            bool isOpen\\n        );\\n\\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\\n\\n    function getOpenBinSteps() external view returns (uint256[] memory openBinStep);\\n\\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\\n        external\\n        view\\n        returns (LBPairInformation[] memory LBPairsBinStep);\\n\\n    function setLBPairImplementation(address lbPairImplementation) external;\\n\\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\\n        external\\n        returns (ILBPair pair);\\n\\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external;\\n\\n    function setPreset(\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator,\\n        bool isOpen\\n    ) external;\\n\\n    function setPresetOpenState(uint16 binStep, bool isOpen) external;\\n\\n    function removePreset(uint16 binStep) external;\\n\\n    function setFeesParametersOnPair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    ) external;\\n\\n    function setFeeRecipient(address feeRecipient) external;\\n\\n    function setFlashLoanFee(uint256 flashLoanFee) external;\\n\\n    function addQuoteAsset(IERC20 quoteAsset) external;\\n\\n    function removeQuoteAsset(IERC20 quoteAsset) external;\\n\\n    function forceDecay(ILBPair lbPair) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBFlashLoanCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Liquidity Book Flashloan Callback Interface\\n/// @author Trader Joe\\n/// @notice Required interface to interact with LB flash loans\\ninterface ILBFlashLoanCallback {\\n    function LBFlashLoanCallback(\\n        address sender,\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        bytes32 amounts,\\n        bytes32 totalFees,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport {ILBFactory} from \\\"./ILBFactory.sol\\\";\\nimport {ILBFlashLoanCallback} from \\\"./ILBFlashLoanCallback.sol\\\";\\nimport {ILBToken} from \\\"./ILBToken.sol\\\";\\n\\ninterface ILBPair is ILBToken {\\n    error LBPair__ZeroBorrowAmount();\\n    error LBPair__AddressZero();\\n    error LBPair__AlreadyInitialized();\\n    error LBPair__EmptyMarketConfigs();\\n    error LBPair__FlashLoanCallbackFailed();\\n    error LBPair__FlashLoanInsufficientAmount();\\n    error LBPair__InsufficientAmountIn();\\n    error LBPair__InsufficientAmountOut();\\n    error LBPair__InvalidInput();\\n    error LBPair__InvalidStaticFeeParameters();\\n    error LBPair__OnlyFactory();\\n    error LBPair__OnlyProtocolFeeRecipient();\\n    error LBPair__OutOfLiquidity();\\n    error LBPair__TokenNotSupported();\\n    error LBPair__ZeroAmount(uint24 id);\\n    error LBPair__ZeroAmountsOut(uint24 id);\\n    error LBPair__ZeroShares(uint24 id);\\n    error LBPair__MaxTotalFeeExceeded();\\n\\n    struct MintArrays {\\n        uint256[] ids;\\n        bytes32[] amounts;\\n        uint256[] liquidityMinted;\\n    }\\n\\n    event DepositedToBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\\n\\n    event WithdrawnFromBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\\n\\n    event CompositionFees(address indexed sender, uint24 id, bytes32 totalFees, bytes32 protocolFees);\\n\\n    event CollectedProtocolFees(address indexed feeRecipient, bytes32 protocolFees);\\n\\n    event Swap(\\n        address indexed sender,\\n        address indexed to,\\n        uint24 id,\\n        bytes32 amountsIn,\\n        bytes32 amountsOut,\\n        uint24 volatilityAccumulator,\\n        bytes32 totalFees,\\n        bytes32 protocolFees\\n    );\\n\\n    event StaticFeeParametersSet(\\n        address indexed sender,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    );\\n\\n    event FlashLoan(\\n        address indexed sender,\\n        ILBFlashLoanCallback indexed receiver,\\n        uint24 activeId,\\n        bytes32 amounts,\\n        bytes32 totalFees,\\n        bytes32 protocolFees\\n    );\\n\\n    event OracleLengthIncreased(address indexed sender, uint16 oracleLength);\\n\\n    event ForcedDecay(address indexed sender, uint24 idReference, uint24 volatilityReference);\\n\\n    function initialize(\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator,\\n        uint24 activeId\\n    ) external;\\n\\n    function getFactory() external view returns (ILBFactory factory);\\n\\n    function getTokenX() external view returns (IERC20 tokenX);\\n\\n    function getTokenY() external view returns (IERC20 tokenY);\\n\\n    function getBinStep() external view returns (uint16 binStep);\\n\\n    function getReserves() external view returns (uint128 reserveX, uint128 reserveY);\\n\\n    function getActiveId() external view returns (uint24 activeId);\\n\\n    function getBin(uint24 id) external view returns (uint128 binReserveX, uint128 binReserveY);\\n\\n    function getNextNonEmptyBin(bool swapForY, uint24 id) external view returns (uint24 nextId);\\n\\n    function getProtocolFees() external view returns (uint128 protocolFeeX, uint128 protocolFeeY);\\n\\n    function getStaticFeeParameters()\\n        external\\n        view\\n        returns (\\n            uint16 baseFactor,\\n            uint16 filterPeriod,\\n            uint16 decayPeriod,\\n            uint16 reductionFactor,\\n            uint24 variableFeeControl,\\n            uint16 protocolShare,\\n            uint24 maxVolatilityAccumulator\\n        );\\n\\n    function getVariableFeeParameters()\\n        external\\n        view\\n        returns (uint24 volatilityAccumulator, uint24 volatilityReference, uint24 idReference, uint40 timeOfLastUpdate);\\n\\n    function getOracleParameters()\\n        external\\n        view\\n        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp);\\n\\n    function getOracleSampleAt(uint40 lookupTimestamp)\\n        external\\n        view\\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed);\\n\\n    function getPriceFromId(uint24 id) external view returns (uint256 price);\\n\\n    function getIdFromPrice(uint256 price) external view returns (uint24 id);\\n\\n    function getSwapIn(uint128 amountOut, bool swapForY)\\n        external\\n        view\\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\\n\\n    function getSwapOut(uint128 amountIn, bool swapForY)\\n        external\\n        view\\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\\n\\n    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\\n\\n    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\\n\\n    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\\n        external\\n        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted);\\n\\n    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\\n        external\\n        returns (bytes32[] memory amounts);\\n\\n    function collectProtocolFees() external returns (bytes32 collectedProtocolFees);\\n\\n    function increaseOracleLength(uint16 newLength) external;\\n\\n    function setStaticFeeParameters(\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    ) external;\\n\\n    function forceDecay() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Token Interface\\n * @author Trader Joe\\n * @notice Interface to interact with the LBToken.\\n */\\ninterface ILBToken {\\n    error LBToken__AddressThisOrZero();\\n    error LBToken__InvalidLength();\\n    error LBToken__SelfApproval(address owner);\\n    error LBToken__SpenderNotApproved(address from, address spender);\\n    error LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\\n    error LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\\n\\n    event TransferBatch(\\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\\n\\n    function approveForAll(address spender, bool approved) external;\\n\\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPendingOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Pending Ownable Interface\\n * @author Trader Joe\\n * @notice Required interface of Pending Ownable contract used for LBFactory\\n */\\ninterface IPendingOwnable {\\n    error PendingOwnable__AddressZero();\\n    error PendingOwnable__NoPendingOwner();\\n    error PendingOwnable__NotOwner();\\n    error PendingOwnable__NotPendingOwner();\\n    error PendingOwnable__PendingOwnerAlreadySet();\\n\\n    event PendingOwnerSet(address indexed pendingOwner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function setPendingOwner(address pendingOwner) external;\\n\\n    function revokePendingOwner() external;\\n\\n    function becomeOwner() external;\\n\\n    function renounceOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Constants Library\\n * @author Trader Joe\\n * @notice Set of constants for Liquidity Book contracts\\n */\\nlibrary Constants {\\n    uint8 internal constant SCALE_OFFSET = 128;\\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\\n\\n    uint256 internal constant PRECISION = 1e18;\\n    uint256 internal constant SQUARED_PRECISION = PRECISION * PRECISION;\\n\\n    uint256 internal constant MAX_FEE = 0.1e18; // 10%\\n    uint256 internal constant MAX_PROTOCOL_SHARE = 2_500; // 25% of the fee\\n\\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\\n\\n    /// @dev The expected return after a successful flash loan\\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\\\"LBPair.onFlashLoan\\\");\\n}\\n\"\r\n    },\r\n    \"src/libraries/ImmutableClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Immutable Clone Library\\n * @notice Minimal immutable proxy library.\\n * @author Trader Joe\\n * @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n * @author Minimal proxy by 0age (https://github.com/0age)\\n * @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n * (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n * @dev Minimal proxy:\\n * Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n * it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n * which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n * @dev Clones with immutable args (CWIA):\\n * The implementation of CWIA here doesn't implements a `receive()` as it is not needed for LB.\\n */\\nlibrary ImmutableClone {\\n    error DeploymentFailed();\\n    error PackedDataTooBig();\\n\\n    /**\\n     * @dev Deploys a deterministic clone of `implementation` using immutable arguments encoded in `data`, with `salt`\\n     * @param implementation The address of the implementation\\n     * @param data The encoded immutable arguments\\n     * @param salt The salt\\n     */\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 63`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            // if `extraLength` is greater than `0xffca` revert as the `creationSize` would be greater than `0xffff`.\\n            if gt(extraLength, 0xffca) {\\n                // Store the function selector of `PackedDataTooBig()`.\\n                mstore(0x00, 0xc8c78139)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x35  | PUSH1 0x35     | 0x35 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x35 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x33  | PUSH1 0x33     | 0x33 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e603357fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            mstore(\\n                sub(data, 0x21),\\n                or(\\n                    shl(0xd8, add(extraLength, 0x35)),\\n                    or(shl(0x48, extraLength), 0x6100003d81600a3d39f3363d3d373d3d3d3d610000806035363936013d73)\\n                )\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create2(0, sub(data, 0x1f), add(extraLength, 0x3f), salt)\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the initialization code hash of the clone of `implementation`\\n     * using immutable arguments encoded in `data`.\\n     * Used for mining vanity addresses with create2crunch.\\n     * @param implementation The address of the implementation contract.\\n     * @param data The encoded immutable arguments.\\n     * @return hash The initialization code hash.\\n     */\\n    function initCodeHash(address implementation, bytes memory data) internal pure returns (bytes32 hash) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 63`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            // if `extraLength` is greater than `0xffca` revert as the `creationSize` would be greater than `0xffff`.\\n            if gt(extraLength, 0xffca) {\\n                // Store the function selector of `PackedDataTooBig()`.\\n                mstore(0x00, 0xc8c78139)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e603357fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            mstore(\\n                sub(data, 0x21),\\n                or(\\n                    shl(0xd8, add(extraLength, 0x35)),\\n                    or(shl(0x48, extraLength), 0x6100003d81600a3d39f3363d3d373d3d3d3d610000806035363936013d73)\\n                )\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            hash := keccak256(sub(data, 0x1f), add(extraLength, 0x3f))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address of the deterministic clone of\\n     * `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n     * @param implementation The address of the implementation.\\n     * @param data The immutable arguments of the implementation.\\n     * @param salt The salt used to compute the address.\\n     * @param deployer The address of the deployer.\\n     * @return predicted The predicted address.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes memory data, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /**\\n     * @dev Returns the address when a contract with initialization code hash,\\n     * `hash`, is deployed with `salt`, by `deployer`.\\n     * @param hash The initialization code hash.\\n     * @param salt The salt used to compute the address.\\n     * @param deployer The address of the deployer.\\n     * @return predicted The predicted address.\\n     */\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore := mload(0x35)\\n\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, mBefore)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/PairParameterHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {Constants} from \\\"./Constants.sol\\\";\\nimport {SafeCast} from \\\"./math/SafeCast.sol\\\";\\nimport {Encoded} from \\\"./math/Encoded.sol\\\";\\n\\n/**\\n * @title Liquidity Book Pair Parameter Helper Library\\n * @author Trader Joe\\n * @dev This library contains functions to get and set parameters of a pair\\n * The parameters are stored in a single bytes32 variable in the following format:\\n * [0 - 16[: base factor (16 bits)\\n * [16 - 28[: filter period (12 bits)\\n * [28 - 40[: decay period (12 bits)\\n * [40 - 54[: reduction factor (14 bits)\\n * [54 - 78[: variable fee control (24 bits)\\n * [78 - 92[: protocol share (14 bits)\\n * [92 - 112[: max volatility accumulator (20 bits)\\n * [112 - 132[: volatility accumulator (20 bits)\\n * [132 - 152[: volatility reference (20 bits)\\n * [152 - 176[: index reference (24 bits)\\n * [176 - 216[: time of last update (40 bits)\\n * [216 - 232[: oracle index (16 bits)\\n * [232 - 256[: active index (24 bits)\\n */\\nlibrary PairParameterHelper {\\n    using SafeCast for uint256;\\n    using Encoded for bytes32;\\n\\n    error PairParametersHelper__InvalidParameter();\\n\\n    uint256 internal constant OFFSET_BASE_FACTOR = 0;\\n    uint256 internal constant OFFSET_FILTER_PERIOD = 16;\\n    uint256 internal constant OFFSET_DECAY_PERIOD = 28;\\n    uint256 internal constant OFFSET_REDUCTION_FACTOR = 40;\\n    uint256 internal constant OFFSET_VAR_FEE_CONTROL = 54;\\n    uint256 internal constant OFFSET_PROTOCOL_SHARE = 78;\\n    uint256 internal constant OFFSET_MAX_VOL_ACC = 92;\\n    uint256 internal constant OFFSET_VOL_ACC = 112;\\n    uint256 internal constant OFFSET_VOL_REF = 132;\\n    uint256 internal constant OFFSET_ID_REF = 152;\\n    uint256 internal constant OFFSET_TIME_LAST_UPDATE = 176;\\n    uint256 internal constant OFFSET_ORACLE_ID = 216;\\n    uint256 internal constant OFFSET_ACTIVE_ID = 232;\\n\\n    uint256 internal constant MASK_STATIC_PARAMETER = 0xffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @dev Get the base factor from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 16[: base factor (16 bits)\\n     * [16 - 256[: other parameters\\n     * @return baseFactor The base factor\\n     */\\n    function getBaseFactor(bytes32 params) internal pure returns (uint16 baseFactor) {\\n        baseFactor = params.decodeUint16(OFFSET_BASE_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Get the filter period from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 16[: other parameters\\n     * [16 - 28[: filter period (12 bits)\\n     * [28 - 256[: other parameters\\n     * @return filterPeriod The filter period\\n     */\\n    function getFilterPeriod(bytes32 params) internal pure returns (uint16 filterPeriod) {\\n        filterPeriod = params.decodeUint12(OFFSET_FILTER_PERIOD);\\n    }\\n\\n    /**\\n     * @dev Get the decay period from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 28[: other parameters\\n     * [28 - 40[: decay period (12 bits)\\n     * [40 - 256[: other parameters\\n     * @return decayPeriod The decay period\\n     */\\n    function getDecayPeriod(bytes32 params) internal pure returns (uint16 decayPeriod) {\\n        decayPeriod = params.decodeUint12(OFFSET_DECAY_PERIOD);\\n    }\\n\\n    /**\\n     * @dev Get the reduction factor from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 40[: other parameters\\n     * [40 - 54[: reduction factor (14 bits)\\n     * [54 - 256[: other parameters\\n     * @return reductionFactor The reduction factor\\n     */\\n    function getReductionFactor(bytes32 params) internal pure returns (uint16 reductionFactor) {\\n        reductionFactor = params.decodeUint14(OFFSET_REDUCTION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Get the variable fee control from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 54[: other parameters\\n     * [54 - 78[: variable fee control (24 bits)\\n     * [78 - 256[: other parameters\\n     * @return variableFeeControl The variable fee control\\n     */\\n    function getVariableFeeControl(bytes32 params) internal pure returns (uint24 variableFeeControl) {\\n        variableFeeControl = params.decodeUint24(OFFSET_VAR_FEE_CONTROL);\\n    }\\n\\n    /**\\n     * @dev Get the protocol share from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 78[: other parameters\\n     * [78 - 92[: protocol share (14 bits)\\n     * [92 - 256[: other parameters\\n     * @return protocolShare The protocol share\\n     */\\n    function getProtocolShare(bytes32 params) internal pure returns (uint16 protocolShare) {\\n        protocolShare = params.decodeUint14(OFFSET_PROTOCOL_SHARE);\\n    }\\n\\n    /**\\n     * @dev Get the max volatility accumulator from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 92[: other parameters\\n     * [92 - 112[: max volatility accumulator (20 bits)\\n     * [112 - 256[: other parameters\\n     * @return maxVolatilityAccumulator The max volatility accumulator\\n     */\\n    function getMaxVolatilityAccumulator(bytes32 params) internal pure returns (uint24 maxVolatilityAccumulator) {\\n        maxVolatilityAccumulator = params.decodeUint20(OFFSET_MAX_VOL_ACC);\\n    }\\n\\n    /**\\n     * @dev Get the volatility accumulator from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 112[: other parameters\\n     * [112 - 132[: volatility accumulator (20 bits)\\n     * [132 - 256[: other parameters\\n     * @return volatilityAccumulator The volatility accumulator\\n     */\\n    function getVolatilityAccumulator(bytes32 params) internal pure returns (uint24 volatilityAccumulator) {\\n        volatilityAccumulator = params.decodeUint20(OFFSET_VOL_ACC);\\n    }\\n\\n    /**\\n     * @dev Get the volatility reference from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 132[: other parameters\\n     * [132 - 152[: volatility reference (20 bits)\\n     * [152 - 256[: other parameters\\n     * @return volatilityReference The volatility reference\\n     */\\n    function getVolatilityReference(bytes32 params) internal pure returns (uint24 volatilityReference) {\\n        volatilityReference = params.decodeUint20(OFFSET_VOL_REF);\\n    }\\n\\n    /**\\n     * @dev Get the index reference from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 152[: other parameters\\n     * [152 - 176[: index reference (24 bits)\\n     * [176 - 256[: other parameters\\n     * @return idReference The index reference\\n     */\\n    function getIdReference(bytes32 params) internal pure returns (uint24 idReference) {\\n        idReference = params.decodeUint24(OFFSET_ID_REF);\\n    }\\n\\n    /**\\n     * @dev Get the time of last update from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 176[: other parameters\\n     * [176 - 216[: time of last update (40 bits)\\n     * [216 - 256[: other parameters\\n     * @return timeOflastUpdate The time of last update\\n     */\\n    function getTimeOfLastUpdate(bytes32 params) internal pure returns (uint40 timeOflastUpdate) {\\n        timeOflastUpdate = params.decodeUint40(OFFSET_TIME_LAST_UPDATE);\\n    }\\n\\n    /**\\n     * @dev Get the oracle id from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 216[: other parameters\\n     * [216 - 232[: oracle id (16 bits)\\n     * [232 - 256[: other parameters\\n     * @return oracleId The oracle id\\n     */\\n    function getOracleId(bytes32 params) internal pure returns (uint16 oracleId) {\\n        oracleId = params.decodeUint16(OFFSET_ORACLE_ID);\\n    }\\n\\n    /**\\n     * @dev Get the active index from the encoded pair parameters\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 232[: other parameters\\n     * [232 - 256[: active index (24 bits)\\n     * @return activeId The active index\\n     */\\n    function getActiveId(bytes32 params) internal pure returns (uint24 activeId) {\\n        activeId = params.decodeUint24(OFFSET_ACTIVE_ID);\\n    }\\n\\n    /**\\n     * @dev Get the delta between the current active index and the cached active index\\n     * @param params The encoded pair parameters, as follows:\\n     * [0 - 232[: other parameters\\n     * [232 - 256[: active index (24 bits)\\n     * @param activeId The current active index\\n     * @return The delta\\n     */\\n    function getDeltaId(bytes32 params, uint24 activeId) internal pure returns (uint24) {\\n        uint24 id = getActiveId(params);\\n        unchecked {\\n            return activeId > id ? activeId - id : id - activeId;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the base fee, with 18 decimals\\n     * @param params The encoded pair parameters\\n     * @param binStep The bin step (in basis points)\\n     * @return baseFee The base fee\\n     */\\n    function getBaseFee(bytes32 params, uint16 binStep) internal pure returns (uint256) {\\n        unchecked {\\n            // Base factor is in basis points, binStep is in basis points, so we multiply by 1e10\\n            return uint256(getBaseFactor(params)) * binStep * 1e10;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the variable fee\\n     * @param params The encoded pair parameters\\n     * @param binStep The bin step (in basis points)\\n     * @return variableFee The variable fee\\n     */\\n    function getVariableFee(bytes32 params, uint16 binStep) internal pure returns (uint256 variableFee) {\\n        uint256 variableFeeControl = getVariableFeeControl(params);\\n\\n        if (variableFeeControl != 0) {\\n            unchecked {\\n                // The volatility accumulator is in basis points, binStep is in basis points,\\n                // and the variable fee control is in basis points, so the result is in 100e18th\\n                uint256 prod = uint256(getVolatilityAccumulator(params)) * binStep;\\n                variableFee = (prod * prod * variableFeeControl + 99) / 100;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the total fee, which is the sum of the base fee and the variable fee\\n     * @param params The encoded pair parameters\\n     * @param binStep The bin step (in basis points)\\n     * @return totalFee The total fee\\n     */\\n    function getTotalFee(bytes32 params, uint16 binStep) internal pure returns (uint128) {\\n        unchecked {\\n            return (getBaseFee(params, binStep) + getVariableFee(params, binStep)).safe128();\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the oracle id in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param oracleId The oracle id\\n     * @return The updated encoded pair parameters\\n     */\\n    function setOracleId(bytes32 params, uint16 oracleId) internal pure returns (bytes32) {\\n        return params.set(oracleId, Encoded.MASK_UINT16, OFFSET_ORACLE_ID);\\n    }\\n\\n    /**\\n     * @dev Set the volatility reference in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param volRef The volatility reference\\n     * @return The updated encoded pair parameters\\n     */\\n    function setVolatilityReference(bytes32 params, uint24 volRef) internal pure returns (bytes32) {\\n        if (volRef > Encoded.MASK_UINT20) revert PairParametersHelper__InvalidParameter();\\n\\n        return params.set(volRef, Encoded.MASK_UINT20, OFFSET_VOL_REF);\\n    }\\n\\n    /**\\n     * @dev Set the volatility accumulator in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param volAcc The volatility accumulator\\n     * @return The updated encoded pair parameters\\n     */\\n    function setVolatilityAccumulator(bytes32 params, uint24 volAcc) internal pure returns (bytes32) {\\n        if (volAcc > Encoded.MASK_UINT20) revert PairParametersHelper__InvalidParameter();\\n\\n        return params.set(volAcc, Encoded.MASK_UINT20, OFFSET_VOL_ACC);\\n    }\\n\\n    /**\\n     * @dev Set the active id in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param activeId The active id\\n     * @return newParams The updated encoded pair parameters\\n     */\\n    function setActiveId(bytes32 params, uint24 activeId) internal pure returns (bytes32 newParams) {\\n        return params.set(activeId, Encoded.MASK_UINT24, OFFSET_ACTIVE_ID);\\n    }\\n\\n    /**\\n     * @dev Sets the static fee parameters in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param baseFactor The base factor\\n     * @param filterPeriod The filter period\\n     * @param decayPeriod The decay period\\n     * @param reductionFactor The reduction factor\\n     * @param variableFeeControl The variable fee control\\n     * @param protocolShare The protocol share\\n     * @param maxVolatilityAccumulator The max volatility accumulator\\n     * @return newParams The updated encoded pair parameters\\n     */\\n    function setStaticFeeParameters(\\n        bytes32 params,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    ) internal pure returns (bytes32 newParams) {\\n        if (\\n            filterPeriod > decayPeriod || decayPeriod > Encoded.MASK_UINT12\\n                || reductionFactor > Constants.BASIS_POINT_MAX || protocolShare > Constants.MAX_PROTOCOL_SHARE\\n                || maxVolatilityAccumulator > Encoded.MASK_UINT20\\n        ) revert PairParametersHelper__InvalidParameter();\\n\\n        newParams = newParams.set(baseFactor, Encoded.MASK_UINT16, OFFSET_BASE_FACTOR);\\n        newParams = newParams.set(filterPeriod, Encoded.MASK_UINT12, OFFSET_FILTER_PERIOD);\\n        newParams = newParams.set(decayPeriod, Encoded.MASK_UINT12, OFFSET_DECAY_PERIOD);\\n        newParams = newParams.set(reductionFactor, Encoded.MASK_UINT14, OFFSET_REDUCTION_FACTOR);\\n        newParams = newParams.set(variableFeeControl, Encoded.MASK_UINT24, OFFSET_VAR_FEE_CONTROL);\\n        newParams = newParams.set(protocolShare, Encoded.MASK_UINT14, OFFSET_PROTOCOL_SHARE);\\n        newParams = newParams.set(maxVolatilityAccumulator, Encoded.MASK_UINT20, OFFSET_MAX_VOL_ACC);\\n\\n        return params.set(uint256(newParams), MASK_STATIC_PARAMETER, 0);\\n    }\\n\\n    /**\\n     * @dev Updates the index reference in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @return newParams The updated encoded pair parameters\\n     */\\n    function updateIdReference(bytes32 params) internal pure returns (bytes32 newParams) {\\n        uint24 activeId = getActiveId(params);\\n        return params.set(activeId, Encoded.MASK_UINT24, OFFSET_ID_REF);\\n    }\\n\\n    /**\\n     * @dev Updates the time of last update in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @return newParams The updated encoded pair parameters\\n     */\\n    function updateTimeOfLastUpdate(bytes32 params) internal view returns (bytes32 newParams) {\\n        uint40 currentTime = block.timestamp.safe40();\\n        return params.set(currentTime, Encoded.MASK_UINT40, OFFSET_TIME_LAST_UPDATE);\\n    }\\n\\n    /**\\n     * @dev Updates the volatility reference in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @return The updated encoded pair parameters\\n     */\\n    function updateVolatilityReference(bytes32 params) internal pure returns (bytes32) {\\n        uint256 volAcc = getVolatilityAccumulator(params);\\n        uint256 reductionFactor = getReductionFactor(params);\\n\\n        uint24 volRef;\\n        unchecked {\\n            volRef = uint24(volAcc * reductionFactor / Constants.BASIS_POINT_MAX);\\n        }\\n\\n        return setVolatilityReference(params, volRef);\\n    }\\n\\n    /**\\n     * @dev Updates the volatility accumulator in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param activeId The active id\\n     * @return The updated encoded pair parameters\\n     */\\n    function updateVolatilityAccumulator(bytes32 params, uint24 activeId) internal pure returns (bytes32) {\\n        uint256 idReference = getIdReference(params);\\n\\n        uint256 deltaId;\\n        uint256 volAcc;\\n\\n        unchecked {\\n            deltaId = activeId > idReference ? activeId - idReference : idReference - activeId;\\n            volAcc = (uint256(getVolatilityReference(params)) + deltaId * Constants.BASIS_POINT_MAX);\\n        }\\n\\n        uint256 maxVolAcc = getMaxVolatilityAccumulator(params);\\n\\n        volAcc = volAcc > maxVolAcc ? maxVolAcc : volAcc;\\n\\n        return setVolatilityAccumulator(params, uint24(volAcc));\\n    }\\n\\n    /**\\n     * @dev Updates the volatility reference and the volatility accumulator in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @return The updated encoded pair parameters\\n     */\\n    function updateReferences(bytes32 params) internal view returns (bytes32) {\\n        uint256 dt = block.timestamp - getTimeOfLastUpdate(params);\\n\\n        if (dt >= getFilterPeriod(params)) {\\n            params = updateIdReference(params);\\n            params = dt < getDecayPeriod(params) ? updateVolatilityReference(params) : setVolatilityReference(params, 0);\\n        }\\n\\n        return updateTimeOfLastUpdate(params);\\n    }\\n\\n    /**\\n     * @dev Updates the volatility reference and the volatility accumulator in the encoded pair parameters\\n     * @param params The encoded pair parameters\\n     * @param activeId The active id\\n     * @return The updated encoded pair parameters\\n     */\\n    function updateVolatilityParameters(bytes32 params, uint24 activeId) internal view returns (bytes32) {\\n        params = updateReferences(params);\\n        return updateVolatilityAccumulator(params, activeId);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/PendingOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IPendingOwnable} from \\\"../interfaces/IPendingOwnable.sol\\\";\\n\\n/**\\n * @title Pending Ownable\\n * @author Trader Joe\\n * @notice Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions. The ownership of this contract is transferred using the\\n * push and pull pattern, the current owner sets a `pendingOwner` using\\n * {setPendingOwner} and that address can then call {becomeOwner} to become the\\n * owner of that contract. The main logic and comments comes from OpenZeppelin's\\n * Ownable contract.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {setPendingOwner} and {becomeOwner}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner\\n */\\ncontract PendingOwnable is IPendingOwnable {\\n    address private _owner;\\n    address private _pendingOwner;\\n\\n    /**\\n     * @notice Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner) revert PendingOwnable__NotOwner();\\n        _;\\n    }\\n\\n    /**\\n     * /**\\n     * @notice Throws if called by any account other than the pending owner.\\n     */\\n    modifier onlyPendingOwner() {\\n        if (msg.sender != _pendingOwner || msg.sender == address(0)) revert PendingOwnable__NotPendingOwner();\\n        _;\\n    }\\n\\n    /**\\n     * /**\\n     * @notice Initializes the contract setting the deployer as the initial owner\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner\\n     * @return The address of the current owner\\n     */\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current pending owner\\n     * @return The address of the current pending owner\\n     */\\n    function pendingOwner() public view override returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @notice Sets the pending owner address. This address will be able to become\\n     * the owner of this contract by calling {becomeOwner}\\n     */\\n    function setPendingOwner(address pendingOwner_) public override onlyOwner {\\n        if (pendingOwner_ == address(0)) revert PendingOwnable__AddressZero();\\n        if (_pendingOwner != address(0)) revert PendingOwnable__PendingOwnerAlreadySet();\\n        _setPendingOwner(pendingOwner_);\\n    }\\n\\n    /**\\n     * @notice Revoke the pending owner address. This address will not be able to\\n     * call {becomeOwner} to become the owner anymore.\\n     * Can only be called by the owner\\n     */\\n    function revokePendingOwner() public override onlyOwner {\\n        if (_pendingOwner == address(0)) revert PendingOwnable__NoPendingOwner();\\n        _setPendingOwner(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers the ownership to the new owner (`pendingOwner).\\n     * Can only be called by the pending owner\\n     */\\n    function becomeOwner() public override onlyPendingOwner {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public override onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     * @param _newOwner The address of the new owner\\n     */\\n    function _transferOwnership(address _newOwner) internal virtual {\\n        address _oldOwner = _owner;\\n        _owner = _newOwner;\\n        _pendingOwner = address(0);\\n        emit OwnershipTransferred(_oldOwner, _newOwner);\\n    }\\n\\n    /**\\n     * @dev Push the new owner, it needs to be pulled to be effective.\\n     * Internal function without access restriction.\\n     * @param pendingOwner_ The address of the new pending owner\\n     */\\n    function _setPendingOwner(address pendingOwner_) internal virtual {\\n        _pendingOwner = pendingOwner_;\\n        emit PendingOwnerSet(pendingOwner_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/PriceHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {Uint128x128Math} from \\\"./math/Uint128x128Math.sol\\\";\\nimport {Uint256x256Math} from \\\"./math/Uint256x256Math.sol\\\";\\nimport {SafeCast} from \\\"./math/SafeCast.sol\\\";\\nimport {Constants} from \\\"./Constants.sol\\\";\\n\\n/**\\n * @title Liquidity Book Price Helper Library\\n * @author Trader Joe\\n * @notice This library contains functions to calculate prices\\n */\\nlibrary PriceHelper {\\n    using Uint128x128Math for uint256;\\n    using Uint256x256Math for uint256;\\n    using SafeCast for uint256;\\n\\n    int256 private constant REAL_ID_SHIFT = 1 << 23;\\n\\n    /**\\n     * @dev Calculates the price from the id and the bin step\\n     * @param id The id\\n     * @param binStep The bin step\\n     * @return price The price as a 128.128-binary fixed-point number\\n     */\\n    function getPriceFromId(uint24 id, uint16 binStep) internal pure returns (uint256 price) {\\n        uint256 base = getBase(binStep);\\n        int256 exponent = getExponent(id);\\n\\n        price = base.pow(exponent);\\n    }\\n\\n    /**\\n     * @dev Calculates the id from the price and the bin step\\n     * @param price The price as a 128.128-binary fixed-point number\\n     * @param binStep The bin step\\n     * @return id The id\\n     */\\n    function getIdFromPrice(uint256 price, uint16 binStep) internal pure returns (uint24 id) {\\n        uint256 base = getBase(binStep);\\n        int256 realId = price.log2() / base.log2();\\n\\n        unchecked {\\n            id = uint256(REAL_ID_SHIFT + realId).safe24();\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the base from the bin step, which is `1 + binStep / BASIS_POINT_MAX`\\n     * @param binStep The bin step\\n     * @return base The base\\n     */\\n    function getBase(uint16 binStep) internal pure returns (uint256) {\\n        unchecked {\\n            return Constants.SCALE + (uint256(binStep) << Constants.SCALE_OFFSET) / Constants.BASIS_POINT_MAX;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the exponent from the id, which is `id - REAL_ID_SHIFT`\\n     * @param id The id\\n     * @return exponent The exponent\\n     */\\n    function getExponent(uint24 id) internal pure returns (int256) {\\n        unchecked {\\n            return int256(uint256(id)) - REAL_ID_SHIFT;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a price with 18 decimals to a 128.128-binary fixed-point number\\n     * @param price The price with 18 decimals\\n     * @return price128x128 The 128.128-binary fixed-point number\\n     */\\n    function convertDecimalPriceTo128x128(uint256 price) internal pure returns (uint256) {\\n        return price.shiftDivRoundDown(Constants.SCALE_OFFSET, Constants.PRECISION);\\n    }\\n\\n    /**\\n     * @dev Converts a 128.128-binary fixed-point number to a price with 18 decimals\\n     * @param price128x128 The 128.128-binary fixed-point number\\n     * @return price The price with 18 decimals\\n     */\\n    function convert128x128PriceToDecimal(uint256 price128x128) internal pure returns (uint256) {\\n        return price128x128.mulShiftRoundDown(Constants.PRECISION, Constants.SCALE_OFFSET);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/math/BitMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Bit Math Library\\n * @author Trader Joe\\n * @notice Helper contract used for bit calculations\\n */\\nlibrary BitMath {\\n    /**\\n     * @dev Returns the index of the closest bit on the right of x that is non null\\n     * @param x The value as a uint256\\n     * @param bit The index of the bit to start searching at\\n     * @return id The index of the closest non null bit on the right of x.\\n     * If there is no closest bit, it returns max(uint256)\\n     */\\n    function closestBitRight(uint256 x, uint8 bit) internal pure returns (uint256 id) {\\n        unchecked {\\n            uint256 shift = 255 - bit;\\n            x <<= shift;\\n\\n            // can't overflow as it's non-zero and we shifted it by `_shift`\\n            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - shift;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the index of the closest bit on the left of x that is non null\\n     * @param x The value as a uint256\\n     * @param bit The index of the bit to start searching at\\n     * @return id The index of the closest non null bit on the left of x.\\n     * If there is no closest bit, it returns max(uint256)\\n     */\\n    function closestBitLeft(uint256 x, uint8 bit) internal pure returns (uint256 id) {\\n        unchecked {\\n            x >>= bit;\\n\\n            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the index of the most significant bit of x\\n     * This function returns 0 if x is 0\\n     * @param x The value as a uint256\\n     * @return msb The index of the most significant bit of x\\n     */\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 msb) {\\n        assembly {\\n            if gt(x, 0xffffffffffffffffffffffffffffffff) {\\n                x := shr(128, x)\\n                msb := 128\\n            }\\n            if gt(x, 0xffffffffffffffff) {\\n                x := shr(64, x)\\n                msb := add(msb, 64)\\n            }\\n            if gt(x, 0xffffffff) {\\n                x := shr(32, x)\\n                msb := add(msb, 32)\\n            }\\n            if gt(x, 0xffff) {\\n                x := shr(16, x)\\n                msb := add(msb, 16)\\n            }\\n            if gt(x, 0xff) {\\n                x := shr(8, x)\\n                msb := add(msb, 8)\\n            }\\n            if gt(x, 0xf) {\\n                x := shr(4, x)\\n                msb := add(msb, 4)\\n            }\\n            if gt(x, 0x3) {\\n                x := shr(2, x)\\n                msb := add(msb, 2)\\n            }\\n            if gt(x, 0x1) { msb := add(msb, 1) }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the index of the least significant bit of x\\n     * This function returns 255 if x is 0\\n     * @param x The value as a uint256\\n     * @return lsb The index of the least significant bit of x\\n     */\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 lsb) {\\n        assembly {\\n            let sx := shl(128, x)\\n            if iszero(iszero(sx)) {\\n                lsb := 128\\n                x := sx\\n            }\\n            sx := shl(64, x)\\n            if iszero(iszero(sx)) {\\n                x := sx\\n                lsb := add(lsb, 64)\\n            }\\n            sx := shl(32, x)\\n            if iszero(iszero(sx)) {\\n                x := sx\\n                lsb := add(lsb, 32)\\n            }\\n            sx := shl(16, x)\\n            if iszero(iszero(sx)) {\\n                x := sx\\n                lsb := add(lsb, 16)\\n            }\\n            sx := shl(8, x)\\n            if iszero(iszero(sx)) {\\n                x := sx\\n                lsb := add(lsb, 8)\\n            }\\n            sx := shl(4, x)\\n            if iszero(iszero(sx)) {\\n                x := sx\\n                lsb := add(lsb, 4)\\n            }\\n            sx := shl(2, x)\\n            if iszero(iszero(sx)) {\\n                x := sx\\n                lsb := add(lsb, 2)\\n            }\\n            if iszero(iszero(shl(1, x))) { lsb := add(lsb, 1) }\\n\\n            lsb := sub(255, lsb)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/math/Encoded.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Encoded Library\\n * @author Trader Joe\\n * @notice Helper contract used for decoding bytes32 sample\\n */\\nlibrary Encoded {\\n    uint256 internal constant MASK_UINT1 = 0x1;\\n    uint256 internal constant MASK_UINT8 = 0xff;\\n    uint256 internal constant MASK_UINT12 = 0xfff;\\n    uint256 internal constant MASK_UINT14 = 0x3fff;\\n    uint256 internal constant MASK_UINT16 = 0xffff;\\n    uint256 internal constant MASK_UINT20 = 0xfffff;\\n    uint256 internal constant MASK_UINT24 = 0xffffff;\\n    uint256 internal constant MASK_UINT40 = 0xffffffffff;\\n    uint256 internal constant MASK_UINT64 = 0xffffffffffffffff;\\n    uint256 internal constant MASK_UINT128 = 0xffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Internal function to set a value in an encoded bytes32 using a mask and offset\\n     * @dev This function can overflow\\n     * @param encoded The previous encoded value\\n     * @param value The value to encode\\n     * @param mask The mask\\n     * @param offset The offset\\n     * @return newEncoded The new encoded value\\n     */\\n    function set(bytes32 encoded, uint256 value, uint256 mask, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes32 newEncoded)\\n    {\\n        assembly {\\n            newEncoded := and(encoded, not(shl(offset, mask)))\\n            newEncoded := or(newEncoded, shl(offset, and(value, mask)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to set a bool in an encoded bytes32 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The previous encoded value\\n     * @param boolean The bool to encode\\n     * @param offset The offset\\n     * @return newEncoded The new encoded value\\n     */\\n    function setBool(bytes32 encoded, bool boolean, uint256 offset) internal pure returns (bytes32 newEncoded) {\\n        return set(encoded, boolean ? 1 : 0, MASK_UINT1, offset);\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample using a mask and offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param mask The mask\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decode(bytes32 encoded, uint256 mask, uint256 offset) internal pure returns (uint256 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a bool using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return boolean The decoded value as a bool\\n     */\\n    function decodeBool(bytes32 encoded, uint256 offset) internal pure returns (bool boolean) {\\n        assembly {\\n            boolean := and(shr(offset, encoded), MASK_UINT1)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint8 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint8(bytes32 encoded, uint256 offset) internal pure returns (uint8 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT8)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint12 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value as a uint16, since uint12 is not supported\\n     */\\n    function decodeUint12(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT12)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint14 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value as a uint16, since uint14 is not supported\\n     */\\n    function decodeUint14(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT14)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint16 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint16(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT16)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint20 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value as a uint24, since uint20 is not supported\\n     */\\n    function decodeUint20(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT20)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint24 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint24(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT24)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint40 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint40(bytes32 encoded, uint256 offset) internal pure returns (uint40 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT40)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint64 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint64(bytes32 encoded, uint256 offset) internal pure returns (uint64 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT64)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint128 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint128(bytes32 encoded, uint256 offset) internal pure returns (uint128 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT128)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Safe Cast Library\\n * @author Trader Joe\\n * @notice This library contains functions to safely cast uint256 to different uint types.\\n */\\nlibrary SafeCast {\\n    error SafeCast__Exceeds248Bits();\\n    error SafeCast__Exceeds240Bits();\\n    error SafeCast__Exceeds232Bits();\\n    error SafeCast__Exceeds224Bits();\\n    error SafeCast__Exceeds216Bits();\\n    error SafeCast__Exceeds208Bits();\\n    error SafeCast__Exceeds200Bits();\\n    error SafeCast__Exceeds192Bits();\\n    error SafeCast__Exceeds184Bits();\\n    error SafeCast__Exceeds176Bits();\\n    error SafeCast__Exceeds168Bits();\\n    error SafeCast__Exceeds160Bits();\\n    error SafeCast__Exceeds152Bits();\\n    error SafeCast__Exceeds144Bits();\\n    error SafeCast__Exceeds136Bits();\\n    error SafeCast__Exceeds128Bits();\\n    error SafeCast__Exceeds120Bits();\\n    error SafeCast__Exceeds112Bits();\\n    error SafeCast__Exceeds104Bits();\\n    error SafeCast__Exceeds96Bits();\\n    error SafeCast__Exceeds88Bits();\\n    error SafeCast__Exceeds80Bits();\\n    error SafeCast__Exceeds72Bits();\\n    error SafeCast__Exceeds64Bits();\\n    error SafeCast__Exceeds56Bits();\\n    error SafeCast__Exceeds48Bits();\\n    error SafeCast__Exceeds40Bits();\\n    error SafeCast__Exceeds32Bits();\\n    error SafeCast__Exceeds24Bits();\\n    error SafeCast__Exceeds16Bits();\\n    error SafeCast__Exceeds8Bits();\\n\\n    /**\\n     * @dev Returns x on uint248 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint248\\n     */\\n    function safe248(uint256 x) internal pure returns (uint248 y) {\\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint240 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint240\\n     */\\n    function safe240(uint256 x) internal pure returns (uint240 y) {\\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint232 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint232\\n     */\\n    function safe232(uint256 x) internal pure returns (uint232 y) {\\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint224 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint224\\n     */\\n    function safe224(uint256 x) internal pure returns (uint224 y) {\\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint216 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint216\\n     */\\n    function safe216(uint256 x) internal pure returns (uint216 y) {\\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint208 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint208\\n     */\\n    function safe208(uint256 x) internal pure returns (uint208 y) {\\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint200 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint200\\n     */\\n    function safe200(uint256 x) internal pure returns (uint200 y) {\\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint192 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint192\\n     */\\n    function safe192(uint256 x) internal pure returns (uint192 y) {\\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint184 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint184\\n     */\\n    function safe184(uint256 x) internal pure returns (uint184 y) {\\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint176 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint176\\n     */\\n    function safe176(uint256 x) internal pure returns (uint176 y) {\\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint168 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint168\\n     */\\n    function safe168(uint256 x) internal pure returns (uint168 y) {\\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint160 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint160\\n     */\\n    function safe160(uint256 x) internal pure returns (uint160 y) {\\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint152 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint152\\n     */\\n    function safe152(uint256 x) internal pure returns (uint152 y) {\\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint144 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint144\\n     */\\n    function safe144(uint256 x) internal pure returns (uint144 y) {\\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint136 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint136\\n     */\\n    function safe136(uint256 x) internal pure returns (uint136 y) {\\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint128 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint128\\n     */\\n    function safe128(uint256 x) internal pure returns (uint128 y) {\\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint120 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint120\\n     */\\n    function safe120(uint256 x) internal pure returns (uint120 y) {\\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint112 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint112\\n     */\\n    function safe112(uint256 x) internal pure returns (uint112 y) {\\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint104 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint104\\n     */\\n    function safe104(uint256 x) internal pure returns (uint104 y) {\\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint96 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint96\\n     */\\n    function safe96(uint256 x) internal pure returns (uint96 y) {\\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint88 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint88\\n     */\\n    function safe88(uint256 x) internal pure returns (uint88 y) {\\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint80 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint80\\n     */\\n    function safe80(uint256 x) internal pure returns (uint80 y) {\\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint72 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint72\\n     */\\n    function safe72(uint256 x) internal pure returns (uint72 y) {\\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint64 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint64\\n     */\\n    function safe64(uint256 x) internal pure returns (uint64 y) {\\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint56 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint56\\n     */\\n    function safe56(uint256 x) internal pure returns (uint56 y) {\\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint48 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint48\\n     */\\n    function safe48(uint256 x) internal pure returns (uint48 y) {\\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint40 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint40\\n     */\\n    function safe40(uint256 x) internal pure returns (uint40 y) {\\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint32 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint32\\n     */\\n    function safe32(uint256 x) internal pure returns (uint32 y) {\\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint24 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint24\\n     */\\n    function safe24(uint256 x) internal pure returns (uint24 y) {\\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint16 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint16\\n     */\\n    function safe16(uint256 x) internal pure returns (uint16 y) {\\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint8 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint8\\n     */\\n    function safe8(uint256 x) internal pure returns (uint8 y) {\\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/math/Uint128x128Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {Constants} from \\\"../Constants.sol\\\";\\nimport {BitMath} from \\\"./BitMath.sol\\\";\\n\\n/**\\n * @title Liquidity Book Uint128x128 Math Library\\n * @author Trader Joe\\n * @notice Helper contract used for power and log calculations\\n */\\nlibrary Uint128x128Math {\\n    using BitMath for uint256;\\n\\n    error Uint128x128Math__LogUnderflow();\\n    error Uint128x128Math__PowUnderflow(uint256 x, int256 y);\\n\\n    uint256 constant LOG_SCALE_OFFSET = 127;\\n    uint256 constant LOG_SCALE = 1 << LOG_SCALE_OFFSET;\\n    uint256 constant LOG_SCALE_SQUARED = LOG_SCALE * LOG_SCALE;\\n\\n    /**\\n     * @notice Calculates the binary logarithm of x.\\n     * @dev Based on the iterative approximation algorithm.\\n     * https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n     * Requirements:\\n     * - x must be greater than zero.\\n     * Caveats:\\n     * - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation\\n     * Also because x is converted to an unsigned 129.127-binary fixed-point number during the operation to optimize the multiplication\\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the binary logarithm.\\n     * @return result The binary logarithm as a signed 128.128-binary fixed-point number.\\n     */\\n    function log2(uint256 x) internal pure returns (int256 result) {\\n        // Convert x to a unsigned 129.127-binary fixed-point number to optimize the multiplication.\\n        // If we use an offset of 128 bits, y would need 129 bits and y**2 would would overflow and we would have to\\n        // use mulDiv, by reducing x to 129.127-binary fixed-point number we assert that y will use 128 bits, and we\\n        // can use the regular multiplication\\n\\n        if (x == 1) return -128;\\n        if (x == 0) revert Uint128x128Math__LogUnderflow();\\n\\n        x >>= 1;\\n\\n        unchecked {\\n            // This works because log2(x) = -log2(1/x).\\n            int256 sign;\\n            if (x >= LOG_SCALE) {\\n                sign = 1;\\n            } else {\\n                sign = -1;\\n                // Do the fixed-point inversion inline to save gas\\n                x = LOG_SCALE_SQUARED / x;\\n            }\\n\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();\\n\\n            // The integer part of the logarithm as a signed 129.127-binary fixed-point number. The operation can't overflow\\n            // because n is maximum 255, LOG_SCALE_OFFSET is 127 bits and sign is either 1 or -1.\\n            result = int256(n) << LOG_SCALE_OFFSET;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y != LOG_SCALE) {\\n                // Calculate the fractional part via the iterative approximation.\\n                // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {\\n                    y = (y * y) >> LOG_SCALE_OFFSET;\\n\\n                    // Is y^2 > 2 and so in the range [2,4)?\\n                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {\\n                        // Add the 2^(-m) factor to the logarithm.\\n                        result += delta;\\n\\n                        // Corresponds to z/2 on Wikipedia.\\n                        y >>= 1;\\n                    }\\n                }\\n            }\\n            // Convert x back to unsigned 128.128-binary fixed-point number\\n            result = (result * sign) << 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the value of x^y. It calculates `1 / x^abs(y)` if x is bigger than 2^128.\\n     * At the end of the operations, we invert the result if needed.\\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the power\\n     * @param y A relative number without any decimals, needs to be between ]2^21; 2^21[\\n     */\\n    function pow(uint256 x, int256 y) internal pure returns (uint256 result) {\\n        bool invert;\\n        uint256 absY;\\n\\n        if (y == 0) return Constants.SCALE;\\n\\n        assembly {\\n            absY := y\\n            if slt(absY, 0) {\\n                absY := sub(0, absY)\\n                invert := iszero(invert)\\n            }\\n        }\\n\\n        if (absY < 0x100000) {\\n            result = Constants.SCALE;\\n            assembly {\\n                let squared := x\\n                if gt(x, 0xffffffffffffffffffffffffffffffff) {\\n                    squared := div(not(0), squared)\\n                    invert := iszero(invert)\\n                }\\n\\n                if and(absY, 0x1) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x2) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x4) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x8) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x10) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x20) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x40) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x80) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x100) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x200) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x400) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x800) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x1000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x2000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x4000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x8000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x10000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x20000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x40000) { result := shr(128, mul(result, squared)) }\\n                squared := shr(128, mul(squared, squared))\\n                if and(absY, 0x80000) { result := shr(128, mul(result, squared)) }\\n            }\\n        }\\n\\n        // revert if y is too big or if x^y underflowed\\n        if (result == 0) revert Uint128x128Math__PowUnderflow(x, y);\\n\\n        return invert ? type(uint256).max / result : result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/math/Uint256x256Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Uint256x256 Math Library\\n * @author Trader Joe\\n * @notice Helper contract used for full precision calculations\\n */\\nlibrary Uint256x256Math {\\n    error Uint256x256Math__MulShiftOverflow();\\n    error Uint256x256Math__MulDivOverflow();\\n\\n    /**\\n     * @notice Calculates floor(x*y/denominator) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The denominator cannot be zero\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\\n\\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\\n    }\\n\\n    /**\\n     * @notice Calculates ceil(x*y/denominator) with full precision\\n     * The result will be rounded up\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The denominator cannot be zero\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        result = mulDivRoundDown(x, y, denominator);\\n        if (mulmod(x, y, denominator) != 0) result += 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / 2**offset) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param offset The offset as an uint256, can't be greater than 256\\n     * @return result The result as an uint256\\n     */\\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\\n\\n        if (prod0 != 0) result = prod0 >> offset;\\n        if (prod1 != 0) {\\n            // Make sure the result is less than 2^256.\\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\\n\\n            unchecked {\\n                result += prod1 << (256 - offset);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / 2**offset) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param offset The offset as an uint256, can't be greater than 256\\n     * @return result The result as an uint256\\n     */\\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\\n        result = mulShiftRoundDown(x, y, offset);\\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x << offset / y) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param offset The number of bit to shift x as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n\\n        prod0 = x << offset; // Least significant 256 bits of the product\\n        unchecked {\\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\\n        }\\n\\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\\n    }\\n\\n    /**\\n     * @notice Calculates ceil(x << offset / y) with full precision\\n     * The result will be rounded up\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param offset The number of bit to shift x as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\\n        result = shiftDivRoundDown(x, offset, denominator);\\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\\n    }\\n\\n    /**\\n     * @notice Helper function to return the result of `x * y` as 2 uint256\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @return prod0 The least significant 256 bits of the product\\n     * @return prod1 The most significant 256 bits of the product\\n     */\\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @param prod0 The least significant 256 bits of the product\\n     * @param prod1 The most significant 256 bits of the product\\n     * @return result The result as an uint256\\n     */\\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\\n        private\\n        pure\\n        returns (uint256 result)\\n    {\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n        } else {\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\\n            // See https://cs.stackexchange.com/q/138556/92363\\n            unchecked {\\n                // Does not overflow because the denominator cannot be zero at this stage in the function\\n                uint256 lpotdod = denominator & (~denominator + 1);\\n                assembly {\\n                    // Divide denominator by lpotdod.\\n                    denominator := div(denominator, lpotdod)\\n\\n                    // Divide [prod1 prod0] by lpotdod.\\n                    prod0 := div(prod0, lpotdod)\\n\\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n                }\\n\\n                // Shift in bits from prod1 into prod0\\n                prod0 |= prod1 * lpotdod;\\n\\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n                // four bits. That is, denominator * inv = 1 mod 2^4\\n                uint256 inverse = (3 * denominator) ^ 2;\\n\\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n                // in modular arithmetic, doubling the correct bits in each step\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n                // is no longer required.\\n                result = prod0 * inverse;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashLoanFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LBFactory__AddressZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"LBFactory__BinStepHasNoPreset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"LBFactory__BinStepTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFees\",\"type\":\"uint256\"}],\"name\":\"LBFactory__FlashLoanFeeAboveMax\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LBFactory__IdenticalAddresses\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBFactory__ImplementationNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_binStep\",\"type\":\"uint256\"}],\"name\":\"LBFactory__LBPairAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"LBFactory__LBPairDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBFactory__LBPairIgnoredIsAlreadyInTheSameState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"LBFactory__LBPairNotCreated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"LBPairImplementation\",\"type\":\"address\"}],\"name\":\"LBFactory__LBPairSafetyCheckFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"LBFactory__PresetIsLockedForUsers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBFactory__PresetOpenStateIsAlreadyInTheSameState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"LBFactory__QuoteAssetAlreadyWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"LBFactory__QuoteAssetNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"LBFactory__SameFeeRecipient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flashLoanFee\",\"type\":\"uint256\"}],\"name\":\"LBFactory__SameFlashLoanFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"LBPairImplementation\",\"type\":\"address\"}],\"name\":\"LBFactory__SameImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PairParametersHelper__InvalidParameter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingOwnable__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingOwnable__NoPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingOwnable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingOwnable__NotPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingOwnable__PendingOwnerAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCast__Exceeds16Bits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Uint128x128Math__PowUnderflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"FeeRecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFlashLoanFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFlashLoanFee\",\"type\":\"uint256\"}],\"name\":\"FlashLoanFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract ILBPair\",\"name\":\"LBPair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"LBPairCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILBPair\",\"name\":\"LBPair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ignored\",\"type\":\"bool\"}],\"name\":\"LBPairIgnoredStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLBPairImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"LBPairImplementation\",\"type\":\"address\"}],\"name\":\"LBPairImplementationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"PendingOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"PresetOpenStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"PresetRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"filterPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decayPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reductionFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableFeeControl\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxVolatilityAccumulator\",\"type\":\"uint256\"}],\"name\":\"PresetSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"QuoteAssetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"QuoteAssetRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"addQuoteAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"becomeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"activeId\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"}],\"name\":\"createLBPair\",\"outputs\":[{\"internalType\":\"contract ILBPair\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILBPair\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"forceDecay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllBinSteps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"binStepWithPreset\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"}],\"name\":\"getAllLBPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"contract ILBPair\",\"name\":\"LBPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"createdByOwner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ignoredForRouting\",\"type\":\"bool\"}],\"internalType\":\"struct ILBFactory.LBPairInformation[]\",\"name\":\"lbPairsAvailable\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFlashLoanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"flashLoanFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getLBPairAtIndex\",\"outputs\":[{\"internalType\":\"contract ILBPair\",\"name\":\"lbPair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLBPairImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lbPairImplementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"getLBPairInformation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"contract ILBPair\",\"name\":\"LBPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"createdByOwner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ignoredForRouting\",\"type\":\"bool\"}],\"internalType\":\"struct ILBFactory.LBPairInformation\",\"name\":\"lbPairInformation\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxFlashLoanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinBinStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minBinStep\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfLBPairs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lbPairNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfQuoteAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfQuoteAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenBinSteps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"openBinStep\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"binStep\",\"type\":\"uint256\"}],\"name\":\"getPreset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"filterPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decayPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reductionFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableFeeControl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVolatilityAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getQuoteAssetAtIndex\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"asset\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isQuoteAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isQuote\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"}],\"name\":\"removePreset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"removeQuoteAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokePendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"baseFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"filterPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"decayPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reductionFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"variableFeeControl\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"protocolShare\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"maxVolatilityAccumulator\",\"type\":\"uint24\"}],\"name\":\"setFeesParametersOnPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flashLoanFee\",\"type\":\"uint256\"}],\"name\":\"setFlashLoanFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"ignored\",\"type\":\"bool\"}],\"name\":\"setLBPairIgnored\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLBPairImplementation\",\"type\":\"address\"}],\"name\":\"setLBPairImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner_\",\"type\":\"address\"}],\"name\":\"setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"baseFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"filterPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"decayPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reductionFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"variableFeeControl\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"protocolShare\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"maxVolatilityAccumulator\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"setPreset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"setPresetOpenState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LBFactory", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000c8fc59fceb8259534d8b10879273879eddf7eec00000000000000000000000000000000000000000000000000000048c27395000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}