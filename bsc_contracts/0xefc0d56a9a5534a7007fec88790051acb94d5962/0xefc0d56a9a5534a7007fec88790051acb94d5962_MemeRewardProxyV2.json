{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/meme/MemeRewardProxy.sol\": {\r\n      \"content\": \"/**\\r\\n * @dev                          :^~!77!^:\\r\\n *                            ^?J?!~^^^^!7??^\\r\\n *                          .JJ^      .~!!~~?Y^.~???.\\r\\n *                         .P!       75~^~7J7:5G!: YY.:^.\\r\\n *                        .5J       .B^:G#Y:YJ ?Y:~5P?7!P!\\r\\n *                       .G@^ .!?7:  57.B@@Y.B~.GY!:    G7\\r\\n *                       ^#B^ :BBGG. .57:YP!.G~.:     .57\\r\\n *                       .BB7  7PY!   .?Y7~!Y?       ^P!:!.\\r\\n *                        J#G   ..      .^~^.       ~B5JJB! ^75^\\r\\n *                         !B7                   .:^Y#?!~PPYYJ#:\\r\\n *                          :B:                  .!!!?7!!!7!!G!\\r\\n *                           75             ^~~~~~!!!!!!!!~7G!\\r\\n *                            JJ       ... ^!!!!!!!!!!!!!!YP^\\r\\n *                             Y?     ~!!!~!!!!!!!!!!!!!JP?.\\r\\n *                              JJ:::^!!!!!!!!!!!!!!!7J5?:\\r\\n *                               !5J!!!!!!!!!!!!!7?YY?~.\\r\\n *                                .JYJ??77777??YYY#J\\r\\n *                                  .^~7????JGY::?PP\\r\\n *                                         .7PY   !:\\r\\n *                                           :.\\r\\n *                     meme share reward v2: multi token\\r\\n *                     website: https://www.memebook.xyz/home\\r\\n *                     twitter: https://twitter.com/memebook_xyz\\r\\n *                     whitepapper_en: https://whitepaper.memebook.xyz/en/\\r\\n *                     whitepapper_zh: https://whitepaper.memebook.xyz/zh/\\r\\n *\\r\\n *\\r\\n *\\r\\n */\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary StorageSlot {\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    struct BooleanSlot {\\r\\n        bool value;\\r\\n    }\\r\\n\\r\\n    struct Bytes32Slot {\\r\\n        bytes32 value;\\r\\n    }\\r\\n\\r\\n    struct Uint256Slot {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    function getAddressSlot(\\r\\n        bytes32 slot\\r\\n    ) internal pure returns (AddressSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBooleanSlot(\\r\\n        bytes32 slot\\r\\n    ) internal pure returns (BooleanSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBytes32Slot(\\r\\n        bytes32 slot\\r\\n    ) internal pure returns (Bytes32Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUint256Slot(\\r\\n        bytes32 slot\\r\\n    ) internal pure returns (Uint256Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                0,\\r\\n                \\\"Address: low-level call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance >= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\r\\n            data\\r\\n        );\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal view returns (bytes memory) {\\r\\n        return\\r\\n            functionStaticCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level static call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionDelegateCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level delegate call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) private pure {\\r\\n        if (returndata.length > 0) {\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC1822Proxiable {\\r\\n    function proxiableUUID() external view returns (bytes32);\\r\\n}\\r\\n\\r\\ninterface IBeacon {\\r\\n    function implementation() external view returns (address);\\r\\n}\\r\\n\\r\\nabstract contract ERC1967Upgrade {\\r\\n    bytes32 private constant _ROLLBACK_SLOT =\\r\\n        0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\r\\n\\r\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\r\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    event Upgraded(address indexed implementation);\\r\\n\\r\\n    function _getImplementation() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n    }\\r\\n\\r\\n    function _setImplementation(address newImplementation) private {\\r\\n        require(\\r\\n            Address.isContract(newImplementation),\\r\\n            \\\"ERC1967: new implementation is not a contract\\\"\\r\\n        );\\r\\n        StorageSlot\\r\\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\\r\\n            .value = newImplementation;\\r\\n    }\\r\\n\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    function _upgradeToAndCall(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _upgradeTo(newImplementation);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            Address.functionDelegateCall(newImplementation, data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _upgradeToAndCallUUPS(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\r\\n            _setImplementation(newImplementation);\\r\\n        } else {\\r\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (\\r\\n                bytes32 slot\\r\\n            ) {\\r\\n                require(\\r\\n                    slot == _IMPLEMENTATION_SLOT,\\r\\n                    \\\"ERC1967Upgrade: unsupported proxiableUUID\\\"\\r\\n                );\\r\\n            } catch {\\r\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\r\\n            }\\r\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant _ADMIN_SLOT =\\r\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n    event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n    function _getAdmin() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\r\\n    }\\r\\n\\r\\n    function _setAdmin(address newAdmin) private {\\r\\n        require(\\r\\n            newAdmin != address(0),\\r\\n            \\\"ERC1967: new admin is the zero address\\\"\\r\\n        );\\r\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\r\\n    }\\r\\n\\r\\n    function _changeAdmin(address newAdmin) internal {\\r\\n        emit AdminChanged(_getAdmin(), newAdmin);\\r\\n        _setAdmin(newAdmin);\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant _BEACON_SLOT =\\r\\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\r\\n\\r\\n    event BeaconUpgraded(address indexed beacon);\\r\\n\\r\\n    function _getBeacon() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\r\\n    }\\r\\n\\r\\n    function _setBeacon(address newBeacon) private {\\r\\n        require(\\r\\n            Address.isContract(newBeacon),\\r\\n            \\\"ERC1967: new beacon is not a contract\\\"\\r\\n        );\\r\\n        require(\\r\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\r\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\r\\n        );\\r\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\r\\n    }\\r\\n\\r\\n    function _upgradeBeaconToAndCall(\\r\\n        address newBeacon,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _setBeacon(newBeacon);\\r\\n        emit BeaconUpgraded(newBeacon);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            Address.functionDelegateCall(\\r\\n                IBeacon(newBeacon).implementation(),\\r\\n                data\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Proxy {\\r\\n    function _delegate(address implementation) internal virtual {\\r\\n        assembly {\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            let result := delegatecall(\\r\\n                gas(),\\r\\n                implementation,\\r\\n                0,\\r\\n                calldatasize(),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            switch result\\r\\n            case 0 {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            default {\\r\\n                return(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _implementation() internal view virtual returns (address);\\r\\n\\r\\n    function _fallback() internal virtual {\\r\\n        _beforeFallback();\\r\\n        _delegate(_implementation());\\r\\n    }\\r\\n\\r\\n    fallback() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    receive() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    function _beforeFallback() internal virtual {}\\r\\n}\\r\\n\\r\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\r\\n    constructor(address _logic, bytes memory _data) payable {\\r\\n        _upgradeToAndCall(_logic, _data, false);\\r\\n    }\\r\\n\\r\\n    function _implementation()\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (address impl)\\r\\n    {\\r\\n        return ERC1967Upgrade._getImplementation();\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract MemeRewardProxyV2 is ERC1967Proxy {\\r\\n    constructor(\\r\\n        address _logic,\\r\\n        bytes memory _data\\r\\n    ) ERC1967Proxy(_logic, _data) {}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MemeRewardProxyV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d176a03f301d3d9d35687741060d1a137f091013000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000048129fc1c00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xd0e4b681a21bce46f7d9004ac66a1b06e8cb61ef", "SwarmSource": ""}