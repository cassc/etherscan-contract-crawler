{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StargateDepositAuthorizer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"FarmingBase.sol\\\";\\nimport \\\"IStargateFactory.sol\\\";\\nimport \\\"StargateAddressUtils.sol\\\";\\n\\ncontract StargateDepositAuthorizer is FarmingBaseACL {\\n    bytes32 public constant NAME = \\\"StargateDepositAuthorizer\\\";\\n    uint256 public constant VERSION = 1;\\n\\n    address public immutable router;\\n    address public immutable stakingPool;\\n    address public immutable stargateFactory;\\n\\n    constructor(address _owner, address _caller) FarmingBaseACL(_owner, _caller) {\\n        (stakingPool, router, stargateFactory) = getAddresses();\\n    }\\n\\n    ///@dev for stargate router\\n    function addLiquidity(\\n        uint256 poolId,\\n        uint256, //_amountLD\\n        address _to\\n    ) external view onlyContract(router) {\\n        address liquidity_pool = IStargateFactory(stargateFactory).getPool(poolId);\\n        _checkAllowPoolAddress(liquidity_pool);\\n        _checkRecipient(_to);\\n    }\\n\\n    ///@dev for lp staking\\n    function deposit(\\n        uint256 _pid,\\n        uint256 //amount\\n    ) public view onlyContract(stakingPool) {\\n        _checkAllowPoolId(_pid);\\n    }\\n\\n    function contracts() public view override returns (address[] memory _contracts) {\\n        _contracts = new address[](2);\\n        _contracts[0] = router;\\n        _contracts[1] = stakingPool;\\n    }\\n}\\n\"\r\n    },\r\n    \"FarmingBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"BaseACL.sol\\\";\\nimport \\\"EnumerableSet.sol\\\";\\n\\nabstract contract FarmingBaseACL is BaseACL {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    //roles => pool id whitelist\\n    EnumerableSet.UintSet farmPoolIdWhitelist;\\n    EnumerableSet.AddressSet farmPoolAddressWhitelist;\\n\\n    //events\\n    event AddPoolAddressWhitelist(address indexed _poolAddress, address indexed user);\\n    event RemovePoolAddressWhitelist(address indexed _poolAddress, address indexed user);\\n    event AddPoolIdWhitelist(uint256 indexed _poolId, address indexed user);\\n    event RemovePoolIdWhitelist(uint256 indexed _poolId, address indexed user);\\n\\n    constructor(address _owner, address _caller) BaseACL(_owner, _caller) {}\\n\\n    function addPoolIds(uint256[] calldata _poolIds) external onlyOwner {\\n        for (uint256 i = 0; i < _poolIds.length; i++) {\\n            if (farmPoolIdWhitelist.add(_poolIds[i])) {\\n                emit AddPoolIdWhitelist(_poolIds[i], msg.sender);\\n            }\\n        }\\n    }\\n\\n    function removePoolIds(uint256[] calldata _poolIds) external onlyOwner {\\n        for (uint256 i = 0; i < _poolIds.length; i++) {\\n            if (farmPoolIdWhitelist.remove(_poolIds[i])) {\\n                emit RemovePoolIdWhitelist(_poolIds[i], msg.sender);\\n            }\\n        }\\n    }\\n\\n    function addPoolAddresses(address[] calldata _poolAddresses) external onlyOwner {\\n        for (uint256 i = 0; i < _poolAddresses.length; i++) {\\n            if (farmPoolAddressWhitelist.add(_poolAddresses[i])) {\\n                emit AddPoolAddressWhitelist(_poolAddresses[i], msg.sender);\\n            }\\n        }\\n    }\\n\\n    function removePoolAddresses(address[] calldata _poolAddresses) external onlyOwner {\\n        for (uint256 i = 0; i < _poolAddresses.length; i++) {\\n            if (farmPoolAddressWhitelist.remove(_poolAddresses[i])) {\\n                emit RemovePoolAddressWhitelist(_poolAddresses[i], msg.sender);\\n            }\\n        }\\n    }\\n\\n    function getPoolIdWhiteList() external view returns (uint256[] memory) {\\n        return farmPoolIdWhitelist.values();\\n    }\\n\\n    function getPoolAddressWhiteList() external view returns (address[] memory) {\\n        return farmPoolAddressWhitelist.values();\\n    }\\n\\n    function _checkAllowPoolId(uint256 _poolId) internal view {\\n        require(farmPoolIdWhitelist.contains(_poolId), \\\"pool id not allowed\\\");\\n    }\\n\\n    function _checkAllowPoolAddress(address _poolAddress) internal view {\\n        require(farmPoolAddressWhitelist.contains(_poolAddress), \\\"pool address not allowed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"BaseACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"EnumerableSet.sol\\\";\\n\\nimport \\\"BaseAuthorizer.sol\\\";\\n\\n/// @title BaseACL - Basic ACL template which uses the call-self trick to perform function and parameters check.\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev Steps to extend this:\\n///        1. Set the NAME and VERSION.\\n///        2. Write ACL functions according the target contract.\\n///        3. Add a constructor. eg:\\n///           `constructor(address _owner, address _caller) BaseACL(_owner, _caller) {}`\\n///        4. Override `contracts()` to only target contracts that you checks. For txn\\n////          whose to address is not in the list `_preExecCheck()` will revert.\\n///        5. (Optional) If state changing operation in the checking method is required,\\n///           override `_preExecCheck()` to change `staticcall` to `call`.\\n///        6. (Optional) Override `permissions()` to summary your checking methods.\\n///\\n///      NOTE for ACL developers:\\n///        1. Implement your checking functions which should be defined extractly the same as\\n///           the target method to control so you do not bother to write a lot abi.decode code.\\n///        2. Checking funtions should NOT return any value, use `require` to perform your check.\\n///        3. BaseACL may serve for multiple target contracts.\\n///            - Implement contracts() to manage the target contracts set.\\n///            - Use `onlyContract` modifier or check `_txn().to` in checking functions.\\n///        4. Do NOT implement your own `setXXX` function, wrap your data into `Variant` and\\n///           use `setVariant` `getVariant` instead.\\n///        5. If you still need your own setter, ensure `onlyOwner` is used.\\n\\nabstract contract BaseACL is BaseAuthorizer {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    /// @dev Set such constants in sub contract.\\n    // bytes32 public constant NAME = \\\"BaseACL\\\";\\n    // bytes32 public constant override TYPE = \\\"ACLType\\\";\\n    // uint256 public constant VERSION = 0;\\n\\n    /// Only preExecCheck is used in BaseACL.\\n    uint256 public constant flag = AuthFlags.HAS_PRE_CHECK_MASK;\\n\\n    constructor(address _owner, address _caller) BaseAuthorizer(_owner, _caller) {}\\n\\n    /// Internal functions.\\n    function _parseReturnData(\\n        bool success,\\n        bytes memory revertData\\n    ) internal pure returns (AuthorizerReturnData memory authData) {\\n        if (success) {\\n            // ACL check function should return empty bytes which differs from normal view functions.\\n            require(revertData.length == 0, Errors.ACL_FUNC_RETURNS_NON_EMPTY);\\n            authData.result = AuthResult.SUCCESS;\\n        } else {\\n            if (revertData.length < 68) {\\n                // 4(Error sig) + 32(offset) + 32(length)\\n                authData.message = string(revertData);\\n            } else {\\n                assembly {\\n                    // Slice the sighash.\\n                    revertData := add(revertData, 0x04)\\n                }\\n                authData.message = abi.decode(revertData, (string));\\n            }\\n        }\\n    }\\n\\n    function _contractCheck(TransactionData calldata transaction) internal virtual returns (bool result) {\\n        // This works as a catch-all check. Sample but safer.\\n        address to = transaction.to;\\n        address[] memory _contracts = contracts(); // Call external.\\n        for (uint i = 0; i < _contracts.length; i++) {\\n            if (to == _contracts[i]) return true;\\n        }\\n        return false;\\n    }\\n\\n    function _packTxn(TransactionData calldata transaction) internal pure virtual returns (bytes memory) {\\n        bytes memory txnData = abi.encode(transaction);\\n        bytes memory callDataSize = abi.encode(transaction.data.length);\\n        return abi.encodePacked(transaction.data, txnData, callDataSize);\\n    }\\n\\n    function _unpackTxn() internal pure virtual returns (TransactionData memory transaction) {\\n        uint256 end = msg.data.length;\\n        uint256 callDataSize = abi.decode(msg.data[end - 32:end], (uint256));\\n        transaction = abi.decode(msg.data[callDataSize:], (TransactionData));\\n    }\\n\\n    // @dev Only valid in self-call checking functions.\\n    function _txn() internal pure virtual returns (TransactionData memory transaction) {\\n        return _unpackTxn();\\n    }\\n\\n    function _preExecCheck(\\n        TransactionData calldata transaction\\n    ) internal virtual override returns (AuthorizerReturnData memory authData) {\\n        if (!_contractCheck(transaction)) {\\n            authData.result = AuthResult.FAILED;\\n            authData.message = Errors.NOT_IN_CONTRACT_LIST;\\n            return authData;\\n        }\\n        (bool success, bytes memory revertData) = address(this).staticcall(_packTxn(transaction));\\n        return _parseReturnData(success, revertData);\\n    }\\n\\n    function _postExecCheck(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult,\\n        AuthorizerReturnData calldata preData\\n    ) internal virtual override returns (AuthorizerReturnData memory authData) {\\n        authData.result = AuthResult.SUCCESS;\\n    }\\n\\n    // Internal view functions.\\n\\n    // Utilities for checking functions.\\n    function _checkRecipient(address _recipient) internal view {\\n        require(_recipient == _txn().from, \\\"Invalid recipient\\\");\\n    }\\n\\n    function _checkContract(address _contract) internal view {\\n        require(_contract == _txn().to, \\\"Invalid contract\\\");\\n    }\\n\\n    // Modifiers.\\n\\n    modifier onlyContract(address _contract) {\\n        _checkContract(_contract);\\n        _;\\n    }\\n\\n    /// External functions\\n\\n    /// @dev Implement your own access control checking functions here.\\n\\n    // example:\\n\\n    // function transfer(address to, uint256 amount)\\n    //     onlyContract(USDT_ADDR)\\n    //     external view\\n    // {\\n    //     require(amount > 0 & amount < 10000, \\\"amount not in range\\\");\\n    // }\\n\\n    /// @dev Override this as `_preExecCheck` used.\\n    /// @notice Target contracts this BaseACL controls.\\n    function contracts() public view virtual returns (address[] memory _contracts) {}\\n\\n    fallback() external virtual {\\n        revert(Errors.METHOD_NOT_ALLOW);\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"BaseAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"BaseOwnable.sol\\\";\\nimport \\\"Errors.sol\\\";\\nimport \\\"IAuthorizer.sol\\\";\\nimport \\\"IAccount.sol\\\";\\nimport \\\"IRoleManager.sol\\\";\\n\\n/// @title BaseAuthorizer - A basic pausable authorizer with caller restriction.\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev Base contract to extend to implement specific authorizer.\\nabstract contract BaseAuthorizer is IAuthorizer, BaseOwnable {\\n    /// @dev Override such constants while extending BaseAuthorizer.\\n\\n    bool public paused = false;\\n\\n    // Often used for off-chain system.\\n    // Each contract instance has its own value.\\n    bytes32 public tag = \\\"\\\";\\n\\n    // The caller which is able to call this contract's pre/postExecProcess\\n    // and pre/postExecCheck having side-effect.\\n    // It is usually the account or the parent authorizer(set) on higher level.\\n    address public caller;\\n\\n    // This is the account this authorizer works for.\\n    // Currently used to lookup `roleManager`.\\n    // If not used it is OK to keep it unset.\\n    address public account;\\n\\n    event CallerSet(address indexed caller);\\n    event AccountSet(address indexed account);\\n    event TagSet(bytes32 indexed tag);\\n    event PausedSet(bool indexed status);\\n\\n    constructor(address _owner, address _caller) BaseOwnable(_owner) {\\n        caller = _caller;\\n    }\\n\\n    function initialize(address _owner, address _caller) public {\\n        initialize(_owner);\\n        caller = _caller;\\n        emit CallerSet(_caller);\\n    }\\n\\n    function initialize(address _owner, address _caller, address _account) public {\\n        initialize(_owner, _caller);\\n        account = _account;\\n        emit AccountSet(_account);\\n    }\\n\\n    modifier onlyCaller() virtual {\\n        require(msg.sender == caller, Errors.INVALID_CALLER);\\n        _;\\n    }\\n\\n    /// @notice Change the caller.\\n    /// @param _caller the caller which calls the authorizer.\\n    function setCaller(address _caller) external onlyOwner {\\n        caller = _caller;\\n        emit CallerSet(_caller);\\n    }\\n\\n    /// @notice Change the account.\\n    /// @param _account the account which the authorizer get role manager from.\\n    function setAccount(address _account) external onlyOwner {\\n        account = _account;\\n        emit AccountSet(_account);\\n    }\\n\\n    /// @notice Change the tag for the contract instance.\\n    /// @dev For off-chain index.\\n    /// @param _tag the tag\\n    function setTag(bytes32 _tag) external onlyOwner {\\n        tag = _tag;\\n        emit TagSet(_tag);\\n    }\\n\\n    /// @notice Set the pause status. Authorizer just denies all when paused.\\n    /// @param _paused the paused status: true or false.\\n    function setPaused(bool _paused) external onlyOwner {\\n        paused = _paused;\\n        emit PausedSet(_paused);\\n    }\\n\\n    /// @notice Function check if a transaction can be executed.\\n    /// @param transaction Transaction data which contains from,to,value,data,delegate\\n    /// @return authData Return check status, error message and hint (if needed)\\n    function preExecCheck(\\n        TransactionData calldata transaction\\n    ) external virtual onlyCaller returns (AuthorizerReturnData memory authData) {\\n        if (paused) {\\n            authData.result = AuthResult.FAILED;\\n            authData.message = Errors.AUTHORIZER_PAUSED;\\n        } else {\\n            authData = _preExecCheck(transaction);\\n        }\\n    }\\n\\n    /// @notice Check after transaction execution.\\n    /// @param transaction Transaction data which contains from,to,value,data,delegate\\n    /// @param callResult Transaction call status and return data.\\n    function postExecCheck(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult,\\n        AuthorizerReturnData calldata preData\\n    ) external virtual onlyCaller returns (AuthorizerReturnData memory authData) {\\n        if (paused) {\\n            authData.result = AuthResult.FAILED;\\n            authData.message = Errors.AUTHORIZER_PAUSED;\\n        } else {\\n            authData = _postExecCheck(transaction, callResult, preData);\\n        }\\n    }\\n\\n    /// @dev Perform actions before the transaction execution.\\n    /// `onlyCaller` check forced here or attacker can call this directly\\n    /// to pollute our data.\\n    function preExecProcess(TransactionData calldata transaction) external virtual onlyCaller {\\n        if (!paused) _preExecProcess(transaction);\\n    }\\n\\n    /// @dev Perform actions after the transaction execution.\\n    /// `onlyCaller` check forced here or attacker can call this directly\\n    /// to pollute our data.\\n    function postExecProcess(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult\\n    ) external virtual onlyCaller {\\n        if (!paused) _postExecProcess(transaction, callResult);\\n    }\\n\\n    /// @dev Extract the roles of the delegate. If no roleManager set return empty lists.\\n    function _authenticate(TransactionData calldata transaction) internal view returns (bytes32[] memory roles) {\\n        return _authenticate(transaction.delegate);\\n    }\\n\\n    function _authenticate(address delegate) internal view returns (bytes32[] memory roles) {\\n        require(account != address(0), Errors.ACCOUNT_NOT_SET);\\n        address roleManager = IAccount(account).roleManager();\\n        require(roleManager != address(0), Errors.ROLE_MANAGER_NOT_SET);\\n        roles = IRoleManager(roleManager).getRoles(delegate);\\n    }\\n\\n    /// @dev Call `roleManager` to validate the role of delegate.\\n    function _hasRole(TransactionData calldata transaction, bytes32 role) internal view returns (bool) {\\n        return _hasRole(transaction.delegate, role);\\n    }\\n\\n    function _hasRole(address delegate, bytes32 role) internal view returns (bool) {\\n        require(account != address(0), Errors.ACCOUNT_NOT_SET);\\n        address roleManager = IAccount(account).roleManager();\\n        require(roleManager != address(0), Errors.ROLE_MANAGER_NOT_SET);\\n        return IRoleManager(roleManager).hasRole(delegate, role);\\n    }\\n\\n    /// @dev Override this to implement new authorization.\\n    ///      NOTE: If your check involves side-effect, onlyCaller should be used.\\n    function _preExecCheck(\\n        TransactionData calldata transaction\\n    ) internal virtual returns (AuthorizerReturnData memory authData) {}\\n\\n    /// @dev Override this to implement new authorization.\\n    function _postExecCheck(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult,\\n        AuthorizerReturnData calldata preData\\n    ) internal virtual returns (AuthorizerReturnData memory) {}\\n\\n    function _preExecProcess(TransactionData calldata transaction) internal virtual {}\\n\\n    function _postExecProcess(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult\\n    ) internal virtual {}\\n\\n    /// @dev Override this if you implement new type of authorizer.\\n    function TYPE() external view virtual returns (bytes32) {\\n        return AuthType.COMMON;\\n    }\\n}\\n\"\r\n    },\r\n    \"BaseOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"BaseVersion.sol\\\";\\n\\n/// @title BaseOwnable - Provides simple ownership access control.\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev Can be used in both proxy and non-proxy mode.\\nabstract contract BaseOwnable is BaseVersion {\\n    address public owner;\\n    address public pendingOwner;\\n    bool private initialized = false;\\n\\n    event PendingOwnerSet(address indexed to);\\n    event NewOwnerSet(address indexed owner);\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, Errors.CALLER_IS_NOT_OWNER);\\n        _;\\n    }\\n\\n    /// @dev `owner` is set by argument, thus the owner can any address.\\n    ///      When used in non-proxy mode, `initialize` can not be called\\n    ///      after deployment.\\n    constructor(address _owner) {\\n        initialize(_owner);\\n    }\\n\\n    /// @dev When used in proxy mode, `initialize` can be called by anyone\\n    ///      to claim the ownership.\\n    ///      This function can be called only once.\\n    function initialize(address _owner) public {\\n        require(!initialized, Errors.ALREADY_INITIALIZED);\\n        _setOwner(_owner);\\n        initialized = true;\\n    }\\n\\n    /// @notice User should ensure the corrent owner address set, or the\\n    ///         ownership may be transferred to blackhole. It is recommended to\\n    ///         take a safer way with setPendingOwner() + acceptOwner().\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"New Owner is zero\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @notice The original owner calls `setPendingOwner(newOwner)` and the new\\n    ///         owner calls `acceptOwner()` to take the ownership.\\n    function setPendingOwner(address to) external onlyOwner {\\n        pendingOwner = to;\\n        emit PendingOwnerSet(pendingOwner);\\n    }\\n\\n    function acceptOwner() external {\\n        require(msg.sender == pendingOwner);\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /// @notice Make the contract immutable.\\n    function renounceOwnership() external onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    // Internal functions\\n\\n    /// @dev Clear pendingOwner to prevent from reclaiming the ownership.\\n    function _setOwner(address _owner) internal {\\n        owner = _owner;\\n        pendingOwner = address(0);\\n        emit NewOwnerSet(owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/// @dev Common errors. This helps reducing the contract size.\\nlibrary Errors {\\n    // \\\"E1\\\";\\n\\n    // Call/Static-call failed.\\n    string constant CALL_FAILED = \\\"E2\\\";\\n\\n    // Argument's type not supported in View Variant.\\n    string constant INVALID_VIEW_ARG_SOL_TYPE = \\\"E3\\\";\\n\\n    // Invalid length for variant raw data.\\n    string constant INVALID_VARIANT_RAW_DATA = \\\"E4\\\";\\n\\n    // \\\"E5\\\";\\n\\n    // Invalid variant type.\\n    string constant INVALID_VAR_TYPE = \\\"E6\\\";\\n\\n    // Rule not exists\\n    string constant RULE_NOT_EXISTS = \\\"E7\\\";\\n\\n    // Variant name not found.\\n    string constant VAR_NAME_NOT_FOUND = \\\"E8\\\";\\n\\n    // Rule: v1/v2 solType mismatch\\n    string constant SOL_TYPE_MISMATCH = \\\"E9\\\";\\n\\n    // \\\"E10\\\";\\n\\n    // Invalid rule OP.\\n    string constant INVALID_RULE_OP = \\\"E11\\\";\\n\\n    //  \\\"E12\\\";\\n\\n    // \\\"E13\\\";\\n\\n    //  \\\"E14\\\";\\n\\n    // \\\"E15\\\";\\n\\n    // \\\"E16\\\";\\n\\n    // \\\"E17\\\";\\n\\n    // \\\"E18\\\";\\n\\n    // \\\"E19\\\";\\n\\n    // \\\"E20\\\";\\n\\n    // checkCmpOp: OP not support\\n    string constant CMP_OP_NOT_SUPPORT = \\\"E21\\\";\\n\\n    // checkBySolType: Invalid op for bool\\n    string constant INVALID_BOOL_OP = \\\"E22\\\";\\n\\n    // checkBySolType: Invalid op\\n    string constant CHECK_INVALID_OP = \\\"E23\\\";\\n\\n    // Invalid solidity type.\\n    string constant INVALID_SOL_TYPE = \\\"E24\\\";\\n\\n    // computeBySolType: invalid vm op\\n    string constant INVALID_VM_BOOL_OP = \\\"E25\\\";\\n\\n    // computeBySolType: invalid vm arith op\\n    string constant INVALID_VM_ARITH_OP = \\\"E26\\\";\\n\\n    // onlyCaller: Invalid caller\\n    string constant INVALID_CALLER = \\\"E27\\\";\\n\\n    // \\\"E28\\\";\\n\\n    // Side-effect is not allowed here.\\n    string constant SIDE_EFFECT_NOT_ALLOWED = \\\"E29\\\";\\n\\n    // Invalid variant count for the rule op.\\n    string constant INVALID_VAR_COUNT = \\\"E30\\\";\\n\\n    // extractCallData: Invalid op.\\n    string constant INVALID_EXTRACTOR_OP = \\\"E31\\\";\\n\\n    // extractCallData: Invalid array index.\\n    string constant INVALID_ARRAY_INDEX = \\\"E32\\\";\\n\\n    // extractCallData: No extract op.\\n    string constant NO_EXTRACT_OP = \\\"E33\\\";\\n\\n    // extractCallData: No extract path.\\n    string constant NO_EXTRACT_PATH = \\\"E34\\\";\\n\\n    // BaseOwnable: caller is not owner\\n    string constant CALLER_IS_NOT_OWNER = \\\"E35\\\";\\n\\n    // BaseOwnable: Already initialized\\n    string constant ALREADY_INITIALIZED = \\\"E36\\\";\\n\\n    // \\\"E37\\\";\\n\\n    // \\\"E38\\\";\\n\\n    // BaseACL: ACL check method should not return anything.\\n    string constant ACL_FUNC_RETURNS_NON_EMPTY = \\\"E39\\\";\\n\\n    // \\\"E40\\\";\\n\\n    // BaseAccount: Invalid delegate.\\n    string constant INVALID_DELEGATE = \\\"E41\\\";\\n\\n    // RootAuthorizer: delegateCallAuthorizer not set\\n    string constant DELEGATE_CALL_AUTH_NOT_SET = \\\"E42\\\";\\n\\n    // RootAuthorizer: callAuthorizer not set.\\n    string constant CALL_AUTH_NOT_SET = \\\"E43\\\";\\n\\n    // BaseAccount: Authorizer not set.\\n    string constant AUTHORIZER_NOT_SET = \\\"E44\\\";\\n\\n    // BaseAccount: Invalid authorizer flag.\\n    string constant INVALID_AUTHORIZER_FLAG = \\\"E45\\\";\\n\\n    // BaseAuthorizer: Authorizer paused.\\n    string constant AUTHORIZER_PAUSED = \\\"E46\\\";\\n\\n    // Authorizer set: Invalid hint.\\n    string constant INVALID_HINT = \\\"E47\\\";\\n\\n    // Authorizer set: All auth deny.\\n    string constant ALL_AUTH_FAILED = \\\"E48\\\";\\n\\n    // BaseACL: Method not allow.\\n    string constant METHOD_NOT_ALLOW = \\\"E49\\\";\\n\\n    // AuthorizerUnionSet: Invalid hint collected.\\n    string constant INVALID_HINT_COLLECTED = \\\"E50\\\";\\n\\n    // AuthorizerSet: Empty auth set\\n    string constant EMPTY_AUTH_SET = \\\"E51\\\";\\n\\n    // AuthorizerSet: hint not implement.\\n    string constant HINT_NOT_IMPLEMENT = \\\"E52\\\";\\n\\n    // RoleAuthorizer: Empty role set\\n    string constant EMPTY_ROLE_SET = \\\"E53\\\";\\n\\n    // RoleAuthorizer: No auth for the role\\n    string constant NO_AUTH_FOR_THE_ROLE = \\\"E54\\\";\\n\\n    // BaseACL: No in contract white list.\\n    string constant NOT_IN_CONTRACT_LIST = \\\"E55\\\";\\n\\n    // BaseACL: Same process not allowed to install twice.\\n    string constant SAME_PROCESS_TWICE = \\\"E56\\\";\\n\\n    // BaseAuthorizer: Account not set (then can not find roleManger)\\n    string constant ACCOUNT_NOT_SET = \\\"E57\\\";\\n\\n    // BaseAuthorizer: roleManger not set\\n    string constant ROLE_MANAGER_NOT_SET = \\\"E58\\\";\\n}\\n\"\r\n    },\r\n    \"BaseVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"IVersion.sol\\\";\\n\\n/// @title BaseVersion - Provides version information\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev\\n///    Implement NAME() and VERSION() methods according to IVersion interface.\\n///\\n///    Or just:\\n///      bytes32 public constant NAME = \\\"<Your contract name>\\\";\\n///      uint256 public constant VERSION = <Your contract version>;\\n///\\n///    Change the NAME when writing new kind of contract.\\n///    Change the VERSION when upgrading existing contract.\\nabstract contract BaseVersion is IVersion {\\n    /// @dev Convert to `string` which looks prettier on Etherscan viewer.\\n    function _NAME() external view virtual returns (string memory) {\\n        return string(abi.encodePacked(this.NAME()));\\n    }\\n}\\n\"\r\n    },\r\n    \"IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IVersion {\\n    function NAME() external view returns (bytes32 name);\\n\\n    function VERSION() external view returns (uint256 version);\\n}\\n\"\r\n    },\r\n    \"IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Types.sol\\\";\\n\\ninterface IAuthorizer {\\n    function flag() external view returns (uint256 authFlags);\\n\\n    function setCaller(address _caller) external;\\n\\n    function preExecCheck(TransactionData calldata transaction) external returns (AuthorizerReturnData memory authData);\\n\\n    function postExecCheck(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult,\\n        AuthorizerReturnData calldata preAuthData\\n    ) external returns (AuthorizerReturnData memory authData);\\n\\n    function preExecProcess(TransactionData calldata transaction) external;\\n\\n    function postExecProcess(TransactionData calldata transaction, TransactionResult calldata callResult) external;\\n}\\n\\ninterface IAuthorizerSupportingHint is IAuthorizer {\\n    // When IAuthorizer(auth).flag().supportHint() == true;\\n    function collectHint(\\n        AuthorizerReturnData calldata preAuthData,\\n        AuthorizerReturnData calldata postAuthData\\n    ) external view returns (bytes memory hint);\\n}\\n\"\r\n    },\r\n    \"Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nenum AuthResult {\\n    FAILED,\\n    SUCCESS\\n}\\n\\nstruct CallData {\\n    uint256 flag; // 0x1 delegate call, 0x0 call.\\n    address to;\\n    uint256 value;\\n    bytes data; // calldata\\n    bytes hint;\\n    bytes extra; // for future support: signatures etc.\\n}\\n\\nstruct TransactionData {\\n    address from; // Sender who performs the transaction a.k.a wallet address.\\n    address delegate; // Delegate who calls executeTransactions().\\n    // Same as CallData\\n    uint256 flag; // 0x1 delegate call, 0x0 call.\\n    address to;\\n    uint256 value;\\n    bytes data; // calldata\\n    bytes hint;\\n    bytes extra;\\n}\\n\\nstruct AuthorizerReturnData {\\n    AuthResult result;\\n    string message;\\n    bytes data; // Authorizer return data. usually used for hint purpose.\\n}\\n\\nstruct TransactionResult {\\n    bool success; // Call status.\\n    bytes data; // Return/Revert data.\\n    bytes hint;\\n}\\n\\nlibrary TxFlags {\\n    uint256 internal constant DELEGATE_CALL_MASK = 0x1; // 1 for delegatecall, 0 for call\\n\\n    function isDelegateCall(uint256 flag) internal pure returns (bool) {\\n        return flag & DELEGATE_CALL_MASK == DELEGATE_CALL_MASK;\\n    }\\n}\\n\\nlibrary VarName {\\n    bytes5 internal constant TEMP = \\\"temp.\\\";\\n\\n    function isTemp(bytes32 name) internal pure returns (bool) {\\n        return bytes5(name) == TEMP;\\n    }\\n}\\n\\nlibrary AuthType {\\n    bytes32 internal constant FUNC = \\\"FunctionType\\\";\\n    bytes32 internal constant TRANSFER = \\\"TransferType\\\";\\n    bytes32 internal constant DEX = \\\"DexType\\\";\\n    bytes32 internal constant LENDING = \\\"LendingType\\\";\\n    bytes32 internal constant COMMON = \\\"CommonType\\\";\\n    bytes32 internal constant SET = \\\"SetType\\\";\\n    bytes32 internal constant VM = \\\"VM\\\";\\n}\\n\\nlibrary AuthFlags {\\n    uint256 internal constant HAS_PRE_CHECK_MASK = 0x1;\\n    uint256 internal constant HAS_POST_CHECK_MASK = 0x2;\\n    uint256 internal constant HAS_PRE_PROC_MASK = 0x4;\\n    uint256 internal constant HAS_POST_PROC_MASK = 0x8;\\n\\n    uint256 internal constant SUPPORT_HINT_MASK = 0x40;\\n\\n    uint256 internal constant FULL_MODE =\\n        HAS_PRE_CHECK_MASK | HAS_POST_CHECK_MASK | HAS_PRE_PROC_MASK | HAS_POST_PROC_MASK;\\n\\n    function isValid(uint256 flag) internal pure returns (bool) {\\n        // At least one check handler is activated.\\n        return hasPreCheck(flag) || hasPostCheck(flag);\\n    }\\n\\n    function hasPreCheck(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_PRE_CHECK_MASK == HAS_PRE_CHECK_MASK;\\n    }\\n\\n    function hasPostCheck(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_POST_CHECK_MASK == HAS_POST_CHECK_MASK;\\n    }\\n\\n    function hasPreProcess(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_PRE_PROC_MASK == HAS_PRE_PROC_MASK;\\n    }\\n\\n    function hasPostProcess(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_POST_PROC_MASK == HAS_POST_PROC_MASK;\\n    }\\n\\n    function supportHint(uint256 flag) internal pure returns (bool) {\\n        return flag & SUPPORT_HINT_MASK == SUPPORT_HINT_MASK;\\n    }\\n}\\n\\n// For Rule VM.\\n\\n// For each VariantType, an extractor should be implement.\\nenum VariantType {\\n    INVALID, // Mark for delete.\\n    EXTRACT_CALLDATA, // extract calldata by path bytes.\\n    NAME, // name for user-defined variant.\\n    RAW, // encoded solidity values.\\n    VIEW, // staticcall view non-side-effect function and get return value.\\n    CALL, // call state changing function and get returned value.\\n    RULE, // rule expression.\\n    ANY\\n}\\n\\n// How the data should be decoded.\\nenum SolidityType {\\n    _invalid, // Mark for delete.\\n    _any,\\n    _bytes,\\n    _bool,\\n    ///// START 1\\n    ///// Generated by gen_rulelib.py (start)\\n    _address,\\n    _uint256,\\n    _int256,\\n    ///// Generated by gen_rulelib.py (end)\\n    ///// END 1\\n    _end\\n}\\n\\n// A common operand in rule.\\nstruct Variant {\\n    VariantType varType;\\n    SolidityType solType;\\n    bytes data;\\n}\\n\\n// OpCode for rule expression which returns v0.\\nenum OP {\\n    INVALID,\\n    // One opnd.\\n    VAR, // v1\\n    NOT, // !v1\\n    // Two opnds.\\n    // checkBySolType() which returns boolean.\\n    EQ, // v1 == v2\\n    NE, // v1 != v2\\n    GT, // v1 > v2\\n    GE, // v1 >= v2\\n    LT, // v1 < v2\\n    LE, // v1 <= v2\\n    IN, // v1 in [...]\\n    NOTIN, // v1 not in [...]\\n    // computeBySolType() which returns bytes (with same solType)\\n    AND, // v1 & v2\\n    OR, // v1 | v2\\n    ADD, // v1 + v2\\n    SUB, // v1 - v2\\n    MUL, // v1 * v2\\n    DIV, // v1 / v2\\n    MOD, // v1 % v2\\n    // Three opnds.\\n    IF, // v1? v2: v3\\n    // Side-effect ones.\\n    ASSIGN, // v1 := v2\\n    VM, // rule list bytes.\\n    NOP // as end.\\n}\\n\\nstruct Rule {\\n    OP op;\\n    Variant[] vars;\\n}\\n\"\r\n    },\r\n    \"IAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Types.sol\\\";\\n\\ninterface IAccount {\\n    /// @notice Call Gnosis Safe to execute a transaction\\n    /// @dev Delegates can call this method to invoke gnosis safe to forward to\\n    ///      transaction to target contract\\n    ///      The function can only be called by delegates.\\n    /// @param callData The callData  to be called by Gnosis Safe\\n    function execTransaction(CallData calldata callData) external returns (TransactionResult memory result);\\n\\n    function execTransactions(\\n        CallData[] calldata callDataList\\n    ) external returns (TransactionResult[] memory resultList);\\n\\n    function setAuthorizer(address _authorizer) external;\\n\\n    function setRoleManager(address _roleManager) external;\\n\\n    function addDelegate(address _delegate) external;\\n\\n    function addDelegates(address[] calldata _delegates) external;\\n\\n    /// @dev Sub instance should override this to set `from` for transaction\\n    /// @return account The address for the contract wallet, also the\\n    ///         `msg.sender` address which send the transaction.\\n    function getAccountAddress() external view returns (address account);\\n\\n    function roleManager() external view returns (address _roleManager);\\n\\n    function authorizer() external view returns (address _authorizer);\\n}\\n\"\r\n    },\r\n    \"IRoleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Types.sol\\\";\\n\\ninterface IRoleManager {\\n    function getRoles(address delegate) external view returns (bytes32[] memory);\\n\\n    function hasRole(address delegate, bytes32 role) external view returns (bool);\\n}\\n\\ninterface IFlatRoleManager is IRoleManager {\\n    function addRoles(bytes32[] calldata roles) external;\\n\\n    function grantRoles(bytes32[] calldata roles, address[] calldata delegates) external;\\n\\n    function revokeRoles(bytes32[] calldata roles, address[] calldata delegates) external;\\n\\n    function getDelegates() external view returns (address[] memory);\\n\\n    function getAllRoles() external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"IStargateFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IStargateFactory {\\n    function getPool(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"StargateAddressUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nfunction getAddresses() returns (address stakingPool, address router, address factory) {\\n    uint256 chainId = block.chainid;\\n    if (chainId == 1) {\\n        stakingPool = 0xB0D502E938ed5f4df2E681fE6E419ff29631d62b;\\n        router = 0x8731d54E9D02c286767d56ac03e8037C07e01e98;\\n        factory = 0x06D538690AF257Da524f25D0CD52fD85b1c2173E;\\n    } else if (chainId == 56) {\\n        stakingPool = 0x3052A0F6ab15b4AE1df39962d5DdEFacA86DaB47;\\n        router = 0x4a364f8c717cAAD9A442737Eb7b8A55cc6cf18D8;\\n        factory = 0xe7Ec689f432f29383f217e36e680B5C855051f25;\\n    } else if (chainId == 43114) {\\n        stakingPool = 0x8731d54E9D02c286767d56ac03e8037C07e01e98;\\n        router = 0x45A01E4e04F14f7A4a6702c74187c5F6222033cd;\\n        factory = 0x808d7c71ad2ba3FA531b068a2417C63106BC0949;\\n    } else if (chainId == 137) {\\n        stakingPool = 0x8731d54E9D02c286767d56ac03e8037C07e01e98;\\n        router = 0x45A01E4e04F14f7A4a6702c74187c5F6222033cd;\\n        factory = 0x808d7c71ad2ba3FA531b068a2417C63106BC0949;\\n    } else if (chainId == 42161) {\\n        stakingPool = 0xeA8DfEE1898a7e0a59f7527F076106d7e44c2176;\\n        router = 0x53Bf833A5d6c4ddA888F69c22C88C9f356a41614;\\n        factory = 0x55bDb4164D28FBaF0898e0eF14a589ac09Ac9970;\\n    } else if (chainId == 10) {\\n        stakingPool = 0x4DeA9e918c6289a52cd469cAC652727B7b412Cd2;\\n        router = 0xB0D502E938ed5f4df2E681fE6E419ff29631d62b;\\n        factory = 0xE3B53AF74a4BF62Ae5511055290838050bf764Df;\\n    } else if (chainId == 250) {\\n        stakingPool = 0x224D8Fd7aB6AD4c6eb4611Ce56EF35Dec2277F03;\\n        router = 0xAf5191B0De278C7286d6C7CC6ab6BB8A73bA2Cd6;\\n        factory = 0x9d1B1669c73b033DFe47ae5a0164Ab96df25B944;\\n    } else {\\n        revert(\\\"no chain id is matched\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"StargateDepositAuthorizer.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddPoolAddressWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddPoolIdWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"PausedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PendingOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovePoolAddressWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovePoolIdWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tag\",\"type\":\"bytes32\"}],\"name\":\"TagSet\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TYPE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"account\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_poolAddresses\",\"type\":\"address[]\"}],\"name\":\"addPoolAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"}],\"name\":\"addPoolIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"caller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolAddressWhiteList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolIdWhiteList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionData\",\"name\":\"transaction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionResult\",\"name\":\"callResult\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum AuthResult\",\"name\":\"result\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct AuthorizerReturnData\",\"name\":\"preData\",\"type\":\"tuple\"}],\"name\":\"postExecCheck\",\"outputs\":[{\"components\":[{\"internalType\":\"enum AuthResult\",\"name\":\"result\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct AuthorizerReturnData\",\"name\":\"authData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionData\",\"name\":\"transaction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionResult\",\"name\":\"callResult\",\"type\":\"tuple\"}],\"name\":\"postExecProcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionData\",\"name\":\"transaction\",\"type\":\"tuple\"}],\"name\":\"preExecCheck\",\"outputs\":[{\"components\":[{\"internalType\":\"enum AuthResult\",\"name\":\"result\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct AuthorizerReturnData\",\"name\":\"authData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionData\",\"name\":\"transaction\",\"type\":\"tuple\"}],\"name\":\"preExecProcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_poolAddresses\",\"type\":\"address[]\"}],\"name\":\"removePoolAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"}],\"name\":\"removePoolIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"setCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tag\",\"type\":\"bytes32\"}],\"name\":\"setTag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tag\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StargateDepositAuthorizer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000089635b6dc339ff219c53ef8a7c53af3368decabb00000000000000000000000089635b6dc339ff219c53ef8a7c53af3368decabb", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}