{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AquaStrategy.sol\": {\r\n      \"content\": \"pragma solidity 0.8.15;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n}\\n\\ninterface IERC20 {\\n   \\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\\n\\nlibrary Address {\\n   \\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + (value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance =\\n            token.allowance(address(this), spender) - (value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\nabstract contract ReentrancyGuard {\\n   \\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ninterface IWBNB is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\\ninterface IToken {\\n    function totalSupply() external view returns(uint);\\n}\\n\\ninterface GammaTroller {\\n    function claimGamma(address[] memory holders,address[] memory gTokens,bool borrowers,bool suppliers) external ;\\n    function gammaAccrued(address holder) external view returns(uint256);\\n}\\n\\ninterface Gtoken {\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n}\\n\\nabstract contract StratX2 is Ownable, ReentrancyGuard {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address public wantAddress;\\n    address public rewardsAddress;\\n    address public feeRewardsUpdater;\\n\\n    address public wbnbAddress;\\n    address public gammaFarmAddress;\\n    address public GAMMAAddress;\\n    address public AQUAAddress;\\n    address public iAquaAddress;\\n    address public gammaTrollerAddress;\\n\\n    uint256 public feeRewardsAccruedPerWeek;\\n    uint256 public feeRewardsAccrued;\\n    \\n    uint256 public wantLockedTotal;\\n    uint256 public constant initialExchangeRate = 1e8;\\n   \\n    uint256 public entranceFeeFactor; \\n    uint256 public constant entranceFeeFactorMax = 50; // 0.5% is the max entrance fee settable.\\n\\n    uint256 public withdrawFeeFactor = 100;\\n    uint256 public constant withdrawFeeFactorMax = 200; // 2% is the max withdraw fee settable. \\n\\n    uint256 public instantWithdrawFeeFactor = 500; // 5%;\\n    uint256 public constant instantWithdrawFeeMaxFactor = 1000; //10%\\n\\n    event SetSettings(uint256 _entranceFeeFactor, uint256 _withdrawFeeFactor, uint256 _instantWithdrawFeeFactor);\\n    event SetRewardsAddress(address _rewardsAddress);\\n    \\n    error Unauthorized(address caller);\\n\\n    function checkForFarmAddressCall() private view  {\\n        if(msg.sender != gammaFarmAddress) \\n        {\\n            revert Unauthorized(msg.sender);\\n        }\\n    }\\n\\n    function getUserGtokenBal(address _user) external view returns (uint256 gAQUABalance){\\n        gAQUABalance = (IERC20(iAquaAddress).balanceOf(_user) * iTokenExchangeRate())/1e18;\\n    }\\n\\n    // Receives new deposits from user\\n    function deposit(uint256 _wantAmt) external virtual nonReentrant returns (uint256) {\\n        checkForFarmAddressCall();\\n\\n        uint256 balBefore = IERC20(wantAddress).balanceOf(address(this));\\n        IERC20(AQUAAddress).safeIncreaseAllowance(wantAddress, _wantAmt);\\n        Gtoken(wantAddress).mint(_wantAmt);\\n        uint256 depositAmount = IERC20(wantAddress).balanceOf(address(this)) - balBefore;\\n\\n        uint256 depositFee = (depositAmount* entranceFeeFactor)/ 10000;\\n        if(depositFee != 0){\\n            depositAmount = depositAmount - depositFee;\\n            IERC20(wantAddress).safeTransfer(rewardsAddress, depositFee);\\n        }\\n        \\n        // exchange rate should be calcualted before updating wantLockedTotal so that new user gets same exchange rate as existing users\\n        uint current_exchange_rate = iTokenExchangeRate();\\n        uint256 mintAmount = (depositAmount * 1e18) / current_exchange_rate;\\n\\n        wantLockedTotal = wantLockedTotal + depositAmount;\\n        \\n        return (mintAmount);\\n    }\\n\\n  \\n    function unstake(uint256 _wantAmt, bool instantly) external virtual nonReentrant returns (uint256, uint256) {\\n        checkForFarmAddressCall();\\n\\n        if (wantLockedTotal < _wantAmt) {\\n            _wantAmt = wantLockedTotal;\\n        }\\n\\n        uint256 balanceOfStrat = IERC20(wantAddress).balanceOf(address(this));\\n        if (_wantAmt > balanceOfStrat) {\\n            _wantAmt = balanceOfStrat;\\n        }\\n        \\n        uint256 stratWantTokensRemoved = _wantAmt;\\n        uint256 withdrawFee;\\n        uint256 withdrawAmount;\\n        uint256 feeFactor = withdrawFeeFactor;\\n\\n        if(instantly) {\\n            feeFactor = instantWithdrawFeeFactor;\\n        }\\n        \\n        if (_wantAmt != 0) {\\n            withdrawFee = (_wantAmt * feeFactor) / 10000;\\n            _wantAmt = _wantAmt - withdrawFee;\\n            withdrawFee = withdrawFee/2;\\n            wantLockedTotal = wantLockedTotal - _wantAmt - withdrawFee;\\n            IERC20(wantAddress).safeTransfer(rewardsAddress, withdrawFee);\\n        \\n            feeRewardsAccrued += withdrawFee;\\n\\n            uint256 balBefore = IERC20(AQUAAddress).balanceOf(address(this));\\n            Gtoken(wantAddress).redeem(_wantAmt);\\n            withdrawAmount = IERC20(AQUAAddress).balanceOf(address(this)) - balBefore;\\n            \\n            IERC20(AQUAAddress).safeTransfer(gammaFarmAddress, withdrawAmount);\\n        }\\n        return (withdrawAmount, stratWantTokensRemoved);\\n    }\\n\\n    function getShares() external virtual view returns (uint256, uint256) {\\n        return (wantLockedTotal, IToken(iAquaAddress).totalSupply());\\n    }\\n\\n    function sharesTotal() external virtual view returns (uint256) {\\n        return IToken(iAquaAddress).totalSupply();\\n    }\\n\\n    function getStratPendingRewards() external virtual view returns (uint256) {\\n        return (GammaTroller(gammaTrollerAddress).gammaAccrued(address(this)));\\n    }\\n\\n    function setSettings(uint256 _entranceFeeFactor, uint256 _withdrawFeeFactor, uint256 _instantWithdrawFeeFactor) external virtual onlyOwner {\\n\\n        require(_entranceFeeFactor <= entranceFeeFactorMax, \\\"_entranceFeeFactor too high\\\");\\n        entranceFeeFactor = _entranceFeeFactor;\\n\\n        require(_withdrawFeeFactor <= withdrawFeeFactorMax, \\\"_withdrawFeeFactor too high\\\");\\n        withdrawFeeFactor = _withdrawFeeFactor;\\n\\n        require(_instantWithdrawFeeFactor <= instantWithdrawFeeMaxFactor, \\\"_instantWithdrawFeeFactor too high\\\");\\n        instantWithdrawFeeFactor = _instantWithdrawFeeFactor;\\n\\n        emit SetSettings(_entranceFeeFactor, _withdrawFeeFactor, _instantWithdrawFeeFactor);\\n\\n    }\\n\\n    function setRewardsAddress(address _rewardsAddress) external virtual onlyOwner {\\n        rewardsAddress = _rewardsAddress;\\n        emit SetRewardsAddress(_rewardsAddress);\\n    }\\n\\n    /**\\n    * @notice this will change fee rewards updater address\\n    *         in the contract it is called by owner address only\\n    */\\n    function changeFeeRewardsUpdater(address _newFeeRewardsUpdater) external onlyOwner {\\n        feeRewardsUpdater = _newFeeRewardsUpdater;\\n    }\\n\\n    /**\\n    * @notice this will update feeRewardsAccruedPerWeek value\\n    *         in the contract it is called by feeRewardsUpdater address only\\n    */\\n    function updateFeeRewards() external {\\n        require(_msgSender()  == feeRewardsUpdater,\\\"Caller is not fee rewards updater\\\");\\n        if(feeRewardsAccrued > 0){\\n            feeRewardsAccruedPerWeek = feeRewardsAccrued;\\n            feeRewardsAccrued = 0;\\n        }\\n    }\\n\\n    function changeGammaTrollerAddress(address _gammatrollerAddress) external onlyOwner {\\n        gammaTrollerAddress = _gammatrollerAddress;\\n    }\\n    \\n     function inCaseTokensGetStuck(address _token) external onlyOwner {\\n        require(_token != address(wantAddress), \\\"Token cannot be same as deposit token\\\");\\n        require(_token != GAMMAAddress, \\\"Token cannot be same as gamma token\\\");\\n        uint256 amount = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(_msgSender(), amount);\\n    }  \\n\\n    function _wrapBNB() internal virtual {\\n        // BNB -> WBNB\\n        uint256 bnbBal = address(this).balance;\\n        if (bnbBal != 0) {\\n            IWBNB(wbnbAddress).deposit{value: bnbBal}(); // BNB -> WBNB\\n        }\\n    }\\n\\n    function wrapBNB() external virtual onlyOwner {\\n        _wrapBNB();\\n    }\\n\\n    /**\\n    * @notice Calculates the exchange rate from the gToken to the iToken\\n    * @return (calculated exchange rate scaled by 1e18)\\n    */\\n    function iTokenExchangeRate() public view returns (uint) {\\n        uint256 _totalSupply = IToken(iAquaAddress).totalSupply();\\n        if (_totalSupply == 0) {\\n           /**\\n            * If there are no iTokens minted:\\n            *  exchangeRate = initialExchangeRate\\n            */\\n            return (initialExchangeRate); //1e8\\n        } else { \\n            return ((wantLockedTotal * 1e18) / _totalSupply);\\n        }\\n    }\\n\\n    function earnGammaProfits() external returns (uint256){\\n        checkForFarmAddressCall();\\n        if(wantLockedTotal == 0){\\n            return 0;\\n        }\\n        claimPendingGamma();\\n        uint256 earned = IERC20(GAMMAAddress).balanceOf(address(this));\\n        \\n        if(earned != 0){\\n            IERC20(GAMMAAddress).safeTransfer(address(msg.sender), earned);\\n        }    \\n\\t    return earned;\\n    }\\n\\n    function claimPendingGamma() internal {\\n        \\n        address[] memory holders = new address[](1);\\n        holders[0] = address(this);\\n\\n        address[] memory gTokens = new address[](1);\\n        gTokens[0] = address(wantAddress);\\n\\n        GammaTroller(gammaTrollerAddress).claimGamma(holders,gTokens, false, true);        \\n    }\\n}\\n\\ncontract AquaStrategy_GAMMA is StratX2 {\\n    \\n    constructor(\\n        address[] memory _addresses,\\n        uint256 _entranceFeeFactor,\\n        uint256 _withdrawFeeFactor,\\n        uint256 _instantWithdrawFeeFactor\\n    ) {\\n        wbnbAddress = _addresses[0];\\n        gammaFarmAddress = _addresses[1];\\n        GAMMAAddress = _addresses[2];\\n        AQUAAddress = _addresses[3];\\n        wantAddress = _addresses[4];\\n        iAquaAddress = _addresses[5];\\n        gammaTrollerAddress = _addresses[6];\\n        rewardsAddress = _addresses[7];\\n\\tfeeRewardsUpdater = _addresses[8];\\n\\n        \\n        entranceFeeFactor = _entranceFeeFactor;\\n        withdrawFeeFactor = _withdrawFeeFactor;\\n        instantWithdrawFeeFactor = _instantWithdrawFeeFactor;\\n\\n        //transferOwnership(gammaFarmAddress);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_entranceFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instantWithdrawFeeFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_rewardsAddress\",\"type\":\"address\"}],\"name\":\"SetRewardsAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_entranceFeeFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_instantWithdrawFeeFactor\",\"type\":\"uint256\"}],\"name\":\"SetSettings\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AQUAAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAMMAAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeRewardsUpdater\",\"type\":\"address\"}],\"name\":\"changeFeeRewardsUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gammatrollerAddress\",\"type\":\"address\"}],\"name\":\"changeGammaTrollerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wantAmt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnGammaProfits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entranceFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entranceFeeFactorMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardsAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardsAccruedPerWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardsUpdater\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gammaFarmAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gammaTrollerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStratPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserGtokenBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gAQUABalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iAquaAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iTokenExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"inCaseTokensGetStuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantWithdrawFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantWithdrawFeeMaxFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsAddress\",\"type\":\"address\"}],\"name\":\"setRewardsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_entranceFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instantWithdrawFeeFactor\",\"type\":\"uint256\"}],\"name\":\"setSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sharesTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wantAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"instantly\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFeeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wantAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wantLockedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnbAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeFactorMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AquaStrategy_GAMMA", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000009000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000b68a5caff818878e355cf622bd65a73bb2936301000000000000000000000000b3cb6d2f8f2fde203a022201c81a96c167607f1500000000000000000000000072b7d61e8fc8cf971960dd9cfa59b8c829d919910000000000000000000000002f5d7a9d8d32c16e41af811744db9f15d853e0a50000000000000000000000002b54226d62cbddc0fcd4ce8266de88a3b666f46f0000000000000000000000001e0c9d09f9995b95ec4175aaa18b49f49f6165a3000000000000000000000000ac88bd12c992b1adbb43183a0aa5e3fa5ae3e5ee000000000000000000000000fbb8d3ace23f822a412ac6f150e75ec8d29e51f8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}