{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n\r\n    function _checkOwner(address sender) external view returns (bool);\r\n}\r\n\r\ncontract ContractToken {\r\n    struct Sell {\r\n        uint256 fundFee;\r\n        uint256 wardFee;\r\n    }\r\n    struct ForSale {\r\n        uint256 start;\r\n        uint256 end;\r\n    }\r\n    struct UserCard {\r\n        uint256 amount;\r\n        uint256 cardNumber;\r\n        uint256 splitTimestamp;\r\n        uint256 picId;\r\n        uint256 mark;\r\n        uint256 transferIndex;\r\n    }\r\n    struct ReckonDetail {\r\n        uint256 total;\r\n        uint256 residue;\r\n        uint256 obtainTimestamp;\r\n        uint256 timestamp;\r\n    }\r\n    struct Reckon {\r\n        uint256 total;\r\n        uint256 released;\r\n        ReckonDetail[] reckonDetail;\r\n    }\r\n    struct UserInfo {\r\n        address senior;\r\n        UserCard[] userCardList;\r\n        Reckon reckon;\r\n        uint256 minion;\r\n        address team;\r\n        Kickback[] kickback;\r\n        uint256 kickbackTotal;\r\n    }\r\n    struct TransferMarket {\r\n        address owner;\r\n        uint256 amount;\r\n        uint256 cardNumber;\r\n        uint256 timestamp;\r\n        uint256 picId;\r\n        uint256 ownerIndex;\r\n    }\r\n    struct Kickback {\r\n        address owner;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    struct BlindBox {\r\n        uint256 amount;\r\n        uint256 multiple;\r\n        uint256 computing;\r\n        uint256 timestamp;\r\n    }\r\n    struct NowSell {\r\n        uint256 cardNumber;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 fee;\r\n        uint256 funFee;\r\n        uint256 ownerFee;\r\n    }\r\n    struct NowSellTotal {\r\n        uint256 size;\r\n        uint256 amount;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(\r\n            Owner == msg.sender || ownable._checkOwner(msg.sender),\r\n            \"Ownable: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n    IOwnable ownable;\r\n    address private Owner;\r\n    IERC20 feeToken;\r\n    address private  fundAddress;\r\n    Sell public sell;\r\n    uint256 public fixRise;\r\n    uint256 private  constant baseTimestamp = 1703865600;\r\n    uint256 private constant secondsInDay = 24 * 60 * 60;\r\n    ForSale public forSale;\r\n    uint256 public constant nftTotal = 1000;\r\n    uint256 public issuedTotal;\r\n    uint256 public issuedNoPuy;\r\n    uint256 public issuePrice;\r\n    uint256 public issueUsdtTotal;\r\n    IERC20 usdtToken;\r\n    uint256[] private nftPicId;\r\n    ISwapRouter private router;\r\n    uint256 public cardNumber;\r\n    mapping(address => UserInfo) userInfoList;\r\n    bool public lock;\r\n    TransferMarket[] public transferMarketList;\r\n    uint256 public size = 5;\r\n    mapping(uint256 => bool) transferMarketListMap;\r\n    bool private marketLock;\r\n    uint256 public factorPrice;\r\n    uint256 private fraction = 5;\r\n    uint256 public boxPrice;\r\n    address[] private blindBoxAddress;\r\n    mapping(address => bool) blindBoxMap;\r\n    BlindBox[] private blindBoxList;\r\n    mapping(uint256 => NowSell[]) NowSellMap;\r\n    mapping(uint256 => NowSellTotal) NowSellTotalMap;\r\n    modifier MarketLock() {\r\n        marketLock = true;\r\n        _;\r\n        marketLock = false;\r\n    }\r\n\r\n    constructor() {\r\n        ownable = IOwnable(0x3012AD0d396e3cA7c4518684F8e6e1b19761cE54);\r\n        Owner = msg.sender;\r\n        feeToken = IERC20(0x08801120Ab610F42Eaa5c573112EEc68C19cbD9c);\r\n        fundAddress = 0x1EA677cA58eEaC6C1A9bfDa82f8270FD34D32Cd8;\r\n        sell = Sell(200, 100);\r\n        fixRise = 500;\r\n        forSale = ForSale(17, 14);\r\n        IERC20 IUsdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        usdtToken = IUsdt;\r\n        issuePrice = 100 * 10**IUsdt.decimals();\r\n        nftPicId.push(1);\r\n        nftPicId.push(2);\r\n        nftPicId.push(3);\r\n        nftPicId.push(4);\r\n        nftPicId.push(5);\r\n        router = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        factorPrice = 1000 * 10**IUsdt.decimals();\r\n        boxPrice = 500 * 10**IUsdt.decimals();\r\n    }\r\n\r\n    function snapshotSenior(\r\n        address[] memory adrList,\r\n        address[] memory seniorList\r\n    ) external virtual onlyOwner {\r\n        require(adrList.length == seniorList.length, \"lnconsistent length\");\r\n        for (uint256 i = 0; i < adrList.length; i++) {\r\n            UserInfo storage userinfo = userInfoList[adrList[i]];\r\n            userinfo.team = userInfoList[seniorList[i]].team;\r\n            userInfoList[seniorList[i]].minion =\r\n                userInfoList[seniorList[i]].minion +\r\n                1;\r\n            userinfo.senior = seniorList[i];\r\n        }\r\n    }\r\n\r\n    function snapshotCard(address[] memory adrList) external virtual onlyOwner {\r\n        uint256 length = adrList.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            UserCard[] storage userCardList = userInfoList[adrList[i]]\r\n                .userCardList;\r\n            userCardList.push(\r\n                UserCard(\r\n                    issuePrice,\r\n                    cardNumber + 1 + i,\r\n                    0,\r\n                    getRandomString(i),\r\n                    0,\r\n                    0\r\n                )\r\n            );\r\n        }\r\n        cardNumber = cardNumber + length;\r\n    }\r\n\r\n    function snapshotSell(\r\n        address[] memory adrList,\r\n        uint256[] memory indexList,\r\n        uint256[] memory boolList\r\n    ) external virtual onlyOwner {\r\n        require(\r\n            adrList.length == indexList.length &&\r\n                adrList.length == boolList.length,\r\n            \"lnconsistent length\"\r\n        );\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < adrList.length; i++) {\r\n            UserCard[] storage userCardList = userInfoList[adrList[i]]\r\n                .userCardList;\r\n            UserCard storage userCard = userCardList[indexList[i]];\r\n            userCard.mark = 1;\r\n            uint256 marketLength = transferMarketList.length;\r\n            userCard.transferIndex = marketLength;\r\n            uint256 amount = userCard.amount +\r\n                ((userCard.amount * fixRise) / 10000);\r\n            uint256 cardNumber_ = userCard.cardNumber;\r\n            if (boolList[i] == 1) {\r\n                cardNumber_ = cardNumber + count + 1;\r\n                count++;\r\n            }\r\n            transferMarketList.push(\r\n                TransferMarket(\r\n                    adrList[i],\r\n                    amount,\r\n                    cardNumber_,\r\n                    getCurrentBlockTimestamp(),\r\n                    userCard.picId,\r\n                    indexList[i]\r\n                )\r\n            );\r\n        }\r\n        cardNumber = cardNumber + count;\r\n        issuedTotal = cardNumber;\r\n        issueUsdtTotal = cardNumber * issuePrice;\r\n    }\r\n\r\n    function snapshotPuy(address[] memory adrList, uint256[] memory indexList)\r\n        external\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(adrList.length == indexList.length, \"lnconsistent length\");\r\n        for (uint256 i = 0; i < adrList.length; i++) {\r\n            TransferMarket storage transferMarket = transferMarketList[\r\n                indexList[i]\r\n            ];\r\n            userInfoList[adrList[i]].userCardList.push(\r\n                UserCard(\r\n                    transferMarket.amount,\r\n                    transferMarket.cardNumber,\r\n                    0,\r\n                    transferMarket.picId,\r\n                    0,\r\n                    0\r\n                )\r\n            );\r\n            transferMarketListMap[transferMarket.cardNumber] = true;\r\n            UserCard storage ownerUserCard = userInfoList[transferMarket.owner]\r\n                .userCardList[transferMarket.ownerIndex];\r\n            ownerUserCard.mark = 2;\r\n            ownerUserCard.transferIndex = 0;\r\n            delete transferMarketList[indexList[i]];\r\n        }\r\n    }\r\n\r\n    function getTeam(address adr)\r\n        public\r\n        view\r\n        returns (\r\n            address team,\r\n            address senior,\r\n            uint256 minion\r\n        )\r\n    {\r\n        UserInfo memory userInfo = userInfoList[adr];\r\n        team = userInfo.team;\r\n        senior = userInfo.senior;\r\n        minion = userInfo.minion;\r\n        return (team, senior, minion);\r\n    }\r\n\r\n    function getUserInfo(address adr)\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (\r\n            uint256 minion,\r\n            address team,\r\n            uint256 kickbackTotal\r\n        )\r\n    {\r\n        UserInfo memory userInfo = userInfoList[adr];\r\n        minion = userInfo.minion;\r\n        team = userInfo.team;\r\n        kickbackTotal = userInfo.kickbackTotal;\r\n    }\r\n\r\n    function getNowSellMap(uint256 page, uint256 size_)\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (NowSell[] memory nowSellList,uint256 amount, uint256 _size)\r\n    {\r\n        require(page > 0, \"Page number must be greater than zero.\");\r\n        NowSell[] memory NowSellList_ = NowSellMap[getMidnightTimestamp()];\r\n        uint256 length = NowSellList_.length;\r\n        NowSellTotal memory nowSellTotal = NowSellTotalMap[\r\n            getMidnightTimestamp()\r\n        ];\r\n        amount = nowSellTotal.amount;\r\n        _size = nowSellTotal.size;\r\n        uint256 max = (page - 1) * size_;\r\n        if (length == 0 || length <= max) {\r\n            return (new NowSell[](0),amount, _size);\r\n        }\r\n        (uint256 start, uint256 end, uint256 itemCount) = pageData(length, max);\r\n        nowSellList = new NowSell[](itemCount);\r\n        for (uint256 i = start; i >= end; i--) {\r\n            nowSellList[start - i] = NowSellList_[i];\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return (nowSellList,amount, _size);\r\n        // return nowSellList;\r\n    }\r\n\r\n    function getBlindBox(uint256 page, uint256 size_)\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 total, BlindBox[] memory blindBoxList_)\r\n    {\r\n        require(page > 0, \"Page number must be greater than zero.\");\r\n        total = blindBoxAddress.length;\r\n        uint256 length = blindBoxList.length;\r\n        uint256 max = (page - 1) * size_;\r\n        if (length == 0 || length <= max) {\r\n            return (total, new BlindBox[](0));\r\n        }\r\n        (uint256 start, uint256 end, uint256 itemCount) = pageData(length, max);\r\n        blindBoxList_ = new BlindBox[](itemCount);\r\n        for (uint256 i = start; i >= end; i--) {\r\n            blindBoxList_[start - i] = blindBoxList[i];\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return (total, blindBoxList_);\r\n    }\r\n\r\n    function pageData(uint256 length, uint256 max)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 start,\r\n            uint256 end,\r\n            uint256 itemCount\r\n        )\r\n    {\r\n        start = length - max - 1;\r\n        end = start >= size ? start - size + 1 : 0;\r\n        itemCount = start - end + 1;\r\n        return (start, end, itemCount);\r\n    }\r\n\r\n    function getReckon(address adr)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 total,\r\n            uint256 released,\r\n            uint256 residue,\r\n            uint256 NoClaim\r\n        )\r\n    {\r\n        Reckon memory reckon = userInfoList[adr].reckon;\r\n        total = reckon.total;\r\n        ReckonDetail[] memory reckonDetailList = reckon.reckonDetail;\r\n        for (uint256 i = 0; i < reckonDetailList.length; i++) {\r\n            ReckonDetail memory reckonDetail = reckonDetailList[i];\r\n            uint256 thatTime = getMidnightTimestamp();\r\n            uint256 timestamp = reckonDetail.timestamp;\r\n            if ((reckonDetail.total == 0 && reckonDetail.residue == 0) || thatTime - timestamp == 0) {\r\n                continue;\r\n            }\r\n            uint256 reAmount = ((reckonDetail.total * 100) *\r\n                ((thatTime - timestamp) / secondsInDay)) / 10000;\r\n            NoClaim += reAmount;\r\n        }\r\n        released = reckon.released + NoClaim;\r\n        residue = reckon.total - released;\r\n\r\n        return (total, released, residue, NoClaim);\r\n    }\r\n\r\n    function getKickback(address adr, uint256 size_)\r\n        public\r\n        view\r\n        returns (uint256 kickbackTotal, Kickback[] memory kickbackList)\r\n    {\r\n        UserInfo memory userInfo = userInfoList[adr];\r\n        kickbackTotal = userInfo.kickbackTotal;\r\n        Kickback[] memory kickback = userInfo.kickback;\r\n        if (kickback.length == 0) {\r\n            return (kickbackTotal, new Kickback[](0));\r\n        }\r\n        uint256 itemCount = kickback.length > size_ ? size_ : kickback.length;\r\n        kickbackList = new Kickback[](itemCount);\r\n        uint256 count = 0;\r\n        for (uint256 i = kickback.length - 1; 0 <= i; i--) {\r\n            if (count >= itemCount) {\r\n                break;\r\n            }\r\n            kickbackList[count] = kickback[i];\r\n            count++;\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return (kickbackTotal, kickbackList);\r\n    }\r\n\r\n    function getMyNFT(address adr, uint256 page)\r\n        public\r\n        view\r\n        returns (\r\n            UserCard[] memory userCardListResult,\r\n            uint256[] memory userCardListIndex,\r\n            bool\r\n        )\r\n    {\r\n        require(page > 0, \"Page number must be greater than zero.\");\r\n        UserCard[] memory userCardList = userInfoList[adr].userCardList;\r\n        uint256 max = (page - 1) * size;\r\n        if (userCardList.length == 0 || userCardList.length <= max) {\r\n            return (new UserCard[](0), new uint256[](0), false);\r\n        }\r\n        (uint256 start, uint256 end, uint256 itemCount) = pageData(\r\n            userCardList.length,\r\n            max\r\n        );\r\n        userCardListResult = new UserCard[](itemCount);\r\n        userCardListIndex = new uint256[](itemCount);\r\n        for (uint256 i = start; i >= end; i--) {\r\n            userCardListResult[start - i] = userCardList[i];\r\n            userCardListIndex[start - i] = i;\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return (userCardListResult, userCardListIndex, true);\r\n    }\r\n\r\n    function getTransferMarket(uint256 page)\r\n        public\r\n        view\r\n        returns (\r\n            TransferMarket[] memory transferMarketResult,\r\n            uint256[] memory transferMarketIndex,\r\n            bool\r\n        )\r\n    {\r\n        uint256 max = (page - 1) * size;\r\n        if (\r\n            transferMarketList.length == 0 || transferMarketList.length <= max\r\n        ) {\r\n            return (new TransferMarket[](0), new uint256[](0), false);\r\n        }\r\n        (uint256 start, uint256 end, uint256 itemCount) = pageData(\r\n            transferMarketList.length,\r\n            max\r\n        );\r\n        transferMarketResult = new TransferMarket[](itemCount);\r\n        transferMarketIndex = new uint256[](itemCount);\r\n        for (uint256 i = start; i >= end; i--) {\r\n            transferMarketResult[start - i] = transferMarketList[i];\r\n            transferMarketIndex[start - i] = i;\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return (transferMarketResult, transferMarketIndex, true);\r\n    }\r\n\r\n    function claimBoxBalance() external virtual {\r\n        Reckon storage reckon = userInfoList[msgSender()].reckon;\r\n        ReckonDetail[] storage reckonDetailList = reckon.reckonDetail;\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < reckonDetailList.length; i++) {\r\n            ReckonDetail storage reckonDetail = reckonDetailList[i];\r\n            if (reckonDetail.total == 0 && reckonDetail.residue == 0) {\r\n                continue;\r\n            }\r\n            uint256 thatTime = getMidnightTimestamp();\r\n            uint256 timestamp = reckonDetail.timestamp;\r\n            if (thatTime - timestamp == 0) {\r\n                continue;\r\n            }\r\n            uint256 reAmount = (reckonDetail.total *\r\n                100 *\r\n                ((thatTime - timestamp) / secondsInDay)) / 10000;\r\n            amount += reAmount;\r\n            if (reckonDetail.residue - reAmount <= 0) {\r\n                delete reckonDetailList[i];\r\n            } else {\r\n                reckonDetail.residue = reckonDetail.residue - reAmount;\r\n                reckonDetail.timestamp = getMidnightTimestamp();\r\n            }\r\n        }\r\n        reckon.released = reckon.released + amount;\r\n        require(amount > 0, \"no claimed amount\");\r\n        uint256 tokenAmount = getUsdtToTokenSwapOutput(amount);\r\n        require(\r\n            feeToken.balanceOf(address(this)) >= tokenAmount,\r\n            \"transfer amount exceeds balance\"\r\n        );\r\n        feeToken.transfer(msgSender(), tokenAmount);\r\n    }\r\n\r\n    function blindBox(uint256 index) external virtual{\r\n        UserInfo storage userInfo = userInfoList[msgSender()];\r\n        UserCard[] storage userCardList = userInfo.userCardList;\r\n        require(\r\n            userCardList.length > 0,\r\n            \"there are no cards available for splitting\"\r\n        );\r\n        require(userCardList.length > index, \"index too large\");\r\n        UserCard storage userCard = userCardList[index];\r\n        require(userCard.mark == 0, \"card has been manipulated\");\r\n        require(\r\n            userCard.amount >= boxPrice,\r\n            \"the card value has not reached 500u\"\r\n        );\r\n        uint256 multiple = getRandomNumber(index);\r\n        uint256 computing = userCard.amount * multiple;\r\n        Reckon storage reckon = userInfo.reckon;\r\n        reckon.total = reckon.total + computing;\r\n        reckon.reckonDetail.push(\r\n            ReckonDetail(\r\n                computing,\r\n                computing,\r\n                getCurrentBlockTimestamp(),\r\n                getMidnightTimestamp()\r\n            )\r\n        );\r\n        userInfoList[fundAddress].userCardList.push(\r\n            UserCard(\r\n                userCard.amount,\r\n                userCard.cardNumber,\r\n                0,\r\n                userCard.picId,\r\n                0,\r\n                0\r\n            )\r\n        );\r\n        userCard.mark = 4;\r\n        if (!blindBoxMap[msgSender()]) {\r\n            blindBoxAddress.push(msgSender());\r\n            blindBoxMap[msgSender()] = true;\r\n        }\r\n        blindBoxList.push(\r\n            BlindBox(\r\n                userCard.amount,\r\n                multiple,\r\n                computing,\r\n                getCurrentBlockTimestamp()\r\n            )\r\n        );\r\n    }\r\n\r\n    function splitCard(uint256 index) external virtual {\r\n        UserCard[] storage userCardList = userInfoList[msgSender()]\r\n            .userCardList;\r\n        require(\r\n            userCardList.length > 0,\r\n            \"there are no cards available for splitting\"\r\n        );\r\n        require(userCardList.length > index, \"index too large\");\r\n        UserCard storage userCard = userCardList[index];\r\n        require(userCard.mark == 0, \"card has been manipulated\");\r\n        require(\r\n            userCard.amount >= factorPrice,\r\n            \"not meeting the splitting criteria\"\r\n        );\r\n        require(\r\n            getCurrentBlockTimestamp() >=\r\n                (userCard.splitTimestamp + secondsInDay),\r\n            \"less than 24 hours since the last split\"\r\n        );\r\n        uint256 onePrice = userCard.amount / fraction;\r\n        for (uint256 i = 0; i < fraction; i++) {\r\n            userCardList.push(\r\n                UserCard(\r\n                    onePrice,\r\n                    cardNumber + i + 1,\r\n                    getCurrentBlockTimestamp(),\r\n                    getRandomString(i),\r\n                    0,\r\n                    0\r\n                )\r\n            );\r\n        }\r\n        userCard.mark = 3;\r\n        cardNumber = cardNumber + fraction;\r\n    }\r\n\r\n    function userPuy(uint256 index) external virtual MarketLock {\r\n        require(!inForSale(), \"not during trading hours\");\r\n        require(lock, \"the platform has not opened transactions\");\r\n        require(transferMarketList.length > index, \"index too large\");\r\n        TransferMarket storage transferMarket = transferMarketList[index];\r\n        require(\r\n            (transferMarket.amount != 0 && transferMarket.cardNumber != 0) ||\r\n                !transferMarketListMap[transferMarket.cardNumber],\r\n            \"the current card has been snapped up\"\r\n        ); //\u5df2\u88ab\u8d2d\u4e70\r\n        uint256 userAmount = usdtToken.balanceOf(msgSender());\r\n        require(\r\n            userAmount >= transferMarket.amount,\r\n            \"transfer amount exceeds balance\"\r\n        );\r\n        usdtToken.transferFrom(\r\n            msgSender(),\r\n            address(this),\r\n            transferMarket.amount\r\n        );\r\n        require(\r\n            usdtToken.balanceOf(address(this)) >= transferMarket.amount,\r\n            \"contract transfer amount exceeds balance\"\r\n        );\r\n        usdtToken.transfer(transferMarket.owner, transferMarket.amount);\r\n        userInfoList[msgSender()].userCardList.push(\r\n            UserCard(\r\n                transferMarket.amount,\r\n                transferMarket.cardNumber,\r\n                0,\r\n                transferMarket.picId,\r\n                0,\r\n                0\r\n            )\r\n        );\r\n        transferMarketListMap[transferMarket.cardNumber] = true;\r\n        UserCard storage ownerUserCard = userInfoList[transferMarket.owner]\r\n            .userCardList[transferMarket.ownerIndex];\r\n        ownerUserCard.mark = 2;\r\n        ownerUserCard.transferIndex = 0;\r\n        delete transferMarketList[index];\r\n    }\r\n\r\n    function userSell(uint256 index) external virtual MarketLock {\r\n        require(inForSale(), \"not during trading hours\");\r\n        require(lock, \"the platform has not opened transactions\");\r\n        UserCard[] storage userCardList = userInfoList[msgSender()]\r\n            .userCardList;\r\n        require(userCardList.length > 0, \"no cards available for sale\");\r\n        UserCard storage userCard = userCardList[index];\r\n        uint256 amount = userCard.amount +\r\n            ((userCard.amount * fixRise) / 10000);\r\n        uint256 sellFee = calculateFee(amount);\r\n        uint256 userAmount = feeToken.balanceOf(msgSender());\r\n        require(userAmount >= sellFee, \"transfer amount exceeds balance\");\r\n        require(userCard.mark == 0, \"the current card has been snapped up\");\r\n        transferFee(sellFee);\r\n        transferMarketListMap[userCard.cardNumber] = false;\r\n        userCard.mark = 1;\r\n        uint256 marketLength = transferMarketList.length;\r\n        userCard.transferIndex = marketLength;\r\n        transferMarketList.push(\r\n            TransferMarket(\r\n                msgSender(),\r\n                amount,\r\n                userCard.cardNumber,\r\n                getCurrentBlockTimestamp(),\r\n                userCard.picId,\r\n                index\r\n            )\r\n        );\r\n        uint256 totalFee = sell.fundFee + sell.wardFee;\r\n        uint256 fundFee = (amount * sell.fundFee) / totalFee;\r\n        NowSellMap[getMidnightTimestamp()].push(\r\n            NowSell(\r\n                userCard.cardNumber,\r\n                amount,\r\n                getCurrentBlockTimestamp(),\r\n                sellFee,\r\n                fundFee,\r\n                amount - fundFee\r\n            )\r\n        );\r\n        NowSellTotal storage nowSellTotal = NowSellTotalMap[\r\n            getMidnightTimestamp()\r\n        ];\r\n        NowSellTotalMap[getMidnightTimestamp()] = NowSellTotal(\r\n            nowSellTotal.size + 1,\r\n            nowSellTotal.amount + amount\r\n        );\r\n    }\r\n\r\n    function cast() external virtual MarketLock {\r\n        require(issuedNoPuy > 0, \"has been snatched empty\");\r\n        uint256 userAmount = usdtToken.balanceOf(msgSender());\r\n        require(userAmount >= issuePrice, \"transfer amount exceeds balance\");\r\n        UserInfo storage userInfo = userInfoList[msgSender()];\r\n        userInfo.userCardList.push(\r\n            UserCard(\r\n                issuePrice,\r\n                cardNumber + 1,\r\n                0,\r\n                getRandomString(cardNumber + 1),\r\n                0,\r\n                0\r\n            )\r\n        );\r\n        usdtToken.transferFrom(msgSender(), fundAddress, issuePrice);\r\n        issuedNoPuy = issuedNoPuy - 1;\r\n        cardNumber = cardNumber + 1;\r\n        issueUsdtTotal = issueUsdtTotal + issuePrice;\r\n    }\r\n\r\n    function Mint(\r\n        address adr,\r\n        uint256 price,\r\n        uint256 count\r\n    ) external virtual onlyOwner {\r\n        UserCard[] storage userCardList = userInfoList[adr].userCardList;\r\n        uint256 amount = price * 10**usdtToken.decimals();\r\n        for (uint256 i = 0; i < count; i++) {\r\n            uint256 str = getRandomString(i);\r\n            userCardList.push(\r\n                UserCard(\r\n                    amount,\r\n                    cardNumber + i + 1,\r\n                    0,\r\n                    str,\r\n                    0,\r\n                    0\r\n                )\r\n            );\r\n        }\r\n        cardNumber = cardNumber + count;\r\n    }\r\n\r\n    function issueNFT(uint256 amount) external virtual onlyOwner {\r\n        require(issuedTotal + amount <= nftTotal, \"excessive circulation\");\r\n        issuedTotal = issuedTotal + amount;\r\n        issuedNoPuy = issuedNoPuy + amount;\r\n    }\r\n\r\n    function setSenior(address adr) external virtual {\r\n        UserInfo storage userinfo = userInfoList[msgSender()];\r\n        require(msgSender() != adr, \"cannot be set as oneself\");\r\n        require(adr != address(0), \"superior does not allow 0 addresses\");\r\n        require(userinfo.senior == address(0), \"bound to superior\");\r\n        userinfo.team = userInfoList[adr].team;\r\n        userInfoList[adr].minion = userInfoList[adr].minion + 1;\r\n        userinfo.senior = adr;\r\n    }\r\n\r\n    function inSenior(address adr) public view returns (bool) {\r\n        UserInfo memory userinfo = userInfoList[adr];\r\n        return userinfo.senior != address(0);\r\n    }\r\n\r\n    function getRandomNumber(uint256 seed) private view returns (uint256) {\r\n        uint256 random = generateHash(seed);\r\n        uint256 chance = random % 100;\r\n        if (chance < 80) {\r\n            return 2;\r\n        } else if (chance < 96) {\r\n            return 3;\r\n        } else if (chance < 98) {\r\n            return 4;\r\n        } else {\r\n            return 5;\r\n        }\r\n    }\r\n\r\n    function generateHash(uint256 input) private view returns (uint256) {\r\n        uint256 blockNumber = block.number;\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                blockNumber - 2,\r\n                input,\r\n                blockNumber,\r\n                blockNumber - 1,\r\n                getCurrentBlockTimestamp()\r\n            )\r\n        );\r\n        return uint256(hash);\r\n    }\r\n\r\n    function getRandomString(uint256 seed) private view returns (uint256) {\r\n        uint256 index = generateHash(seed) % nftPicId.length;\r\n        return nftPicId[index];\r\n    }\r\n\r\n    function transferFee(uint256 amount) private {\r\n        feeToken.transferFrom(msgSender(), address(this), amount);\r\n        uint256 totalFee = sell.fundFee + sell.wardFee;\r\n        if (totalFee <= 0) {\r\n            return;\r\n        }\r\n        uint256 fundFee = (amount * sell.fundFee) / totalFee;\r\n        uint256 feeAmount = feeToken.balanceOf(address(this));\r\n        require(\r\n            feeAmount >= amount,\r\n            \"ERC20: contract transfer amount exceeds balance\"\r\n        );\r\n        feeToken.transfer(fundAddress, fundFee);\r\n        UserInfo memory userInfo = userInfoList[msgSender()];\r\n        address senior = userInfo.senior;\r\n        if (senior == address(0)) {\r\n            return;\r\n        }\r\n        feeToken.transfer(senior, amount - fundFee);\r\n        UserInfo storage seniorInfo = userInfoList[\r\n            userInfoList[msgSender()].senior\r\n        ];\r\n        seniorInfo.kickbackTotal =\r\n            seniorInfo.kickbackTotal +\r\n            (amount - fundFee);\r\n        seniorInfo.kickback.push(\r\n            Kickback(msgSender(), amount - fundFee, getCurrentBlockTimestamp())\r\n        );\r\n    }\r\n\r\n    function setSize(uint256 size_) external virtual onlyOwner {\r\n        size = size_;\r\n    }\r\n\r\n    function setLock(bool bl) external virtual onlyOwner {\r\n        lock = bl;\r\n    }\r\n\r\n    function setForSale(uint256 start, uint256 end) external virtual onlyOwner {\r\n        forSale.start = start;\r\n        forSale.end = end;\r\n    }\r\n\r\n    function setSell(uint256 fundFee, uint256 wardFee)\r\n        external\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        sell = Sell(fundFee, wardFee);\r\n    }\r\n\r\n    function setFund(address adr) external virtual onlyOwner {\r\n        fundAddress = adr;\r\n    }\r\n\r\n    function calculateFee(uint256 cardPrice) public view returns (uint256) {\r\n        uint256 amount = getUsdtToTokenSwapOutput(cardPrice);\r\n        uint256 fee = (amount * (sell.fundFee + sell.wardFee)) / 10000;\r\n        return fee;\r\n    }\r\n\r\n    function getUsdtToTokenSwapOutput(uint256 usdtAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(usdtToken);\r\n        path[1] = address(feeToken);\r\n        uint256[] memory amounts = router.getAmountsOut(usdtAmount, path);\r\n        return amounts[amounts.length - 1];\r\n    }\r\n\r\n    function getCurrentBlockTimestamp() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function getMidnightTimestamp() public view returns (uint256) {\r\n        return baseMidnightTimestamp(getCurrentBlockTimestamp());\r\n    }\r\n\r\n    function baseMidnightTimestamp(uint256 currentTimestamp)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 daysSinceReference = (currentTimestamp - baseTimestamp) /\r\n            secondsInDay;\r\n        uint256 midnightTimestamp = baseTimestamp +\r\n            (daysSinceReference * secondsInDay);\r\n        return midnightTimestamp;\r\n    }\r\n\r\n    function inForSale() public view returns (bool) {\r\n        uint256 blockTimestamp = getCurrentBlockTimestamp();\r\n        uint256 midnightTimestamp = getMidnightTimestamp();\r\n        uint256 sameDayAfternoonFive = midnightTimestamp +\r\n            (forSale.start * 60 * 60);\r\n        if (sameDayAfternoonFive <= blockTimestamp) {\r\n            return true;\r\n        } else {\r\n            uint256 nextDayAfternoonTwo = midnightTimestamp +\r\n                (forSale.end * 60 * 60);\r\n            if (nextDayAfternoonTwo < blockTimestamp) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function msgSender() private view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function claimBalance(uint256 amount, address to) external onlyOwner {\r\n        payable(to).transfer(amount);\r\n    }\r\n\r\n    function claimToken(\r\n        address token_,\r\n        uint256 amount_,\r\n        address to_\r\n    ) external onlyOwner {\r\n        IERC20(token_).transfer(to_, amount_);\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTimestamp\",\"type\":\"uint256\"}],\"name\":\"baseMidnightTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"blindBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boxPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardPrice\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cardNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBoxBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixRise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size_\",\"type\":\"uint256\"}],\"name\":\"getBlindBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiple\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"computing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractToken.BlindBox[]\",\"name\":\"blindBoxList_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"size_\",\"type\":\"uint256\"}],\"name\":\"getKickback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"kickbackTotal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractToken.Kickback[]\",\"name\":\"kickbackList\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMidnightTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getMyNFT\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"picId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mark\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractToken.UserCard[]\",\"name\":\"userCardListResult\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userCardListIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size_\",\"type\":\"uint256\"}],\"name\":\"getNowSellMap\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cardNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"funFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractToken.NowSell[]\",\"name\":\"nowSellList\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getReckon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NoClaim\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getTeam\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"team\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senior\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minion\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getTransferMarket\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"picId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractToken.TransferMarket[]\",\"name\":\"transferMarketResult\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"transferMarketIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"getUsdtToTokenSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minion\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"team\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"kickbackTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inForSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"inSenior\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issueNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issueUsdtTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuedNoPuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"pageData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fundFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wardFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"setForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bl\",\"type\":\"bool\"}],\"name\":\"setLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fundFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wardFee\",\"type\":\"uint256\"}],\"name\":\"setSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setSenior\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size_\",\"type\":\"uint256\"}],\"name\":\"setSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adrList\",\"type\":\"address[]\"}],\"name\":\"snapshotCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adrList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indexList\",\"type\":\"uint256[]\"}],\"name\":\"snapshotPuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adrList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indexList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"boolList\",\"type\":\"uint256[]\"}],\"name\":\"snapshotSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adrList\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"seniorList\",\"type\":\"address[]\"}],\"name\":\"snapshotSenior\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"splitCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferMarketList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"picId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"userPuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"userSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ContractToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ad026c000dd0d53c8b4117e51eed21e68e9d6858c178af752aa008d3d7fbda5e"}