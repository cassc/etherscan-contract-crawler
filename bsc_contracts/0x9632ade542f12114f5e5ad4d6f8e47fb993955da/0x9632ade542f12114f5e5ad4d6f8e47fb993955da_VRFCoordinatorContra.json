{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/vrf/VRFCoordinatorContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../interfaces/BlockhashStoreInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"./VRF.sol\\\";\\nimport \\\"../access/ConfirmedOwner.sol\\\";\\nimport \\\"./VRFConsumerBase.sol\\\";\\n\\ncontract VRFCoordinatorContract is\\nVRF,\\nConfirmedOwner,\\nTypeAndVersionInterface,\\nVRFCoordinatorInterface\\n{\\n    BlockhashStoreInterface public immutable BLOCKHASH_STORE;\\n\\n    // We need to maintain a list of consuming addresses.\\n    // This bound ensures we are able to loop over them as needed.\\n    // Should a user require more consumers, they can use multiple subscriptions.\\n    uint16 public constant MAX_CONSUMERS = 100;\\n    error TooManyConsumers();\\n    error InsufficientBalance(uint96 balance, uint96 payment);\\n    error InvalidConsumer(uint64 subId, address consumer);\\n    error InvalidSubscription();\\n    error InvalidCalldata();\\n    error MustBeSubOwner(address owner);\\n    error PendingRequestExists();\\n    error MustBeRequestedOwner(address proposedOwner);\\n    error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\\n    error ExceedingTheMaximumRechargeLimit(uint96 subAccountMaxDeposit, uint256 oldSubBalance, uint96 depositAmount);\\n    error InvalidAddress();\\n    event FundsRecovered(address to, uint256 amount);\\n    // We use the subscription struct (1 word)\\n    // at fulfillment time.\\n    struct Subscription {\\n        uint96 balance;\\n        uint64 reqCount; // For fee tiers\\n    }\\n    // We use the config for the mgmt APIs\\n    struct SubscriptionConfig {\\n        address owner; // Owner can fund/withdraw/cancel the sub.\\n        address requestedOwner; // For safely transferring sub ownership.\\n        // Maintains the list of keys in s_consumers.\\n        // We do this for 2 reasons:\\n        // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\\n        // 2. To be able to return the list of all consumers in getSubscription.\\n        // Note that we need the s_consumers map to be able to directly check if a\\n        // consumer is valid without reading all the consumers from storage.\\n        address[] consumers;\\n    }\\n    // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.\\n    mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subId */ /* nonce */\\n    private s_consumers;\\n    mapping(uint64 => SubscriptionConfig) /* subId */ /* subscriptionConfig */\\n    private s_subscriptionConfigs;\\n    mapping(uint64 => Subscription) /* subId */ /* subscription */\\n    private s_subscriptions;\\n\\n    mapping(uint64 => uint32) /* subId */ /* feeTier */\\n    private s_designated_subId_fee;\\n\\n    // We make the sub count public so that its possible to\\n    // get all the current subscriptions via getSubscription.\\n    uint64 private s_currentSubId;\\n    uint96 private s_totalBalance;\\n    event SubscriptionCreated(uint64 indexed subId, address owner);\\n    event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\\n    event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\\n    event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\\n    event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\\n    event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\\n    event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\\n\\n    // Set this maximum to 200 to give us a 56 block window to fulfill\\n    // the request before requiring the block hash feeder.\\n    uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\\n    // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\\n    // and some arithmetic operations.\\n    uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\\n    error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\\n    error GasLimitTooBig(uint32 have, uint32 want);\\n    error NumWordsTooBig(uint32 have, uint32 want);\\n    error ProvingKeyAlreadyRegistered(bytes32 keyHash);\\n    error NoSuchProvingKey(bytes32 keyHash);\\n    error InsufficientGasForConsumer(uint256 have, uint256 want);\\n    error NoCorrespondingRequest();\\n    error IncorrectCommitment();\\n    error BlockhashNotInStore(uint256 blockNum);\\n    error PaymentTooLarge();\\n    error Reentrant();\\n    struct RequestCommitment {\\n        uint64 blockNum;\\n        uint64 subId;\\n        uint32 callbackGasLimit;\\n        uint32 numWords;\\n        address sender;\\n    }\\n    bytes32[] private s_provingKeyHashes;\\n    uint96 private s_withdrawableTokens;\\n    address private s_withdrawableTokensAddress;\\n    mapping(uint256 => bytes32) /* requestID */ /* commitment */\\n    private s_requestCommitments;\\n    event ProvingKeyRegistered(bytes32 keyHash);\\n    event ProvingKeyDeregistered(bytes32 keyHash);\\n    event s_withdrawableTokensAddressChange(address newAddress, address oldAddress);\\n    event RandomWordsRequested(\\n        bytes32 indexed keyHash,\\n        uint256 requestId,\\n        uint256 preSeed,\\n        uint64 indexed subId,\\n        uint16 minimumRequestConfirmations,\\n        uint32 callbackGasLimit,\\n        uint32 numWords,\\n        address indexed sender\\n    );\\n    event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, uint256 fee, bool success);\\n    struct Config {\\n        uint16 minimumRequestConfirmations;\\n        uint16 maxNumWords;\\n        uint32 maxGasLimit;\\n        // Reentrancy protection.\\n        bool reentrancyLock;\\n        // Gas to cover oracle payment after we calculate the payment.\\n        // We make it configurable in case those operations are repriced.\\n        uint32 gasAfterPaymentCalculation;\\n        uint96 subAccountMaxDeposit;\\n    }\\n    Config private s_config;\\n    FeeConfig private s_feeConfig;\\n    struct FeeConfig {\\n        // Flat fee charged per fulfillment in millionths of bnb\\n        // So fee range is [0, 2^32/10^6].\\n        uint32 fulfillmentFlatFeeBNBPPMTier1;\\n        uint32 fulfillmentFlatFeeBNBPPMTier2;\\n        uint32 fulfillmentFlatFeeBNBPPMTier3;\\n        uint32 fulfillmentFlatFeeBNBPPMTier4;\\n        uint32 fulfillmentFlatFeeBNBPPMTier5;\\n        uint24 reqsForTier2;\\n        uint24 reqsForTier3;\\n        uint24 reqsForTier4;\\n        uint24 reqsForTier5;\\n    }\\n    event ConfigSet(\\n        uint16 minimumRequestConfirmations,\\n        uint16 maxNumWords,\\n        uint32 maxGasLimit,\\n        uint32 gasAfterPaymentCalculation,\\n        uint96 subAccountMaxDeposit,\\n        FeeConfig feeConfig\\n    );\\n    bool private nodesWhiteListSwitchStatus;\\n    mapping(address => bool) private nodesWhiteListConfig;\\n    event NodeAccessDisabled(address node);\\n    event NodeAccessAdd(address node);\\n    error NoAuthFulfillRandomWords(address node);\\n\\n    constructor(\\n        address blockhashStore\\n    ) ConfirmedOwner(msg.sender) {\\n        BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\\n    }\\n\\n    /**\\n     * @notice Registers a proving key to an oracle.\\n     * @param publicProvingKey key that oracle can use to submit vrf fulfillments\\n     */\\n    function registerProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\\n        bytes32 kh = hashOfKey(publicProvingKey);\\n        for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\\n            if (s_provingKeyHashes[i] == kh) {\\n                revert ProvingKeyAlreadyRegistered(kh);\\n            }\\n        }\\n        s_provingKeyHashes.push(kh);\\n        emit ProvingKeyRegistered(kh);\\n    }\\n\\n    /**\\n    * @notice Deregisters a proving key to an oracle.\\n    * @param publicProvingKey key that oracle can use to submit vrf fulfillments\\n    */\\n    function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\\n        bytes32 kh = hashOfKey(publicProvingKey);\\n        for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\\n            if (s_provingKeyHashes[i] == kh) {\\n                bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\\n                // Copy last element and overwrite kh to be deleted with it\\n                s_provingKeyHashes[i] = last;\\n                s_provingKeyHashes.pop();\\n            }\\n        }\\n          emit ProvingKeyDeregistered(kh);\\n    }\\n\\n    /**\\n    * @notice Returns the proving key hash key associated with this public key\\n    * @param publicKey the key to return the hash of\\n    */\\n    function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\\n        return keccak256(abi.encode(publicKey));\\n    }\\n\\n    /**\\n    * @notice Sets the configuration of the vrfv2 coordinator\\n    * @param minimumRequestConfirmations global min for request confirmations\\n    * @param maxGasLimit global max for request gas limit\\n    * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\\n    * @param feeConfig fee tier configuration\\n    */\\n    function setConfig(\\n        uint16 minimumRequestConfirmations,\\n        uint16 maxNumWords,\\n        uint32 maxGasLimit,\\n        uint32 gasAfterPaymentCalculation,\\n        uint96 subAccountMaxDeposit,\\n        FeeConfig memory feeConfig\\n    ) external onlyOwner {\\n        if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\\n            revert InvalidRequestConfirmations(\\n                minimumRequestConfirmations,\\n                minimumRequestConfirmations,\\n                MAX_REQUEST_CONFIRMATIONS\\n            );\\n        }\\n        s_config = Config({\\n        minimumRequestConfirmations: minimumRequestConfirmations,\\n        maxNumWords: maxNumWords,\\n        maxGasLimit: maxGasLimit,\\n        gasAfterPaymentCalculation: gasAfterPaymentCalculation,\\n        reentrancyLock: false,\\n        subAccountMaxDeposit: subAccountMaxDeposit\\n        });\\n        s_feeConfig = feeConfig;\\n        emit ConfigSet(\\n            minimumRequestConfirmations,\\n            maxNumWords,\\n            maxGasLimit,\\n            gasAfterPaymentCalculation,\\n            subAccountMaxDeposit,\\n            s_feeConfig\\n        );\\n    }\\n\\n    function getConfig()\\n    external\\n    view\\n    returns (\\n        uint16 minimumRequestConfirmations,\\n        uint16 maxNumWords,\\n        uint32 maxGasLimit,\\n        uint32 gasAfterPaymentCalculation,\\n        uint96 subAccountMaxDeposit\\n    )\\n    {\\n        return (\\n        s_config.minimumRequestConfirmations,\\n        s_config.maxNumWords,\\n        s_config.maxGasLimit,\\n        s_config.gasAfterPaymentCalculation,\\n        s_config.subAccountMaxDeposit\\n        );\\n    }\\n\\n    function getFeeConfig()\\n    external\\n    view\\n    returns (\\n        uint32 fulfillmentFlatFeeBNBPPMTier1,\\n        uint32 fulfillmentFlatFeeBNBPPMTier2,\\n        uint32 fulfillmentFlatFeeBNBPPMTier3,\\n        uint32 fulfillmentFlatFeeBNBPPMTier4,\\n        uint32 fulfillmentFlatFeeBNBPPMTier5,\\n        uint24 reqsForTier2,\\n        uint24 reqsForTier3,\\n        uint24 reqsForTier4,\\n        uint24 reqsForTier5\\n    )\\n    {\\n        return (\\n        s_feeConfig.fulfillmentFlatFeeBNBPPMTier1,\\n        s_feeConfig.fulfillmentFlatFeeBNBPPMTier2,\\n        s_feeConfig.fulfillmentFlatFeeBNBPPMTier3,\\n        s_feeConfig.fulfillmentFlatFeeBNBPPMTier4,\\n        s_feeConfig.fulfillmentFlatFeeBNBPPMTier5,\\n        s_feeConfig.reqsForTier2,\\n        s_feeConfig.reqsForTier3,\\n        s_feeConfig.reqsForTier4,\\n        s_feeConfig.reqsForTier5\\n        );\\n    }\\n\\n    function getTotalBalance() external view returns (uint256) {\\n        return s_totalBalance;\\n    }\\n\\n    function getWithdrawableTokens() external view returns (uint96) {\\n        return s_withdrawableTokens;\\n    }\\n\\n    /**\\n    * @notice Owner cancel subscription, sends remaining coin directly to the subscription owner.\\n    * @param subId subscription id\\n    * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\\n    */\\n    function ownerCancelSubscription(uint64 subId) external onlyOwner {\\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\\n    }\\n\\n    /**\\n    * @inheritdoc VRFCoordinatorInterface\\n    */\\n    function getRequestConfig()\\n    external\\n    view\\n    override\\n    returns (\\n        uint16,\\n        uint32,\\n        bytes32[] memory\\n    )\\n    {\\n        return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n   */\\n    function requestRandomWords(\\n        bytes32 keyHash,\\n        uint64 subId,\\n        uint16 requestConfirmations,\\n        uint32 callbackGasLimit,\\n        uint32 numWords\\n    ) external override vrfLock returns (uint256) {\\n        // Input validation using the subscription storage.\\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        // Its important to ensure that the consumer is in fact who they say they\\n        // are, otherwise they could use someone else's subscription balance.\\n        // A nonce of 0 indicates consumer is not allocated to the sub.\\n        uint64 currentNonce = s_consumers[msg.sender][subId];\\n        if (currentNonce == 0) {\\n            revert InvalidConsumer(subId, msg.sender);\\n        }\\n        // Input validation using the config storage word.\\n        if (\\n            requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\\n        ) {\\n            revert InvalidRequestConfirmations(\\n                requestConfirmations,\\n                s_config.minimumRequestConfirmations,\\n                MAX_REQUEST_CONFIRMATIONS\\n            );\\n        }\\n        // No lower bound on the requested gas limit. A user could request 0\\n        // and they would simply be billed for the proof verification and wouldn't be\\n        // able to do anything with the random value.\\n        if (callbackGasLimit > s_config.maxGasLimit) {\\n            revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\\n        }\\n        if (numWords > s_config.maxNumWords) {\\n            revert NumWordsTooBig(numWords, s_config.maxNumWords);\\n        }\\n        // Note we do not check whether the keyHash is valid to save gas.\\n        // The consequence for users is that they can send requests\\n        // for invalid keyHashes which will simply not be fulfilled.\\n        uint64 nonce = currentNonce + 1;\\n        (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\\n\\n        s_requestCommitments[requestId] = keccak256(\\n            abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\\n        );\\n        emit RandomWordsRequested(\\n            keyHash,\\n            requestId,\\n            preSeed,\\n            subId,\\n            requestConfirmations,\\n            callbackGasLimit,\\n            numWords,\\n            msg.sender\\n        );\\n        s_consumers[msg.sender][subId] = nonce;\\n\\n        return requestId;\\n    }\\n\\n    /**\\n    * @notice Get request commitment\\n    * @param requestId id of request\\n    * @dev used to determine if a request is fulfilled or not\\n    */\\n    function getCommitment(uint256 requestId) external view returns (bytes32) {\\n        return s_requestCommitments[requestId];\\n    }\\n\\n    function computeRequestId(\\n        bytes32 keyHash,\\n        address sender,\\n        uint64 subId,\\n        uint64 nonce\\n    ) private pure returns (uint256, uint256) {\\n        uint256 preSeed = uint256(keccak256(abi.encode(keyHash, sender, subId, nonce)));\\n        return (uint256(keccak256(abi.encode(keyHash, preSeed))), preSeed);\\n\\n    }\\n\\n    /**\\n     * @dev calls target address with exactly gasAmount gas and data as calldata\\n     * or reverts if at least gasAmount gas is not available.\\n     */\\n    function callWithExactGas(\\n        uint256 gasAmount,\\n        address target,\\n        bytes memory data\\n    ) private returns (bool success) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let g := gas()\\n        // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\\n        // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\\n        // We want to ensure that we revert if gasAmount >  63//64*gas available\\n        // as we do not want to provide them with less, however that check itself costs\\n        // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\\n        // to revert if gasAmount >  63//64*gas available.\\n            if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\\n                revert(0, 0)\\n            }\\n            g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\\n        // if g - g//64 <= gasAmount, revert\\n        // (we subtract g//64 because of EIP-150)\\n            if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n                revert(0, 0)\\n            }\\n        // solidity calls check that a contract actually exists at the destination, so we do the same\\n            if iszero(extcodesize(target)) {\\n                revert(0, 0)\\n            }\\n        // call and return whether we succeeded. ignore return data\\n        // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\\n            success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n        }\\n        return success;\\n    }\\n\\n    function getRandomnessFromProof(Proof memory proof, RequestCommitment memory rc)\\n    private\\n    view\\n    returns (\\n        uint256 requestId,\\n        uint256 randomness\\n    )\\n    {\\n        bytes32 keyHash = hashOfKey(proof.pk);\\n        // Only registered proving keys are permitted.\\n        bool flag = false;\\n        for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\\n            if (s_provingKeyHashes[i] == keyHash) {\\n                flag = true;\\n            }\\n        }\\n        if (!flag) {\\n            revert NoSuchProvingKey(keyHash);\\n        }\\n        requestId = uint256(keccak256(abi.encode(keyHash, proof.seed)));\\n        bytes32 commitment = s_requestCommitments[requestId];\\n        if (commitment == 0) {\\n            revert NoCorrespondingRequest();\\n        }\\n        if (\\n            commitment != keccak256(abi.encode(requestId, rc.blockNum, rc.subId, rc.callbackGasLimit, rc.numWords, rc.sender))\\n        ) {\\n            revert IncorrectCommitment();\\n        }\\n\\n        bytes32 blockHash = blockhash(rc.blockNum);\\n        if (blockHash == bytes32(0)) {\\n            blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum);\\n            if (blockHash == bytes32(0)) {\\n                revert BlockhashNotInStore(rc.blockNum);\\n            }\\n        }\\n\\n        // The seed actually used by the VRF machinery, mixing in the blockhash\\n        uint256 actualSeed = uint256(keccak256(abi.encodePacked(proof.seed, blockHash)));\\n        randomness = VRF.randomValueFromVRFProof(proof, actualSeed); // Reverts on failure\\n    }\\n\\n    /*\\n    * @notice Compute fee based on the request count\\n    * @param reqCount number of requests\\n    * @return feePPM fee\\n    */\\n    function getFeeTier(uint64 reqCount, uint64 subId) public view returns (uint32) {\\n        if (s_designated_subId_fee[subId] != 0 ){\\n            return s_designated_subId_fee[subId];\\n        }\\n        FeeConfig memory fc = s_feeConfig;\\n        if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\\n            return fc.fulfillmentFlatFeeBNBPPMTier1;\\n        }\\n        if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\\n            return fc.fulfillmentFlatFeeBNBPPMTier2;\\n        }\\n        if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\\n            return fc.fulfillmentFlatFeeBNBPPMTier3;\\n        }\\n        if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\\n            return fc.fulfillmentFlatFeeBNBPPMTier4;\\n        }\\n        return fc.fulfillmentFlatFeeBNBPPMTier5;\\n    }\\n\\n    /**\\n    * @notice set feeTier by the designated subId\\n    * @param subId (Unique identification of subscription accounts)\\n    * @param feeTier, feeTier of the designated subId\\n    */\\n    function setDesignatedSubIdFeeTier(uint64 subId, uint32 feeTier) external onlyOwner {\\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        s_designated_subId_fee[subId] = feeTier;\\n    }\\n\\n    /**\\n    * @notice get designated feeTier by subId\\n    * @param subId (Unique identification of subscription accounts)\\n    * @return feeTier of the designated subId\\n    */\\n    function getDesignatedSubIdFeeTier(uint64 subId) external view returns (uint32) {\\n        return s_designated_subId_fee[subId];\\n    }\\n\\n    /*\\n     * @notice Fulfill a randomness request\\n     * @param proof contains the proof and randomness\\n     * @param rc request commitment pre-image, committed to at request time\\n     * @return payment amount billed to the subscription\\n     * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\\n     */\\n    function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external vrfLock checkNodeAccess(msg.sender) returns (uint96) {\\n        uint256 startGas = gasleft();\\n        (uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\\n\\n        uint256[] memory randomWords = new uint256[](rc.numWords);\\n        for (uint256 i = 0; i < rc.numWords; i++) {\\n            randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\\n        }\\n\\n        delete s_requestCommitments[requestId];\\n        VRFConsumerBase v;\\n        bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, requestId, randomWords);\\n        // Call with explicitly the amount of callback gas requested\\n        // Important to not let them exhaust the gas budget and avoid oracle payment.\\n        // Do not allow any non-view/non-pure coordinator functions to be called\\n        // during the consumers callback code via reentrancyLock.\\n        // Note that callWithExactGas will revert if we do not have sufficient gas\\n        // to give the callee their requested amount.\\n        s_config.reentrancyLock = true;\\n        bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\\n        s_config.reentrancyLock = false;\\n\\n        // Increment the req count for fee tier selection.\\n        uint64 subId = rc.subId;\\n        uint64 reqCount = s_subscriptions[subId].reqCount;\\n        s_subscriptions[subId].reqCount += 1;\\n\\n        // We want to charge users exactly for how much gas they use in their callback.\\n        // The gasAfterPaymentCalculation is meant to cover these additional operations where we\\n        // decrement the subscription balance and increment the oracles withdrawable balance.\\n        (uint96 payment, uint256 fee) = calculatePaymentAmount(\\n            startGas,\\n            s_config.gasAfterPaymentCalculation,\\n            getFeeTier(reqCount, subId),\\n            tx.gasprice\\n        );\\n        if (s_subscriptions[subId].balance < payment) {\\n            revert InsufficientBalance(s_subscriptions[subId].balance, payment);\\n        }\\n        s_subscriptions[subId].balance -= payment;\\n        s_withdrawableTokens += payment;\\n        // Include payment in the event for tracking costs.\\n        emit RandomWordsFulfilled(requestId, randomness, payment, fee, success);\\n        return payment;\\n    }\\n\\n    // Get the amount of gas used for fulfillment\\n    function calculatePaymentAmount(\\n        uint256 startGas,\\n        uint256 gasAfterPaymentCalculation,\\n        uint32 fulfillmentFlatFeeBNBPPMTier,\\n        uint256 weiPerUnitGas\\n    ) internal view returns (uint96, uint256) {\\n        uint256 paymentNoFee = weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft());\\n        uint256 fee = 1e12 * uint256(fulfillmentFlatFeeBNBPPMTier);\\n        return (uint96(paymentNoFee + fee), fee);\\n    }\\n\\n    function getCurrentSubId() external view returns (uint64) {\\n        return s_currentSubId;\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function getSubscription(uint64 subId)\\n    external\\n    view\\n    override\\n    returns (\\n        uint96 balance,\\n        uint64 reqCount,\\n        address owner,\\n        address[] memory consumers\\n    )\\n    {\\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        return (\\n        s_subscriptions[subId].balance,\\n        s_subscriptions[subId].reqCount,\\n        s_subscriptionConfigs[subId].owner,\\n        s_subscriptionConfigs[subId].consumers\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function createSubscription() external override vrfLock returns (uint64) {\\n        s_currentSubId++;\\n        uint64 currentSubId = s_currentSubId;\\n        address[] memory consumers = new address[](0);\\n        s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\\n        s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\\n        owner: msg.sender,\\n        requestedOwner: address(0),\\n        consumers: consumers\\n        });\\n\\n        emit SubscriptionCreated(currentSubId, msg.sender);\\n        return currentSubId;\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\\n    external\\n    override\\n    onlySubOwner(subId)\\n    vrfLock\\n    {\\n        // Proposing to address(0) would never be claimable so don't need to check.\\n        if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\\n            s_subscriptionConfigs[subId].requestedOwner = newOwner;\\n            emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function acceptSubscriptionOwnerTransfer(uint64 subId) external override vrfLock {\\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\\n            revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\\n        }\\n        address oldOwner = s_subscriptionConfigs[subId].owner;\\n        s_subscriptionConfigs[subId].owner = msg.sender;\\n        s_subscriptionConfigs[subId].requestedOwner = address(0);\\n        emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) vrfLock {\\n        if (s_consumers[consumer][subId] == 0) {\\n            revert InvalidConsumer(subId, consumer);\\n        }\\n        // Note bounded by MAX_CONSUMERS\\n        address[] memory consumers = s_subscriptionConfigs[subId].consumers;\\n        uint256 lastConsumerIndex = consumers.length - 1;\\n        for (uint256 i = 0; i < consumers.length; i++) {\\n            if (consumers[i] == consumer) {\\n                address last = consumers[lastConsumerIndex];\\n                // Storage write to preserve last element\\n                s_subscriptionConfigs[subId].consumers[i] = last;\\n                // Storage remove last element\\n                s_subscriptionConfigs[subId].consumers.pop();\\n                break;\\n            }\\n        }\\n        delete s_consumers[consumer][subId];\\n        emit SubscriptionConsumerRemoved(subId, consumer);\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) vrfLock {\\n        // Already maxed, cannot add any more consumers.\\n        if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\\n            revert TooManyConsumers();\\n        }\\n        if (s_consumers[consumer][subId] != 0) {\\n            // Idempotence - do nothing if already added.\\n            // Ensures uniqueness in s_subscriptions[subId].consumers.\\n            return;\\n        }\\n        // Initialize the nonce to 1, indicating the consumer is allocated.\\n        s_consumers[consumer][subId] = 1;\\n        s_subscriptionConfigs[subId].consumers.push(consumer);\\n\\n        emit SubscriptionConsumerAdded(subId, consumer);\\n    }\\n\\n    /**\\n     * @inheritdoc VRFCoordinatorInterface\\n     */\\n    function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) {\\n        if (pendingRequestExists(subId)) {\\n            revert PendingRequestExists();\\n        }\\n        cancelSubscriptionHelper(subId, to);\\n    }\\n\\n    function cancelSubscriptionHelper(uint64 subId, address to) private vrfLock {\\n        SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\\n        Subscription memory sub = s_subscriptions[subId];\\n        uint96 balance = sub.balance;\\n        // Note bounded by MAX_CONSUMERS;\\n        // If no consumers, does nothing.\\n        for (uint256 i = 0; i < subConfig.consumers.length; i++) {\\n            delete s_consumers[subConfig.consumers[i]][subId];\\n        }\\n        delete s_subscriptionConfigs[subId];\\n        delete s_subscriptions[subId];\\n        s_totalBalance -= balance;\\n        (bool success,) = payable(to).call{value: balance}(\\\"\\\");\\n        if (!success) {\\n            revert InsufficientBalance(s_totalBalance, balance);\\n        }\\n        emit SubscriptionCanceled(subId, to, balance);\\n    }\\n\\n    /**\\n    * @notice withdrawal of available balance\\n    * @param amount, how much to withdraw\\n    */\\n    function oracleWithdraw(uint96 amount) external vrfLock {\\n        if (s_withdrawableTokens < amount) {\\n            revert InsufficientBalance(s_withdrawableTokens, amount);\\n        }\\n        if (s_withdrawableTokensAddress == address(0)) {\\n            revert InvalidAddress();\\n        }\\n        s_withdrawableTokens -= amount;\\n        s_totalBalance -= amount;\\n        (bool success,) = s_withdrawableTokensAddress.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert InsufficientBalance(s_withdrawableTokens, amount);\\n        }\\n    }\\n\\n    /**\\n    * @notice set wallet address for withdraw\\n    * @param recipient, wallet address\\n    */\\n    function updateAddress(address recipient) external onlyOwner{\\n        if (recipient == address(0)) {\\n            revert InvalidAddress();\\n        }\\n        s_withdrawableTokensAddress = recipient;\\n        emit s_withdrawableTokensAddressChange(s_withdrawableTokensAddress, recipient);\\n    }\\n\\n    function deposit(uint64 subId) external payable {\\n        require(msg.value != 0, \\\"ia\\\");\\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        // We do not check that the msg.sender is the subscription owner,\\n        // anyone can fund a subscription.\\n        uint256 oldBalance = s_subscriptions[subId].balance;\\n        uint96 afterDepositAmount = s_subscriptions[subId].balance + uint96(msg.value);\\n        if(s_config.subAccountMaxDeposit < afterDepositAmount){\\n            revert ExceedingTheMaximumRechargeLimit(s_config.subAccountMaxDeposit, s_subscriptions[subId].balance, uint96(msg.value));\\n        }\\n        s_subscriptions[subId].balance += uint96(msg.value);\\n        s_totalBalance += uint96(msg.value);\\n        emit SubscriptionFunded(subId, oldBalance, oldBalance + msg.value);\\n    }\\n\\n    /**\\n    * @inheritdoc VRFCoordinatorInterface\\n    * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).\\n    * @dev Used to disable subscription canceling while outstanding request are present.\\n    */\\n    function pendingRequestExists(uint64 subId) public view override returns (bool) {\\n        SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\\n        for (uint256 i = 0; i < subConfig.consumers.length; i++) {\\n            for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\\n                (uint256 reqId, ) = computeRequestId(\\n                    s_provingKeyHashes[j],\\n                    subConfig.consumers[i],\\n                    subId,\\n                    s_consumers[subConfig.consumers[i]][subId]\\n                );\\n                if (s_requestCommitments[reqId] != 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n    * @notice set node whitelist switch status, if open, will only the nodes of whitelist can call the \\\"fulfillRandomWords\\\"\\n    */\\n    function setNodesWhiteListSwitchStatus(bool status) external onlyOwner {\\n        nodesWhiteListSwitchStatus = status;\\n    }\\n\\n    function getNodesWhiteListSwitchStatus() external view returns (bool) {\\n        return nodesWhiteListSwitchStatus;\\n    }\\n\\n    /**\\n    * @notice disable designated wallet address in the nodesWhiteList\\n    * @param node, wallet address\\n    */\\n    function disableNodeAccess(address node) external onlyOwner {\\n        if (nodesWhiteListConfig[node]) {\\n            nodesWhiteListConfig[node] = false;\\n            emit NodeAccessDisabled(node);\\n        }\\n    }\\n\\n    /**\\n    * @notice add designated wallet address to the nodesWhiteList\\n    * @param node, wallet address\\n    */\\n    function addNodeAccess(address node) external onlyOwner {\\n        if (!nodesWhiteListConfig[node]) {\\n            nodesWhiteListConfig[node] = true;\\n            emit NodeAccessAdd(node);\\n        }\\n    }\\n\\n    /**\\n    * @notice return designated wallet address access status\\n    */\\n    function getNodeAccessStatus(address node) external view returns (bool) {\\n        return nodesWhiteListConfig[node];\\n    }\\n\\n    /**\\n    * @notice check if node has access\\n    */\\n    modifier checkNodeAccess(address node) {\\n        if(nodesWhiteListSwitchStatus && !nodesWhiteListConfig[node]){\\n            revert NoAuthFulfillRandomWords(node);\\n        }\\n        _;\\n    }\\n\\n    modifier onlySubOwner(uint64 subId) {\\n        address owner = s_subscriptionConfigs[subId].owner;\\n        if (owner == address(0)) {\\n            revert InvalidSubscription();\\n        }\\n        if (msg.sender != owner) {\\n            revert MustBeSubOwner(owner);\\n        }\\n        _;\\n    }\\n\\n    modifier vrfLock() {\\n        if (s_config.reentrancyLock) {\\n            revert Reentrant();\\n        }\\n        _;\\n    }\\n\\n    /**\\n    * @notice The type and version of this contract\\n    * @return Type and version string\\n    */\\n    function typeAndVersion() external pure virtual override returns (string memory) {\\n        return \\\"VRFCoordinatorV2 1.0.0\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/VRFCoordinatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorInterface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n  external\\n  view\\n  returns (\\n    uint16,\\n    uint32,\\n    bytes32[] memory\\n  );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - BNB balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n  external\\n  view\\n  returns (\\n    uint96 balance,\\n    uint64 reqCount,\\n    address owner,\\n    address[] memory consumers\\n  );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining BNB to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/vrf/VRF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\\n\\n  * @dev Bibliographic references:\\n\\n  * @dev Goldberg, et al., \\\"Verifiable Random Functions (VRFs)\\\", Internet Draft\\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\\n\\n  * @dev Papadopoulos, et al., \\\"Making NSEC5 Practical for DNSSEC\\\", Cryptology\\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\\n  * ****************************************************************************\\n  * @dev USAGE\\n\\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\\n  * ****************************************************************************\\n  * @dev PURPOSE\\n\\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\\n  * @dev Reggie, he gives back a value which is computed completely\\n  * @dev deterministically from the seed and the secret key.\\n\\n  * @dev Reggie provides a proof by which Vera can verify that the output was\\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\\n  * @dev the output is computationally indistinguishable to her from a uniform\\n  * @dev random sample from the output space.\\n\\n  * @dev The purpose of this contract is to perform that verification.\\n  * ****************************************************************************\\n  * @dev DESIGN NOTES\\n\\n  * @dev The VRF algorithm verified here satisfies the full uniqueness, full\\n  * @dev collision resistance, and full pseudo-randomness security properties.\\n  * @dev See \\\"SECURITY PROPERTIES\\\" below, and\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\\n\\n  * @dev An elliptic curve point is generally represented in the solidity code\\n  * @dev as a uint256[2], corresponding to its affine coordinates in\\n  * @dev GF(FIELD_SIZE).\\n\\n  * @dev For the sake of efficiency, this implementation deviates from the spec\\n  * @dev in some minor ways:\\n\\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\\n\\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\\n\\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\\n  * @dev   nonce updated until a valid x-ordinate is found.\\n\\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\\n  * @dev   in the hash message, as recommended in step 5.B of the draft\\n  * @dev   standard. They are unnecessary here because no variation in the\\n  * @dev   cipher suite is allowed.\\n\\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\\n  * @dev   points, not the compressed points as recommended in step 3.\\n\\n  * @dev - In the calculation of the challenge value \\\"c\\\", the \\\"u\\\" value (i.e.\\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\\n  * @dev   generator point, see steps 5 and 7 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\\n  * @dev   keccak hash of the original u. This is because we only verify the\\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\\n  * ****************************************************************************\\n  * @dev   SECURITY PROPERTIES\\n\\n  * @dev Here are the security properties for this VRF:\\n\\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\\n  * @dev   the sense that the proof will pass verifyVRFProof.\\n\\n  * @dev Full collision resistance: It's cryptographically infeasible to find\\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\\n\\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\\n  * @dev   derived from a given seed, the outputs are computationally\\n  * @dev   indistinguishable from randomness.\\n\\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\\n  * @dev for these properties.\\n\\n  * @dev For secp256k1, the key validation described in section\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\\n  * @dev representation of the public key used here (affine x- and y-ordinates\\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\\n  * @dev the point at infinity.\\n  * ****************************************************************************\\n  * @dev OTHER SECURITY CONSIDERATIONS\\n  *\\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\\n  * @dev However, under the Random Oracle Model the probability of choosing a\\n  * @dev point which forces n extra rounds in hashToCurve is 2\u207b\u207f. The base cost\\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\\n  * @dev try, in expectation, about 2\u00b9\u00b2\u2078 seeds, which is infeasible for any\\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\\n\\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\\n  * @dev this means it is infeasible for an adversary to prevent correct\\n  * @dev operation of this contract by choosing an adverse seed.\\n\\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\\n  * @dev hashToCurve.)\\n\\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\\n  * @dev See notes in hashToCurve docstring.\\n*/\\ncontract VRF {\\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\\n  // Number of points in Secp256k1\\n  uint256 private constant GROUP_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n  // Prime characteristic of the galois field over which Secp256k1 is defined\\n  uint256 private constant FIELD_SIZE =\\n    // solium-disable-next-line indentation\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n  uint256 private constant WORD_LENGTH_BYTES = 0x20;\\n\\n  // (base^exponent) % FIELD_SIZE\\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\\n  function bigModExp(uint256 base, uint256 exponent) internal view returns (uint256 exponentiation) {\\n    uint256 callResult;\\n    uint256[6] memory bigModExpContractInputs;\\n    bigModExpContractInputs[0] = WORD_LENGTH_BYTES; // Length of base\\n    bigModExpContractInputs[1] = WORD_LENGTH_BYTES; // Length of exponent\\n    bigModExpContractInputs[2] = WORD_LENGTH_BYTES; // Length of modulus\\n    bigModExpContractInputs[3] = base;\\n    bigModExpContractInputs[4] = exponent;\\n    bigModExpContractInputs[5] = FIELD_SIZE;\\n    uint256[1] memory output;\\n    assembly {\\n      // solhint-disable-line no-inline-assembly\\n      callResult := staticcall(\\n        not(0), // Gas cost: no limit\\n        0x05, // Bigmodexp contract address\\n        bigModExpContractInputs,\\n        0xc0, // Length of input segment: 6*0x20-bytes\\n        output,\\n        0x20 // Length of output segment\\n      )\\n    }\\n    if (callResult == 0) {\\n      require(1==2, '5');\\n//      revert(\\\"bigModExp failure!\\\");\\n    }\\n    return output[0];\\n  }\\n\\n  // Let q=FIELD_SIZE. q % 4 = 3, \u2234 x\u2261r^2 mod q \u21d2 x^SQRT_POWER\u2261\u00b1r mod q.  See\\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\\n  uint256 private constant SQRT_POWER = (FIELD_SIZE + 1) >> 2;\\n\\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\\n  function squareRoot(uint256 x) internal view returns (uint256) {\\n    return bigModExp(x, SQRT_POWER);\\n  }\\n\\n  // The value of y^2 given that (x,y) is on secp256k1.\\n  function ySquared(uint256 x) internal pure returns (uint256) {\\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\\n    return addmod(xCubed, 7, FIELD_SIZE);\\n  }\\n\\n  // True if p is on secp256k1\\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\\n    // Section 2.3.6. in https://www.secg.org/sec1-v2.pdf\\n    // requires each ordinate to be in [0, ..., FIELD_SIZE-1]\\n    require(p[0] < FIELD_SIZE, \\\"invalid x-ordinate\\\");\\n    require(p[1] < FIELD_SIZE, \\\"invalid y-ordinate\\\");\\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\\n  }\\n\\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\\n    x_ = uint256(keccak256(b));\\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\\n    // string_to_point in the IETF draft\\n    while (x_ >= FIELD_SIZE) {\\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\\n    }\\n  }\\n\\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\\n  // is always even, due to\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  // step 5.C, which references arbitrary_string_to_point, defined in\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\\n  // returning the point with given x ordinate, and even y ordinate.\\n  function newCandidateSecp256k1Point(bytes memory b) internal view returns (uint256[2] memory p) {\\n    unchecked {\\n      p[0] = fieldHash(b);\\n      p[1] = squareRoot(ySquared(p[0]));\\n      if (p[1] % 2 == 1) {\\n        // Note that 0 <= p[1] < FIELD_SIZE\\n        // so this cannot wrap, we use unchecked to save gas.\\n        p[1] = FIELD_SIZE - p[1];\\n      }\\n    }\\n  }\\n\\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\\n  // vrf.go/hashToCurveHashPrefix\\n  uint256 internal constant HASH_TO_CURVE_HASH_PREFIX = 1;\\n\\n  // Cryptographic hash function onto the curve.\\n  //\\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\\n  // DESIGN NOTES above for slight differences.)\\n  //\\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\\n  // \\\"Construction of Rational Points on Elliptic Curves over Finite Fields\\\"\\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\\n  // and suggested by\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\\n  //\\n  // This would greatly simplify the analysis in \\\"OTHER SECURITY CONSIDERATIONS\\\"\\n  // https://www.pivotaltracker.com/story/show/171120900\\n  function hashToCurve(uint256[2] memory pk, uint256 input) internal view returns (uint256[2] memory rv) {\\n    rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX, pk, input));\\n    while (!isOnCurve(rv)) {\\n      rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\\n    }\\n  }\\n\\n  /** *********************************************************************\\n   * @notice Check that product==scalar*multiplicand\\n   *\\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\\n   *\\n   * @param multiplicand: secp256k1 point\\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\\n   * @param product: secp256k1 expected to be multiplier * multiplicand\\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\\n   */\\n  function ecmulVerify(\\n    uint256[2] memory multiplicand,\\n    uint256 scalar,\\n    uint256[2] memory product\\n  ) internal pure returns (bool verifies) {\\n    // hash, s, sHashWitness\\n    require(scalar != 0, \\\"zero scalar\\\"); // Rules out an ecrecover failure case\\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\\n    // (x\u207b\u00b9 mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\\n    // Explicit conversion to address takes bottom 160 bits\\n    address expected = address(uint160(uint256(keccak256(abi.encodePacked(product)))));\\n    return (actual == expected);\\n  }\\n\\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P\u00b9(\ud835\udd3d\u2099)\\n  function projectiveSub(\\n    uint256 x1,\\n    uint256 z1,\\n    uint256 x2,\\n    uint256 z2\\n  ) internal pure returns (uint256 x3, uint256 z3) {\\n    unchecked {\\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\\n      // Note this cannot wrap since x2 is a point in [0, FIELD_SIZE-1]\\n      // we use unchecked to save gas.\\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n    }\\n  }\\n\\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P\u00b9(\ud835\udd3d\u2099)\\n  function projectiveMul(\\n    uint256 x1,\\n    uint256 z1,\\n    uint256 x2,\\n    uint256 z2\\n  ) internal pure returns (uint256 x3, uint256 z3) {\\n    (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n  }\\n\\n  /** **************************************************************************\\n        @notice Computes elliptic-curve sum, in projective co-ordinates\\n\\n        @dev Using projective coordinates avoids costly divisions\\n\\n        @dev To use this with p and q in affine coordinates, call\\n        @dev projectiveECAdd(px, py, qx, qy). This will return\\n        @dev the addition of (px, py, 1) and (qx, qy, 1), in the\\n        @dev secp256k1 group.\\n\\n        @dev This can be used to calculate the z which is the inverse to zInv\\n        @dev in isValidVRFOutput. But consider using a faster\\n        @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\\n\\n        @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\\n             coordinates of secp256k1 points. That is safe in this contract,\\n             because this method is only used by linearCombination, which checks\\n             points are on the curve via ecrecover.\\n        **************************************************************************\\n        @param px The first affine coordinate of the first summand\\n        @param py The second affine coordinate of the first summand\\n        @param qx The first affine coordinate of the second summand\\n        @param qy The second affine coordinate of the second summand\\n\\n        (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\\n        **************************************************************************\\n        Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\\n        on secp256k1, in P\u00b2(\ud835\udd3d\u2099)\\n        @return sx\\n        @return sy\\n        @return sz\\n    */\\n  function projectiveECAdd(\\n    uint256 px,\\n    uint256 py,\\n    uint256 qx,\\n    uint256 qy\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256 sx,\\n      uint256 sy,\\n      uint256 sz\\n    )\\n  {\\n    unchecked {\\n      // See \\\"Group law for E/K : y^2 = x^3 + ax + b\\\", in section 3.1.2, p. 80,\\n      // \\\"Guide to Elliptic Curve Cryptography\\\" by Hankerson, Menezes and Vanstone\\n      // We take the equations there for (sx,sy), and homogenize them to\\n      // projective coordinates. That way, no inverses are required, here, and we\\n      // only need the one inverse in affineECAdd.\\n\\n      // We only need the \\\"point addition\\\" equations from Hankerson et al. Can\\n      // skip the \\\"point doubling\\\" equations because p1 == p2 is cryptographically\\n      // impossible, and required not to be the case in linearCombination.\\n\\n      // Add extra \\\"projective coordinate\\\" to the two points\\n      (uint256 z1, uint256 z2) = (1, 1);\\n\\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\\n      // Cannot wrap since px and py are in [0, FIELD_SIZE-1]\\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\\n\\n      uint256 dx; // Accumulates denominator from sx calculation\\n      // sx=((qy-py)/(qx-px))^2-px-qx\\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\\n\\n      uint256 dy; // Accumulates denominator from sy calculation\\n      // sy=((qy-py)/(qx-px))(px-sx)-py\\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\\n\\n      if (dx != dy) {\\n        // Cross-multiply to put everything over a common denominator\\n        sx = mulmod(sx, dy, FIELD_SIZE);\\n        sy = mulmod(sy, dx, FIELD_SIZE);\\n        sz = mulmod(dx, dy, FIELD_SIZE);\\n      } else {\\n        // Already over a common denominator, use that for z ordinate\\n        sz = dx;\\n      }\\n    }\\n  }\\n\\n  // p1+p2, as affine points on secp256k1.\\n  //\\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\\n  // It is computed off-chain to save gas.\\n  //\\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\\n  // point doubling.\\n  function affineECAdd(\\n    uint256[2] memory p1,\\n    uint256[2] memory p2,\\n    uint256 invZ\\n  ) internal pure returns (uint256[2] memory) {\\n    uint256 x;\\n    uint256 y;\\n    uint256 z;\\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \\\"invZ must be inverse of z\\\");\\n    // Clear the z ordinate of the projective representation by dividing through\\n    // by it, to obtain the affine representation\\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\\n  }\\n\\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\\n  // cryptographically high probability.)\\n  function verifyLinearCombinationWithGenerator(\\n    uint256 c,\\n    uint256[2] memory p,\\n    uint256 s,\\n    address lcWitness\\n  ) internal pure returns (bool) {\\n    // Rule out ecrecover failure modes which return address 0.\\n    unchecked {\\n      require(lcWitness != address(0), \\\"bad witness\\\");\\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\\n      // Note this cannot wrap (X - Y % X), but we use unchecked to save\\n      // gas.\\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n      // The point corresponding to the address returned by\\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\\n      // (p[0]\u207b\u00b9 mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\\n      // See https://crypto.stackexchange.com/a/18106\\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\\n      return computed == lcWitness;\\n    }\\n  }\\n\\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\\n  // requires cp1Witness != sp2Witness (which is fine for this application,\\n  // since it is cryptographically impossible for them to be equal. In the\\n  // (cryptographically impossible) case that a prover accidentally derives\\n  // a proof with equal c*p1 and s*p2, they should retry with a different\\n  // proof nonce.) Assumes that all points are on secp256k1\\n  // (which is checked in verifyVRFProof below.)\\n  // c, gamma, cGammaWitness, s, hash, sHashWitness, zInv\\n  // hash = hashToCurve(pk, seed);\\n  function linearCombination(\\n    uint256 c,\\n    uint256[2] memory p1,\\n    uint256[2] memory cp1Witness,\\n    uint256 s,\\n    uint256[2] memory p2,\\n    uint256[2] memory sp2Witness,\\n    uint256 zInv\\n  ) internal pure returns (uint256[2] memory) {\\n    unchecked {\\n      // Note we are relying on the wrap around here\\n      require((cp1Witness[0] % FIELD_SIZE) != (sp2Witness[0] % FIELD_SIZE), \\\"points in sum must be distinct\\\");\\n      require(ecmulVerify(p1, c, cp1Witness), \\\"First mul check failed\\\");\\n      require(ecmulVerify(p2, s, sp2Witness), \\\"Second mul check failed\\\");//s, hash, sHashWitness\\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\\n    }\\n  }\\n\\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\\n  uint256 internal constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\\n\\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  // The draft calls (in step 7, via the definition of string_to_int, in\\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\\n  // first hash without checking that it corresponds to a number less than the\\n  // group order, which will lead to a slight bias in the sample.\\n  //\\n  // TODO(alx): We could save a bit of gas by following the standard here and\\n  // using the compressed representation of the points, if we collated the y\\n  // parities into a single bytes32.\\n  // https://www.pivotaltracker.com/story/show/171120588\\n  function scalarFromCurvePoints(\\n    uint256[2] memory hash,\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    address uWitness,\\n    uint256[2] memory v\\n  ) internal pure returns (uint256 s) {\\n    return uint256(keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX, hash, pk, gamma, v, uWitness)));\\n  }\\n\\n\\n\\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\\n  // and seed. zInv must be the inverse of the third ordinate from\\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\\n  // section 5.3 of the IETF draft.\\n  //\\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\\n  // (which I could make a uint256 without using any extra space.) Would save\\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\\n  function verifyVRFProof(\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    uint256 c,\\n    uint256 s,\\n    uint256 seed,\\n    address uWitness,\\n    uint256[2] memory cGammaWitness,\\n    uint256[2] memory sHashWitness,\\n    uint256 zInv\\n  ) internal view {\\n    unchecked {\\n      require(isOnCurve(pk), \\\"public key is not on curve\\\");\\n      require(isOnCurve(gamma), \\\"gamma is not on curve\\\");\\n      require(isOnCurve(cGammaWitness), \\\"cGammaWitness is not on curve\\\");\\n      require(isOnCurve(sHashWitness), \\\"sHashWitness is not on curve\\\");\\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\\n      // we use the address of u instead of u itself. Also, here we add the\\n      // terms instead of taking the difference, and in the proof construction in\\n      // vrf.GenerateProof, we correspondingly take the difference instead of\\n      // taking the sum as they do in step 7 of section 5.1.)\\n      require(verifyLinearCombinationWithGenerator(c, pk, s, uWitness), \\\"addr(c*pk+s*g)!=_uWitness\\\");\\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\\n      uint256[2] memory hash = hashToCurve(pk, seed);\\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\\n      uint256[2] memory v = linearCombination(c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\\n      // Steps 7. and 8. of IETF draft section 5.3\\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\\n      require(c == derivedC, \\\"invalid proof\\\");\\n    }\\n  }\\n\\n  // Domain-separation tag for the hash used as the final VRF output.\\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\\n  uint256 internal constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\\n\\n  struct Proof {\\n    uint256[2] pk;\\n    uint256[2] gamma;\\n    uint256 c;\\n    uint256 s;\\n    uint256 seed;\\n    address uWitness;\\n    uint256[2] cGammaWitness;\\n    uint256[2] sHashWitness;\\n    uint256 zInv;\\n  }\\n\\n  /* ***************************************************************************\\n     * @notice Returns proof's output, if proof is valid. Otherwise reverts\\n\\n     * @param proof vrf proof components\\n     * @param seed  seed used to generate the vrf output\\n     *\\n     * Throws if proof is invalid, otherwise:\\n     * @return output i.e., the random output implied by the proof\\n     * ***************************************************************************\\n     */\\n  function randomValueFromVRFProof(Proof memory proof, uint256 seed) internal view returns (uint256 output) {\\n    verifyVRFProof(\\n      proof.pk,\\n      proof.gamma,\\n      proof.c,\\n      proof.s,\\n      seed,\\n      proof.uWitness,\\n      proof.cGammaWitness,\\n      proof.sHashWitness,\\n      proof.zInv\\n    );\\n    output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, proof.gamma)));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BlockhashStoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface BlockhashStoreInterface {\\n  function getBlockhash(uint256 number) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface TypeAndVersionInterface {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/vrf/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBase {\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert ('OnlyCoordinatorCanFulfill');\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/access/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) external override onlyOwner {\\n    require(to != address(0), \\\"Cannot set owner to zero\\\");\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() external view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blockhashStore\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"internalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"externalBalance\",\"type\":\"uint256\"}],\"name\":\"BalanceInvariantViolated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"BlockhashNotInStore\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"subAccountMaxDeposit\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"oldSubBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"depositAmount\",\"type\":\"uint96\"}],\"name\":\"ExceedingTheMaximumRechargeLimit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"have\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"want\",\"type\":\"uint32\"}],\"name\":\"GasLimitTooBig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectCommitment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"InsufficientGasForConsumer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCalldata\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"InvalidConsumer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"have\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"min\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"max\",\"type\":\"uint16\"}],\"name\":\"InvalidRequestConfirmations\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSubscription\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"MustBeRequestedOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"MustBeSubOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"NoAuthFulfillRandomWords\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoCorrespondingRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"NoSuchProvingKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"have\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"want\",\"type\":\"uint32\"}],\"name\":\"NumWordsTooBig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingRequestExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"ProvingKeyAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyConsumers\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"maxNumWords\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"gasAfterPaymentCalculation\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"subAccountMaxDeposit\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier5\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier2\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier3\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier4\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier5\",\"type\":\"uint24\"}],\"indexed\":false,\"internalType\":\"struct VRFCoordinatorContract.FeeConfig\",\"name\":\"feeConfig\",\"type\":\"tuple\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"NodeAccessAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"NodeAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"ProvingKeyDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"ProvingKeyRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"RandomWordsFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"preSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RandomWordsRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SubscriptionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"SubscriptionConsumerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"SubscriptionConsumerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SubscriptionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"SubscriptionFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SubscriptionOwnerTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SubscriptionOwnerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"s_withdrawableTokensAddressChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BLOCKHASH_STORE\",\"outputs\":[{\"internalType\":\"contract BlockhashStoreInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CONSUMERS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REQUEST_CONFIRMATIONS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"acceptSubscriptionOwnerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"addConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"addNodeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"cancelSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createSubscription\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"publicProvingKey\",\"type\":\"uint256[2]\"}],\"name\":\"deregisterProvingKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"disableNodeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"pk\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"gamma\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uWitness\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"cGammaWitness\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"sHashWitness\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"zInv\",\"type\":\"uint256\"}],\"internalType\":\"struct VRF.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"internalType\":\"struct VRFCoordinatorContract.RequestCommitment\",\"name\":\"rc\",\"type\":\"tuple\"}],\"name\":\"fulfillRandomWords\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getCommitment\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxNumWords\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"maxGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gasAfterPaymentCalculation\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"subAccountMaxDeposit\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSubId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"getDesignatedSubIdFeeTier\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeConfig\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier5\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier2\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier3\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier4\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier5\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"reqCount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"getFeeTier\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"getNodeAccessStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodesWhiteListSwitchStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequestConfig\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"getSubscription\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"reqCount\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"consumers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawableTokens\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"publicKey\",\"type\":\"uint256[2]\"}],\"name\":\"hashOfKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"oracleWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"ownerCancelSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"pendingRequestExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"publicProvingKey\",\"type\":\"uint256[2]\"}],\"name\":\"registerProvingKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"removeConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"requestRandomWords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"requestSubscriptionOwnerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxNumWords\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"maxGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gasAfterPaymentCalculation\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"subAccountMaxDeposit\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeBNBPPMTier5\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier2\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier3\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier4\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier5\",\"type\":\"uint24\"}],\"internalType\":\"struct VRFCoordinatorContract.FeeConfig\",\"name\":\"feeConfig\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"feeTier\",\"type\":\"uint32\"}],\"name\":\"setDesignatedSubIdFeeTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setNodesWhiteListSwitchStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"updateAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VRFCoordinatorContract", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000076981541c1ebc393aff7a53179c59c56b152ab55", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}