{"SourceCode": "// Sources flattened with hardhat v2.5.0 https://hardhat.org\r\n\r\n// File contracts/interfaces/IOAXDEX_VotingRegistry.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity =0.6.11;\r\n\r\ninterface IOAXDEX_VotingRegistry {\r\n    function governance() external view returns (address);\r\n    function newVote(address executor,\r\n                        bytes32 name, \r\n                        bytes32[] calldata options, \r\n                        uint256 quorum, \r\n                        uint256 threshold, \r\n                        uint256 voteEndTime,\r\n                        uint256 executeDelay, \r\n                        bytes32[] calldata executeParam\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IOAXDEX_Governance.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOAXDEX_Governance {\r\n\r\n    struct NewStake {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    struct VotingConfig {\r\n        uint256 minExeDelay;\r\n        uint256 minVoteDuration;\r\n        uint256 maxVoteDuration;\r\n        uint256 minOaxTokenToCreateVote;\r\n        uint256 minQuorum;\r\n    }\r\n\r\n    event ParamSet(bytes32 indexed name, bytes32 value);\r\n    event ParamSet2(bytes32 name, bytes32 value1, bytes32 value2);\r\n    event AddVotingConfig(bytes32 name, \r\n        uint256 minExeDelay,\r\n        uint256 minVoteDuration,\r\n        uint256 maxVoteDuration,\r\n        uint256 minOaxTokenToCreateVote,\r\n        uint256 minQuorum);\r\n    event SetVotingConfig(bytes32 indexed configName, bytes32 indexed paramName, uint256 minExeDelay);\r\n\r\n    event Stake(address indexed who, uint256 value);\r\n    event Unstake(address indexed who, uint256 value);\r\n\r\n    event NewVote(address indexed vote);\r\n    event NewPoll(address indexed poll);\r\n    event Vote(address indexed account, address indexed vote, uint256 option);\r\n    event Poll(address indexed account, address indexed poll, uint256 option);\r\n    event Executed(address indexed vote);\r\n    event Veto(address indexed vote);\r\n\r\n    function votingConfigs(bytes32) external view returns (uint256 minExeDelay,\r\n        uint256 minVoteDuration,\r\n        uint256 maxVoteDuration,\r\n        uint256 minOaxTokenToCreateVote,\r\n        uint256 minQuorum);\r\n    function votingConfigProfiles(uint256) external view returns (bytes32);\r\n\r\n    function oaxToken() external view returns (address);\r\n    function freezedStake(address) external view returns (uint256 amount, uint256 timestamp);\r\n    function stakeOf(address) external view returns (uint256);\r\n    function totalStake() external view returns (uint256);\r\n\r\n    function votingRegister() external view returns (address);\r\n    function votingExecutor(uint256) external view returns (address);\r\n    function votingExecutorInv(address) external view returns (uint256);\r\n    function isVotingExecutor(address) external view returns (bool);\r\n    function admin() external view returns (address);\r\n    function minStakePeriod() external view returns (uint256);\r\n\r\n    function voteCount() external view returns (uint256);\r\n    function votingIdx(address) external view returns (uint256);\r\n    function votings(uint256) external view returns (address);\r\n\r\n\r\n\tfunction votingConfigProfilesLength() external view returns(uint256);\r\n\tfunction getVotingConfigProfiles(uint256 start, uint256 length) external view returns(bytes32[] memory profiles);\r\n    function getVotingParams(bytes32) external view returns (uint256 _minExeDelay, uint256 _minVoteDuration, uint256 _maxVoteDuration, uint256 _minOaxTokenToCreateVote, uint256 _minQuorum);\r\n\r\n    function setVotingRegister(address _votingRegister) external;\r\n    function votingExecutorLength() external view returns (uint256);\r\n    function initVotingExecutor(address[] calldata _setVotingExecutor) external;\r\n    function setVotingExecutor(address _setVotingExecutor, bool _bool) external;\r\n    function initAdmin(address _admin) external;\r\n    function setAdmin(address _admin) external;\r\n    function addVotingConfig(bytes32 name, uint256 minExeDelay, uint256 minVoteDuration, uint256 maxVoteDuration, uint256 minOaxTokenToCreateVote, uint256 minQuorum) external;\r\n    function setVotingConfig(bytes32 configName, bytes32 paramName, uint256 paramValue) external;\r\n    function setMinStakePeriod(uint _minStakePeriod) external;\r\n\r\n    function stake(uint256 value) external;\r\n    function unlockStake() external;\r\n    function unstake(uint256 value) external;\r\n    function allVotings() external view returns (address[] memory);\r\n    function getVotingCount() external view returns (uint256);\r\n    function getVotings(uint256 start, uint256 count) external view returns (address[] memory _votings);\r\n\r\n    function isVotingContract(address votingContract) external view returns (bool);\r\n\r\n    function getNewVoteId() external returns (uint256);\r\n    function newVote(address vote, bool isExecutiveVote) external;\r\n    function voted(bool poll, address account, uint256 option) external;\r\n    function executed() external;\r\n    function veto(address voting) external;\r\n    function closeVote(address vote) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IOAXDEX_VotingContract.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOAXDEX_VotingContract {\r\n\r\n    function governance() external view returns (address);\r\n    function executor() external view returns (address);\r\n\r\n    function id() external view returns (uint256);\r\n    function name() external view returns (bytes32);\r\n    function _options(uint256) external view returns (bytes32);\r\n    function quorum() external view returns (uint256);\r\n    function threshold() external view returns (uint256);\r\n\r\n    function voteStartTime() external view returns (uint256);\r\n    function voteEndTime() external view returns (uint256);\r\n    function executeDelay() external view returns (uint256);\r\n\r\n    function executed() external view returns (bool);\r\n    function vetoed() external view returns (bool);\r\n\r\n    function accountVoteOption(address) external view returns (uint256);\r\n    function accountVoteWeight(address) external view returns (uint256);\r\n\r\n    function _optionsWeight(uint256) external view returns (uint256);\r\n    function totalVoteWeight() external view returns (uint256);\r\n    function totalWeight() external view returns (uint256);\r\n    function _executeParam(uint256) external view returns (bytes32);\r\n\r\n    function getParams() external view returns (\r\n        address executor_,\r\n        uint256 id_,\r\n        bytes32 name_,\r\n        bytes32[] memory options_,\r\n        uint256 voteStartTime_,\r\n        uint256 voteEndTime_,\r\n        uint256 executeDelay_,\r\n        bool[2] memory status_, // [executed, vetoed]\r\n        uint256[] memory optionsWeight_,\r\n        uint256[3] memory quorum_, // [quorum, threshold, totalWeight]\r\n        bytes32[] memory executeParam_\r\n    );\r\n\r\n    function veto() external;\r\n    function optionsCount() external view returns(uint256);\r\n    function options() external view returns (bytes32[] memory);\r\n    function optionsWeight() external view returns (uint256[] memory);\r\n    function execute() external;\r\n    function vote(uint256 option) external;\r\n    function updateWeight(address account) external;\r\n    function executeParam() external view returns (bytes32[] memory);\r\n}\r\n\r\n\r\n// File contracts/libraries/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/OAXDEX_VotingContract.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\ninterface IOAXDEX_VotingExecutor {\r\n    function execute(bytes32[] calldata params) external;\r\n}\r\n\r\ncontract OAXDEX_VotingContract is IOAXDEX_VotingContract {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant WEI = 10 ** 18;\r\n    \r\n    address public override governance;\r\n    address public override executor;\r\n\r\n    uint256 public override id;\r\n    bytes32 public override name;\r\n    bytes32[] public override _options;\r\n    uint256 public override quorum;\r\n    uint256 public override threshold;\r\n    \r\n    uint256 public override voteStartTime;\r\n    uint256 public override voteEndTime;\r\n    uint256 public override executeDelay;\r\n    bool public override executed;\r\n    bool public override vetoed;\r\n    \r\n\r\n    mapping (address => uint256) public override accountVoteOption;\r\n    mapping (address => uint256) public override accountVoteWeight;\r\n    uint256[] public override  _optionsWeight;\r\n    uint256 public override totalVoteWeight;\r\n    uint256 public override totalWeight;\r\n    bytes32[] public override _executeParam;\r\n\r\n    constructor(address governance_, \r\n                address executor_, \r\n                uint256 id_, \r\n                bytes32 name_, \r\n                bytes32[] memory options_, \r\n                uint256 quorum_, \r\n                uint256 threshold_, \r\n                uint256 voteEndTime_,\r\n                uint256 executeDelay_, \r\n                bytes32[] memory executeParam_\r\n               ) public {\r\n        require(block.timestamp <= voteEndTime_, 'VotingContract: Voting already ended');\r\n        if (executeParam_.length != 0){\r\n            require(IOAXDEX_Governance(governance_).isVotingExecutor(executor_), \"VotingContract: Invalid executor\");\r\n            require(options_.length == 2 && options_[0] == 'Y' && options_[1] == 'N', \"VotingContract: Invalid options\");\r\n            require(threshold_ <= WEI, \"VotingContract: Invalid threshold\");\r\n            require(executeDelay_ > 0, \"VotingContract: Invalid execute delay\");\r\n        }\r\n        governance = governance_;\r\n        executor = executor_;\r\n        totalWeight = IOAXDEX_Governance(governance).totalStake();\r\n        id = id_;\r\n        name = name_;\r\n        _options = options_;\r\n        quorum = quorum_;\r\n        threshold = threshold_;\r\n        _optionsWeight = new uint256[](options_.length);\r\n        \r\n        voteStartTime = block.timestamp;\r\n        voteEndTime = voteEndTime_;\r\n        executeDelay = executeDelay_;\r\n        _executeParam = executeParam_;\r\n    }\r\n    function getParams() external view override returns (\r\n        address executor_,\r\n        uint256 id_,\r\n        bytes32 name_,\r\n        bytes32[] memory options_,\r\n        uint256 voteStartTime_,\r\n        uint256 voteEndTime_,\r\n        uint256 executeDelay_,\r\n        bool[2] memory status_, // [executed, vetoed]\r\n        uint256[] memory optionsWeight_,\r\n        uint256[3] memory quorum_, // [quorum, threshold, totalWeight]\r\n        bytes32[] memory executeParam_\r\n    ) {\r\n        return (executor, id, name, _options, voteStartTime, voteEndTime, executeDelay, [executed, vetoed], _optionsWeight, [quorum, threshold, totalWeight], _executeParam);\r\n    }\r\n    function veto() external override {\r\n        require(msg.sender == governance, 'OAXDEX_VotingContract: Not from Governance');\r\n        require(!executed, 'OAXDEX_VotingContract: Already executed');\r\n        vetoed = true;\r\n    }\r\n    function optionsCount() external view override returns(uint256){\r\n        return _options.length;\r\n    }\r\n    function options() external view override returns (bytes32[] memory){\r\n        return _options;\r\n    }\r\n    function optionsWeight() external view override returns (uint256[] memory){\r\n        return _optionsWeight;\r\n    }\r\n    function execute() external override {\r\n        require(block.timestamp > voteEndTime.add(executeDelay), \"VotingContract: Execute delay not past yet\");\r\n        require(!vetoed, 'VotingContract: Vote already vetoed');\r\n        require(!executed, 'VotingContract: Vote already executed');\r\n        require(_executeParam.length != 0, 'VotingContract: Execute param not defined');\r\n\r\n        require(totalVoteWeight >= quorum, 'VotingContract: Quorum not met');\r\n        require(_optionsWeight[0] > _optionsWeight[1], \"VotingContract: Majority not met\"); // 0: Y, 1:N\r\n        require(_optionsWeight[0].mul(WEI) > totalVoteWeight.mul(threshold), \"VotingContract: Threshold not met\");\r\n        executed = true;\r\n        IOAXDEX_VotingExecutor(executor).execute(_executeParam);\r\n        IOAXDEX_Governance(governance).executed();\r\n    }\r\n    function vote(uint256 option) external override {\r\n        require(block.timestamp <= voteEndTime, 'VotingContract: Vote already ended');\r\n        require(!vetoed, 'VotingContract: Vote already vetoed');\r\n        require(!executed, 'VotingContract: Vote already executed');\r\n        require(option < _options.length, 'VotingContract: Invalid option');\r\n\r\n        IOAXDEX_Governance(governance).voted(_executeParam.length == 0, msg.sender, option);\r\n\r\n        uint256 currVoteWeight = accountVoteWeight[msg.sender];\r\n        if (currVoteWeight > 0){\r\n            uint256 currVoteIdx = accountVoteOption[msg.sender];    \r\n            _optionsWeight[currVoteIdx] = _optionsWeight[currVoteIdx].sub(currVoteWeight);\r\n            totalVoteWeight = totalVoteWeight.sub(currVoteWeight);\r\n        }\r\n        \r\n        uint256 weight = IOAXDEX_Governance(governance).stakeOf(msg.sender);\r\n        require(weight > 0, \"VotingContract: Not staked to vote\");\r\n        accountVoteOption[msg.sender] = option;\r\n        accountVoteWeight[msg.sender] = weight;\r\n        _optionsWeight[option] = _optionsWeight[option].add(weight);\r\n        totalVoteWeight = totalVoteWeight.add(weight);\r\n\r\n        totalWeight = IOAXDEX_Governance(governance).totalStake();\r\n    }\r\n    function updateWeight(address account) external override {\r\n        // use if-cause and don't use requrie() here to avoid revert as Governance is looping through all votings\r\n        if (block.timestamp <= voteEndTime && !vetoed && !executed){\r\n            uint256 weight = IOAXDEX_Governance(governance).stakeOf(account);\r\n            uint256 currVoteWeight = accountVoteWeight[account];\r\n            if (currVoteWeight > 0 && currVoteWeight != weight){\r\n                uint256 currVoteIdx = accountVoteOption[account];\r\n                accountVoteWeight[account] = weight;\r\n                _optionsWeight[currVoteIdx] = _optionsWeight[currVoteIdx].sub(currVoteWeight).add(weight);\r\n                totalVoteWeight = totalVoteWeight.sub(currVoteWeight).add(weight);\r\n            }\r\n            totalWeight = IOAXDEX_Governance(governance).totalStake();\r\n        }\r\n    }\r\n    function executeParam() external view override returns (bytes32[] memory){\r\n        return _executeParam;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/OAXDEX_VotingRegistry.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\ncontract OAXDEX_VotingRegistry is IOAXDEX_VotingRegistry {\r\n    using SafeMath for uint256;\r\n\r\n    address public override governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = _governance;\r\n    }\r\n\r\n    function newVote(address executor,\r\n                     bytes32 name, \r\n                     bytes32[] calldata options, \r\n                     uint256 quorum, \r\n                     uint256 threshold, \r\n                     uint256 voteEndTime,\r\n                     uint256 executeDelay, \r\n                     bytes32[] calldata executeParam\r\n    ) external override {\r\n        bool isExecutiveVote = executeParam.length != 0;\r\n        {\r\n        require(IOAXDEX_Governance(governance).isVotingExecutor(executor), \"OAXDEX_VotingRegistry: Invalid executor\");\r\n        bytes32 configName = isExecutiveVote ? executeParam[0] : bytes32(\"poll\");\r\n        (uint256 minExeDelay, uint256 minVoteDuration, uint256 maxVoteDuration, uint256 minOaxTokenToCreateVote, uint256 minQuorum) = IOAXDEX_Governance(governance).getVotingParams(configName);\r\n        uint256 staked = IOAXDEX_Governance(governance).stakeOf(msg.sender);\r\n        require(staked >= minOaxTokenToCreateVote, \"OAXDEX_VotingRegistry: minOaxTokenToCreateVote not met\");\r\n        require(voteEndTime.sub(block.timestamp) >= minVoteDuration, \"OAXDEX_VotingRegistry: minVoteDuration not met\");\r\n        require(voteEndTime.sub(block.timestamp) <= maxVoteDuration, \"OAXDEX_VotingRegistry: exceeded maxVoteDuration\");\r\n        if (isExecutiveVote) {\r\n            require(quorum >= minQuorum, \"OAXDEX_VotingRegistry: minQuorum not met\");\r\n            require(executeDelay >= minExeDelay, \"OAXDEX_VotingRegistry: minExeDelay not met\");\r\n        }\r\n        }\r\n\r\n        uint256 id = IOAXDEX_Governance(governance).getNewVoteId();\r\n        OAXDEX_VotingContract voting = new OAXDEX_VotingContract(governance, executor, id, name, options, quorum, threshold, voteEndTime, executeDelay, executeParam);\r\n        IOAXDEX_Governance(governance).newVote(address(voting), isExecutiveVote);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"options\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executeDelay\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"executeParam\",\"type\":\"bytes32[]\"}],\"name\":\"newVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OAXDEX_VotingRegistry", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000510a179aa399672e26e54ed8ce0e822cc9d0a98d", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0e27a6eb731cc3cf234a44f11fd74e47fa7891a2bfdc60d4a1f32abb03778d6d"}