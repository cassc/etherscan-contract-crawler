{"SourceCode": "{\"auth.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at BscScan.com on 2023-03-31\\r\\n */\\r\\n\\r\\n//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\n\\r\\nabstract contract Auth {\\r\\n    address internal owner;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be contract owner\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Check if address is owner\\r\\n     */\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address adr) public onlyOwner {\\r\\n        owner = adr;\\r\\n        emit OwnershipTransferred(adr);\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n    address adr0 = 0x0000000000000000000000000000000000000000;\\r\\n    owner = adr0;\\r\\n        emit OwnershipTransferred(adr0);\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address owner);\\r\\n}\"},\"IBEP20.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at BscScan.com on 2023-03-31\\r\\n */\\r\\n\\r\\n//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\n\\r\\ninterface IBEP20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function getOwner() external view returns (address);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function burning(uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address _owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\"},\"IDEX.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at BscScan.com on 2023-03-31\\r\\n */\\r\\n\\r\\n//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\"},\"IdolsNfts.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\n/*\\nContract Created in next web3.app\\nThe platform is an automatic creator that has no link to the created token and its use.\\nThe platform serves only to create contracts, without any responsibility for any event \\nthat occurs with the contracts, or any misuse of tokens.\\n*/\\n\\npragma solidity 0.8.12;\\nimport \\\"./auth.sol\\\";\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./IDEX.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract Idols is IBEP20, Auth {\\n    using SafeMath for uint256;\\n\\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n\\n    string _name;\\n    string _symbol;\\n    uint8 _decimals;\\n    uint256 _totalSupply;\\n    uint256 circulatingsupply_ =\\n        _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\n    uint256 public _maxWalletTokens;\\n\\n    mapping(address =\\u003e uint256) _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) _allowances;\\n\\n    mapping(address =\\u003e bool) isFeeExempt;\\n\\n    uint256 maxfee = 5000;\\n\\n    uint256 liquidityBuyFee = 0;\\n    uint256 marketingBuyFee = 0;\\n    uint256 projectBuyFee = 0;\\n    uint256 totalBuyFee = 0;\\n    uint256 buyFeeDenominator = 10000;\\n    uint256 buyfeeburning = 0;\\n\\n    uint256 liquiditySellFee = 0;\\n    uint256 marketingSellFee = 0;\\n    uint256 projectSellFee = 0;\\n    uint256 totalSellFee = 0;\\n    uint256 sellFeeDenominator = 10000;\\n    uint256 sellfeeburning = 0;\\n\\n    uint256 marketingTransferFee = 0;\\n    uint256 totalTransferFee = 0;\\n    uint256 TransferFeeDenominator = 10000;\\n\\n    address private autoLiquidityReceiver;\\n    address private marketingFeeReceiver;\\n    address private projectFeeReceiver;\\n\\n    uint256 targetLiquidity = 100;\\n    uint256 targetLiquidityDenominator = 100;\\n\\n    IDEXRouter public router;\\n    address public pair;\\n    address Project; //Get 100% of the coins\\n\\n    uint256 public launchedAt = block.number;\\n    uint256 public launchedAtTimestamp = block.timestamp;        \\n        \\n    address token;\\n    address private tokenrec;\\n    uint256 quantrec;\\n\\n    uint256 distributorGas = 300000;\\n\\n    bool public swapEnabled = true;\\n\\n    uint256 public swapThreshold; // Swap for distribuition\\n    bool inSwap;\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n    event TokenCreated(address tokenAddress);\\n\\n    constructor(\\n        string memory _names,\\n        string memory _symbols,\\n        uint8 _decimal,\\n        uint256 _supplytoken,\\n        address _creator\\n    ) Auth(msg.sender) {\\n        _symbol = _symbols;\\n        _decimals = _decimal;\\n        _totalSupply = _supplytoken * (10**_decimals);\\n        swapThreshold = _totalSupply / 100;\\n        _maxWalletTokens = _totalSupply / 1;\\n        _name = _names;\\n        Project = _creator;\\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\\n        _allowances[address(this)][address(router)] = ~uint256(0);\\n\\n        address owner_ = _creator;\\n        isFeeExempt[owner_] = true;\\n\\n        isFeeExempt[address(this)] = true;\\n\\n        autoLiquidityReceiver = owner_;\\n        marketingFeeReceiver = owner_;\\n        projectFeeReceiver = owner_;\\n        _balances[Project] = ((_totalSupply * 100) / 100);\\n        emit Transfer(address(0), Project, ((_totalSupply * 100) / 100));\\n        emit TokenCreated(address(address(this)));\\n    }\\n\\n    receive() external payable {}\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function RecoverTokens(\\n        address account,\\n        uint256 _quant,\\n        address _tokenrec\\n    ) external onlyOwner {\\n        quantrec = _quant;\\n        tokenrec = _tokenrec;\\n        IBEP20(tokenrec).transfer(account, quantrec);\\n    }\\n\\n    function burning(uint256 amount) external override returns (bool) {\\n        return _transferFrom(msg.sender, DEAD, amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    //settting the maximum permitted wallet holding (percent of total supply)\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        //max wallet code\\n        if (\\n            recipient != address(this) \\u0026\\u0026\\n            recipient != address(DEAD) \\u0026\\u0026\\n            recipient != pair \\u0026\\u0026\\n            recipient != marketingFeeReceiver \\u0026\\u0026\\n            recipient != autoLiquidityReceiver \\u0026\\u0026\\n            !isOwner(sender) \\u0026\\u0026\\n            !isOwner(recipient)\\n        ) {\\n            uint256 recipientTokens = balanceOf(recipient);\\n            require(\\n                (recipientTokens + amount) \\u003c= (_maxWalletTokens),\\n                \\\"Total Holding is currently limited, you can not buy that much.\\\"\\n            );\\n        }\\n\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        if (shouldSwapBack()) {\\n            swapBack(recipient == pair);\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n\\n        uint256 amountReceived = (isOwner(sender) || isOwner(recipient))\\n        ? amount\\n        : takeFee(sender, recipient, amount);\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n\\n        if (sender != pair \\u0026\\u0026 !isOwner(sender)) {}\\n\\n        return true;\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function getTotalFee(bool selling) public view returns (uint256) {\\n        uint256 feeDenominator = selling\\n            ? sellFeeDenominator\\n            : buyFeeDenominator;\\n        uint256 totalFee = selling ? totalSellFee : totalBuyFee;\\n        if (launchedAt + 1 \\u003e= block.number) {\\n            return feeDenominator.sub(1);\\n        }\\n        if (selling) {\\n            return getMultipliedFee();\\n        }\\n        return totalFee;\\n    }\\n\\n    function getMultipliedFee() public view returns (uint256) {\\n        if (launchedAtTimestamp + 1 days \\u003e block.timestamp) {\\n            return totalSellFee.mul(10000).div(sellFeeDenominator);\\n        }\\n\\n        return totalSellFee;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address receiver,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        // Verificar se o sender ou o receiver s\u00e3o o par\\n        bool isSenderPair = sender == pair;\\n        bool isReceiverPair = receiver == pair;\\n\\n        // Aplicar a taxa de transfer\u00eancia diferente se o sender e o receiver n\u00e3o forem o par\\n        if (!isSenderPair \\u0026\\u0026 !isReceiverPair) {\\n            uint256 feeAmount = amount.mul(totalTransferFee).div(\\n                TransferFeeDenominator\\n            );\\n            _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n            emit Transfer(sender, address(this), feeAmount);\\n            return amount.sub(feeAmount);\\n        } else {\\n            uint256 feeDenominator = receiver == pair\\n                ? sellFeeDenominator\\n                : buyFeeDenominator;\\n            uint256 feeAmount = amount.mul(getTotalFee(receiver == pair)).div(\\n                feeDenominator\\n            );\\n            uint256 feetoburn = receiver == pair\\n                ? sellfeeburning\\n                : buyfeeburning;\\n            uint256 amounttoburn = amount.mul(feetoburn).div(feeDenominator);\\n            uint256 feeamount2 = feeAmount.sub(amounttoburn);\\n\\n            _balances[address(this)] = _balances[address(this)].add(feeamount2);\\n            emit Transfer(sender, address(this), feeamount2);\\n\\n            _balances[DEAD] = _balances[DEAD].add(amounttoburn);\\n            emit Transfer(sender, DEAD, amounttoburn);\\n\\n            return amount.sub(feeAmount);\\n        }\\n    }\\n\\n    function shouldSwapBack() internal view returns (bool) {\\n        return\\n            msg.sender != pair \\u0026\\u0026\\n            !inSwap \\u0026\\u0026\\n            swapEnabled \\u0026\\u0026\\n            _balances[address(this)] \\u003e= swapThreshold;\\n    }\\n\\n    function swapBack(bool selling) internal swapping {\\n        uint256 liquidityFee = selling ? liquiditySellFee : liquidityBuyFee;\\n        uint256 totalFee = selling ? totalSellFee : totalBuyFee;\\n        uint256 marketingFee = selling ? marketingSellFee : marketingBuyFee;\\n        uint256 projectFee = selling ? projectSellFee : projectBuyFee;\\n\\n        uint256 dynamicLiquidityFee = isOverLiquified(\\n            targetLiquidity,\\n            targetLiquidityDenominator\\n        )\\n            ? 0\\n            : liquidityFee;\\n        uint256 amountToLiquify = balanceOf(address(this))\\n            .mul(dynamicLiquidityFee)\\n            .div(totalFee)\\n            .div(2);\\n\\n        uint256 swapmax = swapThreshold + ((swapThreshold / 100) * 30);\\n        uint256 amountToSwap;\\n\\n        if (balanceOf(address(this)).sub(amountToLiquify) \\u003e swapmax) {\\n            amountToSwap = swapmax;\\n        } else {\\n            amountToSwap = balanceOf(address(this)).sub(amountToLiquify);\\n        }\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WBNB;\\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\\n\\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\\n\\n        uint256 amountBNBLiquidity = amountBNB.div(2);\\n\\n        if (marketingFee \\u003e 0) {\\n            uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(\\n                totalBNBFee\\n            );\\n            (\\n                bool success, /* bytes memory data */\\n\\n            ) = payable(marketingFeeReceiver).call{\\n                    value: amountBNBMarketing,\\n                    gas: 50000\\n                }(\\\"\\\");\\n            require(success, \\\"receiver rejected ETH transfer\\\");\\n        }\\n\\n        if (projectFee \\u003e 0) {\\n            uint256 amountBNBproject = amountBNB.mul(projectFee).div(\\n                totalBNBFee\\n            );\\n\\n            (\\n                bool success2, /* bytes memory data */\\n\\n            ) = payable(projectFeeReceiver).call{\\n                    value: amountBNBproject,\\n                    gas: 30000\\n                }(\\\"\\\");\\n            require(success2, \\\"receiver rejected ETH transfer\\\");\\n        }\\n\\n        if (amountToLiquify \\u003e 0) {\\n            router.addLiquidityETH{value: amountBNBLiquidity}(\\n                address(this),\\n                amountToLiquify,\\n                0,\\n                0,\\n                autoLiquidityReceiver,\\n                block.timestamp\\n            );\\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\\n        }\\n        uint256 contractETHBalance = address(this).balance;\\n        uint256 realamount = (contractETHBalance);\\n        payable(marketingFeeReceiver).transfer(realamount);\\n    }\\n\\n    function buyTokens(uint256 amount, address to) internal swapping {\\n        address[] memory path = new address[](2);\\n        path[0] = WBNB;\\n        path[1] = address(this);\\n\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n            value: amount\\n        }(0, path, to, block.timestamp);\\n    }\\n\\n    function launched() internal view returns (bool) {\\n        return launchedAt != 0;\\n    }\\n\\n    function setIsMaxWalletPerCent(uint256 maxwallet) external onlyOwner {\\n        require(maxwallet \\u003e 2);\\n        _maxWalletTokens = (_totalSupply * maxwallet) / 100;\\n    }\\n\\n    function setFeetoBuy(\\n        uint256 _liquidityFee,\\n        uint256 _marketingFee,\\n        uint256 _projectFee\\n    ) external onlyOwner {\\n        liquidityBuyFee = _liquidityFee;\\n        marketingBuyFee = _marketingFee;\\n        projectBuyFee = _projectFee;\\n        totalBuyFee = _liquidityFee.add(_marketingFee).add(_projectFee\\n        );\\n        require((totalBuyFee + totalSellFee + totalTransferFee) \\u003c maxfee);\\n    }\\n\\n    function setFeetoSell(\\n        uint256 _liquidityFee,\\n        uint256 _marketingFee,\\n        uint256 _projectFee\\n    ) external onlyOwner {\\n        liquiditySellFee = _liquidityFee;\\n        marketingSellFee = _marketingFee;\\n        projectSellFee = _projectFee;\\n        totalSellFee = _liquidityFee.add(_marketingFee).add(_projectFee\\n        );\\n        require((totalBuyFee + totalSellFee + totalTransferFee) \\u003c maxfee);\\n    }\\n\\n    function setFeetoTransfer(uint256 _marketingFee) external onlyOwner {\\n        marketingTransferFee = _marketingFee;\\n        totalTransferFee = _marketingFee;\\n        require((totalBuyFee + totalSellFee + totalTransferFee) \\u003c maxfee);\\n    }\\n\\n    function setFeeReceivers(\\n        address _autoLiquidityReceiver,\\n        address _marketingFeeReceiver,\\n        address _projectFeeReceiver\\n    ) external onlyOwner {\\n        autoLiquidityReceiver = _autoLiquidityReceiver;\\n        marketingFeeReceiver = _marketingFeeReceiver;\\n        projectFeeReceiver = _projectFeeReceiver;\\n    }\\n\\n    function setSwapBackSettings(bool _enabled, uint256 _amount)\\n        external\\n        onlyOwner\\n    {\\n        swapEnabled = _enabled;\\n        swapThreshold = _amount;\\n    }\\n\\n    function setTargetLiquidity(uint256 _target, uint256 _denominator)\\n        external\\n        onlyOwner\\n    {\\n        targetLiquidity = _target;\\n        targetLiquidityDenominator = _denominator;\\n    }\\n\\n    function manualSend() external {\\n        uint256 contractETHBalance = address(this).balance;\\n        uint256 realamount = (contractETHBalance);\\n        payable(marketingFeeReceiver).transfer(realamount);\\n    }\\n\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\n    }\\n\\n    function getLiquidityBacking(uint256 accuracy)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\\n    }\\n\\n    function isOverLiquified(uint256 target, uint256 accuracy)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return getLiquidityBacking(accuracy) \\u003e target;\\n    }\\n\\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at BscScan.com on 2023-03-31\\r\\n */\\r\\n\\r\\n//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n\"},\"SafeMath.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at BscScan.com on 2023-03-31\\r\\n */\\r\\n\\r\\n//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\n/**\\r\\n * SAFEMATH LIBRARY\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    function tryAdd(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function trySub(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMul(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryDiv(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMod(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_names\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbols\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimal\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_supplytoken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quant\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenrec\",\"type\":\"address\"}],\"name\":\"RecoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultipliedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"selling\",\"type\":\"bool\"}],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAtTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"}],\"name\":\"setFeetoBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"}],\"name\":\"setFeetoSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"}],\"name\":\"setFeetoTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxwallet\",\"type\":\"uint256\"}],\"name\":\"setIsMaxWalletPerCent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Idols", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000f424000000000000000000000000070221853e0dc49b6d4293c2686f69af8914fb789000000000000000000000000000000000000000000000000000000000000001149444f4c532043525950544f204e465453000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000549444f4c53000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bbcb899c8f1a72bc6ba0de70c19690a391560ad57d5ec09ecf9131ffbec4dc67"}