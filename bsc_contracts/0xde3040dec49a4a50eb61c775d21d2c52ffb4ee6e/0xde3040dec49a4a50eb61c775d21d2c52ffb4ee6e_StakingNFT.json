{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.18;\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n \r\n\r\ninterface IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n \r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n \r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n \tfunction add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n \t\tuint256 c = a + b;\r\n \t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n \t\treturn c;\r\n \t}\r\n\r\n \tfunction sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n \t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n \t}\r\n\r\n \tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n \t\trequire(b <= a, errorMessage);\r\n \t\tuint256 c = a - b;\r\n \t\treturn c;\r\n \t}\r\n\r\n \tfunction mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n \t\t// benefit is lost if 'b' is also tested.\r\n \t\tif (a == 0) {\r\n \t\t\treturn 0;\r\n \t\t}\r\n \t\tuint256 c = a * b;\r\n \t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n \t\treturn c;\r\n \t}\r\n\r\n \tfunction div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n \t\treturn div(a, b, \"SafeMath: division by zero\");\r\n \t}\r\n\r\n \tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n \t\trequire(b > 0, errorMessage);\r\n \t\tuint256 c = a / b;\r\n \t\treturn c;\r\n \t}\r\n\r\n \tfunction mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n \t\treturn mod(a, b, \"SafeMath: modulo by zero\");\r\n \t}\r\n\r\n \tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n \t\trequire(b != 0, errorMessage);\r\n \t\treturn a % b;\r\n \t}\r\n }\r\n\r\n\r\n \r\n library Address {\r\n \tfunction isContract(address account) internal view returns(bool) {\r\n \t\tbytes32 codehash;\r\n \t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n \t\tassembly {\r\n \t\t\tcodehash:= extcodehash(account)\r\n \t\t}\r\n \t\treturn (codehash != accountHash && codehash != 0x0);\r\n \t}\r\n\r\n \tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n \t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n \t\t(bool success, ) = recipient.call {\r\n \t\t\tvalue: amount\r\n \t\t}(\"\");\r\n \t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n \t}\r\n\r\n \tfunction functionCall(address target, bytes memory data) internal returns(bytes memory) {\r\n \t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n \t}\r\n\r\n \tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n \t\treturn _functionCallWithValue(target, data, 0, errorMessage);\r\n \t}\r\n\r\n \tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns(bytes memory) {\r\n \t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n \t}\r\n\r\n \tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns(bytes memory) {\r\n \t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n \t\treturn _functionCallWithValue(target, data, value, errorMessage);\r\n \t}\r\n\r\n \tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns(bytes memory) {\r\n \t\trequire(isContract(target), \"Address: call to non-contract\");\r\n \t\t(bool success, bytes memory returndata) = target.call {\r\n \t\t\tvalue: weiValue\r\n \t\t}(data);\r\n \t\tif (success) {\r\n \t\t\treturn returndata;\r\n \t\t} else {\r\n \t\t\tif (returndata.length > 0) {\r\n\r\n \t\t\t\tassembly {\r\n \t\t\t\t\tlet returndata_size:= mload(returndata)\r\n \t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n \t\t\t\t}\r\n \t\t\t} else {\r\n \t\t\t\trevert(errorMessage);\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n }\r\n \r\n\r\n  \r\n\r\n  contract Ownable is Context {\r\n \taddress private _owner;\r\n \tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n \tconstructor() {\r\n \t\taddress msgSender = _msgSender();\r\n \t\t_owner = msgSender;\r\n \t\temit OwnershipTransferred(address(0), msgSender);\r\n \t}\r\n\r\n \tfunction owner() public view returns(address) {\r\n \t\treturn _owner;\r\n \t}\r\n \tmodifier onlyOwner() {\r\n \t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n \t\t_;\r\n \t}\r\n\r\n \tfunction renounceOwnership() public virtual onlyOwner {\r\n \t\temit OwnershipTransferred(_owner, address(0));\r\n \t\t_owner = address(0);\r\n \t}\r\n\r\n \tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n \t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n \t\temit OwnershipTransferred(_owner, newOwner);\r\n \t\t_owner = newOwner;\r\n \t}\r\n }\r\n\r\n\r\n  \r\n \r\ncontract StakingNFT is Ownable, IERC721Receiver {\r\n \tusing SafeMath\r\n \tfor uint256;\r\n    \r\n    address NFT  = 0x5E2E95e68Fd77b4aAf9b07adf10A4d927f4A31eC;\r\n    address TOKEN = 0x5f4b7DA9EF2eeD3F55770e4BB18Cf90F104afB42;\r\n\r\n    struct  config {\r\n    uint256 continue_stakefee ;\r\n    uint256 restake_fee ;\r\n    uint256[] reward;\r\n    uint256 timelock;\r\n    uint256 referral_percent;\r\n    uint256 airdropidfrom;\r\n    uint256 airdropidto;\r\n   \r\n    }\r\n    config public configs;\r\n\r\n   //log register\r\n    struct user {\r\n            address upline;\r\n            address addr;\r\n            uint256 timestamp;\r\n        }\r\n    user[] public users;\r\n    uint256 public  users_length=0;\r\n    mapping(address => bool) public registered;\r\n   \r\n    //log staking\r\n    struct staking {\r\n            address addr;\r\n            uint256 tokenid;\r\n            uint256 timestamp;\r\n            uint256 nftclass;\r\n            bool thisIn;\r\n\r\n        }\r\n    staking[] public stakings;\r\n    uint256 public  stakings_length;\r\n \r\n    uint256[] stakednft;\r\n\r\n\r\n     //log staking\r\n    struct nft {\r\n            address addr;\r\n            uint256 timestamp;\r\n            uint256 lastclaim;\r\n            uint256 rewardpersecond;\r\n            uint256 nftclass;\r\n        }\r\n     mapping(uint256 => nft) public nfts;\r\n\r\n\r\n    //log staking user\r\n    struct nftl {\r\n            uint256 timestamp;\r\n            uint256 tokenId;\r\n            bool thisIn;\r\n        }\r\n     mapping(address => nftl[]) public nftlogs;\r\n     mapping(address => uint256) public nftlogs_length;\r\n     mapping(address => uint256) public affiliate_reward;\r\n     mapping(uint256 => bool) public hasbeenstake;\r\n\r\n    //data user\r\n    struct userstate {\r\n            address upline;\r\n            address addr; \r\n        }\r\n    mapping(address => userstate) public userstates;\r\n\r\n    \r\n    constructor() {\r\n\r\n        configs.continue_stakefee = 1e18 ;\r\n        configs.restake_fee = 1e18 ;\r\n        configs.reward =[1e15,1e15,1e15,1e15,1e15,1e15];\r\n        configs.referral_percent = 5;\r\n        configs.airdropidfrom = 95001; // fix and unable to update\r\n        configs.airdropidto   = 100000; // fix and unable to update\r\n        stakednft=[0,0,0,0,0,0];\r\n        configs.timelock = 10000; //in second\r\n         \r\n        //initial affiliate \r\n        users.push(user({\r\n                upline :msg.sender,\r\n                addr   :msg.sender,\r\n                timestamp :block.timestamp\r\n                }));\r\n        users_length++;\r\n        registered[msg.sender] =true;\r\n    \r\n    }\r\n\r\n   function extend(uint256 tokenId) public {\r\n          //fee extend\r\n          claim_staking_reward(tokenId);\r\n          nft storage nftdata = nfts[tokenId];\r\n          if(nftdata.addr==address(0))return;\r\n\r\n          uint256 fee_by_class = configs.continue_stakefee;\r\n          if(nftdata.nftclass==1)fee_by_class = configs.continue_stakefee.mul(10);\r\n          if(nftdata.nftclass==2)fee_by_class = configs.continue_stakefee.mul(50);\r\n          if(nftdata.nftclass==3)fee_by_class = configs.continue_stakefee.mul(100);\r\n          if(nftdata.nftclass==4)fee_by_class = configs.continue_stakefee.mul(250);\r\n          if(nftdata.nftclass==5)fee_by_class = configs.continue_stakefee.mul(500);\r\n\r\n          IERC20(TOKEN).transferFrom(msg.sender, address(this),configs.continue_stakefee.mul(fee_by_class));\r\n          if(nftdata.timestamp<block.timestamp) nftdata.timestamp = block.timestamp.add(configs.timelock);\r\n          else\r\n          nftdata.timestamp = nftdata.timestamp.add(configs.timelock);\r\n          nftdata.rewardpersecond = configs.reward[nftdata.nftclass];\r\n          nftdata.lastclaim = block.timestamp;\r\n   }\r\n\r\n\r\n    function reconfig(uint256 continue_stakefee,uint256 restake_fee ,uint256  reward1,uint256  reward2,uint256  reward3,uint256  reward4,uint256  reward5,uint256  reward6,uint256 timelock,uint256 referral_percent ) public onlyOwner  {\r\n        if(continue_stakefee>0) configs.continue_stakefee = continue_stakefee; //optional users to stop or continue\r\n        if(restake_fee>0) configs.restake_fee = restake_fee; //optional user to restake old nft or not\r\n        if(reward1>0)configs.reward[0] = reward1;//unable set to zero\r\n        if(reward2>0)configs.reward[1] = reward2;//unable set to zero\r\n        if(reward3>0)configs.reward[2] = reward3;//unable set to zero\r\n        if(reward4>0)configs.reward[3] = reward4;//unable set to zero\r\n        if(reward5>0)configs.reward[4] = reward5;//unable set to zero\r\n        if(reward6>0)configs.reward[5] = reward6;//unable set to zero\r\n        if(timelock<=15780000 )configs.timelock = timelock;//max timelock is 6 months\r\n        if(referral_percent>0 &&referral_percent<=100)configs.referral_percent=referral_percent;//set uppline commission\r\n    }\r\n\r\n\r\n     function stake( address upline,uint256 tokenId) public {\r\n      userstate storage userdetail = userstates[msg.sender];\r\n      require(tokenId>0,\"Require nft id\");\r\n\r\n      //airdrop unable to intial staking\r\n      if(tokenId>=configs.airdropidfrom && tokenId<=configs.airdropidto){\r\n          if(registered[msg.sender]==false){\r\n        return;\r\n       } \r\n      }\r\n\r\n           nft storage nftdata = nfts[tokenId];\r\n     \r\n           if(hasbeenstake[tokenId]){\r\n                //fee restake\r\n                uint256 fee_by_class = configs.restake_fee;\r\n                if(nftdata.nftclass==1)fee_by_class = configs.restake_fee.mul(10);\r\n                if(nftdata.nftclass==2)fee_by_class = configs.restake_fee.mul(50);\r\n                if(nftdata.nftclass==3)fee_by_class = configs.restake_fee.mul(100);\r\n                if(nftdata.nftclass==4)fee_by_class = configs.restake_fee.mul(250);\r\n                if(nftdata.nftclass==5)fee_by_class = configs.restake_fee.mul(500);\r\n                \r\n                IERC20(TOKEN).transferFrom(msg.sender, address(this),fee_by_class);\r\n            }\r\n            else \r\n            if(registered[msg.sender]){\r\n\r\n            } else  //register log neet upline address\r\n            if(upline != address(0) && registered[upline]) {\r\n\r\n                users.push(user({\r\n                upline:upline,\r\n                addr:msg.sender,\r\n                timestamp :block.timestamp\r\n                }));\r\n                users_length++;\r\n                registered[msg.sender] =true;\r\n            }\r\n\r\n           hasbeenstake[tokenId]=true;\r\n           IERC721(NFT).safeTransferFrom(msg.sender, address(this), tokenId);\r\n\r\n\r\n            //find class nft\r\n             uint256 a=5;\r\n             if(tokenId<=100000) a=0;\r\n             else\r\n             if(tokenId<=110000) a=1;\r\n             else\r\n             if(tokenId<=115000) a=2;\r\n             else\r\n             if(tokenId<=117500) a=3;\r\n             else\r\n             if(tokenId<=118500) a=4;\r\n\r\n\r\n           \r\n           nftdata.addr = msg.sender;\r\n           nftdata.timestamp = block.timestamp.add(configs.timelock);\r\n           nftdata.lastclaim = block.timestamp;\r\n           nftdata.rewardpersecond = configs.reward[a];\r\n           nftdata.nftclass=a;\r\n\r\n            stakings.push(staking({\r\n                addr:msg.sender,\r\n                tokenid:tokenId,\r\n                timestamp:block.timestamp,\r\n                nftclass:a,\r\n                thisIn:true\r\n            }));\r\n\r\n            nftlogs[msg.sender].push(nftl({\r\n              tokenId:tokenId,\r\n              timestamp: nftdata.timestamp,\r\n              thisIn:true\r\n           }));\r\n\r\n            userdetail.addr=msg.sender;\r\n            if(upline != address(0)&&userdetail.upline==address(0)){ \r\n                userdetail.upline = upline;\r\n            }\r\n            stakings_length++;\r\n            stakednft[a]++;\r\n            nftlogs_length[msg.sender]++;\r\n\r\n \r\n      }\r\n\r\n \r\n\r\n    function pendingreward(uint256 tokenId) public view returns(uint256) {\r\n        nft storage nftdata = nfts[tokenId];\r\n        if(nftdata.addr==address(0)) return 0;\r\n        if(nftdata.timestamp < block.timestamp) {\r\n            if(nftdata.timestamp<=nftdata.lastclaim)\r\n            return 0;\r\n            else {\r\n                 return (nftdata.timestamp.sub(nftdata.lastclaim).mul(nftdata.rewardpersecond));\r\n            }\r\n       \r\n        }\r\n        uint256 r1 = block.timestamp.sub(nftdata.lastclaim).mul(nftdata.rewardpersecond);\r\n        return  r1 ;\r\n     }\r\n\r\n\r\n    // anyone can help to process claim reward\r\n    function claim_affiliate(address addr) public  {\r\n        uint256 pending = affiliate_reward[addr];\r\n        if(pending>0){\r\n             affiliate_reward[addr] = 0;\r\n             IERC20(TOKEN).transfer(addr,pending);\r\n        }\r\n    }\r\n\r\n     // anyone can help to process claim reward\r\n    function claim_my_affiliate() public  {\r\n        uint256 pending = affiliate_reward[msg.sender];\r\n        if(pending>0){\r\n             affiliate_reward[msg.sender] = 0;\r\n             IERC20(TOKEN).transfer(msg.sender,pending);\r\n        }\r\n    }\r\n\r\n\r\n    // anyone can help to process claim reward\r\n    function claim_staking_reward(uint256 tokenId) public  {\r\n       uint256 pending = pendingreward(tokenId);\r\n       nft storage nftdata = nfts[tokenId];\r\n          if(pending>0){\r\n                 userstate storage userdetail = userstates[nftdata.addr];\r\n                 if(userdetail.upline != address(0)){\r\n                    affiliate_reward[userdetail.upline] = affiliate_reward[userdetail.upline].add(pending.mul(configs.referral_percent).div(100));\r\n                 }\r\n                 IERC20(TOKEN).transfer(nftdata.addr,pending);\r\n          }\r\n        nftdata.lastclaim = block.timestamp;\r\n        nftdata.rewardpersecond = configs.reward[nftdata.nftclass];\r\n     }\r\n\r\n\r\n    function configinfo_reward() public view returns(uint256,uint256,uint256,uint256,uint256,uint256) {\r\n      return (\r\n           configs.reward[0]>0?configs.reward[0]:0,\r\n           configs.reward[1]>0?configs.reward[1]:0,\r\n           configs.reward[2]>0?configs.reward[2]:0,\r\n           configs.reward[3]>0?configs.reward[3]:0,\r\n           configs.reward[4]>0?configs.reward[4]:0,\r\n           configs.reward[5]>0?configs.reward[5]:0\r\n       );\r\n\r\n    }\r\n\r\n    function globalstake() public view returns(uint256,uint256,uint256,uint256,uint256,uint256) {\r\n       return (\r\n        stakednft[0]>0?stakednft[0]:0,\r\n        stakednft[1]>0?stakednft[1]:0,\r\n        stakednft[2]>0?stakednft[2]:0,\r\n        stakednft[3]>0?stakednft[3]:0,\r\n        stakednft[4]>0?stakednft[4]:0,\r\n        stakednft[5]>0?stakednft[5]:0\r\n         );\r\n    }\r\n\r\n   \r\n    \r\n    function unstake(uint256 tokenId) public {\r\n        require(tokenId>0,\"Require tokenId\");\r\n        claim_staking_reward(tokenId);\r\n    \r\n        nft storage nftdata = nfts[tokenId];\r\n        if(nftdata.timestamp<=block.timestamp && nftdata.addr==msg.sender){\r\n            IERC721(NFT).safeTransferFrom(address(this),msg.sender, tokenId);\r\n\r\n            //reset data after wd\r\n            nftdata.addr = address(0);\r\n            nftdata.timestamp = 0;\r\n            nftdata.lastclaim = 0;\r\n\r\n            stakednft[nftdata.nftclass]--;\r\n\r\n            stakings.push(staking({\r\n                addr:msg.sender,\r\n                tokenid:tokenId,\r\n                timestamp:block.timestamp,\r\n                nftclass : nftdata.nftclass,\r\n                thisIn:false\r\n            }));\r\n\r\n            nftlogs[msg.sender].push(nftl({\r\n                tokenId:tokenId,\r\n                timestamp: nftdata.timestamp,\r\n                thisIn:false\r\n            })); \r\n\r\n            nftlogs_length[msg.sender]++;\r\n            stakings_length++;\r\n         }\r\n         \r\n      }\r\n     \r\n\r\n\r\n     function emergency(uint256 tokenId) public {\r\n        require(tokenId>0,\"Require tokenId\");\r\n      \r\n           nft storage nftdata = nfts[tokenId];\r\n           if(nftdata.timestamp<=block.timestamp && nftdata.addr==msg.sender){\r\n           IERC721(NFT).safeTransferFrom(address(this),msg.sender, tokenId);\r\n\r\n           //reset data after wd\r\n           nftdata.addr = address(0);\r\n           nftdata.timestamp = 0;\r\n           nftdata.lastclaim = 0;\r\n\r\n            stakednft[nftdata.nftclass]--;\r\n            stakings.push(staking({\r\n                addr:msg.sender,\r\n                tokenid:tokenId,\r\n                timestamp:block.timestamp,\r\n                nftclass:nftdata.nftclass,\r\n                thisIn:false\r\n            }));\r\n            stakings_length++;\r\n\r\n            nftlogs[msg.sender].push(nftl({\r\n              tokenId:tokenId,\r\n              timestamp: nftdata.timestamp,\r\n              thisIn:false\r\n           }));\r\n\r\n           nftlogs_length[msg.sender]++;\r\n\r\n         }\r\n        \r\n\r\n    }\r\n     \r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliate_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claim_affiliate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim_my_affiliate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claim_staking_reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configinfo_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"continue_stakefee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restake_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral_percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdropidfrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdropidto\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"emergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"extend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasbeenstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftlogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"thisIn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nftlogs_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nfts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastclaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardpersecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftclass\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"pendingreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"continue_stakefee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restake_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral_percent\",\"type\":\"uint256\"}],\"name\":\"reconfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftclass\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"thisIn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakings_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"users_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userstates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingNFT", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://79b67135a4f69a28eb98d92abfc145ed88c63bb4f2b0ef9797833852d7c5ec96"}