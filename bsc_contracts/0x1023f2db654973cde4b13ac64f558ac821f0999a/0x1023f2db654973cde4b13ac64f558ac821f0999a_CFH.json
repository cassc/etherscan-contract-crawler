{"SourceCode": "pragma solidity 0.8.4;\r\n// SPDX-License-Identifier: MIT\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n      uint c = a + b;\r\n      require(c >= a, \"SafeMath: addition overflow\");\r\n      return c;\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n      return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n      require(b <= a, errorMessage);\r\n      uint c = a - b;\r\n      return c;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      uint c = a * b;\r\n      require(c / a == b, \"SafeMath: multiplication overflow\");\r\n      return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n      return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n      // Solidity only automatically asserts when dividing by 0\r\n      require(b > 0, errorMessage);\r\n      uint c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n      return c;\r\n    }\r\n    function mod(uint a, uint b) internal pure returns (uint) {\r\n      return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n      require(b != 0, errorMessage);\r\n      return a % b;\r\n    }\r\n}\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ncontract CFH is Context, IERC20, Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    address fundaddress1 = 0xFb4c65893eDda75e0604a31d5fe7c7122956A68B;//\u751f\u6001\u5efa\u8bbe\uff1a0.5%\r\n    address fundaddress2 = 0x286bA5434081439CA4db990F830124BA8850Bda1;//\u6316\u77ff \u57fa\u91d1\u4f1a\uff1a0.5%\r\n    address shareaddress = 0x4288fB994D01Aa98D1fC56E354676E9DdA9859Ec;//\u4e00\u4ee3\u4e8c\u4ee3\u5206\u4eab\u5956\u52b1/\u5e95\u6c60\u5730\u5740\r\n    address lpaddress = 0x3CD22D23dC6dBff7DD07AA6a7B428f1DF14245F1;//LP\u5206\u7ea2\uff0c\u6dfb\u52a0\u8d44\u91d1\u6c600.5%\r\n    address usdt = 0x55d398326f99059fF775485246999027B3197955;\r\n    address pair;\r\n\r\n    address lasttradeaddress;\r\n\r\n    mapping (address => uint) private _balances;\r\n    mapping (address => mapping (address => uint)) private _allowances;\r\n     \r\n    mapping (address => bool) public isWhite;\r\n\r\n    struct UserInfo {\r\n        address inviter;//\u6211\u7684\u9080\u8bf7\u4eba\r\n        uint lastminetime;//\u4e0a\u4e00\u6b21\u6316\u77ff\u65f6\u95f4\r\n        uint lastswapnum;//\u4e0a\u4e00\u6b21\u4ea4\u6613\u6570\u91cf\r\n        uint lastswapprice;//\u4e0a\u4e00\u6b21\u4ea4\u6613\u65f6\u7684\u5e01\u4ef7\r\n        uint lpvalue;//\u7528\u6237\u6dfb\u52a0\u6c60\u5b50\u65f6\u5019\u7684\u4ef7\u503c\u603b\u548c\r\n        uint lpamount;//\u7528\u6237lp\u6570\u91cf\r\n        uint tradetype;//1=add,2=remove,3=transfer\r\n        bool isinlist;//\u662f\u5426\u5728lp\u5206\u7ea2\u540d\u5355\r\n    }\r\n    mapping(address => UserInfo) public userInfo;\r\n    address[] public LpHoldList;\r\n\r\n    uint fundfee1 = 5;//\u751f\u6001\u5efa\u8bbe\uff1a0.5%\r\n    uint fundfee2 = 5;//\u6316\u77ff \u57fa\u91d1\u4f1a\uff1a0.5%\r\n    uint inviterfee1 = 6;//\u4e00\u4ee3\u9080\u8bf7\u4eba 0.6%\r\n    uint inviterfee2 = 4;//\u4e8c\u4ee3\u9080\u8bf7\u4eba 0.4%\r\n    uint lpfee = 5;//0.5%\r\n    uint burnfee = 10;//1%\r\n    uint public minetotalamount;\r\n\r\n    uint private constant E9 = 1000000000;\r\n    uint private constant E18 = 1000000000000000000;\r\n    uint private constant MAX = ~uint(0);\r\n    uint private _totalSupply = 100000 * E18;\r\n    uint private _decimals = 18;\r\n    string private _symbol = \"CFH\";\r\n    string private _name = \"CFH\";\r\n\r\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n\r\n    bool inSwap;\r\n    modifier lockTheSwap {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    constructor(){\r\n\r\n        _balances[shareaddress] = _totalSupply.mul(30).div(1000);\r\n        _balances[address(this)] = _totalSupply.mul(970).div(1000);\r\n        minetotalamount = _totalSupply.mul(970).div(1000);\r\n        IUniswapV2Router02 Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pair = IUniswapV2Factory(Router.factory()).createPair(address(this), usdt);\r\n        uniswapV2Router = Router;\r\n        isWhite[shareaddress] = true;\r\n        isWhite[lpaddress] = true;\r\n        isWhite[fundaddress1] = true;\r\n        isWhite[fundaddress2] = true;\r\n        isWhite[owner()] = true;\r\n        isWhite[address(this)] = true;\r\n        emit Transfer(address(0), shareaddress, _totalSupply.mul(30).div(1000));\r\n        emit Transfer(address(0), address(this), _totalSupply.mul(970).div(1000));\r\n    }\r\n    receive() external payable {}\r\n\r\n    function decimals() public view  returns(uint) {\r\n        return _decimals;\r\n    }\r\n    function symbol() public view  returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function name() public view  returns (string memory) {\r\n        return _name;\r\n    }\r\n    function totalSupply() public override view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public override view returns (uint) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view override returns (uint) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint amount) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n    function getLpHoldList() view external returns(address[] memory){\r\n        return LpHoldList;\r\n    }\r\n    function setFundWallet(address newaddress1,address newaddress2) external onlyOwner { \r\n        fundaddress1 = newaddress1;\r\n        fundaddress2 = newaddress2;\r\n    }\r\n\r\n    function _transfer(address sender, address to, uint amount) internal {\r\n\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(_balances[sender] > amount,\"can not sell all\");\r\n\r\n        uint reallpamount = IUniswapV2Pair(pair).balanceOf(lasttradeaddress);\r\n        uint lastlpamount = userInfo[lasttradeaddress].lpamount;\r\n \r\n        if(lasttradeaddress != address(0) && reallpamount > 0 && !userInfo[lasttradeaddress].isinlist){\r\n            LpHoldList.push(lasttradeaddress);\r\n            userInfo[lasttradeaddress].isinlist = true;\r\n        }\r\n\r\n        if(lasttradeaddress != address(0) && (reallpamount != lastlpamount || userInfo[lasttradeaddress].tradetype == 4)){\r\n            uint valuechanged = (userInfo[lasttradeaddress].lastswapnum).mul(userInfo[lasttradeaddress].lastswapprice).mul(2);\r\n            if(userInfo[lasttradeaddress].tradetype == 1){\r\n                userInfo[lasttradeaddress].lpvalue += valuechanged;\r\n            }else if(userInfo[lasttradeaddress].tradetype == 4){\r\n                if(userInfo[lasttradeaddress].lpvalue > valuechanged){\r\n                    userInfo[lasttradeaddress].lpvalue -= valuechanged;\r\n                }else{\r\n                    userInfo[lasttradeaddress].lpvalue = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(userInfo[sender].lpvalue > 0 && sender != pair && to != pair && !isWhite[sender] && !isWhite[to] && userInfo[to].inviter == address(0)){\r\n            userInfo[to].inviter = sender;\r\n        }\r\n\r\n        uint lpvalue = userInfo[lasttradeaddress].lpvalue;\r\n        uint lastminetime = userInfo[lasttradeaddress].lastminetime;\r\n        if(lpvalue >= 100*E18*E9 && lastminetime == 0 && lasttradeaddress != address(0)){\r\n            userInfo[lasttradeaddress].lastminetime = block.timestamp;\r\n        }else if(lpvalue < 100*E18*E9 && lasttradeaddress != address(0)){\r\n            userInfo[lasttradeaddress].lastminetime = 0;\r\n        }\r\n\r\n        if((sender == pair || to == pair) && !isWhite[sender] && !isWhite[to]){\r\n            address user = sender == pair ? to : sender ;\r\n            uint _lpvalue = userInfo[user].lpvalue;\r\n            uint _lastminetime = userInfo[user].lastminetime;\r\n            if(_lpvalue >= 100*E18*E9 && _lastminetime != 0 && block.timestamp.sub(_lastminetime) >= 86400){\r\n                trademine(user,_lpvalue,amount);\r\n                userInfo[user].lastminetime = block.timestamp;\r\n            }\r\n        }\r\n\r\n        uint price;\r\n\r\n        if(_balances[pair] != 0){\r\n            price = (IERC20(usdt).balanceOf(pair)).mul(E9).div(_balances[pair]);\r\n        }\r\n        \r\n        if(isWhite[sender] || isWhite[to] || (sender != pair && to != pair)){\r\n            _tokenTransfer(sender,to,amount,false);\r\n        }else{\r\n            _tokenTransfer(sender,to,amount,true);\r\n        }\r\n        \r\n        if(to == pair){\r\n            price = (IERC20(usdt).balanceOf(pair)).mul(E9).div(_balances[pair]); \r\n        }\r\n\r\n        if(sender == pair){\r\n\r\n            lasttradeaddress = to;\r\n            userInfo[to].lastswapnum = amount;\r\n            userInfo[to].lastswapprice = price;\r\n            if(IUniswapV2Pair(pair).balanceOf(to) < userInfo[to].lpamount){\r\n                userInfo[to].tradetype = 4;\r\n            }else{\r\n                userInfo[to].tradetype = 2;\r\n            }\r\n            userInfo[to].lpamount = IUniswapV2Pair(pair).balanceOf(to);\r\n            \r\n        }else if(to == pair){\r\n\r\n            lasttradeaddress = sender;\r\n            userInfo[sender].lastswapnum = amount;\r\n            userInfo[sender].lastswapprice = price;\r\n            userInfo[sender].tradetype = 1;\r\n            userInfo[sender].lpamount = IUniswapV2Pair(pair).balanceOf(sender);\r\n\r\n        }else{\r\n            lasttradeaddress = address(0);\r\n            userInfo[to].tradetype = 3;\r\n        }\r\n    }\r\n    function _tokenTransfer(address sender, address to, uint amount, bool ishaveFee) private {\r\n\r\n        if(!ishaveFee){\r\n\r\n            _balances[sender] = _balances[sender].sub(amount);\r\n            _balances[to] = _balances[to].add(amount);\r\n            emit Transfer(sender, to, amount);\r\n\r\n        }else{\r\n            \r\n            address inviter;\r\n            address inviter2;\r\n\r\n            uint fundamount1 = amount.mul(fundfee1).div(1000);\r\n            uint lpamount = amount.mul(lpfee).div(1000);\r\n            uint burnfeeamount = amount.mul(burnfee).div(1000);\r\n            uint inviterfeeamount1 = amount.mul(inviterfee1).div(1000);\r\n            uint inviterfeeamount2 = amount.mul(inviterfee2).div(1000);\r\n            \r\n            uint leftamount = amount.sub(fundamount1.add(lpamount).add(burnfeeamount).add(inviterfeeamount1).add(inviterfeeamount2));\r\n\r\n            _balances[sender] = _balances[sender].sub(amount);\r\n\r\n            _balances[fundaddress1] = _balances[fundaddress1].add(fundamount1);\r\n            _balances[lpaddress] = _balances[lpaddress].add(lpamount);\r\n            _balances[address(0)] = _balances[address(0)].add(burnfeeamount);\r\n            if(sender == pair){\r\n                inviter = userInfo[to].inviter == address(0) ? shareaddress : userInfo[to].inviter;\r\n            }else{\r\n                inviter = userInfo[sender].inviter == address(0) ? shareaddress : userInfo[sender].inviter;\r\n            }\r\n            inviter2 = userInfo[inviter].inviter == address(0) ? shareaddress : userInfo[inviter].inviter;\r\n\r\n            _balances[inviter] = _balances[inviter].add(inviterfeeamount1);\r\n            _balances[inviter2] = _balances[inviter2].add(inviterfeeamount2);\r\n\r\n            _balances[to] = _balances[to].add(leftamount);\r\n\r\n            emit Transfer(sender, fundaddress1, fundamount1);\r\n            emit Transfer(sender, lpaddress, lpamount);\r\n            emit Transfer(sender, address(0), burnfeeamount);\r\n            emit Transfer(sender, inviter, inviterfeeamount1);\r\n            emit Transfer(sender, inviter2, inviterfeeamount2);\r\n            emit Transfer(sender, to, leftamount);\r\n        }\r\n    } \r\n    function DistributeToken() external {\r\n        uint tokenamount = _balances[address(this)].sub(minetotalamount);\r\n        uint lptotalamount;\r\n        for(uint i; i < LpHoldList.length; i++) {\r\n            lptotalamount = lptotalamount.add(IUniswapV2Pair(pair).balanceOf(LpHoldList[i]));\r\n        }\r\n        _balances[address(this)] = _balances[address(this)].sub(tokenamount);\r\n        for(uint i; i < LpHoldList.length; i++){\r\n            uint lpamount = IUniswapV2Pair(pair).balanceOf(LpHoldList[i]);\r\n            if(lpamount>0){\r\n                uint reward = lpamount.mul(tokenamount).div(lptotalamount);\r\n                _balances[LpHoldList[i]] = _balances[LpHoldList[i]].add(reward);\r\n                emit Transfer(address(this), LpHoldList[i], reward);\r\n            }\r\n        } \r\n  \r\n    }\r\n    function trademine(address user,uint lpvalue,uint tradeamount) internal {\r\n\r\n        uint minedamount;\r\n    \r\n        if(lpvalue >= 100000*E18*E9){\r\n            minedamount = tradeamount.mul(95).div(1000);\r\n        }else if(lpvalue >= 70000*E18*E9){\r\n            minedamount = tradeamount.mul(85).div(1000);\r\n        }else if(lpvalue >= 40000*E18*E9){\r\n            minedamount = tradeamount.mul(75).div(1000);\r\n        }else if(lpvalue >= 20000*E18*E9){\r\n            minedamount = tradeamount.mul(70).div(1000);\r\n        }else if(lpvalue >= 10000*E18*E9){\r\n            minedamount = tradeamount.mul(65).div(1000);\r\n        }else if(lpvalue >= 5000*E18*E9){\r\n            minedamount = tradeamount.mul(60).div(1000);\r\n        }else if(lpvalue >= 3000*E18*E9){\r\n            minedamount = tradeamount.mul(55).div(1000);\r\n        }else if(lpvalue >= 1000*E18*E9){\r\n            minedamount = tradeamount.mul(50).div(1000);\r\n        }else if(lpvalue >= 500*E18*E9){\r\n            minedamount = tradeamount.mul(45).div(1000);\r\n        }else if(lpvalue >= 300*E18*E9){\r\n            minedamount = tradeamount.mul(43).div(1000);\r\n        }else if(lpvalue >= 100*E18*E9){\r\n            minedamount = tradeamount.mul(40).div(1000);\r\n        }\r\n        uint fundamount2 = tradeamount.mul(5).div(1000);\r\n        uint totalamount = minedamount.add(fundamount2);\r\n\r\n        if(minetotalamount >= totalamount){\r\n            _balances[address(this)] = _balances[address(this)].sub(totalamount);\r\n            minetotalamount = minetotalamount.sub(totalamount);\r\n            _balances[user] = _balances[user].add(minedamount);\r\n            _balances[fundaddress2] = _balances[fundaddress2].add(fundamount2);\r\n\r\n            emit Transfer(address(this), user, minedamount);\r\n            emit Transfer(address(this), fundaddress2, fundamount2);\r\n        }\r\n    }   \r\n    function _approve(address owner, address spender, uint amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    function claimLeftToken(address token) external onlyOwner {\r\n        uint left = IERC20(token).balanceOf(address(this));\r\n        IERC20(token).transfer(_msgSender(), left.mul(9999).div(10000));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DistributeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LpHoldList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimLeftToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpHoldList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhite\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minetotalamount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newaddress1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newaddress2\",\"type\":\"address\"}],\"name\":\"setFundWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastminetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastswapnum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastswapprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpvalue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradetype\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isinlist\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CFH", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6213862e055e8d7ef02f270abb65759ccd2bbe229fa587a4ba4042fabd4b7952"}