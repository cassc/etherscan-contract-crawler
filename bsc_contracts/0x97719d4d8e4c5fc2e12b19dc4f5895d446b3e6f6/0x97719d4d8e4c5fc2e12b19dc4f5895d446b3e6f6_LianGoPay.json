{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n   \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ILiquidityMining {\r\n    function isUserExists(address addr) external view returns (bool);\r\n    function users(address addr) external view returns (uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract LianGoPay is Ownable {\r\n    IERC20 private constant c_erc20 = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n    ILiquidityMining private constant c_lpMining = ILiquidityMining(0x83362243028a84b2B390945D1C682F33f2aBA158);\r\n    address private constant firstAddress = 0x1cceC87FE96E940e9027fc3c9127118199F1cC10;\r\n\r\n    struct User {\r\n        address upline;\r\n        uint128 totalPayAmount;\r\n        uint128 totalStakeAmount;\r\n        uint128 adaptAmount;\r\n        uint128 lastAdaptTime;\r\n\r\n        uint128 withdrawnAmount;\r\n        uint128 withdrawnPay;\r\n\r\n        uint128 refReward;\r\n    }\r\n    mapping(address => User) public users; \r\n\r\n    address private constant feeAddress1 = 0xa24bbc4c45aa305C44D2A7104f0E699Fd4790E7C;\r\n    address private constant feeAddress2 = 0x6a8fE3B7b725342a712FbC4f297847f496DD6880;\r\n    uint128 private constant shopRate = 87;\r\n    uint256 public totalPayIn;\r\n    uint256 public totalPoint;\r\n    \r\n    struct RefInfo {\r\n        uint128 minAmount;\r\n        uint128 refRewardRate;\r\n    }\r\n    mapping (uint256 => RefInfo) public refRewardRates;\r\n    \r\n    constructor() {\r\n        refRewardRates[0] = RefInfo(2500*10**18, 50);\r\n        refRewardRates[1] = RefInfo(5000*10**18, 50);\r\n        refRewardRates[2] = RefInfo(7500*10**18, 50);\r\n        refRewardRates[3] = RefInfo(10000*10**18, 50);\r\n        refRewardRates[4] = RefInfo(12500*10**18, 50);\r\n        refRewardRates[5] = RefInfo(15000*10**18, 50);\r\n        refRewardRates[6] = RefInfo(17500*10**18, 50);\r\n        refRewardRates[7] = RefInfo(20000*10**18, 50);\r\n        refRewardRates[8] = RefInfo(22500*10**18, 50);\r\n        refRewardRates[9] = RefInfo(25000*10**18, 50);\r\n        refRewardRates[10] = RefInfo(27500*10**18, 50);\r\n        refRewardRates[11] = RefInfo(30000*10**18, 50);\r\n        refRewardRates[12] = RefInfo(32500*10**18, 50);\r\n        refRewardRates[13] = RefInfo(35000*10**18, 50);\r\n        refRewardRates[14] = RefInfo(37500*10**18, 50);\r\n        refRewardRates[15] = RefInfo(40000*10**18, 50);\r\n        refRewardRates[16] = RefInfo(42500*10**18, 50);\r\n        refRewardRates[17] = RefInfo(45000*10**18, 50);\r\n        refRewardRates[18] = RefInfo(47500*10**18, 50);\r\n        refRewardRates[19] = RefInfo(50000*10**18, 50);\r\n    }\r\n\r\n    function isUserExists(address addr) public view returns(bool) {\r\n        if(users[addr].upline != address(0)){\r\n            return true;\r\n        }\r\n        if (addr == firstAddress) {\r\n            return true;\r\n        }\r\n        return c_lpMining.isUserExists(addr);\r\n    }\r\n\r\n    function _upline(address addr) private returns(address) {\r\n        address up = users[addr].upline;\r\n        if(up != address(0)) {\r\n            return up;\r\n        }\r\n        if (addr == firstAddress) {\r\n            return address(0);\r\n        }\r\n\r\n        (, up, , , , , , , ) = c_lpMining.users(addr);\r\n        users[addr].upline = up;\r\n        return up;\r\n    }\r\n    \r\n    function pay(address shopkeeper, uint128 amount) external {\r\n        require(isUserExists(shopkeeper), \"shopkeeper not exists\");\r\n        require(isUserExists(msg.sender), \"msgsender not exists\");\r\n        unchecked{\r\n            uint128 shopAmount = amount * shopRate/100;\r\n            uint128 dayReleaseRate = calDayReleaseRate();\r\n\r\n            User storage s = users[shopkeeper];\r\n\r\n            uint128 interval = uint128(block.timestamp - s.lastAdaptTime);\r\n            uint128 adaptAmount = getReleaseAmount(interval, s.totalStakeAmount, dayReleaseRate);\r\n            s.adaptAmount += adaptAmount;\r\n            s.lastAdaptTime = uint128(block.timestamp);\r\n            s.totalStakeAmount = s.totalStakeAmount - adaptAmount + amount - shopAmount;\r\n            s.withdrawnPay += shopAmount;\r\n            uint256 t = totalPoint - adaptAmount + amount - shopAmount;\r\n    \r\n            User storage m = users[msg.sender];\r\n            \r\n            interval = uint128(block.timestamp - m.lastAdaptTime);\r\n            adaptAmount = getReleaseAmount(interval, m.totalStakeAmount, dayReleaseRate);\r\n            m.adaptAmount += adaptAmount;\r\n            m.lastAdaptTime = uint128(block.timestamp);\r\n            m.totalStakeAmount = m.totalStakeAmount - adaptAmount + amount;\r\n            m.totalPayAmount += amount;\r\n            t = t - adaptAmount + amount;\r\n    \r\n            totalPayIn += uint256(amount);\r\n            totalPoint = t;\r\n            c_erc20.transferFrom(msg.sender, address(this), amount);\r\n            c_erc20.transfer(shopkeeper, shopAmount);\r\n            c_erc20.transfer(feeAddress1, amount/100);\r\n            c_erc20.transfer(feeAddress2, amount/50);\r\n        }\r\n    }\r\n\r\n    function getReleaseAmount(uint128 intervalSeconds, uint128 stakeAmount, uint128 dayReleaseRate) public pure returns(uint128) {\r\n        unchecked{\r\n            if (intervalSeconds == 0 || stakeAmount == 0 || dayReleaseRate == 0) {\r\n                return 0;\r\n            }\r\n\r\n            uint128 intervalDays = intervalSeconds/(24*3600);\r\n            if (intervalDays == 0) {\r\n                return uint128(stakeAmount * dayReleaseRate * intervalSeconds/(100000*24*3600));\r\n            }   \r\n\r\n            uint128 amount = 0;\r\n            for (uint128 i = 0; i < intervalDays; i++) {\r\n                uint128 oneReleaseAmount = uint128(stakeAmount * dayReleaseRate/100000);\r\n                amount += oneReleaseAmount;\r\n                stakeAmount -= oneReleaseAmount;\r\n            }   \r\n\r\n            amount += uint128((intervalSeconds-24*3600*intervalDays)*stakeAmount*dayReleaseRate/(100000*24*3600));\r\n            return amount;\r\n        }\r\n    }\r\n\r\n    function calDayReleaseRate() public view returns(uint128) {\r\n        uint256 contractBalance = c_erc20.balanceOf(address(this));\r\n        uint256 t = totalPoint;\r\n        if (t == 0) {\r\n            return 0;\r\n        }\r\n\r\n        unchecked{\r\n            uint256 rate = 100 * contractBalance/t;\r\n            if (rate < 2) {\r\n                return 5;\r\n            }else if (rate < 3) {\r\n                return 10;\r\n            }else if (rate < 4) {\r\n                return 20;\r\n            }else if (rate < 5) {\r\n                return 30;\r\n            }\r\n            return 40;\r\n        }\r\n    }\r\n    \r\n    function withdraw() external {\r\n        require(isUserExists(msg.sender), \"addr not exists\");\r\n        unchecked{\r\n            User storage m = users[msg.sender];\r\n            uint128 interval = uint128(block.timestamp - m.lastAdaptTime);\r\n            uint128 dayReleaseRate = calDayReleaseRate();\r\n            uint128 adaptAmount = getReleaseAmount(interval, m.totalStakeAmount, dayReleaseRate);\r\n            uint128 withdrawableAmount = m.adaptAmount + adaptAmount;\r\n            m.adaptAmount = 0;\r\n            m.lastAdaptTime = uint128(block.timestamp); \r\n\r\n            _refPayout(msg.sender, withdrawableAmount); \r\n\r\n            interval = m.refReward;\r\n            withdrawableAmount += interval;\r\n            c_erc20.transfer(msg.sender, withdrawableAmount);\r\n            m.withdrawnAmount += withdrawableAmount;    \r\n\r\n            interval += adaptAmount;\r\n            if(m.totalStakeAmount > interval) {\r\n                m.totalStakeAmount -= interval;\r\n                totalPoint -= interval;\r\n            } else {\r\n                totalPoint -= m.totalStakeAmount;\r\n                m.totalStakeAmount = 0;\r\n            }\r\n            m.refReward = 0;\r\n        }  \r\n    }\r\n\r\n    function _refPayout(address addr, uint128 amount) private {\r\n        unchecked{\r\n            address up = _upline(addr);\r\n            for(uint128 i; i < 20; ++i) {\r\n                if(up == address(0)) break;\r\n                if (users[up].totalStakeAmount >= refRewardRates[i].minAmount){\r\n                    users[up].refReward += amount * refRewardRates[i].refRewardRate / 1000;\r\n                }\r\n                up = _upline(up);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setRefRate(uint256 i, uint128 m, uint128 newR) external onlyOwner {\r\n        require(50 <= newR && newR <= 3000, \"invalid rate\");\r\n        refRewardRates[i].minAmount = m;\r\n        refRewardRates[i].refRewardRate = newR;\r\n    }\r\n\r\n    function contractInfo() external view returns(uint256, uint256, uint256, uint128) {\r\n        uint128 dayReleaseRate = calDayReleaseRate();\r\n        return (c_erc20.balanceOf(address(this)), totalPoint, totalPayIn, dayReleaseRate);\r\n    }\r\n\r\n    function userInfo(address addr) public view returns(uint128, uint128, uint128, uint128, uint128, uint128) {\r\n        User storage o = users[addr];\r\n        uint128 interval;\r\n        if (o.lastAdaptTime != 0){\r\n            uint128 dayReleaseRate = calDayReleaseRate();\r\n            interval = uint128(block.timestamp - o.lastAdaptTime);\r\n            interval = getReleaseAmount(interval, o.totalStakeAmount, dayReleaseRate);\r\n        }\r\n        return (o.totalPayAmount, o.totalStakeAmount, o.adaptAmount+interval, o.refReward, o.withdrawnAmount, o.withdrawnPay);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"calDayReleaseRate\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"intervalSeconds\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"stakeAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"dayReleaseRate\",\"type\":\"uint128\"}],\"name\":\"getReleaseAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shopkeeper\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"pay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refRewardRates\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"minAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"refRewardRate\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"m\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"newR\",\"type\":\"uint128\"}],\"name\":\"setRefRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"totalPayAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalStakeAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"adaptAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastAdaptTime\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawnAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawnPay\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"refReward\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LianGoPay", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://391fcf0ceb360a5dc3a3259a969b48a9c9509ef92fd2e79d487f5ca67bc8385e"}