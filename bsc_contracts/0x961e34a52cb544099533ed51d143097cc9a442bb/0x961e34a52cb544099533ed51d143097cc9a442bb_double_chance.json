{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity >=0.4.22 <0.9.0;\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal pure virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: kan geen waarde verzenden, de ontvanger is mogelijk teruggekeerd\"\r\n        );\r\n    }\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: onvoldoende saldo voor gesprek\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) +\r\n            (value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) -\r\n            (value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\ncontract double_chance is Context {\r\n    using SafeERC20 for IERC20;\r\n    struct Node {\r\n        uint256 leftDirect;\r\n        uint256 rightDirect;\r\n        uint256 ALLleftDirect;\r\n        uint256 ALLrightDirect;\r\n        uint256 todayCountPoint;\r\n        uint256 depth;\r\n        uint256 childs;\r\n        uint256 leftOrrightUpline;\r\n        address UplineAddress;\r\n        address leftDirectAddress;\r\n        address rightDirectAddress;\r\n        uint256 winCount;\r\n    }\r\n    mapping(address => Node) private _users;\r\n    mapping(uint256 => address) private _allUsersAddress;\r\n    mapping(uint256 => address) private Flash_User;\r\n    address private owner;\r\n    //address private tokenAddress;\r\n    address private Last_Reward_Order;\r\n    address[] private Lottery_candida;\r\n    uint256 private _listingNetwork;\r\n//    uint256 private _lotteryNetwork;\r\n    address private Operator;\r\n    address private Admin;\r\n    uint256 private _counter_Flash;\r\n    uint256 private _userId;\r\n    uint256 private lastRun;\r\n    uint256 private All_Payment;\r\n    uint256 private _count_Lottery_Candidate;\r\n    uint256 private Value_LotteryANDFee;\r\n    uint256[] private _randomNumbers;\r\n    uint256 private Lock = 0;\r\n    uint256 private Max_Point;\r\n    uint256 private Max_Lottery_Price;\r\n    uint256 private Count_Last_Users;\r\n    IERC20 private _depositToken;\r\n\r\n    constructor() {\r\n        owner = _msgSender();\r\n        _listingNetwork = 50 * 10**18;\r\n//        _lotteryNetwork = 2500000 * 10**18;\r\n        Max_Point = 50;\r\n        Max_Lottery_Price = 10;\r\n        lastRun = block.timestamp;\r\n        //tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf; \r\n        Operator = 0xc8bB0b553f091F23B41ea5655b3149a6199835D8;\r\n        Admin = 0x4ad6Df0B37241B93fa4d697A01d7b71491f2A738;\r\n        _depositToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        Count_Last_Users = 0;\r\n        All_Payment = 26200 * 10**18;\r\n    }\r\n\r\n    function Reward_12() public {\r\n        require(Lock == 0, \"Proccesing\");\r\n        require(\r\n            _users[_msgSender()].todayCountPoint > 0,\r\n            \"Je hebt vandaag geen enkel punt\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp > lastRun + 12 hours,\r\n            \"De beloning_12 De tijd is nog niet gekomen\"\r\n        );\r\n\r\n        Lock = 1;\r\n        Last_Reward_Order = _msgSender();\r\n        All_Payment += _depositToken.balanceOf(address(this));\r\n\r\n        uint256 Value_Reward = Price_Point() * 70;\r\n        Value_LotteryANDFee = Price_Point();\r\n\r\n        uint256 valuePoint = ((Value_Reward)) / Today_Total_Point();\r\n        uint256 _counterFlash = _counter_Flash;\r\n\r\n        uint256 RewardClick = Today_Reward_Writer_Reward() * 10**18;\r\n        if(valuePoint>10* 10**18){\r\n            valuePoint=valuePoint - 2* 10**18;\r\n        }\r\n        for (uint256 i = 0; i <= _userId; i = unsafe_inc(i)) {\r\n            Node memory TempNode = _users[_allUsersAddress[i]];\r\n            uint256 Point;\r\n            uint256 Result = TempNode.leftDirect <= TempNode.rightDirect\r\n                ? TempNode.leftDirect\r\n                : TempNode.rightDirect;\r\n            if (Result > 0) {\r\n                if (Result > Max_Point) {\r\n                    Point = Max_Point;\r\n                    if (TempNode.leftDirect < Result) {\r\n                        TempNode.leftDirect = 0;\r\n                        TempNode.rightDirect -= Result;\r\n                    } else if (TempNode.rightDirect < Result) {\r\n                        TempNode.leftDirect -= Result;\r\n                        TempNode.rightDirect = 0;\r\n                    } else {\r\n                        TempNode.leftDirect -= Result;\r\n                        TempNode.rightDirect -= Result;\r\n                    }\r\n                    Flash_User[_counterFlash] = _allUsersAddress[i];\r\n                    _counterFlash++;\r\n                } else {\r\n                    Point = Result;\r\n                    if (TempNode.leftDirect < Point) {\r\n                        TempNode.leftDirect = 0;\r\n                        TempNode.rightDirect -= Point;\r\n                    } else if (TempNode.rightDirect < Point) {\r\n                        TempNode.leftDirect -= Point;\r\n                        TempNode.rightDirect = 0;\r\n                    } else {\r\n                        TempNode.leftDirect -= Point;\r\n                        TempNode.rightDirect -= Point;\r\n                    }\r\n                }\r\n                TempNode.todayCountPoint = 0;\r\n                _users[_allUsersAddress[i]] = TempNode;\r\n\r\n                if (\r\n                    Point * valuePoint > _depositToken.balanceOf(address(this))\r\n                ) {\r\n                    _depositToken.safeTransfer(\r\n                        _allUsersAddress[i],\r\n                        _depositToken.balanceOf(address(this))\r\n                    );\r\n                } else {\r\n                    _depositToken.safeTransfer(\r\n                        _allUsersAddress[i],\r\n                        Point * valuePoint\r\n                    );\r\n                }\r\n\r\n//                if (\r\n //                   Point * 1000000 * 10**18 <=\r\n //                   IERC20(tokenAddress).balanceOf(address(this))\r\n //               ) {\r\n //                   IERC20(tokenAddress).transfer(\r\n //                       _allUsersAddress[i],\r\n //                       Point * 1000000 * 10**18\r\n //                   );\r\n //               }\r\n            }\r\n        }\r\n        _counter_Flash = _counterFlash;\r\n        lastRun = block.timestamp;\r\n\r\n        if (RewardClick <= _depositToken.balanceOf(address(this))) {\r\n            _depositToken.safeTransfer(_msgSender(), RewardClick);\r\n        }\r\n\r\n        Lottery_Reward();\r\n\r\n        _depositToken.safeTransfer(\r\n            Admin,\r\n            _depositToken.balanceOf(address(this))\r\n        );\r\n\r\n        Lock = 0;\r\n    }\r\n\r\n    function X_Emergency_72() public {\r\n        require(_msgSender() == Operator, \"Alleen de eigenaar kan deze bestelling uitvoeren!\");\r\n        require(\r\n            block.timestamp > lastRun + 72 hours,\r\n            \"De X_Emergency_72 tijd is nog niet gekomen\"\r\n        );\r\n        _depositToken.safeTransfer(\r\n            Admin,\r\n            _depositToken.balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function Register(address uplineAddress) public {\r\n        require(\r\n            _users[uplineAddress].childs != 2,\r\n            \"Dit adres heeft twee directe leden en kon geen nieuwe leden accepteren!\"\r\n        );\r\n        require(\r\n            _msgSender() != uplineAddress,\r\n            \"U kunt uw eigen adres niet invoeren!\"\r\n        );\r\n        bool testUser = false;\r\n        for (uint256 i = 0; i <= _userId; i = unsafe_inc(i)) {\r\n            if (_allUsersAddress[i] == _msgSender()) {\r\n                testUser = true;\r\n                break;\r\n            }\r\n        }\r\n        require(testUser == false, \"Dit adres is al geregistreerd!\");\r\n\r\n        bool testUpline = false;\r\n        for (uint256 i = 0; i <= _userId; i = unsafe_inc(i)) {\r\n            if (_allUsersAddress[i] == uplineAddress) {\r\n                testUpline = true;\r\n                break;\r\n            }\r\n        }\r\n        require(testUpline == true, \"Dit upline-adres bestaat niet!\");\r\n\r\n        _depositToken.safeTransferFrom(\r\n            _msgSender(),\r\n            address(this),\r\n            _listingNetwork\r\n        );       \r\n        _allUsersAddress[_userId] = _msgSender();\r\n        _userId++;\r\n        uint256 depthChild = _users[uplineAddress].depth + 1;\r\n        _users[_msgSender()] = Node(\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            depthChild,\r\n            0,\r\n            _users[uplineAddress].childs,\r\n            uplineAddress,\r\n            address(0),\r\n            address(0),\r\n            0\r\n        );\r\n        if (_users[uplineAddress].childs == 0) {\r\n            _users[uplineAddress].leftDirect++;\r\n            _users[uplineAddress].ALLleftDirect++;\r\n            _users[uplineAddress].leftDirectAddress = _msgSender();\r\n        } else {\r\n            _users[uplineAddress].rightDirect++;\r\n            _users[uplineAddress].ALLrightDirect++;\r\n            _users[uplineAddress].rightDirectAddress = _msgSender();\r\n        }\r\n        _users[uplineAddress].childs++;\r\n        setTodayPoint(uplineAddress);\r\n        address uplineNode = _users[uplineAddress].UplineAddress;\r\n        address childNode = uplineAddress;\r\n        for (\r\n            uint256 j = 0;\r\n            j < _users[uplineAddress].depth;\r\n            j = unsafe_inc(j)\r\n        ) {\r\n            if (_users[childNode].leftOrrightUpline == 0) {\r\n                _users[uplineNode].leftDirect++;\r\n                _users[uplineNode].ALLleftDirect++;\r\n            } else {\r\n                _users[uplineNode].rightDirect++;\r\n                _users[uplineNode].ALLrightDirect++;\r\n            }\r\n            setTodayPoint(uplineNode);\r\n            childNode = uplineNode;\r\n            uplineNode = _users[uplineNode].UplineAddress;\r\n        }\r\n//        IERC20(tokenAddress).transfer(_msgSender(), 100000000 * 10**18);\r\n    }\r\n\r\n    function Lottery_Reward() private {\r\n        uint256 Numer_Win = ((Value_LotteryANDFee * 20) / 10**18) /\r\n            Max_Lottery_Price;\r\n\r\n        if (Numer_Win != 0 && _count_Lottery_Candidate != 0) {\r\n            if (_count_Lottery_Candidate > Numer_Win) {\r\n                for (\r\n                    uint256 i = 1;\r\n                    i <= _count_Lottery_Candidate;\r\n                    i = unsafe_inc(i)\r\n                ) {\r\n                    _randomNumbers.push(i);\r\n                }\r\n\r\n                for (uint256 i = 1; i <= Numer_Win; i = unsafe_inc(i)) {\r\n                    uint256 randomIndex = uint256(\r\n                        keccak256(\r\n                            abi.encodePacked(block.timestamp, msg.sender, i)\r\n                        )\r\n                    ) % _count_Lottery_Candidate;\r\n                    uint256 resultNumber = _randomNumbers[randomIndex];\r\n\r\n                    _randomNumbers[randomIndex] = _randomNumbers[\r\n                        _randomNumbers.length - 1\r\n                    ];\r\n                    _randomNumbers.pop();\r\n\r\n                    _depositToken.safeTransfer(\r\n                        Lottery_candida[resultNumber - 1],\r\n                        Max_Lottery_Price * 10**18\r\n                    );\r\n                }\r\n\r\n                for (\r\n                    uint256 i = 0;\r\n                    i < (_count_Lottery_Candidate - Numer_Win);\r\n                    i = unsafe_inc(i)\r\n                ) {\r\n                    _randomNumbers.pop();\r\n                }\r\n            } else {\r\n                for (\r\n                    uint256 i = 0;\r\n                    i < _count_Lottery_Candidate;\r\n                    i = unsafe_inc(i)\r\n                ) {\r\n                    _depositToken.safeTransfer(\r\n                        Lottery_candida[i],\r\n                        Max_Lottery_Price * 10**18\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint256 i = 0; i < _count_Lottery_Candidate; i = unsafe_inc(i)) {\r\n            Lottery_candida.pop();\r\n        }\r\n\r\n        _count_Lottery_Candidate = 0;\r\n    }\r\n\r\n    function Smart_Gift() public {\r\n        require(\r\n            _users[_msgSender()].todayCountPoint < 1,\r\n            \"Je hebt een punt vandaag\"\r\n        );\r\n         require(\r\n            _users[_msgSender()].winCount < 9,\r\n            \"Je kunt niet meer winnen\"\r\n        );\r\n//        require(\r\n//            IERC20(tokenAddress).balanceOf(_msgSender()) >= _lotteryNetwork,\r\n//            \"You Dont Have Enough Smart Binary Token!\"\r\n//        );\r\n\r\n        bool testUser = false;\r\n        for (uint256 i = 0; i <= _userId; i = unsafe_inc(i)) {\r\n            if (_allUsersAddress[i] == _msgSender()) {\r\n                testUser = true;\r\n                break;\r\n            }\r\n        }\r\n        require(\r\n            testUser == true,\r\n            \"Dit adres staat niet in Double Chance Contract!\"\r\n        );\r\n\r\n//        IERC20(tokenAddress).safeTransferFrom(\r\n//            _msgSender(),\r\n//            address(this),\r\n//            _lotteryNetwork\r\n//        );\r\n\r\n        Lottery_candida.push(_msgSender());\r\n        _count_Lottery_Candidate++;\r\n    }\r\n\r\n    function Upload_Old_Users(\r\n        address person,\r\n        uint256 leftDirect,\r\n        uint256 rightDirect,\r\n        uint256 ALLleftDirect,\r\n        uint256 ALLrightDirect,\r\n        uint256 depth,\r\n        uint256 childs,\r\n        uint256 leftOrrightUpline,\r\n        address UplineAddress,\r\n        address leftDirectAddress,\r\n        address rightDirectAddress,\r\n        uint256 winCount\r\n    ) public {\r\n        require(_msgSender() == Operator ||_msgSender() == owner , \"Alleen de eigenaar kan deze bestelling uitvoeren!\");\r\n        require(Count_Last_Users <= 262, \"Het aantal oude gebruikers is voorbij!\");\r\n\r\n        _allUsersAddress[_userId] = person;\r\n        _users[_allUsersAddress[_userId]] = Node(\r\n            leftDirect,\r\n            rightDirect,\r\n            ALLleftDirect,\r\n            ALLrightDirect,\r\n            0,\r\n            depth,\r\n            childs,\r\n            leftOrrightUpline,\r\n            UplineAddress,\r\n            leftDirectAddress,\r\n            rightDirectAddress,\r\n            winCount\r\n        );\r\n//        IERC20(tokenAddress).transfer(person, 100000000 * 10**18);\r\n        Count_Last_Users++;\r\n        _userId++;\r\n    }\r\n\r\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\r\n        unchecked {\r\n            return x + 1;\r\n        }\r\n    }\r\n\r\n    function User_Information(address UserAddress)\r\n        public\r\n        view\r\n        returns (Node memory)\r\n    {\r\n        return _users[UserAddress];\r\n    }\r\n\r\n    function Today_Contract_Balance() public view returns (uint256) {\r\n        return _depositToken.balanceOf(address(this)) / 10**18;\r\n    }\r\n\r\n    function Price_Point() private view returns (uint256) {\r\n        return (_depositToken.balanceOf(address(this))) / 100;\r\n    }\r\n\r\n    function Today_Reward_Balance() public view returns (uint256) {\r\n        return (Price_Point() * 70)/ 10**18;\r\n    }\r\n\r\n    function Today_Gift_Balance() public view returns (uint256) {\r\n        return (Price_Point() * 20) / 10**18;\r\n    }\r\n\r\n    function Today_Reward_Writer_Reward() public view returns (uint256) {\r\n        uint256 Remain = ((Price_Point() * 20) / 10**18) % Max_Lottery_Price;\r\n        return Remain;\r\n    }\r\n\r\n    function Number_Of_Gift_Candidate() public view returns (uint256) {\r\n        return _count_Lottery_Candidate;\r\n    }\r\n\r\n    function All_payment() public view returns (uint256) {\r\n        return All_Payment / 10**18;\r\n    }\r\n\r\n    function X_Old_Users_Counter() public view returns (uint256) {\r\n        return Count_Last_Users;\r\n    }\r\n\r\n    function Contract_Address() public view returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n//    function Smart_Binary_Token_Address() public view returns (address) {\r\n//        return tokenAddress;\r\n//    }\r\n\r\n    function Total_Register() public view returns (uint256) {\r\n        return _userId;\r\n    }\r\n\r\n    function User_Upline(address Add_Address) public view returns (address) {\r\n        return _users[Add_Address].UplineAddress;\r\n    }\r\n\r\n    function Last_Reward_Writer() public view returns (address) {\r\n        return Last_Reward_Order;\r\n    }\r\n\r\n    function User_Directs_Address(address Add_Address)\r\n        public\r\n        view\r\n        returns (address, address)\r\n    {\r\n        return (\r\n            _users[Add_Address].leftDirectAddress,\r\n            _users[Add_Address].rightDirectAddress\r\n        );\r\n    }\r\n\r\n    function Today_User_Point(address Add_Address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_users[Add_Address].todayCountPoint > Max_Point) {\r\n            return Max_Point;\r\n        } else {\r\n            return _users[Add_Address].todayCountPoint;\r\n        }\r\n    }\r\n\r\n    function Today_User_Left_Right(address Add_Address)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (\r\n            _users[Add_Address].leftDirect,\r\n            _users[Add_Address].rightDirect\r\n        );\r\n    }\r\n\r\n    function All_Time_User_Left_Right(address Add_Address)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (\r\n            _users[Add_Address].ALLleftDirect,\r\n            _users[Add_Address].ALLrightDirect\r\n        );\r\n    }\r\n\r\n    function Today_Total_Point() public view returns (uint256) {\r\n        uint256 TPoint;\r\n        for (uint256 i = 0; i <= _userId; i = unsafe_inc(i)) {\r\n            uint256 min = _users[_allUsersAddress[i]].leftDirect <=\r\n                _users[_allUsersAddress[i]].rightDirect\r\n                ? _users[_allUsersAddress[i]].leftDirect\r\n                : _users[_allUsersAddress[i]].rightDirect;\r\n\r\n            if (min > Max_Point) {\r\n                min = Max_Point;\r\n            }\r\n            TPoint += min;\r\n        }\r\n        return TPoint;\r\n    }\r\n\r\n    function Flash_users() public view returns (address[] memory) {\r\n        address[] memory items = new address[](_counter_Flash);\r\n\r\n        for (uint256 i = 0; i < _counter_Flash; i = unsafe_inc(i)) {\r\n            items[i] = Flash_User[i];\r\n        }\r\n        return items;\r\n    }\r\n\r\n    function Today_Value_Point() public view returns (uint256) {\r\n        if (Today_Total_Point() == 0) {\r\n            return Today_Reward_Balance();\r\n        } else {\r\n            return (Price_Point() * 70) / (Today_Total_Point() * 10**18);\r\n        }\r\n    }\r\n\r\n    function setTodayPoint(address userAddress) private {\r\n        uint256 min = _users[userAddress].leftDirect <=\r\n            _users[userAddress].rightDirect\r\n            ? _users[userAddress].leftDirect\r\n            : _users[userAddress].rightDirect;\r\n        if (min > 0) {\r\n            _users[userAddress].todayCountPoint = min;\r\n        }\r\n    }\r\n  \r\n    function User_Exist(address Useraddress)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        bool test = false;\r\n        for (uint256 i = 0; i <= _userId; i = unsafe_inc(i)) {\r\n            if (_allUsersAddress[i] == Useraddress) {\r\n                test = true;\r\n            }\r\n        }\r\n        if (test) {\r\n            return \"YES!\";\r\n        } else {\r\n            return \"NO!\";\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Add_Address\",\"type\":\"address\"}],\"name\":\"All_Time_User_Left_Right\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"All_payment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Contract_Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Flash_users\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Last_Reward_Writer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Number_Of_Gift_Candidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uplineAddress\",\"type\":\"address\"}],\"name\":\"Register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Reward_12\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Smart_Gift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Today_Contract_Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Today_Gift_Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Today_Reward_Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Today_Reward_Writer_Reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Today_Total_Point\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Add_Address\",\"type\":\"address\"}],\"name\":\"Today_User_Left_Right\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Add_Address\",\"type\":\"address\"}],\"name\":\"Today_User_Point\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Today_Value_Point\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Total_Register\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"person\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leftDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ALLleftDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ALLrightDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leftOrrightUpline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"UplineAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leftDirectAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightDirectAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winCount\",\"type\":\"uint256\"}],\"name\":\"Upload_Old_Users\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Add_Address\",\"type\":\"address\"}],\"name\":\"User_Directs_Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Useraddress\",\"type\":\"address\"}],\"name\":\"User_Exist\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"}],\"name\":\"User_Information\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"leftDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ALLleftDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ALLrightDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"todayCountPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leftOrrightUpline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"UplineAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leftDirectAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightDirectAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winCount\",\"type\":\"uint256\"}],\"internalType\":\"struct double_chance.Node\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Add_Address\",\"type\":\"address\"}],\"name\":\"User_Upline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"X_Emergency_72\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"X_Old_Users_Counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "double_chance", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bfb3506dca2d9fffc6cb0d1a22c9d0e8276e3a0139f5389aa5bf9df7591350a3"}