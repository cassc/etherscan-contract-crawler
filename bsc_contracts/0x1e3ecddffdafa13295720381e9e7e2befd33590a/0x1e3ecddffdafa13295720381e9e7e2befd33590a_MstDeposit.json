{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n \\nlibrary DateTime {\\n    /*\\n     *  Date and Time utilities for ethereum contracts\\n     *\\n     */\\n    struct _DateTime {\\n        uint16 year;\\n        uint8 month;\\n        uint8 day;\\n        uint8 hour;\\n        uint8 minute;\\n        uint8 second;\\n        uint8 weekday;\\n    }\\n \\n    uint256 constant DAY_IN_SECONDS = 86400;\\n    uint256 constant YEAR_IN_SECONDS = 31536000;\\n    uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n \\n    uint256 constant HOUR_IN_SECONDS = 3600;\\n    uint256 constant MINUTE_IN_SECONDS = 60;\\n \\n    uint16 constant ORIGIN_YEAR = 1970;\\n \\n    //\u5224\u65ad\u8f93\u5165\u7684\u5e74\u4efd\u662f\u4e0d\u662f\u95f0\u5e74\\n    function isLeapYear(uint16 year) public pure returns (bool) {\\n        if (year % 4 != 0) {\\n            return false;\\n        }\\n        if (year % 100 != 0) {\\n            return true;\\n        }\\n        if (year % 400 != 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n \\n    //\u5224\u65ad\u8f93\u5165\u7684\u5e74\u4efd \u7684\u95f0\u5e74\u524d\\n    function leapYearsBefore(uint256 year) public pure returns (uint256) {\\n        year -= 1;\\n        return year / 4 - year / 100 + year / 400;\\n    }\\n \\n    //\u8f93\u5165\u5e74year   \u6708month  \u5f97\u5230\u5f53\u6708\u7684\u5929\u6570\\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            return 31;\\n        }\\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n            return 30;\\n        }\\n        else if (isLeapYear(year)) {\\n            return 29;\\n        }\\n        else {\\n            return 28;\\n        }\\n    }\\n \\n    function parseTimestamp(uint256 timestamp) internal pure returns (_DateTime memory dt) {\\n        uint secondsAccountedFor = 0;\\n        uint buf;\\n        uint8 i;\\n \\n        // Year\\n        dt.year = getYear(timestamp);\\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\n \\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\n \\n        // Month\\n        uint secondsInMonth;\\n        for (i = 1; i <= 12; i++) {\\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\\n                dt.month = i;\\n                break;\\n            }\\n            secondsAccountedFor += secondsInMonth;\\n        }\\n \\n        // Day\\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\n                dt.day = i;\\n                break;\\n            }\\n            secondsAccountedFor += DAY_IN_SECONDS;\\n        }\\n    }\\n \\n    //\u6839\u636e\u65f6\u95f4\u6233\u83b7\u53d6\u5e74\u4efd\\n    function getYear(uint256 timestamp) public pure returns (uint16) {\\n        uint secondsAccountedFor = 0;\\n        uint16 year;\\n        uint numLeapYears;\\n \\n        // Year\\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n \\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n \\n        while (secondsAccountedFor > timestamp) {\\n            if (isLeapYear(uint16(year - 1))) {\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n            }\\n            else {\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\n            }\\n            year -= 1;\\n        }\\n        return year;\\n    }\\n \\n    //\u6839\u636e\u65f6\u95f4\u6233\u83b7\u53d6\u6708\u4efd\\n    function getMonth(uint256 timestamp) public pure returns (uint8) {\\n        return parseTimestamp(timestamp).month;\\n    }\\n\\n    function getDate(uint256 timestamp) public pure returns (uint256) {\\n        return uint256(getYear(timestamp)) * 100 + uint256(getMonth(timestamp));\\n    }\\n\\n    function getMonthGap(uint256 date1, uint256 date2) public pure returns (uint256) {\\n        require(date1 >= date2, \\\"error date\\\");\\n        return (date1 / 100 - date2 / 100) * 12 + date1 % 100 - date2 % 100;\\n    }\\n}\"\r\n    },\r\n    \"contracts/MstDeposit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Relation.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\n\\ncontract MstDeposit is Ownable {\\n\\n    using DateTime for uint256;\\n\\n    event AddRelationEvent (\\n        address owner,\\n        address recommer\\n    );\\n\\n    event Deposit(\\n        address owner,\\n        uint256 amount,\\n        uint256 action\\n    );\\n\\n    event Redeem(\\n        address owner,\\n        uint256 hashrate,\\n        uint256 amount\\n    );\\n\\n    event DeductHashrate(\\n        address onwer,\\n        uint256 lastDate,\\n        uint256 currentDate,\\n        uint256 deductTimes,\\n        uint256 amount\\n    );\\n\\n    event RelationProfit(\\n        address owner,\\n        uint256 amount\\n    );\\n\\n    event CooProfit(\\n        address owner,\\n        uint256 amount\\n    );\\n\\n    event ServiceCenterProfit(\\n        address owner,\\n        uint256 amount\\n    );\\n\\n    event AddServiceCenter(\\n        address owner\\n    );\\n\\n    event RemoveServiceCenter(\\n        address owner\\n    );\\n\\n    address public coo;\\n    address public cfo;\\n    address public relation;\\n    uint256 public totalHashrate;\\n    uint256 public totalIssuance;\\n    uint256 public maxTimes;\\n    uint256 public timesAmount;\\n    uint256 public maxHashrate;\\n    address public USDT;\\n    address public MST;\\n    uint256 public relationProfitRaido;\\n    uint256 public cooProfitRadio;\\n    uint256 public serviceProfitRadio;\\n    uint256 public deductRadio;\\n    uint256 public releaseRadio;\\n    uint256 public hashrateLimitPerUser;\\n\\n\\n\\n\\n    mapping(address => User) public userInfo;\\n\\n    struct User {\\n        uint256 hashrate;\\n        address recommer;\\n        uint256 lastDate;\\n        uint256 times;\\n        bool isServiceCenter;\\n        bool isBlack;\\n    }\\n\\n    constructor(address _coo,\\n                        address _cfo,\\n                        address _relation,\\n                        address _usdt,\\n                        address _mst) {\\n        coo = _coo;\\n        cfo = _cfo;\\n        relation = _relation;\\n        USDT = _usdt;\\n        MST = _mst;\\n        totalIssuance = 10000 * 10**6;\\n        maxTimes = 3;\\n        timesAmount = 15 ether;\\n        maxHashrate = 100 ether;\\n        relationProfitRaido = 6000;\\n        cooProfitRadio = 2000;\\n        serviceProfitRadio = 2000;\\n        deductRadio = 20;\\n        releaseRadio = 8000;\\n        hashrateLimitPerUser = 1913 ether;\\n\\n    }\\n\\n    function setHashrateLimitPerUser(uint256 _hashrateLimitPerUser) external onlyOwner {\\n        hashrateLimitPerUser = _hashrateLimitPerUser;\\n    }\\n\\n    function setDeductRadio(uint256 _deductRadio) external onlyOwner {\\n        require(_deductRadio <= 100, \\\"error params\\\");\\n        deductRadio = _deductRadio;\\n    }\\n\\n    function setReleaseRadio(uint256 _releaseRadio) external onlyOwner {\\n        releaseRadio = _releaseRadio;\\n    }\\n\\n    function setRelationProfitRadio(uint256 _relationProfitRadio) external onlyOwner {\\n        relationProfitRaido = _relationProfitRadio;\\n    }\\n\\n    function setRelation(address _relation) external onlyOwner {\\n        relation = _relation;\\n    }\\n\\n    function setCooProrfitRadio(uint256 _cooProfitRadio) external onlyOwner {\\n        cooProfitRadio = _cooProfitRadio;\\n    }\\n\\n    function setServiceProfitRadio(uint256 _serviceProfitRadio) external onlyOwner {\\n        serviceProfitRadio = _serviceProfitRadio;\\n    }\\n\\n\\n\\n    function setMaxHashrate(uint256 _maxHashrate) external onlyOwner {\\n        maxHashrate = _maxHashrate;\\n    }\\n\\n    function setCoo(address _coo) external onlyOwner {\\n        coo = _coo;\\n    }\\n\\n    function setCfo(address _cfo) external onlyOwner {\\n        cfo = _cfo;\\n    }\\n\\n    function setTotalIssuance(uint256 _totalIssuance) external onlyOwner {\\n        totalIssuance = _totalIssuance;\\n    }\\n\\n    function setMst(address _address) external onlyOwner {\\n        MST = _address;\\n    }\\n\\n    // \u5efa\u7acb\u63a8\u8350\u5173\u7cfb\\n    function addRelationEx(address recommer) external returns (bool result) {\\n        result =  Relation(relation).addRelationEx(msg.sender, recommer);\\n        User storage user = userInfo[msg.sender];\\n        user.recommer = recommer;\\n        emit AddRelationEvent(msg.sender, recommer);\\n    }\\n\\n    function addRelationByAdmin(address owner, address recommer) external onlyOwner returns (bool result) {\\n        result =  Relation(relation).addRelationEx(owner, recommer);\\n        User storage user = userInfo[owner];\\n        user.recommer = recommer;\\n        emit AddRelationEvent(owner, recommer);\\n    }\\n\\n    // \u5b9a\u6295\\n    function deposit(uint256 action) external {\\n        uint256 currentDate = block.timestamp.getDate();\\n        User storage user = userInfo[msg.sender];\\n        require(!user.isBlack, \\\"user error\\\");\\n        if (user.lastDate == 0 || currentDate.getMonthGap(user.lastDate) == 0) { // \u5904\u4e8e\u5f53\u524d\u6708\u6295\u8d44\\n            require(user.times < maxTimes, \\\"Not enough investment opportunities\\\");\\n            require(user.times + 1 == action, \\\"action error\\\");\\n            \\n            // \u79fb\u52a8\u6295\u8d44\u989d\\n            IERC20(USDT).transferFrom(msg.sender, cfo, timesAmount);\\n            \\n            // \u4fee\u6539\u6570\u636e\\n            user.times += 1;\\n            user.lastDate = currentDate;\\n            user.hashrate += timesAmount;\\n            totalHashrate += timesAmount;\\n            \\n        }  else { // \u5904\u4e8e\u6b21\u6708\u6216\u82e5\u5e72\u6708\u540e\u518d\u6295\u8d44\\n            require(1 == action, \\\"action error\\\");\\n            // \u79fb\u52a8\u6295\u8d44\u989d\\n            IERC20(USDT).transferFrom(msg.sender, cfo, timesAmount);\\n            if (user.times == maxTimes && currentDate.getMonthGap(user.lastDate) == 1) { // \u6b63\u5e38\u987a\u4f4d\\n            \\n                // \u4fee\u6539\u6570\u636e\\n                user.times = 1;\\n                user.hashrate += timesAmount;\\n                user.lastDate = currentDate;\\n                totalHashrate += timesAmount;\\n            } else {\\n\\n                // \u4fee\u6539\u6570\u636e\\n                uint256 gap = currentDate.getMonthGap(user.lastDate);\\n                uint256 remainHashrate = user.hashrate * (100 - deductRadio)**gap / 100**gap;\\n                uint256 deductHashrate = user.hashrate - remainHashrate;\\n                uint256 lastDate = user.lastDate;\\n                user.times = 1;\\n                user.hashrate = remainHashrate + timesAmount;\\n                user.lastDate = currentDate;\\n                totalHashrate = totalHashrate - deductHashrate + timesAmount;\\n                \\n                emit DeductHashrate(msg.sender, lastDate, currentDate, gap, deductHashrate);\\n            }\\n        }\\n        emit Deposit(msg.sender, timesAmount, action);\\n\\n        // \u5ba1\u6838\u4e0a\u7ea7\u5730\u5740\u662f\u5426\u6709\u95ee\u9898\\n        if (user.recommer != address(0) && user.recommer != coo) {\\n             User storage recommer =  userInfo[user.recommer];\\n             if (recommer.lastDate > 0 \\n                    && ((currentDate.getMonthGap(recommer.lastDate) == 1 && recommer.times < maxTimes) || currentDate.getMonthGap(recommer.lastDate) > 1)) {\\n                        // \u4fee\u6539\u6570\u636e\\n                uint256 gap = currentDate.getMonthGap(recommer.lastDate);\\n                uint256 remainHashrate = recommer.hashrate * (100 - deductRadio)**gap / 100**gap;\\n                uint256 deductHashrate = recommer.hashrate - remainHashrate;\\n                uint256 lastDate = recommer.lastDate;\\n                recommer.times = 0;\\n                recommer.hashrate = remainHashrate;\\n                recommer.lastDate = currentDate;\\n                totalHashrate = totalHashrate - deductHashrate;\\n                \\n                emit DeductHashrate(user.recommer, lastDate, currentDate, gap, deductHashrate);\\n            }\\n        }\\n\\n        // \u76f4\u63a8\u5730\u5740\u5956\u52b1\\n        if (user.recommer != address(0) && userInfo[user.recommer].hashrate > 0 && userInfo[user.recommer].hashrate < hashrateLimitPerUser) {\\n            userInfo[user.recommer].hashrate += timesAmount * relationProfitRaido / 10000;\\n            emit RelationProfit(user.recommer, timesAmount * relationProfitRaido / 10000);\\n        } else { // \u7ed9\u8fd0\u8425\u5730\u5740\\n            userInfo[coo].hashrate += timesAmount * relationProfitRaido / 10000;\\n            emit RelationProfit(coo, timesAmount * relationProfitRaido / 10000);\\n        }\\n        totalHashrate += timesAmount * relationProfitRaido / 10000;\\n\\n        // \u8fd0\u8425\u5730\u5740\u5956\u52b1\\n        userInfo[coo].hashrate += timesAmount * cooProfitRadio / 10000;\\n        totalHashrate += timesAmount * cooProfitRadio / 10000;\\n        emit CooProfit(coo, timesAmount * cooProfitRadio / 10000);\\n\\n        // \u670d\u52a1\u5730\u5740\u5956\u52b1\\n        address[] memory relations = Relation(relation).getForefathers(msg.sender, 50);\\n        for (uint256 i = 0; i < relations.length && relations[i] != address(0); i++) {\\n            if (userInfo[relations[i]].isServiceCenter && userInfo[relations[i]].hashrate < hashrateLimitPerUser) {\\n                userInfo[relations[i]].hashrate += timesAmount * serviceProfitRadio / 10000;\\n                totalHashrate += timesAmount * serviceProfitRadio / 10000;\\n                emit ServiceCenterProfit(relations[i], timesAmount * serviceProfitRadio / 10000);\\n                break;\\n            }\\n        }\\n    }\\n\\n    // \u8d4e\u56de\\n    function redeem() external {\\n        User storage user = userInfo[msg.sender];\\n        require(user.hashrate >= maxHashrate, \\\"Can not redeem\\\");\\n        require(!user.isBlack, \\\"user error\\\");\\n        // \u8d4e\u56de\u53ea\u80fd\u8d4e\u56de80%\\n        uint256 redeemAmount = user.hashrate * releaseRadio / 10000;\\n        user.hashrate -= redeemAmount;\\n        uint256 amount = redeemAmount * totalIssuance / totalHashrate;\\n        IERC20(MST).transfer(msg.sender, amount);\\n        totalHashrate -= redeemAmount;\\n        totalIssuance -= amount;\\n        emit Redeem(msg.sender, redeemAmount, amount);\\n    }\\n\\n    // \u8d4e\u56de\u6570\u91cf\\n    function getRedeemAmount(address sender) view external returns(uint256, uint256) {\\n        User memory user = userInfo[sender];\\n        if (user.hashrate < maxHashrate) {\\n            return (user.hashrate,0);\\n        } else{\\n            uint256 redeemAmount = user.hashrate * releaseRadio / 10000;\\n            uint256 hashrate = user.hashrate;\\n            user.hashrate -= redeemAmount;\\n            return (hashrate, redeemAmount * totalIssuance / totalHashrate);\\n        }\\n    }\\n\\n    // \u589e\u52a0\u6216\u53d6\u6d88\u670d\u52a1\u4e2d\u5fc3\\n    function addServiceCenter(address _serviceCender) external onlyOwner {\\n        userInfo[_serviceCender].isServiceCenter = true;\\n        emit AddServiceCenter(_serviceCender);\\n    }\\n\\n    function removeServiceCenter(address _serviceCenter) external onlyOwner {\\n        userInfo[_serviceCenter].isServiceCenter = false;\\n        emit RemoveServiceCenter(_serviceCenter);\\n    }\\n\\n    function addBlack(address _black) external onlyOwner {\\n        userInfo[_black].isBlack = true;\\n    }\\n\\n    function removeBlack(address _black) external onlyOwner {\\n        userInfo[_black].isBlack = false;\\n    }\\n\\n    // \u8bbe\u7f6e\u603b\u8d2d\u4e70\u4ee3\u5e01\\n    function setTimesAmount(uint256 _timesAmount) external onlyOwner {\\n        timesAmount = _timesAmount;\\n    }\\n\\n    function withdrawToken(address token) external onlyOwner {\\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\\n    }\\n}\"\r\n    },\r\n    \"contracts/Relation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract RelationStorage {\\n\\n    struct RecommerData {\\n        uint256 ts;\\n        address addr;\\n    }\\n\\n    uint public totalAddresses;\\n    // parent node\\n    mapping (address => address) public _recommerMapping;\\n    // have node\\n    mapping (address => bool) internal _haveChild;\\n    \\n    constructor() {\\n    }\\n}\\n\\ncontract Relation is RelationStorage, Ownable {\\n\\n    modifier onlyBoss() {\\n        require(bosses[msg.sender], \\\"Relation: caller is not the boss\\\");\\n        _;\\n    }\\n\\n    mapping(address => bool) public bosses;\\n\\n    function addBoss(address _boss) external onlyOwner {\\n        bosses[_boss] = true;\\n    }\\n\\n    function removeBoss(address _boss) external onlyOwner {\\n        bosses[_boss] = false;\\n    }\\n\\n    // bind\\n    function addRelationEx(address slef,address recommer) external onlyBoss returns (bool) {\\n\\n        require(recommer != slef,\\\"your_self\\\");                   \\n\\n        require(_recommerMapping[slef] == address(0),\\\"binded\\\");\\n        \\n        require(!_haveChild[slef], \\\"error\\\");\\n\\n        totalAddresses++;\\n\\n        _recommerMapping[slef] = recommer;\\n        _haveChild[slef] = true;\\n        return true;\\n    }\\n\\n    // find parent\\n    function parentOf(address owner) external view returns(address){\\n        return _recommerMapping[owner];\\n    }\\n    \\n    // find parent\\n    function getForefathers(address owner,uint num) public view returns(address[] memory fathers){\\n\\n        fathers = new address[](num);\\n\\n        address parent  = owner;\\n        for( uint i = 0; i < num; i++){\\n            parent = _recommerMapping[parent];\\n\\n            if(parent == address(0) ) break;\\n\\n            fathers[i] = parent;\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/DateTime.sol\": {\r\n        \"DateTime\": \"0x281002c3240627fe29e954ccebb8f2f13e3c0003\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cfo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mst\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"}],\"name\":\"AddRelationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AddServiceCenter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CooProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onwer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deductTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DeductHashrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"action\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RelationProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RemoveServiceCenter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ServiceCenterProfit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MST\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_black\",\"type\":\"address\"}],\"name\":\"addBlack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"}],\"name\":\"addRelationByAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"}],\"name\":\"addRelationEx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_serviceCender\",\"type\":\"address\"}],\"name\":\"addServiceCenter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooProfitRadio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deductRadio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"action\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getRedeemAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashrateLimitPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHashrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relationProfitRaido\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseRadio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_black\",\"type\":\"address\"}],\"name\":\"removeBlack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_serviceCenter\",\"type\":\"address\"}],\"name\":\"removeServiceCenter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceProfitRadio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cfo\",\"type\":\"address\"}],\"name\":\"setCfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coo\",\"type\":\"address\"}],\"name\":\"setCoo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cooProfitRadio\",\"type\":\"uint256\"}],\"name\":\"setCooProrfitRadio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deductRadio\",\"type\":\"uint256\"}],\"name\":\"setDeductRadio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hashrateLimitPerUser\",\"type\":\"uint256\"}],\"name\":\"setHashrateLimitPerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxHashrate\",\"type\":\"uint256\"}],\"name\":\"setMaxHashrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMst\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relation\",\"type\":\"address\"}],\"name\":\"setRelation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_relationProfitRadio\",\"type\":\"uint256\"}],\"name\":\"setRelationProfitRadio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_releaseRadio\",\"type\":\"uint256\"}],\"name\":\"setReleaseRadio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceProfitRadio\",\"type\":\"uint256\"}],\"name\":\"setServiceProfitRadio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timesAmount\",\"type\":\"uint256\"}],\"name\":\"setTimesAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalIssuance\",\"type\":\"uint256\"}],\"name\":\"setTotalIssuance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timesAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHashrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalIssuance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isServiceCenter\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isBlack\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MstDeposit", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000dc50206f370aa80cba9e7274fbf48ca1df62b82d000000000000000000000000c576043f9a171b0801de0e6bca7234e93f63e697000000000000000000000000bbd10784f69f50d6dae307be04a0e7eaf78c34f200000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000f9e7941f3deb84914098b046a490f495b43d4a31", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}