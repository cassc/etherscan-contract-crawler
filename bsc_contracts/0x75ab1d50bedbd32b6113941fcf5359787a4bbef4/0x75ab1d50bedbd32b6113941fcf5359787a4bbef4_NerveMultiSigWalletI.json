{"SourceCode": "pragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value, mapping(address => uint8) storage bugERC20s) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value), bugERC20s);\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value, mapping(address => uint8) storage bugERC20s) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value), bugERC20s);\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data, mapping(address => uint8) storage bugERC20s) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (bugERC20s[address(token)] != 0) {\r\n            return;\r\n        }\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// Part: ReentrancyGuard\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n        // Get a location of some free memory and store it in tempBytes as\r\n        // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n        // Store the length of the first bytes array at the beginning of\r\n        // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n        // Maintain a memory counter for the current write location in the\r\n        // temp bytes array by adding the 32 bytes for the array length to\r\n        // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n        // Stop copying when the memory counter reaches the length of the\r\n        // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n            // Initialize a copy counter to the start of the _preBytes data,\r\n            // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n            // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n            // Write the _preBytes data into the tempBytes memory 32 bytes\r\n            // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n        // Add the length of _postBytes to the current length of tempBytes\r\n        // and store it as the new length in the first 32 bytes of the\r\n        // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n        // Move the memory counter back from a multiple of 0x20 to the\r\n        // actual end of the _preBytes data.\r\n            mc := end\r\n        // Stop copying when the memory counter reaches the new combined\r\n        // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n        // Update the free-memory pointer by padding our last write location\r\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n        // next 32 byte block, then round down to the nearest multiple of\r\n        // 32. If the sum of the length of the two arrays is zero then add\r\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n            not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n        // Read the first 32 bytes of _preBytes storage, which is the length\r\n        // of the array. (We don't need to use the offset into the slot\r\n        // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n        // Arrays of 31 bytes or less have an even value in their slot,\r\n        // while longer arrays have an odd value. The actual length is\r\n        // the slot divided by two for odd values, and the lowest order\r\n        // byte divided by two for even values.\r\n        // If the slot is even, bitwise and the slot with 255 and divide by\r\n        // two to get the length. If the slot is odd, bitwise and the slot\r\n        // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n        // slength can contain both the length and contents of the array\r\n        // if length < 32 bytes so let's prepare for that\r\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n            // Since the new array still fits in the slot, we just need to\r\n            // update the contents of the slot.\r\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                _preBytes_slot,\r\n                // all the modifications to the slot are inside this\r\n                // next block\r\n                add(\r\n                // we can just add to the slot contents because the\r\n                // bytes we want to change are the LSBs\r\n                fslot,\r\n                add(\r\n                mul(\r\n                div(\r\n                // load the bytes from memory\r\n                mload(add(_postBytes, 0x20)),\r\n                // zero all bytes to the right\r\n                exp(0x100, sub(32, mlength))\r\n                ),\r\n                // and now shift left the number of bytes to\r\n                // leave space for the length in the slot\r\n                exp(0x100, sub(32, newlength))\r\n                ),\r\n                // increase length by the double of the memory\r\n                // bytes length\r\n                mul(mlength, 2)\r\n                )\r\n                )\r\n                )\r\n            }\r\n            case 1 {\r\n            // The stored value fits in the slot, but the combined value\r\n            // will exceed it.\r\n            // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n            // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n            // The contents of the _postBytes array start 32 bytes into\r\n            // the structure. Our first read should obtain the `submod`\r\n            // bytes that can fit into the unused space in the last word\r\n            // of the stored array. To get this, we read 32 bytes starting\r\n            // from `submod`, so the data we read overlaps with the array\r\n            // contents by `submod` bytes. Masking the lowest-order\r\n            // `submod` bytes allows us to add that value directly to the\r\n            // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                sc,\r\n                add(\r\n                and(\r\n                fslot,\r\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                ),\r\n                and(mload(mc), mask)\r\n                )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n            // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n            // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n            // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n            // Copy over the first `submod` bytes of the new data as in\r\n            // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n            // The first word of the slice result is potentially a partial\r\n            // word read from the original array. To read it, we calculate\r\n            // the length of that partial word and start copying that many\r\n            // bytes into the array. The first word we copy will start with\r\n            // data we don't care about, but the last `lengthmod` bytes will\r\n            // land at the beginning of the contents of the new array. When\r\n            // we're done copying, we overwrite the full first word with\r\n            // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n            // The multiplication in the next line is necessary\r\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n            // the following copy loop was copying the origin's length\r\n            // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                // The multiplication in the next line has the same exact purpose\r\n                // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n            //update free-memory pointer\r\n            //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n        // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n            // cb is a circuit breaker in the for loop since there's\r\n            //  no said feature for inline assembly loops\r\n            // cb = 1 - don't breaker\r\n            // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                    // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n            // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n        // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n        // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n        // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                    // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                        // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                    // cb is a circuit breaker in the for loop since there's\r\n                    //  no said feature for inline assembly loops\r\n                    // cb = 1 - don't breaker\r\n                    // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                    // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                    // the next line is the loop condition:\r\n                    // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                            // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n            // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\ninterface IERC20Minter {\r\n    function mint(address to, uint256 amount) external;\r\n    function burn(uint256 amount) external;\r\n    function replaceMinter(address newMinter) external;\r\n}\r\n\r\ncontract NerveMultiSigWalletIII is ReentrancyGuard {\r\n    using Address for address;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    modifier isOwner{\r\n        require(owner == msg.sender, \"Only owner can execute it\");\r\n        _;\r\n    }\r\n    modifier isManager{\r\n        require(managers[msg.sender] == 1, \"Only manager can execute it\");\r\n        _;\r\n    }\r\n    bool public upgrade = false;\r\n    address public upgradeContractAddress = address(0);\r\n    // \u6700\u5927\u7ba1\u7406\u5458\u6570\u91cf\r\n    uint public max_managers = 15;\r\n    // \u6700\u5c0f\u7ba1\u7406\u5458\u6570\u91cf\r\n    uint public min_managers = 3;\r\n    // \u6700\u5c0f\u7b7e\u540d\u6bd4\u4f8b 66%\r\n    uint public rate = 66;\r\n    // \u7b7e\u540d\u5b57\u8282\u957f\u5ea6\r\n    uint public signatureLength = 65;\r\n    // \u6bd4\u4f8b\u5206\u6bcd\r\n    uint constant DENOMINATOR = 100;\r\n    // \u5f53\u524d\u5408\u7ea6\u7248\u672c\r\n    uint8 constant VERSION = 3;\r\n    // hash\u8ba1\u7b97\u52a0\u76d0\r\n    uint public hashSalt; \r\n    // \u5f53\u524d\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\r\n    uint8 public current_min_signatures;\r\n    address public owner;\r\n    mapping(address => uint8) private seedManagers;\r\n    address[] private seedManagerArray;\r\n    mapping(address => uint8) private managers;\r\n    address[] private managerArray;\r\n    mapping(bytes32 => uint8) private completedKeccak256s;\r\n    mapping(string => uint8) private completedTxs;\r\n    mapping(address => uint8) private minterERC20s;\r\n    mapping(address => uint8) public bugERC20s;\r\n    bool public openCrossOutII = false;\r\n\r\n    constructor(uint256 _chainid, address[] memory _managers) public{\r\n        require(_managers.length <= max_managers, \"Exceeded the maximum number of managers\");\r\n        require(_managers.length >= min_managers, \"Not reaching the min number of managers\");\r\n        owner = msg.sender;\r\n        managerArray = _managers;\r\n        for (uint8 i = 0; i < managerArray.length; i++) {\r\n            managers[managerArray[i]] = 1;\r\n            seedManagers[managerArray[i]] = 1;\r\n            seedManagerArray.push(managerArray[i]);\r\n        }\r\n        require(managers[owner] == 0, \"Contract creator cannot act as manager\");\r\n        // \u8bbe\u7f6e\u5f53\u524d\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\r\n        current_min_signatures = calMinSignatures(managerArray.length);\r\n        hashSalt = _chainid * 2 + VERSION;\r\n    }\r\n    function() external payable {\r\n        emit DepositFunds(msg.sender, msg.value);\r\n    }\r\n\r\n    function createOrSignWithdraw(string memory txKey, address payable to, uint256 amount, bool isERC20, address ERC20, bytes memory signatures) public nonReentrant isManager {\r\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\r\n        require(to != address(0), \"Withdraw: transfer to the zero address\");\r\n        require(amount > 0, \"Withdrawal amount must be greater than 0\");\r\n        // \u6821\u9a8c\u5df2\u7ecf\u5b8c\u6210\u7684\u4ea4\u6613\r\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\r\n        // \u6821\u9a8c\u63d0\u73b0\u91d1\u989d\r\n        if (isERC20) {\r\n            validateTransferERC20(ERC20, to, amount);\r\n        } else {\r\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of ether\");\r\n        }\r\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, to, amount, isERC20, ERC20, hashSalt));\r\n        // \u6821\u9a8c\u8bf7\u6c42\u91cd\u590d\u6027\r\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\r\n        // \u6821\u9a8c\u7b7e\u540d\r\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\r\n        // \u6267\u884c\u8f6c\u8d26\r\n        if (isERC20) {\r\n            transferERC20(ERC20, to, amount);\r\n        } else {\r\n            // \u5b9e\u9645\u5230\u8d26\r\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of ether\");\r\n            to.transfer(amount);\r\n            emit TransferFunds(to, amount);\r\n        }\r\n        // \u4fdd\u5b58\u4ea4\u6613\u6570\u636e\r\n        completeTx(txKey, vHash, 1);\r\n        emit TxWithdrawCompleted(txKey);\r\n    }\r\n\r\n\r\n    function createOrSignManagerChange(string memory txKey, address[] memory adds, address[] memory removes, uint8 count, bytes memory signatures) public isManager {\r\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\r\n        require(adds.length > 0 || removes.length > 0, \"There are no managers joining or exiting\");\r\n        // \u6821\u9a8c\u5df2\u7ecf\u5b8c\u6210\u7684\u4ea4\u6613\r\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\r\n        preValidateAddsAndRemoves(adds, removes);\r\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, adds, count, removes, hashSalt));\r\n        // \u6821\u9a8c\u8bf7\u6c42\u91cd\u590d\u6027\r\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\r\n        // \u6821\u9a8c\u7b7e\u540d\r\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\r\n        // \u53d8\u66f4\u7ba1\u7406\u5458\r\n        removeManager(removes);\r\n        addManager(adds);\r\n        // \u66f4\u65b0\u5f53\u524d\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\r\n        current_min_signatures = calMinSignatures(managerArray.length);\r\n        // \u4fdd\u5b58\u4ea4\u6613\u6570\u636e\r\n        completeTx(txKey, vHash, 1);\r\n        // add event\r\n        emit TxManagerChangeCompleted(txKey);\r\n    }\r\n\r\n    function createOrSignUpgrade(string memory txKey, address upgradeContract, bytes memory signatures) public isManager {\r\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\r\n        // \u6821\u9a8c\u5df2\u7ecf\u5b8c\u6210\u7684\u4ea4\u6613\r\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\r\n        require(!upgrade, \"It has been upgraded\");\r\n        require(upgradeContract.isContract(), \"The address is not a contract address\");\r\n        // \u6821\u9a8c\r\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, upgradeContract, hashSalt));\r\n        // \u6821\u9a8c\u8bf7\u6c42\u91cd\u590d\u6027\r\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\r\n        // \u6821\u9a8c\u7b7e\u540d\r\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\r\n        // \u53d8\u66f4\u53ef\u5347\u7ea7\r\n        upgrade = true;\r\n        upgradeContractAddress = upgradeContract;\r\n        // \u4fdd\u5b58\u4ea4\u6613\u6570\u636e\r\n        completeTx(txKey, vHash, 1);\r\n        // add event\r\n        emit TxUpgradeCompleted(txKey);\r\n    }\r\n\r\n    function validSignature(bytes32 hash, bytes memory signatures) internal view returns (bool) {\r\n        require(signatures.length <= 975, \"Max length of signatures: 975\");\r\n        // \u83b7\u53d6\u7b7e\u540d\u5217\u8868\u5bf9\u5e94\u7684\u6709\u6548\u7ba1\u7406\u5458,\u5982\u679c\u5b58\u5728\u9519\u8bef\u7684\u7b7e\u540d\u3001\u6216\u8005\u4e0d\u662f\u7ba1\u7406\u5458\u7684\u7b7e\u540d\uff0c\u5c31\u5931\u8d25\r\n        uint sManagersCount = getManagerFromSignatures(hash, signatures);\r\n        // \u5224\u65ad\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\r\n        return sManagersCount >= current_min_signatures;\r\n    }\r\n\r\n    function getManagerFromSignatures(bytes32 hash, bytes memory signatures) internal view returns (uint){\r\n        uint signCount = 0;\r\n        uint times = signatures.length.div(signatureLength);\r\n        address[] memory result = new address[](times);\r\n        uint k = 0;\r\n        uint8 j = 0;\r\n        for (uint i = 0; i < times; i++) {\r\n            bytes memory sign = signatures.slice(k, signatureLength);\r\n            address mAddress = ecrecovery(hash, sign);\r\n            require(mAddress != address(0), \"Signatures error\");\r\n            // \u7ba1\u7406\u8ba1\u6570\r\n            if (managers[mAddress] == 1) {\r\n                signCount++;\r\n                result[j++] = mAddress;\r\n            }\r\n            k += signatureLength;\r\n        }\r\n        // \u9a8c\u8bc1\u5730\u5740\u91cd\u590d\u6027\r\n        bool suc = repeatability(result);\r\n        delete result;\r\n        require(suc, \"Signatures duplicate\");\r\n        return signCount;\r\n    }\r\n\r\n    function validateRepeatability(address currentAddress, address[] memory list) internal pure returns (bool) {\r\n        address tempAddress;\r\n        for (uint i = 0; i < list.length; i++) {\r\n            tempAddress = list[i];\r\n            if (tempAddress == address(0)) {\r\n                break;\r\n            }\r\n            if (tempAddress == currentAddress) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function repeatability(address[] memory list) internal pure returns (bool) {\r\n        for (uint i = 0; i < list.length; i++) {\r\n            address address1 = list[i];\r\n            if (address1 == address(0)) {\r\n                break;\r\n            }\r\n            for (uint j = i + 1; j < list.length; j++) {\r\n                address address2 = list[j];\r\n                if (address2 == address(0)) {\r\n                    break;\r\n                }\r\n                if (address1 == address2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function ecrecovery(bytes32 hash, bytes memory sig) internal view returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != signatureLength) {\r\n            return address(0);\r\n        }\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        if(uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        // https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function preValidateAddsAndRemoves(address[] memory adds, address[] memory removes) internal view {\r\n        // \u6821\u9a8cadds\r\n        uint addLen = adds.length;\r\n        for (uint i = 0; i < addLen; i++) {\r\n            address add = adds[i];\r\n            require(add != address(0), \"ERROR: Detected zero address in adds\");\r\n            require(managers[add] == 0, \"The address list that is being added already exists as a manager\");\r\n        }\r\n        require(repeatability(adds), \"Duplicate parameters for the address to join\");\r\n        // \u6821\u9a8c\u5408\u7ea6\u521b\u5efa\u8005\u4e0d\u80fd\u88ab\u6dfb\u52a0\r\n        require(validateRepeatability(owner, adds), \"Contract creator cannot act as manager\");\r\n        // \u6821\u9a8cremoves\r\n        require(repeatability(removes), \"Duplicate parameters for the address to exit\");\r\n        uint removeLen = removes.length;\r\n        for (uint i = 0; i < removeLen; i++) {\r\n            address remove = removes[i];\r\n            require(seedManagers[remove] == 0, \"Can't exit seed manager\");\r\n            require(managers[remove] == 1, \"There are addresses in the exiting address list that are not manager\");\r\n        }\r\n        require(managerArray.length + adds.length - removes.length <= max_managers, \"Exceeded the maximum number of managers\");\r\n    }\r\n\r\n    /*\r\n     \u6839\u636e `\u5f53\u524d\u6709\u6548\u7ba1\u7406\u5458\u6570\u91cf` \u548c `\u6700\u5c0f\u7b7e\u540d\u6bd4\u4f8b` \u8ba1\u7b97\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\uff0c\u5411\u4e0a\u53d6\u6574\r\n    */\r\n    function calMinSignatures(uint managerCounts) internal view returns (uint8) {\r\n        require(managerCounts > 0, \"Manager Can't empty.\");\r\n        uint numerator = rate * managerCounts + DENOMINATOR - 1;\r\n        return uint8(numerator / DENOMINATOR);\r\n    }\r\n    function removeManager(address[] memory removes) internal {\r\n        if (removes.length == 0) {\r\n            return;\r\n        }\r\n        for (uint i = 0; i < removes.length; i++) {\r\n            delete managers[removes[i]];\r\n        }\r\n        // \u904d\u5386\u4fee\u6539\u524d\u7ba1\u7406\u5458\u5217\u8868\r\n        for (uint i = 0; i < managerArray.length; i++) {\r\n            if (managers[managerArray[i]] == 0) {\r\n                delete managerArray[i];\r\n            }\r\n        }\r\n        uint tempIndex = 0x10;\r\n        for (uint i = 0; i<managerArray.length; i++) {\r\n            address temp = managerArray[i];\r\n            if (temp == address(0)) {\r\n                if (tempIndex == 0x10) tempIndex = i;\r\n                continue;\r\n            } else if (tempIndex != 0x10) {\r\n                managerArray[tempIndex] = temp;\r\n                tempIndex++;\r\n            }\r\n        }\r\n        managerArray.length -= removes.length;\r\n    }\r\n    function addManager(address[] memory adds) internal {\r\n        if (adds.length == 0) {\r\n            return;\r\n        }\r\n        for (uint i = 0; i < adds.length; i++) {\r\n            address add = adds[i];\r\n            if(managers[add] == 0) {\r\n                managers[add] = 1;\r\n                managerArray.push(add);\r\n            }\r\n        }\r\n    }\r\n    function completeTx(string memory txKey, bytes32 keccak256Hash, uint8 e) internal {\r\n        completedTxs[txKey] = e;\r\n        completedKeccak256s[keccak256Hash] = e;\r\n    }\r\n    function validateTransferERC20(address ERC20, address to, uint256 amount) internal view {\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(address(this) != ERC20, \"Do nothing by yourself\");\r\n        require(ERC20.isContract(), \"The address is not a contract address\");\r\n        if (isMinterERC20(ERC20)) {\r\n            // \u5b9a\u5236ERC20\u9a8c\u8bc1\u7ed3\u675f\r\n            return;\r\n        }\r\n        IERC20 token = IERC20(ERC20);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= amount, \"No enough balance of token\");\r\n    }\r\n    function transferERC20(address ERC20, address to, uint256 amount) internal {\r\n        if (isMinterERC20(ERC20)) {\r\n            // \u5b9a\u5236\u7684ERC20\uff0c\u8de8\u94fe\u8f6c\u5165\u4ee5\u592a\u574a\u7f51\u7edc\u5373\u589e\u53d1\r\n            IERC20Minter minterToken = IERC20Minter(ERC20);\r\n            minterToken.mint(to, amount);\r\n            return;\r\n        }\r\n        IERC20 token = IERC20(ERC20);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= amount, \"No enough balance of token\");\r\n        token.safeTransfer(to, amount, bugERC20s);\r\n    }\r\n    function closeUpgrade() public isOwner {\r\n        require(upgrade, \"Denied\");\r\n        upgrade = false;\r\n    }\r\n    function upgradeContractS1() public isOwner {\r\n        require(upgrade, \"Denied\");\r\n        require(upgradeContractAddress != address(0), \"ERROR: transfer to the zero address\");\r\n        address(uint160(upgradeContractAddress)).transfer(address(this).balance);\r\n    }\r\n    function upgradeContractS2(address ERC20) public isOwner {\r\n        require(upgrade, \"Denied\");\r\n        require(upgradeContractAddress != address(0), \"ERROR: transfer to the zero address\");\r\n        require(address(this) != ERC20, \"Do nothing by yourself\");\r\n        require(ERC20.isContract(), \"The address is not a contract address\");\r\n        IERC20 token = IERC20(ERC20);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= 0, \"No enough balance of token\");\r\n        token.safeTransfer(upgradeContractAddress, balance, bugERC20s);\r\n        if (isMinterERC20(ERC20)) {\r\n            // \u5b9a\u5236\u7684ERC20\uff0c\u8f6c\u79fb\u589e\u53d1\u9500\u6bc1\u6743\u9650\u5230\u65b0\u591a\u7b7e\u5408\u7ea6\r\n            IERC20Minter minterToken = IERC20Minter(ERC20);\r\n            minterToken.replaceMinter(upgradeContractAddress);\r\n        }\r\n    }\r\n\r\n    // \u662f\u5426\u5b9a\u5236\u7684ERC20\r\n    function isMinterERC20(address ERC20) public view returns (bool) {\r\n        return minterERC20s[ERC20] > 0;\r\n    }\r\n\r\n    // \u767b\u8bb0\u5b9a\u5236\u7684ERC20\r\n    function registerMinterERC20(address ERC20) public isOwner {\r\n        require(address(this) != ERC20, \"Do nothing by yourself\");\r\n        require(ERC20.isContract(), \"The address is not a contract address\");\r\n        require(!isMinterERC20(ERC20), \"This address has already been registered\");\r\n        minterERC20s[ERC20] = 1;\r\n    }\r\n\r\n    // \u53d6\u6d88\u767b\u8bb0\u5b9a\u5236\u7684ERC20\r\n    function unregisterMinterERC20(address ERC20) public isOwner {\r\n        require(isMinterERC20(ERC20), \"This address is not registered\");\r\n        delete minterERC20s[ERC20];\r\n    }\r\n\r\n    // \u767b\u8bb0BUG\u7684ERC20\r\n    function registerBugERC20(address bug) public isOwner {\r\n        require(address(this) != bug, \"Do nothing by yourself\");\r\n        require(bug.isContract(), \"The address is not a contract address\");\r\n        bugERC20s[bug] = 1;\r\n    }\r\n    // \u53d6\u6d88\u767b\u8bb0BUG\u7684ERC20\r\n    function unregisterBugERC20(address bug) public isOwner {\r\n        bugERC20s[bug] = 0;\r\n    }\r\n    // \u4eceeth\u7f51\u7edc\u8de8\u94fe\u8f6c\u51fa\u8d44\u4ea7(ETH or ERC20)\r\n    function crossOut(string memory to, uint256 amount, address ERC20) public payable returns (bool) {\r\n        address from = msg.sender;\r\n        require(amount > 0, \"ERROR: Zero amount\");\r\n        if (ERC20 != address(0)) {\r\n            require(msg.value == 0, \"ERC20: Does not accept Ethereum Coin\");\r\n            require(ERC20.isContract(), \"The address is not a contract address\");\r\n            IERC20 token = IERC20(ERC20);\r\n            uint256 allowance = token.allowance(from, address(this));\r\n            require(allowance >= amount, \"No enough amount for authorization\");\r\n            uint256 fromBalance = token.balanceOf(from);\r\n            require(fromBalance >= amount, \"No enough balance of the token\");\r\n            token.safeTransferFrom(from, address(this), amount, bugERC20s);\r\n            if (isMinterERC20(ERC20)) {\r\n                // \u5b9a\u5236\u7684ERC20\uff0c\u4ece\u4ee5\u592a\u574a\u7f51\u7edc\u8de8\u94fe\u8f6c\u51fatoken\u5373\u9500\u6bc1\r\n                IERC20Minter minterToken = IERC20Minter(ERC20);\r\n                minterToken.burn(amount);\r\n            }\r\n        } else {\r\n            require(msg.value == amount, \"Inconsistency Ethereum amount\");\r\n        }\r\n        emit CrossOutFunds(from, to, amount, ERC20);\r\n        return true;\r\n    }\r\n\r\n    // \u4eceeth\u7f51\u7edc\u8de8\u94fe\u8f6c\u51fa\u8d44\u4ea7(ETH or ERC20)\r\n    function crossOutII(string memory to, uint256 amount, address ERC20, bytes memory data) public payable returns (bool) {\r\n        require(openCrossOutII, \"CrossOutII: Not open\");\r\n        address from = msg.sender;\r\n        uint erc20Amount = 0;\r\n        if (ERC20 != address(0)) {\r\n            require(amount > 0, \"ERROR: Zero amount\");\r\n            require(ERC20.isContract(), \"The address is not a contract address\");\r\n            IERC20 token = IERC20(ERC20);\r\n            uint256 allowance = token.allowance(from, address(this));\r\n            require(allowance >= amount, \"No enough amount for authorization\");\r\n            uint256 fromBalance = token.balanceOf(from);\r\n            require(fromBalance >= amount, \"No enough balance of the token\");\r\n            token.safeTransferFrom(from, address(this), amount, bugERC20s);\r\n            if (isMinterERC20(ERC20)) {\r\n                // \u5b9a\u5236\u7684ERC20\uff0c\u4ece\u4ee5\u592a\u574a\u7f51\u7edc\u8de8\u94fe\u8f6c\u51fatoken\u5373\u9500\u6bc1\r\n                IERC20Minter minterToken = IERC20Minter(ERC20);\r\n                minterToken.burn(amount);\r\n            }\r\n            erc20Amount = amount;\r\n        } else {\r\n            require(msg.value > 0 && amount == 0, \"CrossOutII: Illegal eth amount\");\r\n        }\r\n        emit CrossOutIIFunds(from, to, erc20Amount, ERC20, msg.value, data);\r\n        return true;\r\n    }\r\n\r\n    function setCrossOutII(bool _open) public isOwner {\r\n        openCrossOutII = _open;\r\n    }\r\n\r\n    function isCompletedTx(string memory txKey) public view returns (bool){\r\n        return completedTxs[txKey] > 0;\r\n    }\r\n    function ifManager(address _manager) public view returns (bool) {\r\n        return managers[_manager] == 1;\r\n    }\r\n    function allManagers() public view returns (address[] memory) {\r\n        return managerArray;\r\n    }\r\n    event DepositFunds(address from, uint amount);\r\n    event CrossOutFunds(address from, string to, uint amount, address ERC20);\r\n    event CrossOutIIFunds(address from, string to, uint amount, address ERC20, uint ethAmount, bytes data);\r\n    event TransferFunds(address to, uint amount);\r\n    event TxWithdrawCompleted(string txKey);\r\n    event TxManagerChangeCompleted(string txKey);\r\n    event TxUpgradeCompleted(string txKey);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainid\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_managers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"CrossOutFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"CrossOutIIFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"TxManagerChangeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"TxUpgradeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"TxWithdrawCompleted\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"allManagers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bugERC20s\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"adds\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"removes\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"createOrSignManagerChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"upgradeContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"createOrSignUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isERC20\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"createOrSignWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"crossOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"crossOutII\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_min_signatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashSalt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ifManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"isCompletedTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"isMinterERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_managers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_managers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openCrossOutII\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"bug\",\"type\":\"address\"}],\"name\":\"registerBugERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"registerMinterERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_open\",\"type\":\"bool\"}],\"name\":\"setCrossOutII\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signatureLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"bug\",\"type\":\"address\"}],\"name\":\"unregisterBugERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"unregisterMinterERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradeContractS1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"upgradeContractS2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NerveMultiSigWalletIII", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000003800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000d87f2ad3ef011817319fd25454fc186ca71b3b560000000000000000000000000eb9e4427a0af1fa457230bef3481d028488363e000000000000000000000000d6946039519bccc0b302f89493bec60f4f0b4610", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://95362de7fdf4ec3e185dbb78fd46d56f1688dd2b375a85b3badd17bb0a57a2d8"}