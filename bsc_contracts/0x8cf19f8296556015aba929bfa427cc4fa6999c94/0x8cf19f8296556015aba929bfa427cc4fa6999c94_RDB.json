{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RDB.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.19;\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// file: pinkBotInterface.sol\\ninterface IPinkAntiBot {\\n    function setTokenOwner(address owner) external;\\n\\n    function onPreTransferCheck(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n}\\n\\n// file: RDB.sol\\n/**\\n * @title RDB Token\\n * @dev Implementation of the RDB Token\\n */\\ncontract RDB is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping(address => uint256) private _rOwned;\\n    mapping(address => uint256) private _tOwned;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n\\n    mapping(address => bool) private _isExcludedFromFee;\\n    mapping(address => bool) private _isExcluded;\\n    bool public isTradingEnabled;\\n    bool public isPinkBotEnabled;\\n\\n    address[] private _excluded;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private constant _tTotal = 100000000 * 1e9; // 100 million supply\\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\\n    uint256 private _tFeeTotal;\\n    uint256 public maxWallet = 1000000 * 1e9; // 1 million (1% of the supply)\\n\\n\\n\\n    string private constant _name = \\\"RDB Token\\\";\\n    string private constant _symbol = \\\"RDB\\\";\\n    uint8 private constant _decimals = 9;\\n\\n    struct BuyFee {\\n        uint16 marketingFee;\\n        uint16 reflectionFee;\\n        uint16 developmentFee;\\n        uint16 founderFee;\\n    }\\n\\n    struct SellFee {\\n        uint16 marketingFee;\\n        uint16 reflectionFee;\\n        uint16 developmentFee;\\n        uint16 founderFee;\\n    }\\n\\n    BuyFee public buyFee;\\n    SellFee public sellFee;\\n\\n    uint16 private _reflectionFee;\\n    uint16 private _marketingFee;\\n    uint16 private _developmentFee;\\n    uint16 private _founderFee;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public uniswapV2Pair;\\n    address public founderWallet;\\n    address public developmentWallet;\\n    address public marketingWallet;\\n    address public presaleAddress;\\n\\n    IPinkAntiBot public pinkAntiBot;\\n\\n\\n    bool internal inSwapAndLiquify;\\n    bool public swapAndLiquifyEnabled = true;\\n\\n    uint256 private swapThreshold = 1000 * 1e9;\\n\\n\\n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived\\n    );\\n    event MaxWalletUpdated(uint256 amount);\\n    event BuyFeesUpdated (uint256 marketingFee, uint256 ReflectionFee, uint256 developmentFee, uint256 FounderFee);\\n    event SellFeesUpdated (uint256 marketingFee, uint256 ReflectionFee, uint256 developmentFee, uint256 FounderFee);\\n    event TokensClaimed (address indexed token, uint256 amount);\\n    event BNBClaimed (uint256 amount);\\n\\n    event RouterUpdated(address indexed oldRouter, address indexed newRouter);\\n\\n    modifier lockTheSwap() {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    /**\\n     * @dev Contract constructor function. Initializes contract state variables and sets the owner of the contract.\\n     * The constructor sets the initial supply, fee rates, and creates a Uniswap pair for the token.\\n     * It also sets the addresses for the marketing, development, and founder wallets.\\n     * Finally, it excludes the owner and the contract itself from fees, and emits a `Transfer` event.\\n     */\\n    constructor() {\\n        _rOwned[_msgSender()] = _rTotal;\\n\\n        // Set fee rates\\n        buyFee.reflectionFee = 1;\\n        buyFee.marketingFee = 1;\\n        buyFee.developmentFee =1;\\n        buyFee.founderFee = 1;\\n\\n        sellFee.reflectionFee = 2;\\n        sellFee.marketingFee = 2;\\n        sellFee.developmentFee = 2;\\n        sellFee.founderFee = 2;\\n\\n        // Creating an instance of the PinkAntiBot variable from the given address\\n        //https://github.com/pinkmoonfinance/pink-antibot-guide\\n        pinkAntiBot = IPinkAntiBot(0x8EFDb3b642eb2a20607ffe0A56CFefF6a95Df002);\\n        pinkAntiBot.setTokenOwner(msg.sender);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\n            0x10ED43C718714eb63d5aA57B78B54704E256024E // pancakeswap Router\\n        );\\n        // Create a uniswap pair for this new token\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        // set the rest of the contract variables\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        // set your wallets below\\n\\n        founderWallet = address(0xc7f72fEf9B09503cEf0c26188D714403dce71E7E);\\n        developmentWallet = address(0x269F5B5A349DDD46126a6AFfD1936b776F55162F);\\n        marketingWallet = address(0xE0747a60E81B616990cEbF791602e41571755D6c);\\n        //exclude owner and this contract from fee\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n\\n        emit Transfer(address(0), _msgSender(), _tTotal );\\n\\n    }\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the total token supply.\\n     */\\n    function totalSupply() public pure override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    /**\\n     * @dev Returns the token balance of the given `account`.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcluded[account]) return _tOwned[account];\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    /**\\n     * @dev Returns the token balance of the given `account`.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n    public\\n    override\\n    returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the token allowance for the given `owner` and `spender`.\\n     */\\n    function allowance(address tokenOwner, address spender)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n    {\\n        return _allowances[tokenOwner][spender];\\n    }\\n\\n    /**\\n     * @dev Sets the allowance to `amount` for the `spender` address.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount)\\n    public\\n    override\\n    returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * This function emits a {Transfer} event and an {Approval} event indicating\\n     * the updated allowance.\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least `amount`.\\n     *\\n     * @param sender the address of the sender.\\n     * @param recipient the address of the recipient.\\n     * @param amount the amount of tokens to be transferred.\\n     * @return a boolean value indicating whether the operation succeeded.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount)\\n    public\\n    override\\n    returns (bool)\\n    {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n    public\\n    virtual\\n    returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Decreases the allowance granted by the caller to `spender`.\\n    * This is an alternative to {approve} that can be used as a mitigation for\\n    * problems described in {IERC20-approve}.\\n    * Emits an {Approval} event indicating the updated allowance.\\n    * Requirements:\\n    * - `spender` cannot be the zero address.\\n    * - `spender` must have allowance for the caller of at least\\n    * `subtractedValue`.\\n    * @param spender The address which will spend the funds.\\n    * @param subtractedValue The amount of allowance to decrease.\\n    * @return A boolean value indicating whether the operation succeeded.\\n    */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n    public\\n    virtual\\n    returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens to the contract itself, which will effectively remove the tokens from circulation.\\n     * This will increase the rate at which all holders will earn rewards.\\n     * @param tAmount The amount of tokens to be delivered (removed from circulation).\\n     */\\n    function deliver(uint256 tAmount) public {\\n        address sender = _msgSender();\\n        require(\\n            !_isExcluded[sender],\\n            \\\"Excluded addresses cannot call this function\\\"\\n        );\\n        (uint256 rAmount, , , , , ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _rTotal = _rTotal.sub(rAmount);\\n        _tFeeTotal = _tFeeTotal.add(tAmount);\\n    }\\n\\n    /**\\n     * @dev Returns the reflection amount of given token amount\\n     *\\n     * This function is used to get the reflection amount from a given token amount with the option to deduct the transfer fee.\\n     * It's a view function meaning it will not modify the state of the blockchain. It will only read the values.\\n     *\\n     * @param tAmount - the token amount to get the reflection from\\n     * @param deductTransferFee - a boolean value indicating whether the transfer fee should be deducted\\n     *\\n     * @return - the calculated reflection amount\\n     */\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rTransferAmount, , , , ) = _getValues(tAmount);\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    /**\\n    * @dev Converts reflection amount to token amount\\n    * @param rAmount amount of reflection\\n    * @return amount of tokens\\n    */\\n    function tokenFromReflection(uint256 rAmount)\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        require(\\n            rAmount <= _rTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount.div(currentRate);\\n    }\\n\\n    ///@dev update the router\\n    ///@param newAddress: owner can update the router address\\n    function updateRouter(address newAddress) external onlyOwner {\\n        require(newAddress != address(uniswapV2Router), \\\"The router already has that address\\\");\\n        require(newAddress != address(0), \\\"zero address not allowed\\\");\\n        address oldRouter = address(uniswapV2Router);\\n        uniswapV2Router = IUniswapV2Router02(newAddress);\\n        address get_pair =\\n                                IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this),\\n                uniswapV2Router.WETH());\\n        if (get_pair == address(0)) {\\n            uniswapV2Pair =\\n                                    IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this),\\n                    uniswapV2Router.WETH());\\n        } else {\\n            uniswapV2Pair = get_pair;\\n        }\\n\\n        emit RouterUpdated(oldRouter, newAddress);\\n    }\\n\\n    ///@dev enable or disbale pinkbot\\n    ///@param value: boolean value, true means enabled, false means disabled\\n    function managePinkBot (bool value) external onlyOwner {\\n        isPinkBotEnabled = value;\\n    }\\n\\n    ///@dev set presale address (useful incase using pinksale or similiar platform for presale)\\n    ///@param _presaleAddress: presale address\\n    function setPresaleAddress(address _presaleAddress) external onlyOwner {\\n        require (_presaleAddress != address(0), \\\"zero address not allowed\\\");\\n        presaleAddress = _presaleAddress;\\n        _isExcludedFromFee[_presaleAddress] = true;\\n    }\\n\\n    ///@dev update max wallet amount\\n    ///@param amount: new maxWallet amount, must be greator than equal to 1 percent of the supply\\n    function updateMaxWalletAmount (uint256 amount) external onlyOwner {\\n        require (amount >= totalSupply() /100,\\\"amount must be 1% or more of the total supply\\\");\\n        maxWallet = amount;\\n        emit MaxWalletUpdated (amount);\\n    }\\n\\n    ///@notice Returns if an address is excluded or not from reflection\\n    function isExcludedFromReward(address account) public view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n\\n    ///@notice Returns total reflection distributed so far\\n    function totalFees() public view returns (uint256) {\\n        return _tFeeTotal;\\n    }\\n\\n    ///@dev exclude a particular address from reward\\n    ///@param account: address to be excluded from reward\\n    function excludeFromReward(address account) public onlyOwner {\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n        if (_rOwned[account] > 0) {\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\n        }\\n        _isExcluded[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    ///@dev include a address in reward\\n    ///@param account: address to be added in reward mapping again\\n    function includeInReward (address account) external onlyOwner {\\n        require(_isExcluded [account], \\\"Account is already excluded\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n\\n            if (_excluded[i] == account){\\n                //updating _rOwned to make sure the balances stay the same\\n                if (_tOwned [account] > 0) {\\n                    uint256 newrOwned = _tOwned [account].mul(_getRate());\\n                    _rTotal = _rTotal.sub(_rOwned [account]-newrOwned);\\n                    _rOwned[account] = newrOwned;\\n                }\\n                else{\\n                    _rOwned [account] = 0;\\n                }\\n                _tOwned[account]= 0;\\n                _excluded [i] = _excluded [_excluded.length-1];\\n                _isExcluded [account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    ///@dev manage exclude and include fee\\n    ///@param account: account to be excluded or included\\n    ///@param excluded: boolean value, true means excluded, false means included\\n    function excludeFromFee(address account, bool excluded) external onlyOwner {\\n        require(account != presaleAddress, \\\"Presale address cannot be included in fees again\\\");\\n        if (excluded) {\\n            require(!_isExcludedFromFee[account], \\\"already excluded\\\");\\n        }\\n        _isExcludedFromFee[account] = excluded;\\n    }\\n\\n\\n    ///@dev set buy fees\\n    ///@param market: new marketing fee on buy\\n    ///@param reflection: new reflection fee on buy\\n    ///@param development: new development fee on buy\\n    ///@param founder: new founder fee on buy\\n    function setBuyFee(\\n        uint16 market,\\n        uint16 reflection,\\n        uint16 development,\\n        uint16 founder\\n    ) external onlyOwner {\\n        buyFee.marketingFee = market;\\n        buyFee.reflectionFee = reflection;\\n        buyFee.developmentFee = development;\\n        buyFee.founderFee = founder;\\n        uint256 totalBuyFee = market  + reflection + development + founder;\\n        require(totalBuyFee <= 10, \\\"max buy fee limit is 10%\\\");\\n\\n        emit BuyFeesUpdated (market, reflection, development, founder);\\n    }\\n\\n    ///@dev set sell fees\\n    ///@param market: new marketing fee on sell\\n    ///@param reflection: new reflection fee on sell\\n    ///@param development: new development fee on sell\\n    ///@param founder: new founder fee on sell\\n    function setSellFee(\\n        uint16 market,\\n        uint16 reflection,\\n        uint16 development,\\n        uint16 founder\\n    ) external onlyOwner {\\n        sellFee.marketingFee = market;\\n        sellFee.reflectionFee = reflection;\\n        sellFee.developmentFee = development;\\n        sellFee.founderFee = founder;\\n        uint256 totalSellFee = market  + reflection + development + founder;\\n        require(totalSellFee <= 10, \\\"max sell fee limit is 10%\\\");\\n        emit SellFeesUpdated (market, reflection, development, founder);\\n    }\\n\\n    ///@dev set swap amount after which collected tax should be swappped for ether\\n    ///@param numTokens: new token amount\\n    function setSwapTokensAtAmount(uint256 numTokens)  external onlyOwner {\\n        swapThreshold = numTokens * 1e9;\\n        emit MinTokensBeforeSwapUpdated(numTokens);\\n    }\\n\\n\\n    ///@dev claim stucked tokens from contract\\n    ///@param _token: token address to be rescued\\n    function claimStuckTokens(address _token) external onlyOwner {\\n        require(_token != address(0), \\\"Invalid token address\\\");\\n        require(_token != address(this), \\\"Can't claim native token\\\");\\n        IERC20 erc20token = IERC20(_token);\\n        uint256 balance = erc20token.balanceOf(address(this));\\n        erc20token.transfer(owner(), balance);\\n        emit TokensClaimed(_token, balance);\\n    }\\n\\n    ///@dev owner can claim any stucked BNB from contract\\n    function claimBNB() external onlyOwner {\\n        (bool sent,) = owner().call{value: address(this).balance}(\\\"\\\");\\n        require (sent, \\\"bnb transfer failed\\\");\\n        emit BNBClaimed (address(this).balance);\\n    }\\n\\n    //to recieve ETH from uniswapV2Router when swaping\\n    receive() external payable {\\n        this;\\n    }\\n\\n    /**\\n     * @dev Internal function that handles how the fees are stored and reflected.\\n     * This method is called after fees are calculated and is used to reduce the total reflected amount and fee total.\\n     *\\n     * @param rFee The reflection fee amount in RType.\\n     * @param tFee The fee amount in TokenType.\\n     */\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\n        _rTotal = _rTotal.sub(rFee);\\n        _tFeeTotal = _tFeeTotal.add(tFee);\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate reflection values.\\n     * @param tAmount The total amount of tokens.\\n     * @return rAmount The calculated reflection amount.\\n     * @return rTransferAmount The calculated transfer reflection amount.\\n     * @return rFee The calculated reflection fee.\\n     */\\n    function _getValues(uint256 tAmount)\\n    private\\n    view\\n    returns (\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256\\n    )\\n    {\\n        (\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tMarketing,\\n            uint256 tDevelopment,\\n            uint256 tFounder\\n        ) = _getTValues(tAmount);\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\\n            tAmount,\\n            tFee,\\n            tMarketing,\\n            tDevelopment,\\n            tFounder,\\n            _getRate()\\n        );\\n        return (\\n            rAmount,\\n            rTransferAmount,\\n            rFee,\\n            tTransferAmount,\\n            tFee,\\n            tMarketing\\n        );\\n    }\\n\\n    function _getTValues(uint256 tAmount)\\n    private\\n    view\\n    returns (\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256\\n    )\\n    {\\n        uint256 tFee = calculateReflectionFee(tAmount);\\n        uint256 tMarketing = calculateMarketingFee(tAmount);\\n        uint256 tDevelopment = calculateDevelopmentFee(tAmount);\\n        uint256 tFounder = calculateFounderFee(tAmount);\\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tMarketing);\\n        tTransferAmount = tTransferAmount.sub(tDevelopment).sub(tFounder);\\n        return (tTransferAmount, tFee, tMarketing, tDevelopment, tFounder);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tFee,\\n        uint256 tMarketing,\\n        uint256 tDevelopment,\\n        uint256 tFounder,\\n        uint256 currentRate\\n    )\\n    private\\n    pure\\n    returns (\\n        uint256,\\n        uint256,\\n        uint256\\n    )\\n    {\\n        uint256 rAmount = tAmount.mul(currentRate);\\n        uint256 rFee = tFee.mul(currentRate);\\n        uint256 rMarketing = tMarketing.mul(currentRate);\\n        uint256 rDevelopment = tDevelopment.mul(currentRate);\\n        uint256 rFounder = tFounder.mul(currentRate);\\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rMarketing).sub(\\n            rDevelopment).sub(rFounder);\\n        return (rAmount, rTransferAmount, rFee);\\n    }\\n\\n    /**\\n     * @dev Internal function that handles the transfer of fees to the contract address.\\n     * This method is called before fees are distributed and is used to store the fees in this contract.\\n     */\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply.div(tSupply);\\n    }\\n\\n    /**\\n     * @dev Internal function that handles the transfer of fees to the contract address.\\n     * This method is called before fees are distributed and is used to store the fees in this contract.\\n     */\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (\\n                _rOwned[_excluded[i]] > rSupply ||\\n                _tOwned[_excluded[i]] > tSupply\\n            ) return (_rTotal, _tTotal);\\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\\n        }\\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    /**\\n     * @dev Internal function that handles how the marketing fee is taken from the transaction.\\n     * This is necessary to ensure the marketing wallet receives the correct number of tokens.\\n     * @param tMarketing The number of tokens to be taken as marketing fee from the transaction.\\n     */\\n    function _takeMarketing(uint256 tMarketing) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rMarketing = tMarketing.mul(currentRate);\\n        _rOwned[address(this)] = _rOwned[address(this)].add(rMarketing);\\n        if (_isExcluded[address(this)])\\n            _tOwned[address(this)] = _tOwned[address(this)].add(tMarketing);\\n\\n    }\\n\\n    /**\\n     * @dev Internal function to handle the collection of development fees during transactions.\\n     * The collected development fees are added to the contract's balance.\\n     * @param tDevelopment The amount of tokens to be collected as development fees.\\n     */\\n    function _takeDevelopment(uint256 tDevelopment) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rDevelopment = tDevelopment.mul(currentRate);\\n\\n        _rOwned[address(this)] = _rOwned[address(this)].add(rDevelopment);\\n        if (_isExcluded[address(this)]) {\\n            _tOwned[address(this)] = _tOwned[address(this)].add(tDevelopment);\\n        }\\n    }\\n\\n    function _takeFounder(uint256 tFounder) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rFounder = tFounder.mul(currentRate);\\n\\n        _rOwned[address(this)] = _rOwned[address(this)].add(rFounder);\\n        if (_isExcluded[address(this)]) {\\n            _tOwned[address(this)] = _tOwned[address(this)].add(tFounder);\\n        }\\n    }\\n\\n    ///@notice enabled trading globally,\\n    ///can be called once and can never be turned off.\\n    function enableTrading () external onlyOwner {\\n        require (!isTradingEnabled, \\\"trading is already live\\\");\\n        isTradingEnabled = true;\\n\\n    }\\n\\n    ///@dev Calculates the reflection fee for a given amount.\\n    /// @param _amount The amount to calculate the reflection fee for.\\n    /// @return The calculated reflection fee.\\n    function calculateReflectionFee(uint256 _amount) private view returns (uint256) {\\n        return _amount.mul(_reflectionFee).div(10**2);\\n    }\\n\\n    ///@dev Calculates the Marketing fee for a given amount.\\n    /// @param _amount The amount to calculate the marketing fee for.\\n    /// @return The calculated marketing fee.\\n    function calculateMarketingFee(uint256 _amount)\\n    private\\n    view\\n    returns (uint256)\\n    {\\n        return _amount.mul(_marketingFee).div(10**2);\\n    }\\n\\n    ///@dev Calculates the Development fee for a given amount.\\n    /// @param _amount The amount to calculate the development fee for.\\n    /// @return The calculated development fee.\\n    function calculateDevelopmentFee(uint256 _amount)\\n    private\\n    view\\n    returns (uint256)\\n    {\\n        return _amount.mul(_developmentFee).div(10**2);\\n    }\\n\\n\\n    ///@dev Calculates the founder fee for a given amount.\\n    /// @param _amount The amount to calculate the founder fee for.\\n    /// @return The calculated founder fee.\\n    function calculateFounderFee(uint256 _amount) private view returns (uint256){\\n        return _amount.mul(_founderFee).div(10**2);\\n    }\\n\\n    /**\\n     * @dev Internal function to reflect the transaction fee. This is done by reducing the total reflected supply (_rTotal) and increasing\\n     * the total fee (_tFeeTotal) by the amount of the reflected fee.\\n     */\\n    function removeAllFee() private {\\n        _reflectionFee = 0;\\n        _marketingFee = 0;\\n        _developmentFee = 0;\\n        _founderFee = 0;\\n    }\\n\\n    /**\\n     * @dev Sets the fees for buy transactions.\\n     * The fees are set according to the `buyFee` struct values.\\n     * This function is called in the `_tokenTransfer()` function when a buy transaction is detected.\\n     */\\n    function setBuy() private {\\n        _reflectionFee = buyFee.reflectionFee;\\n        _marketingFee = buyFee.marketingFee;\\n        _developmentFee = buyFee.developmentFee;\\n        _founderFee = buyFee.founderFee;\\n    }\\n\\n    /**\\n     * @dev This function sets the fees for selling transactions.\\n     * It is called whenever a sell is happening. The fees are set according to the sellFee structure.\\n     * The fees include reflectionFee, marketingFee, developmentFee and founderFee.\\n     * These fees are used to distribute rewards, cover operational costs, etc.\\n     */\\n    function setSell() private {\\n        _reflectionFee = sellFee.reflectionFee;\\n        _marketingFee = sellFee.marketingFee;\\n        _developmentFee = sellFee.developmentFee;\\n        _founderFee = sellFee.founderFee;\\n    }\\n\\n    /**\\n     * @dev Function to check if an address is excluded from fee\\n     * @param account Address of the account to check\\n     * @return bool indicating whether the account is excluded from fee\\n     */\\n    function isExcludedFromFee(address account) public view returns (bool) {\\n        return _isExcludedFromFee[account];\\n    }\\n\\n    /**\\n     * @dev Toggles the state of the swap and liquify feature of the contract.\\n     * When `swapAndLiquifyEnabled` is true, the contract will automatically swap and liquify tokens.\\n     * This is beneficial as it automatically adds liquidity and stabilizes the token price.\\n     * When `swapAndLiquifyEnabled` is false, the contract will not swap and liquify tokens.\\n     * This function can only be called by the owner of the contract.\\n     */\\n    function toggleSwapAndLiquify() external onlyOwner {\\n        swapAndLiquifyEnabled = !swapAndLiquifyEnabled;\\n    }\\n\\n    /**\\n     * @dev Internal function that sets the approval amount for a given spender. `approve` and `increaseAllowance`\\n     * call this function to update the spender's allowance. It emits an `Approval` event.\\n     * @param tokenOwner The address of the token owner.\\n     * @param spender The address of the spender.\\n     * @param amount The amount of allowance.\\n     */\\n    function _approve(\\n        address tokenOwner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(tokenOwner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[tokenOwner][spender] = amount;\\n        emit Approval(tokenOwner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev A private function to handle token transfers. It contains conditions to check whether the transfer is to or from an excluded account,\\n     * whether it's a buy or sell operation and whether the max wallet limit has been exceeded.\\n     * @param from The account to transfer tokens from.\\n     * @param to The account to transfer tokens to.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        if(from != owner() && to != owner()){\\n            require(isTradingEnabled, \\\"Trading is not enabled yet\\\");\\n        }\\n\\n        if(from != owner() || from != presaleAddress){\\n            require (isTradingEnabled, \\\"trading is not live\\\");\\n        }\\n\\n        // is the token balance of this contract address over the min number of\\n        // tokens that we need to initiate a swap + liquidity lock?\\n        // also, don't get caught in a circular liquidity event.\\n        // also, don't swap & liquify if sender is uniswap pair.\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool overMinTokenBalance = contractTokenBalance >=\\n                    swapThreshold;\\n        if (\\n            overMinTokenBalance &&\\n            !inSwapAndLiquify &&\\n            from != uniswapV2Pair &&\\n            swapAndLiquifyEnabled\\n        ) {\\n\\n            swapAndLiquify(contractTokenBalance);\\n        }\\n\\n        //indicates if fee should be deducted from transfer\\n        bool takeFee = true;\\n\\n        //if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\\n            takeFee = false;\\n        }\\n\\n        //transfer amount, it will take reflection, liquidity fee\\n        _tokenTransfer(from, to, amount, takeFee);\\n    }\\n\\n    /**\\n     * @dev Swaps and liquifies tokens whenever it reaches the threshold.\\n     * This function is used to automatically add liquidity and balance the price impact of large sales.\\n     * It swaps half of the tokens for BNB, then pairs it with the remaining half to add as a liquidity pair on PancakeSwap.\\n     * @param tokens The number of tokens to be swapped and liquified.\\n     */\\n    function swapAndLiquify(uint256 tokens) private lockTheSwap {\\n        uint256 oldBalance = address(this).balance;\\n        // swap tokens for ETH\\n        swapTokensForEth(tokens);\\n        // how much ETH did we just swap into?\\n        uint256 newBalance = address(this).balance.sub(oldBalance);\\n        uint256 divisor = buyFee.marketingFee + buyFee.developmentFee + buyFee.founderFee\\n            + sellFee.marketingFee + sellFee.developmentFee + sellFee.founderFee;\\n\\n        uint256 marketingShare = newBalance.mul(buyFee.marketingFee + sellFee.marketingFee).div(divisor);\\n        uint256 developmentShare = newBalance.mul(buyFee.developmentFee + sellFee.developmentFee).div(divisor);\\n        (bool sent,) = marketingWallet.call{value: marketingShare}(\\\"\\\");\\n        require(sent,\\\"bnb transfer to marketing wallet failed\\\");\\n        (bool sent1,) = developmentWallet.call{value: developmentShare}(\\\"\\\");\\n        require(sent1,\\\"bnb transfer to development wallet failed\\\");\\n        (bool sent2,) = founderWallet.call{value: address(this).balance}(\\\"\\\");\\n        require(sent2,\\\"bnb transfer to founder wallet failed\\\");\\n\\n        emit SwapAndLiquify(tokens, newBalance);\\n    }\\n\\n    /**\\n     * @dev Swaps tokens for BNB. This function is used for the swapAndLiquify function.\\n     * @param tokenAmount The number of tokens to be swapped.\\n     */\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of BNB\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Swaps BNB for tokens which are then sent to a burn address to reduce supply.\\n     * This function is only callable by the contract owner.\\n     * @param bnbAmount The amount of BNB to swap for tokens.\\n     */\\n    function swapBNBforTokens (uint256 bnbAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = uniswapV2Router.WETH();\\n        path[1] = address(this);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbAmount}(\\n            0, // accept any amount of tokens\\n            path,\\n            address(0xdead),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the addresses of the fee wallets\\n     * @param marketing The new address for the marketing wallet\\n     * @param founder The new address for the founder wallet\\n     * @param development The new address for the development wallet\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     * - `marketing` must not be the zero address.\\n     * - `founder` must not be the zero address.\\n     * - `development` must not be the zero address.\\n     */\\n    function updateWallets (address marketing, address founder, address development) external onlyOwner {\\n        //zero address is not allowed\\n        require (marketing != address(0) && founder != address(0) && development != address(0), \\\"error zero address\\\");\\n        marketingWallet = marketing;\\n        founderWallet = founder;\\n        developmentWallet = development;\\n\\n    }\\n\\n    /**\\n     * @dev Allows the owner to buy tokens using BNB and send them to the 0xdead address (burn address).\\n     * This function is used to decrease the supply of tokens in circulation, effectively increasing the value of remaining tokens.\\n     * The amount of BNB used for the buyback is the amount of BNB sent to the contract by the owner.\\n     */\\n    function buybackAndBurn () public payable onlyOwner {\\n        swapBNBforTokens(msg.value);\\n    }\\n\\n    /**\\n     * @dev Internal function that transfers the token from a sender to a recipient.\\n     * It can also conditionally apply fees to the transfer.\\n     * @param sender address: the sender address.\\n     * @param recipient address: the recipient address.\\n     * @param amount uint256: the amount of tokens to transfer.\\n     * @param takeFee bool: whether to apply fees to this transfer.\\n     */\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        removeAllFee();\\n\\n        if (takeFee) {\\n            if(isPinkBotEnabled){\\n                pinkAntiBot.onPreTransferCheck(sender, recipient, amount);\\n            }\\n\\n            if (sender == uniswapV2Pair) {\\n                setBuy();\\n\\n            }\\n            if (recipient == uniswapV2Pair) {\\n                setSell();\\n            }\\n\\n            if( recipient != uniswapV2Pair){\\n                require (balanceOf(recipient) + amount <= maxWallet, \\\"max wallet limit exceed\\\");\\n\\n            }\\n        }\\n\\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferFromExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferToExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferStandard(sender, recipient, amount);\\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferBothExcluded(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Standard transfer function called during a transaction.\\n     * Takes care of calculating values, updating balances and reflecting fees.\\n     *\\n     * @param sender - address initiating the transaction\\n     * @param recipient - address receiving the tokens\\n     * @param tAmount - amount of tokens being transferred\\n     */\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\n        _takeMarketing(tMarketing);\\n        _takeDevelopment(calculateDevelopmentFee(tAmount));\\n        _takeFounder(calculateFounderFee(tAmount));\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from a non-excluded account to an excluded account, taking into account the reflection mechanism.\\n     * The sender's balance is reduced by the reflection amount of the tokens being sent.\\n     * The recipient's excluded balance is increased by the actual token amount.\\n     * The recipient's reflected balance is increased by the reflection amount of the tokens being sent.\\n     * Marketing, development and founder fees are taken from the transaction.\\n     * The total fees and reflection fees are reflected.\\n     * A Transfer event is emitted with the details of the transfer.\\n     *\\n     * @param sender The address of the account sending the tokens.\\n     * @param recipient The address of the account receiving the tokens.\\n     * @param tAmount The amount of tokens being sent.\\n     */\\n    function _transferToExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\n        _takeMarketing(tMarketing);\\n        _takeDevelopment(calculateDevelopmentFee(tAmount));\\n        _takeFounder(calculateFounderFee(tAmount));\\n\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from an excluded address to another address.\\n     * The function calculates the necessary values using the _getValues function,\\n     * reduces the sender's balance, updates the recipient's balance, takes the necessary fees,\\n     * reflects the fee, and emits a Transfer event.\\n     *\\n     * Requirements:\\n     * - `sender` must be an excluded address.\\n     * - `recipient` must not be the zero address.\\n     * - `tAmount` must be less than or equal to the `sender`'s token balance.\\n     *\\n     * @param sender the address to transfer from.\\n     * @param recipient the address to transfer to.\\n     * @param tAmount the amount of tokens to be transferred.\\n     */\\n    function _transferFromExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\n        _takeMarketing(tMarketing);\\n        _takeDevelopment(calculateDevelopmentFee(tAmount));\\n        _takeFounder(calculateFounderFee(tAmount));\\n\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    /**\\n     * @notice This function handles transfers between two addresses that are both excluded from fees.\\n     * @param sender The address initiating the transfer.\\n     * @param recipient The address receiving the transfer.\\n     * @param tAmount The amount of tokens to be transferred.\\n     */\\n    function _transferBothExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\n        _takeMarketing(tMarketing);\\n        _takeDevelopment(calculateDevelopmentFee(tAmount));\\n        _takeFounder(calculateFounderFee(tAmount));\\n\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BNBClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReflectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"developmentFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FounderFee\",\"type\":\"uint256\"}],\"name\":\"BuyFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"MinTokensBeforeSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"RouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReflectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"developmentFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FounderFee\",\"type\":\"uint256\"}],\"name\":\"SellFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"marketingFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflectionFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"developmentFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"founderFee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackAndBurn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"founderWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPinkBotEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"managePinkBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pinkAntiBot\",\"outputs\":[{\"internalType\":\"contract IPinkAntiBot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"marketingFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflectionFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"developmentFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"founderFee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"market\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflection\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"development\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"founder\",\"type\":\"uint16\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_presaleAddress\",\"type\":\"address\"}],\"name\":\"setPresaleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"market\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reflection\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"development\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"founder\",\"type\":\"uint16\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"founder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"development\",\"type\":\"address\"}],\"name\":\"updateWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RDB", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}