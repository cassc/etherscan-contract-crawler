{"SourceCode": "{\"Address.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"},\"IERC20.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    \\r\\n    function symbol() external view returns(string memory);\\r\\n    \\r\\n    function name() external view returns(string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the number of decimal places\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IXSurge.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n/**\\r\\n    XSurge Interface\\r\\n        Supports xSwap Protocol\\r\\n */\\r\\ninterface IXSurge is IERC20{\\r\\n\\r\\n    function exchange(address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) external;\\r\\n    function burn(uint256 amount) external;\\r\\n    function mintWithNative(address recipient, uint256 minOut) external payable returns (uint256);\\r\\n    function mintWithBacking(address backingToken, uint256 numTokens, address recipient) external returns (uint256);\\r\\n    function requestPromiseTokens(address stable, uint256 amount) external returns (uint256);\\r\\n    function sell(uint256 tokenAmount) external returns (address, uint256);\\r\\n    function calculatePrice() external view returns (uint256);\\r\\n    function getValueOfHoldings(address holder) external view returns(uint256);\\r\\n    function isUnderlyingAsset(address token) external view returns (bool);\\r\\n    function getUnderlyingAssets() external view returns(address[] memory);\\r\\n    function requestFlashLoan(address stable, address stableToRepay, uint256 amount) external returns (bool);\\r\\n    function resourceCollector() external view returns (address);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title Owner\\r\\n * @dev Set \\u0026 change owner\\r\\n */\\r\\ncontract Ownable {\\r\\n\\r\\n    address private owner;\\r\\n    \\r\\n    // event for EVM logging\\r\\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\\r\\n    \\r\\n    // modifier to check if caller is owner\\r\\n    modifier onlyOwner() {\\r\\n        // If the first argument of \\u0027require\\u0027 evaluates to \\u0027false\\u0027, execution terminates and all\\r\\n        // changes to the state and to Ether balances are reverted.\\r\\n        // This used to consume all gas in old EVM versions, but not anymore.\\r\\n        // It is often a good idea to use \\u0027require\\u0027 to check if functions are called correctly.\\r\\n        // As a second argument, you can also provide an explanation about what went wrong.\\r\\n        require(msg.sender == owner, \\\"Caller is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Set contract deployer as owner\\r\\n     */\\r\\n    constructor() {\\r\\n        owner = msg.sender; // \\u0027msg.sender\\u0027 is sender of current call, contract deployer for a constructor\\r\\n        emit OwnerSet(address(0), owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change owner\\r\\n     * @param newOwner address of new owner\\r\\n     */\\r\\n    function changeOwner(address newOwner) public onlyOwner {\\r\\n        emit OwnerSet(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return owner address \\r\\n     * @return address of owner\\r\\n     */\\r\\n    function getOwner() external view returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"XUSDV2.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IXSurge.sol\\\";\\r\\n\\r\\ninterface ITokenFetcher {\\r\\n    function bnbToStable(address stable, uint256 minOut) external payable;\\r\\n    function chooseStable() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IPromiseUSD {\\r\\n    function mint(uint256 amount) external;\\r\\n    function setApprovedContract(address Contract, bool _isApproved) external;\\r\\n}\\r\\n\\r\\ninterface ILoanProvider {\\r\\n    function fulfillFlashLoanRequest() external returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Contract: xUSD V2\\r\\n * Developed By: DeFi Mark\\r\\n *\\r\\n * XUSD Is A Token With A Built In Exchange, Loan Provider, and Internal Market Maker\\r\\n * Send BNB or Stake Stablecoins in To Mint xUSD Tokens\\r\\n * Sell XUSD tokens to redeem the underlying stablecoins\\r\\n * Every Transaction Raises The Value Of XUSD In Stable Coins\\r\\n * Price is calculated as a ratio between Total Supply and stable coin quantity in Contract\\r\\n * No Contract Interaction Can Lower The Value Of XUSD In Stables, It Is Only Allowed To Rise\\r\\n *\\r\\n * For More Information:\\r\\n * Visit xsurge.net\\r\\n */\\r\\ncontract XUSD is IXSurge, Ownable {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    // token data\\r\\n    string private constant _name = \\\"XUSD\\\";\\r\\n    string private constant _symbol = \\\"XUSD\\\";\\r\\n    uint8 private constant _decimals = 18;\\r\\n    uint256 private constant precision = 10**18;\\r\\n    \\r\\n    // 1 initial supply\\r\\n    uint256 private _totalSupply = 10**18; \\r\\n    \\r\\n    // balances\\r\\n    mapping (address =\\u003e uint256) _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) _allowances;\\r\\n\\r\\n    // Dead Wallet\\r\\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    // Fees\\r\\n    uint256 public mintFee        = 99250;            // 0.75% mint fee\\r\\n    uint256 public sellFee        = 99750;            // 0.25% redeem fee \\r\\n    uint256 public transferFee    = 99750;            // 0.25% transfer fee\\r\\n    uint256 public constant feeDenominator = 10**5;\\r\\n    \\r\\n    // Underlying Asset\\r\\n    struct StableAsset {\\r\\n        bool isApproved;\\r\\n        bool mintDisabled;\\r\\n        uint8 index;\\r\\n    }\\r\\n    address[] public stables;\\r\\n    mapping ( address =\\u003e StableAsset ) public stableAssets;\\r\\n    \\r\\n    // address -\\u003e Fee Exemption\\r\\n    mapping ( address =\\u003e bool ) public isTransferFeeExempt;\\r\\n\\r\\n    // Immutable Contracts\\r\\n    // Lending Token\\r\\n    address public immutable PROMISE_USD;\\r\\n    // Token Proposal Contract\\r\\n    address public immutable TokenProposalContract;\\r\\n\\r\\n    // Swappable Contracts\\r\\n    // xSwap Router\\r\\n    address public xSwapRouter;\\r\\n    // fee collection\\r\\n    address private _resourceCollector;\\r\\n    // Flash Loan Provider\\r\\n    address public flashLoanProvider;\\r\\n    // Token Fetcher\\r\\n    ITokenFetcher public TokenFetcher;\\r\\n    \\r\\n    // Percentage of taxation to go toward utilities\\r\\n    uint256 public resourceAllocationPercentage;\\r\\n\\r\\n    // Reentrancy Guard\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n    uint256 private _status;\\r\\n    modifier nonReentrant() {\\r\\n        require(_status != _ENTERED, \\\"Reentrancy Guard call\\\");\\r\\n        _status = _ENTERED;\\r\\n        _;\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    modifier notEntered() {\\r\\n        require(_status != _ENTERED, \\\"Reentrant call\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // initialize some stuff\\r\\n    constructor (\\r\\n        address PromiseUSD,\\r\\n        address NewTokenProposal\\r\\n    ) {\\r\\n        require(\\r\\n            PromiseUSD != address(0) \\u0026\\u0026\\r\\n            NewTokenProposal != address(0)\\r\\n        );\\r\\n\\r\\n        // Set Fields\\r\\n        PROMISE_USD = PromiseUSD;\\r\\n        TokenProposalContract = NewTokenProposal;\\r\\n\\r\\n        // Set Contracts\\r\\n        flashLoanProvider = 0x7FEeb737D07F24eAa76F146295f0f3D4ad9c2Adc;\\r\\n        _resourceCollector = 0x2fCFB41613b0404A669a4B708860ae13FA3a5932;\\r\\n        xSwapRouter       = 0x336548555A2850B279e48076A06cD39aA897eCB6;\\r\\n\\r\\n        // set reentrancy\\r\\n        _status = _NOT_ENTERED;\\r\\n\\r\\n        // resource collector\\r\\n        resourceAllocationPercentage = 50;\\r\\n\\r\\n        // Add BUSD\\r\\n        address BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\r\\n        stables.push(BUSD);\\r\\n        stableAssets[BUSD].isApproved = true;\\r\\n        stableAssets[BUSD].index = 0;\\r\\n\\r\\n        // Add USDC\\r\\n        address USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\\r\\n        stables.push(USDC);\\r\\n        stableAssets[USDC].isApproved = true;\\r\\n        stableAssets[USDC].index = 1;\\r\\n\\r\\n        // Add USDT\\r\\n        address USDT = 0x55d398326f99059fF775485246999027B3197955;\\r\\n        stables.push(USDT);\\r\\n        stableAssets[USDT].isApproved = true;\\r\\n        stableAssets[USDT].index = 2;\\r\\n        \\r\\n        // fee exempt PCS Router + Promisary Contract\\r\\n        isTransferFeeExempt[0x10ED43C718714eb63d5aA57B78B54704E256024E] = true;\\r\\n        isTransferFeeExempt[PromiseUSD]                                 = true;\\r\\n        isTransferFeeExempt[_resourceCollector]                         = true;\\r\\n        isTransferFeeExempt[msg.sender]                                 = true;\\r\\n\\r\\n        // allocate initial 1 token\\r\\n        _balances[msg.sender] = _totalSupply;\\r\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    /** Returns the total number of tokens in existence */\\r\\n    function totalSupply() external view override returns (uint256) { \\r\\n        return _totalSupply; \\r\\n    }\\r\\n\\r\\n    /** Returns the number of tokens owned by `account` */\\r\\n    function balanceOf(address account) public view override returns (uint256) { \\r\\n        return _balances[account]; \\r\\n    }\\r\\n\\r\\n    /** Returns the number of tokens `spender` can transfer from `holder` */\\r\\n    function allowance(address holder, address spender) external view override returns (uint256) { \\r\\n        return _allowances[holder][spender]; \\r\\n    }\\r\\n    \\r\\n    /** Token Name */\\r\\n    function name() public pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /** Token Ticker Symbol */\\r\\n    function symbol() public pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /** Tokens decimals */\\r\\n    function decimals() public pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /** Approves `spender` to transfer `amount` tokens from caller */\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n  \\r\\n    /** Transfer Function */\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        if (recipient == msg.sender) {\\r\\n            require(_status != _ENTERED, \\\"Reentrant call\\\");\\r\\n            _sell(msg.sender, expectedTokenToReceive(amount), amount, recipient);\\r\\n            return true;\\r\\n        } else {\\r\\n            return _transferFrom(msg.sender, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** Transfer Function */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\u0027Insufficient Allowance\\u0027);\\r\\n        return _transferFrom(sender, recipient, amount);\\r\\n    }\\r\\n    \\r\\n    /** Internal Transfer */\\r\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        // make standard checks\\r\\n        require(recipient != address(0) \\u0026\\u0026 sender != address(0), \\\"Transfer To Zero\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer Amt Zero\\\");\\r\\n        // track price change\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n        // fee exempt\\r\\n        bool isExempt = isTransferFeeExempt[sender] || isTransferFeeExempt[recipient];\\r\\n        // amount to give recipient\\r\\n        uint256 tAmount = isExempt ? amount : amount.mul(transferFee).div(feeDenominator);\\r\\n        // tax taken from transfer\\r\\n        uint256 tax = amount.sub(tAmount);\\r\\n        // subtract from sender\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\r\\n\\r\\n        // allocate tax if applicable\\r\\n        if (shouldAllocateResources(isExempt, sender, recipient)) {\\r\\n            _allocateResources(tax);\\r\\n        }\\r\\n\\r\\n        // give reduced amount to receiver\\r\\n        _balances[recipient] = _balances[recipient].add(tAmount);\\r\\n\\r\\n        // burn the tax\\r\\n        if (tax \\u003e 0) {\\r\\n            _totalSupply = _totalSupply.sub(tax);\\r\\n            emit Transfer(sender, address(0), tax);\\r\\n        }\\r\\n        \\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n        // Transfer Event\\r\\n        emit Transfer(sender, recipient, tAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Mint XUSD Tokens With The Native Token ( Smart Chain BNB )\\r\\n        This will choose the optimal stable token to purchase via PancakeSwap\\r\\n        It will then mint tokens to `recipient` based on the value received from Pancakeswap\\r\\n        `minOut` should be set to avoid the PCS Transaction from being front runned\\r\\n\\r\\n        @param recipient Account to receive minted XUSD Tokens\\r\\n        @param minOut minimum amount out from BNB -\\u003e StableCoin - prevents front run attacks\\r\\n        @return received number of XUSD tokens received\\r\\n     */\\r\\n    function mintWithNative(address recipient, uint256 minOut) external override payable returns (uint256) {\\r\\n        _checkGarbageCollector(address(this));\\r\\n        _checkGarbageCollector(DEAD);\\r\\n        return _mintWithNative(recipient, minOut);\\r\\n    }\\r\\n    \\r\\n    /** \\r\\n        Mint XUSD Tokens By Depositing Approved Stable Coins Into The Contract\\r\\n        Requires Approval from the backingToken prior to purchase\\r\\n        \\r\\n        @param backingToken Approved Stable To Mint XUSD With, Must have mintDisabled set to false\\r\\n        @param numTokens number of `backingToken` tokens to mint XUSD with\\r\\n        @return tokensMinted number of XUSD tokens minted\\r\\n    */\\r\\n    function mintWithBacking(address backingToken, uint256 numTokens) external nonReentrant returns (uint256) {\\r\\n        _checkGarbageCollector(address(this));\\r\\n        _checkGarbageCollector(DEAD);\\r\\n        return _mintWithBacking(backingToken, numTokens, msg.sender);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        Mint XUSD Tokens For `recipient` By Depositing `backingToken` Into The Contract\\r\\n            Requirements:\\r\\n                `backingToken` must be an approved XUSD stable coin\\r\\n                Approval from the `backingToken` prior to purchase\\r\\n        \\r\\n        @param backingToken Approved Stable To Mint XUSD With, Must have mintDisabled set to false\\r\\n        @param numTokens number of `backingToken` tokens to mint XUSD with\\r\\n        @param recipient Account to receive minted XUSD tokens\\r\\n        @return tokensMinted number of XUSD tokens minted\\r\\n    */\\r\\n    function mintWithBacking(address backingToken, uint256 numTokens, address recipient) external override nonReentrant returns (uint256) {\\r\\n        _checkGarbageCollector(address(this));\\r\\n        _checkGarbageCollector(DEAD);\\r\\n        return _mintWithBacking(backingToken, numTokens, recipient);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        Burns Sender\\u0027s XUSD Tokens and redeems their value in the optimal Approved XUSD Stable Token\\r\\n        @param tokenAmount Number of XUSD Tokens To Redeem, Must be greater than 0\\r\\n    */\\r\\n    function sell(uint256 tokenAmount) external override notEntered returns (address, uint256) {\\r\\n        address tokenToSend = expectedTokenToReceive(tokenAmount);\\r\\n        return _sell(msg.sender, tokenToSend, tokenAmount, msg.sender);\\r\\n    }\\r\\n    \\r\\n    /** \\r\\n        Burns Sender\\u0027s XUSD Tokens and redeems their value in `desiredToken`\\r\\n        @param desiredToken Token to receive from XUSD, Must be an Approved XUSD Stable\\r\\n        @param tokenAmount Number of XUSD Tokens To Redeem, Must be greater than 0\\r\\n    */\\r\\n    function sell(uint256 tokenAmount, address desiredToken) external notEntered returns (address, uint256) {\\r\\n        return _sell(msg.sender, desiredToken, tokenAmount, msg.sender);\\r\\n    }\\r\\n    \\r\\n    /** \\r\\n        Burns Sender\\u0027s XUSD Tokens and redeems their value in `desiredToken` for `recipient`\\r\\n        @param desiredToken Token to receive from XUSD, Must be an Approved XUSD Stable\\r\\n        @param tokenAmount Number of XUSD Tokens To Redeem, Must be greater than 0\\r\\n        @param recipient Recipient Of `desiredToken` transfer, Must not be address(0)\\r\\n    */\\r\\n    function sell(uint256 tokenAmount, address desiredToken, address recipient) external notEntered returns (address, uint256) {\\r\\n        return _sell(msg.sender, desiredToken, tokenAmount, recipient);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Exchanges TokenIn For TokenOut 1:1 So Long As:\\r\\n            - TokenIn  is an approved XUSD stable and not address(0) or tokenOut\\r\\n            - TokenOut is an approved XUSD stable and not address(0) or tokenIn\\r\\n            - TokenIn and TokenOut have the same decimal count\\r\\n        \\r\\n        The xSwap Router is the only contract with permission to this function\\r\\n        It is up to the xSwap Router to charge a fee for this service that will\\r\\n        benefit XUSD in some capacity, either through donation or to the Treasury\\r\\n\\r\\n        @param tokenIn - Token To Give XUSD in exchange for TokenOut\\r\\n        @param tokenOut - Token To receive from swap\\r\\n        @param tokenInAmount - Amount of `tokenIn` to exchange for tokenOut\\r\\n        @param recipient - Recipient of `tokenOut` tokens\\r\\n     */\\r\\n    function exchange(address tokenIn, address tokenOut, uint256 tokenInAmount, address recipient) external override notEntered {\\r\\n        require(\\r\\n            tokenIn != address(0) \\u0026\\u0026 \\r\\n            tokenOut != address(0) \\u0026\\u0026 \\r\\n            recipient != address(0) \\u0026\\u0026\\r\\n            tokenIn != tokenOut \\u0026\\u0026\\r\\n            tokenInAmount \\u003e 0,\\r\\n            \\u0027Invalid Params\\u0027\\r\\n        );\\r\\n        require(\\r\\n            !stableAssets[tokenIn].mintDisabled,\\r\\n            \\u0027TokenIn Disabled\\u0027\\r\\n        );\\r\\n        require(\\r\\n            stableAssets[tokenIn].isApproved \\u0026\\u0026\\r\\n            stableAssets[tokenOut].isApproved,\\r\\n            \\u0027Not Approved\\u0027\\r\\n        );\\r\\n        require(\\r\\n            IERC20(tokenIn).decimals() == IERC20(tokenOut).decimals(),\\r\\n            \\u0027Decimal Mismatch\\u0027\\r\\n        );\\r\\n        require(\\r\\n            msg.sender == xSwapRouter,\\r\\n            \\u0027Only Router\\u0027\\r\\n        );\\r\\n        _swapStables(tokenIn, tokenOut, tokenInAmount, recipient);\\r\\n    }\\r\\n    \\r\\n    /** \\r\\n        Allows A User To Erase Their Holdings From Supply \\r\\n        DOES NOT REDEEM UNDERLYING ASSET FOR USER\\r\\n        @param amount Number of XUSD Tokens To Burn\\r\\n    */\\r\\n    function burn(uint256 amount) external override notEntered {\\r\\n        // get balance of caller\\r\\n        uint256 bal = _balances[msg.sender];\\r\\n        require(bal \\u003e= amount \\u0026\\u0026 bal \\u003e 0, \\u0027Zero Holdings\\u0027);\\r\\n        // Track Change In Price\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n        // burn tokens from sender + supply\\r\\n        _burn(msg.sender, amount);\\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n        // Emit Call\\r\\n        emit Burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Triggerable Only By PromisaryToken Contract\\r\\n        Temporarily Sells XUSD Tax Free and holds XUSD in escrow\\r\\n        Until Stable Amount Is Returned\\r\\n        It is up to implementing contracts to ensure XUSD profits from this trade off\\r\\n\\r\\n        @param stable Stable Token To Be Sent To PROMISE_USD\\r\\n        @param amount number of XUSD tokens to redeem\\r\\n        @return amountDelivered number of `stable` tokens returned to PROMISE_USD\\r\\n     */\\r\\n    function requestPromiseTokens(address stable, uint256 amount) external override nonReentrant returns (uint256) {\\r\\n        require(msg.sender == PROMISE_USD, \\u0027Only Promise\\u0027);\\r\\n        require(stableAssets[stable].isApproved, \\u0027Non Approved Stable\\u0027);\\r\\n\\r\\n        // log old price\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n\\r\\n        // value in underlying\\r\\n        uint256 amountUnderlyingToDeliver = amountOut(amount);\\r\\n        require(\\r\\n            amountUnderlyingToDeliver \\u003e 0 \\u0026\\u0026\\r\\n            amountUnderlyingToDeliver \\u003c= IERC20(stable).balanceOf(address(this)),\\r\\n            \\u0027Invalid Amount\\u0027\\r\\n        );\\r\\n\\r\\n        // send Tokens to Seller\\r\\n        bool successful = IERC20(stable).transfer(PROMISE_USD, amountUnderlyingToDeliver);\\r\\n        require(successful, \\u0027Transfer Failure\\u0027);\\r\\n\\r\\n        // Trigger Ghost Token Creation\\r\\n        IPromiseUSD(PROMISE_USD).mint(amountUnderlyingToDeliver);\\r\\n\\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n\\r\\n        // emit ghost event\\r\\n        emit PromiseTokens(amount, amountUnderlyingToDeliver);\\r\\n\\r\\n        // return amount that was sent\\r\\n        return amountUnderlyingToDeliver;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Allows User To Borrow Stables From XUSD For One Transaction\\r\\n        If The Stables Are Not Returned By The End Of The Transaction, everything is reverted\\r\\n        It is up to the implementing flashLoanProvider contract to handle the charging of fees if applicable\\r\\n\\r\\n        @param stable Stable Token To Request Loan\\r\\n        @param stableToRepay Stable Token To Fulfil Loan\\r\\n        @param amount amount of stable tokens to transfer\\r\\n        @return success whether transaction succeeded or not\\r\\n     */\\r\\n    function requestFlashLoan(address stable, address stableToRepay, uint256 amount) external override nonReentrant returns (bool) {\\r\\n        require(\\r\\n            msg.sender == flashLoanProvider,\\r\\n            \\u0027Only Flash Loan Provider\\u0027\\r\\n        );\\r\\n        require(\\r\\n            stableAssets[stable].isApproved,\\r\\n            \\u0027Not Approved\\u0027\\r\\n        );\\r\\n        require(\\r\\n            stableAssets[stableToRepay].isApproved \\u0026\\u0026\\r\\n            !stableAssets[stableToRepay].mintDisabled,\\r\\n            \\u0027Repayment Stable Not Approved\\u0027\\r\\n        );\\r\\n        require(\\r\\n            amount \\u003c= IERC20(stable).balanceOf(address(this)),\\r\\n            \\\"Insufficient Balance\\\"\\r\\n        );\\r\\n\\r\\n        // stable swap liquidity balance before loan\\r\\n        uint256 oldLiquidity = liquidityInStableCoinSwap();\\r\\n\\r\\n        // price before loan\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n\\r\\n        // backing before loan\\r\\n        uint256 oldBacking = calculateBacking();\\r\\n\\r\\n        // transfer amount to sender\\r\\n        IERC20(stable).transfer(flashLoanProvider, amount);\\r\\n\\r\\n        // trigger functionality on external contract\\r\\n        require(\\r\\n            ILoanProvider(flashLoanProvider).fulfillFlashLoanRequest(),\\r\\n            \\u0027Fulfilment Request Failed\\u0027\\r\\n        );\\r\\n        \\r\\n        // track pricing value changes\\r\\n        uint256 newLiquidity = liquidityInStableCoinSwap();\\r\\n\\r\\n        // require more stable has been acquired\\r\\n        require(\\r\\n            newLiquidity \\u003e= oldLiquidity \\u0026\\u0026\\r\\n            calculateBacking() \\u003e= oldBacking, \\r\\n            \\\"Flash loan not paid back\\\"\\r\\n        );\\r\\n\\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n\\r\\n        // track event\\r\\n        emit FlashLoaned(stable, stableToRepay, amount, newLiquidity - oldLiquidity + amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    ///////////////////////////////////\\r\\n    //////  INTERNAL FUNCTIONS  ///////\\r\\n    ///////////////////////////////////\\r\\n    \\r\\n    /** Purchases xUSD Token and Deposits Them in Recipient\\u0027s Address */\\r\\n    function _mintWithNative(address recipient, uint256 minOut) internal nonReentrant returns (uint256) {        \\r\\n        require(msg.value \\u003e 0, \\u0027Zero Value\\u0027);\\r\\n        require(recipient != address(0));\\r\\n        \\r\\n        // calculate price change\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n        \\r\\n        // previous backing\\r\\n        uint256 previousBacking = calculateBacking();\\r\\n        \\r\\n        // swap BNB for stable\\r\\n        uint256 received = _swapForStable(minOut);\\r\\n\\r\\n        // if this is the first purchase, use new amount\\r\\n        uint256 relevantBacking = previousBacking == 0 ? calculateBacking() : previousBacking;\\r\\n\\r\\n        // mint to recipient\\r\\n        return _mintTo(recipient, received, relevantBacking, oldPrice);\\r\\n    }\\r\\n    \\r\\n    /** Stake Tokens and Deposits xUSD in Sender\\u0027s Address, Must Have Prior Approval */\\r\\n    function _mintWithBacking(address token, uint256 numTokens, address recipient) internal returns (uint256) {\\r\\n        // require staking token is approved\\r\\n        require(stableAssets[token].isApproved \\u0026\\u0026 token != address(0), \\u0027Token Not Approved\\u0027);\\r\\n        // users token balance\\r\\n        uint256 userTokenBalance = IERC20(token).balanceOf(msg.sender);\\r\\n        // ensure user has enough to send\\r\\n        require(userTokenBalance \\u003e 0 \\u0026\\u0026 numTokens \\u003c= userTokenBalance, \\u0027Insufficient Balance\\u0027);\\r\\n        // require token is approved for minting\\r\\n        require(!stableAssets[token].mintDisabled, \\u0027Mint Is Disabled With This Token\\u0027);\\r\\n\\r\\n        // calculate price change\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n\\r\\n        // previous backing\\r\\n        uint256 previousBacking = calculateBacking();\\r\\n\\r\\n        // transfer in token\\r\\n        uint256 received = _transferIn(token, numTokens);\\r\\n\\r\\n        // if this is the first purchase, use new amount\\r\\n        uint256 relevantBacking = previousBacking == 0 ? received : previousBacking;\\r\\n\\r\\n        // Handle Minting\\r\\n        return _mintTo(recipient, received, relevantBacking, oldPrice);\\r\\n    }\\r\\n    \\r\\n    /** Sells xUSD Tokens And Deposits Underlying Asset Tokens into Recipients\\u0027s Address */\\r\\n    function _sell(address seller, address desiredToken, uint256 tokenAmount, address recipient) internal nonReentrant returns (address, uint256) {\\r\\n        require(tokenAmount \\u003e 0 \\u0026\\u0026 _balances[seller] \\u003e= tokenAmount);\\r\\n        require(seller != address(0) \\u0026\\u0026 recipient != address(0));\\r\\n        \\r\\n        // calculate price change\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n        \\r\\n        // tokens post fee to swap for underlying asset\\r\\n        uint256 tokensToSwap = isTransferFeeExempt[seller] ? \\r\\n            tokenAmount.sub(10, \\u0027Minimum Exemption\\u0027) :\\r\\n            tokenAmount.mul(sellFee).div(feeDenominator);\\r\\n\\r\\n        // value of taxed tokens\\r\\n        uint256 amountUnderlyingAsset = amountOut(tokensToSwap);\\r\\n        require(_validToSend(desiredToken, amountUnderlyingAsset), \\u0027Invalid Token\\u0027);\\r\\n\\r\\n        // burn from sender + supply \\r\\n        _burn(seller, tokenAmount);\\r\\n        \\r\\n        // allocate resources\\r\\n        if (shouldAllocateResources(isTransferFeeExempt[seller], seller, recipient)) {\\r\\n            _allocateResources(tokenAmount.sub(tokensToSwap));\\r\\n        }\\r\\n\\r\\n        // send Tokens to Seller\\r\\n        bool successful = IERC20(desiredToken).transfer(recipient, amountUnderlyingAsset);\\r\\n\\r\\n        // ensure Tokens were delivered\\r\\n        require(successful, \\u0027Transfer Failure\\u0027);\\r\\n\\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n        // Differentiate Sell\\r\\n        emit Redeemed(seller, tokenAmount, amountUnderlyingAsset);\\r\\n        // return token redeemed and amount underlying\\r\\n        return (desiredToken, amountUnderlyingAsset);\\r\\n    }\\r\\n\\r\\n    /** Handles Minting Logic To Create New Surge Tokens*/\\r\\n    function _mintTo(address recipient, uint256 received, uint256 totalBacking, uint256 oldPrice) private returns(uint256) {\\r\\n        \\r\\n        // find the number of tokens we should mint to keep up with the current price\\r\\n        uint256 calculatedSupply = _totalSupply == 0 ? 10**18 : _totalSupply;\\r\\n        uint256 tokensToMintNoTax = calculatedSupply.mul(received).div(totalBacking);\\r\\n        \\r\\n        // apply fee to minted tokens to inflate price relative to total supply\\r\\n        uint256 tokensToMint = isTransferFeeExempt[msg.sender] ? \\r\\n                tokensToMintNoTax.sub(10, \\u0027Minimum Exemption\\u0027) :\\r\\n                tokensToMintNoTax.mul(mintFee).div(feeDenominator);\\r\\n        require(tokensToMint \\u003e 0, \\u0027Zero Amount\\u0027);\\r\\n        \\r\\n        // allocate resources if fee exempt\\r\\n        if (shouldAllocateResources(isTransferFeeExempt[msg.sender], msg.sender, recipient)) {\\r\\n            _allocateResources(tokensToMintNoTax.sub(tokensToMint));\\r\\n        }\\r\\n        \\r\\n        // mint to Buyer\\r\\n        _mint(recipient, tokensToMint);\\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n        // differentiate purchase\\r\\n        emit Minted(recipient, tokensToMint);\\r\\n        return tokensToMint;\\r\\n    }\\r\\n\\r\\n    /** Swaps `amount` BNB for `stable` utilizing the token fetcher contract */\\r\\n    function _swapForStable(uint256 minOut) internal returns (uint256) {\\r\\n\\r\\n        // stable to swap for\\r\\n        address stable = TokenFetcher.chooseStable();\\r\\n        require(stableAssets[stable].isApproved \\u0026\\u0026 !stableAssets[stable].mintDisabled);\\r\\n\\r\\n        // previous amount of Tokens before we received any\\r\\n        uint256 prevTokenAmount = IERC20(stable).balanceOf(address(this));\\r\\n\\r\\n        // swap BNB For stable of choice\\r\\n        TokenFetcher.bnbToStable{value: address(this).balance}(stable, minOut);\\r\\n\\r\\n        // amount after swap\\r\\n        uint256 currentTokenAmount = IERC20(stable).balanceOf(address(this));\\r\\n        require(currentTokenAmount \\u003e prevTokenAmount);\\r\\n        return currentTokenAmount - prevTokenAmount;\\r\\n    }\\r\\n\\r\\n    /** Accepts `tokenIn` and sends `tokenOut` to recipient. This is a 1:1 swap */\\r\\n    function _swapStables(address tokenIn, address tokenOut, uint256 tokenInAmount, address recipient) internal {\\r\\n\\r\\n        // track previous price\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n\\r\\n        // transfer in tokens\\r\\n        uint256 received = _transferIn(tokenIn, tokenInAmount);\\r\\n\\r\\n        // check send amount validity\\r\\n        require(\\r\\n            received \\u003c= tokenInAmount \\u0026\\u0026 received \\u003e 0,\\r\\n            \\u0027SC\\u0027\\r\\n        );\\r\\n        require(\\r\\n            IERC20(tokenOut).balanceOf(address(this)) \\u003e= received,\\r\\n            \\u0027Insufficient Balance\\u0027\\r\\n        );\\r\\n\\r\\n        // send amount to sender\\r\\n        bool s = IERC20(tokenOut).transfer(recipient, received);\\r\\n        require(s, \\u0027Transfer Fail\\u0027);\\r\\n\\r\\n        // require price rises\\r\\n        _requirePriceRises(oldPrice);\\r\\n\\r\\n        // track event\\r\\n        emit ExchangeStables(tokenIn, tokenOut, tokenInAmount, received, recipient);\\r\\n    }\\r\\n\\r\\n    /** Requires The Price Of XUSD To Rise For The Transaction To Conclude */\\r\\n    function _requirePriceRises(uint256 oldPrice) internal {\\r\\n        // Calculate Price After Transaction\\r\\n        uint256 newPrice = _calculatePrice();\\r\\n        // Require Current Price \\u003e= Last Price\\r\\n        require(newPrice \\u003e= oldPrice, \\u0027Price Cannot Fall\\u0027);\\r\\n        // Emit The Price Change\\r\\n        emit PriceChange(oldPrice, newPrice, _totalSupply);\\r\\n    }\\r\\n\\r\\n    /** Transfers `desiredAmount` of `token` in and verifies the transaction success */\\r\\n    function _transferIn(address token, uint256 desiredAmount) internal returns (uint256) {\\r\\n        uint256 balBefore = IERC20(token).balanceOf(address(this));\\r\\n        bool s = IERC20(token).transferFrom(msg.sender, address(this), desiredAmount);\\r\\n        uint256 received = IERC20(token).balanceOf(address(this)) - balBefore;\\r\\n        require(s \\u0026\\u0026 received \\u003e 0 \\u0026\\u0026 received \\u003c= desiredAmount);\\r\\n        return received;\\r\\n    }\\r\\n    \\r\\n    /** Mints a percentage of `tax` to the resource collector */\\r\\n    function _allocateResources(uint256 tax) private {\\r\\n        uint256 allocation = tax.mul(resourceAllocationPercentage).div(100);\\r\\n        if (allocation \\u003e 0) {\\r\\n            _mint(_resourceCollector, allocation);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /** Mints Tokens to the Receivers Address */\\r\\n    function _mint(address receiver, uint amount) private {\\r\\n        _balances[receiver] = _balances[receiver].add(amount);\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        emit Transfer(address(0), receiver, amount);\\r\\n    }\\r\\n    \\r\\n    /** Burns `amount` of tokens from `account` */\\r\\n    function _burn(address account, uint amount) private {\\r\\n        _balances[account] = _balances[account].sub(amount, \\u0027Insufficient Balance\\u0027);\\r\\n        _totalSupply = _totalSupply.sub(amount, \\u0027Negative Supply\\u0027);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /** Make Sure there\\u0027s no Native Tokens in contract */\\r\\n    function _checkGarbageCollector(address burnLocation) internal {\\r\\n        uint256 bal = _balances[burnLocation];\\r\\n        if (bal \\u003e 0) {\\r\\n            // Track Change In Price\\r\\n            uint256 oldPrice = _calculatePrice();\\r\\n            // burn amount\\r\\n            _burn(burnLocation, bal);\\r\\n            // Emit Collection\\r\\n            emit GarbageCollected(bal);\\r\\n            // Emit Price Difference\\r\\n            emit PriceChange(oldPrice, _calculatePrice(), _totalSupply);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    ///////////////////////////////////\\r\\n    //////    READ FUNCTIONS    ///////\\r\\n    ///////////////////////////////////\\r\\n    \\r\\n\\r\\n    /** Price Of XUSD in BUSD With 18 Points Of Precision */\\r\\n    function calculatePrice() external view override returns (uint256) {\\r\\n        return _calculatePrice();\\r\\n    }\\r\\n    \\r\\n    /** Returns the Current Price of 1 Token */\\r\\n    function _calculatePrice() internal view returns (uint256) {\\r\\n        uint256 totalShares = _totalSupply == 0 ? 1 : _totalSupply;\\r\\n        uint256 backingValue = calculateBacking();\\r\\n        return (backingValue.mul(precision)).div(totalShares);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Amount Of Underlying To Receive For `numTokens` of XUSD\\r\\n     */\\r\\n    function amountOut(uint256 numTokens) public view returns (uint256) {\\r\\n        return _calculatePrice().mul(numTokens).div(precision);\\r\\n    }\\r\\n\\r\\n    /** Returns the value of `holder`\\u0027s holdings */\\r\\n    function getValueOfHoldings(address holder) public view override returns(uint256) {\\r\\n        return amountOut(_balances[holder]);\\r\\n    }\\r\\n\\r\\n    /** Returns true if `token` is an XUSD Approved Stable Coin, false otherwise */\\r\\n    function isUnderlyingAsset(address token) external view override returns (bool) {\\r\\n        return stableAssets[token].isApproved;\\r\\n    }\\r\\n\\r\\n    /** Returns The Address of the Underlying Asset */\\r\\n    function getUnderlyingAssets() external override view returns(address[] memory) {\\r\\n        return stables;\\r\\n    }\\r\\n\\r\\n    /** Calculates The Sum Of Assets Backing XUSD\\u0027s Valuation */\\r\\n    function calculateBacking() public view returns (uint256) {\\r\\n        uint total = liquidityInStableCoinSwap();\\r\\n        return total + IERC20(PROMISE_USD).totalSupply();\\r\\n    }\\r\\n\\r\\n    /** Calculates Sum Of Assets Backing XUSD\\u0027s Valuation EXLCUDING Promisary Tokens */\\r\\n    function liquidityInStableCoinSwap() public view returns (uint256 total) {\\r\\n        for (uint i = 0; i \\u003c stables.length; i++) {\\r\\n            total += IERC20(stables[i]).balanceOf(address(this));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** expected token to receive when tokens are sold */\\r\\n    function expectedTokenToReceive(uint256 amount) public view returns (address) {\\r\\n        for (uint i = stables.length - 1; i \\u003e= 0; i--) {\\r\\n            if (_validToSend(stables[i], amountOut(amount))) {\\r\\n                return stables[i];\\r\\n            }\\r\\n        }\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n    function resourceCollector() external view override returns (address) {\\r\\n        return _resourceCollector;\\r\\n    }\\r\\n\\r\\n    /** Whether or not XUSD Should Allocate Resources To The Resource Collector */\\r\\n    function shouldAllocateResources(bool feeExempt, address caller, address recipient) internal view returns (bool) {\\r\\n        return \\r\\n            !feeExempt\\r\\n            \\u0026\\u0026 caller != _resourceCollector\\r\\n            \\u0026\\u0026 recipient != _resourceCollector\\r\\n            \\u0026\\u0026 resourceAllocationPercentage \\u003e 0;\\r\\n    }\\r\\n    \\r\\n    /** Whether or not a stable token is valid to send to a user when selling the token */\\r\\n    function _validToSend(address stable, uint256 amount) internal view returns (bool) {\\r\\n        return \\r\\n            stable != address(0) \\u0026\\u0026 \\r\\n            stableAssets[stable].isApproved \\u0026\\u0026 \\r\\n            amount \\u003e 0 \\u0026\\u0026\\r\\n            IERC20(stable).balanceOf(address(this)) \\u003e= amount;\\r\\n    }\\r\\n    \\r\\n    ///////////////////////////////////\\r\\n    //////   OWNER FUNCTIONS    ///////\\r\\n    ///////////////////////////////////\\r\\n\\r\\n    /** Updates The Address Of The Flashloan Provider */\\r\\n    function upgradeFlashLoanProvider(address flashLoanProvider_) external onlyOwner {\\r\\n        require(flashLoanProvider_ != address(0));\\r\\n        flashLoanProvider = flashLoanProvider_;\\r\\n        emit SetFlashLoanProvider(flashLoanProvider_);\\r\\n    }\\r\\n\\r\\n    /** Updates The Address Of The Token Fetcher, in case of PCS Migration */\\r\\n    function upgradeTokenFetcher(ITokenFetcher tokenFetcher) external onlyOwner {\\r\\n        require(address(tokenFetcher) != address(0));\\r\\n        TokenFetcher = tokenFetcher;\\r\\n        emit SetTokenFetcher(address(tokenFetcher));\\r\\n    }\\r\\n\\r\\n    /** Updates The Address Of The xSwap Router */\\r\\n    function upgradeXSwapRouter(address _newRouter) external onlyOwner {\\r\\n        require(_newRouter != address(0));\\r\\n        xSwapRouter = _newRouter;\\r\\n        emit SetXSwapRouter(_newRouter);\\r\\n    }\\r\\n\\r\\n    /** Updates The Address Of The Resource Collector */\\r\\n    function upgradeResourceCollector(address newCollector, uint256 _allocationPercentage) external onlyOwner {\\r\\n        require(newCollector != address(0));\\r\\n        require(_allocationPercentage \\u003c= 90);\\r\\n        if (!isTransferFeeExempt[newCollector]) {\\r\\n            isTransferFeeExempt[newCollector] = true;\\r\\n        }\\r\\n        _resourceCollector = newCollector;\\r\\n        resourceAllocationPercentage = _allocationPercentage;\\r\\n        emit SetResourceCollector(newCollector, _allocationPercentage);\\r\\n    }\\r\\n\\r\\n    /** Disables The Stable Token To Be Used To Mint XUSD, Cannot Disable Immutable Tokens */\\r\\n    function disableMintForStable(address stable, bool isDisabled) external onlyOwner {\\r\\n        require(stable != address(0));\\r\\n        require(stableAssets[stable].isApproved);\\r\\n        stableAssets[stable].mintDisabled = isDisabled;\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        Adds And Approves A Stable Coin For XUSD\\r\\n        Must be called From TokenProposalContract which puts\\r\\n        precautions and wait times in place for security and transparency\\r\\n     */\\r\\n    function addStable(address newStable) external {\\r\\n        require(msg.sender == TokenProposalContract);\\r\\n        require(!stableAssets[newStable].isApproved);\\r\\n        require(newStable != address(0));\\r\\n        require(IERC20(newStable).decimals() == 18);\\r\\n\\r\\n        stableAssets[newStable].isApproved = true;\\r\\n        stableAssets[newStable].index = uint8(stables.length);\\r\\n        stables.push(newStable);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        Removes A Stable Coin From The List Of Approved Stables\\r\\n        ALL Value Of The Removed Token MUST Be Replaced By The Caller\\r\\n        Within The Same Transaction. This Function is here to prevent risks from\\r\\n        a compromised stable coin.\\r\\n    */\\r\\n    function removeStable(address stable, address stableToSwapWith) external nonReentrant onlyOwner {\\r\\n        require(stableAssets[stable].isApproved);\\r\\n        require(stableAssets[stableToSwapWith].isApproved);\\r\\n        require(stableToSwapWith != stable, \\u0027Matching Swap\\u0027);\\r\\n        require(stableToSwapWith != PROMISE_USD \\u0026\\u0026 stable != PROMISE_USD, \\u0027Promise\\u0027);\\r\\n\\r\\n        // price before Tx\\r\\n        uint256 oldPrice = _calculatePrice();\\r\\n\\r\\n        // last element\\u0027s index set to removed element\\u0027s index\\r\\n        stableAssets[\\r\\n            stables[stables.length - 1]\\r\\n        ].index = stableAssets[stable].index;\\r\\n\\r\\n        // replace removed element with last element\\r\\n        stables[\\r\\n            stableAssets[stable].index\\r\\n        ] = stables[stables.length - 1];\\r\\n\\r\\n        // remove last element of array\\r\\n        stables.pop();\\r\\n        delete stableAssets[stable];\\r\\n        \\r\\n        // transfer in approved stable\\r\\n        uint256 bal = IERC20(stable).balanceOf(address(this));\\r\\n        uint256 received = _transferIn(stableToSwapWith, bal);\\r\\n        \\r\\n        // transfer out removed stable\\r\\n        require(\\r\\n            IERC20(stable).transfer(msg.sender, received),\\r\\n            \\u0027Failure Transfer Out\\u0027\\r\\n        );\\r\\n\\r\\n        // require no change to price\\r\\n        _requirePriceRises(oldPrice);\\r\\n    }\\r\\n\\r\\n    /** Withdraws Tokens Incorrectly Sent To XUSD */\\r\\n    function withdrawNonStableToken(address token) external onlyOwner {\\r\\n        require(!stableAssets[token].isApproved);\\r\\n        require(token != address(0) \\u0026\\u0026 token != PROMISE_USD);\\r\\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        Situation Where Tokens Are Un-Recoverable\\r\\n            Example Situations: \\r\\n                Lost Wallet Keys\\r\\n                Broken Contract Without Withdraw Fuctionality\\r\\n                Exchange Hot Wallet Without XUSD Support\\r\\n        Will Redeem Stables Tax Free On Behalf of Wallet\\r\\n        Will Prevent Incorrectly \\u0027Burnt\\u0027 or Locked Up Tokens From Continuously Appreciating\\r\\n     */\\r\\n    function redeemForLostAccount(address account, uint256 amount) external onlyOwner {\\r\\n        require(account != address(0));\\r\\n        require(account != PROMISE_USD);\\r\\n        require(_balances[account] \\u003e 0 \\u0026\\u0026 _balances[account] \\u003e= amount);\\r\\n\\r\\n        // make tax exempt\\r\\n        isTransferFeeExempt[account] = true;\\r\\n        // sell tokens tax free on behalf of frozen wallet\\r\\n        _sell(\\r\\n            account, \\r\\n            expectedTokenToReceive(amount),\\r\\n            amount == 0 ? _balances[account] : amount, \\r\\n            account\\r\\n        );\\r\\n        // remove tax exemption\\r\\n        isTransferFeeExempt[account] = false;\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        Sets Mint, Transfer, Sell Fee\\r\\n        Must Be Within Bounds ( Between 0% - 2% ) \\r\\n    */\\r\\n    function setFees(uint256 _mintFee, uint256 _transferFee, uint256 _sellFee) external onlyOwner {\\r\\n        require(_mintFee \\u003e= 98000);      // capped at 2% fee\\r\\n        require(_transferFee \\u003e= 98000);  // capped at 2% fee\\r\\n        require(_sellFee \\u003e= 98000);      // capped at 2% fee\\r\\n        \\r\\n        mintFee = _mintFee;\\r\\n        transferFee = _transferFee;\\r\\n        sellFee = _sellFee;\\r\\n        emit SetFees(_mintFee, _transferFee, _sellFee);\\r\\n    }\\r\\n    \\r\\n    /** Excludes Contract From Transfer Fees */\\r\\n    function setPermissions(address Contract, bool transferFeeExempt) external onlyOwner {\\r\\n        require(Contract != address(0) \\u0026\\u0026 Contract != PROMISE_USD);\\r\\n        isTransferFeeExempt[Contract] = transferFeeExempt;\\r\\n        emit SetPermissions(Contract, transferFeeExempt);\\r\\n    }\\r\\n\\r\\n    /** Allows an external contract to interact with Promise USD */\\r\\n    function setApprovedPromiseUSDContract(address Contract, bool isApprovedForPromiseUSD) external onlyOwner {\\r\\n        require(Contract != address(0));\\r\\n        IPromiseUSD(PROMISE_USD).setApprovedContract(Contract, isApprovedForPromiseUSD);\\r\\n    }\\r\\n    \\r\\n    /** Mint Tokens to Buyer */\\r\\n    receive() external payable {\\r\\n        _mintWithNative(msg.sender, 0);\\r\\n        _checkGarbageCollector(address(this));\\r\\n        _checkGarbageCollector(DEAD);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    ///////////////////////////////////\\r\\n    //////        EVENTS        ///////\\r\\n    ///////////////////////////////////\\r\\n    \\r\\n    // Data Tracking\\r\\n    event PriceChange(uint256 previousPrice, uint256 currentPrice, uint256 totalSupply);\\r\\n    event TokenActivated(uint blockNo);\\r\\n\\r\\n    // Balance Tracking\\r\\n    event Burn(address from, uint256 amountTokensErased);\\r\\n    event GarbageCollected(uint256 amountTokensErased);\\r\\n    event Redeemed(address seller, uint256 amountxUSD, uint256 assetsRedeemed);\\r\\n    event Minted(address recipient, uint256 numTokens);\\r\\n\\r\\n    // Upgradable Contract Tracking\\r\\n    event SetFlashLoanProvider(address newFlashProvider);\\r\\n    event SetTokenFetcher(address newTokenFetcher);\\r\\n    event SetXSwapRouter(address newRouter);\\r\\n    event SetResourceCollector(address newCollector, uint256 allocation);\\r\\n\\r\\n    // Utility Event Notifiers\\r\\n    event PromiseTokens(uint256 tokensLocked, uint256 assetsGhosted);\\r\\n    event FlashLoaned(address token, address repaymentToken, uint256 amountLent, uint256 amountReceived);\\r\\n    event ExchangeStables(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, address recipient);\\r\\n\\r\\n    // Governance Tracking\\r\\n    event TransferOwnership(address newOwner);\\r\\n    event SetPermissions(address Contract, bool feeExempt);\\r\\n    event SetFees(uint mintFee, uint transferFee, uint sellFee);\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"PromiseUSD\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"NewTokenProposal\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensErased\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ExchangeStables\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"repaymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"name\":\"FlashLoaned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensErased\",\"type\":\"uint256\"}],\"name\":\"GarbageCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"PriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensLocked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsGhosted\",\"type\":\"uint256\"}],\"name\":\"PromiseTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountxUSD\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsRedeemed\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFlashProvider\",\"type\":\"address\"}],\"name\":\"SetFlashLoanProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"feeExempt\",\"type\":\"bool\"}],\"name\":\"SetPermissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"SetResourceCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTokenFetcher\",\"type\":\"address\"}],\"name\":\"SetTokenFetcher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"SetXSwapRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"}],\"name\":\"TokenActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PROMISE_USD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenFetcher\",\"outputs\":[{\"internalType\":\"contract ITokenFetcher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenProposalContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStable\",\"type\":\"address\"}],\"name\":\"addStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"amountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isDisabled\",\"type\":\"bool\"}],\"name\":\"disableMintForStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"expectedTokenToReceive\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashLoanProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getValueOfHoldings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTransferFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isUnderlyingAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityInStableCoinSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"backingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"mintWithBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"backingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintWithBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"mintWithNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemForLostAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stableToSwapWith\",\"type\":\"address\"}],\"name\":\"removeStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stableToRepay\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestFlashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestPromiseTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resourceAllocationPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resourceCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"desiredToken\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"desiredToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApprovedForPromiseUSD\",\"type\":\"bool\"}],\"name\":\"setApprovedPromiseUSDContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"transferFeeExempt\",\"type\":\"bool\"}],\"name\":\"setPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stableAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mintDisabled\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stables\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"flashLoanProvider_\",\"type\":\"address\"}],\"name\":\"upgradeFlashLoanProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allocationPercentage\",\"type\":\"uint256\"}],\"name\":\"upgradeResourceCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenFetcher\",\"name\":\"tokenFetcher\",\"type\":\"address\"}],\"name\":\"upgradeTokenFetcher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRouter\",\"type\":\"address\"}],\"name\":\"upgradeXSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawNonStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xSwapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "XUSD", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000096a33730eb478b0603baf5966cfcc10e7bcbcd2b00000000000000000000000030bb9e3862ed4898143277ad839827128e55aeef", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7bd397a8a1700705523453cc6d7960984c059ddc8de14878daaf4e83d96223ce"}