{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LockStakingRewardFixedApyCellit.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at BscScan.com on 2023-02-02\\n*/\\n\\npragma solidity ^0.8.0;\\n\\ninterface IBEP20 {\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function getOwner() external view returns (address);\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface ICellitRouter {\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ncontract Ownable {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed from, address indexed to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Ownable: Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return owner;\\n    }\\n\\n    function transferOwnership(address transferOwner) external onlyOwner {\\n        require(transferOwner != newOwner);\\n        newOwner = transferOwner;\\n    }\\n\\n    function acceptOwnership() virtual external {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in construction, \\n        // since the code is only stored at the end of the constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\\nlibrary SafeBEP20 {\\n    using Address for address;\\n\\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeBEP20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function callOptionalReturn(IBEP20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeBEP20: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeBEP20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { \\n            require(abi.decode(returndata, (bool)), \\\"SafeBEP20: BEP20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\\ninterface ILockStakingRewards {\\n    function earned(address account) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function stake(uint256 amount) external;\\n    function stakeFor(uint256 amount, address user) external;\\n    function getReward() external;\\n    function getRewardForUser(address user) external;\\n    function withdraw(uint256 nonce) external;\\n    function withdrawAndGetReward(uint256 nonce) external;\\n}\\n\\ninterface IPriceFeed {\\n    function queryRate(address sourceTokenAddress, address destTokenAddress) external view returns (uint256 rate, uint256 precision);\\n    function wbnbToken() external view returns(address);\\n}\\n\\ninterface IBEP20Permit {\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\\ncontract LockStakingRewardFixedAPY is ILockStakingRewards, ReentrancyGuard, Ownable, Pausable {\\n    using SafeBEP20 for IBEP20;\\n\\n    IBEP20 public immutable rewardsToken;\\n    IBEP20 public immutable stakingToken;\\n    ICellitRouter public swapRouter;\\n    uint256 public rewardRate; \\n    uint256 public immutable lockDuration; \\n    uint256 public constant rewardDuration = 730 days; \\n    uint256 public rateChangesNonce;\\n\\n    mapping(address => uint256) public weightedStakeDate;\\n    mapping(address => mapping(uint256 => StakeNonceInfo)) public stakeNonceInfos;\\n    mapping(address => uint256) public stakeNonces;\\n    mapping(uint256 => APYCheckpoint) APYcheckpoints;\\n\\n    struct StakeNonceInfo {\\n        uint256 unlockTime;\\n        uint256 stakeTime;\\n        uint256 stakingTokenAmount;\\n        uint256 rewardsTokenAmount;\\n        uint256 rewardRate;\\n    }\\n\\n    struct APYCheckpoint {\\n        uint256 timestamp;\\n        uint256 rewardRate;\\n    }\\n\\n    uint256 private _totalSupply;\\n    uint256 private _totalSupplyRewardEquivalent;\\n    mapping(address => uint256) private _balances;\\n    mapping(address => uint256) private _balancesRewardEquivalent;\\n\\n    address public affiliateContract;\\n    bool public usePriceFeeds;\\n    IPriceFeed public priceFeed;\\n\\n    event RewardRateUpdated(uint256 indexed rateChangesNonce, uint256 rewardRate, uint256 timestamp);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event Rescue(address indexed to, uint amount);\\n    event RescueToken(address indexed to, address indexed token, uint amount);\\n\\n    event ToggleUsePriceFeeds(bool indexed usePriceFeeds);\\n\\n    constructor(\\n        address _rewardsToken,\\n        address _stakingToken,\\n        address _swapRouter,\\n        uint _rewardRate,\\n        uint _lockDuration\\n    ) {\\n        require(_rewardsToken != address(0) && _swapRouter != address(0), \\\"LockStakingRewardFixedAPY: Zero address(es)\\\");\\n        rewardsToken = IBEP20(_rewardsToken);\\n        stakingToken = IBEP20(_stakingToken);\\n        swapRouter = ICellitRouter(_swapRouter);\\n        rewardRate = _rewardRate;\\n        lockDuration = _lockDuration;\\n        emit RewardRateUpdated(rateChangesNonce, _rewardRate, block.timestamp);\\n        APYcheckpoints[rateChangesNonce++] = APYCheckpoint(block.timestamp, rewardRate);\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function totalSupplyRewardEquivalent() external view returns (uint256) {\\n        return _totalSupplyRewardEquivalent;\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return _balances[account];\\n    }\\n    \\n    function balanceOfRewardEquivalent(address account) external view returns (uint256) {\\n        return _balancesRewardEquivalent[account];\\n    }\\n\\n    function earnedByNonce(address account, uint256 nonce) public view returns (uint256) {\\n        return stakeNonceInfos[account][nonce].rewardsTokenAmount * \\n            (block.timestamp - stakeNonceInfos[account][nonce].stakeTime) *\\n             stakeNonceInfos[account][nonce].rewardRate / (100 * rewardDuration);\\n    }\\n\\n    function earned(address account) public view override returns (uint256 totalEarned) {\\n        for (uint256 i = 0; i < stakeNonces[account]; i++) {\\n            totalEarned += earnedByNonce(account, i);\\n        }\\n    }\\n\\n    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant {\\n        require(amount > 0, \\\"LockStakingRewardFixedAPY: Cannot stake 0\\\");\\n        // permit\\n        IBEP20Permit(address(stakingToken)).permit(msg.sender, address(this), amount, deadline, v, r, s);\\n        _stake(amount, msg.sender);\\n    }\\n\\n    function stake(uint256 amount) external override nonReentrant {\\n        require(amount > 0, \\\"LockStakingRewardFixedAPY: Cannot stake 0\\\");\\n        _stake(amount, msg.sender);\\n    }\\n\\n    function stakeFor(uint256 amount, address user) external override nonReentrant {\\n        require(amount > 0, \\\"LockStakingRewardFixedAPY: Cannot stake 0\\\");\\n        require(user != address(0), \\\"LockStakingRewardFixedAPY: Cannot stake for zero address\\\");\\n        _stake(amount, user);\\n    }\\n\\n    function _stake(uint256 amount, address user) private whenNotPaused {\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n        uint amountRewardEquivalent = getEquivalentAmount(amount);\\n\\n        _totalSupply += amount;\\n        _totalSupplyRewardEquivalent += amountRewardEquivalent;\\n        _balances[user] += amount;\\n\\n        uint stakeNonce = stakeNonces[user]++;\\n        stakeNonceInfos[user][stakeNonce].stakingTokenAmount = amount;\\n        stakeNonceInfos[user][stakeNonce].unlockTime = block.timestamp + lockDuration;\\n        stakeNonceInfos[user][stakeNonce].stakeTime = block.timestamp;\\n        stakeNonceInfos[user][stakeNonce].rewardRate = rewardRate;\\n        stakeNonceInfos[user][stakeNonce].rewardsTokenAmount = amountRewardEquivalent;\\n        _balancesRewardEquivalent[user] += amountRewardEquivalent;\\n        emit Staked(user, amount);\\n    }\\n\\n    //A user can withdraw its staking tokens even if there is no rewards tokens on the contract account\\n    function withdraw(uint256 nonce) public override nonReentrant whenNotPaused {\\n        require(stakeNonceInfos[msg.sender][nonce].stakingTokenAmount > 0, \\\"LockStakingRewardFixedAPY: This stake nonce was withdrawn\\\");\\n        require(stakeNonceInfos[msg.sender][nonce].unlockTime < block.timestamp, \\\"LockStakingRewardFixedAPY: Locked\\\");\\n        uint amount = stakeNonceInfos[msg.sender][nonce].stakingTokenAmount;\\n        uint amountRewardEquivalent = stakeNonceInfos[msg.sender][nonce].rewardsTokenAmount;\\n        _totalSupply -= amount;\\n        _totalSupplyRewardEquivalent -= amountRewardEquivalent;\\n        _balances[msg.sender] -= amount;\\n        _balancesRewardEquivalent[msg.sender] -= amountRewardEquivalent;\\n        stakeNonceInfos[msg.sender][nonce].stakingTokenAmount = 0;\\n        stakeNonceInfos[msg.sender][nonce].rewardsTokenAmount = 0;\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        \\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function getReward() public override nonReentrant whenNotPaused {\\n        uint256 reward = earned(msg.sender);\\n        if (reward > 0) {\\n            for (uint256 i = 0; i < stakeNonces[msg.sender]; i++) {\\n                stakeNonceInfos[msg.sender][i].stakeTime = block.timestamp;\\n            }\\n            rewardsToken.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function getRewardForUser(address user) public override nonReentrant whenNotPaused {\\n        require(msg.sender == affiliateContract || msg.sender == owner, \\\"LockStakingRewardFixedAPY :: isn`t allowed to call rewards\\\");\\n        uint256 reward = earned(user);\\n        if (reward > 0) {\\n            for (uint256 i = 0; i < stakeNonces[user]; i++) {\\n                stakeNonceInfos[user][i].stakeTime = block.timestamp;\\n            }\\n            rewardsToken.safeTransfer(user, reward);\\n            emit RewardPaid(user, reward);\\n        }\\n    }\\n\\n    function withdrawAndGetReward(uint256 nonce) external override {\\n        getReward();\\n        withdraw(nonce);\\n    }\\n\\n    function exit() external {\\n        getReward();\\n        for (uint256 i = 0; i < stakeNonces[msg.sender]; i++) {\\n            if (stakeNonceInfos[msg.sender][i].stakingTokenAmount > 0) {\\n                withdraw(i);\\n            }\\n        }\\n    }\\n\\n    function getEquivalentAmount(uint amount) public view returns (uint) {\\n        address[] memory path = new address[](2);\\n\\n        uint equivalent;\\n        if (stakingToken != rewardsToken) {\\n             if (usePriceFeeds && address(priceFeed) != address(0)) {\\n                (uint256 rate, uint256 precision) = priceFeed.queryRate(address(stakingToken), address(rewardsToken));\\n                equivalent = amount * rate / precision;\\n            } else {\\n                path[0] = address(stakingToken);            \\n                path[1] = address(rewardsToken);\\n                equivalent = swapRouter.getAmountsOut(amount, path)[1];\\n            }\\n        } else {\\n            equivalent = amount;   \\n        }\\n        \\n        return equivalent;\\n    }\\n\\n    function setAffiliateContract(address _affiliateContract) external onlyOwner {\\n        require(Address.isContract(_affiliateContract), \\\"LockStakingRewardFixedAPY: Not a contract\\\");\\n        affiliateContract = _affiliateContract;\\n    }\\n\\n    function setPaused(bool _paused) external onlyOwner {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    function updateRewardRate(uint256 _rewardRate) external onlyOwner {\\n        rewardRate = _rewardRate;\\n        emit RewardRateUpdated(rateChangesNonce, _rewardRate, block.timestamp);\\n        APYcheckpoints[rateChangesNonce++] = APYCheckpoint(block.timestamp, _rewardRate);\\n    }\\n\\n    function updateSwapRouter(address newSwapRouter) external onlyOwner {\\n        require(newSwapRouter != address(0), \\\"LockStakingRewardFixedAPY: Address is zero\\\");\\n        swapRouter = ICellitRouter(newSwapRouter);\\n    }\\n\\n    function updatePriceFeed(address newPriceFeed) external onlyOwner {\\n        require(newPriceFeed != address(0), \\\"LockStakingRewardFixedAPY: Address is zero\\\");\\n        priceFeed = IPriceFeed(newPriceFeed);\\n    }\\n\\n    function toggleUsePriceFeeds() external onlyOwner {\\n        usePriceFeeds = !usePriceFeeds;\\n        emit ToggleUsePriceFeeds(usePriceFeeds);\\n    }\\n\\n    function rescue(address to, address token, uint256 amount) external onlyOwner whenPaused {\\n        require(to != address(0), \\\"LockStakingRewardFixedAPY: Cannot rescue to the zero address\\\");\\n        require(amount > 0, \\\"LockStakingRewardFixedAPY: Cannot rescue 0\\\");\\n\\n        IBEP20(token).safeTransfer(to, amount);\\n        emit RescueToken(to, address(token), amount);\\n    }\\n\\n    function rescue(address payable to, uint256 amount) external onlyOwner whenPaused {\\n        require(to != address(0), \\\"LockStakingRewardFixedAPY: Cannot rescue to the zero address\\\");\\n        require(amount > 0, \\\"LockStakingRewardFixedAPY: Cannot rescue 0\\\");\\n\\n        to.transfer(amount);\\n        emit Rescue(to, amount);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Rescue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RescueToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rateChangesNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"usePriceFeeds\",\"type\":\"bool\"}],\"name\":\"ToggleUsePriceFeeds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"affiliateContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOfRewardEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"earnedByNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getEquivalentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewardForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateChangesNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_affiliateContract\",\"type\":\"address\"}],\"name\":\"setAffiliateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeNonceInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract ICellitRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleUsePriceFeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyRewardEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPriceFeed\",\"type\":\"address\"}],\"name\":\"updatePriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"}],\"name\":\"updateRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSwapRouter\",\"type\":\"address\"}],\"name\":\"updateSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usePriceFeeds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weightedStakeDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"withdrawAndGetReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LockStakingRewardFixedAPY", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000e43c97a42888a9651279146af0a7492a028f14a200000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000003c26700", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}