{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title Token\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    amount: uint256\r\n\r\nevent Transfer:\r\n    owner: indexed(address)\r\n    receiver: indexed(address)\r\n    amount: uint256\r\n\r\nevent SetMinter:\r\n    minter: indexed(address)\r\n\r\n\r\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\n\r\nVERSION: constant(String[5]) = \"1.0.0\"\r\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\r\n\r\n\r\nCACHED_CHAIN_ID: immutable(uint256)\r\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\r\n\r\nNAME_HASH: immutable(bytes32)\r\n\r\nname: public(immutable(String[64]))\r\nsymbol: public(immutable(String[32]))\r\ndecimals: public(immutable(uint8))\r\n\r\n\r\ntotalSupply: public(uint256)\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\n\r\nminter: public(address)\r\nnonces: public(HashMap[address, uint256])\r\n\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint8):\r\n    name = _name\r\n    symbol = _symbol\r\n    decimals = _decimals\r\n\r\n    CACHED_CHAIN_ID = chain.id\r\n    CACHED_DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_TYPEHASH,\r\n            keccak256(_name),\r\n            VERSION_HASH,\r\n            chain.id,\r\n            self\r\n        )\r\n    )\r\n\r\n    NAME_HASH = keccak256(_name)\r\n\r\n    self.minter = msg.sender\r\n    log SetMinter(msg.sender)\r\n\r\n\r\n@internal\r\ndef _approve(_owner: address, _spender: address, _amount: uint256):\r\n    self.allowance[_owner][_spender] = _amount\r\n\r\n    log Approval(_owner, _spender, _amount)\r\n\r\n\r\n@internal\r\ndef _burn(_from: address, _amount: uint256):\r\n    self.balanceOf[_from] -= _amount\r\n    self.totalSupply -= _amount\r\n\r\n    log Transfer(_from, empty(address), _amount)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _amount: uint256):\r\n    assert _to not in [self, empty(address)]\r\n\r\n    self.balanceOf[_from] -= _amount\r\n    self.balanceOf[_to] += _amount\r\n\r\n    log Transfer(_from, _to, _amount)\r\n\r\n\r\n@view\r\n@internal\r\ndef _domain_separator() -> bytes32:\r\n    if chain.id != CACHED_CHAIN_ID:\r\n        return keccak256(\r\n            _abi_encode(\r\n                EIP712_TYPEHASH,\r\n                NAME_HASH,\r\n                VERSION_HASH,\r\n                chain.id,\r\n                self\r\n            )\r\n        )\r\n\r\n    return CACHED_DOMAIN_SEPARATOR\r\n\r\n\r\n@external\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer tokens from one account to another.\r\n    @dev The caller needs to have an allowance from account `_from` greater than or\r\n        equal to the value being transferred. An allowance equal to the uint256 type's\r\n        maximum, is considered infinite and does not decrease the caller's allowance.\r\n    @param _from The account which tokens will be spent from.\r\n    @param _to The account which tokens will be sent to.\r\n    @param _value The amount of tokens to be transferred.\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if allowance != max_value(uint256):\r\n        self._approve(_from, msg.sender, allowance - _value)\r\n\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer tokens to `_to`.\r\n    @param _to The account to transfer tokens to.\r\n    @param _value The amount of tokens to transfer.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Allow `_spender` to transfer up to `_value` amount of tokens from the caller's account.\r\n    @dev Non-zero to non-zero approvals are allowed, but should be used cautiously. The methods\r\n        increaseAllowance + decreaseAllowance are available to prevent any front-running that\r\n        may occur.\r\n    @param _spender The account permitted to spend up to `_value` amount of caller's funds.\r\n    @param _value The amount of tokens `_spender` is allowed to spend.\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32,\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Permit `_spender` to spend up to `_value` amount of `_owner`'s tokens via a signature.\r\n    @dev In the event of a chain fork, replay attacks are prevented as domain separator is recalculated.\r\n        However, this is only if the resulting chains update their chainId.\r\n    @param _owner The account which generated the signature and is granting an allowance.\r\n    @param _spender The account which will be granted an allowance.\r\n    @param _value The approval amount.\r\n    @param _deadline The deadline by which the signature must be submitted.\r\n    @param _v The last byte of the ECDSA signature.\r\n    @param _r The first 32 bytes of the ECDSA signature.\r\n    @param _s The second 32 bytes of the ECDSA signature.\r\n    \"\"\"\r\n    assert _owner != empty(address) and block.timestamp <= _deadline\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self._domain_separator(),\r\n            keccak256(_abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\r\n        )\r\n    )\r\n\r\n    assert ecrecover(digest, _v, _r, _s) == _owner\r\n\r\n    self.nonces[_owner] = nonce + 1\r\n    self._approve(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _add_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender`.\r\n    @dev This function will never overflow, and instead will bound\r\n        allowance to MAX_UINT256. This has the potential to grant an\r\n        infinite approval.\r\n    @param _spender The account to increase the allowance of.\r\n    @param _add_value The amount to increase the allowance by.\r\n    \"\"\"\r\n    cached_allowance: uint256 = self.allowance[msg.sender][_spender]\r\n    allowance: uint256 = unsafe_add(cached_allowance, _add_value)\r\n\r\n    # check for an overflow\r\n    if allowance < cached_allowance:\r\n        allowance = max_value(uint256)\r\n\r\n    if allowance != cached_allowance:\r\n        self._approve(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _sub_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender`.\r\n    @dev This function will never underflow, and instead will bound\r\n        allowance to 0.\r\n    @param _spender The account to decrease the allowance of.\r\n    @param _sub_value The amount to decrease the allowance by.\r\n    \"\"\"\r\n    cached_allowance: uint256 = self.allowance[msg.sender][_spender]\r\n    allowance: uint256 = unsafe_sub(cached_allowance, _sub_value)\r\n\r\n    # check for an underflow\r\n    if cached_allowance < allowance:\r\n        allowance = 0\r\n\r\n    if allowance != cached_allowance:\r\n        self._approve(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burnFrom(_from: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burn `_value` amount of tokens from `_from`.\r\n    @dev The caller must have previously been given an allowance by `_from`.\r\n    @param _from The account to burn the tokens from.\r\n    @param _value The amount of tokens to burn.\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if allowance != max_value(uint256):\r\n        self._approve(_from, msg.sender, allowance - _value)\r\n\r\n    self._burn(_from, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burn `_value` amount of tokens.\r\n    @param _value The amount of tokens to burn.\r\n    \"\"\"\r\n    self._burn(msg.sender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Mint `_value` amount of tokens to `_to`.\r\n    @dev Only callable by an account with minter privileges.\r\n    @param _to The account newly minted tokens are credited to.\r\n    @param _value The amount of tokens to mint.\r\n    \"\"\"\r\n    assert msg.sender == self.minter\r\n    assert _to not in [self, empty(address)]\r\n\r\n    self.balanceOf[_to] += _value\r\n    self.totalSupply += _value\r\n\r\n    log Transfer(empty(address), _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef set_minter(_minter: address):\r\n    \"\"\"\r\n    @notice Set the minter.\r\n    @dev Only callble by the current minter account.\r\n    @param _minter The account to transfer minter permissions to.\r\n    \"\"\"\r\n    assert msg.sender == self.minter\r\n\r\n    self.minter = _minter\r\n    log SetMinter(_minter)\r\n\r\n\r\n@view\r\n@external\r\ndef DOMAIN_SEPARATOR() -> bytes32:\r\n    \"\"\"\r\n    @notice EIP712 domain separator.\r\n    \"\"\"\r\n    return self._domain_separator()", "ABI": "[{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMinter\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_add_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_sub_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burnFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_minter\",\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Token", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000f43757276652044414f20546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034352560000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}