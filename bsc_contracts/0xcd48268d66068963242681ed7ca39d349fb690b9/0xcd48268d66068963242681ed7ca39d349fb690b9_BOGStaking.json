{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\n/**\r\n * $$$$$$$\\                                                $$\\       $$$$$$$$\\ $$\\                                                   \r\n * $$  __$$\\                                               $$ |      $$  _____|\\__|                                                  \r\n * $$ |  $$ | $$$$$$\\   $$$$$$\\   $$$$$$\\   $$$$$$\\   $$$$$$$ |      $$ |      $$\\ $$$$$$$\\   $$$$$$\\  $$$$$$$\\   $$$$$$$\\  $$$$$$\\  \r\n * $$$$$$$\\ |$$  __$$\\ $$  __$$\\ $$  __$$\\ $$  __$$\\ $$  __$$ |      $$$$$\\    $$ |$$  __$$\\  \\____$$\\ $$  __$$\\ $$  _____|$$  __$$\\ \r\n * $$  __$$\\ $$ /  $$ |$$ /  $$ |$$ /  $$ |$$$$$$$$ |$$ /  $$ |      $$  __|   $$ |$$ |  $$ | $$$$$$$ |$$ |  $$ |$$ /      $$$$$$$$ |\r\n * $$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |      $$ |      $$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$ |      $$   ____|\r\n * $$$$$$$  |\\$$$$$$  |\\$$$$$$$ |\\$$$$$$$ |\\$$$$$$$\\ \\$$$$$$$ |      $$ |      $$ |$$ |  $$ |\\$$$$$$$ |$$ |  $$ |\\$$$$$$$\\ \\$$$$$$$\\ \r\n * \\_______/  \\______/  \\____$$ | \\____$$ | \\_______| \\_______|      \\__|      \\__|\\__|  \\__| \\_______|\\__|  \\__| \\_______| \\_______|\r\n *                     $$\\   $$ |$$\\   $$ |                                                                                          \r\n *                     \\$$$$$$  |\\$$$$$$  |                                                                                          \r\n *                      \\______/  \\______/\r\n *\r\n * Bogged Finance\r\n * https://bogged.finance/\r\n */\r\n\r\n/**\r\n * Standard SafeMath, stripped down to just add/sub/mul/div\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Provides ownable & authorized contexts\r\n */\r\nabstract contract BOGAuth {\r\n    address owner;\r\n    mapping (address => bool) private authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender)); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be authorized\r\n     */\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender)); _;\r\n    }\r\n\r\n    /**\r\n     * Authorize address. Any authorized address\r\n     */\r\n    function authorize(address adr) public authorized {\r\n        authorizations[adr] = true;\r\n        emit Authorized(adr);\r\n    }\r\n\r\n    /**\r\n     * Remove address' authorization. Owner only\r\n     */\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n        emit Unauthorized(adr);\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner.\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n    event Authorized(address adr);\r\n    event Unauthorized(address adr);\r\n}\r\n\r\nabstract contract BOGPausable is BOGAuth {\r\n    bool public paused;\r\n\r\n    modifier whenPaused() {\r\n        require(paused || isAuthorized(msg.sender)); _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!paused || isAuthorized(msg.sender)); _;\r\n    }\r\n\r\n    function pause() external notPaused authorized {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    function unpause() public whenPaused authorized {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n\r\n    event Paused();\r\n    event Unpaused();\r\n}\r\n\r\ninterface IBOGStaking {\r\n    function stakingToken() external view returns (address);\r\n    function rewardToken() external view returns (address);\r\n\r\n    function totalStaked() external view returns (uint256);\r\n    function totalRealised() external view returns (uint256);\r\n\r\n    function getTotalRewards() external view returns (uint256);\r\n\r\n    function getCumulativeRewardsPerLP() external view returns (uint256);\r\n    function getLastContractBalance() external view returns (uint256);\r\n    function getAccuracyFactor() external view returns (uint256);\r\n\r\n    function getStake(address staker) external view returns (uint256);\r\n    function getRealisedEarnings(address staker) external returns (uint256);\r\n    function getUnrealisedEarnings(address staker) external view returns (uint256);\r\n\r\n    function stake(uint256 amount) external;\r\n    function stakeAll() external;\r\n\r\n    function unstake(uint256 amount) external;\r\n    function unstakeAll() external;\r\n\r\n    function realise() external;\r\n\r\n    event Realised(address account, uint amount);\r\n    event Compounded(address account, uint amount);\r\n    event Staked(address account, uint amount);\r\n    event Unstaked(address account, uint amount);\r\n    event EarlyWithdrawalPenalty(address account, uint amount);\r\n}\r\n\r\ncontract BOGStaking is BOGAuth, BOGPausable, IBOGStaking {\r\n    using SafeMath for uint256;\r\n    \r\n    struct Stake {\r\n        uint256 lastStaked;\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    \r\n    address public override stakingToken = 0xB09FE1613fE03E7361319d2a43eDc17422f36B09;\r\n    address public override rewardToken = 0xB09FE1613fE03E7361319d2a43eDc17422f36B09;\r\n\r\n    uint256 public override totalRealised;\r\n    uint256 public override totalStaked;\r\n\r\n    mapping (address => Stake) public stakes;\r\n\r\n    uint256 _accuracyFactor = 10 ** 36;\r\n    uint256 _rewardsPerLP;\r\n    uint256 _lastContractBalance;\r\n    \r\n    uint256 public penaltyTime = 7 days;\r\n    uint256 public penaltyFee = 50; // 0.50%\r\n    uint256 public penaltyFeeDenominator = 10000;\r\n    address public penaltyFeeReceiver = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    constructor () BOGAuth(msg.sender) { }\r\n\r\n    /**\r\n     * Total rewards realised and to be realised\r\n     */\r\n    function getTotalRewards() external override view  returns (uint256) {\r\n        return totalRealised + IBEP20(rewardToken).balanceOf(address(this)).sub(totalStaked);\r\n    }\r\n\r\n    /**\r\n     * Total rewards per LP cumulatively, inflated by _accuracyFactor\r\n     */\r\n    function getCumulativeRewardsPerLP() external override view returns (uint256) {\r\n        return _rewardsPerLP;\r\n    }\r\n\r\n    /**\r\n     * The last balance the contract had\r\n     */\r\n    function getLastContractBalance() external override view returns (uint256) {\r\n        return _lastContractBalance;\r\n    }\r\n\r\n    /**\r\n     * Total amount of transaction fees sent or to be sent to stakers\r\n     */\r\n    function getAccuracyFactor() external override view returns (uint256) {\r\n        return _accuracyFactor;\r\n    }\r\n\r\n    /**\r\n     * Returns amount of LP that address has staked\r\n     */\r\n    function getStake(address account) public override view returns (uint256) {\r\n        return stakes[account].amount;\r\n    }\r\n\r\n    /**\r\n     * Returns total earnings (realised + unrealised)\r\n     */\r\n    function getRealisedEarnings(address staker) external view override returns (uint256) {\r\n        return stakes[staker].totalRealised; // realised gains plus outstanding earnings\r\n    }\r\n\r\n    /**\r\n     * Returns unrealised earnings\r\n     */\r\n    function getUnrealisedEarnings(address staker) external view override returns (uint256) {\r\n        if(stakes[staker].amount == 0){ return 0; }\r\n\r\n        uint256 stakerTotalRewards = stakes[staker].amount.mul(getCurrentRewardsPerLP()).div(_accuracyFactor);\r\n        uint256 stakerTotalExcluded = stakes[staker].totalExcluded;\r\n\r\n        if(stakerTotalRewards <= stakerTotalExcluded){ return 0; }\r\n\r\n        return stakerTotalRewards.sub(stakerTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeRewards(uint256 amount) public view returns (uint256) {\r\n        return amount.mul(_rewardsPerLP).div(_accuracyFactor);\r\n    }\r\n\r\n    function stake(uint amount) external override {\r\n        require(amount > 0);\r\n\r\n        _realise(msg.sender);\r\n\r\n        IBEP20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\r\n        _stake(msg.sender, amount);\r\n    }\r\n\r\n    function stakeAll() external override {\r\n        uint256 amount = IBEP20(stakingToken).balanceOf(msg.sender);\r\n        require(amount > 0);\r\n\r\n        _realise(msg.sender);\r\n\r\n        IBEP20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\r\n        _stake(msg.sender, amount);\r\n    }\r\n\r\n    function unstake(uint amount) external override {\r\n        require(amount > 0);\r\n\r\n        _unstake(msg.sender, amount);\r\n    }\r\n\r\n    function unstakeAll() external override {\r\n        uint256 amount = getStake(msg.sender);\r\n        require(amount > 0);\r\n\r\n        _unstake(msg.sender, amount);\r\n    }\r\n\r\n    function realise() external override notPaused {\r\n        _realise(msg.sender);\r\n    }\r\n\r\n    function _realise(address staker) internal {\r\n        _updateRewards();\r\n\r\n        uint amount = earnt(staker);\r\n\r\n        if (getStake(staker) == 0 || amount == 0) {\r\n            return;\r\n        }\r\n\r\n        stakes[staker].totalRealised = stakes[staker].totalRealised.add(amount);\r\n        stakes[staker].totalExcluded = stakes[staker].totalExcluded.add(amount);\r\n        totalRealised = totalRealised.add(amount);\r\n\r\n        IBEP20(rewardToken).transfer(staker, amount);\r\n\r\n        _updateRewards();\r\n\r\n        emit Realised(staker, amount);\r\n    }\r\n    \r\n    function earnt(address staker) internal view returns (uint256) {\r\n        if(stakes[staker].amount == 0){ return 0; }\r\n\r\n        uint256 stakerTotalRewards = getCumulativeRewards(stakes[staker].amount);\r\n        uint256 stakerTotalExcluded = stakes[staker].totalExcluded;\r\n\r\n        if(stakerTotalRewards <= stakerTotalExcluded){ return 0; }\r\n\r\n        return stakerTotalRewards.sub(stakerTotalExcluded);\r\n    }\r\n\r\n    function _stake(address staker, uint256 amount) internal notPaused {\r\n        require(amount > 0);\r\n\r\n        // add to current address' stake\r\n        stakes[staker].lastStaked = block.timestamp;\r\n        stakes[staker].amount = stakes[staker].amount.add(amount);\r\n        stakes[staker].totalExcluded = getCumulativeRewards(stakes[staker].amount);\r\n        totalStaked = totalStaked.add(amount);\r\n\r\n        emit Staked(staker, amount);\r\n    }\r\n\r\n    function _unstake(address staker, uint256 amount) internal notPaused {\r\n        require(stakes[staker].amount >= amount, \"Insufficient Stake\");\r\n\r\n        _realise(staker); // realise staking gains\r\n\r\n        // remove stake\r\n        stakes[staker].amount = stakes[staker].amount.sub(amount);\r\n        stakes[staker].totalExcluded = getCumulativeRewards(stakes[staker].amount);\r\n        totalStaked = totalStaked.sub(amount);\r\n\r\n        if(stakes[staker].lastStaked + penaltyTime > block.timestamp){\r\n            uint256 penalty = amount.mul(penaltyFee).div(penaltyFeeDenominator);\r\n            uint256 remaining = amount.sub(penalty);\r\n            \r\n            IBEP20(stakingToken).transfer(staker, remaining);\r\n            IBEP20(stakingToken).transfer(penaltyFeeReceiver, penalty);\r\n            \r\n            emit EarlyWithdrawalPenalty(staker, penalty);\r\n        }else{\r\n            IBEP20(stakingToken).transfer(staker, amount);\r\n        }\r\n\r\n        emit Unstaked(staker, amount);\r\n    }\r\n\r\n    function _updateRewards() internal  {\r\n        uint tokenBalance = IBEP20(rewardToken).balanceOf(address(this)).sub(totalStaked);\r\n\r\n        if(tokenBalance > _lastContractBalance && totalStaked != 0) {\r\n            uint256 newRewards = tokenBalance.sub(_lastContractBalance);\r\n            uint256 additionalAmountPerLP = newRewards.mul(_accuracyFactor).div(totalStaked);\r\n            _rewardsPerLP = _rewardsPerLP.add(additionalAmountPerLP);\r\n        }\r\n\r\n        if(totalStaked > 0){ _lastContractBalance = tokenBalance; }\r\n    }\r\n\r\n    function getCurrentRewardsPerLP() public view returns (uint256 currentRewardsPerLP) {\r\n        uint tokenBalance = IBEP20(rewardToken).balanceOf(address(this)).sub(totalStaked);\r\n        if(tokenBalance > _lastContractBalance && totalStaked != 0){\r\n            uint256 newRewards = tokenBalance.sub(_lastContractBalance);\r\n            uint256 additionalAmountPerLP = newRewards.mul(_accuracyFactor).div(totalStaked);\r\n            currentRewardsPerLP = _rewardsPerLP.add(additionalAmountPerLP);\r\n        }\r\n    }\r\n\r\n    function setAccuracyFactor(uint256 newFactor) external authorized {\r\n        _rewardsPerLP = _rewardsPerLP.mul(newFactor).div(_accuracyFactor); // switch _rewardsPerLP to be inflated by the new factor instead\r\n        _accuracyFactor = newFactor;\r\n    }\r\n    \r\n    function setPenalty(uint256 time, uint256 fee, uint256 denominator, address receiver) external authorized {\r\n        penaltyTime = time;\r\n        penaltyFee = fee;\r\n        penaltyFeeDenominator = denominator;\r\n        penaltyFeeReceiver = receiver;\r\n    }\r\n\r\n    function emergencyUnstakeAll() external {\r\n        require(stakes[msg.sender].amount > 0, \"No Stake\");\r\n\r\n        IBEP20(stakingToken).transfer(msg.sender, stakes[msg.sender].amount);\r\n        totalStaked = totalStaked.sub(stakes[msg.sender].amount);\r\n        stakes[msg.sender].amount = 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Compounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EarlyWithdrawalPenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Realised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getCumulativeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCumulativeRewardsPerLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRewardsPerLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentRewardsPerLP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getRealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUnrealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyFeeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"setAccuracyFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRealised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BOGStaking", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fabf0b910d805e1e9276d746bd9146ddaf7bc57cc547a4009c0b4f443a4626b2"}