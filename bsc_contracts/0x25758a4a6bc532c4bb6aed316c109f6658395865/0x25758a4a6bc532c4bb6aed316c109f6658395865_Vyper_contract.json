{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title Voting YFI\r\n@author Curve Finance, Yearn Finance\r\n@license MIT\r\n@notice\r\n    Votes have a weight depending on time, so that users are\r\n    committed to the future of whatever they are voting for.\r\n@dev\r\n    The voting power is capped at 4 years, but the lock can exceed that duration.\r\n    Vote weight decays linearly over time.\r\n    A user can unlock funds early incurring a penalty.\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface RewardPool:\r\n    def burn(amount: uint256) -> bool: nonpayable\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n\r\nstruct LockedBalance:\r\n    amount: uint256\r\n    end: uint256\r\n\r\nstruct Kink:\r\n    slope: int128\r\n    ts: uint256\r\n\r\nstruct Withdrawn:\r\n    amount: uint256\r\n    penalty: uint256\r\n\r\nevent ModifyLock:\r\n    sender: indexed(address)\r\n    user: indexed(address)\r\n    amount: uint256\r\n    locktime: uint256\r\n    ts: uint256\r\n\r\nevent Withdraw:\r\n    user: indexed(address)\r\n    amount: uint256\r\n    ts: uint256\r\n\r\nevent Penalty:\r\n    user: indexed(address)\r\n    amount: uint256\r\n    ts: uint256\r\n\r\nevent Supply:\r\n    old_supply: uint256\r\n    new_supply: uint256\r\n    ts: uint256\r\n\r\nevent Initialized:\r\n    token: ERC20\r\n    reward_pool: RewardPool\r\n\r\nYFI: immutable(ERC20)\r\nREWARD_POOL: immutable(RewardPool)\r\n\r\nDAY: constant(uint256) = 86400\r\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\r\nMAX_LOCK_DURATION: constant(uint256) = 4 * 365 * 86400 / WEEK * WEEK  # 4 years\r\nSCALE: constant(uint256) = 10 ** 18\r\nMAX_PENALTY_RATIO: constant(uint256) = SCALE * 3 / 4  # 75% for early exit of max lock\r\nMAX_N_WEEKS: constant(uint256) = 522\r\n\r\nsupply: public(uint256)\r\nlocked: public(HashMap[address, LockedBalance])\r\n# history\r\nepoch: public(HashMap[address, uint256])\r\npoint_history: public(HashMap[address, HashMap[uint256, Point]])  # epoch -> unsigned point\r\nslope_changes: public(HashMap[address, HashMap[uint256, int128]])  # time -> signed slope change\r\n\r\n\r\n@external\r\ndef __init__(token: ERC20, reward_pool: RewardPool):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param token YFI token address\r\n    @param reward_pool Pool for early exit penalties\r\n    \"\"\"\r\n    YFI = token\r\n    REWARD_POOL = reward_pool\r\n    self.point_history[self][0].blk = block.number\r\n    self.point_history[self][0].ts = block.timestamp\r\n\r\n    log Initialized(token, reward_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_last_user_point(addr: address) -> Point:\r\n    \"\"\"\r\n    @notice Get the most recently recorded point for a user\r\n    @param addr Address of the user wallet\r\n    @return Last recorded point\r\n    \"\"\"\r\n    epoch: uint256 = self.epoch[addr]\r\n    return self.point_history[addr][epoch]\r\n\r\n\r\n@pure\r\n@internal\r\ndef round_to_week(ts: uint256) -> uint256:\r\n    return ts / WEEK * WEEK\r\n\r\n\r\n@view\r\n@internal\r\ndef lock_to_point(lock: LockedBalance) -> Point:\r\n    point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\r\n    if lock.amount > 0:\r\n        # the lock is longer than the max duration\r\n        slope: int128 = convert(lock.amount / MAX_LOCK_DURATION, int128)\r\n        if lock.end > block.timestamp + MAX_LOCK_DURATION:\r\n            point.slope = 0\r\n            point.bias = slope * convert(MAX_LOCK_DURATION, int128)\r\n        # the lock ends in the future but shorter than max duration\r\n        elif lock.end > block.timestamp:\r\n            point.slope = slope\r\n            point.bias = slope * convert(lock.end - block.timestamp, int128)\r\n    return point\r\n\r\n\r\n@view\r\n@internal\r\ndef lock_to_kink(lock: LockedBalance) -> Kink:\r\n    kink: Kink = empty(Kink)\r\n    # the lock is longer than the max duration\r\n    if lock.amount > 0 and lock.end > self.round_to_week(block.timestamp + MAX_LOCK_DURATION):\r\n        kink.ts = self.round_to_week(lock.end - MAX_LOCK_DURATION)\r\n        kink.slope = convert(lock.amount / MAX_LOCK_DURATION, int128)\r\n\r\n    return kink\r\n\r\n\r\n@internal\r\ndef _checkpoint_user(user: address, old_lock: LockedBalance, new_lock: LockedBalance) -> Point[2]:\r\n    old_point: Point = self.lock_to_point(old_lock)\r\n    new_point: Point = self.lock_to_point(new_lock)\r\n\r\n    old_kink: Kink = self.lock_to_kink(old_lock)        \r\n    new_kink: Kink = self.lock_to_kink(new_lock)\r\n\r\n    # schedule slope changes for the lock end\r\n    if old_point.slope != 0 and old_lock.end > block.timestamp:\r\n        self.slope_changes[self][old_lock.end] += old_point.slope\r\n        self.slope_changes[user][old_lock.end] += old_point.slope\r\n    if new_point.slope != 0 and new_lock.end > block.timestamp:\r\n        self.slope_changes[self][new_lock.end] -= new_point.slope\r\n        self.slope_changes[user][new_lock.end] -= new_point.slope\r\n\r\n    # schedule kinks for locks longer than max duration\r\n    if old_kink.slope != 0:\r\n        self.slope_changes[self][old_kink.ts] -= old_kink.slope\r\n        self.slope_changes[user][old_kink.ts] -= old_kink.slope\r\n        self.slope_changes[self][old_lock.end] += old_kink.slope\r\n        self.slope_changes[user][old_lock.end] += old_kink.slope\r\n    if new_kink.slope != 0:\r\n        self.slope_changes[self][new_kink.ts] += new_kink.slope\r\n        self.slope_changes[user][new_kink.ts] += new_kink.slope\r\n        self.slope_changes[self][new_lock.end] -= new_kink.slope\r\n        self.slope_changes[user][new_lock.end] -= new_kink.slope\r\n\r\n    self.epoch[user] += 1\r\n    self.point_history[user][self.epoch[user]] = new_point\r\n    return [old_point, new_point]\r\n\r\n@internal\r\ndef _checkpoint_global() -> Point:\r\n    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\r\n    epoch: uint256 = self.epoch[self]\r\n    if epoch > 0:\r\n        last_point = self.point_history[self][epoch]\r\n    last_checkpoint: uint256 = last_point.ts\r\n    # initial_last_point is used for extrapolation to calculate block number\r\n    initial_last_point: Point = last_point\r\n    block_slope: uint256 = 0  # dblock/dt\r\n    if block.timestamp > last_checkpoint:\r\n        block_slope = SCALE * (block.number - last_point.blk) / (block.timestamp - last_checkpoint)\r\n    \r\n    # apply weekly slope changes and record weekly global snapshots\r\n    t_i: uint256 = self.round_to_week(last_checkpoint)\r\n    for i in range(255):\r\n        t_i = min(t_i + WEEK, block.timestamp)\r\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\r\n        last_point.slope += self.slope_changes[self][t_i]  # will read 0 if not aligned to week\r\n        last_point.bias = max(0, last_point.bias)  # this can happen\r\n        last_point.slope = max(0, last_point.slope)  # this shouldn't happen\r\n        last_checkpoint = t_i\r\n        last_point.ts = t_i\r\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / SCALE\r\n        epoch += 1\r\n        if t_i < block.timestamp:\r\n            self.point_history[self][epoch] = last_point\r\n        # skip last week\r\n        else:\r\n            last_point.blk = block.number\r\n            break\r\n\r\n    self.epoch[self] = epoch\r\n    return last_point\r\n\r\n\r\n@internal\r\ndef _checkpoint(user: address, old_lock: LockedBalance, new_lock: LockedBalance):\r\n    \"\"\"\r\n    @notice Record global and per-user data to checkpoint\r\n    @param user User's wallet address. No user checkpoint if 0x0\r\n    @param old_lock Pevious locked amount / end lock time for the user\r\n    @param new_lock New locked amount / end lock time for the user\r\n    \"\"\"\r\n    user_points: Point[2] = empty(Point[2])\r\n\r\n    if user != empty(address):\r\n        user_points = self._checkpoint_user(user, old_lock, new_lock)\r\n\r\n    # fill point_history until t=now\r\n    last_point: Point = self._checkpoint_global()\r\n    \r\n    # only affects the last checkpoint at t=now\r\n    if user != empty(address):\r\n        # If last point was in this block, the slope change has been applied already\r\n        # But in such case we have 0 slope(s)\r\n        last_point.slope += (user_points[1].slope - user_points[0].slope)\r\n        last_point.bias += (user_points[1].bias - user_points[0].bias)\r\n        last_point.slope = max(0, last_point.slope)\r\n        last_point.bias = max(0, last_point.bias)\r\n\r\n    # Record the changed point into history\r\n    epoch: uint256 = self.epoch[self]\r\n    self.point_history[self][epoch] = last_point\r\n\r\n\r\n@external\r\ndef checkpoint():\r\n    \"\"\"\r\n    @notice Record global data to checkpoint\r\n    \"\"\"\r\n    self._checkpoint(empty(address), empty(LockedBalance), empty(LockedBalance))\r\n\r\n\r\n@external\r\ndef modify_lock(amount: uint256, unlock_time: uint256, user: address = msg.sender) -> LockedBalance:\r\n    \"\"\"\r\n    @notice Create or modify a lock for a user. Support deposits on behalf of a user.\r\n    @dev\r\n        Minimum deposit to create a lock is 1 YFI.\r\n        You can lock for longer than 4 years, but less than 10 years, the max voting power is capped at 4 years.\r\n        You can only increase lock duration if it has less than 4 years remaining.\r\n        You can decrease lock duration if it has more than 4 years remaining.\r\n    @param amount YFI amount to add to a lock. 0 to not modify.\r\n    @param unlock_time Unix timestamp when the lock ends, must be in the future. 0 to not modify.\r\n    @param user A user to deposit to. If different from msg.sender, unlock_time has no effect\r\n    \"\"\"\r\n    old_lock: LockedBalance = self.locked[user]\r\n    new_lock: LockedBalance = old_lock\r\n    new_lock.amount += amount\r\n\r\n    unlock_week: uint256 = 0\r\n    # only a user can modify their own unlock time\r\n    if msg.sender == user:\r\n        if unlock_time != 0:\r\n            unlock_week = self.round_to_week(unlock_time)  # locktime is rounded down to weeks\r\n            assert ((unlock_week - self.round_to_week(block.timestamp)) / WEEK) < MAX_N_WEEKS # lock can't exceed 10 years\r\n            assert unlock_week > block.timestamp  #  dev: unlock time must be in the future\r\n            if unlock_week - block.timestamp < MAX_LOCK_DURATION:\r\n                assert unlock_week > old_lock.end  # dev: can only increase lock duration\r\n            else:\r\n                assert unlock_week > block.timestamp + MAX_LOCK_DURATION  # dev: can only decrease to \u22654 years\r\n            new_lock.end = unlock_week\r\n\r\n    # create lock\r\n    if old_lock.amount == 0 and old_lock.end == 0:\r\n        assert msg.sender == user  # dev: you can only create a lock for yourself\r\n        assert amount >= 10 ** 18  # dev: minimum amount is 1 YFI\r\n        assert unlock_week != 0  # dev: must specify unlock time in the future\r\n    # modify lock\r\n    else:\r\n        assert old_lock.end > block.timestamp  # dev: lock expired\r\n\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before + amount\r\n    self.locked[user] = new_lock\r\n    \r\n    self._checkpoint(user, old_lock, new_lock)\r\n\r\n    if amount > 0:\r\n        assert YFI.transferFrom(msg.sender, self, amount)\r\n\r\n    log Supply(supply_before, supply_before + amount, block.timestamp)\r\n    log ModifyLock(msg.sender, user, new_lock.amount, new_lock.end, block.timestamp)\r\n\r\n    return new_lock\r\n\r\n\r\n@external\r\ndef withdraw() -> Withdrawn:\r\n    \"\"\"\r\n    @notice Withdraw lock for a sender\r\n    @dev\r\n        If a lock has expired, sends a full amount to the sender.\r\n        If a lock is still active, the sender pays a 75% penalty during the first year\r\n        and a linearly decreasing penalty from 75% to 0 based on the remaining lock time.\r\n    \"\"\"\r\n    old_locked: LockedBalance = self.locked[msg.sender]\r\n    assert old_locked.amount > 0  # dev: create a lock first to withdraw\r\n    \r\n    time_left: uint256 = 0\r\n    penalty: uint256 = 0\r\n\r\n    if old_locked.end > block.timestamp:\r\n        time_left = min(old_locked.end - block.timestamp, MAX_LOCK_DURATION)\r\n        penalty_ratio: uint256 = min(time_left * SCALE / MAX_LOCK_DURATION, MAX_PENALTY_RATIO)\r\n        penalty = old_locked.amount * penalty_ratio / SCALE\r\n\r\n    zero_locked: LockedBalance = empty(LockedBalance)\r\n    self.locked[msg.sender] = zero_locked\r\n\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before - old_locked.amount\r\n\r\n    self._checkpoint(msg.sender, old_locked, zero_locked)\r\n\r\n    assert YFI.transfer(msg.sender, old_locked.amount - penalty)\r\n    \r\n    if penalty > 0:\r\n        assert YFI.approve(REWARD_POOL.address, penalty)\r\n        assert REWARD_POOL.burn(penalty)\r\n\r\n        log Penalty(msg.sender, penalty, block.timestamp)\r\n    \r\n    log Withdraw(msg.sender, old_locked.amount - penalty, block.timestamp)\r\n    log Supply(supply_before, supply_before - old_locked.amount, block.timestamp)\r\n\r\n    return Withdrawn({amount: old_locked.amount - penalty, penalty: penalty})\r\n\r\n@view\r\n@internal\r\ndef find_epoch_by_block(user: address, height: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to estimate epoch height number\r\n    @param height Block to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Epoch the block is in\r\n    \"\"\"\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[user][_mid].blk <= height:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@view\r\n@external\r\ndef find_epoch_by_timestamp(user: address, ts: uint256) -> uint256:\r\n    return self._find_epoch_by_timestamp(user, ts, self.epoch[user])\r\n\r\n@view\r\n@internal\r\ndef _find_epoch_by_timestamp(user: address, ts: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to estimate epoch timestamp\r\n    @param ts Timestamp to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Epoch the timestamp is in\r\n    \"\"\"\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[user][_mid].ts <= ts:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@view\r\n@internal\r\ndef replay_slope_changes(user: address, point: Point, ts: uint256) -> Point:\r\n    \"\"\"\r\n    @dev\r\n        If the `ts` is higher than MAX_N_WEEKS weeks ago, this function will return the \r\n        balance at exactly MAX_N_WEEKS weeks instead of `ts`. \r\n        MAX_N_WEEKS weeks is considered sufficient to cover the `MAX_LOCK_DURATION` period.\r\n    \"\"\"\r\n    upoint: Point = point\r\n    t_i: uint256 = self.round_to_week(upoint.ts)\r\n\r\n    for i in range(MAX_N_WEEKS):\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > ts:\r\n            t_i = ts\r\n        else:\r\n            d_slope = self.slope_changes[user][t_i]\r\n        upoint.bias -= upoint.slope * convert(t_i - upoint.ts, int128)\r\n        if t_i == ts:\r\n            break\r\n        upoint.slope += d_slope\r\n        upoint.ts = t_i\r\n    \r\n    upoint.bias = max(0, upoint.bias)\r\n    return upoint\r\n\r\n@view\r\n@internal\r\ndef _balanceOf(user: address, ts: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for `user`\r\n    @param user User wallet address\r\n    @param ts Epoch time to return voting power at\r\n    @return User voting power\r\n    \"\"\"\r\n    epoch: uint256 = self.epoch[user]\r\n    if epoch == 0:\r\n        return 0\r\n    if ts != block.timestamp:\r\n        epoch = self._find_epoch_by_timestamp(user, ts, epoch)\r\n    upoint: Point = self.point_history[user][epoch]\r\n    \r\n    upoint = self.replay_slope_changes(user, upoint, ts)\r\n\r\n    return convert(upoint.bias, uint256)\r\n\r\n\r\n@view\r\n@external\r\ndef balanceOf(user: address, ts: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for `user`\r\n    @param user User wallet address\r\n    @param ts Epoch time to return voting power at\r\n    @return User voting power\r\n    \"\"\"\r\n    return self._balanceOf(user, ts)\r\n\r\n\r\n@view\r\n@external\r\ndef getPriorVotes(user: address, height: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Measure voting power of `user` at block height `height`\r\n    @dev \r\n        Compatible with GovernorAlpha. \r\n        `user`can be self to get total supply at height.\r\n    @param user User's wallet address\r\n    @param height Block to calculate the voting power at\r\n    @return Voting power\r\n    \"\"\"\r\n    assert height <= block.number\r\n\r\n    uepoch: uint256 = self.epoch[user]\r\n    uepoch = self.find_epoch_by_block(user, height, uepoch)\r\n    upoint: Point = self.point_history[user][uepoch]\r\n\r\n    max_epoch: uint256 = self.epoch[self]\r\n    epoch: uint256 = self.find_epoch_by_block(self, height, max_epoch)\r\n    point_0: Point = self.point_history[self][epoch]\r\n    d_block: uint256 = 0\r\n    d_t: uint256 = 0\r\n    if epoch < max_epoch:\r\n        point_1: Point = self.point_history[self][epoch + 1]\r\n        d_block = point_1.blk - point_0.blk\r\n        d_t = point_1.ts - point_0.ts\r\n    else:\r\n        d_block = block.number - point_0.blk\r\n        d_t = block.timestamp - point_0.ts\r\n    block_time: uint256 = point_0.ts\r\n    if d_block != 0:\r\n        block_time += d_t * (height - point_0.blk) / d_block\r\n\r\n    upoint = self.replay_slope_changes(user, upoint, block_time)\r\n    return convert(upoint.bias, uint256)\r\n@view\r\n@external\r\ndef totalSupply(ts: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power\r\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n    @param ts Epoch time to return voting power at\r\n    @return Total voting power\r\n    \"\"\"\r\n    return self._balanceOf(self, ts)\r\n\r\n\r\n@view\r\n@external\r\ndef totalSupplyAt(height: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param height Block to calculate the total voting power at\r\n    @return Total voting power at `height`\r\n    \"\"\"\r\n    assert height <= block.number\r\n    epoch: uint256 = self.epoch[self]\r\n    target_epoch: uint256 = self.find_epoch_by_block(self, height, epoch)\r\n\r\n    point: Point = self.point_history[self][target_epoch]\r\n    dt: uint256 = 0\r\n    if target_epoch < epoch:\r\n        point_next: Point = self.point_history[self][target_epoch + 1]\r\n        if point.blk != point_next.blk:\r\n            dt = (height - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\r\n    else:\r\n        if point.blk != block.number:\r\n            dt = (height - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\r\n\r\n    # Now dt contains info on how far are we beyond point\r\n    point = self.replay_slope_changes(self, point, point.ts + dt)\r\n    return convert(point.bias, uint256)\r\n\r\n\r\n@view\r\n@external\r\ndef token() -> ERC20:\r\n    return YFI\r\n\r\n\r\n@view\r\n@external\r\ndef reward_pool() -> RewardPool:\r\n    return REWARD_POOL\r\n\r\n\r\n@view\r\n@external\r\ndef name() -> String[12]:\r\n    return \"Voting SISHI\"\r\n\r\n\r\n@view\r\n@external\r\ndef symbol() -> String[7]:\r\n    return \"veSISHI\"\r\n\r\n\r\n@view\r\n@external\r\ndef decimals() -> uint8:\r\n    return 18", "ABI": "[{\"name\":\"ModifyLock\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"locktime\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Penalty\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Supply\",\"inputs\":[{\"name\":\"old_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Initialized\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"reward_pool\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"reward_pool\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_last_user_point\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"modify_lock\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unlock_time\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"modify_lock\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unlock_time\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"penalty\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_epoch_by_timestamp\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"ts\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"ts\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getPriorVotes\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"height\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[{\"name\":\"ts\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupplyAt\",\"inputs\":[{\"name\":\"height\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"slope_changes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000008e8538c75f273ab2df6adeecd3622a9c314fccf30000000000000000000000003d8c9febbff7a75a66868e57fe650ab8b372900c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}