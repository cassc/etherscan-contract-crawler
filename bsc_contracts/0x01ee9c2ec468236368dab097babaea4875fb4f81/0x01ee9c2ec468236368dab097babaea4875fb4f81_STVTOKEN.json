{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"STV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        address pair,\\r\\n        uint\\r\\n    );\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external view returns (address pair);\\r\\n\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint amountA,\\r\\n        uint reserveA,\\r\\n        uint reserveB\\r\\n    ) external pure returns (uint amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint amountIn,\\r\\n        uint reserveIn,\\r\\n        uint reserveOut\\r\\n    ) external pure returns (uint amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint amountOut,\\r\\n        uint reserveIn,\\r\\n        uint reserveOut\\r\\n    ) external pure returns (uint amountIn);\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(\\r\\n        uint amountOut,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract Owner is Context {\\r\\n    address private _owner;\\r\\n    mapping(address => bool) private admin;\\r\\n\\r\\n    constructor() {\\r\\n        _owner = _msgSender();\\r\\n        admin[_msgSender()] = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_msgSender() == _owner);\\r\\n        _;\\r\\n    }\\r\\n    modifier Admin() {\\r\\n        require(admin[_msgSender()]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function isAdmin(address account) public view returns (bool) {\\r\\n        return admin[account];\\r\\n    }\\r\\n\\r\\n    function changgeOwner(address _newOwner) external onlyOwner returns (bool) {\\r\\n        require(_newOwner != address(0));\\r\\n        _owner = _newOwner;\\r\\n        admin[_owner] = false;\\r\\n        admin[_newOwner] = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function changgeAdmin(\\r\\n        address account,\\r\\n        bool status\\r\\n    ) external onlyOwner returns (bool) {\\r\\n        admin[account] = status;\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ERC20 is Owner, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) internal _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_, uint total_Supply) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _totalSupply = total_Supply * 1 ether;\\r\\n        _balances[tx.origin] = total_Supply * 1 ether;\\r\\n        emit Transfer(address(0), tx.origin, total_Supply * 1 ether);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the default value returned by this function, unless\\r\\n     * it's overridden.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(\\r\\n        address account\\r\\n    ) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint256 addedValue\\r\\n    ) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint256 subtractedValue\\r\\n    ) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(\\r\\n            currentAllowance >= subtractedValue,\\r\\n            \\\"ERC20: decreased allowance below zero\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(\\r\\n            fromBalance >= amount,\\r\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(\\r\\n                currentAllowance >= amount,\\r\\n                \\\"ERC20: insufficient allowance\\\"\\r\\n            );\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\ninterface IProject {\\r\\n    function oOAddPower(address account, uint amount) external;\\r\\n\\r\\n    function oOAddNFT(address account, uint _type) external;\\r\\n}\\r\\n\\r\\ninterface ISTV is IERC20 {\\r\\n    function FreeDomStart() external;\\r\\n\\r\\n    function userHoldNFT(address account, uint _type) external;\\r\\n\\r\\n    function getOnePercent() external returns (uint);\\r\\n}\\r\\n\\r\\ninterface IPancakePair {\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\ncontract STVTOKEN is ERC20 {\\r\\n    bool public Freedom;\\r\\n    //Maximum single purchase\\r\\n    uint private immutable OneBuyMax;\\r\\n    //\\r\\n    uint public totalCommission;\\r\\n\\r\\n    address private immutable _adrUSDT;\\r\\n    address private immutable _adrSTV;\\r\\n    //\\r\\n    //address private immutable _adrBurn;\\r\\n    //Fee collection address|\\r\\n    address private immutable _adrFee;\\r\\n    //Trading pair|\\r\\n    address private immutable _adrPair;\\r\\n    address private immutable _adrRouter;\\r\\n\\r\\n    //Whitelist for initial liquidity provider addresses\\r\\n    mapping(address => bool) public WhiteList;\\r\\n    //Staking contract\\r\\n    IProject public stakeCon;\\r\\n\\r\\n    uint public poolBurnAmount;\\r\\n\\r\\n    mapping(address => uint) public HaveNFT;\\r\\n\\r\\n    mapping(address => uint) public CanBuyAmount;\\r\\n\\r\\n    mapping(address => uint) public UserBuyNow;\\r\\n    //Start time for trading \u5f00\u59cb\u4ea4\u6613\u7684\u65f6\u95f4\\r\\n    uint private immutable MarketTime;\\r\\n\\r\\n    uint public platinumNow;\\r\\n\\r\\n    uint public ToolsAllocation;\\r\\n\\r\\n    uint public BurnPercent = 100;\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    // IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E25602);\\r\\n    IPancakePair private immutable Pair;\\r\\n\\r\\n    constructor(\\r\\n        address _USDT,\\r\\n        address _router,\\r\\n        address adrFee,\\r\\n        uint _MarketTime\\r\\n    ) ERC20(\\\"Trust\\\", \\\"STV\\\", 10000000) {\\r\\n        MarketTime = _MarketTime;\\r\\n        _adrUSDT = _USDT;\\r\\n        _adrSTV = address(this);\\r\\n        _adrFee = adrFee;\\r\\n        _adrRouter = _router;\\r\\n        uniswapV2Router = IUniswapV2Router02(_router);\\r\\n        _adrPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\r\\n            address(this),\\r\\n            _USDT\\r\\n        );\\r\\n\\r\\n        Pair = IPancakePair(_adrPair);\\r\\n        OneBuyMax = 2000 ether;\\r\\n        WhiteList[tx.origin] = true;\\r\\n        WhiteList[address(0)] = true;\\r\\n        WhiteList[_adrFee] = true;\\r\\n        WhiteList[address(this)] = true;\\r\\n        //WhiteList[address(Seller)] = true;\\r\\n    }\\r\\n\\r\\n    event logaddress(address a);\\r\\n    bool private ReentrantIng = true;\\r\\n    modifier NotReentrant() {\\r\\n        require(ReentrantIng);\\r\\n        ReentrantIng = false;\\r\\n        _;\\r\\n        ReentrantIng = true;\\r\\n    }\\r\\n\\r\\n    //1% is burned from the pool and sent to the staking contract\\r\\n    function getOnePercent() external NotReentrant returns (uint) {\\r\\n        require(\\r\\n            address(stakeCon) != address(0) && msg.sender == address(stakeCon)\\r\\n        );\\r\\n        //if balanceOf == 10000\\r\\n        // 10000/100 = 100; --> 1%\\r\\n        uint balSTV = balanceOf(address(_adrPair)) / 100;\\r\\n\\r\\n        uint burnAmount = (balSTV * BurnPercent) / 1000;\\r\\n        _burn(_adrPair, balSTV);\\r\\n        _burn(_adrPair, burnAmount);\\r\\n        ToolsAllocation += balSTV;\\r\\n        poolBurnAmount += burnAmount;\\r\\n        Pair.sync();\\r\\n        _mint(address(stakeCon), balSTV);\\r\\n\\r\\n        return balSTV;\\r\\n    }\\r\\n\\r\\n    function changgePercent(uint p) external Admin {\\r\\n        require(p >= 100 && p <= 1000, \\\"0.1% - 1%\\\");\\r\\n        BurnPercent = p;\\r\\n    }\\r\\n\\r\\n    function _takeTaxFee(\\r\\n        address sender,\\r\\n        uint256 fee,\\r\\n        uint256 tAmount\\r\\n    ) private returns (uint256 amountAfter) {\\r\\n        if (tAmount == 0 || fee == 0) return tAmount;\\r\\n\\r\\n        uint256 feeAmount = (tAmount * fee) / 100;\\r\\n\\r\\n        totalCommission += feeAmount;\\r\\n\\r\\n        amountAfter = tAmount - feeAmount;\\r\\n        _balances[_adrFee] = _balances[_adrFee] + feeAmount;\\r\\n        emit Transfer(sender, _adrFee, feeAmount);\\r\\n    }\\r\\n\\r\\n    function _tokenTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint fee,\\r\\n        uint256 amount,\\r\\n        bool takeFee\\r\\n    ) private {\\r\\n        _balances[sender] = _balances[sender] - amount;\\r\\n\\r\\n        if (takeFee) {\\r\\n            uint256 amountAfter = _takeTaxFee(recipient, fee, amount);\\r\\n            _balances[recipient] = _balances[recipient] + amountAfter;\\r\\n            emit Transfer(sender, recipient, amountAfter);\\r\\n        } else {\\r\\n            _balances[recipient] = _balances[recipient] + amount;\\r\\n            emit Transfer(sender, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //This is the sell coin condition.\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        uint256 fromBalance = _balances[from];\\r\\n\\r\\n        require(\\r\\n            fromBalance >= amount,\\r\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n\\r\\n        bool takeFee = false;\\r\\n\\r\\n        if (!WhiteList[from] && to == _adrPair) {\\r\\n            takeFee = true;\\r\\n        }\\r\\n        _tokenTransfer(from, to, 10, amount, takeFee);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    //Passing the token quantity or its equivalent value in USDT.\\r\\n    function getPrice(uint amount) public view returns (uint) {\\r\\n        uint[] memory result = uniswapV2Router.getAmountsIn(amount, getPath());\\r\\n        return result[0];\\r\\n    }\\r\\n\\r\\n    function getPair() public view returns (address) {\\r\\n        return _adrPair;\\r\\n    }\\r\\n\\r\\n    function getPath() public view returns (address[] memory) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _adrUSDT;\\r\\n        path[1] = _adrSTV;\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    //This is the buying coin scenario.\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual override {\\r\\n        //If not on the whitelist and buying coins on PancakeSwap.\\r\\n        if (!WhiteList[to] && from == _adrPair) {\\r\\n            //If trading is not available.\\r\\n            if (!Freedom) {\\r\\n                //Check if the transaction has started\\r\\n                require(block.timestamp >= MarketTime);\\r\\n\\r\\n                if (HaveNFT[to] == 0) revert(\\\"you must have NFT\\\");\\r\\n\\r\\n                uint buy_usdt = getPrice(amount);\\r\\n                require(buy_usdt <= OneBuyMax, \\\"Cannot exceed 2000USDT\\\");\\r\\n                require(\\r\\n                    UserBuyNow[to] + buy_usdt <= CanBuyAmount[to],\\r\\n                    \\\"Too many buy\\\"\\r\\n                );\\r\\n                UserBuyNow[to] += buy_usdt;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** admin */\\r\\n    function FreeDomStart() external Admin {\\r\\n        Freedom = true;\\r\\n    }\\r\\n\\r\\n    function userHoldNFT(address account, uint _type) external Admin {\\r\\n        require(_type == 1 || _type == 2, \\\"NFT type err\\\");\\r\\n        require(HaveNFT[account] == 0, \\\"have NFT now\\\");\\r\\n        if (_type == 2) {\\r\\n            require(platinumNow < 30, \\\"platinum limit out\\\");\\r\\n            platinumNow++;\\r\\n        }\\r\\n        HaveNFT[account] = _type;\\r\\n        if (_type == 1) {\\r\\n            CanBuyAmount[account] = 2000 ether;\\r\\n        }\\r\\n        if (_type == 2) {\\r\\n            CanBuyAmount[account] = 10000 ether;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setProject(address _con) external Admin returns (bool) {\\r\\n        WhiteList[_con] = true;\\r\\n        stakeCon = IProject(_con);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Project is Owner {\\r\\n    struct UserInfo {\\r\\n        uint total_power;\\r\\n        uint stake_power;\\r\\n        uint stake_STV;\\r\\n        uint nft_type;\\r\\n        uint nft_id;\\r\\n        uint max_canBuy;\\r\\n        uint pending_Bonus;\\r\\n        uint total_bonus;\\r\\n        uint check_time;\\r\\n        uint additionIng;\\r\\n    }\\r\\n    address private immutable _adrUSDT;\\r\\n    address private immutable _adrSTV;\\r\\n    address private immutable _adrRouter;\\r\\n    address private immutable _adrBurn;\\r\\n    address private immutable _adrFee;\\r\\n    address public immutable _adrPair;\\r\\n    IUniswapV2Router02 public immutable uniswapRouter;\\r\\n\\r\\n    IERC20 public immutable USDT;\\r\\n\\r\\n    ISTV public immutable STV;\\r\\n\\r\\n    uint public immutable NFTpirce;\\r\\n\\r\\n    //The time when minting is possible.\\r\\n    uint private immutable MintTime;\\r\\n\\r\\n    //Maximum quantity of platinum.\\r\\n    uint private immutable MAXPlatinum;\\r\\n\\r\\n    uint public platinumNow;\\r\\n\\r\\n    uint public MaxTotalNFT;\\r\\n\\r\\n    //Number of current NFTs\\r\\n    uint public totalNFT;\\r\\n    //\\r\\n    //The sum of 20% fees from the total amount withdrawn from the pool, which is 1% of the total daily withdrawal.\\r\\n    uint public FundFees;\\r\\n    /**fee config */\\r\\n    uint private immutable PERCENTS_DIVIDER = 1000;\\r\\n    uint private immutable FEE = 100;\\r\\n\\r\\n    /** Settlement area*/\\r\\n\\r\\n    //Is mining enabled?\\r\\n    bool public mining;\\r\\n\\r\\n    /**\\r\\n    Number of participants with valid staking.\\r\\n    Individuals with both NFTs and computing power. */\\r\\n    uint public miningPeople;\\r\\n\\r\\n    //Mining starts at 12:00 PM (noon) each day.\\r\\n    uint public systemTime;\\r\\n\\r\\n    //Until which day does the system settle?\\r\\n    uint public day_last;\\r\\n\\r\\n    /**Daily allocation data */\\r\\n    mapping(uint => uint) public EveryBonus;\\r\\n    mapping(uint => uint) public EveryPower;\\r\\n\\r\\n    mapping(address => UserInfo) public UserInfos;\\r\\n\\r\\n    //Total network computing power\\r\\n    uint public total_power;\\r\\n\\r\\n    address[] public CEOWallet;\\r\\n\\r\\n    /**for UI\\r\\n     *\\r\\n     * The following are all for UI usage.\\r\\n     */\\r\\n    struct Finance {\\r\\n        address account;\\r\\n        uint timestamp;\\r\\n        uint amount;\\r\\n        uint tokenPrice;\\r\\n    }\\r\\n    struct withdrawInfo {\\r\\n        uint timestamp;\\r\\n        uint amount;\\r\\n    }\\r\\n    struct Blacklist {\\r\\n        address account;\\r\\n        uint tokenAmount;\\r\\n        uint power;\\r\\n        uint nft_type;\\r\\n    }\\r\\n    Finance[] private StakeInfo;\\r\\n    Finance[] private UnStakeInfo;\\r\\n    Finance[] private MintInfo;\\r\\n    Blacklist[] private Blacklists;\\r\\n    mapping(address => uint[]) private BlacklistIndex;\\r\\n    mapping(address => withdrawInfo[]) private WithdrawInfos;\\r\\n\\r\\n    constructor(\\r\\n        address _usdt,\\r\\n        address _stv,\\r\\n        address _pair,\\r\\n        address _router,\\r\\n        address _burn,\\r\\n        address _fee,\\r\\n        address[] memory ceoWallet,\\r\\n        uint _MintTime\\r\\n    ) {\\r\\n        //systemTime = (block.timestamp / 1 days) * 1 days;\\r\\n        _adrUSDT = _usdt;\\r\\n        _adrSTV = _stv;\\r\\n        _adrPair = _pair;\\r\\n        _adrRouter = _router;\\r\\n        _adrBurn = _burn;\\r\\n        _adrFee = _fee;\\r\\n        CEOWallet = ceoWallet;\\r\\n        MintTime = _MintTime;\\r\\n        MAXPlatinum = 30;\\r\\n        uniswapRouter = IUniswapV2Router02(_router);\\r\\n        USDT = IERC20(_usdt);\\r\\n        STV = ISTV(_stv);\\r\\n        NFTpirce = 2000 ether;\\r\\n        MaxTotalNFT = 10000;\\r\\n    }\\r\\n\\r\\n    //Simple prevention of reentrancy attacks.\\r\\n    bool private ReentrantIng = true;\\r\\n    modifier NotReentrant() {\\r\\n        require(ReentrantIng);\\r\\n        ReentrantIng = false;\\r\\n        _;\\r\\n        ReentrantIng = true;\\r\\n    }\\r\\n\\r\\n    modifier MySelf() {\\r\\n        require(tx.origin == _msgSender(), \\\"i love you,don't hurt me\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function mintNFT() external MySelf NotReentrant {\\r\\n        require(block.timestamp >= MintTime);\\r\\n        UserInfo storage user = UserInfos[_msgSender()];\\r\\n        require(user.nft_type == 0, \\\"you have NFT now\\\");\\r\\n        require(totalNFT < MaxTotalNFT, \\\"NFT to many\\\");\\r\\n\\r\\n        USDT.transferFrom(_msgSender(), address(this), NFTpirce);\\r\\n        USDT.approve(_adrRouter, NFTpirce);\\r\\n        uint deadline = block.timestamp + 15;\\r\\n\\r\\n        uint[] memory result = uniswapRouter.swapExactTokensForTokens(\\r\\n            NFTpirce,\\r\\n            0,\\r\\n            getPath(), //USDT->STV\\r\\n            address(this),\\r\\n            deadline\\r\\n        );\\r\\n\\r\\n        STV.transfer(_adrBurn, result[1]);\\r\\n        totalNFT++;\\r\\n        user.nft_type = 1;\\r\\n        user.nft_id = totalNFT;\\r\\n        user.check_time = day_last;\\r\\n        MintInfo.push(\\r\\n            Finance(msg.sender, block.timestamp, result[1], result[1] / 2000)\\r\\n        );\\r\\n        STV.userHoldNFT(msg.sender, 1);\\r\\n    }\\r\\n\\r\\n    function stake(uint amount) external MySelf NotReentrant {\\r\\n        UserInfo storage user = UserInfos[_msgSender()];\\r\\n        require(user.nft_type > 0, \\\"you must have NFT\\\");\\r\\n        require(amount >= 1e17, \\\"amount > 0.1 STV\\\");\\r\\n        STV.transferFrom(_msgSender(), address(this), amount);\\r\\n        uint price = getPrice(1 ether);\\r\\n        uint _power = (amount * price) / 1 ether;\\r\\n\\r\\n        uint beforPower = user.total_power;\\r\\n\\r\\n        //If settlement is possible, settle the earnings first to prevent later energy updates from affecting the earnings count.\\r\\n\\r\\n        if (day_last > user.check_time + 1) {\\r\\n            uint bonus = getUserDividends(_msgSender());\\r\\n            user.pending_Bonus += bonus;\\r\\n            user.check_time = day_last - 1;\\r\\n        }\\r\\n        user.stake_power += _power;\\r\\n        user.stake_STV += amount;\\r\\n        StakeInfo.push(Finance(_msgSender(), block.timestamp, amount, price));\\r\\n\\r\\n        uint additonPower = 0;\\r\\n\\r\\n        if (user.nft_type == 1 && user.stake_power > 0) {\\r\\n            additonPower = 2000 ether;\\r\\n        }\\r\\n\\r\\n        if (user.nft_type == 2 && user.stake_power > 10000 ether) {\\r\\n            additonPower = 50000 ether;\\r\\n        }\\r\\n\\r\\n        uint additionIng = additonPower > 0 ? 1 : 0;\\r\\n\\r\\n        if (user.additionIng == 0 && additionIng == 1) {\\r\\n            user.additionIng = 1;\\r\\n            miningPeople++;\\r\\n\\r\\n            if (!mining && miningPeople >= 500) {\\r\\n                systemTime = (block.timestamp / 1 days) * 1 days;\\r\\n                STV.FreeDomStart();\\r\\n                mining = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        user.total_power = user.stake_power + additonPower;\\r\\n\\r\\n        uint difference = user.total_power - beforPower;\\r\\n\\r\\n        total_power += difference;\\r\\n    }\\r\\n\\r\\n    function unStake(uint amount) external MySelf NotReentrant {\\r\\n        UserInfo storage user = UserInfos[_msgSender()];\\r\\n        require(\\r\\n            amount > 1 ether && user.stake_STV >= amount,\\r\\n            \\\"unStake amount err\\\"\\r\\n        );\\r\\n\\r\\n        uint beforPower = user.total_power;\\r\\n\\r\\n        //If settlement is possible, settle the earnings first to prevent later energy updates from affecting the earnings count.\\r\\n\\r\\n        if (day_last > user.check_time + 1) {\\r\\n            uint bonus = getUserDividends(_msgSender());\\r\\n            user.pending_Bonus += bonus;\\r\\n            user.check_time = day_last - 1;\\r\\n        }\\r\\n\\r\\n        uint price = getPrice(1 ether);\\r\\n        uint _power = (amount * price) / 1 ether;\\r\\n\\r\\n        //Insufficient energy, counted as 1.\\r\\n        if (_power < 1 ether) _power = 1 ether;\\r\\n\\r\\n        user.stake_power = subOverflow(user.stake_power, _power);\\r\\n        user.stake_STV -= amount;\\r\\n        uint fee = (amount * FEE) / PERCENTS_DIVIDER;\\r\\n        STV.transfer(_adrFee, fee);\\r\\n        STV.transfer(_msgSender(), amount - fee);\\r\\n        UnStakeInfo.push(Finance(_msgSender(), block.timestamp, amount, price));\\r\\n\\r\\n        uint additonPower = 0;\\r\\n\\r\\n        if (user.nft_type == 1 && user.stake_power > 0) {\\r\\n            additonPower = 2000 ether;\\r\\n        }\\r\\n\\r\\n        if (user.nft_type == 2 && user.stake_power > 10000 ether) {\\r\\n            additonPower = 50000 ether;\\r\\n        }\\r\\n\\r\\n        uint additionIng = additonPower > 0 ? 1 : 0;\\r\\n\\r\\n        if (user.additionIng == 1 && additionIng == 0) {\\r\\n            user.additionIng = 0;\\r\\n            miningPeople--;\\r\\n        }\\r\\n\\r\\n        user.total_power = user.stake_power + additonPower;\\r\\n\\r\\n        uint difference = beforPower - user.total_power;\\r\\n\\r\\n        total_power -= difference;\\r\\n    }\\r\\n\\r\\n    function _settlement() public {\\r\\n        require(mining, \\\"not mining\\\");\\r\\n        uint dayNow = _culDay();\\r\\n        uint totalfee = 0;\\r\\n        for (; day_last < dayNow; day_last++) {\\r\\n            if (mining) {\\r\\n                uint balSTV = STV.getOnePercent();\\r\\n                uint fee = (balSTV * 20) / 100;\\r\\n                EveryBonus[day_last] = balSTV - fee;\\r\\n                EveryPower[day_last] = total_power;\\r\\n                totalfee += fee;\\r\\n            }\\r\\n        }\\r\\n        if (totalfee > 0) {\\r\\n            FundFees += totalfee;\\r\\n            totalfee = totalfee / 4;\\r\\n            for (uint a = 0; a < 4; a++) {\\r\\n                STV.transfer(CEOWallet[a], totalfee);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw() external MySelf NotReentrant {\\r\\n        UserInfo storage user = UserInfos[_msgSender()];\\r\\n        uint check_time = user.check_time;\\r\\n        uint withdrawAmount = user.pending_Bonus;\\r\\n        if (day_last > check_time + 1) {\\r\\n            uint bonus = getUserDividends(_msgSender());\\r\\n            withdrawAmount += bonus;\\r\\n            user.check_time = day_last - 1;\\r\\n        }\\r\\n        user.total_bonus += withdrawAmount;\\r\\n        user.pending_Bonus = 0;\\r\\n        //for UI\\r\\n        if (withdrawAmount > 0) {\\r\\n            WithdrawInfos[_msgSender()].push(\\r\\n                withdrawInfo(block.timestamp, withdrawAmount)\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint stvbal = STV.balanceOf(address(this));\\r\\n        if (withdrawAmount > stvbal) {\\r\\n            withdrawAmount = stvbal;\\r\\n        }\\r\\n\\r\\n        STV.transfer(_msgSender(), withdrawAmount);\\r\\n    }\\r\\n\\r\\n    /**utils */\\r\\n\\r\\n    function getUserDividends(address account) public view returns (uint) {\\r\\n        if (day_last <= 1) return 0;\\r\\n        UserInfo memory user = UserInfos[account];\\r\\n        uint toal_amount = 0;\\r\\n        uint check_time = user.check_time;\\r\\n        uint _power = user.total_power;\\r\\n\\r\\n        uint _Daylast = day_last - 1;\\r\\n        for (uint a = check_time; a < _Daylast; a++) {\\r\\n            uint dayBonus = EveryBonus[check_time];\\r\\n            uint dayPower = EveryPower[check_time];\\r\\n            if (dayBonus != 0 && dayPower != 0) {\\r\\n                uint userBonus = (dayBonus * _power) / dayPower;\\r\\n                toal_amount += userBonus;\\r\\n            }\\r\\n            check_time++;\\r\\n        }\\r\\n\\r\\n        return toal_amount;\\r\\n    }\\r\\n\\r\\n    function getPrice(uint amount) public view returns (uint) {\\r\\n        uint[] memory result = uniswapRouter.getAmountsIn(amount, getPath());\\r\\n        return result[0];\\r\\n    }\\r\\n\\r\\n    //\\r\\n    function subOverflow(uint a, uint b) public pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        return a < b ? 0 : a - b;\\r\\n    }\\r\\n\\r\\n    function getPath() public view returns (address[] memory) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _adrUSDT;\\r\\n        path[1] = _adrSTV;\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    //\\r\\n    function _addNFT(address account, uint _type) private {\\r\\n        UserInfos[account].nft_type = _type;\\r\\n        totalNFT++;\\r\\n        UserInfos[account].nft_id = totalNFT;\\r\\n        UserInfos[account].check_time = day_last;\\r\\n        STV.userHoldNFT(account, _type);\\r\\n    }\\r\\n\\r\\n    /**for TEST */\\r\\n    // uint private TEST_DAY;\\r\\n\\r\\n    // event logNumber(uint _c);\\r\\n    // event logAddress(address _c);\\r\\n\\r\\n    function _culDay() public view returns (uint) {\\r\\n        if (systemTime == 0) return 0;\\r\\n        return (block.timestamp - systemTime) / 1 days; // + TEST_DAY;\\r\\n    }\\r\\n\\r\\n    // function TEST_addDay() external {\\r\\n    //     TEST_DAY++;\\r\\n    // }\\r\\n\\r\\n    /**TEST functions END */\\r\\n\\r\\n    /** for Admin  */\\r\\n    function oOAddNFT(address account, uint _type) external Admin {\\r\\n        require(_type == 1 || _type == 2, \\\"type is 1 or 2\\\");\\r\\n        require(UserInfos[account].nft_type == 0, \\\"user must not have ntf\\\");\\r\\n        require(totalNFT < MaxTotalNFT, \\\"NFT to many\\\");\\r\\n        if (_type == 2) {\\r\\n            require(platinumNow < MAXPlatinum);\\r\\n            platinumNow++;\\r\\n        }\\r\\n        _addNFT(account, _type);\\r\\n    }\\r\\n\\r\\n    //Enable transactions to avoid a continuous failure to reach 500 valid addresses.\\r\\n    function oOstartMining() external Admin {\\r\\n        if (systemTime == 0) {\\r\\n            // for china time 00:00\\r\\n            systemTime = (block.timestamp / 1 days) * 1 days - 28800;\\r\\n        }\\r\\n        mining = true;\\r\\n        STV.FreeDomStart();\\r\\n    }\\r\\n\\r\\n    function AddNFTAmount(uint amount) external Admin {\\r\\n        MaxTotalNFT += amount;\\r\\n    }\\r\\n\\r\\n    function oOAddPower(address account, uint amount) external Admin {\\r\\n        UserInfos[account].total_power += amount;\\r\\n        total_power += amount;\\r\\n    }\\r\\n\\r\\n    function oORefresh(address[] calldata account_list) external Admin {\\r\\n        uint num = account_list.length;\\r\\n        uint _total_power = 0;\\r\\n        uint yesterday = day_last - 1;\\r\\n        for (uint a = 0; a < num; a++) {\\r\\n            UserInfo storage user = UserInfos[account_list[a]];\\r\\n            Blacklist memory info = Blacklist(\\r\\n                account_list[a],\\r\\n                user.stake_STV,\\r\\n                user.total_power,\\r\\n                user.nft_type\\r\\n            );\\r\\n            Blacklists.push(info);\\r\\n            BlacklistIndex[account_list[a]].push(Blacklists.length - 1);\\r\\n            _total_power += user.total_power;\\r\\n            user.total_power = 0;\\r\\n            user.stake_power = 0;\\r\\n        }\\r\\n        total_power = subOverflow(total_power, _total_power);\\r\\n        uint yserterday_power = EveryPower[yesterday];\\r\\n        EveryPower[yesterday] = subOverflow(yserterday_power, _total_power);\\r\\n    }\\r\\n\\r\\n    /**for UI */\\r\\n\\r\\n    function selectContract() public view returns (uint[] memory) {\\r\\n        uint[] memory number = new uint[](9);\\r\\n        number[0] = MintTime;\\r\\n        number[1] = platinumNow;\\r\\n        number[2] = MaxTotalNFT;\\r\\n        number[3] = totalNFT;\\r\\n        number[4] = FundFees;\\r\\n        number[5] = miningPeople;\\r\\n        number[6] = systemTime;\\r\\n        number[7] = day_last;\\r\\n        number[8] = total_power;\\r\\n        return number;\\r\\n    }\\r\\n\\r\\n    function oOBlacklistUser(\\r\\n        address account\\r\\n    ) public view returns (Blacklist[] memory) {\\r\\n        uint[] memory num = BlacklistIndex[account];\\r\\n        Blacklist[] memory list = new Blacklist[](num.length);\\r\\n        for (uint a = 0; a < num.length - 1; a++) {\\r\\n            list[a] = Blacklists[num[a]];\\r\\n        }\\r\\n        return list;\\r\\n    }\\r\\n\\r\\n    function oOgetBlacklist(\\r\\n        uint start,\\r\\n        uint end\\r\\n    ) public view returns (Blacklist[] memory, uint total) {\\r\\n        uint limit = end - start;\\r\\n        Blacklist[] memory list = new Blacklist[](limit);\\r\\n        for (uint a = 0; a <= limit; a++) {\\r\\n            list[a] = Blacklists[start + a];\\r\\n        }\\r\\n        return (list, Blacklists.length);\\r\\n    }\\r\\n\\r\\n    function getTotalLength() public view returns (uint[] memory) {\\r\\n        uint[] memory result = new uint[](5);\\r\\n        result[1] = StakeInfo.length;\\r\\n        result[2] = UnStakeInfo.length;\\r\\n        result[3] = MintInfo.length;\\r\\n        result[4] = Blacklists.length;\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function WithdrawInfo(\\r\\n        address account\\r\\n    ) public view returns (withdrawInfo[] memory) {\\r\\n        return WithdrawInfos[account];\\r\\n    }\\r\\n\\r\\n    function oOgetFinanceInfo(\\r\\n        uint page,\\r\\n        uint limit,\\r\\n        uint _type\\r\\n    ) public view returns (Finance[] memory, uint) {\\r\\n        uint total = 0;\\r\\n        uint skip = page * limit;\\r\\n        Finance[] memory list = new Finance[](limit + 1);\\r\\n        for (uint a = 0; a < limit; a++) {\\r\\n            //StakeInfo =1  UnStakeInfo=2 MintInfo=3\\r\\n            if (_type == 1) {\\r\\n                list[a] = StakeInfo[skip + a];\\r\\n            } else if (_type == 2) {\\r\\n                list[a] = UnStakeInfo[skip + a];\\r\\n            } else if (_type == 3) {\\r\\n                list[a] = MintInfo[skip + a];\\r\\n            }\\r\\n        }\\r\\n        if (_type == 1) total = StakeInfo.length;\\r\\n        if (_type == 2) total = UnStakeInfo.length;\\r\\n        if (_type == 3) total = MintInfo.length;\\r\\n\\r\\n        return (list, total);\\r\\n    }\\r\\n\\r\\n    function oOgetFinanceInfo2(\\r\\n        uint start,\\r\\n        uint end,\\r\\n        uint _type\\r\\n    ) public view returns (Finance[] memory, uint) {\\r\\n        uint limit = end - start;\\r\\n        uint total = 0;\\r\\n        Finance[] memory list = new Finance[](limit + 1);\\r\\n        for (uint a = 0; a <= limit; a++) {\\r\\n            //StakeInfo =1  UnStakeInfo=2 MintInfo=3\\r\\n            if (_type == 1) {\\r\\n                list[a] = StakeInfo[start + a];\\r\\n            } else if (_type == 2) {\\r\\n                list[a] = UnStakeInfo[start + a];\\r\\n            } else if (_type == 3) {\\r\\n                list[a] = MintInfo[start + a];\\r\\n            }\\r\\n        }\\r\\n        if (_type == 1) total = StakeInfo.length;\\r\\n        if (_type == 2) total = UnStakeInfo.length;\\r\\n        if (_type == 3) total = MintInfo.length;\\r\\n\\r\\n        return (list, total);\\r\\n    }\\r\\n\\r\\n    function getDay(\\r\\n        uint[] calldata timestamps\\r\\n    ) public view returns (uint[] memory) {\\r\\n        uint length = timestamps.length;\\r\\n        uint[] memory res = new uint[](length);\\r\\n        for (uint a = 0; a < length; a++) {\\r\\n            res[a] = ((timestamps[a] - systemTime) / 1 days) * 1 days;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract SetAddress {\\r\\n    IProject private immutable _con;\\r\\n    address private immutable _owner;\\r\\n\\r\\n    constructor(address project_con) {\\r\\n        _owner = tx.origin;\\r\\n        _con = IProject(project_con);\\r\\n    }\\r\\n\\r\\n    function wnlcwnebh(address[] calldata list, uint _type) external {\\r\\n        require(msg.sender == _owner, \\\"you not owner\\\");\\r\\n        for (uint a = 0; a < list.length; a++) {\\r\\n            _con.oOAddNFT(list[a], _type);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Tools {\\r\\n    STVTOKEN public T_stv;\\r\\n    Project public T_project;\\r\\n    SetAddress public T_SetAddress;\\r\\n    //startTime\\r\\n    uint public market_time = 1694080800;\\r\\n    //USDT\\r\\n    address public usdt = 0x55d398326f99059fF775485246999027B3197955;\\r\\n    //pancake test\\r\\n    //address public factory = 0x6725F303b657a9451d8BA641348b6761A6CC7a17;\\r\\n    //pancake factory main\\r\\n    address public factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\\r\\n    //pancake router testnet\\r\\n    //address public _router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\r\\n    //pancake router main\\r\\n    address public _router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n\\r\\n    address public adrBurn = 0x60a0fC814394a90c7176850471c72A5F05A7A9D7;\\r\\n\\r\\n    address public adrFee = 0x95A7d77Ad08C33e256E2Ae2dd70D7F70aD91ca27;\\r\\n\\r\\n    address[] public _CEOWallet = [\\r\\n        0x2A7a670A64235dfEE81755777B62eeb65c232E36,\\r\\n        0x3a32719130c982a38343D528831752f619D6fc79,\\r\\n        0x6F0C626013F572Dd3dD77c27d0f655712878D0cB,\\r\\n        0x4d3aF729244575C2521c461224aE845aFD67069f\\r\\n    ];\\r\\n\\r\\n    event log(address _logSTV, address _logProject, address _logsetContract);\\r\\n    event logBool(bool b0, bool b1, bool b2, bool b3, bool b4, bool b5);\\r\\n\\r\\n    constructor() {\\r\\n        T_stv = new STVTOKEN(usdt, _router, adrFee, market_time);\\r\\n        address pair = T_stv.getPair();\\r\\n        T_project = new Project(\\r\\n            usdt,\\r\\n            address(T_stv),\\r\\n            pair,\\r\\n            _router,\\r\\n            adrBurn,\\r\\n            adrFee,\\r\\n            _CEOWallet,\\r\\n            market_time + 10 //+10s\\r\\n        );\\r\\n        T_SetAddress = new SetAddress(address(T_project));\\r\\n\\r\\n        bool b0 = T_stv.setProject(address(T_project));\\r\\n        bool b1 = T_stv.changgeAdmin(address(T_project), true);\\r\\n        bool b2 = T_project.changgeAdmin(address(T_stv), true);\\r\\n        bool b3 = T_project.changgeAdmin(address(T_SetAddress), true);\\r\\n        bool b4 = T_stv.changgeOwner(msg.sender);\\r\\n        bool b5 = T_project.changgeOwner(msg.sender);\\r\\n        emit logBool(b0, b1, b2, b3, b4, b5);\\r\\n        emit log(address(T_stv), address(T_project), address(T_SetAddress));\\r\\n        selfdestruct(payable(msg.sender));\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adrFee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_MarketTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"logaddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BurnPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"CanBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FreeDomStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Freedom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"HaveNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ToolsAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserBuyNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"WhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changgeAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changgeOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"changgePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOnePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platinumNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBurnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_con\",\"type\":\"address\"}],\"name\":\"setProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeCon\",\"outputs\":[{\"internalType\":\"contract IProject\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"userHoldNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "STVTOKEN", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e00000000000000000000000095a7d77ad08c33e256e2ae2dd70d7f70ad91ca270000000000000000000000000000000000000000000000000000000064f99f20", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}