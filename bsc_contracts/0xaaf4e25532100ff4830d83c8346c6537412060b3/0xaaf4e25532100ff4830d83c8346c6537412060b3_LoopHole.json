{"SourceCode": "/*\r\n * https://t.me/loopholebsc\r\n *\r\n * Written by: MrGreenCrypto\r\n * Co-Founder of CodeCraftrs.com\r\n * \r\n * SPDX-License-Identifier: None\r\n */\r\npragma solidity 0.8.17;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {function createPair(address tokenA, address tokenB) external returns (address pair);}\r\ninterface IDEXPair {function sync() external;}\r\ninterface IHelper {function giveMeMyMoneyBack(address currency) external returns (bool);}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);    \r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n}\r\n\r\ncontract LoopHole is IBEP20 {\r\n    string private _name = \"LoopHole\";\r\n    string private _symbol = \"LOOPHOLE\";\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 1 * (10**_decimals);\r\n\r\n    address public constant CEO = 0x95faa34cB204748F455056Ef4Ac845F25961dCcC;\r\n    address private constant rewardAddress = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\r\n    IBEP20 public constant rewardToken = IBEP20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public limitless;\r\n    mapping(address => bool) public isExludedFromMaxWallet;\r\n\r\n    uint256 public tax = 7;\r\n    uint256 public rewards = 3;\r\n    uint256 public liq = 1;\r\n    uint256 public dev = 1;\r\n    uint256 public noneOfYourBusiness = 1;\r\n    uint256 public jackpot = 1;\r\n    uint256 public jackpotBalance;\r\n    uint256 public buyCounter;\r\n    uint256 public enough = 42069696969690;\r\n    uint256 private swapAt = _totalSupply / 10_000;\r\n    uint256 public maxWalletInPermille = 5;\r\n    uint256 private maxTx = 50;\r\n\r\n    IDEXRouter public constant ROUTER = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    IHelper private constant helper = IHelper(0xd85FbeFc217ce783A54bC25A0Aea971F0B1d7D5b);\r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    address public immutable pcsPair;\r\n    \r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised; \r\n    }\r\n\r\n    mapping (address => uint256) public shareholderIndexes;\r\n    mapping (address => uint256) public lastClaim;\r\n    mapping (address => Share) public shares;\r\n    mapping (address => bool) public addressNotGettingRewards;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDistributed;\r\n    uint256 public rewardsPerShare;\r\n    uint256 private veryLargeNumber = 10 ** 36;\r\n    uint256 private rewardTokenBalanceBefore;\r\n\r\n    uint256 public minTokensForRewards;\r\n    address[] private shareholders;\r\n    \r\n    modifier onlyCEO(){\r\n        require (msg.sender == CEO, \"Only the CEO can do that\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        pcsPair = IDEXFactory(IDEXRouter(ROUTER).factory()).createPair(rewardAddress, address(this));\r\n        _allowances[address(this)][address(ROUTER)] = type(uint256).max;\r\n\r\n        isExludedFromMaxWallet[pcsPair] = true;\r\n        isExludedFromMaxWallet[address(this)] = true;\r\n\r\n        addressNotGettingRewards[pcsPair] = true;\r\n        addressNotGettingRewards[address(this)] = true;\r\n\r\n        limitless[CEO] = true;\r\n        limitless[address(this)] = true;\r\n\r\n        _balances[address(this)] = _totalSupply;\r\n        emit Transfer(address(0), address(this), _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n    function name() public view override returns (string memory) {return _name;}\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply - _balances[DEAD];}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function symbol() public view override returns (string memory) {return _symbol;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    \r\n    function allowance(address holder, address spender) public view override returns (uint256) {return _allowances[holder][spender];}\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {return _transferFrom(msg.sender, recipient, amount);}\r\n    function approveMax(address spender) external returns (bool) {return approve(spender, type(uint256).max);}\r\n    \r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) + addedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        require(allowance(msg.sender, spender) >= subtractedValue, \"Can't subtract more than current allowance\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) - subtractedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n            emit Approval(sender, msg.sender, _allowances[sender][msg.sender]);\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    bool private launched;\r\n    bool private live;\r\n\r\n    function rescueBeforeLaunch() external onlyCEO {\r\n        require(!launched);\r\n        rewardToken.transfer(CEO, rewardToken.balanceOf(address(this)));\r\n    }\r\n\r\n    function launch() external onlyCEO {\r\n        require(!launched);\r\n        rewardToken.approve(address(ROUTER), type(uint256).max);\r\n        \r\n        ROUTER.addLiquidity(\r\n            address(this),\r\n            rewardAddress,\r\n            _balances[address(this)] / 10,\r\n            rewardToken.balanceOf(address(this)),\r\n            0,\r\n            0,\r\n            CEO,\r\n            block.timestamp\r\n        );\r\n        rewards = 14;\r\n        liq = 7;\r\n        dev = 7;\r\n        noneOfYourBusiness = 7;\r\n        jackpot = 7; \r\n        tax = rewards + liq + dev + noneOfYourBusiness + jackpot;\r\n        launched = true;\r\n    }\r\n\r\n    function thisIsIt() external onlyCEO {\r\n        require(launched && !live);        \r\n        _lowGasTransfer(address(this), pcsPair, _balances[address(this)]);\r\n        IDEXPair(pcsPair).sync();\r\n        rewards = 3;\r\n        liq = 1;\r\n        dev = 1;\r\n        noneOfYourBusiness = 1;\r\n        jackpot = 1; \r\n        tax = rewards + liq + dev + noneOfYourBusiness + jackpot;\r\n        live = true;\r\n    }\r\n\r\n    function setTaxes(uint256 rewardsTax, uint256 liqTax, uint256 devTax, uint256 noneOfYourBusinessTax, uint256 jackpotTax) external onlyCEO {\r\n        rewards = rewardsTax;\r\n        liq = liqTax;\r\n        dev = devTax;\r\n        noneOfYourBusiness = noneOfYourBusinessTax;\r\n        jackpot = jackpotTax; \r\n        tax = rewards + liq + dev + noneOfYourBusiness + jackpot;\r\n        require(tax < 50, \"Tax safety limit\");     \r\n    }\r\n    \r\n    function setMaxWalletInPermille(uint256 permille) external onlyCEO {\r\n        maxWalletInPermille = permille;\r\n        require(maxWalletInPermille >= 5, \"MaxWallet safety limit\");\r\n    }\r\n\r\n    function setMaxTxInPercentOfMaxWallet(uint256 percent) external onlyCEO {\r\n        maxTx = percent;\r\n        require(maxTx >= 50, \"MaxTx safety limit\");\r\n    }\r\n    \r\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyCEO {\r\n        _name = newName;\r\n        _symbol = newSymbol;\r\n    }\r\n\r\n    function setMinBuy(uint256 btcAmount) external onlyCEO {\r\n        enough = btcAmount;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if (limitless[sender] || limitless[recipient]) return _lowGasTransfer(sender, recipient, amount);\r\n        amount = takeTax(sender, recipient, amount);\r\n        _lowGasTransfer(sender, recipient, amount);\r\n        if(!addressNotGettingRewards[sender]) setShare(sender);\r\n        if(!addressNotGettingRewards[recipient]) setShare(recipient);\r\n        return true;\r\n    }\r\n\r\n    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if(!isExludedFromMaxWallet[recipient]) require(_balances[recipient] + amount <= _totalSupply * maxWalletInPermille / 1000, \"MaxWallet\");\r\n        if(!isExludedFromMaxWallet[recipient]) require(amount <= _totalSupply * maxWalletInPermille * maxTx / 1000 / 100, \"MaxTx\");\r\n        \r\n        uint256 totalTax = tax;\r\n        if(totalTax == 0) return amount;\r\n        uint256 taxAmount = amount * totalTax / 100;\r\n        uint256 taxToSwap = amount * (rewards + dev + noneOfYourBusiness) / 100;\r\n        uint256 jackpotTax = amount * jackpot / 100;\r\n        uint256 liqTax = amount * liq / 100;\r\n        if(taxToSwap > 0) _lowGasTransfer(sender, address(this), taxToSwap);\r\n        \r\n        if(jackpotTax > 0) {\r\n            _lowGasTransfer(sender, address(this), jackpotTax);\r\n            jackpotBalance += jackpotTax;\r\n        }\r\n\r\n        if(isPair(sender) && isEnough(amount)) {\r\n            buyCounter++;\r\n            uint256 totalBuys = buyCounter;\r\n            if(totalBuys == 1 || totalBuys == 25 || totalBuys == 50) {\r\n                _lowGasTransfer(address(this), recipient, jackpotBalance);\r\n                jackpotBalance = 0;\r\n                if(totalBuys >= 50) buyCounter = 0;\r\n            }\r\n        }\r\n\r\n        if(liqTax > 0) _lowGasTransfer(sender, pcsPair, liqTax);\r\n        if(!isPair(sender)) {\r\n            swapForRewards();\r\n            IDEXPair(pcsPair).sync();\r\n        }\r\n        return amount - taxAmount;\r\n    }\r\n\r\n    function isEnough(uint256 amount) public view returns (bool isIt) {\r\n        uint256 equivalent = rewardToken.balanceOf(pcsPair) * amount / _balances[pcsPair];\r\n        if(equivalent >= enough) return true;\r\n        return false;\r\n    }\r\n\r\n    function isPair(address check) internal view returns(bool) {\r\n        if(check == pcsPair) return true;\r\n        return false;\r\n    }\r\n\r\n    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0) && recipient != address(0), \"Can't use zero addresses here\");\r\n        require(amount <= _balances[sender], \"Can't transfer more than you own\");\r\n        if(amount == 0) return true;\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function swapForRewards() internal {\r\n        if(_balances[address(this)] - jackpotBalance < swapAt) return;\r\n        rewardTokenBalanceBefore = rewardToken.balanceOf(address(this));\r\n\r\n        address[] memory pathForSelling = new address[](2);\r\n        pathForSelling[0] = address(this);\r\n        pathForSelling[1] = address(rewardToken);\r\n\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            _balances[address(this)] - jackpotBalance,\r\n            0,\r\n            pathForSelling,\r\n            address(helper),\r\n            block.timestamp\r\n        );\r\n        require(helper.giveMeMyMoneyBack(rewardAddress),\"Something went wrong\");\r\n        uint256 newRewardTokenBalance = rewardToken.balanceOf(address(this));\r\n        if(newRewardTokenBalance <= rewardTokenBalanceBefore) return;\r\n        uint256 amount = newRewardTokenBalance - rewardTokenBalanceBefore;\r\n        rewardsPerShare = rewardsPerShare + (veryLargeNumber * amount / totalShares);\r\n    }\r\n\r\n    function setShare(address shareholder) internal {\r\n        if(shares[shareholder].amount >= minTokensForRewards) distributeRewards(shareholder);\r\n        if(shares[shareholder].amount == 0 && _balances[shareholder] >= minTokensForRewards) addShareholder(shareholder);\r\n        \r\n        if(shares[shareholder].amount >= minTokensForRewards && _balances[shareholder] < minTokensForRewards){\r\n            totalShares = totalShares - shares[shareholder].amount;\r\n            shares[shareholder].amount = 0;\r\n            removeShareholder(shareholder);\r\n            return;\r\n        }\r\n\r\n        if(_balances[shareholder] >= minTokensForRewards){\r\n            totalShares = totalShares - shares[shareholder].amount + _balances[shareholder];\r\n            shares[shareholder].amount = _balances[shareholder];\r\n            shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n        }\r\n    }\r\n\r\n    function claimNoSwap() external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewards(msg.sender);}\r\n    function claimBnbPaired(address desiredRewardToken) external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewardsSplit(msg.sender, desiredRewardToken);}\r\n    function claimExpert(address[] memory path) external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewardsExpert(msg.sender, path);}\r\n\r\n    function distributeRewards(address shareholder) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n        rewardToken.transfer(shareholder, amount);\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function distributeRewardsSplit(address shareholder, address userReward) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n\r\n        rewardToken.transfer(shareholder,amount * 2 / 3);\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = rewardAddress;\r\n        path[1] = ROUTER.WETH();\r\n        path[2] = userReward;\r\n\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount / 3,\r\n            0,\r\n            path,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function distributeRewardsExpert(address shareholder, address[] memory userPath) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n\r\n        rewardToken.transfer(shareholder,amount * 2 / 3);\r\n\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount / 3,\r\n            0,\r\n            userPath,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n        \r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        uint256 shareholderTotalRewards = getTotalRewardsOf(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if(shareholderTotalRewards <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalRewards - shareholderTotalExcluded;\r\n    }\r\n\r\n    function getTotalRewardsOf(uint256 share) internal view returns (uint256) {\r\n        return share * rewardsPerShare / veryLargeNumber;\r\n    }\r\n   \r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CEO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressNotGettingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"desiredRewardToken\",\"type\":\"address\"}],\"name\":\"claimBnbPaired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"claimExpert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimNoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enough\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isIt\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExludedFromMaxWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletInPermille\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokensForRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noneOfYourBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pcsPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueBeforeLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxInPercentOfMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"permille\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletInPermille\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"}],\"name\":\"setMinBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"setNameAndSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liqTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noneOfYourBusinessTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jackpotTax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thisIsIt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LoopHole", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9bba356060468b98cb96cedec7c25b5bd86665687e80b9397a70ee1c0b7069a7"}