{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.13;\r\n\r\n/*\r\n * ...\r\n * The spirit of the void is where there is nothing. It is\r\n * not included in man's knowledge. Of course, the void\r\n * does not exist. By knowing things that exist, you can\r\n * know that which does not exist.\r\n * ...\r\n */\r\n\r\ntype CalldataPointer is uint256;\r\ntype ReturndataPointer is uint256;\r\ntype MemoryPointer is uint256;\r\n\r\nusing CalldataPointerLib for CalldataPointer global;\r\nusing MemoryPointerLib for MemoryPointer global;\r\nusing ReturndataPointerLib for ReturndataPointer global;\r\n\r\nusing CalldataReaders for CalldataPointer global;\r\nusing ReturndataReaders for ReturndataPointer global;\r\nusing MemoryReaders for MemoryPointer global;\r\nusing MemoryWriters for MemoryPointer global;\r\n\r\nstruct Schema {\r\n    uint256 id;\r\n    bytes metadata;\r\n}\r\n\r\nusing StructPointers for OrderComponents global;\r\nusing StructPointers for OfferItem global;\r\nusing StructPointers for ConsiderationItem global;\r\nusing StructPointers for SpentItem global;\r\nusing StructPointers for ReceivedItem global;\r\nusing StructPointers for BasicOrderParameters global;\r\nusing StructPointers for AdditionalRecipient global;\r\nusing StructPointers for OrderParameters global;\r\nusing StructPointers for Order global;\r\nusing StructPointers for AdvancedOrder global;\r\nusing StructPointers for OrderStatus global;\r\nusing StructPointers for CriteriaResolver global;\r\nusing StructPointers for Fulfillment global;\r\nusing StructPointers for FulfillmentComponent global;\r\nusing StructPointers for Execution global;\r\nusing StructPointers for ZoneParameters global;\r\n\r\nuint256 constant ThirtyOneBytes = 0x1f;\r\nuint256 constant OneWord = 0x20;\r\nuint256 constant TwoWords = 0x40;\r\nuint256 constant ThreeWords = 0x60;\r\n\r\nuint256 constant OneWordShift = 0x5;\r\nuint256 constant TwoWordsShift = 0x6;\r\n\r\nuint256 constant FreeMemoryPointerSlot = 0x40;\r\nuint256 constant ZeroSlot = 0x60;\r\nuint256 constant DefaultFreeMemoryPointer = 0x80;\r\n\r\nuint256 constant Slot0x80 = 0x80;\r\nuint256 constant Slot0xA0 = 0xa0;\r\nuint256 constant Slot0xC0 = 0xc0;\r\n\r\nuint256 constant Generic_error_selector_offset = 0x1c;\r\n\r\n// abi.encodeWithSignature(\"transferFrom(address,address,uint256)\")\r\nuint256 constant ERC20_transferFrom_signature = (\r\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\r\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\r\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\r\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\r\n\r\n// abi.encodeWithSignature(\r\n//     \"safeTransferFrom(address,address,uint256,uint256,bytes)\"\r\n// )\r\nuint256 constant ERC1155_safeTransferFrom_signature = (\r\n    0xf242432a00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\r\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\r\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\r\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\r\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\r\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\r\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\r\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\r\n\r\n// abi.encodeWithSignature(\r\n//     \"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"\r\n// )\r\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\r\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\n// bytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\r\n//     bytes32(ERC1155_safeBatchTransferFrom_signature)\r\n// );\r\n\r\nuint256 constant ERC721_transferFrom_signature = (\r\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\r\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\r\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\r\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\r\n\r\n/*\r\n *  error NoContract(address account)\r\n *    - Defined in TokenTransferrerErrors.sol\r\n *  Memory layout:\r\n *    - 0x00: Left-padded selector (data begins at 0x1c)\r\n *    - 0x00: account\r\n * Revert buffer is memory[0x1c:0x40]\r\n */\r\nuint256 constant NoContract_error_selector = 0x5f15d672;\r\nuint256 constant NoContract_error_account_ptr = 0x20;\r\nuint256 constant NoContract_error_length = 0x24;\r\n\r\n/*\r\n *  error TokenTransferGenericFailure(\r\n *      address token,\r\n *      address from,\r\n *      address to,\r\n *      uint256 identifier,\r\n *      uint256 amount\r\n *  )\r\n *    - Defined in TokenTransferrerErrors.sol\r\n *  Memory layout:\r\n *    - 0x00: Left-padded selector (data begins at 0x1c)\r\n *    - 0x20: token\r\n *    - 0x40: from\r\n *    - 0x60: to\r\n *    - 0x80: identifier\r\n *    - 0xa0: amount\r\n * Revert buffer is memory[0x1c:0xc0]\r\n */\r\nuint256 constant TokenTransferGenericFailure_error_selector = 0xf486bc87;\r\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x20;\r\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x40;\r\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x60;\r\nuint256 constant TokenTransferGenericFailure_error_identifier_ptr = 0x80;\r\nuint256 constant TokenTransferGenericFailure_err_identifier_ptr = 0x80;\r\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0xa0;\r\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\r\n\r\nuint256 constant ExtraGasBuffer = 0x20;\r\nuint256 constant CostPerWord = 0x3;\r\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\r\n\r\n// Values are offset by 32 bytes in order to write the token to the beginning\r\n// in the event of a revert\r\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\r\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\r\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\r\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\r\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\r\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\r\n\r\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\r\n\r\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\r\n// uint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\r\n// uint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\r\n\r\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\r\n\r\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\r\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\r\n// uint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\r\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\r\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\r\n// uint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\r\n\r\n// Note: abbreviated version of above constant to adhere to line length limit.\r\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\r\n\r\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\r\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\r\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\r\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\r\n    0xafc445e200000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\r\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\r\n\r\n/*\r\n *  error BadReturnValueFromERC20OnTransfer(\r\n *      address token, address from, address to, uint256 amount\r\n *  )\r\n *    - Defined in TokenTransferrerErrors.sol\r\n *  Memory layout:\r\n *    - 0x00: Left-padded selector (data begins at 0x1c)\r\n *    - 0x00: token\r\n *    - 0x20: from\r\n *    - 0x40: to\r\n *    - 0x60: amount\r\n * Revert buffer is memory[0x1c:0xa0]\r\n */\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_selector = 0x98891923;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x20;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x40;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x60;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x80;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\r\n\r\n\r\nuint256 constant Error_selector_offset = 0x1c;\r\n\r\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\r\n    0x375c24c1\r\n);\r\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\r\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\r\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\r\n    0x98e9db6e\r\n);\r\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\r\nuint256 constant MismatchedOfferAndConsiderationComponents_error_selector = (\r\n    0xbced929d\r\n);\r\nuint256 constant MismatchedOfferAndConsiderationComponents_error_idx_ptr = 0x20;\r\nuint256 constant MismatchedOfferAndConsiderationComponents_error_length = 0x24;\r\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\r\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\r\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\r\nuint256 constant InexactFraction_error_length = 0x04;\r\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\r\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\r\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\r\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\r\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\r\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\r\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\r\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\r\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\r\nuint256 constant UnresolvedConsiderationCriteria_error_considerationIdx_ptr = (\r\n    0x40\r\n);\r\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\r\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\r\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = (\r\n    0x6088d7de\r\n);\r\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = (\r\n    0x6088d7de\r\n);\r\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\r\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\r\nuint256 constant InvalidProof_error_selector = 0x09bde339;\r\nuint256 constant InvalidProof_error_length = 0x04;\r\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\r\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\r\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\r\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\r\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\r\nuint256 constant InvalidContractOrder_error_length = 0x24;\r\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\r\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\r\nuint256 constant BadSignatureV_error_length = 0x24;\r\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\r\nuint256 constant InvalidSigner_error_length = 0x04;\r\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\r\nuint256 constant InvalidSignature_error_length = 0x04;\r\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\r\nuint256 constant BadContractSignature_error_length = 0x04;\r\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\r\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\r\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\r\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\r\nuint256 constant MissingItemAmount_error_length = 0x04;\r\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\r\nuint256 constant UnusedItemParameters_error_length = 0x04;\r\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\r\nuint256 constant NoReentrantCalls_error_length = 0x04;\r\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\r\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\r\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\r\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\r\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\r\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\r\nuint256 constant InvalidTime_error_length = 0x44;\r\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\r\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\r\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\r\nuint256 constant InvalidConduit_error_length = 0x44;\r\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\r\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\r\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\r\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\r\nuint256 constant InvalidCallToConduit_error_length = 0x24;\r\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\r\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\r\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\r\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\r\nuint256 constant ConsiderationNotMet_error_length = 0x64;\r\nuint256 constant InsufficientNativeTokensSupplied_error_selector = 0x8ffff980;\r\nuint256 constant InsufficientNativeTokensSupplied_error_length = 0x04;\r\nuint256 constant NativeTokenTransferGenericFailure_error_selector = 0xbc806b96;\r\nuint256 constant NativeTokenTransferGenericFailure_error_account_ptr = 0x20;\r\nuint256 constant NativeTokenTransferGenericFailure_error_amount_ptr = 0x40;\r\nuint256 constant NativeTokenTransferGenericFailure_error_length = 0x44;\r\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\r\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\r\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\r\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\r\nuint256 constant OrderIsCancelled_error_length = 0x24;\r\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\r\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\r\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\r\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\r\nuint256 constant CannotCancelOrder_error_length = 0x04;\r\nuint256 constant BadFraction_error_selector = 0x5a052b32;\r\nuint256 constant BadFraction_error_length = 0x04;\r\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\r\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\r\nuint256 constant InvalidMsgValue_error_length = 0x24;\r\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\r\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\r\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\r\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\r\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\r\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\r\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\r\n    0x2165628a\r\n);\r\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\r\nuint256 constant Panic_error_selector = 0x4e487b71;\r\nuint256 constant Panic_error_code_ptr = 0x20;\r\nuint256 constant Panic_error_length = 0x24;\r\nuint256 constant Panic_arithmetic = 0x11;\r\n\r\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\r\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\r\nuint256 constant IdentityPrecompileAddress = 0x4;\r\nuint256 constant OffsetOrLengthMask = 0xffffffff;\r\nuint256 constant _OneWord = 0x20;\r\nuint256 constant _FreeMemoryPointerSlot = 0x40;\r\n\r\nuint256 constant NameLengthPtr = 0x4D;\r\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\r\n\r\nuint256 constant information_version_offset = 0;\r\nuint256 constant information_version_cd_offset = 0x60;\r\nuint256 constant information_domainSeparator_offset = 0x20;\r\nuint256 constant information_conduitController_offset = 0x40;\r\nuint256 constant information_versionLengthPtr = 0x63;\r\nuint256 constant information_versionWithLength = 0x03312e34; // 1.4\r\nuint256 constant information_length = 0xa0;\r\n\r\nuint256 constant _NOT_ENTERED = 1;\r\nuint256 constant _ENTERED = 2;\r\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS = 3;\r\n\r\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\r\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\r\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\r\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\r\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\r\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts = (\r\n    0x60\r\n);\r\n\r\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\r\n\r\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\r\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\r\n\r\n// Common Offsets\r\n// Offsets for identically positioned fields shared by:\r\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\r\n\r\nuint256 constant Selector_length = 0x4;\r\n\r\nuint256 constant Common_token_offset = 0x20;\r\nuint256 constant Common_identifier_offset = 0x40;\r\nuint256 constant Common_amount_offset = 0x60;\r\nuint256 constant Common_endAmount_offset = 0x80;\r\n\r\nuint256 constant SpentItem_size = 0x80;\r\nuint256 constant SpentItem_size_shift = 0x7;\r\n\r\nuint256 constant OfferItem_size = 0xa0;\r\nuint256 constant OfferItem_size_with_length = 0xc0;\r\n\r\nuint256 constant ReceivedItem_size_excluding_recipient = 0x80;\r\nuint256 constant ReceivedItem_size = 0xa0;\r\nuint256 constant ReceivedItem_amount_offset = 0x60;\r\nuint256 constant ReceivedItem_recipient_offset = 0x80;\r\n\r\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\r\n\r\nuint256 constant ConsiderationItem_size = 0xc0;\r\nuint256 constant ConsiderationItem_size_with_length = 0xe0;\r\n\r\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\r\n// Store the same constant in an abbreviated format for a line length fix.\r\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\r\n\r\nuint256 constant Execution_offerer_offset = 0x20;\r\nuint256 constant Execution_conduit_offset = 0x40;\r\n\r\n// uint256 constant OrderParameters_offerer_offset = 0x00;\r\nuint256 constant OrderParameters_zone_offset = 0x20;\r\nuint256 constant OrderParameters_offer_head_offset = 0x40;\r\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\r\n// uint256 constant OrderParameters_orderType_offset = 0x80;\r\nuint256 constant OrderParameters_startTime_offset = 0xa0;\r\nuint256 constant OrderParameters_endTime_offset = 0xc0;\r\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\r\n// uint256 constant OrderParameters_salt_offset = 0x100;\r\nuint256 constant OrderParameters_conduit_offset = 0x120;\r\nuint256 constant OrderParameters_counter_offset = 0x140;\r\n\r\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\r\n\r\nuint256 constant AdvancedOrder_head_size = 0xa0;\r\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\r\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\r\nuint256 constant AdvancedOrder_signature_offset = 0x60;\r\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\r\n\r\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\r\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\r\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\r\n\r\nuint256 constant FourWords = 0x80;\r\nuint256 constant FiveWords = 0xa0;\r\n\r\nuint256 constant SixtyThreeBytes = 0x3f;\r\nuint256 constant OnlyFullWordMask = 0xffffffe0;\r\n\r\n\r\n// uint256 constant BasicOrder_endAmount_cdPtr = 0x104;\r\nuint256 constant BasicOrder_common_params_size = 0xa0;\r\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\r\nuint256 constant BasicOrder_receivedItemByteMap = (\r\n    0x0000010102030000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant BasicOrder_offeredItemByteMap = (\r\n    0x0203020301010000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nbytes32 constant OrdersMatchedTopic0 = (\r\n    0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7\r\n);\r\n\r\nuint256 constant EIP712_Order_size = 0x180;\r\nuint256 constant EIP712_OfferItem_size = 0xc0;\r\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\r\nuint256 constant AdditionalRecipient_size = 0x40;\r\nuint256 constant AdditionalRecipient_size_shift = 0x6;\r\n\r\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\r\nuint256 constant EIP712_OrderHash_offset = 0x22;\r\nuint256 constant EIP712_DigestPayload_size = 0x42;\r\n\r\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\r\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\r\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\r\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\r\nuint256 constant EIP712_domainData_size = 0xa0;\r\n\r\nuint256 constant BulkOrderProof_minSize = 0x63;\r\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\r\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\r\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\r\nuint256 constant BulkOrderProof_keyShift = 0xe8;\r\nuint256 constant BulkOrderProof_keySize = 0x3;\r\n\r\nuint256 constant BulkOrder_Typehash_Height_One = (\r\n    0x3ca2711d29384747a8f61d60aad3c450405f7aaff5613541dee28df2d6986d32\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Two = (\r\n    0xbf8e29b89f29ed9b529c154a63038ffca562f8d7cd1e2545dda53a1b582dde30\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Three = (\r\n    0x53c6f6856e13104584dd0797ca2b2779202dc2597c6066a42e0d8fe990b0024d\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Four = (\r\n    0xa02eb7ff164c884e5e2c336dc85f81c6a93329d8e9adf214b32729b894de2af1\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Five = (\r\n    0x39c9d33c18e050dda0aeb9a8086fb16fc12d5d64536780e1da7405a800b0b9f6\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Six = (\r\n    0x1c19f71958cdd8f081b4c31f7caf5c010b29d12950be2fa1c95070dc47e30b55\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Seven = (\r\n    0xca74fab2fece9a1d58234a274220ad05ca096a92ef6a1ca1750b9d90c948955c\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Eight = (\r\n    0x7ff98d9d4e55d876c5cfac10b43c04039522f3ddfb0ea9bfe70c68cfb5c7cc14\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Nine = (\r\n    0xbed7be92d41c56f9e59ac7a6272185299b815ddfabc3f25deb51fe55fe2f9e8a\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Ten = (\r\n    0xd1d97d1ef5eaa37a4ee5fbf234e6f6d64eb511eb562221cd7edfbdde0848da05\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Eleven = (\r\n    0x896c3f349c4da741c19b37fec49ed2e44d738e775a21d9c9860a69d67a3dae53\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Twelve = (\r\n    0xbb98d87cc12922b83759626c5f07d72266da9702d19ffad6a514c73a89002f5f\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Thirteen = (\r\n    0xe6ae19322608dd1f8a8d56aab48ed9c28be489b689f4b6c91268563efc85f20e\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Fourteen = (\r\n    0x6b5b04cbae4fcb1a9d78e7b2dfc51a36933d023cf6e347e03d517b472a852590\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Fifteen = (\r\n    0xd1eb68309202b7106b891e109739dbbd334a1817fe5d6202c939e75cf5e35ca9\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Sixteen = (\r\n    0x1da3eed3ecef6ebaa6e5023c057ec2c75150693fd0dac5c90f4a142f9879fde8\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Seventeen = (\r\n    0xeee9a1392aa395c7002308119a58f2582777a75e54e0c1d5d5437bd2e8bf6222\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Eighteen = (\r\n    0xc3939feff011e53ab8c35ca3370aad54c5df1fc2938cd62543174fa6e7d85877\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Nineteen = (\r\n    0x0efca7572ac20f5ae84db0e2940674f7eca0a4726fa1060ffc2d18cef54b203d\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_Twenty = (\r\n    0x5a4f867d3d458dabecad65f6201ceeaba0096df2d0c491cc32e6ea4e64350017\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_TwentyOne = (\r\n    0x80987079d291feebf21c2230e69add0f283cee0b8be492ca8050b4185a2ff719\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_TwentyTwo = (\r\n    0x3bd8cff538aba49a9c374c806d277181e9651624b3e31111bc0624574f8bca1d\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_TwentyThree = (\r\n    0x5d6a3f098a0bc373f808c619b1bb4028208721b3c4f8d6bc8a874d659814eb76\r\n);\r\nuint256 constant BulkOrder_Typehash_Height_TwentyFour = (\r\n    0x1d51df90cba8de7637ca3e8fe1e3511d1dc2f23487d05dbdecb781860c21ac1c\r\n);\r\nuint256 constant receivedItemsHash_ptr = 0x60;\r\n// Minimum length of the OrderFulfilled event data.\r\n// Must be added to the size of the ReceivedItem array for additionalRecipients\r\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\r\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\r\nuint256 constant OrderFulfilled_selector = (\r\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\r\n);\r\n\r\n// Minimum offset in memory to OrderFulfilled event data.\r\n// Must be added to the size of the EIP712 hash array for additionalRecipients\r\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\r\nuint256 constant OrderFulfilled_baseOffset = 0x180;\r\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\r\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\r\n\r\n// Related constants used for restricted order checks on basic orders.\r\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\r\n// uint256 constant ValidateOrder_offerDataOffset = 0x184;\r\n// uint256 constant RatifyOrder_offerDataOffset = 0xc4;\r\n\r\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\r\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\r\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\r\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\r\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\r\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\r\n\r\n// BasicOrderParameters\r\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\r\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\r\nuint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\r\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\r\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\r\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\r\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\r\nuint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\r\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\r\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\r\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\r\nuint256 constant BasicOrder_endTime_cdPtr = 0x164;\r\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\r\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\r\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\r\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\r\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\r\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\r\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\r\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\r\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\r\nuint256 constant BasicOrder_parameters_ptr = 0x20;\r\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\r\n\r\n/*\r\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\r\n *  EIP712 data for ConsiderationItem\r\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\r\n *   - 0xa0: itemType\r\n *   - 0xc0: token\r\n *   - 0xe0: identifier\r\n *   - 0x100: startAmount\r\n *   - 0x120: endAmount\r\n *   - 0x140: recipient\r\n */\r\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\r\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\r\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\r\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\r\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\r\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\r\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\r\n\r\n/*\r\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\r\n *  EIP712 data for OfferItem\r\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\r\n *   - 0xa0:  itemType\r\n *   - 0xc0:  token\r\n *   - 0xe0:  identifier (reused for offeredItemsHash)\r\n *   - 0x100: startAmount\r\n *   - 0x120: endAmount\r\n */\r\nuint256 constant BasicOrder_offerItem_typeHash_ptr = 0x80;\r\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\r\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\r\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\r\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\r\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\r\n\r\n/*\r\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\r\n *  EIP712 data for Order\r\n *   - 0x80:   Order EIP-712 typehash (constant)\r\n *   - 0xa0:   orderParameters.offerer\r\n *   - 0xc0:   orderParameters.zone\r\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\r\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\r\n *   - 0x120:  orderType\r\n *   - 0x140:  startTime\r\n *   - 0x160:  endTime\r\n *   - 0x180:  zoneHash\r\n *   - 0x1a0:  salt\r\n *   - 0x1c0:  conduit\r\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\r\n */\r\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\r\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\r\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\r\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\r\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\r\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\r\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\r\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\r\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\r\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\r\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\r\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\r\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\r\nuint256 constant BasicOrder_signature_ptr = 0x260;\r\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\r\n\r\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\r\n\r\nuint256 constant Counter_blockhash_shift = 0x80;\r\n\r\n// Signature-related\r\nbytes32 constant EIP2098_allButHighestBitMask = (\r\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n);\r\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet = (\r\n    0x0000000000000000000000000000000000000000000000000000000101000000\r\n);\r\nuint256 constant ECDSA_MaxLength = 65;\r\nuint256 constant ECDSA_signature_s_offset = 0x40;\r\nuint256 constant ECDSA_signature_v_offset = 0x60;\r\n\r\nbytes32 constant EIP1271_isValidSignature_selector = (\r\n    0x1626ba7e00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\r\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\r\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\r\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\r\n\r\nuint256 constant EIP_712_PREFIX = (\r\n    0x1901000000000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\n\r\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\r\nuint256 constant Create2AddressDerivation_length = 0x55;\r\n\r\nuint256 constant MaskOverByteTwelve = (\r\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\r\n);\r\nuint256 constant MaskOverLastTwentyBytes = (\r\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\r\n);\r\nuint256 constant AddressDirtyUpperBitThreshold = (\r\n    0x0000000000000000000000010000000000000000000000000000000000000000\r\n);\r\nuint256 constant MaskOverFirstFourBytes = (\r\n    0xffffffff00000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nuint256 constant Conduit_execute_signature = (\r\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nuint256 constant MaxUint8 = 0xff;\r\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\r\n\r\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\r\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\r\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\r\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\r\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\r\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\r\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\r\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\r\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\r\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\r\n\r\nuint256 constant OneConduitExecute_size = 0x104;\r\n\r\n// Sentinel value to indicate that the conduit accumulator is not armed.\r\nuint256 constant AccumulatorDisarmed = 0x20;\r\nuint256 constant AccumulatorArmed = 0x40;\r\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\r\nuint256 constant Accumulator_selector_ptr = 0x40;\r\nuint256 constant Accumulator_array_offset_ptr = 0x44;\r\nuint256 constant Accumulator_array_length_ptr = 0x64;\r\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\r\nuint256 constant Accumulator_array_offset = 0x20;\r\n\r\nuint256 constant Conduit_transferItem_size = 0xc0;\r\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\r\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\r\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\r\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\r\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\r\n\r\nuint256 constant Ecrecover_precompile = 0x1;\r\nuint256 constant Ecrecover_args_size = 0x80;\r\nuint256 constant Signature_lower_v = 27;\r\n\r\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\r\nuint256 constant NonMatchSelector_MagicMask = (\r\n    0x4000000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\n// First bit indicates that a NATIVE offer items has been used and the 231st bit\r\n// indicates that a non match selector has been called.\r\nuint256 constant NonMatchSelector_InvalidErrorValue = (\r\n    0x4000000000000000000000000000000000000000000000000000000001\r\n);\r\n\r\n/**\r\n * @dev Selector and offsets for generateOrder\r\n *\r\n * function generateOrder(\r\n *   address fulfiller,\r\n *   SpentItem[] calldata minimumReceived,\r\n *   SpentItem[] calldata maximumSpent,\r\n *   bytes calldata context\r\n * )\r\n */\r\nuint256 constant generateOrder_selector = 0x98919765;\r\nuint256 constant generateOrder_selector_offset = 0x1c;\r\nuint256 constant generateOrder_head_offset = 0x04;\r\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\r\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\r\nuint256 constant generateOrder_context_head_offset = 0x60;\r\nuint256 constant generateOrder_base_tail_offset = 0x80;\r\nuint256 constant generateOrder_maximum_returndatasize = 0xffff;\r\n\r\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\r\nuint256 constant ratifyOrder_selector_offset = 0x1c;\r\nuint256 constant ratifyOrder_head_offset = 0x04;\r\n// uint256 constant ratifyOrder_offer_head_offset = 0x00;\r\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\r\nuint256 constant ratifyOrder_context_head_offset = 0x40;\r\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\r\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\r\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\r\n\r\nuint256 constant validateOrder_selector = 0x17b1f942;\r\nuint256 constant validateOrder_selector_offset = 0x1c;\r\nuint256 constant validateOrder_head_offset = 0x04;\r\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\r\n\r\n// uint256 constant ZoneParameters_orderHash_offset = 0x00;\r\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\r\nuint256 constant ZoneParameters_offerer_offset = 0x40;\r\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\r\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\r\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\r\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\r\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\r\nuint256 constant ZoneParameters_endTime_offset = 0x100;\r\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\r\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\r\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\r\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x64;\r\n\r\n// ConsiderationDecoder Constants\r\nuint256 constant OrderParameters_head_size = 0x0160;\r\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\r\n    0x0140\r\n);\r\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\r\n\r\nuint256 constant Order_signature_offset = 0x20;\r\nuint256 constant Order_head_size = 0x40;\r\n\r\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\r\n\r\nuint256 constant CriteriaResolver_head_size = 0xa0;\r\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\r\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\r\n\r\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\r\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 0x6;\r\nuint256 constant Fulfillment_head_size = 0x40;\r\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\r\n\r\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\r\nenum ConduitItemType {\r\n    NATIVE, // unused\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}\r\nstruct ConduitTransfer {\r\n    ConduitItemType itemType;\r\n    address token;\r\n    address from;\r\n    address to;\r\n    uint256 identifier;\r\n    uint256 amount;\r\n}\r\nstruct ConduitBatch1155Transfer {\r\n    address token;\r\n    address from;\r\n    address to;\r\n    uint256[] ids;\r\n    uint256[] amounts;\r\n}\r\n\r\ninterface ConduitInterface {\r\n    /**\r\n     * @dev Revert with an error when attempting to execute transfers using a\r\n     *      caller that does not have an open channel.\r\n     */\r\n    error ChannelClosed(address channel);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to update a channel to the\r\n     *      current status of that channel.\r\n     */\r\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to execute a transfer for an\r\n     *      item that does not have an ERC20/721/1155 item type.\r\n     */\r\n    error InvalidItemType();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to update the status of a\r\n     *      channel from a caller that is not the conduit controller.\r\n     */\r\n    error InvalidController();\r\n\r\n    /**\r\n     * @dev Emit an event whenever a channel is opened or closed.\r\n     *\r\n     * @param channel The channel that has been updated.\r\n     * @param open    A boolean indicating whether the conduit is open or not.\r\n     */\r\n    event ChannelUpdated(address indexed channel, bool open);\r\n\r\n    /**\r\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\r\n     *         with an open channel can call this function.\r\n     *\r\n     * @param transfers The ERC20/721/1155 transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function execute(\r\n        ConduitTransfer[] calldata transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    /**\r\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\r\n     *         open channel can call this function.\r\n     *\r\n     * @param batch1155Transfers The 1155 batch transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function executeBatch1155(\r\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    /**\r\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\r\n     *         a caller with an open channel can call this function.\r\n     *\r\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\r\n     * @param batch1155Transfers The 1155 batch transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function executeWithBatch1155(\r\n        ConduitTransfer[] calldata standardTransfers,\r\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    /**\r\n     * @notice Open or close a given channel. Only callable by the controller.\r\n     *\r\n     * @param channel The channel to open or close.\r\n     * @param isOpen  The status of the channel (either open or closed).\r\n     */\r\n    function updateChannel(address channel, bool isOpen) external;\r\n}\r\n\r\ncontract ConsiderationDecoder {\r\n    /**\r\n     * @dev Takes a bytes array from calldata and copies it into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the bytes array in\r\n     *                    calldata which contains the length of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the bytes array in\r\n     *                    memory which contains the length of the array.\r\n     */\r\n    function _decodeBytes(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        assembly {\r\n            // Get the current free memory pointer.\r\n            mPtrLength := mload(FreeMemoryPointerSlot)\r\n\r\n            // Derive the size of the bytes array, rounding up to nearest word\r\n            // and adding a word for the length field. Note: masking\r\n            // `calldataload(cdPtrLength)` is redundant here.\r\n            let size := add(\r\n                and(\r\n                    add(calldataload(cdPtrLength), ThirtyOneBytes),\r\n                    OnlyFullWordMask\r\n                ),\r\n                OneWord\r\n            )\r\n\r\n            // Copy bytes from calldata into memory based on pointers and size.\r\n            calldatacopy(mPtrLength, cdPtrLength, size)\r\n\r\n            // Store the masked value in memory. Note: the value of `size` is at\r\n            // least 32, meaning the calldatacopy above will at least write to\r\n            // `[mPtrLength, mPtrLength + 32)`.\r\n            mstore(\r\n                mPtrLength,\r\n                and(calldataload(cdPtrLength), OffsetOrLengthMask)\r\n            )\r\n\r\n            // Update free memory pointer based on the size of the bytes array.\r\n            mstore(FreeMemoryPointerSlot, add(mPtrLength, size))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an offer array from calldata and copies it into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the offer array\r\n     *                    in calldata which contains the length of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the offer array in\r\n     *                    memory which contains the length of the array.\r\n     */\r\n    function _decodeOffer(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        assembly {\r\n            // Retrieve length of array, masking to prevent potential overflow.\r\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\r\n\r\n            // Get the current free memory pointer.\r\n            mPtrLength := mload(FreeMemoryPointerSlot)\r\n\r\n            // Write the array length to memory.\r\n            mstore(mPtrLength, arrLength)\r\n\r\n            // Derive the head by adding one word to the length pointer.\r\n            let mPtrHead := add(mPtrLength, OneWord)\r\n\r\n            // Derive the tail by adding one word per element (note that structs\r\n            // are written to memory with an offset per struct element).\r\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\r\n\r\n            // Track the next tail, beginning with the initial tail value.\r\n            let mPtrTailNext := mPtrTail\r\n\r\n            // Copy all offer array data into memory at the tail pointer.\r\n            calldatacopy(\r\n                mPtrTail,\r\n                add(cdPtrLength, OneWord),\r\n                mul(arrLength, OfferItem_size)\r\n            )\r\n\r\n            // Track the next head pointer, starting with initial head value.\r\n            let mPtrHeadNext := mPtrHead\r\n\r\n            // Iterate over each head pointer until it reaches the tail.\r\n            for {\r\n\r\n            } lt(mPtrHeadNext, mPtrTail) {\r\n\r\n            } {\r\n                // Write the next tail pointer to next head pointer in memory.\r\n                mstore(mPtrHeadNext, mPtrTailNext)\r\n\r\n                // Increment the next head pointer by one word.\r\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\r\n\r\n                // Increment the next tail pointer by the size of an offer item.\r\n                mPtrTailNext := add(mPtrTailNext, OfferItem_size)\r\n            }\r\n\r\n            // Update free memory pointer to allocate memory up to end of tail.\r\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a consideration array from calldata and copies it into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the consideration\r\n     *                    array in calldata which contains the length of the\r\n     *                    array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the consideration\r\n     *                    array in memory which contains the length of the\r\n     *                    array.\r\n     */\r\n    function _decodeConsideration(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        assembly {\r\n            // Retrieve length of array, masking to prevent potential overflow.\r\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\r\n\r\n            // Get the current free memory pointer.\r\n            mPtrLength := mload(FreeMemoryPointerSlot)\r\n\r\n            // Write the array length to memory.\r\n            mstore(mPtrLength, arrLength)\r\n\r\n            // Derive the head by adding one word to the length pointer.\r\n            let mPtrHead := add(mPtrLength, OneWord)\r\n\r\n            // Derive the tail by adding one word per element (note that structs\r\n            // are written to memory with an offset per struct element).\r\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\r\n\r\n            // Track the next tail, beginning with the initial tail value.\r\n            let mPtrTailNext := mPtrTail\r\n\r\n            // Copy all consideration array data into memory at tail pointer.\r\n            calldatacopy(\r\n                mPtrTail,\r\n                add(cdPtrLength, OneWord),\r\n                mul(arrLength, ConsiderationItem_size)\r\n            )\r\n\r\n            // Track the next head pointer, starting with initial head value.\r\n            let mPtrHeadNext := mPtrHead\r\n\r\n            // Iterate over each head pointer until it reaches the tail.\r\n            for {\r\n\r\n            } lt(mPtrHeadNext, mPtrTail) {\r\n\r\n            } {\r\n                // Write the next tail pointer to next head pointer in memory.\r\n                mstore(mPtrHeadNext, mPtrTailNext)\r\n\r\n                // Increment the next head pointer by one word.\r\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\r\n\r\n                // Increment next tail pointer by size of a consideration item.\r\n                mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\r\n            }\r\n\r\n            // Update free memory pointer to allocate memory up to end of tail.\r\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer and memory pointer and copies a referenced\r\n     *      OrderParameters struct and associated offer and consideration data\r\n     *      to memory.\r\n     *\r\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\r\n     * @param mPtr A memory pointer to the OrderParameters struct head.\r\n     */\r\n    function _decodeOrderParametersTo(\r\n        CalldataPointer cdPtr,\r\n        MemoryPointer mPtr\r\n    ) internal pure {\r\n        // Copy the full OrderParameters head from calldata to memory.\r\n        cdPtr.copy(mPtr, OrderParameters_head_size);\r\n\r\n        // Resolve the offer calldata offset, use that to decode and copy offer\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(OrderParameters_offer_head_offset).write(\r\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\r\n        );\r\n\r\n        // Resolve consideration calldata offset, use that to copy consideration\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\r\n            _decodeConsideration(\r\n                cdPtr.pptr(OrderParameters_consideration_head_offset)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to an OrderParameters struct and copies the\r\n     *      decoded struct to memory.\r\n     *\r\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\r\n     *\r\n     * @return mPtr A memory pointer to the OrderParameters struct head.\r\n     */\r\n    function _decodeOrderParameters(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate required memory for the OrderParameters head (offer and\r\n        // consideration are allocated independently).\r\n        mPtr = malloc(OrderParameters_head_size);\r\n\r\n        // Decode and copy the order parameters to the newly allocated memory.\r\n        _decodeOrderParametersTo(cdPtr, mPtr);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\r\n     *      struct to memory.\r\n     *\r\n     * @param cdPtr A calldata pointer for the Order struct.\r\n     *\r\n     * @return mPtr A memory pointer to the Order struct head.\r\n     */\r\n    function _decodeOrder(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate required memory for the Order head (OrderParameters and\r\n        // signature are allocated independently).\r\n        mPtr = malloc(Order_head_size);\r\n\r\n        // Resolve OrderParameters calldata offset, use it to decode and copy\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        mPtr.write(_decodeOrderParameters(cdPtr.pptr()));\r\n\r\n        // Resolve signature calldata offset, use that to decode and copy from\r\n        // calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(Order_signature_offset).write(\r\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to an AdvancedOrder struct and copies the\r\n     *      decoded struct to memory.\r\n     *\r\n     * @param cdPtr A calldata pointer for the AdvancedOrder struct.\r\n     *\r\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\r\n     */\r\n    function _decodeAdvancedOrder(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\r\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\r\n\r\n        // Use numerator + denominator calldata offset to decode and copy\r\n        // from calldata and write resultant memory offset to head in memory.\r\n        cdPtr.offset(AdvancedOrder_numerator_offset).copy(\r\n            mPtr.offset(AdvancedOrder_numerator_offset),\r\n            AdvancedOrder_fixed_segment_0\r\n        );\r\n\r\n        // Get pointer to memory immediately after advanced order.\r\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\r\n\r\n        // Write pptr for advanced order parameters to memory.\r\n        mPtr.write(mPtrParameters);\r\n\r\n        // Resolve OrderParameters calldata pointer & write to allocated region.\r\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\r\n\r\n        // Resolve signature calldata offset, use that to decode and copy from\r\n        // calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(AdvancedOrder_signature_offset).write(\r\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_signature_offset))\r\n        );\r\n\r\n        // Resolve extraData calldata offset, use that to decode and copy from\r\n        // calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\r\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_extraData_offset))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Allocates a single word of empty bytes in memory and returns the\r\n     *      pointer to that memory region.\r\n     *\r\n     * @return mPtr The memory pointer to the new empty word in memory.\r\n     */\r\n    function _getEmptyBytesOrArray()\r\n        internal\r\n        pure\r\n        returns (MemoryPointer mPtr)\r\n    {\r\n        mPtr = malloc(OneWord);\r\n        mPtr.write(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\r\n     *      struct to memory as an AdvancedOrder.\r\n     *\r\n     * @param cdPtr A calldata pointer for the Order struct.\r\n     *\r\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\r\n     */\r\n    function _decodeOrderAsAdvancedOrder(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\r\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\r\n\r\n        // Get pointer to memory immediately after advanced order.\r\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\r\n\r\n        // Write pptr for advanced order parameters.\r\n        mPtr.write(mPtrParameters);\r\n\r\n        // Resolve OrderParameters calldata pointer & write to allocated region.\r\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\r\n\r\n        // Write default Order numerator and denominator values (i.e. 1/1).\r\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\r\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\r\n\r\n        // Resolve signature calldata offset, use that to decode and copy from\r\n        // calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(AdvancedOrder_signature_offset).write(\r\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\r\n        );\r\n\r\n        // Resolve extraData calldata offset, use that to decode and copy from\r\n        // calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\r\n            _getEmptyBytesOrArray()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to an array of Order structs and copies the\r\n     *      decoded array to memory as an array of AdvancedOrder structs.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\r\n     *                    calldata which contains the length of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the array of advanced\r\n     *                    orders in memory which contains length of the array.\r\n     */\r\n    function _decodeOrdersAsAdvancedOrders(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive offset to the tail based on one word per array element.\r\n            uint256 tailOffset = arrLength << OneWordShift;\r\n\r\n            // Add one additional word for the length and allocate memory.\r\n            mPtrLength = malloc(tailOffset + OneWord);\r\n\r\n            // Write the length of the array to memory.\r\n            mPtrLength.write(arrLength);\r\n\r\n            // Advance to first memory & calldata pointers (e.g. after length).\r\n            MemoryPointer mPtrHead = mPtrLength.next();\r\n            CalldataPointer cdPtrHead = cdPtrLength.next();\r\n\r\n            // Iterate over each pointer, word by word, until tail is reached.\r\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\r\n                // Resolve Order calldata offset, use it to decode and copy from\r\n                // calldata, and write resultant AdvancedOrder offset to memory.\r\n                mPtrHead.offset(offset).write(\r\n                    _decodeOrderAsAdvancedOrder(cdPtrHead.pptr(offset))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to a criteria proof, or an array bytes32\r\n     *      types, and copies the decoded proof to memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the criteria proof\r\n     *                    in calldata which contains the length of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the criteria proof\r\n     *                    in memory which contains length of the array.\r\n     */\r\n    function _decodeCriteriaProof(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive array size based on one word per array element and length.\r\n            uint256 arrSize = (arrLength + 1) << OneWordShift;\r\n\r\n            // Allocate memory equal to the array size.\r\n            mPtrLength = malloc(arrSize);\r\n\r\n            // Copy the array from calldata into memory.\r\n            cdPtrLength.copy(mPtrLength, arrSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to a CriteriaResolver struct and copies the\r\n     *      decoded struct to memory.\r\n     *\r\n     * @param cdPtr A calldata pointer for the CriteriaResolver struct.\r\n     *\r\n     * @return mPtr A memory pointer to the CriteriaResolver struct head.\r\n     */\r\n    function _decodeCriteriaResolver(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate required memory for the CriteriaResolver head (the criteria\r\n        // proof bytes32 array is allocated independently).\r\n        mPtr = malloc(CriteriaResolver_head_size);\r\n\r\n        // Decode and copy order index, side, index, and identifier from\r\n        // calldata and write resultant memory offset to head in memory.\r\n        cdPtr.copy(mPtr, CriteriaResolver_fixed_segment_0);\r\n\r\n        // Resolve criteria proof calldata offset, use it to decode and copy\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(CriteriaResolver_criteriaProof_offset).write(\r\n            _decodeCriteriaProof(\r\n                cdPtr.pptr(CriteriaResolver_criteriaProof_offset)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an array of criteria resolvers from calldata and copies it\r\n     *      into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the criteria\r\n     *                    resolver array in calldata which contains the length\r\n     *                    of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the criteria resolver\r\n     *                    array in memory which contains the length of the\r\n     *                    array.\r\n     */\r\n    function _decodeCriteriaResolvers(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive offset to the tail based on one word per array element.\r\n            uint256 tailOffset = arrLength << OneWordShift;\r\n\r\n            // Add one additional word for the length and allocate memory.\r\n            mPtrLength = malloc(tailOffset + OneWord);\r\n\r\n            // Write the length of the array to memory.\r\n            mPtrLength.write(arrLength);\r\n\r\n            // Advance to first memory & calldata pointers (e.g. after length).\r\n            MemoryPointer mPtrHead = mPtrLength.next();\r\n            CalldataPointer cdPtrHead = cdPtrLength.next();\r\n\r\n            // Iterate over each pointer, word by word, until tail is reached.\r\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\r\n                // Resolve CriteriaResolver calldata offset, use it to decode\r\n                // and copy from calldata, and write resultant memory offset.\r\n                mPtrHead.offset(offset).write(\r\n                    _decodeCriteriaResolver(cdPtrHead.pptr(offset))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an array of orders from calldata and copies it into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\r\n     *                    calldata which contains the length of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the orders array\r\n     *                    in memory which contains the length of the array.\r\n     */\r\n    function _decodeOrders(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive offset to the tail based on one word per array element.\r\n            uint256 tailOffset = arrLength << OneWordShift;\r\n\r\n            // Add one additional word for the length and allocate memory.\r\n            mPtrLength = malloc(tailOffset + OneWord);\r\n\r\n            // Write the length of the array to memory.\r\n            mPtrLength.write(arrLength);\r\n\r\n            // Advance to first memory & calldata pointers (e.g. after length).\r\n            MemoryPointer mPtrHead = mPtrLength.next();\r\n            CalldataPointer cdPtrHead = cdPtrLength.next();\r\n\r\n            // Iterate over each pointer, word by word, until tail is reached.\r\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\r\n                // Resolve Order calldata offset, use it to decode and copy\r\n                // from calldata, and write resultant memory offset.\r\n                mPtrHead.offset(offset).write(\r\n                    _decodeOrder(cdPtrHead.pptr(offset))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an array of fulfillment components from calldata and copies it\r\n     *      into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the fulfillment\r\n     *                    components array in calldata which contains the length\r\n     *                    of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the fulfillment\r\n     *                    components array in memory which contains the length\r\n     *                    of the array.\r\n     */\r\n    function _decodeFulfillmentComponents(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        assembly {\r\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\r\n\r\n            // Get the current free memory pointer.\r\n            mPtrLength := mload(FreeMemoryPointerSlot)\r\n\r\n            mstore(mPtrLength, arrLength)\r\n            let mPtrHead := add(mPtrLength, OneWord)\r\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\r\n            let mPtrTailNext := mPtrTail\r\n            calldatacopy(\r\n                mPtrTail,\r\n                add(cdPtrLength, OneWord),\r\n                shl(FulfillmentComponent_mem_tail_size_shift, arrLength)\r\n            )\r\n            let mPtrHeadNext := mPtrHead\r\n            for {\r\n\r\n            } lt(mPtrHeadNext, mPtrTail) {\r\n\r\n            } {\r\n                mstore(mPtrHeadNext, mPtrTailNext)\r\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\r\n                mPtrTailNext := add(\r\n                    mPtrTailNext,\r\n                    FulfillmentComponent_mem_tail_size\r\n                )\r\n            }\r\n\r\n            // Update the free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a nested array of fulfillment components from calldata and\r\n     *      copies it into memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the nested\r\n     *                    fulfillment components array in calldata which\r\n     *                    contains the length of the array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the nested\r\n     *                    fulfillment components array in memory which\r\n     *                    contains the length of the array.\r\n     */\r\n    function _decodeNestedFulfillmentComponents(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive offset to the tail based on one word per array element.\r\n            uint256 tailOffset = arrLength << OneWordShift;\r\n\r\n            // Add one additional word for the length and allocate memory.\r\n            mPtrLength = malloc(tailOffset + OneWord);\r\n\r\n            // Write the length of the array to memory.\r\n            mPtrLength.write(arrLength);\r\n\r\n            // Advance to first memory & calldata pointers (e.g. after length).\r\n            MemoryPointer mPtrHead = mPtrLength.next();\r\n            CalldataPointer cdPtrHead = cdPtrLength.next();\r\n\r\n            // Iterate over each pointer, word by word, until tail is reached.\r\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\r\n                // Resolve FulfillmentComponents array calldata offset, use it\r\n                // to decode and copy from calldata, and write memory offset.\r\n                mPtrHead.offset(offset).write(\r\n                    _decodeFulfillmentComponents(cdPtrHead.pptr(offset))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an array of advanced orders from calldata and copies it into\r\n     *      memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the advanced orders\r\n     *                    array in calldata which contains the length of the\r\n     *                    array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the advanced orders\r\n     *                    array in memory which contains the length of the\r\n     *                    array.\r\n     */\r\n    function _decodeAdvancedOrders(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive offset to the tail based on one word per array element.\r\n            uint256 tailOffset = arrLength << OneWordShift;\r\n\r\n            // Add one additional word for the length and allocate memory.\r\n            mPtrLength = malloc(tailOffset + OneWord);\r\n\r\n            // Write the length of the array to memory.\r\n            mPtrLength.write(arrLength);\r\n\r\n            // Advance to first memory & calldata pointers (e.g. after length).\r\n            MemoryPointer mPtrHead = mPtrLength.next();\r\n            CalldataPointer cdPtrHead = cdPtrLength.next();\r\n\r\n            // Iterate over each pointer, word by word, until tail is reached.\r\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\r\n                // Resolve AdvancedOrder calldata offset, use it to decode and\r\n                // copy from calldata, and write resultant memory offset.\r\n                mPtrHead.offset(offset).write(\r\n                    _decodeAdvancedOrder(cdPtrHead.pptr(offset))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to a Fulfillment struct and copies the\r\n     *      decoded struct to memory.\r\n     *\r\n     * @param cdPtr A calldata pointer for the Fulfillment struct.\r\n     *\r\n     * @return mPtr A memory pointer to the Fulfillment struct head.\r\n     */\r\n    function _decodeFulfillment(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate required memory for the Fulfillment head (the fulfillment\r\n        // components arrays are allocated independently).\r\n        mPtr = malloc(Fulfillment_head_size);\r\n\r\n        // Resolve offerComponents calldata offset, use it to decode and copy\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        mPtr.write(_decodeFulfillmentComponents(cdPtr.pptr()));\r\n\r\n        // Resolve considerationComponents calldata offset, use it to decode and\r\n        // copy from calldata, and write resultant memory offset to memory head.\r\n        mPtr.offset(Fulfillment_considerationComponents_offset).write(\r\n            _decodeFulfillmentComponents(\r\n                cdPtr.pptr(Fulfillment_considerationComponents_offset)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an array of fulfillments from calldata and copies it into\r\n     *      memory.\r\n     *\r\n     * @param cdPtrLength A calldata pointer to the start of the fulfillments\r\n     *                    array in calldata which contains the length of the\r\n     *                    array.\r\n     *\r\n     * @return mPtrLength A memory pointer to the start of the fulfillments\r\n     *                    array in memory which contains the length of the\r\n     *                    array.\r\n     */\r\n    function _decodeFulfillments(\r\n        CalldataPointer cdPtrLength\r\n    ) internal pure returns (MemoryPointer mPtrLength) {\r\n        // Retrieve length of array, masking to prevent potential overflow.\r\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\r\n\r\n        unchecked {\r\n            // Derive offset to the tail based on one word per array element.\r\n            uint256 tailOffset = arrLength << OneWordShift;\r\n\r\n            // Add one additional word for the length and allocate memory.\r\n            mPtrLength = malloc(tailOffset + OneWord);\r\n\r\n            // Write the length of the array to memory.\r\n            mPtrLength.write(arrLength);\r\n\r\n            // Advance to first memory & calldata pointers (e.g. after length).\r\n            MemoryPointer mPtrHead = mPtrLength.next();\r\n            CalldataPointer cdPtrHead = cdPtrLength.next();\r\n\r\n            // Iterate over each pointer, word by word, until tail is reached.\r\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\r\n                // Resolve Fulfillment calldata offset, use it to decode and\r\n                // copy from calldata, and write resultant memory offset.\r\n                mPtrHead.offset(offset).write(\r\n                    _decodeFulfillment(cdPtrHead.pptr(offset))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a calldata pointer to an OrderComponents struct and copies the\r\n     *      decoded struct to memory as an OrderParameters struct (with the\r\n     *      totalOriginalConsiderationItems value set equal to the length of the\r\n     *      supplied consideration array).\r\n     *\r\n     * @param cdPtr A calldata pointer for the OrderComponents struct.\r\n     *\r\n     * @return mPtr A memory pointer to the OrderParameters struct head.\r\n     */\r\n    function _decodeOrderComponentsAsOrderParameters(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (MemoryPointer mPtr) {\r\n        // Allocate memory for the OrderParameters head.\r\n        mPtr = malloc(OrderParameters_head_size);\r\n\r\n        // Copy the full OrderComponents head from calldata to memory.\r\n        cdPtr.copy(mPtr, OrderComponents_OrderParameters_common_head_size);\r\n\r\n        // Resolve the offer calldata offset, use that to decode and copy offer\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        mPtr.offset(OrderParameters_offer_head_offset).write(\r\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\r\n        );\r\n\r\n        // Resolve consideration calldata offset, use that to copy consideration\r\n        // from calldata, and write resultant memory offset to head in memory.\r\n        MemoryPointer consideration = _decodeConsideration(\r\n            cdPtr.pptr(OrderParameters_consideration_head_offset)\r\n        );\r\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\r\n            consideration\r\n        );\r\n\r\n        // Write masked consideration length to totalOriginalConsiderationItems.\r\n        mPtr\r\n            .offset(OrderParameters_totalOriginalConsiderationItems_offset)\r\n            .write(consideration.readUint256());\r\n    }\r\n\r\n    /**\r\n     * @dev Decodes the returndata from a call to generateOrder, or returns\r\n     *      empty arrays and a boolean signifying that the returndata does not\r\n     *      adhere to a valid encoding scheme if it cannot be decoded.\r\n     *\r\n     * @return invalidEncoding A boolean signifying whether the returndata has\r\n     *                         an invalid encoding.\r\n     * @return offer           The decoded offer array.\r\n     * @return consideration   The decoded consideration array.\r\n     */\r\n    function _decodeGenerateOrderReturndata()\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 invalidEncoding,\r\n            MemoryPointer offer,\r\n            MemoryPointer consideration\r\n        )\r\n    {\r\n        assembly {\r\n            // Check that returndatasize is at least four words: offerOffset,\r\n            // considerationOffset, offerLength, & considerationLength\r\n            invalidEncoding := lt(returndatasize(), FourWords)\r\n\r\n            let offsetOffer\r\n            let offsetConsideration\r\n            let offerLength\r\n            let considerationLength\r\n\r\n            // Proceed if enough returndata is present to continue evaluation.\r\n            if iszero(invalidEncoding) {\r\n                // Copy first two words of returndata (the offsets to offer and\r\n                // consideration array lengths) to scratch space.\r\n                returndatacopy(0, 0, TwoWords)\r\n                offsetOffer := mload(0)\r\n                offsetConsideration := mload(OneWord)\r\n\r\n                // If valid length, check that offsets are within returndata.\r\n                let invalidOfferOffset := gt(offsetOffer, returndatasize())\r\n                let invalidConsiderationOffset := gt(\r\n                    offsetConsideration,\r\n                    returndatasize()\r\n                )\r\n\r\n                // Only proceed if length (and thus encoding) is valid so far.\r\n                invalidEncoding := or(\r\n                    invalidOfferOffset,\r\n                    invalidConsiderationOffset\r\n                )\r\n                if iszero(invalidEncoding) {\r\n                    // Copy length of offer array to scratch space.\r\n                    returndatacopy(0, offsetOffer, OneWord)\r\n                    offerLength := mload(0)\r\n\r\n                    // Copy length of consideration array to scratch space.\r\n                    returndatacopy(OneWord, offsetConsideration, OneWord)\r\n                    considerationLength := mload(OneWord)\r\n\r\n                    {\r\n                        // Calculate total size of offer & consideration arrays.\r\n                        let totalOfferSize := shl(\r\n                            SpentItem_size_shift,\r\n                            offerLength\r\n                        )\r\n                        let totalConsiderationSize := mul(\r\n                            ReceivedItem_size,\r\n                            considerationLength\r\n                        )\r\n\r\n                        // Add 4 words to total size to cover the offset and\r\n                        // length fields of the two arrays.\r\n                        let totalSize := add(\r\n                            FourWords,\r\n                            add(totalOfferSize, totalConsiderationSize)\r\n                        )\r\n                        // Don't continue if returndatasize exceeds 65535 bytes\r\n                        // or is greater than the calculated size.\r\n                        invalidEncoding := or(\r\n                            gt(\r\n                                or(offerLength, considerationLength),\r\n                                generateOrder_maximum_returndatasize\r\n                            ),\r\n                            gt(totalSize, returndatasize())\r\n                        )\r\n\r\n                        // Set first word of scratch space to 0 so length of\r\n                        // offer/consideration are set to 0 on invalid encoding.\r\n                        mstore(0, 0)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if iszero(invalidEncoding) {\r\n                offer := copySpentItemsAsOfferItems(\r\n                    add(offsetOffer, OneWord),\r\n                    offerLength\r\n                )\r\n\r\n                consideration := copyReceivedItemsAsConsiderationItems(\r\n                    add(offsetConsideration, OneWord),\r\n                    considerationLength\r\n                )\r\n            }\r\n\r\n            function copySpentItemsAsOfferItems(rdPtrHead, length)\r\n                -> mPtrLength\r\n            {\r\n                // Retrieve the current free memory pointer.\r\n                mPtrLength := mload(FreeMemoryPointerSlot)\r\n\r\n                // Allocate memory for the array.\r\n                mstore(\r\n                    FreeMemoryPointerSlot,\r\n                    add(\r\n                        mPtrLength,\r\n                        add(OneWord, mul(length, OfferItem_size_with_length))\r\n                    )\r\n                )\r\n\r\n                // Write the length of the array to the start of free memory.\r\n                mstore(mPtrLength, length)\r\n\r\n                // Use offset from length to minimize stack depth.\r\n                let headOffsetFromLength := OneWord\r\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\r\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\r\n\r\n                // Iterate over each element.\r\n                for {\r\n\r\n                } lt(headOffsetFromLength, headSizeWithLength) {\r\n\r\n                } {\r\n                    // Write the memory pointer to the accompanying head offset.\r\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\r\n\r\n                    // Copy itemType, token, identifier and amount.\r\n                    returndatacopy(mPtrTailNext, rdPtrHead, SpentItem_size)\r\n\r\n                    // Copy amount to endAmount.\r\n                    mstore(\r\n                        add(mPtrTailNext, Common_endAmount_offset),\r\n                        mload(add(mPtrTailNext, Common_amount_offset))\r\n                    )\r\n\r\n                    // Update read pointer, next tail pointer, and head offset.\r\n                    rdPtrHead := add(rdPtrHead, SpentItem_size)\r\n                    mPtrTailNext := add(mPtrTailNext, OfferItem_size)\r\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\r\n                }\r\n            }\r\n\r\n            function copyReceivedItemsAsConsiderationItems(rdPtrHead, length)\r\n                -> mPtrLength\r\n            {\r\n                // Retrieve the current free memory pointer.\r\n                mPtrLength := mload(FreeMemoryPointerSlot)\r\n\r\n                // Allocate memory for the array.\r\n                mstore(\r\n                    FreeMemoryPointerSlot,\r\n                    add(\r\n                        mPtrLength,\r\n                        add(\r\n                            OneWord,\r\n                            mul(length, ConsiderationItem_size_with_length)\r\n                        )\r\n                    )\r\n                )\r\n\r\n                // Write the length of the array to the start of free memory.\r\n                mstore(mPtrLength, length)\r\n\r\n                // Use offset from length to minimize stack depth.\r\n                let headOffsetFromLength := OneWord\r\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\r\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\r\n\r\n                // Iterate over each element.\r\n                for {\r\n\r\n                } lt(headOffsetFromLength, headSizeWithLength) {\r\n\r\n                } {\r\n                    // Write the memory pointer to the accompanying head offset.\r\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\r\n\r\n                    // Copy itemType, token, identifier and amount.\r\n                    returndatacopy(\r\n                        mPtrTailNext,\r\n                        rdPtrHead,\r\n                        ReceivedItem_size_excluding_recipient\r\n                    )\r\n\r\n                    // Copy amount and recipient.\r\n                    returndatacopy(\r\n                        add(mPtrTailNext, Common_endAmount_offset),\r\n                        add(rdPtrHead, Common_amount_offset),\r\n                        TwoWords\r\n                    )\r\n\r\n                    // Update read pointer, next tail pointer, and head offset.\r\n                    rdPtrHead := add(rdPtrHead, ReceivedItem_size)\r\n                    mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\r\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function returning _decodeGenerateOrderReturndata types\r\n     *      into a function returning offer and consideration types.\r\n     *\r\n     * @param inFn The input function, taking no arguments and returning an\r\n     *             error buffer, spent item array, and received item array.\r\n     *\r\n     * @return outFn The output function, taking no arguments and returning an\r\n     *               error buffer, offer array, and consideration array.\r\n     */\r\n    function _convertGetGeneratedOrderResult(\r\n        function()\r\n            internal\r\n            pure\r\n            returns (uint256, MemoryPointer, MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function()\r\n                internal\r\n                pure\r\n                returns (\r\n                    uint256,\r\n                    OfferItem[] memory,\r\n                    ConsiderationItem[] memory\r\n                ) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\r\n     *      types (e.g. the _transfer function) into a function taking\r\n     *      OfferItem, address, bytes32, and bytes types.\r\n     *\r\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\r\n     *             and bytes types (e.g. the _transfer function).\r\n     *\r\n     * @return outFn The output function, taking OfferItem, address, bytes32,\r\n     *               and bytes types.\r\n     */\r\n    function _toOfferItemInput(\r\n        function(ReceivedItem memory, address, bytes32, bytes memory)\r\n            internal inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(OfferItem memory, address, bytes32, bytes memory)\r\n                internal outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\r\n     *      types (e.g. the _transfer function) into a function taking\r\n     *      ConsiderationItem, address, bytes32, and bytes types.\r\n     *\r\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\r\n     *             and bytes types (e.g. the _transfer function).\r\n     *\r\n     * @return outFn The output function, taking ConsiderationItem, address,\r\n     *               bytes32, and bytes types.\r\n     */\r\n    function _toConsiderationItemInput(\r\n        function(ReceivedItem memory, address, bytes32, bytes memory)\r\n            internal inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\r\n                internal outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      an OrderParameters type.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning an OrderParameters type.\r\n     */\r\n    function _toOrderParametersReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (OrderParameters memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      an AdvancedOrder type.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning an AdvancedOrder type.\r\n     */\r\n    function _toAdvancedOrderReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (AdvancedOrder memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      a dynamic array of CriteriaResolver types.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning a dynamic array of CriteriaResolver types.\r\n     */\r\n    function _toCriteriaResolversReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (CriteriaResolver[] memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      a dynamic array of Order types.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning a dynamic array of Order types.\r\n     */\r\n    function _toOrdersReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (Order[] memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      a nested dynamic array of dynamic arrays of FulfillmentComponent\r\n     *      types.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning a nested dynamic array of dynamic arrays of\r\n     *               FulfillmentComponent types.\r\n     */\r\n    function _toNestedFulfillmentComponentsReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (FulfillmentComponent[][] memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      a dynamic array of AdvancedOrder types.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning a dynamic array of AdvancedOrder types.\r\n     */\r\n    function _toAdvancedOrdersReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (AdvancedOrder[] memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a function taking a calldata pointer and returning a memory\r\n     *      pointer into a function taking that calldata pointer and returning\r\n     *      a dynamic array of Fulfillment types.\r\n     *\r\n     * @param inFn The input function, taking an arbitrary calldata pointer and\r\n     *             returning an arbitrary memory pointer.\r\n     *\r\n     * @return outFn The output function, taking an arbitrary calldata pointer\r\n     *               and returning a dynamic array of Fulfillment types.\r\n     */\r\n    function _toFulfillmentsReturnType(\r\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            function(CalldataPointer)\r\n                internal\r\n                pure\r\n                returns (Fulfillment[] memory) outFn\r\n        )\r\n    {\r\n        assembly {\r\n            outFn := inFn\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an offer item into a received item, applying a given\r\n     *      recipient.\r\n     *\r\n     * @param offerItem The offer item.\r\n     * @param recipient The recipient.\r\n     *\r\n     * @return receivedItem The received item.\r\n     */\r\n    function _fromOfferItemToReceivedItemWithRecipient(\r\n        OfferItem memory offerItem,\r\n        address recipient\r\n    ) internal pure returns (ReceivedItem memory receivedItem) {\r\n        assembly {\r\n            receivedItem := offerItem\r\n            mstore(add(receivedItem, ReceivedItem_recipient_offset), recipient)\r\n        }\r\n    }\r\n}\r\ncontract ConsiderationEncoder {\r\n    /**\r\n     * @dev Takes a bytes array and casts it to a memory pointer.\r\n     *\r\n     * @param obj A bytes array in memory.\r\n     *\r\n     * @return ptr A memory pointer to the start of the bytes array in memory.\r\n     */\r\n    function toMemoryPointer(\r\n        bytes memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an array of bytes32 types and casts it to a memory pointer.\r\n     *\r\n     * @param obj An array of bytes32 types in memory.\r\n     *\r\n     * @return ptr A memory pointer to the start of the array of bytes32 types\r\n     *             in memory.\r\n     */\r\n    function toMemoryPointer(\r\n        bytes32[] memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a bytes array in memory and copies it to a new location in\r\n     *      memory.\r\n     *\r\n     * @param src A memory pointer referencing the bytes array to be copied (and\r\n     *            pointing to the length of the bytes array).\r\n     * @param src A memory pointer referencing the location in memory to copy\r\n     *            the bytes array to (and pointing to the length of the copied\r\n     *            bytes array).\r\n     *\r\n     * @return size The size of the bytes array.\r\n     */\r\n    function _encodeBytes(\r\n        MemoryPointer src,\r\n        MemoryPointer dst\r\n    ) internal view returns (uint256 size) {\r\n        unchecked {\r\n            // Mask the length of the bytes array to protect against overflow\r\n            // and round up to the nearest word.\r\n            // Note: `size` also includes the 1 word that stores the length.\r\n            size = (src.readUint256() + SixtyThreeBytes) & OnlyFullWordMask;\r\n\r\n            // Copy the bytes array to the new memory location.\r\n            src.copy(dst, size);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an OrderParameters struct and a context bytes array in memory\r\n     *      and encodes it as `generateOrder` calldata.\r\n     *\r\n     * @param orderParameters The OrderParameters struct used to construct the\r\n     *                        encoded `generateOrder` calldata.\r\n     * @param context         The context bytes array used to construct the\r\n     *                        encoded `generateOrder` calldata.\r\n     *\r\n     * @return dst  A memory pointer referencing the encoded `generateOrder`\r\n     *              calldata.\r\n     * @return size The size of the bytes array.\r\n     */\r\n    function _encodeGenerateOrder(\r\n        OrderParameters memory orderParameters,\r\n        bytes memory context\r\n    ) internal view returns (MemoryPointer dst, uint256 size) {\r\n        // Get the memory pointer for the OrderParameters struct.\r\n        MemoryPointer src = orderParameters.toMemoryPointer();\r\n\r\n        // Get free memory pointer to write calldata to.\r\n        dst = getFreeMemoryPointer();\r\n\r\n        // Write generateOrder selector and get pointer to start of calldata.\r\n        dst.write(generateOrder_selector);\r\n        dst = dst.offset(generateOrder_selector_offset);\r\n\r\n        // Get pointer to the beginning of the encoded data.\r\n        MemoryPointer dstHead = dst.offset(generateOrder_head_offset);\r\n\r\n        // Write `fulfiller` to calldata.\r\n        dstHead.write(msg.sender);\r\n\r\n        // Initialize tail offset, used to populate the minimumReceived array.\r\n        uint256 tailOffset = generateOrder_base_tail_offset;\r\n\r\n        // Write offset to minimumReceived.\r\n        dstHead.offset(generateOrder_minimumReceived_head_offset).write(\r\n            tailOffset\r\n        );\r\n\r\n        // Get memory pointer to `orderParameters.offer.length`.\r\n        MemoryPointer srcOfferPointer = src\r\n            .offset(OrderParameters_offer_head_offset)\r\n            .readMemoryPointer();\r\n\r\n        // Encode the offer array as a `SpentItem[]`.\r\n        uint256 minimumReceivedSize = _encodeSpentItems(\r\n            srcOfferPointer,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate maximumSpent array.\r\n            tailOffset += minimumReceivedSize;\r\n        }\r\n\r\n        // Write offset to maximumSpent.\r\n        dstHead.offset(generateOrder_maximumSpent_head_offset).write(\r\n            tailOffset\r\n        );\r\n\r\n        // Get memory pointer to `orderParameters.consideration.length`.\r\n        MemoryPointer srcConsiderationPointer = src\r\n            .offset(OrderParameters_consideration_head_offset)\r\n            .readMemoryPointer();\r\n\r\n        // Encode the consideration array as a `SpentItem[]`.\r\n        uint256 maximumSpentSize = _encodeSpentItems(\r\n            srcConsiderationPointer,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate context array.\r\n            tailOffset += maximumSpentSize;\r\n        }\r\n\r\n        // Write offset to context.\r\n        dstHead.offset(generateOrder_context_head_offset).write(tailOffset);\r\n\r\n        // Get memory pointer to context.\r\n        MemoryPointer srcContext = toMemoryPointer(context);\r\n\r\n        // Encode context as a bytes array.\r\n        uint256 contextSize = _encodeBytes(\r\n            srcContext,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment the tail offset, now used to determine final size.\r\n            tailOffset += contextSize;\r\n\r\n            // Derive the final size by including the selector.\r\n            size = Selector_length + tailOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an order hash (e.g. offerer shifted 96 bits to the left XOR'd\r\n     *      with the contract nonce in the case of contract orders), an\r\n     *      OrderParameters struct, context bytes array, and an array of order\r\n     *      hashes for each order included as part of the current fulfillment\r\n     *      and encodes it as `ratifyOrder` calldata.\r\n     *\r\n     * @param orderHash       The order hash (e.g. shl(0x60, offerer) ^ nonce).\r\n     * @param orderParameters The OrderParameters struct used to construct the\r\n     *                        encoded `ratifyOrder` calldata.\r\n     * @param context         The context bytes array used to construct the\r\n     *                        encoded `ratifyOrder` calldata.\r\n     * @param orderHashes     An array of bytes32 values representing the order\r\n     *                        hashes of all orders included as part of the\r\n     *                        current fulfillment.\r\n     * @param shiftedOfferer  The offerer for the order, shifted 96 bits to the\r\n     *                        left.\r\n     *\r\n     * @return dst  A memory pointer referencing the encoded `ratifyOrder`\r\n     *              calldata.\r\n     * @return size The size of the bytes array.\r\n     */\r\n    function _encodeRatifyOrder(\r\n        bytes32 orderHash, // e.g. shl(0x60, offerer) ^ contract nonce\r\n        OrderParameters memory orderParameters,\r\n        bytes memory context, // encoded based on the schemaID\r\n        bytes32[] memory orderHashes,\r\n        uint256 shiftedOfferer\r\n    ) internal view returns (MemoryPointer dst, uint256 size) {\r\n        // Get free memory pointer to write calldata to. This isn't allocated as\r\n        // it is only used for a single function call.\r\n        dst = getFreeMemoryPointer();\r\n\r\n        // Write ratifyOrder selector and get pointer to start of calldata.\r\n        dst.write(ratifyOrder_selector);\r\n        dst = dst.offset(ratifyOrder_selector_offset);\r\n\r\n        // Get pointer to the beginning of the encoded data.\r\n        MemoryPointer dstHead = dst.offset(ratifyOrder_head_offset);\r\n\r\n        // Write contractNonce to calldata via xor(orderHash, shiftedOfferer).\r\n        dstHead.offset(ratifyOrder_contractNonce_offset).write(\r\n            uint256(orderHash) ^ shiftedOfferer\r\n        );\r\n\r\n        // Initialize tail offset, used to populate the offer array.\r\n        uint256 tailOffset = ratifyOrder_base_tail_offset;\r\n        MemoryPointer src = orderParameters.toMemoryPointer();\r\n\r\n        // Write offset to `offer`.\r\n        dstHead.write(tailOffset);\r\n\r\n        // Get memory pointer to `orderParameters.offer.length`.\r\n        MemoryPointer srcOfferPointer = src\r\n            .offset(OrderParameters_offer_head_offset)\r\n            .readMemoryPointer();\r\n\r\n        // Encode the offer array as a `SpentItem[]`.\r\n        uint256 offerSize = _encodeSpentItems(\r\n            srcOfferPointer,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate consideration array.\r\n            tailOffset += offerSize;\r\n        }\r\n\r\n        // Write offset to consideration.\r\n        dstHead.offset(ratifyOrder_consideration_head_offset).write(tailOffset);\r\n\r\n        // Get pointer to `orderParameters.consideration.length`.\r\n        MemoryPointer srcConsiderationPointer = src\r\n            .offset(OrderParameters_consideration_head_offset)\r\n            .readMemoryPointer();\r\n\r\n        // Encode the consideration array as a `ReceivedItem[]`.\r\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\r\n            srcConsiderationPointer,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate context array.\r\n            tailOffset += considerationSize;\r\n        }\r\n\r\n        // Write offset to context.\r\n        dstHead.offset(ratifyOrder_context_head_offset).write(tailOffset);\r\n\r\n        // Encode context.\r\n        uint256 contextSize = _encodeBytes(\r\n            toMemoryPointer(context),\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate orderHashes array.\r\n            tailOffset += contextSize;\r\n        }\r\n\r\n        // Write offset to orderHashes.\r\n        dstHead.offset(ratifyOrder_orderHashes_head_offset).write(tailOffset);\r\n\r\n        // Encode orderHashes.\r\n        uint256 orderHashesSize = _encodeOrderHashes(\r\n            toMemoryPointer(orderHashes),\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment the tail offset, now used to determine final size.\r\n            tailOffset += orderHashesSize;\r\n\r\n            // Derive the final size by including the selector.\r\n            size = Selector_length + tailOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\r\n     *      and array of order hashes for each order included as part of the\r\n     *      current fulfillment and encodes it as `validateOrder` calldata.\r\n     *      Note that future, new versions of this contract may end up writing\r\n     *      to a memory region that might have been potentially dirtied by the\r\n     *      accumulator. Since the book-keeping for the accumulator does not\r\n     *      update the free memory pointer, it will be necessary to ensure that\r\n     *      all bytes in the memory in the range [dst, dst+size) are fully\r\n     *      updated/written to in this function.\r\n     *\r\n     * @param orderHash       The order hash.\r\n     * @param orderParameters The OrderParameters struct used to construct the\r\n     *                        encoded `validateOrder` calldata.\r\n     * @param extraData       The extraData bytes array used to construct the\r\n     *                        encoded `validateOrder` calldata.\r\n     * @param orderHashes     An array of bytes32 values representing the order\r\n     *                        hashes of all orders included as part of the\r\n     *                        current fulfillment.\r\n     *\r\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\r\n     *              calldata.\r\n     * @return size The size of the bytes array.\r\n     */\r\n    function _encodeValidateOrder(\r\n        bytes32 orderHash,\r\n        OrderParameters memory orderParameters,\r\n        bytes memory extraData,\r\n        bytes32[] memory orderHashes\r\n    ) internal view returns (MemoryPointer dst, uint256 size) {\r\n        // Get free memory pointer to write calldata to. This isn't allocated as\r\n        // it is only used for a single function call.\r\n        dst = getFreeMemoryPointer();\r\n\r\n        // Write validateOrder selector and get pointer to start of calldata.\r\n        dst.write(validateOrder_selector);\r\n        dst = dst.offset(validateOrder_selector_offset);\r\n\r\n        // Get pointer to the beginning of the encoded data.\r\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\r\n\r\n        // Write offset to zoneParameters to start of calldata.\r\n        dstHead.write(validateOrder_zoneParameters_offset);\r\n\r\n        // Reuse `dstHead` as pointer to zoneParameters.\r\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\r\n\r\n        // Write orderHash and fulfiller to zoneParameters.\r\n        dstHead.writeBytes32(orderHash);\r\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\r\n\r\n        // Get the memory pointer to the order parameters struct.\r\n        MemoryPointer src = orderParameters.toMemoryPointer();\r\n\r\n        // Copy offerer, startTime, endTime and zoneHash to zoneParameters.\r\n        dstHead.offset(ZoneParameters_offerer_offset).write(src.readUint256());\r\n        dstHead.offset(ZoneParameters_startTime_offset).write(\r\n            src.offset(OrderParameters_startTime_offset).readUint256()\r\n        );\r\n        dstHead.offset(ZoneParameters_endTime_offset).write(\r\n            src.offset(OrderParameters_endTime_offset).readUint256()\r\n        );\r\n        dstHead.offset(ZoneParameters_zoneHash_offset).write(\r\n            src.offset(OrderParameters_zoneHash_offset).readUint256()\r\n        );\r\n\r\n        // Initialize tail offset, used to populate the offer array.\r\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\r\n\r\n        // Write offset to `offer`.\r\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\r\n\r\n        // Get pointer to `orderParameters.offer.length`.\r\n        MemoryPointer srcOfferPointer = src\r\n            .offset(OrderParameters_offer_head_offset)\r\n            .readMemoryPointer();\r\n\r\n        // Encode the offer array as a `SpentItem[]`.\r\n        uint256 offerSize = _encodeSpentItems(\r\n            srcOfferPointer,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate consideration array.\r\n            tailOffset += offerSize;\r\n        }\r\n\r\n        // Write offset to consideration.\r\n        dstHead.offset(ZoneParameters_consideration_head_offset).write(\r\n            tailOffset\r\n        );\r\n\r\n        // Get pointer to `orderParameters.consideration.length`.\r\n        MemoryPointer srcConsiderationPointer = src\r\n            .offset(OrderParameters_consideration_head_offset)\r\n            .readMemoryPointer();\r\n\r\n        // Encode the consideration array as a `ReceivedItem[]`.\r\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\r\n            srcConsiderationPointer,\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate extraData array.\r\n            tailOffset += considerationSize;\r\n        }\r\n\r\n        // Write offset to extraData.\r\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\r\n        // Copy extraData.\r\n        uint256 extraDataSize = _encodeBytes(\r\n            toMemoryPointer(extraData),\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate orderHashes array.\r\n            tailOffset += extraDataSize;\r\n        }\r\n\r\n        // Write offset to orderHashes.\r\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\r\n            tailOffset\r\n        );\r\n\r\n        // Encode the order hashes array.\r\n        uint256 orderHashesSize = _encodeOrderHashes(\r\n            toMemoryPointer(orderHashes),\r\n            dstHead.offset(tailOffset)\r\n        );\r\n\r\n        unchecked {\r\n            // Increment the tail offset, now used to determine final size.\r\n            tailOffset += orderHashesSize;\r\n\r\n            // Derive final size including selector and ZoneParameters pointer.\r\n            size = ZoneParameters_selectorAndPointer_length + tailOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes an order hash and BasicOrderParameters struct (from calldata)\r\n     *      and encodes it as `validateOrder` calldata.\r\n     *\r\n     * @param orderHash  The order hash.\r\n     * @param parameters The BasicOrderParameters struct used to construct the\r\n     *                   encoded `validateOrder` calldata.\r\n     *\r\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\r\n     *              calldata.\r\n     * @return size The size of the bytes array.\r\n     */\r\n    function _encodeValidateBasicOrder(\r\n        bytes32 orderHash,\r\n        BasicOrderParameters calldata parameters\r\n    ) internal view returns (MemoryPointer dst, uint256 size) {\r\n        // Get free memory pointer to write calldata to. This isn't allocated as\r\n        // it is only used for a single function call.\r\n        dst = getFreeMemoryPointer();\r\n\r\n        // Write validateOrder selector and get pointer to start of calldata.\r\n        dst.write(validateOrder_selector);\r\n        dst = dst.offset(validateOrder_selector_offset);\r\n\r\n        // Get pointer to the beginning of the encoded data.\r\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\r\n\r\n        // Write offset to zoneParameters to start of calldata.\r\n        dstHead.write(validateOrder_zoneParameters_offset);\r\n\r\n        // Reuse `dstHead` as pointer to zoneParameters.\r\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\r\n\r\n        // Write offerer, orderHash and fulfiller to zoneParameters.\r\n        dstHead.writeBytes32(orderHash);\r\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\r\n        dstHead.offset(ZoneParameters_offerer_offset).write(parameters.offerer);\r\n\r\n        // Copy startTime, endTime and zoneHash to zoneParameters.\r\n        CalldataPointer.wrap(BasicOrder_startTime_cdPtr).copy(\r\n            dstHead.offset(ZoneParameters_startTime_offset),\r\n            BasicOrder_startTimeThroughZoneHash_size\r\n        );\r\n\r\n        // Initialize tail offset, used for the offer + consideration arrays.\r\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\r\n\r\n        // Write offset to offer from event data into target calldata.\r\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\r\n\r\n        unchecked {\r\n            // Write consideration offset next (located 5 words after offer).\r\n            dstHead.offset(ZoneParameters_consideration_head_offset).write(\r\n                tailOffset + BasicOrder_common_params_size\r\n            );\r\n\r\n            // Retrieve the offset to the length of additional recipients.\r\n            uint256 additionalRecipientsLength = CalldataPointer\r\n                .wrap(BasicOrder_additionalRecipients_length_cdPtr)\r\n                .readUint256();\r\n\r\n            // Derive offset to event data using base offset & total recipients.\r\n            uint256 offerDataOffset = OrderFulfilled_offer_length_baseOffset +\r\n                additionalRecipientsLength *\r\n                OneWord;\r\n\r\n            // Derive size of offer and consideration data.\r\n            // 2 words (lengths) + 4 (offer data) + 5 (consideration 1) + 5 * ar\r\n            uint256 offerAndConsiderationSize = OrderFulfilled_baseDataSize +\r\n                (additionalRecipientsLength * ReceivedItem_size);\r\n\r\n            // Copy offer and consideration data from event data to calldata.\r\n            MemoryPointer.wrap(offerDataOffset).copy(\r\n                dstHead.offset(tailOffset),\r\n                offerAndConsiderationSize\r\n            );\r\n\r\n            // Increment tail offset, now used to populate extraData array.\r\n            tailOffset += offerAndConsiderationSize;\r\n        }\r\n\r\n        // Write empty bytes for extraData.\r\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\r\n        dstHead.offset(tailOffset).write(0);\r\n\r\n        unchecked {\r\n            // Increment tail offset, now used to populate orderHashes array.\r\n            tailOffset += OneWord;\r\n        }\r\n\r\n        // Write offset to orderHashes.\r\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\r\n            tailOffset\r\n        );\r\n\r\n        // Write length = 1 to the orderHashes array.\r\n        dstHead.offset(tailOffset).write(1);\r\n\r\n        unchecked {\r\n            // Write the single order hash to the orderHashes array.\r\n            dstHead.offset(tailOffset + OneWord).writeBytes32(orderHash);\r\n\r\n            // Final size: selector, ZoneParameters pointer, orderHashes & tail.\r\n            size = ZoneParameters_basicOrderFixedElements_length + tailOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a memory pointer to an array of bytes32 values representing\r\n     *      the order hashes included as part of the fulfillment and a memory\r\n     *      pointer to a location to copy it to, and copies the source data to\r\n     *      the destination in memory.\r\n     *\r\n     * @param srcLength A memory pointer referencing the order hashes array to\r\n     *                  be copied (and pointing to the length of the array).\r\n     * @param dstLength A memory pointer referencing the location in memory to\r\n     *                  copy the orderHashes array to (and pointing to the\r\n     *                  length of the copied array).\r\n     *\r\n     * @return size The size of the order hashes array (including the length).\r\n     */\r\n    function _encodeOrderHashes(\r\n        MemoryPointer srcLength,\r\n        MemoryPointer dstLength\r\n    ) internal view returns (uint256 size) {\r\n        // Read length of the array from source and write to destination.\r\n        uint256 length = srcLength.readUint256();\r\n        dstLength.write(length);\r\n\r\n        unchecked {\r\n            // Determine head & tail size as one word per element in the array.\r\n            uint256 headAndTailSize = length << OneWordShift;\r\n\r\n            // Copy the tail starting from the next element of the source to the\r\n            // next element of the destination.\r\n            srcLength.next().copy(dstLength.next(), headAndTailSize);\r\n\r\n            // Set size to the length of the tail plus one word for length.\r\n            size = headAndTailSize + OneWord;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a memory pointer to an offer or consideration array and a\r\n     *      memory pointer to a location to copy it to, and copies the source\r\n     *      data to the destination in memory as a SpentItem array.\r\n     *\r\n     * @param srcLength A memory pointer referencing the offer or consideration\r\n     *                  array to be copied as a SpentItem array (and pointing to\r\n     *                  the length of the original array).\r\n     * @param dstLength A memory pointer referencing the location in memory to\r\n     *                  copy the offer array to (and pointing to the length of\r\n     *                  the copied array).\r\n     *\r\n     * @return size The size of the SpentItem array (including the length).\r\n     */\r\n    function _encodeSpentItems(\r\n        MemoryPointer srcLength,\r\n        MemoryPointer dstLength\r\n    ) internal pure returns (uint256 size) {\r\n        assembly {\r\n            // Read length of the array from source and write to destination.\r\n            let length := mload(srcLength)\r\n            mstore(dstLength, length)\r\n\r\n            // Get pointer to first item's head position in the array,\r\n            // containing the item's pointer in memory. The head pointer will be\r\n            // incremented until it reaches the tail position (start of the\r\n            // array data).\r\n            let mPtrHead := add(srcLength, OneWord)\r\n\r\n            // Position in memory to write next item for calldata. Since\r\n            // SpentItem has a fixed length, the array elements do not contain\r\n            // head elements in calldata, they are concatenated together after\r\n            // the array length.\r\n            let cdPtrData := add(dstLength, OneWord)\r\n\r\n            // Pointer to end of array head in memory.\r\n            let mPtrHeadEnd := add(mPtrHead, shl(OneWordShift, length))\r\n\r\n            for {\r\n\r\n            } lt(mPtrHead, mPtrHeadEnd) {\r\n\r\n            } {\r\n                // Read pointer to data for array element from head position.\r\n                let mPtrTail := mload(mPtrHead)\r\n\r\n                // Copy itemType, token, identifier, amount to calldata.\r\n                mstore(cdPtrData, mload(mPtrTail))\r\n                mstore(\r\n                    add(cdPtrData, Common_token_offset),\r\n                    mload(add(mPtrTail, Common_token_offset))\r\n                )\r\n                mstore(\r\n                    add(cdPtrData, Common_identifier_offset),\r\n                    mload(add(mPtrTail, Common_identifier_offset))\r\n                )\r\n                mstore(\r\n                    add(cdPtrData, Common_amount_offset),\r\n                    mload(add(mPtrTail, Common_amount_offset))\r\n                )\r\n\r\n                mPtrHead := add(mPtrHead, OneWord)\r\n                cdPtrData := add(cdPtrData, SpentItem_size)\r\n            }\r\n\r\n            size := add(OneWord, shl(SpentItem_size_shift, length))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes a memory pointer to an consideration array and a memory\r\n     *      pointer to a location to copy it to, and copies the source data to\r\n     *      the destination in memory as a ReceivedItem array.\r\n     *\r\n     * @param srcLength A memory pointer referencing the consideration array to\r\n     *                  be copied as a ReceivedItem array (and pointing to the\r\n     *                  length of the original array).\r\n     * @param dstLength A memory pointer referencing the location in memory to\r\n     *                  copy the consideration array to as a ReceivedItem array\r\n     *                  (and pointing to the length of the new array).\r\n     *\r\n     * @return size The size of the ReceivedItem array (including the length).\r\n     */\r\n    function _encodeConsiderationAsReceivedItems(\r\n        MemoryPointer srcLength,\r\n        MemoryPointer dstLength\r\n    ) internal view returns (uint256 size) {\r\n        unchecked {\r\n            // Read length of the array from source and write to destination.\r\n            uint256 length = srcLength.readUint256();\r\n            dstLength.write(length);\r\n\r\n            // Get pointer to first item's head position in the array,\r\n            // containing the item's pointer in memory. The head pointer will be\r\n            // incremented until it reaches the tail position (start of the\r\n            // array data).\r\n            MemoryPointer srcHead = srcLength.next();\r\n            MemoryPointer srcHeadEnd = srcHead.offset(length << OneWordShift);\r\n\r\n            // Position in memory to write next item for calldata. Since\r\n            // ReceivedItem has a fixed length, the array elements do not\r\n            // contain offsets in calldata, they are concatenated together after\r\n            // the array length.\r\n            MemoryPointer dstHead = dstLength.next();\r\n            while (srcHead.lt(srcHeadEnd)) {\r\n                MemoryPointer srcTail = srcHead.pptr();\r\n                srcTail.copy(dstHead, ReceivedItem_size);\r\n                srcHead = srcHead.next();\r\n                dstHead = dstHead.offset(ReceivedItem_size);\r\n            }\r\n\r\n            size = OneWord + (length * ReceivedItem_size);\r\n        }\r\n    }\r\n}\r\ninterface ConsiderationEventsAndErrors {\r\n    /**\r\n     * @dev Emit an event whenever an order is successfully fulfilled.\r\n     *\r\n     * @param orderHash     The hash of the fulfilled order.\r\n     * @param offerer       The offerer of the fulfilled order.\r\n     * @param zone          The zone of the fulfilled order.\r\n     * @param recipient     The recipient of each spent item on the fulfilled\r\n     *                      order, or the null address if there is no specific\r\n     *                      fulfiller (i.e. the order is part of a group of\r\n     *                      orders). Defaults to the caller unless explicitly\r\n     *                      specified otherwise by the fulfiller.\r\n     * @param offer         The offer items spent as part of the order.\r\n     * @param consideration The consideration items received as part of the\r\n     *                      order along with the recipients of each item.\r\n     */\r\n    event OrderFulfilled(\r\n        bytes32 orderHash,\r\n        address indexed offerer,\r\n        address indexed zone,\r\n        address recipient,\r\n        SpentItem[] offer,\r\n        ReceivedItem[] consideration\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever an order is successfully cancelled.\r\n     *\r\n     * @param orderHash The hash of the cancelled order.\r\n     * @param offerer   The offerer of the cancelled order.\r\n     * @param zone      The zone of the cancelled order.\r\n     */\r\n    event OrderCancelled(\r\n        bytes32 orderHash,\r\n        address indexed offerer,\r\n        address indexed zone\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever an order is explicitly validated. Note that\r\n     *      this event will not be emitted on partial fills even though they do\r\n     *      validate the order as part of partial fulfillment.\r\n     *\r\n     * @param orderHash        The hash of the validated order.\r\n     * @param orderParameters  The parameters of the validated order.\r\n     */\r\n    event OrderValidated(bytes32 orderHash, OrderParameters orderParameters);\r\n\r\n    /**\r\n     * @dev Emit an event whenever one or more orders are matched using either\r\n     *      matchOrders or matchAdvancedOrders.\r\n     *\r\n     * @param orderHashes The order hashes of the matched orders.\r\n     */\r\n    event OrdersMatched(bytes32[] orderHashes);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\r\n     *\r\n     * @param newCounter The new counter for the offerer.\r\n     * @param offerer    The offerer in question.\r\n     */\r\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill an order that has\r\n     *      already been fully filled.\r\n     *\r\n     * @param orderHash The order hash on which a fill was attempted.\r\n     */\r\n    error OrderAlreadyFilled(bytes32 orderHash);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill an order outside the\r\n     *      specified start time and end time.\r\n     *\r\n     * @param startTime The time at which the order becomes active.\r\n     * @param endTime   The time at which the order becomes inactive.\r\n     */\r\n    error InvalidTime(uint256 startTime, uint256 endTime);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill an order referencing an\r\n     *      invalid conduit (i.e. one that has not been deployed).\r\n     */\r\n    error InvalidConduit(bytes32 conduitKey, address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when an order is supplied for fulfillment with\r\n     *      a consideration array that is shorter than the original array.\r\n     */\r\n    error MissingOriginalConsiderationItems();\r\n\r\n    /**\r\n     * @dev Revert with an error when an order is validated and the length of\r\n     *      the consideration array is not equal to the supplied total original\r\n     *      consideration items value. This error is also thrown when contract\r\n     *      orders supply a total original consideration items value that does\r\n     *      not match the supplied consideration array length.\r\n     */\r\n    error ConsiderationLengthNotEqualToTotalOriginal();\r\n\r\n    /**\r\n     * @dev Revert with an error when a call to a conduit fails with revert data\r\n     *      that is too expensive to return.\r\n     */\r\n    error InvalidCallToConduit(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error if a consideration amount has not been fully\r\n     *      zeroed out after applying all fulfillments.\r\n     *\r\n     * @param orderIndex         The index of the order with the consideration\r\n     *                           item with a shortfall.\r\n     * @param considerationIndex The index of the consideration item on the\r\n     *                           order.\r\n     * @param shortfallAmount    The unfulfilled consideration amount.\r\n     */\r\n    error ConsiderationNotMet(\r\n        uint256 orderIndex,\r\n        uint256 considerationIndex,\r\n        uint256 shortfallAmount\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when insufficient native tokens are supplied as\r\n     *      part of msg.value when fulfilling orders.\r\n     */\r\n    error InsufficientNativeTokensSupplied();\r\n\r\n    /**\r\n     * @dev Revert with an error when a native token transfer reverts.\r\n     */\r\n    error NativeTokenTransferGenericFailure(address account, uint256 amount);\r\n\r\n    /**\r\n     * @dev Revert with an error when a partial fill is attempted on an order\r\n     *      that does not specify partial fill support in its order type.\r\n     */\r\n    error PartialFillsNotEnabledForOrder();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill an order that has been\r\n     *      cancelled.\r\n     *\r\n     * @param orderHash The hash of the cancelled order.\r\n     */\r\n    error OrderIsCancelled(bytes32 orderHash);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill a basic order that has\r\n     *      been partially filled.\r\n     *\r\n     * @param orderHash The hash of the partially used order.\r\n     */\r\n    error OrderPartiallyFilled(bytes32 orderHash);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to cancel an order as a caller\r\n     *      other than the indicated offerer or zone or when attempting to\r\n     *      cancel a contract order.\r\n     */\r\n    error CannotCancelOrder();\r\n\r\n    /**\r\n     * @dev Revert with an error when supplying a fraction with a value of zero\r\n     *      for the numerator or denominator, or one where the numerator exceeds\r\n     *      the denominator.\r\n     */\r\n    error BadFraction();\r\n\r\n    /**\r\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\r\n     *      non-payable basic order route or does not supply any callvalue to a\r\n     *      payable basic order route.\r\n     */\r\n    error InvalidMsgValue(uint256 value);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill a basic order using\r\n     *      calldata not produced by default ABI encoding.\r\n     */\r\n    error InvalidBasicOrderParameterEncoding();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fulfill any number of\r\n     *      available orders when none are fulfillable.\r\n     */\r\n    error NoSpecifiedOrdersAvailable();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fulfill an order with an\r\n     *      offer for a native token outside of matching orders.\r\n     */\r\n    error InvalidNativeOfferItem();\r\n}\r\ninterface ConduitControllerInterface {\r\n    /**\r\n     * @dev Track the conduit key, current owner, new potential owner, and open\r\n     *      channels for each deployed conduit.\r\n     */\r\n    struct ConduitProperties {\r\n        bytes32 key;\r\n        address owner;\r\n        address potentialOwner;\r\n        address[] channels;\r\n        mapping(address => uint256) channelIndexesPlusOne;\r\n    }\r\n\r\n    /**\r\n     * @dev Emit an event whenever a new conduit is created.\r\n     *\r\n     * @param conduit    The newly created conduit.\r\n     * @param conduitKey The conduit key used to create the new conduit.\r\n     */\r\n    event NewConduit(address conduit, bytes32 conduitKey);\r\n\r\n    /**\r\n     * @dev Emit an event whenever conduit ownership is transferred.\r\n     *\r\n     * @param conduit       The conduit for which ownership has been\r\n     *                      transferred.\r\n     * @param previousOwner The previous owner of the conduit.\r\n     * @param newOwner      The new owner of the conduit.\r\n     */\r\n    event OwnershipTransferred(\r\n        address indexed conduit,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a conduit owner registers a new potential\r\n     *      owner for that conduit.\r\n     *\r\n     * @param newPotentialOwner The new potential owner of the conduit.\r\n     */\r\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to create a new conduit using a\r\n     *      conduit key where the first twenty bytes of the key do not match the\r\n     *      address of the caller.\r\n     */\r\n    error InvalidCreator();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to create a new conduit when no\r\n     *      initial owner address is supplied.\r\n     */\r\n    error InvalidInitialOwner();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to set a new potential owner\r\n     *      that is already set.\r\n     */\r\n    error NewPotentialOwnerAlreadySet(\r\n        address conduit,\r\n        address newPotentialOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to cancel ownership transfer\r\n     *      when no new potential owner is currently set.\r\n     */\r\n    error NoPotentialOwnerCurrentlySet(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to interact with a conduit that\r\n     *      does not yet exist.\r\n     */\r\n    error NoConduit();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to create a conduit that\r\n     *      already exists.\r\n     */\r\n    error ConduitAlreadyExists(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to update channels or transfer\r\n     *      ownership of a conduit when the caller is not the owner of the\r\n     *      conduit in question.\r\n     */\r\n    error CallerIsNotOwner(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to register a new potential\r\n     *      owner and supplying the null address.\r\n     */\r\n    error NewPotentialOwnerIsZeroAddress(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to claim ownership of a conduit\r\n     *      with a caller that is not the current potential owner for the\r\n     *      conduit in question.\r\n     */\r\n    error CallerIsNotNewPotentialOwner(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to retrieve a channel using an\r\n     *      index that is out of range.\r\n     */\r\n    error ChannelOutOfRange(address conduit);\r\n\r\n    /**\r\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\r\n     *         an initial owner for the deployed conduit. Note that the first\r\n     *         twenty bytes of the supplied conduit key must match the caller\r\n     *         and that a new conduit cannot be created if one has already been\r\n     *         deployed using the same conduit key.\r\n     *\r\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\r\n     *                     the first twenty bytes of the conduit key must match\r\n     *                     the caller of this contract.\r\n     * @param initialOwner The initial owner to set for the new conduit.\r\n     *\r\n     * @return conduit The address of the newly deployed conduit.\r\n     */\r\n    function createConduit(\r\n        bytes32 conduitKey,\r\n        address initialOwner\r\n    ) external returns (address conduit);\r\n\r\n    /**\r\n     * @notice Open or close a channel on a given conduit, thereby allowing the\r\n     *         specified account to execute transfers against that conduit.\r\n     *         Extreme care must be taken when updating channels, as malicious\r\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\r\n     *         tokens where the token holder has granted the conduit approval.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to open or close the channel.\r\n     * @param channel The channel to open or close on the conduit.\r\n     * @param isOpen  A boolean indicating whether to open or close the channel.\r\n     */\r\n    function updateChannel(\r\n        address conduit,\r\n        address channel,\r\n        bool isOpen\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Initiate conduit ownership transfer by assigning a new potential\r\n     *         owner for the given conduit. Once set, the new potential owner\r\n     *         may call `acceptOwnership` to claim ownership of the conduit.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to initiate ownership transfer.\r\n     * @param newPotentialOwner The new potential owner of the conduit.\r\n     */\r\n    function transferOwnership(\r\n        address conduit,\r\n        address newPotentialOwner\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Clear the currently set potential owner, if any, from a conduit.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to cancel ownership transfer.\r\n     */\r\n    function cancelOwnershipTransfer(address conduit) external;\r\n\r\n    /**\r\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\r\n     *         current owner has set as the new potential owner may call this\r\n     *         function.\r\n     *\r\n     * @param conduit The conduit for which to accept ownership.\r\n     */\r\n    function acceptOwnership(address conduit) external;\r\n\r\n    /**\r\n     * @notice Retrieve the current owner of a deployed conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the associated owner.\r\n     *\r\n     * @return owner The owner of the supplied conduit.\r\n     */\r\n    function ownerOf(address conduit) external view returns (address owner);\r\n\r\n    /**\r\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\r\n     *         lookup.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the associated conduit\r\n     *                key.\r\n     *\r\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\r\n     */\r\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\r\n\r\n    /**\r\n     * @notice Derive the conduit associated with a given conduit key and\r\n     *         determine whether that conduit exists (i.e. whether it has been\r\n     *         deployed).\r\n     *\r\n     * @param conduitKey The conduit key used to derive the conduit.\r\n     *\r\n     * @return conduit The derived address of the conduit.\r\n     * @return exists  A boolean indicating whether the derived conduit has been\r\n     *                 deployed or not.\r\n     */\r\n    function getConduit(\r\n        bytes32 conduitKey\r\n    ) external view returns (address conduit, bool exists);\r\n\r\n    /**\r\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\r\n     *         current owner may set a new potential owner via\r\n     *         `transferOwnership` and that owner may then accept ownership of\r\n     *         the conduit in question via `acceptOwnership`.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the potential owner.\r\n     *\r\n     * @return potentialOwner The potential owner, if any, for the conduit.\r\n     */\r\n    function getPotentialOwner(\r\n        address conduit\r\n    ) external view returns (address potentialOwner);\r\n\r\n    /**\r\n     * @notice Retrieve the status (either open or closed) of a given channel on\r\n     *         a conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the channel status.\r\n     * @param channel The channel for which to retrieve the status.\r\n     *\r\n     * @return isOpen The status of the channel on the given conduit.\r\n     */\r\n    function getChannelStatus(\r\n        address conduit,\r\n        address channel\r\n    ) external view returns (bool isOpen);\r\n\r\n    /**\r\n     * @notice Retrieve the total number of open channels for a given conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the total channel count.\r\n     *\r\n     * @return totalChannels The total number of open channels for the conduit.\r\n     */\r\n    function getTotalChannels(\r\n        address conduit\r\n    ) external view returns (uint256 totalChannels);\r\n\r\n    /**\r\n     * @notice Retrieve an open channel at a specific index for a given conduit.\r\n     *         Note that the index of a channel can change as a result of other\r\n     *         channels being closed on the conduit.\r\n     *\r\n     * @param conduit      The conduit for which to retrieve the open channel.\r\n     * @param channelIndex The index of the channel in question.\r\n     *\r\n     * @return channel The open channel, if any, at the specified channel index.\r\n     */\r\n    function getChannel(\r\n        address conduit,\r\n        uint256 channelIndex\r\n    ) external view returns (address channel);\r\n\r\n    /**\r\n     * @notice Retrieve all open channels for a given conduit. Note that calling\r\n     *         this function for a conduit with many channels will revert with\r\n     *         an out-of-gas error.\r\n     *\r\n     * @param conduit The conduit for which to retrieve open channels.\r\n     *\r\n     * @return channels An array of open channels on the given conduit.\r\n     */\r\n    function getChannels(\r\n        address conduit\r\n    ) external view returns (address[] memory channels);\r\n\r\n    /**\r\n     * @dev Retrieve the conduit creation code and runtime code hashes.\r\n     */\r\n    function getConduitCodeHashes()\r\n        external\r\n        view\r\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\r\n}\r\n\r\ncontract ConsiderationBase is\r\n    ConsiderationDecoder,\r\n    ConsiderationEncoder,\r\n    ConsiderationEventsAndErrors\r\n{\r\n    // Precompute hashes, original chainId, and domain separator on deployment.\r\n    bytes32 internal immutable _NAME_HASH;\r\n    bytes32 internal immutable _VERSION_HASH;\r\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\r\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\r\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\r\n    bytes32 internal immutable _ORDER_TYPEHASH;\r\n    uint256 internal immutable _CHAIN_ID;\r\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\r\n\r\n    // Allow for interaction with the conduit controller.\r\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\r\n\r\n    // Cache the conduit creation code hash used by the conduit controller.\r\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\r\n\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) {\r\n        // Derive name and version hashes alongside required EIP-712 typehashes.\r\n        (\r\n            _NAME_HASH,\r\n            _VERSION_HASH,\r\n            _EIP_712_DOMAIN_TYPEHASH,\r\n            _OFFER_ITEM_TYPEHASH,\r\n            _CONSIDERATION_ITEM_TYPEHASH,\r\n            _ORDER_TYPEHASH\r\n        ) = _deriveTypehashes();\r\n\r\n        // Store the current chainId and derive the current domain separator.\r\n        _CHAIN_ID = block.chainid;\r\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\r\n\r\n        // Set the supplied conduit controller.\r\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\r\n\r\n        // Retrieve the conduit creation code hash from the supplied controller.\r\n        (_CONDUIT_CREATION_CODE_HASH, ) = (\r\n            _CONDUIT_CONTROLLER.getConduitCodeHashes()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to derive the EIP-712 domain separator.\r\n     *\r\n     * @return domainSeparator The derived domain separator.\r\n     */\r\n    function _deriveDomainSeparator()\r\n        internal\r\n        view\r\n        returns (bytes32 domainSeparator)\r\n    {\r\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\r\n        bytes32 nameHash = _NAME_HASH;\r\n        bytes32 versionHash = _VERSION_HASH;\r\n\r\n        // Leverage scratch space and other memory to perform an efficient hash.\r\n        assembly {\r\n            // Retrieve the free memory pointer; it will be replaced afterwards.\r\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\r\n\r\n            // Retrieve value at 0x80; it will also be replaced afterwards.\r\n            let slot0x80 := mload(Slot0x80)\r\n\r\n            // Place typehash, name hash, and version hash at start of memory.\r\n            mstore(0, typehash)\r\n            mstore(EIP712_domainData_nameHash_offset, nameHash)\r\n            mstore(EIP712_domainData_versionHash_offset, versionHash)\r\n\r\n            // Place chainId in the next memory location.\r\n            mstore(EIP712_domainData_chainId_offset, chainid())\r\n\r\n            // Place the address of this contract in the next memory location.\r\n            mstore(EIP712_domainData_verifyingContract_offset, address())\r\n\r\n            // Hash relevant region of memory to derive the domain separator.\r\n            domainSeparator := keccak256(0, EIP712_domainData_size)\r\n\r\n            // Restore the free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n\r\n            // Restore the value at 0x80.\r\n            mstore(Slot0x80, slot0x80)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to retrieve the default name of this\r\n     *      contract and return.\r\n     *\r\n     * @return The name of this contract.\r\n     */\r\n    function _name() internal pure virtual returns (string memory) {\r\n        // Return the name of the contract.\r\n        assembly {\r\n            // First element is the offset for the returned string. Offset the\r\n            // value in memory by one word so that the free memory pointer will\r\n            // be overwritten by the next write.\r\n            mstore(OneWord, OneWord)\r\n\r\n            // Name is right padded, so it touches the length which is left\r\n            // padded. This enables writing both values at once. The free memory\r\n            // pointer will be overwritten in the process.\r\n            mstore(NameLengthPtr, NameWithLength)\r\n\r\n            // Standard ABI encoding pads returned data to the nearest word. Use\r\n            // the already empty zero slot memory region for this purpose and\r\n            // return the final name string, offset by the original single word.\r\n            return(OneWord, ThreeWords)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to retrieve the default name of this contract\r\n     *      as a string that can be used internally.\r\n     *\r\n     * @return The name of this contract.\r\n     */\r\n    function _nameString() internal pure virtual returns (string memory) {\r\n        // Return the name of the contract.\r\n        return \"Consideration\";\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to derive required EIP-712 typehashes and\r\n     *      other hashes during contract creation.\r\n     *\r\n     * @return nameHash                  The hash of the name of the contract.\r\n     * @return versionHash               The hash of the version string of the\r\n     *                                   contract.\r\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\r\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\r\n     *                                   types.\r\n     * @return considerationItemTypehash The EIP-712 typehash for\r\n     *                                   ConsiderationItem types.\r\n     * @return orderTypehash             The EIP-712 typehash for Order types.\r\n     */\r\n    function _deriveTypehashes()\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes32 nameHash,\r\n            bytes32 versionHash,\r\n            bytes32 eip712DomainTypehash,\r\n            bytes32 offerItemTypehash,\r\n            bytes32 considerationItemTypehash,\r\n            bytes32 orderTypehash\r\n        )\r\n    {\r\n        // Derive hash of the name of the contract.\r\n        nameHash = keccak256(bytes(_nameString()));\r\n\r\n        // Derive hash of the version string of the contract.\r\n        versionHash = keccak256(bytes(\"1.4\"));\r\n\r\n        // Construct the OfferItem type string.\r\n        bytes memory offerItemTypeString = bytes(\r\n            \"OfferItem(\"\r\n            \"uint8 itemType,\"\r\n            \"address token,\"\r\n            \"uint256 identifierOrCriteria,\"\r\n            \"uint256 startAmount,\"\r\n            \"uint256 endAmount\"\r\n            \")\"\r\n        );\r\n\r\n        // Construct the ConsiderationItem type string.\r\n        bytes memory considerationItemTypeString = bytes(\r\n            \"ConsiderationItem(\"\r\n            \"uint8 itemType,\"\r\n            \"address token,\"\r\n            \"uint256 identifierOrCriteria,\"\r\n            \"uint256 startAmount,\"\r\n            \"uint256 endAmount,\"\r\n            \"address recipient\"\r\n            \")\"\r\n        );\r\n\r\n        // Construct the OrderComponents type string, not including the above.\r\n        bytes memory orderComponentsPartialTypeString = bytes(\r\n            \"OrderComponents(\"\r\n            \"address offerer,\"\r\n            \"address zone,\"\r\n            \"OfferItem[] offer,\"\r\n            \"ConsiderationItem[] consideration,\"\r\n            \"uint8 orderType,\"\r\n            \"uint256 startTime,\"\r\n            \"uint256 endTime,\"\r\n            \"bytes32 zoneHash,\"\r\n            \"uint256 salt,\"\r\n            \"bytes32 conduitKey,\"\r\n            \"uint256 counter\"\r\n            \")\"\r\n        );\r\n\r\n        // Construct the primary EIP-712 domain type string.\r\n        eip712DomainTypehash = keccak256(\r\n            bytes(\r\n                \"EIP712Domain(\"\r\n                \"string name,\"\r\n                \"string version,\"\r\n                \"uint256 chainId,\"\r\n                \"address verifyingContract\"\r\n                \")\"\r\n            )\r\n        );\r\n\r\n        // Derive the OfferItem type hash using the corresponding type string.\r\n        offerItemTypehash = keccak256(offerItemTypeString);\r\n\r\n        // Derive ConsiderationItem type hash using corresponding type string.\r\n        considerationItemTypehash = keccak256(considerationItemTypeString);\r\n\r\n        bytes memory orderTypeString = bytes.concat(\r\n            orderComponentsPartialTypeString,\r\n            considerationItemTypeString,\r\n            offerItemTypeString\r\n        );\r\n\r\n        // Derive OrderItem type hash via combination of relevant type strings.\r\n        orderTypehash = keccak256(orderTypeString);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to look up one of twenty-four potential bulk\r\n     *      order typehash constants based on the height of the bulk order tree.\r\n     *      Note that values between one and twenty-four are supported, which is\r\n     *      enforced by _isValidBulkOrderSize.\r\n     *\r\n     * @param _treeHeight The height of the bulk order tree. The value must be\r\n     *                    between one and twenty-four.\r\n     *\r\n     * @return _typeHash The EIP-712 typehash for the bulk order type with the\r\n     *                   given height.\r\n     */\r\n    function _lookupBulkOrderTypehash(\r\n        uint256 _treeHeight\r\n    ) internal pure returns (bytes32 _typeHash) {\r\n        // Utilize assembly to efficiently retrieve correct bulk order typehash.\r\n        assembly {\r\n            // Use a Yul function to enable use of the `leave` keyword\r\n            // to stop searching once the appropriate type hash is found.\r\n            function lookupTypeHash(treeHeight) -> typeHash {\r\n                // Handle tree heights one through eight.\r\n                if lt(treeHeight, 9) {\r\n                    // Handle tree heights one through four.\r\n                    if lt(treeHeight, 5) {\r\n                        // Handle tree heights one and two.\r\n                        if lt(treeHeight, 3) {\r\n                            // Utilize branchless logic to determine typehash.\r\n                            typeHash := ternary(\r\n                                eq(treeHeight, 1),\r\n                                BulkOrder_Typehash_Height_One,\r\n                                BulkOrder_Typehash_Height_Two\r\n                            )\r\n\r\n                            // Exit the function once typehash has been located.\r\n                            leave\r\n                        }\r\n\r\n                        // Handle height three and four via branchless logic.\r\n                        typeHash := ternary(\r\n                            eq(treeHeight, 3),\r\n                            BulkOrder_Typehash_Height_Three,\r\n                            BulkOrder_Typehash_Height_Four\r\n                        )\r\n\r\n                        // Exit the function once typehash has been located.\r\n                        leave\r\n                    }\r\n\r\n                    // Handle tree height five and six.\r\n                    if lt(treeHeight, 7) {\r\n                        // Utilize branchless logic to determine typehash.\r\n                        typeHash := ternary(\r\n                            eq(treeHeight, 5),\r\n                            BulkOrder_Typehash_Height_Five,\r\n                            BulkOrder_Typehash_Height_Six\r\n                        )\r\n\r\n                        // Exit the function once typehash has been located.\r\n                        leave\r\n                    }\r\n\r\n                    // Handle height seven and eight via branchless logic.\r\n                    typeHash := ternary(\r\n                        eq(treeHeight, 7),\r\n                        BulkOrder_Typehash_Height_Seven,\r\n                        BulkOrder_Typehash_Height_Eight\r\n                    )\r\n\r\n                    // Exit the function once typehash has been located.\r\n                    leave\r\n                }\r\n\r\n                // Handle tree height nine through sixteen.\r\n                if lt(treeHeight, 17) {\r\n                    // Handle tree height nine through twelve.\r\n                    if lt(treeHeight, 13) {\r\n                        // Handle tree height nine and ten.\r\n                        if lt(treeHeight, 11) {\r\n                            // Utilize branchless logic to determine typehash.\r\n                            typeHash := ternary(\r\n                                eq(treeHeight, 9),\r\n                                BulkOrder_Typehash_Height_Nine,\r\n                                BulkOrder_Typehash_Height_Ten\r\n                            )\r\n\r\n                            // Exit the function once typehash has been located.\r\n                            leave\r\n                        }\r\n\r\n                        // Handle height eleven and twelve via branchless logic.\r\n                        typeHash := ternary(\r\n                            eq(treeHeight, 11),\r\n                            BulkOrder_Typehash_Height_Eleven,\r\n                            BulkOrder_Typehash_Height_Twelve\r\n                        )\r\n\r\n                        // Exit the function once typehash has been located.\r\n                        leave\r\n                    }\r\n\r\n                    // Handle tree height thirteen and fourteen.\r\n                    if lt(treeHeight, 15) {\r\n                        // Utilize branchless logic to determine typehash.\r\n                        typeHash := ternary(\r\n                            eq(treeHeight, 13),\r\n                            BulkOrder_Typehash_Height_Thirteen,\r\n                            BulkOrder_Typehash_Height_Fourteen\r\n                        )\r\n\r\n                        // Exit the function once typehash has been located.\r\n                        leave\r\n                    }\r\n                    // Handle height fifteen and sixteen via branchless logic.\r\n                    typeHash := ternary(\r\n                        eq(treeHeight, 15),\r\n                        BulkOrder_Typehash_Height_Fifteen,\r\n                        BulkOrder_Typehash_Height_Sixteen\r\n                    )\r\n\r\n                    // Exit the function once typehash has been located.\r\n                    leave\r\n                }\r\n\r\n                // Handle tree height seventeen through twenty.\r\n                if lt(treeHeight, 21) {\r\n                    // Handle tree height seventeen and eighteen.\r\n                    if lt(treeHeight, 19) {\r\n                        // Utilize branchless logic to determine typehash.\r\n                        typeHash := ternary(\r\n                            eq(treeHeight, 17),\r\n                            BulkOrder_Typehash_Height_Seventeen,\r\n                            BulkOrder_Typehash_Height_Eighteen\r\n                        )\r\n\r\n                        // Exit the function once typehash has been located.\r\n                        leave\r\n                    }\r\n\r\n                    // Handle height nineteen and twenty via branchless logic.\r\n                    typeHash := ternary(\r\n                        eq(treeHeight, 19),\r\n                        BulkOrder_Typehash_Height_Nineteen,\r\n                        BulkOrder_Typehash_Height_Twenty\r\n                    )\r\n\r\n                    // Exit the function once typehash has been located.\r\n                    leave\r\n                }\r\n\r\n                // Handle tree height twenty-one and twenty-two.\r\n                if lt(treeHeight, 23) {\r\n                    // Utilize branchless logic to determine typehash.\r\n                    typeHash := ternary(\r\n                        eq(treeHeight, 21),\r\n                        BulkOrder_Typehash_Height_TwentyOne,\r\n                        BulkOrder_Typehash_Height_TwentyTwo\r\n                    )\r\n\r\n                    // Exit the function once typehash has been located.\r\n                    leave\r\n                }\r\n\r\n                // Handle height twenty-three & twenty-four w/ branchless logic.\r\n                typeHash := ternary(\r\n                    eq(treeHeight, 23),\r\n                    BulkOrder_Typehash_Height_TwentyThree,\r\n                    BulkOrder_Typehash_Height_TwentyFour\r\n                )\r\n\r\n                // Exit the function once typehash has been located.\r\n                leave\r\n            }\r\n\r\n            // Implement ternary conditional using branchless logic.\r\n            function ternary(cond, ifTrue, ifFalse) -> c {\r\n                c := xor(ifFalse, mul(cond, xor(ifFalse, ifTrue)))\r\n            }\r\n\r\n            // Look up the typehash using the supplied tree height.\r\n            _typeHash := lookupTypeHash(_treeHeight)\r\n        }\r\n    }\r\n}\r\n\r\nfunction _revertBadFraction() pure {\r\n    assembly {\r\n        mstore(0, BadFraction_error_selector)\r\n        revert(Error_selector_offset, BadFraction_error_length)\r\n    }\r\n}\r\nfunction _revertConsiderationNotMet(\r\n    uint256 orderIndex,\r\n    uint256 considerationIndex,\r\n    uint256 shortfallAmount\r\n) pure {\r\n    assembly {\r\n        mstore(0, ConsiderationNotMet_error_selector)\r\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\r\n        mstore(\r\n            ConsiderationNotMet_error_considerationIndex_ptr,\r\n            considerationIndex\r\n        )\r\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\r\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\r\n    }\r\n}\r\nfunction _revertCriteriaNotEnabledForItem() pure {\r\n    assembly {\r\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\r\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\r\n    }\r\n}\r\nfunction _revertInsufficientNativeTokensSupplied() pure {\r\n    assembly {\r\n        mstore(0, InsufficientNativeTokensSupplied_error_selector)\r\n        revert(\r\n            Error_selector_offset,\r\n            InsufficientNativeTokensSupplied_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\r\n    assembly {\r\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\r\n        revert(\r\n            Error_selector_offset,\r\n            InvalidBasicOrderParameterEncoding_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertInvalidCallToConduit(address conduit) pure {\r\n    assembly {\r\n        mstore(0, InvalidCallToConduit_error_selector)\r\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\r\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\r\n    }\r\n}\r\nfunction _revertCannotCancelOrder() pure {\r\n    assembly {\r\n        mstore(0, CannotCancelOrder_error_selector)\r\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\r\n    assembly {\r\n        mstore(0, InvalidConduit_error_selector)\r\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\r\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\r\n        revert(Error_selector_offset, InvalidConduit_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\r\n    assembly {\r\n        mstore(0, InvalidERC721TransferAmount_error_selector)\r\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\r\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidMsgValue(uint256 value) pure {\r\n    assembly {\r\n        mstore(0, InvalidMsgValue_error_selector)\r\n        mstore(InvalidMsgValue_error_value_ptr, value)\r\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidNativeOfferItem() pure {\r\n    assembly {\r\n        mstore(0, InvalidNativeOfferItem_error_selector)\r\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidProof() pure {\r\n    assembly {\r\n        mstore(0, InvalidProof_error_selector)\r\n        revert(Error_selector_offset, InvalidProof_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\r\n    assembly {\r\n        mstore(0, InvalidContractOrder_error_selector)\r\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\r\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\r\n    }\r\n}\r\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\r\n    assembly {\r\n        mstore(0, InvalidTime_error_selector)\r\n        mstore(InvalidTime_error_startTime_ptr, startTime)\r\n        mstore(InvalidTime_error_endTime_ptr, endTime)\r\n        revert(Error_selector_offset, InvalidTime_error_length)\r\n    }\r\n}\r\nfunction _revertMismatchedFulfillmentOfferAndConsiderationComponents(\r\n    uint256 fulfillmentIndex\r\n) pure {\r\n    assembly {\r\n        mstore(0, MismatchedOfferAndConsiderationComponents_error_selector)\r\n        mstore(\r\n            MismatchedOfferAndConsiderationComponents_error_idx_ptr,\r\n            fulfillmentIndex\r\n        )\r\n        revert(\r\n            Error_selector_offset,\r\n            MismatchedOfferAndConsiderationComponents_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\r\n    assembly {\r\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\r\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\r\n        revert(\r\n            Error_selector_offset,\r\n            MissingFulfillmentComponentOnAggregation_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertMissingOriginalConsiderationItems() pure {\r\n    assembly {\r\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\r\n        revert(\r\n            Error_selector_offset,\r\n            MissingOriginalConsiderationItems_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertNoReentrantCalls() pure {\r\n    assembly {\r\n        mstore(0, NoReentrantCalls_error_selector)\r\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\r\n    }\r\n}\r\nfunction _revertNoSpecifiedOrdersAvailable() pure {\r\n    assembly {\r\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\r\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\r\n    }\r\n}\r\nfunction _revertOfferAndConsiderationRequiredOnFulfillment() pure {\r\n    assembly {\r\n        mstore(0, OfferAndConsiderationRequiredOnFulfillment_error_selector)\r\n        revert(\r\n            Error_selector_offset,\r\n            OfferAndConsiderationRequiredOnFulfillment_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\r\n    assembly {\r\n        mstore(0, OrderAlreadyFilled_error_selector)\r\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\r\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\r\n    }\r\n}\r\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\r\n    assembly {\r\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\r\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\r\n        revert(\r\n            Error_selector_offset,\r\n            OrderCriteriaResolverOutOfRange_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\r\n    assembly {\r\n        mstore(0, OrderIsCancelled_error_selector)\r\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\r\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\r\n    }\r\n}\r\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\r\n    assembly {\r\n        mstore(0, OrderPartiallyFilled_error_selector)\r\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\r\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\r\n    }\r\n}\r\nfunction _revertPartialFillsNotEnabledForOrder() pure {\r\n    assembly {\r\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\r\n        revert(\r\n            Error_selector_offset,\r\n            PartialFillsNotEnabledForOrder_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertUnresolvedConsiderationCriteria(\r\n    uint256 orderIndex,\r\n    uint256 considerationIndex\r\n) pure {\r\n    assembly {\r\n        mstore(0, UnresolvedConsiderationCriteria_error_selector)\r\n        mstore(UnresolvedConsiderationCriteria_error_orderIndex_ptr, orderIndex)\r\n        mstore(\r\n            UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\r\n            considerationIndex\r\n        )\r\n        revert(\r\n            Error_selector_offset,\r\n            UnresolvedConsiderationCriteria_error_length\r\n        )\r\n    }\r\n}\r\nfunction _revertUnresolvedOfferCriteria(\r\n    uint256 orderIndex,\r\n    uint256 offerIndex\r\n) pure {\r\n    assembly {\r\n        mstore(0, UnresolvedOfferCriteria_error_selector)\r\n        mstore(UnresolvedOfferCriteria_error_orderIndex_ptr, orderIndex)\r\n        mstore(UnresolvedOfferCriteria_error_offerIndex_ptr, offerIndex)\r\n        revert(Error_selector_offset, UnresolvedOfferCriteria_error_length)\r\n    }\r\n}\r\nfunction _revertUnusedItemParameters() pure {\r\n    assembly {\r\n        mstore(0, UnusedItemParameters_error_selector)\r\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\r\n    }\r\n}\r\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\r\n    assembly {\r\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\r\n        revert(\r\n            Error_selector_offset,\r\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\r\n        )\r\n    }\r\n}\r\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\r\n///    and returns the memory pointer to the first byte of the allocated region.\r\n// (Free functions cannot have visibility.)\r\n// solhint-disable-next-line func-visibility\r\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\r\n    assembly {\r\n        mPtr := mload(_FreeMemoryPointerSlot)\r\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\r\n    }\r\n}\r\n\r\n// (Free functions cannot have visibility.)\r\n// solhint-disable-next-line func-visibility\r\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\r\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\r\n}\r\n\r\n// (Free functions cannot have visibility.)\r\n// solhint-disable-next-line func-visibility\r\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\r\n    FreeMemoryPPtr.write(mPtr);\r\n}\r\n\r\nlibrary CalldataPointerLib {\r\n    function lt(\r\n        CalldataPointer a,\r\n        CalldataPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := lt(a, b)\r\n        }\r\n    }\r\n\r\n    function gt(\r\n        CalldataPointer a,\r\n        CalldataPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := gt(a, b)\r\n        }\r\n    }\r\n\r\n    function eq(\r\n        CalldataPointer a,\r\n        CalldataPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := eq(a, b)\r\n        }\r\n    }\r\n\r\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\r\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\r\n    ///      type's head stored at `cdPtr + headOffset`.\r\n    function pptr(\r\n        CalldataPointer cdPtr,\r\n        uint256 headOffset\r\n    ) internal pure returns (CalldataPointer cdPtrChild) {\r\n        cdPtrChild = cdPtr.offset(\r\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\r\n        );\r\n    }\r\n\r\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\r\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\r\n    ///      first member, e.g. `struct { bytes data; }`\r\n    function pptr(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (CalldataPointer cdPtrChild) {\r\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\r\n    }\r\n\r\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\r\n    function next(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (CalldataPointer cdPtrNext) {\r\n        assembly {\r\n            cdPtrNext := add(cdPtr, _OneWord)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\r\n    function offset(\r\n        CalldataPointer cdPtr,\r\n        uint256 _offset\r\n    ) internal pure returns (CalldataPointer cdPtrNext) {\r\n        assembly {\r\n            cdPtrNext := add(cdPtr, _offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\r\n    ///      `dst`.\r\n    function copy(\r\n        CalldataPointer src,\r\n        MemoryPointer dst,\r\n        uint256 size\r\n    ) internal pure {\r\n        assembly {\r\n            calldatacopy(dst, src, size)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary ReturndataPointerLib {\r\n    function lt(\r\n        ReturndataPointer a,\r\n        ReturndataPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := lt(a, b)\r\n        }\r\n    }\r\n\r\n    function gt(\r\n        ReturndataPointer a,\r\n        ReturndataPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := gt(a, b)\r\n        }\r\n    }\r\n\r\n    function eq(\r\n        ReturndataPointer a,\r\n        ReturndataPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := eq(a, b)\r\n        }\r\n    }\r\n\r\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\r\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\r\n    ///      type's head stored at `rdPtr + headOffset`.\r\n    function pptr(\r\n        ReturndataPointer rdPtr,\r\n        uint256 headOffset\r\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\r\n        rdPtrChild = rdPtr.offset(\r\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\r\n        );\r\n    }\r\n\r\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\r\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\r\n    ///    first member, e.g. `struct { bytes data; }`\r\n    function pptr(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\r\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\r\n    }\r\n\r\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\r\n    function next(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\r\n        assembly {\r\n            rdPtrNext := add(rdPtr, _OneWord)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\r\n    function offset(\r\n        ReturndataPointer rdPtr,\r\n        uint256 _offset\r\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\r\n        assembly {\r\n            rdPtrNext := add(rdPtr, _offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\r\n    /// `dst`.\r\n    function copy(\r\n        ReturndataPointer src,\r\n        MemoryPointer dst,\r\n        uint256 size\r\n    ) internal pure {\r\n        assembly {\r\n            returndatacopy(dst, src, size)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MemoryPointerLib {\r\n    function copy(\r\n        MemoryPointer src,\r\n        MemoryPointer dst,\r\n        uint256 size\r\n    ) internal view {\r\n        assembly {\r\n            let success := staticcall(\r\n                gas(),\r\n                IdentityPrecompileAddress,\r\n                src,\r\n                size,\r\n                dst,\r\n                size\r\n            )\r\n            if or(iszero(returndatasize()), iszero(success)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function lt(\r\n        MemoryPointer a,\r\n        MemoryPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := lt(a, b)\r\n        }\r\n    }\r\n\r\n    function gt(\r\n        MemoryPointer a,\r\n        MemoryPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := gt(a, b)\r\n        }\r\n    }\r\n\r\n    function eq(\r\n        MemoryPointer a,\r\n        MemoryPointer b\r\n    ) internal pure returns (bool c) {\r\n        assembly {\r\n            c := eq(a, b)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the memory pointer one word after `mPtr`.\r\n    function next(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (MemoryPointer mPtrNext) {\r\n        assembly {\r\n            mPtrNext := add(mPtr, _OneWord)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\r\n    function offset(\r\n        MemoryPointer mPtr,\r\n        uint256 _offset\r\n    ) internal pure returns (MemoryPointer mPtrNext) {\r\n        assembly {\r\n            mPtrNext := add(mPtr, _offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Resolves a pointer pointer at `mPtr + headOffset` to a memory\r\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\r\n    ///    type's pointer stored at `mPtr + headOffset`.\r\n    function pptr(\r\n        MemoryPointer mPtr,\r\n        uint256 headOffset\r\n    ) internal pure returns (MemoryPointer mPtrChild) {\r\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\r\n    }\r\n\r\n    /// @dev Resolves a pointer pointer stored at `mPtr` to a memory pointer.\r\n    ///    `mPtr` must point to some parent object with a dynamic type as its\r\n    ///    first member, e.g. `struct { bytes data; }`\r\n    function pptr(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (MemoryPointer mPtrChild) {\r\n        mPtrChild = mPtr.readMemoryPointer();\r\n    }\r\n}\r\n\r\nlibrary CalldataReaders {\r\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\r\n    ///    last 4 bytes.\r\n    function readMaskedUint256(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint256 value) {\r\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\r\n    }\r\n\r\n    /// @dev Reads the bool at `cdPtr` in calldata.\r\n    function readBool(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bool value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the address at `cdPtr` in calldata.\r\n    function readAddress(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (address value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\r\n    function readBytes1(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes1 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\r\n    function readBytes2(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes2 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\r\n    function readBytes3(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes3 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\r\n    function readBytes4(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes4 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\r\n    function readBytes5(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes5 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\r\n    function readBytes6(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes6 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\r\n    function readBytes7(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes7 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\r\n    function readBytes8(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes8 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\r\n    function readBytes9(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes9 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\r\n    function readBytes10(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes10 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\r\n    function readBytes11(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes11 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\r\n    function readBytes12(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes12 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\r\n    function readBytes13(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes13 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\r\n    function readBytes14(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes14 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\r\n    function readBytes15(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes15 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\r\n    function readBytes16(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes16 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\r\n    function readBytes17(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes17 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\r\n    function readBytes18(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes18 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\r\n    function readBytes19(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes19 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\r\n    function readBytes20(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes20 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\r\n    function readBytes21(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes21 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\r\n    function readBytes22(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes22 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\r\n    function readBytes23(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes23 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\r\n    function readBytes24(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes24 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\r\n    function readBytes25(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes25 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\r\n    function readBytes26(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes26 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\r\n    function readBytes27(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes27 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\r\n    function readBytes28(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes28 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\r\n    function readBytes29(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes29 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\r\n    function readBytes30(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes30 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\r\n    function readBytes31(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes31 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\r\n    function readBytes32(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (bytes32 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\r\n    function readUint8(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint8 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\r\n    function readUint16(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint16 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\r\n    function readUint24(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint24 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\r\n    function readUint32(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint32 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\r\n    function readUint40(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint40 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\r\n    function readUint48(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint48 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\r\n    function readUint56(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint56 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\r\n    function readUint64(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint64 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\r\n    function readUint72(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint72 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\r\n    function readUint80(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint80 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\r\n    function readUint88(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint88 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\r\n    function readUint96(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint96 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\r\n    function readUint104(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint104 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\r\n    function readUint112(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint112 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\r\n    function readUint120(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint120 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\r\n    function readUint128(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint128 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\r\n    function readUint136(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint136 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\r\n    function readUint144(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint144 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\r\n    function readUint152(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint152 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\r\n    function readUint160(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint160 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\r\n    function readUint168(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint168 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\r\n    function readUint176(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint176 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\r\n    function readUint184(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint184 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\r\n    function readUint192(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint192 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\r\n    function readUint200(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint200 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\r\n    function readUint208(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint208 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\r\n    function readUint216(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint216 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\r\n    function readUint224(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint224 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\r\n    function readUint232(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint232 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\r\n    function readUint240(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint240 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\r\n    function readUint248(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint248 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\r\n    function readUint256(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (uint256 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int8 at `cdPtr` in calldata.\r\n    function readInt8(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int8 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int16 at `cdPtr` in calldata.\r\n    function readInt16(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int16 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int24 at `cdPtr` in calldata.\r\n    function readInt24(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int24 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int32 at `cdPtr` in calldata.\r\n    function readInt32(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int32 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int40 at `cdPtr` in calldata.\r\n    function readInt40(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int40 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int48 at `cdPtr` in calldata.\r\n    function readInt48(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int48 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int56 at `cdPtr` in calldata.\r\n    function readInt56(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int56 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int64 at `cdPtr` in calldata.\r\n    function readInt64(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int64 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int72 at `cdPtr` in calldata.\r\n    function readInt72(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int72 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int80 at `cdPtr` in calldata.\r\n    function readInt80(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int80 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int88 at `cdPtr` in calldata.\r\n    function readInt88(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int88 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int96 at `cdPtr` in calldata.\r\n    function readInt96(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int96 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int104 at `cdPtr` in calldata.\r\n    function readInt104(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int104 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int112 at `cdPtr` in calldata.\r\n    function readInt112(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int112 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int120 at `cdPtr` in calldata.\r\n    function readInt120(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int120 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int128 at `cdPtr` in calldata.\r\n    function readInt128(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int128 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int136 at `cdPtr` in calldata.\r\n    function readInt136(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int136 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int144 at `cdPtr` in calldata.\r\n    function readInt144(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int144 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int152 at `cdPtr` in calldata.\r\n    function readInt152(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int152 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int160 at `cdPtr` in calldata.\r\n    function readInt160(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int160 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int168 at `cdPtr` in calldata.\r\n    function readInt168(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int168 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int176 at `cdPtr` in calldata.\r\n    function readInt176(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int176 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int184 at `cdPtr` in calldata.\r\n    function readInt184(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int184 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int192 at `cdPtr` in calldata.\r\n    function readInt192(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int192 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int200 at `cdPtr` in calldata.\r\n    function readInt200(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int200 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int208 at `cdPtr` in calldata.\r\n    function readInt208(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int208 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int216 at `cdPtr` in calldata.\r\n    function readInt216(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int216 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int224 at `cdPtr` in calldata.\r\n    function readInt224(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int224 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int232 at `cdPtr` in calldata.\r\n    function readInt232(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int232 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int240 at `cdPtr` in calldata.\r\n    function readInt240(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int240 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int248 at `cdPtr` in calldata.\r\n    function readInt248(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int248 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int256 at `cdPtr` in calldata.\r\n    function readInt256(\r\n        CalldataPointer cdPtr\r\n    ) internal pure returns (int256 value) {\r\n        assembly {\r\n            value := calldataload(cdPtr)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary ReturndataReaders {\r\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\r\n    function readMaskedUint256(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint256 value) {\r\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\r\n    }\r\n\r\n    /// @dev Reads the bool at `rdPtr` in returndata.\r\n    function readBool(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bool value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the address at `rdPtr` in returndata.\r\n    function readAddress(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (address value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\r\n    function readBytes1(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes1 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\r\n    function readBytes2(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes2 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\r\n    function readBytes3(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes3 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\r\n    function readBytes4(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes4 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\r\n    function readBytes5(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes5 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\r\n    function readBytes6(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes6 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\r\n    function readBytes7(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes7 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\r\n    function readBytes8(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes8 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\r\n    function readBytes9(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes9 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\r\n    function readBytes10(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes10 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\r\n    function readBytes11(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes11 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\r\n    function readBytes12(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes12 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\r\n    function readBytes13(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes13 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\r\n    function readBytes14(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes14 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\r\n    function readBytes15(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes15 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\r\n    function readBytes16(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes16 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\r\n    function readBytes17(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes17 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\r\n    function readBytes18(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes18 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\r\n    function readBytes19(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes19 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\r\n    function readBytes20(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes20 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\r\n    function readBytes21(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes21 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\r\n    function readBytes22(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes22 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\r\n    function readBytes23(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes23 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\r\n    function readBytes24(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes24 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\r\n    function readBytes25(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes25 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\r\n    function readBytes26(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes26 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\r\n    function readBytes27(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes27 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\r\n    function readBytes28(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes28 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\r\n    function readBytes29(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes29 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\r\n    function readBytes30(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes30 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\r\n    function readBytes31(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes31 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\r\n    function readBytes32(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (bytes32 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\r\n    function readUint8(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint8 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\r\n    function readUint16(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint16 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\r\n    function readUint24(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint24 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\r\n    function readUint32(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint32 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\r\n    function readUint40(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint40 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\r\n    function readUint48(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint48 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\r\n    function readUint56(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint56 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\r\n    function readUint64(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint64 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\r\n    function readUint72(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint72 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\r\n    function readUint80(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint80 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\r\n    function readUint88(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint88 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\r\n    function readUint96(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint96 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\r\n    function readUint104(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint104 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\r\n    function readUint112(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint112 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\r\n    function readUint120(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint120 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\r\n    function readUint128(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint128 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\r\n    function readUint136(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint136 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\r\n    function readUint144(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint144 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\r\n    function readUint152(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint152 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\r\n    function readUint160(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint160 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\r\n    function readUint168(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint168 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\r\n    function readUint176(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint176 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\r\n    function readUint184(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint184 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\r\n    function readUint192(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint192 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\r\n    function readUint200(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint200 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\r\n    function readUint208(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint208 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\r\n    function readUint216(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint216 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\r\n    function readUint224(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint224 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\r\n    function readUint232(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint232 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\r\n    function readUint240(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint240 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\r\n    function readUint248(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint248 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\r\n    function readUint256(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (uint256 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int8 at `rdPtr` in returndata.\r\n    function readInt8(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int8 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int16 at `rdPtr` in returndata.\r\n    function readInt16(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int16 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int24 at `rdPtr` in returndata.\r\n    function readInt24(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int24 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int32 at `rdPtr` in returndata.\r\n    function readInt32(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int32 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int40 at `rdPtr` in returndata.\r\n    function readInt40(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int40 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int48 at `rdPtr` in returndata.\r\n    function readInt48(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int48 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int56 at `rdPtr` in returndata.\r\n    function readInt56(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int56 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int64 at `rdPtr` in returndata.\r\n    function readInt64(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int64 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int72 at `rdPtr` in returndata.\r\n    function readInt72(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int72 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int80 at `rdPtr` in returndata.\r\n    function readInt80(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int80 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int88 at `rdPtr` in returndata.\r\n    function readInt88(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int88 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int96 at `rdPtr` in returndata.\r\n    function readInt96(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int96 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int104 at `rdPtr` in returndata.\r\n    function readInt104(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int104 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int112 at `rdPtr` in returndata.\r\n    function readInt112(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int112 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int120 at `rdPtr` in returndata.\r\n    function readInt120(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int120 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int128 at `rdPtr` in returndata.\r\n    function readInt128(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int128 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int136 at `rdPtr` in returndata.\r\n    function readInt136(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int136 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int144 at `rdPtr` in returndata.\r\n    function readInt144(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int144 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int152 at `rdPtr` in returndata.\r\n    function readInt152(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int152 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int160 at `rdPtr` in returndata.\r\n    function readInt160(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int160 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int168 at `rdPtr` in returndata.\r\n    function readInt168(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int168 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int176 at `rdPtr` in returndata.\r\n    function readInt176(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int176 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int184 at `rdPtr` in returndata.\r\n    function readInt184(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int184 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int192 at `rdPtr` in returndata.\r\n    function readInt192(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int192 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int200 at `rdPtr` in returndata.\r\n    function readInt200(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int200 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int208 at `rdPtr` in returndata.\r\n    function readInt208(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int208 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int216 at `rdPtr` in returndata.\r\n    function readInt216(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int216 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int224 at `rdPtr` in returndata.\r\n    function readInt224(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int224 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int232 at `rdPtr` in returndata.\r\n    function readInt232(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int232 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int240 at `rdPtr` in returndata.\r\n    function readInt240(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int240 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int248 at `rdPtr` in returndata.\r\n    function readInt248(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int248 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n\r\n    /// @dev Reads the int256 at `rdPtr` in returndata.\r\n    function readInt256(\r\n        ReturndataPointer rdPtr\r\n    ) internal pure returns (int256 value) {\r\n        assembly {\r\n            returndatacopy(0, rdPtr, _OneWord)\r\n            value := mload(0)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MemoryReaders {\r\n    function readMemoryPointer(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (MemoryPointer value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readMaskedUint256(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint256 value) {\r\n        value = mPtr.readUint256() & OffsetOrLengthMask;\r\n    }\r\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readAddress(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (address value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes1(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes1 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes2(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes2 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes3(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes3 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes4(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes4 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes5(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes5 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes6(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes6 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes7(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes7 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes8(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes8 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes9(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes9 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes10(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes10 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes11(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes11 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes12(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes12 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes13(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes13 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes14(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes14 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes15(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes15 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes16(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes16 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes17(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes17 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes18(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes18 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes19(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes19 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes20(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes20 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes21(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes21 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes22(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes22 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes23(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes23 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes24(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes24 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes25(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes25 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes26(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes26 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes27(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes27 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes28(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes28 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes29(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes29 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes30(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes30 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes31(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes31 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readBytes32(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (bytes32 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint16(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint16 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint24(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint24 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint32(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint32 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint40(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint40 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint48(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint48 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint56(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint56 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint64(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint64 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint72(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint72 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint80(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint80 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint88(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint88 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint96(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint96 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint104(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint104 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint112(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint112 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint120(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint120 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint128(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint128 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint136(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint136 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint144(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint144 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint152(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint152 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint160(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint160 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint168(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint168 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint176(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint176 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint184(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint184 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint192(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint192 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint200(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint200 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint208(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint208 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint216(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint216 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint224(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint224 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint232(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint232 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint240(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint240 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint248(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint248 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readUint256(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (uint256 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt104(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int104 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt112(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int112 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt120(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int120 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt128(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int128 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt136(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int136 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt144(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int144 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt152(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int152 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt160(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int160 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt168(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int168 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt176(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int176 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt184(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int184 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt192(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int192 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt200(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int200 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt208(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int208 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt216(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int216 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt224(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int224 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt232(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int232 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt240(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int240 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt248(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int248 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n    function readInt256(\r\n        MemoryPointer mPtr\r\n    ) internal pure returns (int256 value) {\r\n        assembly {\r\n            value := mload(mPtr)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MemoryWriters {\r\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\r\n        assembly {\r\n            mstore(mPtr, valuePtr)\r\n        }\r\n    }\r\n    function write(MemoryPointer mPtr, bool value) internal pure {\r\n        assembly {\r\n            mstore(mPtr, value)\r\n        }\r\n    }\r\n    function write(MemoryPointer mPtr, address value) internal pure {\r\n        assembly {\r\n            mstore(mPtr, value)\r\n        }\r\n    }\r\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\r\n        assembly {\r\n            mstore(mPtr, value)\r\n        }\r\n    }\r\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\r\n        assembly {\r\n            mstore(mPtr, value)\r\n        }\r\n    }\r\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\r\n        assembly {\r\n            mstore(mPtr, value)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary StructPointers {\r\n    /**\r\n     * @dev Get a MemoryPointer from OrderComponents.\r\n     *\r\n     * @param obj The OrderComponents object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        OrderComponents memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from OrderComponents.\r\n     *\r\n     * @param obj The OrderComponents object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        OrderComponents calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from OfferItem.\r\n     *\r\n     * @param obj The OfferItem object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        OfferItem memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from OfferItem.\r\n     *\r\n     * @param obj The OfferItem object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        OfferItem calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from ConsiderationItem.\r\n     *\r\n     * @param obj The ConsiderationItem object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        ConsiderationItem memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from ConsiderationItem.\r\n     *\r\n     * @param obj The ConsiderationItem object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        ConsiderationItem calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from SpentItem.\r\n     *\r\n     * @param obj The SpentItem object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        SpentItem memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from SpentItem.\r\n     *\r\n     * @param obj The SpentItem object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        SpentItem calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from ReceivedItem.\r\n     *\r\n     * @param obj The ReceivedItem object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        ReceivedItem memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from ReceivedItem.\r\n     *\r\n     * @param obj The ReceivedItem object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        ReceivedItem calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from BasicOrderParameters.\r\n     *\r\n     * @param obj The BasicOrderParameters object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        BasicOrderParameters memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from BasicOrderParameters.\r\n     *\r\n     * @param obj The BasicOrderParameters object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        BasicOrderParameters calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from AdditionalRecipient.\r\n     *\r\n     * @param obj The AdditionalRecipient object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        AdditionalRecipient memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from AdditionalRecipient.\r\n     *\r\n     * @param obj The AdditionalRecipient object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        AdditionalRecipient calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from OrderParameters.\r\n     *\r\n     * @param obj The OrderParameters object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        OrderParameters memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from OrderParameters.\r\n     *\r\n     * @param obj The OrderParameters object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        OrderParameters calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from Order.\r\n     *\r\n     * @param obj The Order object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        Order memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from Order.\r\n     *\r\n     * @param obj The Order object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        Order calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from AdvancedOrder.\r\n     *\r\n     * @param obj The AdvancedOrder object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        AdvancedOrder memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from AdvancedOrder.\r\n     *\r\n     * @param obj The AdvancedOrder object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        AdvancedOrder calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from OrderStatus.\r\n     *\r\n     * @param obj The OrderStatus object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        OrderStatus memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from OrderStatus.\r\n     *\r\n     * @param obj The OrderStatus object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        OrderStatus calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from CriteriaResolver.\r\n     *\r\n     * @param obj The CriteriaResolver object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        CriteriaResolver memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from CriteriaResolver.\r\n     *\r\n     * @param obj The CriteriaResolver object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        CriteriaResolver calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from Fulfillment.\r\n     *\r\n     * @param obj The Fulfillment object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        Fulfillment memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from Fulfillment.\r\n     *\r\n     * @param obj The Fulfillment object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        Fulfillment calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from FulfillmentComponent.\r\n     *\r\n     * @param obj The FulfillmentComponent object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        FulfillmentComponent memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from FulfillmentComponent.\r\n     *\r\n     * @param obj The FulfillmentComponent object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        FulfillmentComponent calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from Execution.\r\n     *\r\n     * @param obj The Execution object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        Execution memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from Execution.\r\n     *\r\n     * @param obj The Execution object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        Execution calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a MemoryPointer from ZoneParameters.\r\n     *\r\n     * @param obj The ZoneParameters object.\r\n     *\r\n     * @return ptr The MemoryPointer.\r\n     */\r\n    function toMemoryPointer(\r\n        ZoneParameters memory obj\r\n    ) internal pure returns (MemoryPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a CalldataPointer from ZoneParameters.\r\n     *\r\n     * @param obj The ZoneParameters object.\r\n     *\r\n     * @return ptr The CalldataPointer.\r\n     */\r\n    function toCalldataPointer(\r\n        ZoneParameters calldata obj\r\n    ) internal pure returns (CalldataPointer ptr) {\r\n        assembly {\r\n            ptr := obj\r\n        }\r\n    }\r\n}\r\n\r\nenum OrderType {\r\n    FULL_OPEN,\r\n    PARTIAL_OPEN,\r\n    FULL_RESTRICTED,\r\n    PARTIAL_RESTRICTED,\r\n    CONTRACT\r\n}\r\n\r\nenum BasicOrderType {\r\n    ETH_TO_ERC721_FULL_OPEN,\r\n    ETH_TO_ERC721_PARTIAL_OPEN,\r\n    ETH_TO_ERC721_FULL_RESTRICTED,\r\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\r\n    ETH_TO_ERC1155_FULL_OPEN,\r\n    ETH_TO_ERC1155_PARTIAL_OPEN,\r\n    ETH_TO_ERC1155_FULL_RESTRICTED,\r\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\r\n    ERC20_TO_ERC721_FULL_OPEN,\r\n    ERC20_TO_ERC721_PARTIAL_OPEN,\r\n    ERC20_TO_ERC721_FULL_RESTRICTED,\r\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\r\n    ERC20_TO_ERC1155_FULL_OPEN,\r\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\r\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\r\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\r\n    ERC721_TO_ERC20_FULL_OPEN,\r\n    ERC721_TO_ERC20_PARTIAL_OPEN,\r\n    ERC721_TO_ERC20_FULL_RESTRICTED,\r\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\r\n    ERC1155_TO_ERC20_FULL_OPEN,\r\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\r\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\r\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\r\n}\r\n\r\nenum BasicOrderRouteType {\r\n    ETH_TO_ERC721,\r\n    ETH_TO_ERC1155,\r\n    ERC20_TO_ERC721,\r\n    ERC20_TO_ERC1155,\r\n    ERC721_TO_ERC20,\r\n    ERC1155_TO_ERC20\r\n}\r\n\r\nenum ItemType {\r\n    NATIVE,\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155,\r\n    ERC721_WITH_CRITERIA,\r\n    ERC1155_WITH_CRITERIA\r\n}\r\n\r\nenum Side {\r\n    OFFER,\r\n    CONSIDERATION\r\n}\r\n\r\nstruct OrderComponents {\r\n    address offerer;\r\n    address zone;\r\n    OfferItem[] offer;\r\n    ConsiderationItem[] consideration;\r\n    OrderType orderType;\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    bytes32 zoneHash;\r\n    uint256 salt;\r\n    bytes32 conduitKey;\r\n    uint256 counter;\r\n}\r\n\r\nstruct OfferItem {\r\n    ItemType itemType;\r\n    address token;\r\n    uint256 identifierOrCriteria;\r\n    uint256 startAmount;\r\n    uint256 endAmount;\r\n}\r\n\r\nstruct ConsiderationItem {\r\n    ItemType itemType;\r\n    address token;\r\n    uint256 identifierOrCriteria;\r\n    uint256 startAmount;\r\n    uint256 endAmount;\r\n    address payable recipient;\r\n}\r\n\r\nstruct SpentItem {\r\n    ItemType itemType;\r\n    address token;\r\n    uint256 identifier;\r\n    uint256 amount;\r\n}\r\n\r\nstruct ReceivedItem {\r\n    ItemType itemType;\r\n    address token;\r\n    uint256 identifier;\r\n    uint256 amount;\r\n    address payable recipient;\r\n}\r\n\r\nstruct AdditionalRecipient {\r\n    uint256 amount;\r\n    address payable recipient;\r\n}\r\n\r\nstruct BasicOrderParameters {\r\n    // calldata offset\r\n    address considerationToken; // 0x24\r\n    uint256 considerationIdentifier; // 0x44\r\n    uint256 considerationAmount; // 0x64\r\n    address payable offerer; // 0x84\r\n    address zone; // 0xa4\r\n    address offerToken; // 0xc4\r\n    uint256 offerIdentifier; // 0xe4\r\n    uint256 offerAmount; // 0x104\r\n    BasicOrderType basicOrderType; // 0x124\r\n    uint256 startTime; // 0x144\r\n    uint256 endTime; // 0x164\r\n    bytes32 zoneHash; // 0x184\r\n    uint256 salt; // 0x1a4\r\n    bytes32 offererConduitKey; // 0x1c4\r\n    bytes32 fulfillerConduitKey; // 0x1e4\r\n    uint256 totalOriginalAdditionalRecipients; // 0x204\r\n    AdditionalRecipient[] additionalRecipients; // 0x224\r\n    bytes signature; // 0x244\r\n}\r\n\r\nstruct OrderParameters {\r\n    address offerer; // 0x00\r\n    address zone; // 0x20\r\n    OfferItem[] offer; // 0x40\r\n    ConsiderationItem[] consideration; // 0x60\r\n    OrderType orderType; // 0x80\r\n    uint256 startTime; // 0xa0\r\n    uint256 endTime; // 0xc0\r\n    bytes32 zoneHash; // 0xe0\r\n    uint256 salt; // 0x100\r\n    bytes32 conduitKey; // 0x120\r\n    uint256 totalOriginalConsiderationItems; // 0x140\r\n    // offer.length                          // 0x160\r\n}\r\n\r\nstruct Order {\r\n    OrderParameters parameters;\r\n    bytes signature;\r\n}\r\n\r\nstruct AdvancedOrder {\r\n    OrderParameters parameters;\r\n    uint120 numerator;\r\n    uint120 denominator;\r\n    bytes signature;\r\n    bytes extraData;\r\n}\r\n\r\nstruct OrderStatus {\r\n    bool isValidated;\r\n    bool isCancelled;\r\n    uint120 numerator;\r\n    uint120 denominator;\r\n}\r\n\r\nstruct CriteriaResolver {\r\n    uint256 orderIndex;\r\n    Side side;\r\n    uint256 index;\r\n    uint256 identifier;\r\n    bytes32[] criteriaProof;\r\n}\r\n\r\nstruct Fulfillment {\r\n    FulfillmentComponent[] offerComponents;\r\n    FulfillmentComponent[] considerationComponents;\r\n}\r\n\r\nstruct FulfillmentComponent {\r\n    uint256 orderIndex;\r\n    uint256 itemIndex;\r\n}\r\n\r\nstruct Execution {\r\n    ReceivedItem item;\r\n    address offerer;\r\n    bytes32 conduitKey;\r\n}\r\n\r\nstruct ZoneParameters {\r\n    bytes32 orderHash;\r\n    address fulfiller;\r\n    address offerer;\r\n    SpentItem[] offer;\r\n    ReceivedItem[] consideration;\r\n    bytes extraData;\r\n    bytes32[] orderHashes;\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    bytes32 zoneHash;\r\n}\r\n\r\ninterface ConsiderationInterface {\r\n    function fulfillBasicOrder(\r\n        BasicOrderParameters calldata parameters\r\n    ) external payable returns (bool fulfilled);\r\n\r\n    function fulfillOrder(\r\n        Order calldata order,\r\n        bytes32 fulfillerConduitKey\r\n    ) external payable returns (bool fulfilled);\r\n\r\n    function fulfillAdvancedOrder(\r\n        AdvancedOrder calldata advancedOrder,\r\n        CriteriaResolver[] calldata criteriaResolvers,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient\r\n    ) external payable returns (bool fulfilled);\r\n\r\n    function fulfillAvailableOrders(\r\n        Order[] calldata orders,\r\n        FulfillmentComponent[][] calldata offerFulfillments,\r\n        FulfillmentComponent[][] calldata considerationFulfillments,\r\n        bytes32 fulfillerConduitKey,\r\n        uint256 maximumFulfilled\r\n    )\r\n        external\r\n        payable\r\n        returns (bool[] memory availableOrders, Execution[] memory executions);\r\n\r\n    function fulfillAvailableAdvancedOrders(\r\n        AdvancedOrder[] calldata advancedOrders,\r\n        CriteriaResolver[] calldata criteriaResolvers,\r\n        FulfillmentComponent[][] calldata offerFulfillments,\r\n        FulfillmentComponent[][] calldata considerationFulfillments,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient,\r\n        uint256 maximumFulfilled\r\n    )\r\n        external\r\n        payable\r\n        returns (bool[] memory availableOrders, Execution[] memory executions);\r\n\r\n    function matchOrders(\r\n        Order[] calldata orders,\r\n        Fulfillment[] calldata fulfillments\r\n    ) external payable returns (Execution[] memory executions);\r\n\r\n    function matchAdvancedOrders(\r\n        AdvancedOrder[] calldata orders,\r\n        CriteriaResolver[] calldata criteriaResolvers,\r\n        Fulfillment[] calldata fulfillments,\r\n        address recipient\r\n    ) external payable returns (Execution[] memory executions);\r\n\r\n    function cancel(\r\n        OrderComponents[] calldata orders\r\n    ) external returns (bool cancelled);\r\n\r\n    function validate(\r\n        Order[] calldata orders\r\n    ) external returns (bool validated);\r\n\r\n    function incrementCounter() external returns (uint256 newCounter);\r\n\r\n    function fulfillBasicOrder_efficient_6GL6yc(\r\n        BasicOrderParameters calldata parameters\r\n    ) external payable returns (bool fulfilled);\r\n\r\n    function getOrderHash(\r\n        OrderComponents calldata order\r\n    ) external view returns (bytes32 orderHash);\r\n\r\n    function getOrderStatus(\r\n        bytes32 orderHash\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool isValidated,\r\n            bool isCancelled,\r\n            uint256 totalFilled,\r\n            uint256 totalSize\r\n        );\r\n\r\n    function getCounter(\r\n        address offerer\r\n    ) external view returns (uint256 counter);\r\n\r\n    function information()\r\n        external\r\n        view\r\n        returns (\r\n            string memory version,\r\n            bytes32 domainSeparator,\r\n            address conduitController\r\n        );\r\n\r\n    function getContractOffererNonce(\r\n        address contractOfferer\r\n    ) external view returns (uint256 nonce);\r\n\r\n    function name() external view returns (string memory contractName);\r\n}\r\ncontract GettersAndDerivers is ConsiderationBase {\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(\r\n        address conduitController\r\n    ) ConsiderationBase(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal view function to derive the order hash for a given order.\r\n     *      Note that only the original consideration items are included in the\r\n     *      order hash, as additional consideration items may be supplied by the\r\n     *      caller.\r\n     *\r\n     * @param orderParameters The parameters of the order to hash.\r\n     * @param counter         The counter of the order to hash.\r\n     *\r\n     * @return orderHash The hash.\r\n     */\r\n    function _deriveOrderHash(\r\n        OrderParameters memory orderParameters,\r\n        uint256 counter\r\n    ) internal view returns (bytes32 orderHash) {\r\n        // Get length of original consideration array and place it on the stack.\r\n        uint256 originalConsiderationLength = (\r\n            orderParameters.totalOriginalConsiderationItems\r\n        );\r\n\r\n        /*\r\n         * Memory layout for an array of structs (dynamic or not) is similar\r\n         * to ABI encoding of dynamic types, with a head segment followed by\r\n         * a data segment. The main difference is that the head of an element\r\n         * is a memory pointer rather than an offset.\r\n         */\r\n\r\n        // Declare a variable for the derived hash of the offer array.\r\n        bytes32 offerHash;\r\n\r\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\r\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\r\n\r\n        // Utilize assembly so that memory regions can be reused across hashes.\r\n        assembly {\r\n            // Retrieve the free memory pointer and place on the stack.\r\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\r\n\r\n            // Get the pointer to the offers array.\r\n            let offerArrPtr := mload(\r\n                add(orderParameters, OrderParameters_offer_head_offset)\r\n            )\r\n\r\n            // Load the length.\r\n            let offerLength := mload(offerArrPtr)\r\n\r\n            // Set the pointer to the first offer's head.\r\n            offerArrPtr := add(offerArrPtr, OneWord)\r\n\r\n            // Iterate over the offer items.\r\n            for { let i := 0 } lt(i, offerLength) {\r\n                i := add(i, 1)\r\n            } {\r\n                // Read the pointer to the offer data and subtract one word\r\n                // to get typeHash pointer.\r\n                let ptr := sub(mload(offerArrPtr), OneWord)\r\n\r\n                // Read the current value before the offer data.\r\n                let value := mload(ptr)\r\n\r\n                // Write the type hash to the previous word.\r\n                mstore(ptr, typeHash)\r\n\r\n                // Take the EIP712 hash and store it in the hash array.\r\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\r\n\r\n                // Restore the previous word.\r\n                mstore(ptr, value)\r\n\r\n                // Increment the array pointers by one word.\r\n                offerArrPtr := add(offerArrPtr, OneWord)\r\n                hashArrPtr := add(hashArrPtr, OneWord)\r\n            }\r\n\r\n            // Derive the offer hash using the hashes of each item.\r\n            offerHash := keccak256(\r\n                mload(FreeMemoryPointerSlot),\r\n                shl(OneWordShift, offerLength)\r\n            )\r\n        }\r\n\r\n        // Declare a variable for the derived hash of the consideration array.\r\n        bytes32 considerationHash;\r\n\r\n        // Read consideration item typehash from runtime code & place on stack.\r\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\r\n\r\n        // Utilize assembly so that memory regions can be reused across hashes.\r\n        assembly {\r\n            // Retrieve the free memory pointer and place on the stack.\r\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\r\n\r\n            // Get the pointer to the consideration array.\r\n            let considerationArrPtr := add(\r\n                mload(\r\n                    add(\r\n                        orderParameters,\r\n                        OrderParameters_consideration_head_offset\r\n                    )\r\n                ),\r\n                OneWord\r\n            )\r\n\r\n            // Iterate over the consideration items (not including tips).\r\n            for { let i := 0 } lt(i, originalConsiderationLength) {\r\n                i := add(i, 1)\r\n            } {\r\n                // Read the pointer to the consideration data and subtract one\r\n                // word to get typeHash pointer.\r\n                let ptr := sub(mload(considerationArrPtr), OneWord)\r\n\r\n                // Read the current value before the consideration data.\r\n                let value := mload(ptr)\r\n\r\n                // Write the type hash to the previous word.\r\n                mstore(ptr, typeHash)\r\n\r\n                // Take the EIP712 hash and store it in the hash array.\r\n                mstore(\r\n                    hashArrPtr,\r\n                    keccak256(ptr, EIP712_ConsiderationItem_size)\r\n                )\r\n\r\n                // Restore the previous word.\r\n                mstore(ptr, value)\r\n\r\n                // Increment the array pointers by one word.\r\n                considerationArrPtr := add(considerationArrPtr, OneWord)\r\n                hashArrPtr := add(hashArrPtr, OneWord)\r\n            }\r\n\r\n            // Derive the consideration hash using the hashes of each item.\r\n            considerationHash := keccak256(\r\n                mload(FreeMemoryPointerSlot),\r\n                shl(OneWordShift, originalConsiderationLength)\r\n            )\r\n        }\r\n\r\n        // Read order item EIP-712 typehash from runtime code & place on stack.\r\n        typeHash = _ORDER_TYPEHASH;\r\n\r\n        // Utilize assembly to access derived hashes & other arguments directly.\r\n        assembly {\r\n            // Retrieve pointer to the region located just behind parameters.\r\n            let typeHashPtr := sub(orderParameters, OneWord)\r\n\r\n            // Store the value at that pointer location to restore later.\r\n            let previousValue := mload(typeHashPtr)\r\n\r\n            // Store the order item EIP-712 typehash at the typehash location.\r\n            mstore(typeHashPtr, typeHash)\r\n\r\n            // Retrieve the pointer for the offer array head.\r\n            let offerHeadPtr := add(\r\n                orderParameters,\r\n                OrderParameters_offer_head_offset\r\n            )\r\n\r\n            // Retrieve the data pointer referenced by the offer head.\r\n            let offerDataPtr := mload(offerHeadPtr)\r\n\r\n            // Store the offer hash at the retrieved memory location.\r\n            mstore(offerHeadPtr, offerHash)\r\n\r\n            // Retrieve the pointer for the consideration array head.\r\n            let considerationHeadPtr := add(\r\n                orderParameters,\r\n                OrderParameters_consideration_head_offset\r\n            )\r\n\r\n            // Retrieve the data pointer referenced by the consideration head.\r\n            let considerationDataPtr := mload(considerationHeadPtr)\r\n\r\n            // Store the consideration hash at the retrieved memory location.\r\n            mstore(considerationHeadPtr, considerationHash)\r\n\r\n            // Retrieve the pointer for the counter.\r\n            let counterPtr := add(\r\n                orderParameters,\r\n                OrderParameters_counter_offset\r\n            )\r\n\r\n            // Store the counter at the retrieved memory location.\r\n            mstore(counterPtr, counter)\r\n\r\n            // Derive the order hash using the full range of order parameters.\r\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\r\n\r\n            // Restore the value previously held at typehash pointer location.\r\n            mstore(typeHashPtr, previousValue)\r\n\r\n            // Restore offer data pointer at the offer head pointer location.\r\n            mstore(offerHeadPtr, offerDataPtr)\r\n\r\n            // Restore consideration data pointer at the consideration head ptr.\r\n            mstore(considerationHeadPtr, considerationDataPtr)\r\n\r\n            // Restore consideration item length at the counter pointer.\r\n            mstore(counterPtr, originalConsiderationLength)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to derive the address of a given conduit\r\n     *      using a corresponding conduit key.\r\n     *\r\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\r\n     *                   if any, to source token approvals from. This value is\r\n     *                   the \"salt\" parameter supplied by the deployer (i.e. the\r\n     *                   conduit controller) when deploying the given conduit.\r\n     *\r\n     * @return conduit The address of the conduit associated with the given\r\n     *                 conduit key.\r\n     */\r\n    function _deriveConduit(\r\n        bytes32 conduitKey\r\n    ) internal view returns (address conduit) {\r\n        // Read conduit controller address from runtime and place on the stack.\r\n        address conduitController = address(_CONDUIT_CONTROLLER);\r\n\r\n        // Read conduit creation code hash from runtime and place on the stack.\r\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\r\n\r\n        // Leverage scratch space to perform an efficient hash.\r\n        assembly {\r\n            // Retrieve the free memory pointer; it will be replaced afterwards.\r\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\r\n\r\n            // Place the control character and the conduit controller in scratch\r\n            // space; note that eleven bytes at the beginning are left unused.\r\n            mstore(0, or(MaskOverByteTwelve, conduitController))\r\n\r\n            // Place the conduit key in the next region of scratch space.\r\n            mstore(OneWord, conduitKey)\r\n\r\n            // Place conduit creation code hash in free memory pointer location.\r\n            mstore(TwoWords, conduitCreationCodeHash)\r\n\r\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\r\n            conduit := and(\r\n                // Hash the relevant region.\r\n                keccak256(\r\n                    // The region starts at memory pointer 11.\r\n                    Create2AddressDerivation_ptr,\r\n                    // The region is 85 bytes long (1 + 20 + 32 + 32).\r\n                    Create2AddressDerivation_length\r\n                ),\r\n                // The address equals the last twenty bytes of the hash.\r\n                MaskOverLastTwentyBytes\r\n            )\r\n\r\n            // Restore the free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to get the EIP-712 domain separator. If the\r\n     *      chainId matches the chainId set on deployment, the cached domain\r\n     *      separator will be returned; otherwise, it will be derived from\r\n     *      scratch.\r\n     *\r\n     * @return The domain separator.\r\n     */\r\n    function _domainSeparator() internal view returns (bytes32) {\r\n        return block.chainid == _CHAIN_ID\r\n            ? _DOMAIN_SEPARATOR\r\n            : _deriveDomainSeparator();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to retrieve configuration information for\r\n     *      this contract.\r\n     *\r\n     * @return The contract version.\r\n     * @return The domain separator for this contract.\r\n     * @return The conduit Controller set for this contract.\r\n     */\r\n    function _information()\r\n        internal\r\n        view\r\n        returns (\r\n            string memory /* version */,\r\n            bytes32 /* domainSeparator */,\r\n            address /* conduitController */\r\n        )\r\n    {\r\n        // Derive the domain separator.\r\n        bytes32 domainSeparator = _domainSeparator();\r\n\r\n        // Declare variable as immutables cannot be accessed within assembly.\r\n        address conduitController = address(_CONDUIT_CONTROLLER);\r\n\r\n        // Return the version, domain separator, and conduit controller.\r\n        assembly {\r\n            mstore(information_version_offset, information_version_cd_offset)\r\n            mstore(information_domainSeparator_offset, domainSeparator)\r\n            mstore(information_conduitController_offset, conduitController)\r\n            mstore(information_versionLengthPtr, information_versionWithLength)\r\n            return(information_version_offset, information_length)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to efficiently derive an digest to sign for\r\n     *      an order in accordance with EIP-712.\r\n     *\r\n     * @param domainSeparator The domain separator.\r\n     * @param orderHash       The order hash.\r\n     *\r\n     * @return value The hash.\r\n     */\r\n    function _deriveEIP712Digest(\r\n        bytes32 domainSeparator,\r\n        bytes32 orderHash\r\n    ) internal pure returns (bytes32 value) {\r\n        // Leverage scratch space to perform an efficient hash.\r\n        assembly {\r\n            // Place the EIP-712 prefix at the start of scratch space.\r\n            mstore(0, EIP_712_PREFIX)\r\n\r\n            // Place the domain separator in the next region of scratch space.\r\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\r\n\r\n            // Place the order hash in scratch space, spilling into the first\r\n            // two bytes of the free memory pointer \u2014 this should never be set\r\n            // as memory cannot be expanded to that size, and will be zeroed out\r\n            // after the hash is performed.\r\n            mstore(EIP712_OrderHash_offset, orderHash)\r\n\r\n            // Hash the relevant region (65 bytes).\r\n            value := keccak256(0, EIP712_DigestPayload_size)\r\n\r\n            // Clear out the dirtied bits in the memory pointer.\r\n            mstore(EIP712_OrderHash_offset, 0)\r\n        }\r\n    }\r\n}\r\ncontract LowLevelHelpers {\r\n    /**\r\n     * @dev Internal view function to revert and pass along the revert reason if\r\n     *      data was returned by the last call and that the size of that data\r\n     *      does not exceed the currently allocated memory size.\r\n     */\r\n    function _revertWithReasonIfOneIsReturned() internal view {\r\n        assembly {\r\n            // If it returned a message, bubble it up as long as sufficient gas\r\n            // remains to do so:\r\n            if returndatasize() {\r\n                // Ensure that sufficient gas is available to copy returndata\r\n                // while expanding memory where necessary. Start by computing\r\n                // the word size of returndata and allocated memory.\r\n                let returnDataWords := shr(\r\n                    OneWordShift,\r\n                    add(returndatasize(), ThirtyOneBytes)\r\n                )\r\n\r\n                // Note: use the free memory pointer in place of msize() to work\r\n                // around a Yul warning that prevents accessing msize directly\r\n                // when the IR pipeline is activated.\r\n                let msizeWords := shr(\r\n                    OneWordShift,\r\n                    mload(FreeMemoryPointerSlot)\r\n                )\r\n\r\n                // Next, compute the cost of the returndatacopy.\r\n                let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                // Then, compute cost of new memory allocation.\r\n                if gt(returnDataWords, msizeWords) {\r\n                    cost := add(\r\n                        cost,\r\n                        add(\r\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\r\n                            shr(\r\n                                MemoryExpansionCoefficientShift,\r\n                                sub(\r\n                                    mul(returnDataWords, returnDataWords),\r\n                                    mul(msizeWords, msizeWords)\r\n                                )\r\n                            )\r\n                        )\r\n                    )\r\n                }\r\n\r\n                // Finally, add a small constant and compare to gas remaining;\r\n                // bubble up the revert data if enough gas is still available.\r\n                if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                    // Copy returndata to memory; overwrite existing memory.\r\n                    returndatacopy(0, 0, returndatasize())\r\n\r\n                    // Revert, specifying memory region with copied returndata.\r\n                    revert(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to branchlessly select either the caller (if\r\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\r\n     *      that recipient is a nonzero value).\r\n     *\r\n     * @param recipient The supplied recipient.\r\n     *\r\n     * @return updatedRecipient The updated recipient.\r\n     */\r\n    function _substituteCallerForEmptyRecipient(\r\n        address recipient\r\n    ) internal view returns (address updatedRecipient) {\r\n        // Utilize assembly to perform a branchless operation on the recipient.\r\n        assembly {\r\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\r\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\r\n     *\r\n     * @param b The `bool` value to cast.\r\n     *\r\n     * @return u The `uint256` value.\r\n     */\r\n    function _cast(bool b) internal pure returns (uint256 u) {\r\n        assembly {\r\n            u := b\r\n        }\r\n    }\r\n}\r\ninterface ReentrancyErrors {\r\n    error NoReentrantCalls();\r\n}\r\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\r\n    uint256 private _reentrancyGuard;\r\n    constructor() {\r\n        _reentrancyGuard = _NOT_ENTERED;\r\n    }\r\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\r\n        _assertNonReentrant();\r\n        unchecked {\r\n            _reentrancyGuard = _ENTERED + _cast(acceptNativeTokens);\r\n        }\r\n    }\r\n    function _clearReentrancyGuard() internal {\r\n        _reentrancyGuard = _NOT_ENTERED;\r\n    }\r\n    function _assertNonReentrant() internal view {\r\n        if (_reentrancyGuard != _NOT_ENTERED) {\r\n            _revertNoReentrantCalls();\r\n        }\r\n    }\r\n    function _assertAcceptingNativeTokens() internal view {\r\n        if (_reentrancyGuard != _ENTERED_AND_ACCEPTING_NATIVE_TOKENS) {\r\n            _revertInvalidMsgValue(msg.value);\r\n        }\r\n    }\r\n}\r\n\r\ncontract CounterManager is ConsiderationEventsAndErrors, ReentrancyGuard {\r\n    mapping(address => uint256) private _counters;\r\n\r\n    function _incrementCounter() internal returns (uint256 newCounter) {\r\n        _assertNonReentrant();\r\n        assembly {\r\n            let quasiRandomNumber := shr(\r\n                Counter_blockhash_shift,\r\n                blockhash(sub(number(), 1))\r\n            )\r\n            mstore(0, caller())\r\n            mstore(OneWord, _counters.slot)\r\n            let storagePointer := keccak256(0, TwoWords)\r\n            newCounter := add(quasiRandomNumber, sload(storagePointer))\r\n            sstore(storagePointer, newCounter)\r\n        }\r\n        emit CounterIncremented(newCounter, msg.sender);\r\n    }\r\n    function _getCounter(\r\n        address offerer\r\n    ) internal view returns (uint256 currentCounter) {\r\n        // Return the counter for the supplied offerer.\r\n        currentCounter = _counters[offerer];\r\n    }\r\n}\r\n\r\ninterface TokenTransferrerErrors {\r\n    /**\r\n     * @dev Revert with an error when an ERC721 transfer with amount other than\r\n     *      one is attempted.\r\n     *\r\n     * @param amount The amount of the ERC721 tokens to transfer.\r\n     */\r\n    error InvalidERC721TransferAmount(uint256 amount);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fulfill an order where an\r\n     *      item has an amount of zero.\r\n     */\r\n    error MissingItemAmount();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fulfill an order where an\r\n     *      item has unused parameters. This includes both the token and the\r\n     *      identifier parameters for native transfers as well as the identifier\r\n     *      parameter for ERC20 transfers. Note that the conduit does not\r\n     *      perform this check, leaving it up to the calling channel to enforce\r\n     *      when desired.\r\n     */\r\n    error UnusedItemParameters();\r\n\r\n    /**\r\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\r\n     *      transfer reverts.\r\n     *\r\n     * @param token      The token for which the transfer was attempted.\r\n     * @param from       The source of the attempted transfer.\r\n     * @param to         The recipient of the attempted transfer.\r\n     * @param identifier The identifier for the attempted transfer.\r\n     * @param amount     The amount for the attempted transfer.\r\n     */\r\n    error TokenTransferGenericFailure(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\r\n     *\r\n     * @param token       The token for which the transfer was attempted.\r\n     * @param from        The source of the attempted transfer.\r\n     * @param to          The recipient of the attempted transfer.\r\n     * @param identifiers The identifiers for the attempted transfer.\r\n     * @param amounts     The amounts for the attempted transfer.\r\n     */\r\n    error ERC1155BatchTransferGenericFailure(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256[] identifiers,\r\n        uint256[] amounts\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\r\n     *      value.\r\n     *\r\n     * @param token      The token for which the ERC20 transfer was attempted.\r\n     * @param from       The source of the attempted ERC20 transfer.\r\n     * @param to         The recipient of the attempted ERC20 transfer.\r\n     * @param amount     The amount for the attempted ERC20 transfer.\r\n     */\r\n    error BadReturnValueFromERC20OnTransfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when an account being called as an assumed\r\n     *      contract does not have code and returns no data.\r\n     *\r\n     * @param account The account that should contain code.\r\n     */\r\n    error NoContract(address account);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to execute an 1155 batch\r\n     *      transfer using calldata not produced by default ABI encoding or with\r\n     *      different lengths for ids and amounts arrays.\r\n     */\r\n    error Invalid1155BatchTransferEncoding();\r\n}\r\n\r\ncontract Assertions is\r\n    GettersAndDerivers,\r\n    CounterManager,\r\n    TokenTransferrerErrors\r\n{\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(\r\n        address conduitController\r\n    ) GettersAndDerivers(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal view function to ensure that the supplied consideration\r\n     *      array length on a given set of order parameters is not less than the\r\n     *      original consideration array length for that order and to retrieve\r\n     *      the current counter for a given order's offerer and zone and use it\r\n     *      to derive the order hash.\r\n     *\r\n     * @param orderParameters The parameters of the order to hash.\r\n     *\r\n     * @return The hash.\r\n     */\r\n    function _assertConsiderationLengthAndGetOrderHash(\r\n        OrderParameters memory orderParameters\r\n    ) internal view returns (bytes32) {\r\n        // Ensure supplied consideration array length is not less than original.\r\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\r\n            orderParameters.consideration.length,\r\n            orderParameters.totalOriginalConsiderationItems\r\n        );\r\n\r\n        // Derive and return order hash using current counter for the offerer.\r\n        return\r\n            _deriveOrderHash(\r\n                orderParameters,\r\n                _getCounter(orderParameters.offerer)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to ensure that the supplied consideration\r\n     *      array length for an order to be fulfilled is not less than the\r\n     *      original consideration array length for that order.\r\n     *\r\n     * @param suppliedConsiderationItemTotal The number of consideration items\r\n     *                                       supplied when fulfilling the order.\r\n     * @param originalConsiderationItemTotal The number of consideration items\r\n     *                                       supplied on initial order creation.\r\n     */\r\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\r\n        uint256 suppliedConsiderationItemTotal,\r\n        uint256 originalConsiderationItemTotal\r\n    ) internal pure {\r\n        // Ensure supplied consideration array length is not less than original.\r\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\r\n            _revertMissingOriginalConsiderationItems();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to ensure that a given item amount is not\r\n     *      zero.\r\n     *\r\n     * @param amount The amount to check.\r\n     */\r\n    function _assertNonZeroAmount(uint256 amount) internal pure {\r\n        assembly {\r\n            if iszero(amount) {\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, MissingItemAmount_error_selector)\r\n\r\n                // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\r\n                revert(Error_selector_offset, MissingItemAmount_error_length)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to validate calldata offsets for dynamic\r\n     *      types in BasicOrderParameters and other parameters. This ensures\r\n     *      that functions using the calldata object normally will be using the\r\n     *      same data as the assembly functions and that values that are bound\r\n     *      to a given range are within that range. Note that no parameters are\r\n     *      supplied as all basic order functions use the same calldata\r\n     *      encoding.\r\n     */\r\n    function _assertValidBasicOrderParameters() internal pure {\r\n        // Declare a boolean designating basic order parameter offset validity.\r\n        bool validOffsets;\r\n\r\n        // Utilize assembly in order to read offset data directly from calldata.\r\n        assembly {\r\n            /*\r\n             * Checks:\r\n             * 1. Order parameters struct offset == 0x20\r\n             * 2. Additional recipients arr offset == 0x240\r\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\r\n             * 4. BasicOrderType between 0 and 23 (i.e. < 24)\r\n             * 5. Offerer, zone, offer token, and consideration token have no\r\n             *    upper dirty bits \u2014 each argument is type(uint160).max or less\r\n             */\r\n            validOffsets := and(\r\n                and(\r\n                    and(\r\n                        // Order parameters at cd 0x04 must have offset of 0x20.\r\n                        eq(\r\n                            calldataload(BasicOrder_parameters_cdPtr),\r\n                            BasicOrder_parameters_ptr\r\n                        ),\r\n                        // Additional recipients (cd 0x224) arr offset == 0x240.\r\n                        eq(\r\n                            calldataload(\r\n                                BasicOrder_additionalRecipients_head_cdPtr\r\n                            ),\r\n                            BasicOrder_additionalRecipients_head_ptr\r\n                        )\r\n                    ),\r\n                    // Signature offset == 0x260 + (recipients.length * 0x40).\r\n                    eq(\r\n                        // Load signature offset from calldata 0x244.\r\n                        calldataload(BasicOrder_signature_cdPtr),\r\n                        // Expected offset is start of recipients + len * 64.\r\n                        add(\r\n                            BasicOrder_signature_ptr,\r\n                            shl(\r\n                                // Each additional recipient has length of 0x40.\r\n                                AdditionalRecipient_size_shift,\r\n                                // Additional recipients length at cd 0x264.\r\n                                calldataload(\r\n                                    BasicOrder_additionalRecipients_length_cdPtr\r\n                                )\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                and(\r\n                    // Ensure BasicOrderType parameter is less than 0x18.\r\n                    lt(\r\n                        // BasicOrderType parameter at calldata offset 0x124.\r\n                        calldataload(BasicOrder_basicOrderType_cdPtr),\r\n                        // Value should be less than 24.\r\n                        BasicOrder_basicOrderType_range\r\n                    ),\r\n                    // Ensure no dirty upper bits are present on offerer, zone,\r\n                    // offer token, or consideration token.\r\n                    lt(\r\n                        or(\r\n                            or(\r\n                                // Offerer parameter at calldata offset 0x84.\r\n                                calldataload(BasicOrder_offerer_cdPtr),\r\n                                // Zone parameter at calldata offset 0xa4.\r\n                                calldataload(BasicOrder_zone_cdPtr)\r\n                            ),\r\n                            or(\r\n                                // Offer token parameter at cd offset 0xc4.\r\n                                calldataload(BasicOrder_offerToken_cdPtr),\r\n                                // Consideration token parameter at offset 0x24.\r\n                                calldataload(\r\n                                    BasicOrder_considerationToken_cdPtr\r\n                                )\r\n                            )\r\n                        ),\r\n                        AddressDirtyUpperBitThreshold\r\n                    )\r\n                )\r\n            )\r\n        }\r\n\r\n        // Revert with an error if basic order parameter offsets are invalid.\r\n        if (!validOffsets) {\r\n            _revertInvalidBasicOrderParameterEncoding();\r\n        }\r\n    }\r\n}\r\ninterface SignatureVerificationErrors {\r\n    error BadSignatureV(uint8 v);\r\n    error InvalidSigner();\r\n    error InvalidSignature();\r\n    error BadContractSignature();\r\n}\r\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\r\n    /**\r\n     * @dev Internal view function to verify the signature of an order. An\r\n     *      ERC-1271 fallback will be attempted if either the signature length\r\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\r\n     *      supplied signer.\r\n     *\r\n     * @param signer                  The signer for the order.\r\n     * @param digest                  The digest to verify signature against.\r\n     * @param originalDigest          The original digest to verify signature\r\n     *                                against.\r\n     * @param originalSignatureLength The original signature length.\r\n     * @param signature               A signature from the signer indicating\r\n     *                                that the order has been approved.\r\n     */\r\n    function _assertValidSignature(\r\n        address signer,\r\n        bytes32 digest,\r\n        bytes32 originalDigest,\r\n        uint256 originalSignatureLength,\r\n        bytes memory signature\r\n    ) internal view {\r\n        // Declare value for ecrecover equality or 1271 call success status.\r\n        bool success;\r\n\r\n        // Utilize assembly to perform optimized signature verification check.\r\n        assembly {\r\n            // Ensure that first word of scratch space is empty.\r\n            mstore(0, 0)\r\n\r\n            // Get the length of the signature.\r\n            let signatureLength := mload(signature)\r\n\r\n            // Get the pointer to the value preceding the signature length.\r\n            // This will be used for temporary memory overrides - either the\r\n            // signature head for isValidSignature or the digest for ecrecover.\r\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\r\n\r\n            // Cache the current value behind the signature to restore it later.\r\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\r\n\r\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\r\n            {\r\n                // Take the difference between the max ECDSA signature length\r\n                // and the actual signature length. Overflow desired for any\r\n                // values > 65. If the diff is not 0 or 1, it is not a valid\r\n                // ECDSA signature - move on to EIP1271 check.\r\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\r\n\r\n                // Declare variable for recovered signer.\r\n                let recoveredSigner\r\n\r\n                // If diff is 0 or 1, it may be an ECDSA signature.\r\n                // Try to recover signer.\r\n                if iszero(gt(lenDiff, 1)) {\r\n                    // Read the signature `s` value.\r\n                    let originalSignatureS := mload(\r\n                        add(signature, ECDSA_signature_s_offset)\r\n                    )\r\n\r\n                    // Read the first byte of the word after `s`. If the\r\n                    // signature is 65 bytes, this will be the real `v` value.\r\n                    // If not, it will need to be modified - doing it this way\r\n                    // saves an extra condition.\r\n                    let v := byte(\r\n                        0,\r\n                        mload(add(signature, ECDSA_signature_v_offset))\r\n                    )\r\n\r\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\r\n                    if lenDiff {\r\n                        // Extract yParity from highest bit of vs and add 27 to\r\n                        // get v.\r\n                        v := add(\r\n                            shr(MaxUint8, originalSignatureS),\r\n                            Signature_lower_v\r\n                        )\r\n\r\n                        // Extract canonical s from vs, all but the highest bit.\r\n                        // Temporarily overwrite the original `s` value in the\r\n                        // signature.\r\n                        mstore(\r\n                            add(signature, ECDSA_signature_s_offset),\r\n                            and(\r\n                                originalSignatureS,\r\n                                EIP2098_allButHighestBitMask\r\n                            )\r\n                        )\r\n                    }\r\n                    // Temporarily overwrite the signature length with `v` to\r\n                    // conform to the expected input for ecrecover.\r\n                    mstore(signature, v)\r\n\r\n                    // Temporarily overwrite the word before the length with\r\n                    // `digest` to conform to the expected input for ecrecover.\r\n                    mstore(wordBeforeSignaturePtr, digest)\r\n\r\n                    // Attempt to recover the signer for the given signature. Do\r\n                    // not check the call status as ecrecover will return a null\r\n                    // address if the signature is invalid.\r\n                    pop(\r\n                        staticcall(\r\n                            gas(),\r\n                            Ecrecover_precompile, // Call ecrecover precompile.\r\n                            wordBeforeSignaturePtr, // Use data memory location.\r\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\r\n                            0, // Write result to scratch space.\r\n                            OneWord // Provide size of returned result.\r\n                        )\r\n                    )\r\n\r\n                    // Restore cached word before signature.\r\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\r\n\r\n                    // Restore cached signature length.\r\n                    mstore(signature, signatureLength)\r\n\r\n                    // Restore cached signature `s` value.\r\n                    mstore(\r\n                        add(signature, ECDSA_signature_s_offset),\r\n                        originalSignatureS\r\n                    )\r\n\r\n                    // Read the recovered signer from the buffer given as return\r\n                    // space for ecrecover.\r\n                    recoveredSigner := mload(0)\r\n                }\r\n\r\n                // Set success to true if the signature provided was a valid\r\n                // ECDSA signature and the signer is not the null address. Use\r\n                // gt instead of direct as success is used outside of assembly.\r\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\r\n            }\r\n\r\n            // If the signature was not verified with ecrecover, try EIP1271.\r\n            if iszero(success) {\r\n                // Reset the original signature length.\r\n                mstore(signature, originalSignatureLength)\r\n\r\n                // Temporarily overwrite the word before the signature length\r\n                // and use it as the head of the signature input to\r\n                // `isValidSignature`, which has a value of 64.\r\n                mstore(\r\n                    wordBeforeSignaturePtr,\r\n                    EIP1271_isValidSignature_signature_head_offset\r\n                )\r\n\r\n                // Get pointer to use for the selector of `isValidSignature`.\r\n                let selectorPtr := sub(\r\n                    signature,\r\n                    EIP1271_isValidSignature_selector_negativeOffset\r\n                )\r\n\r\n                // Cache the value currently stored at the selector pointer.\r\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\r\n\r\n                // Cache the value currently stored at the digest pointer.\r\n                let cachedWordOverwrittenByDigest := mload(\r\n                    sub(\r\n                        signature,\r\n                        EIP1271_isValidSignature_digest_negativeOffset\r\n                    )\r\n                )\r\n\r\n                // Write the selector first, since it overlaps the digest.\r\n                mstore(selectorPtr, EIP1271_isValidSignature_selector)\r\n\r\n                // Next, write the original digest.\r\n                mstore(\r\n                    sub(\r\n                        signature,\r\n                        EIP1271_isValidSignature_digest_negativeOffset\r\n                    ),\r\n                    originalDigest\r\n                )\r\n\r\n                // Call signer with `isValidSignature` to validate signature.\r\n                success := staticcall(\r\n                    gas(),\r\n                    signer,\r\n                    selectorPtr,\r\n                    add(\r\n                        originalSignatureLength,\r\n                        EIP1271_isValidSignature_calldata_baseLength\r\n                    ),\r\n                    0,\r\n                    OneWord\r\n                )\r\n\r\n                // Determine if the signature is valid on successful calls.\r\n                if success {\r\n                    // If first word of scratch space does not contain EIP-1271\r\n                    // signature selector, revert.\r\n                    if iszero(eq(mload(0), EIP1271_isValidSignature_selector)) {\r\n                        // Revert with bad 1271 signature if signer has code.\r\n                        if extcodesize(signer) {\r\n                            // Bad contract signature.\r\n                            // Store left-padded selector with push4, mem[28:32]\r\n                            mstore(0, BadContractSignature_error_selector)\r\n\r\n                            // revert(abi.encodeWithSignature(\r\n                            //     \"BadContractSignature()\"\r\n                            // ))\r\n                            revert(\r\n                                Error_selector_offset,\r\n                                BadContractSignature_error_length\r\n                            )\r\n                        }\r\n\r\n                        // Check if signature length was invalid.\r\n                        if gt(sub(ECDSA_MaxLength, signatureLength), 1) {\r\n                            // Revert with generic invalid signature error.\r\n                            // Store left-padded selector with push4, mem[28:32]\r\n                            mstore(0, InvalidSignature_error_selector)\r\n\r\n                            // revert(abi.encodeWithSignature(\r\n                            //     \"InvalidSignature()\"\r\n                            // ))\r\n                            revert(\r\n                                Error_selector_offset,\r\n                                InvalidSignature_error_length\r\n                            )\r\n                        }\r\n\r\n                        // Check if v was invalid.\r\n                        if and(\r\n                            eq(signatureLength, ECDSA_MaxLength),\r\n                            iszero(\r\n                                byte(\r\n                                    byte(\r\n                                        0,\r\n                                        mload(\r\n                                            add(\r\n                                                signature,\r\n                                                ECDSA_signature_v_offset\r\n                                            )\r\n                                        )\r\n                                    ),\r\n                                    ECDSA_twentySeventhAndTwentyEighthBytesSet\r\n                                )\r\n                            )\r\n                        ) {\r\n                            // Revert with invalid v value.\r\n                            // Store left-padded selector with push4, mem[28:32]\r\n                            mstore(0, BadSignatureV_error_selector)\r\n                            mstore(\r\n                                BadSignatureV_error_v_ptr,\r\n                                byte(\r\n                                    0,\r\n                                    mload(\r\n                                        add(signature, ECDSA_signature_v_offset)\r\n                                    )\r\n                                )\r\n                            )\r\n\r\n                            // revert(abi.encodeWithSignature(\r\n                            //     \"BadSignatureV(uint8)\", v\r\n                            // ))\r\n                            revert(\r\n                                Error_selector_offset,\r\n                                BadSignatureV_error_length\r\n                            )\r\n                        }\r\n\r\n                        // Revert with generic invalid signer error message.\r\n                        // Store left-padded selector with push4, mem[28:32]\r\n                        mstore(0, InvalidSigner_error_selector)\r\n\r\n                        // revert(abi.encodeWithSignature(\"InvalidSigner()\"))\r\n                        revert(\r\n                            Error_selector_offset,\r\n                            InvalidSigner_error_length\r\n                        )\r\n                    }\r\n                }\r\n\r\n                // Restore the cached values overwritten by selector, digest and\r\n                // signature head.\r\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\r\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\r\n                mstore(\r\n                    sub(\r\n                        signature,\r\n                        EIP1271_isValidSignature_digest_negativeOffset\r\n                    ),\r\n                    cachedWordOverwrittenByDigest\r\n                )\r\n            }\r\n        }\r\n\r\n        // If the call failed...\r\n        if (!success) {\r\n            // Revert and pass reason along if one was returned.\r\n            _revertWithReasonIfOneIsReturned();\r\n\r\n            // Otherwise, revert with error indicating bad contract signature.\r\n            assembly {\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, BadContractSignature_error_selector)\r\n                // revert(abi.encodeWithSignature(\"BadContractSignature()\"))\r\n                revert(Error_selector_offset, BadContractSignature_error_length)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Verifiers is Assertions, SignatureVerification {\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) Assertions(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal view function to ensure that the current time falls within\r\n     *      an order's valid timespan.\r\n     *\r\n     * @param startTime       The time at which the order becomes active.\r\n     * @param endTime         The time at which the order becomes inactive.\r\n     * @param revertOnInvalid A boolean indicating whether to revert if the\r\n     *                        order is not active.\r\n     *\r\n     * @return valid A boolean indicating whether the order is active.\r\n     */\r\n    function _verifyTime(\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool revertOnInvalid\r\n    ) internal view returns (bool valid) {\r\n        // Mark as valid if order has started and has not already ended.\r\n        assembly {\r\n            valid := and(\r\n                iszero(gt(startTime, timestamp())),\r\n                gt(endTime, timestamp())\r\n            )\r\n        }\r\n\r\n        // Only revert on invalid if revertOnInvalid has been supplied as true.\r\n        if (revertOnInvalid && !valid) {\r\n            _revertInvalidTime(startTime, endTime);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to verify the signature of an order. An\r\n     *      ERC-1271 fallback will be attempted if either the signature length\r\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\r\n     *      supplied offerer. Note that in cases where a 64 or 65 byte signature\r\n     *      is supplied, only standard ECDSA signatures that recover to a\r\n     *      non-zero address are supported.\r\n     *\r\n     * @param offerer   The offerer for the order.\r\n     * @param orderHash The order hash.\r\n     * @param signature A signature from the offerer indicating that the order\r\n     *                  has been approved.\r\n     */\r\n    function _verifySignature(\r\n        address offerer,\r\n        bytes32 orderHash,\r\n        bytes memory signature\r\n    ) internal view {\r\n        // Determine whether the offerer is the caller.\r\n        bool offererIsCaller;\r\n        assembly {\r\n            offererIsCaller := eq(offerer, caller())\r\n        }\r\n\r\n        // Skip signature verification if the offerer is the caller.\r\n        if (offererIsCaller) {\r\n            return;\r\n        }\r\n\r\n        // Derive the EIP-712 domain separator.\r\n        bytes32 domainSeparator = _domainSeparator();\r\n\r\n        // Derive original EIP-712 digest using domain separator and order hash.\r\n        bytes32 originalDigest = _deriveEIP712Digest(\r\n            domainSeparator,\r\n            orderHash\r\n        );\r\n\r\n        // Read the length of the signature from memory and place on the stack.\r\n        uint256 originalSignatureLength = signature.length;\r\n\r\n        // Determine effective digest if signature has a valid bulk order size.\r\n        bytes32 digest;\r\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\r\n            // Rederive order hash and digest using bulk order proof.\r\n            (orderHash) = _computeBulkOrderProof(signature, orderHash);\r\n            digest = _deriveEIP712Digest(domainSeparator, orderHash);\r\n        } else {\r\n            // Supply the original digest as the effective digest.\r\n            digest = originalDigest;\r\n        }\r\n\r\n        // Ensure that the signature for the digest is valid for the offerer.\r\n        _assertValidSignature(\r\n            offerer,\r\n            digest,\r\n            originalDigest,\r\n            originalSignatureLength,\r\n            signature\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Determines whether the specified bulk order size is valid.\r\n     *\r\n     * @param signatureLength The signature length of the bulk order to check.\r\n     *\r\n     * @return validLength True if bulk order size is valid, false otherwise.\r\n     */\r\n    function _isValidBulkOrderSize(\r\n        uint256 signatureLength\r\n    ) internal pure returns (bool validLength) {\r\n        // Utilize assembly to validate the length; the equivalent logic is\r\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24).\r\n        assembly {\r\n            validLength := and(\r\n                lt(\r\n                    sub(signatureLength, BulkOrderProof_minSize),\r\n                    BulkOrderProof_rangeSize\r\n                ),\r\n                lt(\r\n                    and(\r\n                        add(\r\n                            signatureLength,\r\n                            BulkOrderProof_lengthAdjustmentBeforeMask\r\n                        ),\r\n                        ThirtyOneBytes\r\n                    ),\r\n                    BulkOrderProof_lengthRangeAfterMask\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the bulk order hash for the specified proof and leaf. Note\r\n     *      that if an index that exceeds the number of orders in the bulk order\r\n     *      payload will instead \"wrap around\" and refer to an earlier index.\r\n     *\r\n     * @param proofAndSignature The proof and signature of the bulk order.\r\n     * @param leaf              The leaf of the bulk order tree.\r\n     *\r\n     * @return bulkOrderHash The bulk order hash.\r\n     */\r\n    function _computeBulkOrderProof(\r\n        bytes memory proofAndSignature,\r\n        bytes32 leaf\r\n    ) internal pure returns (bytes32 bulkOrderHash) {\r\n        // Declare arguments for the root hash and the height of the proof.\r\n        bytes32 root;\r\n        uint256 height;\r\n\r\n        // Utilize assembly to efficiently derive the root hash using the proof.\r\n        assembly {\r\n            // Retrieve the length of the proof, key, and signature combined.\r\n            let fullLength := mload(proofAndSignature)\r\n\r\n            // If proofAndSignature has odd length, it is a compact signature\r\n            // with 64 bytes.\r\n            let signatureLength := sub(ECDSA_MaxLength, and(fullLength, 1))\r\n\r\n            // Derive height (or depth of tree) with signature and proof length.\r\n            height := shr(OneWordShift, sub(fullLength, signatureLength))\r\n\r\n            // Update the length in memory to only include the signature.\r\n            mstore(proofAndSignature, signatureLength)\r\n\r\n            // Derive the pointer for the key using the signature length.\r\n            let keyPtr := add(proofAndSignature, add(OneWord, signatureLength))\r\n\r\n            // Retrieve the three-byte key using the derived pointer.\r\n            let key := shr(BulkOrderProof_keyShift, mload(keyPtr))\r\n\r\n            /// Retrieve pointer to first proof element by applying a constant\r\n            // for the key size to the derived key pointer.\r\n            let proof := add(keyPtr, BulkOrderProof_keySize)\r\n\r\n            // Compute level 1.\r\n            let scratchPtr1 := shl(OneWordShift, and(key, 1))\r\n            mstore(scratchPtr1, leaf)\r\n            mstore(xor(scratchPtr1, OneWord), mload(proof))\r\n\r\n            // Compute remaining proofs.\r\n            for {\r\n                let i := 1\r\n            } lt(i, height) {\r\n                i := add(i, 1)\r\n            } {\r\n                proof := add(proof, OneWord)\r\n                let scratchPtr := shl(OneWordShift, and(shr(i, key), 1))\r\n                mstore(scratchPtr, keccak256(0, TwoWords))\r\n                mstore(xor(scratchPtr, OneWord), mload(proof))\r\n            }\r\n\r\n            // Compute root hash.\r\n            root := keccak256(0, TwoWords)\r\n        }\r\n\r\n        // Retrieve appropriate typehash constant based on height.\r\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\r\n\r\n        // Use the typehash and the root hash to derive final bulk order hash.\r\n        assembly {\r\n            mstore(0, rootTypeHash)\r\n            mstore(OneWord, root)\r\n            bulkOrderHash := keccak256(0, TwoWords)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to validate that a given order is fillable\r\n     *      and not cancelled based on the order status.\r\n     *\r\n     * @param orderHash       The order hash.\r\n     * @param orderStatus     The status of the order, including whether it has\r\n     *                        been cancelled and the fraction filled.\r\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\r\n     *                        are supported by the calling function.\r\n     * @param revertOnInvalid A boolean indicating whether to revert if the\r\n     *                        order has been cancelled or filled beyond the\r\n     *                        allowable amount.\r\n     *\r\n     * @return valid A boolean indicating whether the order is valid.\r\n     */\r\n    function _verifyOrderStatus(\r\n        bytes32 orderHash,\r\n        OrderStatus storage orderStatus,\r\n        bool onlyAllowUnused,\r\n        bool revertOnInvalid\r\n    ) internal view returns (bool valid) {\r\n        // Ensure that the order has not been cancelled.\r\n        if (orderStatus.isCancelled) {\r\n            // Only revert if revertOnInvalid has been supplied as true.\r\n            if (revertOnInvalid) {\r\n                _revertOrderIsCancelled(orderHash);\r\n            }\r\n\r\n            // Return false as the order status is invalid.\r\n            return false;\r\n        }\r\n\r\n        // Read order status numerator from storage and place on stack.\r\n        uint256 orderStatusNumerator = orderStatus.numerator;\r\n\r\n        // If the order is not entirely unused...\r\n        if (orderStatusNumerator != 0) {\r\n            // ensure the order has not been partially filled when not allowed.\r\n            if (onlyAllowUnused) {\r\n                // Always revert on partial fills when onlyAllowUnused is true.\r\n                _revertOrderPartiallyFilled(orderHash);\r\n            }\r\n            // Otherwise, ensure that order has not been entirely filled.\r\n            else if (orderStatusNumerator >= orderStatus.denominator) {\r\n                // Only revert if revertOnInvalid has been supplied as true.\r\n                if (revertOnInvalid) {\r\n                    _revertOrderAlreadyFilled(orderHash);\r\n                }\r\n\r\n                // Return false as the order status is invalid.\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Return true as the order status is valid.\r\n        valid = true;\r\n    }\r\n}\r\ncontract TokenTransferrer is TokenTransferrerErrors {\r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens from a given originator\r\n     *      to a given recipient. Sufficient approvals must be set on the\r\n     *      contract performing the transfer.\r\n     *\r\n     * @param token      The ERC20 token to transfer.\r\n     * @param from       The originator of the transfer.\r\n     * @param to         The recipient of the transfer.\r\n     * @param amount     The amount to transfer.\r\n     */\r\n    function _performERC20Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        // Utilize assembly to perform an optimized ERC20 token transfer.\r\n        assembly {\r\n            // The free memory pointer memory slot will be used when populating\r\n            // call data for the transfer; read the value and restore it later.\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n\r\n            // Write call data into memory, starting with function selector.\r\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\r\n            mstore(ERC20_transferFrom_from_ptr, from)\r\n            mstore(ERC20_transferFrom_to_ptr, to)\r\n            mstore(ERC20_transferFrom_amount_ptr, amount)\r\n\r\n            // Make call & copy up to 32 bytes of return data to scratch space.\r\n            // Scratch space does not need to be cleared ahead of time, as the\r\n            // subsequent check will ensure that either at least a full word of\r\n            // return data is received (in which case it will be overwritten) or\r\n            // that no data is received (in which case scratch space will be\r\n            // ignored) on a successful call to the given token.\r\n            let callStatus := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC20_transferFrom_sig_ptr,\r\n                ERC20_transferFrom_length,\r\n                0,\r\n                OneWord\r\n            )\r\n\r\n            // Determine whether transfer was successful using status & result.\r\n            let success := and(\r\n                // Set success to whether the call reverted, if not check it\r\n                // either returned exactly 1 (can't just be non-zero data), or\r\n                // had no return data.\r\n                or(\r\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\r\n                    iszero(returndatasize())\r\n                ),\r\n                callStatus\r\n            )\r\n\r\n            // Handle cases where either the transfer failed or no data was\r\n            // returned. Group these, as most transfers will succeed with data.\r\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\r\n            // but after it's inverted for JUMPI this expression is cheaper.\r\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\r\n                // If the token has no code or the transfer failed: Equivalent\r\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\r\n                // after it's inverted for JUMPI this expression is cheaper.\r\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\r\n                    // If the transfer failed:\r\n                    if iszero(success) {\r\n                        // If it was due to a revert:\r\n                        if iszero(callStatus) {\r\n                            // If it returned a message, bubble it up as long as\r\n                            // sufficient gas remains to do so:\r\n                            if returndatasize() {\r\n                                // Ensure that sufficient gas is available to\r\n                                // copy returndata while expanding memory where\r\n                                // necessary. Start by computing the word size\r\n                                // of returndata and allocated memory. Round up\r\n                                // to the nearest full word.\r\n                                let returnDataWords := shr(\r\n                                    OneWordShift,\r\n                                    add(returndatasize(), ThirtyOneBytes)\r\n                                )\r\n\r\n                                // Note: use the free memory pointer in place of\r\n                                // msize() to work around a Yul warning that\r\n                                // prevents accessing msize directly when the IR\r\n                                // pipeline is activated.\r\n                                let msizeWords := shr(OneWordShift, memPointer)\r\n\r\n                                // Next, compute the cost of the returndatacopy.\r\n                                let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                                // Then, compute cost of new memory allocation.\r\n                                if gt(returnDataWords, msizeWords) {\r\n                                    cost := add(\r\n                                        cost,\r\n                                        add(\r\n                                            mul(\r\n                                                sub(\r\n                                                    returnDataWords,\r\n                                                    msizeWords\r\n                                                ),\r\n                                                CostPerWord\r\n                                            ),\r\n                                            shr(\r\n                                                MemoryExpansionCoefficientShift,\r\n                                                sub(\r\n                                                    mul(\r\n                                                        returnDataWords,\r\n                                                        returnDataWords\r\n                                                    ),\r\n                                                    mul(msizeWords, msizeWords)\r\n                                                )\r\n                                            )\r\n                                        )\r\n                                    )\r\n                                }\r\n\r\n                                // Finally, add a small constant and compare to\r\n                                // gas remaining; bubble up the revert data if\r\n                                // enough gas is still available.\r\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                                    // Copy returndata to memory; overwrite\r\n                                    // existing memory.\r\n                                    returndatacopy(0, 0, returndatasize())\r\n\r\n                                    // Revert, specifying memory region with\r\n                                    // copied returndata.\r\n                                    revert(0, returndatasize())\r\n                                }\r\n                            }\r\n\r\n                            // Store left-padded selector with push4, mem[28:32]\r\n                            mstore(\r\n                                0,\r\n                                TokenTransferGenericFailure_error_selector\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_token_ptr,\r\n                                token\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_from_ptr,\r\n                                from\r\n                            )\r\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                            mstore(\r\n                                TokenTransferGenericFailure_err_identifier_ptr,\r\n                                0\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_amount_ptr,\r\n                                amount\r\n                            )\r\n\r\n                            // revert(abi.encodeWithSignature(\r\n                            //     \"TokenTransferGenericFailure(\r\n                            //         address,address,address,uint256,uint256\r\n                            //     )\", token, from, to, identifier, amount\r\n                            // ))\r\n                            revert(\r\n                                Generic_error_selector_offset,\r\n                                TokenTransferGenericFailure_error_length\r\n                            )\r\n                        }\r\n\r\n                        // Otherwise revert with a message about the token\r\n                        // returning false or non-compliant return values.\r\n\r\n                        // Store left-padded selector with push4, mem[28:32]\r\n                        mstore(\r\n                            0,\r\n                            BadReturnValueFromERC20OnTransfer_error_selector\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\r\n                            token\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\r\n                            from\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\r\n                            to\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\r\n                            amount\r\n                        )\r\n\r\n                        // revert(abi.encodeWithSignature(\r\n                        //     \"BadReturnValueFromERC20OnTransfer(\r\n                        //         address,address,address,uint256\r\n                        //     )\", token, from, to, amount\r\n                        // ))\r\n                        revert(\r\n                            Generic_error_selector_offset,\r\n                            BadReturnValueFromERC20OnTransfer_error_length\r\n                        )\r\n                    }\r\n\r\n                    // Otherwise, revert with error about token not having code:\r\n                    // Store left-padded selector with push4, mem[28:32]\r\n                    mstore(0, NoContract_error_selector)\r\n                    mstore(NoContract_error_account_ptr, token)\r\n\r\n                    // revert(abi.encodeWithSignature(\r\n                    //      \"NoContract(address)\", account\r\n                    // ))\r\n                    revert(\r\n                        Generic_error_selector_offset,\r\n                        NoContract_error_length\r\n                    )\r\n                }\r\n\r\n                // Otherwise, the token just returned no data despite the call\r\n                // having succeeded; no need to optimize for this as it's not\r\n                // technically ERC20 compliant.\r\n            }\r\n\r\n            // Restore the original free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an ERC721 token from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set on\r\n     *      the contract performing the transfer. Note that this function does\r\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\r\n     *      does not use `safeTransferFrom`).\r\n     *\r\n     * @param token      The ERC721 token to transfer.\r\n     * @param from       The originator of the transfer.\r\n     * @param to         The recipient of the transfer.\r\n     * @param identifier The tokenId to transfer.\r\n     */\r\n    function _performERC721Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier\r\n    ) internal {\r\n        // Utilize assembly to perform an optimized ERC721 token transfer.\r\n        assembly {\r\n            // If the token has no code, revert.\r\n            if iszero(extcodesize(token)) {\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, NoContract_error_selector)\r\n                mstore(NoContract_error_account_ptr, token)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"NoContract(address)\", account\r\n                // ))\r\n                revert(Generic_error_selector_offset, NoContract_error_length)\r\n            }\r\n\r\n            // The free memory pointer memory slot will be used when populating\r\n            // call data for the transfer; read the value and restore it later.\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n\r\n            // Write call data to memory starting with function selector.\r\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\r\n            mstore(ERC721_transferFrom_from_ptr, from)\r\n            mstore(ERC721_transferFrom_to_ptr, to)\r\n            mstore(ERC721_transferFrom_id_ptr, identifier)\r\n\r\n            // Perform the call, ignoring return data.\r\n            let success := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC721_transferFrom_sig_ptr,\r\n                ERC721_transferFrom_length,\r\n                0,\r\n                0\r\n            )\r\n\r\n            // If the transfer reverted:\r\n            if iszero(success) {\r\n                // If it returned a message, bubble it up as long as sufficient\r\n                // gas remains to do so:\r\n                if returndatasize() {\r\n                    // Ensure that sufficient gas is available to copy\r\n                    // returndata while expanding memory where necessary. Start\r\n                    // by computing word size of returndata & allocated memory.\r\n                    // Round up to the nearest full word.\r\n                    let returnDataWords := shr(\r\n                        OneWordShift,\r\n                        add(returndatasize(), ThirtyOneBytes)\r\n                    )\r\n\r\n                    // Note: use the free memory pointer in place of msize() to\r\n                    // work around a Yul warning that prevents accessing msize\r\n                    // directly when the IR pipeline is activated.\r\n                    let msizeWords := shr(OneWordShift, memPointer)\r\n\r\n                    // Next, compute the cost of the returndatacopy.\r\n                    let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                    // Then, compute cost of new memory allocation.\r\n                    if gt(returnDataWords, msizeWords) {\r\n                        cost := add(\r\n                            cost,\r\n                            add(\r\n                                mul(\r\n                                    sub(returnDataWords, msizeWords),\r\n                                    CostPerWord\r\n                                ),\r\n                                shr(\r\n                                    MemoryExpansionCoefficientShift,\r\n                                    sub(\r\n                                        mul(returnDataWords, returnDataWords),\r\n                                        mul(msizeWords, msizeWords)\r\n                                    )\r\n                                )\r\n                            )\r\n                        )\r\n                    }\r\n\r\n                    // Finally, add a small constant and compare to gas\r\n                    // remaining; bubble up the revert data if enough gas is\r\n                    // still available.\r\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                        // Copy returndata to memory; overwrite existing memory.\r\n                        returndatacopy(0, 0, returndatasize())\r\n\r\n                        // Revert, giving memory region with copied returndata.\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n\r\n                // Otherwise revert with a generic error message.\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, TokenTransferGenericFailure_error_selector)\r\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\r\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\r\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                mstore(\r\n                    TokenTransferGenericFailure_error_identifier_ptr,\r\n                    identifier\r\n                )\r\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"TokenTransferGenericFailure(\r\n                //         address,address,address,uint256,uint256\r\n                //     )\", token, from, to, identifier, amount\r\n                // ))\r\n                revert(\r\n                    Generic_error_selector_offset,\r\n                    TokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n\r\n            // Restore the original free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC1155 tokens from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set on\r\n     *      the contract performing the transfer and contract recipients must\r\n     *      implement the ERC1155TokenReceiver interface to indicate that they\r\n     *      are willing to accept the transfer.\r\n     *\r\n     * @param token      The ERC1155 token to transfer.\r\n     * @param from       The originator of the transfer.\r\n     * @param to         The recipient of the transfer.\r\n     * @param identifier The id to transfer.\r\n     * @param amount     The amount to transfer.\r\n     */\r\n    function _performERC1155Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    ) internal {\r\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\r\n        assembly {\r\n            // If the token has no code, revert.\r\n            if iszero(extcodesize(token)) {\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, NoContract_error_selector)\r\n                mstore(NoContract_error_account_ptr, token)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"NoContract(address)\", account\r\n                // ))\r\n                revert(Generic_error_selector_offset, NoContract_error_length)\r\n            }\r\n\r\n            // The following memory slots will be used when populating call data\r\n            // for the transfer; read the values and restore them later.\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n            let slot0x80 := mload(Slot0x80)\r\n            let slot0xA0 := mload(Slot0xA0)\r\n            let slot0xC0 := mload(Slot0xC0)\r\n\r\n            // Write call data into memory, beginning with function selector.\r\n            mstore(\r\n                ERC1155_safeTransferFrom_sig_ptr,\r\n                ERC1155_safeTransferFrom_signature\r\n            )\r\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\r\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\r\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\r\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\r\n            mstore(\r\n                ERC1155_safeTransferFrom_data_offset_ptr,\r\n                ERC1155_safeTransferFrom_data_length_offset\r\n            )\r\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\r\n\r\n            // Perform the call, ignoring return data.\r\n            let success := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC1155_safeTransferFrom_sig_ptr,\r\n                ERC1155_safeTransferFrom_length,\r\n                0,\r\n                0\r\n            )\r\n\r\n            // If the transfer reverted:\r\n            if iszero(success) {\r\n                // If it returned a message, bubble it up as long as sufficient\r\n                // gas remains to do so:\r\n                if returndatasize() {\r\n                    // Ensure that sufficient gas is available to copy\r\n                    // returndata while expanding memory where necessary. Start\r\n                    // by computing word size of returndata & allocated memory.\r\n                    // Round up to the nearest full word.\r\n                    let returnDataWords := shr(\r\n                        OneWordShift,\r\n                        add(returndatasize(), ThirtyOneBytes)\r\n                    )\r\n\r\n                    // Note: use the free memory pointer in place of msize() to\r\n                    // work around a Yul warning that prevents accessing msize\r\n                    // directly when the IR pipeline is activated.\r\n                    let msizeWords := shr(OneWordShift, memPointer)\r\n\r\n                    // Next, compute the cost of the returndatacopy.\r\n                    let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                    // Then, compute cost of new memory allocation.\r\n                    if gt(returnDataWords, msizeWords) {\r\n                        cost := add(\r\n                            cost,\r\n                            add(\r\n                                mul(\r\n                                    sub(returnDataWords, msizeWords),\r\n                                    CostPerWord\r\n                                ),\r\n                                shr(\r\n                                    MemoryExpansionCoefficientShift,\r\n                                    sub(\r\n                                        mul(returnDataWords, returnDataWords),\r\n                                        mul(msizeWords, msizeWords)\r\n                                    )\r\n                                )\r\n                            )\r\n                        )\r\n                    }\r\n\r\n                    // Finally, add a small constant and compare to gas\r\n                    // remaining; bubble up the revert data if enough gas is\r\n                    // still available.\r\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                        // Copy returndata to memory; overwrite existing memory.\r\n                        returndatacopy(0, 0, returndatasize())\r\n\r\n                        // Revert, giving memory region with copied returndata.\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n\r\n                // Otherwise revert with a generic error message.\r\n\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, TokenTransferGenericFailure_error_selector)\r\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\r\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\r\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                mstore(\r\n                    TokenTransferGenericFailure_error_identifier_ptr,\r\n                    identifier\r\n                )\r\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"TokenTransferGenericFailure(\r\n                //         address,address,address,uint256,uint256\r\n                //     )\", token, from, to, identifier, amount\r\n                // ))\r\n                revert(\r\n                    Generic_error_selector_offset,\r\n                    TokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n\r\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\r\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\r\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\r\n\r\n            // Restore the original free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC1155 tokens from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set on\r\n     *      the contract performing the transfer and contract recipients must\r\n     *      implement the ERC1155TokenReceiver interface to indicate that they\r\n     *      are willing to accept the transfer. NOTE: this function is not\r\n     *      memory-safe; it will overwrite existing memory, restore the free\r\n     *      memory pointer to the default value, and overwrite the zero slot.\r\n     *      This function should only be called once memory is no longer\r\n     *      required and when uninitialized arrays are not utilized, and memory\r\n     *      should be considered fully corrupted (aside from the existence of a\r\n     *      default-value free memory pointer) after calling this function.\r\n     *\r\n     * @param batchTransfers The group of 1155 batch transfers to perform.\r\n     */\r\n    function _performERC1155BatchTransfers(\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) internal {\r\n        // Utilize assembly to perform optimized batch 1155 transfers.\r\n        assembly {\r\n            let len := batchTransfers.length\r\n            // Pointer to first head in the array, which is offset to the struct\r\n            // at each index. This gets incremented after each loop to avoid\r\n            // multiplying by 32 to get the offset for each element.\r\n            let nextElementHeadPtr := batchTransfers.offset\r\n\r\n            // Pointer to beginning of the head of the array. This is the\r\n            // reference position each offset references. It's held static to\r\n            // let each loop calculate the data position for an element.\r\n            let arrayHeadPtr := nextElementHeadPtr\r\n\r\n            // Write the function selector, which will be reused for each call:\r\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\r\n            mstore(\r\n                ConduitBatch1155Transfer_from_offset,\r\n                ERC1155_safeBatchTransferFrom_signature\r\n            )\r\n\r\n            // Iterate over each batch transfer.\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n                i := add(i, 1)\r\n            } {\r\n                // Read the offset to the beginning of the element and add\r\n                // it to pointer to the beginning of the array head to get\r\n                // the absolute position of the element in calldata.\r\n                let elementPtr := add(\r\n                    arrayHeadPtr,\r\n                    calldataload(nextElementHeadPtr)\r\n                )\r\n\r\n                // Retrieve the token from calldata.\r\n                let token := calldataload(elementPtr)\r\n\r\n                // If the token has no code, revert.\r\n                if iszero(extcodesize(token)) {\r\n                    // Store left-padded selector with push4, mem[28:32]\r\n                    mstore(0, NoContract_error_selector)\r\n                    mstore(NoContract_error_account_ptr, token)\r\n\r\n                    // revert(abi.encodeWithSignature(\r\n                    //     \"NoContract(address)\", account\r\n                    // ))\r\n                    revert(\r\n                        Generic_error_selector_offset,\r\n                        NoContract_error_length\r\n                    )\r\n                }\r\n\r\n                // Get the total number of supplied ids.\r\n                let idsLength := calldataload(\r\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\r\n                )\r\n\r\n                // Determine the expected offset for the amounts array.\r\n                let expectedAmountsOffset := add(\r\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\r\n                    shl(OneWordShift, idsLength)\r\n                )\r\n\r\n                // Validate struct encoding.\r\n                let invalidEncoding := iszero(\r\n                    and(\r\n                        // ids.length == amounts.length\r\n                        eq(\r\n                            idsLength,\r\n                            calldataload(add(elementPtr, expectedAmountsOffset))\r\n                        ),\r\n                        and(\r\n                            // ids_offset == 0xa0\r\n                            eq(\r\n                                calldataload(\r\n                                    add(\r\n                                        elementPtr,\r\n                                        ConduitBatch1155Transfer_ids_head_offset\r\n                                    )\r\n                                ),\r\n                                ConduitBatch1155Transfer_ids_length_offset\r\n                            ),\r\n                            // amounts_offset == 0xc0 + ids.length*32\r\n                            eq(\r\n                                calldataload(\r\n                                    add(\r\n                                        elementPtr,\r\n                                        ConduitBatchTransfer_amounts_head_offset\r\n                                    )\r\n                                ),\r\n                                expectedAmountsOffset\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n\r\n                // Revert with an error if the encoding is not valid.\r\n                if invalidEncoding {\r\n                    // Store left-padded selector with push4, mem[28:32]\r\n                    mstore(\r\n                        Invalid1155BatchTransferEncoding_ptr,\r\n                        Invalid1155BatchTransferEncoding_selector\r\n                    )\r\n\r\n                    // revert(abi.encodeWithSignature(\r\n                    //     \"Invalid1155BatchTransferEncoding()\"\r\n                    // ))\r\n                    revert(\r\n                        Invalid1155BatchTransferEncoding_ptr,\r\n                        Invalid1155BatchTransferEncoding_length\r\n                    )\r\n                }\r\n\r\n                // Update the offset position for the next loop\r\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\r\n\r\n                // Copy the first section of calldata (before dynamic values).\r\n                calldatacopy(\r\n                    BatchTransfer1155Params_ptr,\r\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\r\n                    ConduitBatch1155Transfer_usable_head_size\r\n                )\r\n\r\n                // Determine size of calldata required for ids and amounts. Note\r\n                // that the size includes both lengths as well as the data.\r\n                let idsAndAmountsSize := add(\r\n                    TwoWords,\r\n                    shl(TwoWordsShift, idsLength)\r\n                )\r\n\r\n                // Update the offset for the data array in memory.\r\n                mstore(\r\n                    BatchTransfer1155Params_data_head_ptr,\r\n                    add(\r\n                        BatchTransfer1155Params_ids_length_offset,\r\n                        idsAndAmountsSize\r\n                    )\r\n                )\r\n\r\n                // Set the length of the data array in memory to zero.\r\n                mstore(\r\n                    add(\r\n                        BatchTransfer1155Params_data_length_basePtr,\r\n                        idsAndAmountsSize\r\n                    ),\r\n                    0\r\n                )\r\n\r\n                // Determine the total calldata size for the call to transfer.\r\n                let transferDataSize := add(\r\n                    BatchTransfer1155Params_calldata_baseSize,\r\n                    idsAndAmountsSize\r\n                )\r\n\r\n                // Copy second section of calldata (including dynamic values).\r\n                calldatacopy(\r\n                    BatchTransfer1155Params_ids_length_ptr,\r\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\r\n                    idsAndAmountsSize\r\n                )\r\n\r\n                // Perform the call to transfer 1155 tokens.\r\n                let success := call(\r\n                    gas(),\r\n                    token,\r\n                    0,\r\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\r\n                    transferDataSize, // Location of the length of callData.\r\n                    0,\r\n                    0\r\n                )\r\n\r\n                // If the transfer reverted:\r\n                if iszero(success) {\r\n                    // If it returned a message, bubble it up as long as\r\n                    // sufficient gas remains to do so:\r\n                    if returndatasize() {\r\n                        // Ensure that sufficient gas is available to copy\r\n                        // returndata while expanding memory where necessary.\r\n                        // Start by computing word size of returndata and\r\n                        // allocated memory. Round up to the nearest full word.\r\n                        let returnDataWords := shr(\r\n                            OneWordShift,\r\n                            add(returndatasize(), ThirtyOneBytes)\r\n                        )\r\n\r\n                        // Note: use transferDataSize in place of msize() to\r\n                        // work around a Yul warning that prevents accessing\r\n                        // msize directly when the IR pipeline is activated.\r\n                        // The free memory pointer is not used here because\r\n                        // this function does almost all memory management\r\n                        // manually and does not update it, and transferDataSize\r\n                        // should be the largest memory value used (unless a\r\n                        // previous batch was larger).\r\n                        let msizeWords := shr(OneWordShift, transferDataSize)\r\n\r\n                        // Next, compute the cost of the returndatacopy.\r\n                        let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                        // Then, compute cost of new memory allocation.\r\n                        if gt(returnDataWords, msizeWords) {\r\n                            cost := add(\r\n                                cost,\r\n                                add(\r\n                                    mul(\r\n                                        sub(returnDataWords, msizeWords),\r\n                                        CostPerWord\r\n                                    ),\r\n                                    shr(\r\n                                        MemoryExpansionCoefficientShift,\r\n                                        sub(\r\n                                            mul(\r\n                                                returnDataWords,\r\n                                                returnDataWords\r\n                                            ),\r\n                                            mul(msizeWords, msizeWords)\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        }\r\n\r\n                        // Finally, add a small constant and compare to gas\r\n                        // remaining; bubble up the revert data if enough gas is\r\n                        // still available.\r\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                            // Copy returndata to memory; overwrite existing.\r\n                            returndatacopy(0, 0, returndatasize())\r\n\r\n                            // Revert with memory region containing returndata.\r\n                            revert(0, returndatasize())\r\n                        }\r\n                    }\r\n\r\n                    // Set the error signature.\r\n                    mstore(\r\n                        0,\r\n                        ERC1155BatchTransferGenericFailure_error_signature\r\n                    )\r\n\r\n                    // Write the token.\r\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\r\n\r\n                    // Increase the offset to ids by 32.\r\n                    mstore(\r\n                        BatchTransfer1155Params_ids_head_ptr,\r\n                        ERC1155BatchTransferGenericFailure_ids_offset\r\n                    )\r\n\r\n                    // Increase the offset to amounts by 32.\r\n                    mstore(\r\n                        BatchTransfer1155Params_amounts_head_ptr,\r\n                        add(\r\n                            OneWord,\r\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\r\n                        )\r\n                    )\r\n\r\n                    // Return modified region. The total size stays the same as\r\n                    // `token` uses the same number of bytes as `data.length`.\r\n                    revert(0, transferDataSize)\r\n                }\r\n            }\r\n\r\n            // Reset the free memory pointer to the default value; memory must\r\n            // be assumed to be dirtied and not reused from this point forward.\r\n            // Also note that the zero slot is not reset to zero, meaning empty\r\n            // arrays cannot be safely created or utilized until it is restored.\r\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\r\n        }\r\n    }\r\n}\r\n\r\ncontract Executor is Verifiers, TokenTransferrer {\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) Verifiers(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal function to transfer a given item, either directly or via\r\n     *      a corresponding conduit.\r\n     *\r\n     * @param item        The item to transfer, including an amount and a\r\n     *                    recipient.\r\n     * @param from        The account supplying the item.\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _transfer(\r\n        ReceivedItem memory item,\r\n        address from,\r\n        bytes32 conduitKey,\r\n        bytes memory accumulator\r\n    ) internal {\r\n        // If the item type indicates Ether or a native token...\r\n        if (item.itemType == ItemType.NATIVE) {\r\n            // Ensure neither the token nor the identifier parameters are set.\r\n            if ((uint160(item.token) | item.identifier) != 0) {\r\n                _revertUnusedItemParameters();\r\n            }\r\n\r\n            // transfer the native tokens to the recipient.\r\n            _transferNativeTokens(item.recipient, item.amount);\r\n        } else if (item.itemType == ItemType.ERC20) {\r\n            // Ensure that no identifier is supplied.\r\n            if (item.identifier != 0) {\r\n                _revertUnusedItemParameters();\r\n            }\r\n\r\n            // Transfer ERC20 tokens from the source to the recipient.\r\n            _transferERC20(\r\n                item.token,\r\n                from,\r\n                item.recipient,\r\n                item.amount,\r\n                conduitKey,\r\n                accumulator\r\n            );\r\n        } else if (item.itemType == ItemType.ERC721) {\r\n            // Transfer ERC721 token from the source to the recipient.\r\n            _transferERC721(\r\n                item.token,\r\n                from,\r\n                item.recipient,\r\n                item.identifier,\r\n                item.amount,\r\n                conduitKey,\r\n                accumulator\r\n            );\r\n        } else {\r\n            // Transfer ERC1155 token from the source to the recipient.\r\n            _transferERC1155(\r\n                item.token,\r\n                from,\r\n                item.recipient,\r\n                item.identifier,\r\n                item.amount,\r\n                conduitKey,\r\n                accumulator\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer Ether or other native tokens to a\r\n     *      given recipient.\r\n     *\r\n     * @param to     The recipient of the transfer.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function _transferNativeTokens(\r\n        address payable to,\r\n        uint256 amount\r\n    ) internal {\r\n        // Ensure that the supplied amount is non-zero.\r\n        _assertNonZeroAmount(amount);\r\n\r\n        // Declare a variable indicating whether the call was successful or not.\r\n        bool success;\r\n\r\n        assembly {\r\n            // Transfer the native token and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        // If the call fails...\r\n        if (!success) {\r\n            // Revert and pass the revert reason along if one was returned.\r\n            _revertWithReasonIfOneIsReturned();\r\n\r\n            // Otherwise, revert with a generic error message.\r\n            assembly {\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, NativeTokenTransferGenericFailure_error_selector)\r\n\r\n                // Write `to` and `amount` arguments.\r\n                mstore(NativeTokenTransferGenericFailure_error_account_ptr, to)\r\n                mstore(\r\n                    NativeTokenTransferGenericFailure_error_amount_ptr,\r\n                    amount\r\n                )\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"NativeTokenTransferGenericFailure(address,uint256)\",\r\n                //     to,\r\n                //     amount\r\n                // ))\r\n                revert(\r\n                    Error_selector_offset,\r\n                    NativeTokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens from a given originator\r\n     *      to a given recipient using a given conduit if applicable. Sufficient\r\n     *      approvals must be set on this contract or on a respective conduit.\r\n     *\r\n     * @param token       The ERC20 token to transfer.\r\n     * @param from        The originator of the transfer.\r\n     * @param to          The recipient of the transfer.\r\n     * @param amount      The amount to transfer.\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _transferERC20(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes32 conduitKey,\r\n        bytes memory accumulator\r\n    ) internal {\r\n        // Ensure that the supplied amount is non-zero.\r\n        _assertNonZeroAmount(amount);\r\n\r\n        // Trigger accumulated transfers if the conduits differ.\r\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\r\n\r\n        // If no conduit has been specified...\r\n        if (conduitKey == bytes32(0)) {\r\n            // Perform the token transfer directly.\r\n            _performERC20Transfer(token, from, to, amount);\r\n        } else {\r\n            // Insert the call to the conduit into the accumulator.\r\n            _insert(\r\n                conduitKey,\r\n                accumulator,\r\n                ConduitItemType.ERC20,\r\n                token,\r\n                from,\r\n                to,\r\n                uint256(0),\r\n                amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer a single ERC721 token from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set,\r\n     *      either on the respective conduit or on this contract itself.\r\n     *\r\n     * @param token       The ERC721 token to transfer.\r\n     * @param from        The originator of the transfer.\r\n     * @param to          The recipient of the transfer.\r\n     * @param identifier  The tokenId to transfer (must be 1 for ERC721).\r\n     * @param amount      The amount to transfer.\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _transferERC721(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount,\r\n        bytes32 conduitKey,\r\n        bytes memory accumulator\r\n    ) internal {\r\n        // Trigger accumulated transfers if the conduits differ.\r\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\r\n\r\n        // If no conduit has been specified...\r\n        if (conduitKey == bytes32(0)) {\r\n            // Ensure that exactly one 721 item is being transferred.\r\n            if (amount != 1) {\r\n                _revertInvalidERC721TransferAmount(amount);\r\n            }\r\n\r\n            // Perform transfer via the token contract directly.\r\n            _performERC721Transfer(token, from, to, identifier);\r\n        } else {\r\n            // Insert the call to the conduit into the accumulator.\r\n            _insert(\r\n                conduitKey,\r\n                accumulator,\r\n                ConduitItemType.ERC721,\r\n                token,\r\n                from,\r\n                to,\r\n                identifier,\r\n                amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\r\n     *      to a given recipient. Sufficient approvals must be set, either on\r\n     *      the respective conduit or on this contract itself.\r\n     *\r\n     * @param token       The ERC1155 token to transfer.\r\n     * @param from        The originator of the transfer.\r\n     * @param to          The recipient of the transfer.\r\n     * @param identifier  The id to transfer.\r\n     * @param amount      The amount to transfer.\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _transferERC1155(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount,\r\n        bytes32 conduitKey,\r\n        bytes memory accumulator\r\n    ) internal {\r\n        // Ensure that the supplied amount is non-zero.\r\n        _assertNonZeroAmount(amount);\r\n\r\n        // Trigger accumulated transfers if the conduits differ.\r\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\r\n\r\n        // If no conduit has been specified...\r\n        if (conduitKey == bytes32(0)) {\r\n            // Perform transfer via the token contract directly.\r\n            _performERC1155Transfer(token, from, to, identifier, amount);\r\n        } else {\r\n            // Insert the call to the conduit into the accumulator.\r\n            _insert(\r\n                conduitKey,\r\n                accumulator,\r\n                ConduitItemType.ERC1155,\r\n                token,\r\n                from,\r\n                to,\r\n                identifier,\r\n                amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to trigger a call to the conduit currently held by\r\n     *      the accumulator if the accumulator contains item transfers (i.e. it\r\n     *      is \"armed\") and the supplied conduit key does not match the key held\r\n     *      by the accumulator.\r\n     *\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     */\r\n    function _triggerIfArmedAndNotAccumulatable(\r\n        bytes memory accumulator,\r\n        bytes32 conduitKey\r\n    ) internal {\r\n        // Retrieve the current conduit key from the accumulator.\r\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\r\n\r\n        // Perform conduit call if the set key does not match the supplied key.\r\n        if (accumulatorConduitKey != conduitKey) {\r\n            _triggerIfArmed(accumulator);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to trigger a call to the conduit currently held by\r\n     *      the accumulator if the accumulator contains item transfers (i.e. it\r\n     *      is \"armed\").\r\n     *\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _triggerIfArmed(bytes memory accumulator) internal {\r\n        // Exit if the accumulator is not \"armed\".\r\n        if (accumulator.length != AccumulatorArmed) {\r\n            return;\r\n        }\r\n\r\n        // Retrieve the current conduit key from the accumulator.\r\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\r\n\r\n        // Perform conduit call.\r\n        _trigger(accumulatorConduitKey, accumulator);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to trigger a call to the conduit corresponding to\r\n     *      a given conduit key, supplying all accumulated item transfers. The\r\n     *      accumulator will be \"disarmed\" and reset in the process.\r\n     *\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\r\n        // Declare variables for offset in memory & size of calldata to conduit.\r\n        uint256 callDataOffset;\r\n        uint256 callDataSize;\r\n\r\n        // Call the conduit with all the accumulated transfers.\r\n        assembly {\r\n            // Call begins at third word; the first is length or \"armed\" status,\r\n            // and the second is the current conduit key.\r\n            callDataOffset := add(accumulator, TwoWords)\r\n\r\n            // 68 + items * 192\r\n            callDataSize := add(\r\n                Accumulator_array_offset_ptr,\r\n                mul(\r\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\r\n                    Conduit_transferItem_size\r\n                )\r\n            )\r\n        }\r\n\r\n        // Call conduit derived from conduit key & supply accumulated transfers.\r\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\r\n\r\n        // Reset accumulator length to signal that it is now \"disarmed\".\r\n        assembly {\r\n            mstore(accumulator, AccumulatorDisarmed)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to perform a call to the conduit corresponding to\r\n     *      a given conduit key based on the offset and size of the calldata in\r\n     *      question in memory.\r\n     *\r\n     * @param conduitKey     A bytes32 value indicating what corresponding\r\n     *                       conduit, if any, to source token approvals from.\r\n     *                       The zero hash signifies that no conduit should be\r\n     *                       used, with direct approvals set on this contract.\r\n     * @param callDataOffset The memory pointer where calldata is contained.\r\n     * @param callDataSize   The size of calldata in memory.\r\n     */\r\n    function _callConduitUsingOffsets(\r\n        bytes32 conduitKey,\r\n        uint256 callDataOffset,\r\n        uint256 callDataSize\r\n    ) internal {\r\n        // Derive the address of the conduit using the conduit key.\r\n        address conduit = _deriveConduit(conduitKey);\r\n\r\n        bool success;\r\n        bytes4 result;\r\n\r\n        // call the conduit.\r\n        assembly {\r\n            // Ensure first word of scratch space is empty.\r\n            mstore(0, 0)\r\n\r\n            // Perform call, placing first word of return data in scratch space.\r\n            success := call(\r\n                gas(),\r\n                conduit,\r\n                0,\r\n                callDataOffset,\r\n                callDataSize,\r\n                0,\r\n                OneWord\r\n            )\r\n\r\n            // Take value from scratch space and place it on the stack.\r\n            result := mload(0)\r\n        }\r\n\r\n        // If the call failed...\r\n        if (!success) {\r\n            // Pass along whatever revert reason was given by the conduit.\r\n            _revertWithReasonIfOneIsReturned();\r\n\r\n            // Otherwise, revert with a generic error.\r\n            _revertInvalidCallToConduit(conduit);\r\n        }\r\n\r\n        // Ensure result was extracted and matches EIP-1271 magic value.\r\n        if (result != ConduitInterface.execute.selector) {\r\n            _revertInvalidConduit(conduitKey, conduit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to retrieve the current conduit key set for\r\n     *      the accumulator.\r\n     *\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     *\r\n     * @return accumulatorConduitKey The conduit key currently set for the\r\n     *                               accumulator.\r\n     */\r\n    function _getAccumulatorConduitKey(\r\n        bytes memory accumulator\r\n    ) internal pure returns (bytes32 accumulatorConduitKey) {\r\n        // Retrieve the current conduit key from the accumulator.\r\n        assembly {\r\n            accumulatorConduitKey := mload(\r\n                add(accumulator, Accumulator_conduitKey_ptr)\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to place an item transfer into an accumulator\r\n     *      that collects a series of transfers to execute against a given\r\n     *      conduit in a single call.\r\n     *\r\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\r\n     *                    if any, to source token approvals from. The zero hash\r\n     *                    signifies that no conduit should be used, with direct\r\n     *                    approvals set on this contract.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     * @param itemType    The type of the item to transfer.\r\n     * @param token       The token to transfer.\r\n     * @param from        The originator of the transfer.\r\n     * @param to          The recipient of the transfer.\r\n     * @param identifier  The tokenId to transfer.\r\n     * @param amount      The amount to transfer.\r\n     */\r\n    function _insert(\r\n        bytes32 conduitKey,\r\n        bytes memory accumulator,\r\n        ConduitItemType itemType,\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    ) internal pure {\r\n        uint256 elements;\r\n        // \"Arm\" and prime accumulator if it's not already armed. The sentinel\r\n        // value is held in the length of the accumulator array.\r\n        if (accumulator.length == AccumulatorDisarmed) {\r\n            elements = 1;\r\n            bytes4 selector = ConduitInterface.execute.selector;\r\n            assembly {\r\n                mstore(accumulator, AccumulatorArmed) // \"arm\" the accumulator.\r\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\r\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\r\n                mstore(\r\n                    add(accumulator, Accumulator_array_offset_ptr),\r\n                    Accumulator_array_offset\r\n                )\r\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\r\n            }\r\n        } else {\r\n            // Otherwise, increase the number of elements by one.\r\n            assembly {\r\n                elements := add(\r\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\r\n                    1\r\n                )\r\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\r\n            }\r\n        }\r\n\r\n        // Insert the item.\r\n        assembly {\r\n            let itemPointer := sub(\r\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\r\n                Accumulator_itemSizeOffsetDifference\r\n            )\r\n            mstore(itemPointer, itemType)\r\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\r\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\r\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\r\n            mstore(\r\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\r\n                identifier\r\n            )\r\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\r\n        }\r\n    }\r\n}\r\n\r\ninterface ZoneInteractionErrors {\r\n    /**\r\n     * @dev Revert with an error when attempting to fill an order that specifies\r\n     *      a restricted submitter as its order type when not submitted by\r\n     *      either the offerer or the order's zone or approved as valid by the\r\n     *      zone in question via a call to `isValidOrder`.\r\n     *\r\n     * @param orderHash The order hash for the invalid restricted order.\r\n     */\r\n    error InvalidRestrictedOrder(bytes32 orderHash);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fill a contract order that\r\n     *      fails to generate an order successfully, that does not adhere to the\r\n     *      requirements for minimum spent or maximum received supplied by the\r\n     *      fulfiller, or that fails the post-execution `ratifyOrder` check..\r\n     *\r\n     * @param orderHash The order hash for the invalid contract order.\r\n     */\r\n    error InvalidContractOrder(bytes32 orderHash);\r\n}\r\ninterface ZoneInterface {\r\n    /**\r\n     * @dev Validates an order.\r\n     *\r\n     * @param zoneParameters The context about the order fulfillment and any\r\n     *                       supplied extraData.\r\n     *\r\n     * @return validOrderMagicValue The magic value that indicates a valid\r\n     *                              order.\r\n     */\r\n    function validateOrder(\r\n        ZoneParameters calldata zoneParameters\r\n    ) external returns (bytes4 validOrderMagicValue);\r\n\r\n    /**\r\n     * @dev Returns the metadata for this zone.\r\n     *\r\n     * @return name The name of the zone.\r\n     * @return schemas The schemas that the zone implements.\r\n     */\r\n    function getSeaportMetadata()\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            Schema[] memory schemas // map to Seaport Improvement Proposal IDs\r\n        );\r\n}\r\n\r\ncontract ZoneInteraction is\r\n    ConsiderationEncoder,\r\n    ZoneInteractionErrors,\r\n    LowLevelHelpers\r\n{\r\n    /**\r\n     * @dev Internal function to determine if an order has a restricted order\r\n     *      type and, if so, to ensure that either the zone is the caller or\r\n     *      that a call to `validateOrder` on the zone returns a magic value\r\n     *      indicating that the order is currently valid. Note that contract\r\n     *      orders are not accessible via the basic fulfillment method.\r\n     *\r\n     * @param orderHash  The hash of the order.\r\n     * @param orderType  The order type.\r\n     * @param parameters The parameters of the basic order.\r\n     */\r\n    function _assertRestrictedBasicOrderValidity(\r\n        bytes32 orderHash,\r\n        OrderType orderType,\r\n        BasicOrderParameters calldata parameters\r\n    ) internal {\r\n        // Order type 2-3 require zone be caller or zone to approve.\r\n        // Note that in cases where fulfiller == zone, the restricted order\r\n        // validation will be skipped.\r\n        if (_isRestrictedAndCallerNotZone(orderType, parameters.zone)) {\r\n            // Encode the `validateOrder` call in memory.\r\n            (MemoryPointer callData, uint256 size) = _encodeValidateBasicOrder(\r\n                orderHash,\r\n                parameters\r\n            );\r\n\r\n            // Perform `validateOrder` call and ensure magic value was returned.\r\n            _callAndCheckStatus(\r\n                parameters.zone,\r\n                orderHash,\r\n                callData,\r\n                size,\r\n                InvalidRestrictedOrder_error_selector\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to determine the post-execution validity of\r\n     *      restricted and contract orders. Restricted orders where the caller\r\n     *      is not the zone must successfully call `validateOrder` with the\r\n     *      correct magic value returned. Contract orders must successfully call\r\n     *      `ratifyOrder` with the correct magic value returned.\r\n     *\r\n     * @param advancedOrder The advanced order in question.\r\n     * @param orderHashes   The order hashes of each order included as part of\r\n     *                      the current fulfillment.\r\n     * @param orderHash     The hash of the order.\r\n     */\r\n    function _assertRestrictedAdvancedOrderValidity(\r\n        AdvancedOrder memory advancedOrder,\r\n        bytes32[] memory orderHashes,\r\n        bytes32 orderHash\r\n    ) internal {\r\n        // Declare variables that will be assigned based on the order type.\r\n        address target;\r\n        uint256 errorSelector;\r\n        MemoryPointer callData;\r\n        uint256 size;\r\n\r\n        // Retrieve the parameters of the order in question.\r\n        OrderParameters memory parameters = advancedOrder.parameters;\r\n\r\n        // OrderType 2-3 require zone to be caller or approve via validateOrder.\r\n        if (\r\n            _isRestrictedAndCallerNotZone(parameters.orderType, parameters.zone)\r\n        ) {\r\n            // Encode the `validateOrder` call in memory.\r\n            (callData, size) = _encodeValidateOrder(\r\n                orderHash,\r\n                parameters,\r\n                advancedOrder.extraData,\r\n                orderHashes\r\n            );\r\n\r\n            // Set the target to the zone.\r\n            target = (\r\n                parameters\r\n                    .toMemoryPointer()\r\n                    .offset(OrderParameters_zone_offset)\r\n                    .readAddress()\r\n            );\r\n\r\n            // Set the restricted-order-specific error selector.\r\n            errorSelector = InvalidRestrictedOrder_error_selector;\r\n        } else if (parameters.orderType == OrderType.CONTRACT) {\r\n            // Set the target to the offerer (note the offerer has no offset).\r\n            target = parameters.toMemoryPointer().readAddress();\r\n\r\n            // Shift the target 96 bits to the left.\r\n            uint256 shiftedOfferer;\r\n            assembly {\r\n                shiftedOfferer := shl(\r\n                    ContractOrder_orderHash_offerer_shift,\r\n                    target\r\n                )\r\n            }\r\n\r\n            // Encode the `ratifyOrder` call in memory.\r\n            (callData, size) = _encodeRatifyOrder(\r\n                orderHash,\r\n                parameters,\r\n                advancedOrder.extraData,\r\n                orderHashes,\r\n                shiftedOfferer\r\n            );\r\n\r\n            // Set the contract-order-specific error selector.\r\n            errorSelector = InvalidContractOrder_error_selector;\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        // Perform call and ensure a corresponding magic value was returned.\r\n        _callAndCheckStatus(target, orderHash, callData, size, errorSelector);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines whether the specified order type is restricted and the\r\n     *      caller is not the specified zone.\r\n     *\r\n     * @param orderType     The type of the order to check.\r\n     * @param zone          The address of the zone to check against.\r\n     *\r\n     * @return mustValidate True if the order type is restricted and the caller\r\n     *                      is not the specified zone, false otherwise.\r\n     */\r\n    function _isRestrictedAndCallerNotZone(\r\n        OrderType orderType,\r\n        address zone\r\n    ) internal view returns (bool mustValidate) {\r\n        assembly {\r\n            mustValidate := and(\r\n                // Note that this check requires that there are no order types\r\n                // beyond the current set (0-4).  It will need to be modified if\r\n                // more order types are added.\r\n                and(lt(orderType, 4), gt(orderType, 1)),\r\n                iszero(eq(caller(), zone))\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calls the specified target with the given data and checks the status\r\n     *      of the call. Revert reasons will be \"bubbled up\" if one is returned,\r\n     *      otherwise reverting calls will throw a generic error based on the\r\n     *      supplied error handler.\r\n     *\r\n     * @param target        The address of the contract to call.\r\n     * @param orderHash     The hash of the order associated with the call.\r\n     * @param callData      The data to pass to the contract call.\r\n     * @param size          The size of calldata.\r\n     * @param errorSelector The error handling function to call if the call\r\n     *                      fails or the magic value does not match.\r\n     */\r\n    function _callAndCheckStatus(\r\n        address target,\r\n        bytes32 orderHash,\r\n        MemoryPointer callData,\r\n        uint256 size,\r\n        uint256 errorSelector\r\n    ) internal {\r\n        bool success;\r\n        bool magicMatch;\r\n        assembly {\r\n            // Get magic value from the selector at start of provided calldata.\r\n            let magic := and(mload(callData), MaskOverFirstFourBytes)\r\n\r\n            // Clear the start of scratch space.\r\n            mstore(0, 0)\r\n\r\n            // Perform call, placing result in the first word of scratch space.\r\n            success := call(gas(), target, 0, callData, size, 0, OneWord)\r\n\r\n            // Determine if returned magic value matches the calldata selector.\r\n            magicMatch := eq(magic, mload(0))\r\n        }\r\n\r\n        // Revert if the call was not successful.\r\n        if (!success) {\r\n            // Revert and pass reason along if one was returned.\r\n            _revertWithReasonIfOneIsReturned();\r\n\r\n            // If no reason was returned, revert with supplied error selector.\r\n            assembly {\r\n                mstore(0, errorSelector)\r\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\r\n                // revert(abi.encodeWithSelector(\r\n                //     \"InvalidRestrictedOrder(bytes32)\",\r\n                //     orderHash\r\n                // ))\r\n                revert(\r\n                    Error_selector_offset,\r\n                    InvalidRestrictedOrder_error_length\r\n                )\r\n            }\r\n        }\r\n\r\n        // Revert if the correct magic value was not returned.\r\n        if (!magicMatch) {\r\n            // Revert with a generic error message.\r\n            assembly {\r\n                mstore(0, errorSelector)\r\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\r\n\r\n                // revert(abi.encodeWithSelector(\r\n                //     \"InvalidRestrictedOrder(bytes32)\",\r\n                //     orderHash\r\n                // ))\r\n                revert(\r\n                    Error_selector_offset,\r\n                    InvalidRestrictedOrder_error_length\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract OrderValidator is Executor, ZoneInteraction {\r\n    // Track status of each order (validated, cancelled, and fraction filled).\r\n    mapping(bytes32 => OrderStatus) private _orderStatus;\r\n\r\n    // Track nonces for contract offerers.\r\n    mapping(address => uint256) internal _contractNonces;\r\n\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) Executor(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal function to verify and update the status of a basic order.\r\n     *      Note that this function may only be safely called as part of basic\r\n     *      orders, as it assumes a specific calldata encoding structure that\r\n     *      must first be validated.\r\n     *\r\n     * @param orderHash The hash of the order.\r\n     * @param signature A signature from the offerer indicating that the order\r\n     *                  has been approved.\r\n     */\r\n    function _validateBasicOrderAndUpdateStatus(\r\n        bytes32 orderHash,\r\n        bytes calldata signature\r\n    ) internal {\r\n        // Retrieve offerer directly using fixed calldata offset based on strict\r\n        // basic parameter encoding.\r\n        address offerer;\r\n        assembly {\r\n            offerer := calldataload(BasicOrder_offerer_cdPtr)\r\n        }\r\n\r\n        // Retrieve the order status for the given order hash.\r\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\r\n\r\n        // Ensure order is fillable and is not cancelled.\r\n        _verifyOrderStatus(\r\n            orderHash,\r\n            orderStatus,\r\n            true, // Only allow unused orders when fulfilling basic orders.\r\n            true // Signifies to revert if the order is invalid.\r\n        );\r\n\r\n        // If the order is not already validated, verify the supplied signature.\r\n        if (!orderStatus.isValidated) {\r\n            _verifySignature(offerer, orderHash, signature);\r\n        }\r\n\r\n        // Update order status as fully filled, packing struct values.\r\n        orderStatus.isValidated = true;\r\n        orderStatus.isCancelled = false;\r\n        orderStatus.numerator = 1;\r\n        orderStatus.denominator = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to validate an order, determine what portion to\r\n     *      fill, and update its status. The desired fill amount is supplied as\r\n     *      a fraction, as is the returned amount to fill.\r\n     *\r\n     * @param advancedOrder     The order to fulfill as well as the fraction to\r\n     *                          fill. Note that all offer and consideration\r\n     *                          amounts must divide with no remainder in order\r\n     *                          for a partial fill to be valid.\r\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\r\n     *                          order is invalid due to the time or status.\r\n     *\r\n     * @return orderHash      The order hash.\r\n     * @return numerator      A value indicating the portion of the order that\r\n     *                        will be filled.\r\n     * @return denominator    A value indicating the total size of the order.\r\n     */\r\n    function _validateOrderAndUpdateStatus(\r\n        AdvancedOrder memory advancedOrder,\r\n        bool revertOnInvalid\r\n    )\r\n        internal\r\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\r\n    {\r\n        // Retrieve the parameters for the order.\r\n        OrderParameters memory orderParameters = advancedOrder.parameters;\r\n\r\n        // Ensure current timestamp falls between order start time and end time.\r\n        if (\r\n            !_verifyTime(\r\n                orderParameters.startTime,\r\n                orderParameters.endTime,\r\n                revertOnInvalid\r\n            )\r\n        ) {\r\n            // Assuming an invalid time and no revert, return zeroed out values.\r\n            return (bytes32(0), 0, 0);\r\n        }\r\n\r\n        // Read numerator and denominator from memory and place on the stack.\r\n        // Note that overflowed values are masked.\r\n        assembly {\r\n            numerator := and(\r\n                mload(add(advancedOrder, AdvancedOrder_numerator_offset)),\r\n                MaxUint120\r\n            )\r\n\r\n            denominator := and(\r\n                mload(add(advancedOrder, AdvancedOrder_denominator_offset)),\r\n                MaxUint120\r\n            )\r\n        }\r\n\r\n        // Declare variable for tracking the validity of the supplied fraction.\r\n        bool invalidFraction;\r\n\r\n        // If the order is a contract order, return the generated order.\r\n        if (orderParameters.orderType == OrderType.CONTRACT) {\r\n            // Ensure that the numerator and denominator are both equal to 1.\r\n            assembly {\r\n                // (1 ^ nd =/= 0) => (nd =/= 1) => (n =/= 1) || (d =/= 1)\r\n                // It's important that the values are 120-bit masked before\r\n                // multiplication is applied. Otherwise, the last implication\r\n                // above is not correct (mod 2^256).\r\n                invalidFraction := xor(mul(numerator, denominator), 1)\r\n            }\r\n\r\n            // Revert if the supplied numerator and denominator are not valid.\r\n            if (invalidFraction) {\r\n                _revertBadFraction();\r\n            }\r\n\r\n            // Return the generated order based on the order params and the\r\n            // provided extra data. If revertOnInvalid is true, the function\r\n            // will revert if the input is invalid.\r\n            return\r\n                _getGeneratedOrder(\r\n                    orderParameters,\r\n                    advancedOrder.extraData,\r\n                    revertOnInvalid\r\n                );\r\n        }\r\n\r\n        // Ensure numerator does not exceed denominator and is not zero.\r\n        assembly {\r\n            invalidFraction := or(gt(numerator, denominator), iszero(numerator))\r\n        }\r\n\r\n        // Revert if the supplied numerator and denominator are not valid.\r\n        if (invalidFraction) {\r\n            _revertBadFraction();\r\n        }\r\n\r\n        // If attempting partial fill (n < d) check order type & ensure support.\r\n        if (\r\n            _doesNotSupportPartialFills(\r\n                orderParameters.orderType,\r\n                numerator,\r\n                denominator\r\n            )\r\n        ) {\r\n            // Revert if partial fill was attempted on an unsupported order.\r\n            _revertPartialFillsNotEnabledForOrder();\r\n        }\r\n\r\n        // Retrieve current counter & use it w/ parameters to derive order hash.\r\n        orderHash = _assertConsiderationLengthAndGetOrderHash(orderParameters);\r\n\r\n        // Retrieve the order status using the derived order hash.\r\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\r\n\r\n        // Ensure order is fillable and is not cancelled.\r\n        if (\r\n            !_verifyOrderStatus(\r\n                orderHash,\r\n                orderStatus,\r\n                false, // Allow partially used orders to be filled.\r\n                revertOnInvalid\r\n            )\r\n        ) {\r\n            // Assuming an invalid order status and no revert, return zero fill.\r\n            return (orderHash, 0, 0);\r\n        }\r\n\r\n        // If the order is not already validated, verify the supplied signature.\r\n        if (!orderStatus.isValidated) {\r\n            _verifySignature(\r\n                orderParameters.offerer,\r\n                orderHash,\r\n                advancedOrder.signature\r\n            );\r\n        }\r\n\r\n        assembly {\r\n            let orderStatusSlot := orderStatus.slot\r\n            // Read filled amount as numerator and denominator and put on stack.\r\n            let filledNumerator := sload(orderStatusSlot)\r\n            let filledDenominator := shr(\r\n                OrderStatus_filledDenominator_offset,\r\n                filledNumerator\r\n            )\r\n\r\n            for {\r\n\r\n            } 1 {\r\n\r\n            } {\r\n                if iszero(filledDenominator) {\r\n                    filledNumerator := numerator\r\n\r\n                    break\r\n                }\r\n\r\n                // Shift and mask to calculate the current filled numerator.\r\n                filledNumerator := and(\r\n                    shr(OrderStatus_filledNumerator_offset, filledNumerator),\r\n                    MaxUint120\r\n                )\r\n\r\n                // If denominator of 1 supplied, fill entire remaining amount.\r\n                if eq(denominator, 1) {\r\n                    numerator := sub(filledDenominator, filledNumerator)\r\n                    denominator := filledDenominator\r\n                    filledNumerator := filledDenominator\r\n\r\n                    break\r\n                }\r\n\r\n                // If supplied denominator equals to the current one:\r\n                if eq(denominator, filledDenominator) {\r\n                    // Increment the filled numerator by the new numerator.\r\n                    filledNumerator := add(numerator, filledNumerator)\r\n\r\n                    // Once adjusted, if current + supplied numerator exceeds\r\n                    // the denominator:\r\n                    let carry := mul(\r\n                        sub(filledNumerator, denominator),\r\n                        gt(filledNumerator, denominator)\r\n                    )\r\n\r\n                    numerator := sub(numerator, carry)\r\n\r\n                    filledNumerator := sub(filledNumerator, carry)\r\n\r\n                    break\r\n                }\r\n\r\n                // Otherwise, if supplied denominator differs from current one:\r\n                filledNumerator := mul(filledNumerator, denominator)\r\n                numerator := mul(numerator, filledDenominator)\r\n                denominator := mul(denominator, filledDenominator)\r\n\r\n                // Increment the filled numerator by the new numerator.\r\n                filledNumerator := add(numerator, filledNumerator)\r\n\r\n                // Once adjusted, if current + supplied numerator exceeds\r\n                // denominator:\r\n                let carry := mul(\r\n                    sub(filledNumerator, denominator),\r\n                    gt(filledNumerator, denominator)\r\n                )\r\n\r\n                numerator := sub(numerator, carry)\r\n\r\n                filledNumerator := sub(filledNumerator, carry)\r\n\r\n                // Check filledNumerator and denominator for uint120 overflow.\r\n                if or(\r\n                    gt(filledNumerator, MaxUint120),\r\n                    gt(denominator, MaxUint120)\r\n                ) {\r\n                    // Derive greatest common divisor using euclidean algorithm.\r\n                    function gcd(_a, _b) -> out {\r\n                        for {\r\n\r\n                        } _b {\r\n\r\n                        } {\r\n                            let _c := _b\r\n                            _b := mod(_a, _c)\r\n                            _a := _c\r\n                        }\r\n                        out := _a\r\n                    }\r\n                    let scaleDown := gcd(\r\n                        numerator,\r\n                        gcd(filledNumerator, denominator)\r\n                    )\r\n\r\n                    // Ensure that the divisor is at least one.\r\n                    let safeScaleDown := add(scaleDown, iszero(scaleDown))\r\n\r\n                    // Scale all fractional values down by gcd.\r\n                    numerator := div(numerator, safeScaleDown)\r\n                    filledNumerator := div(filledNumerator, safeScaleDown)\r\n                    denominator := div(denominator, safeScaleDown)\r\n\r\n                    // Perform the overflow check a second time.\r\n                    if or(\r\n                        gt(filledNumerator, MaxUint120),\r\n                        gt(denominator, MaxUint120)\r\n                    ) {\r\n                        // Store the Panic error signature.\r\n                        mstore(0, Panic_error_selector)\r\n                        // Store the arithmetic (0x11) panic code.\r\n                        mstore(Panic_error_code_ptr, Panic_arithmetic)\r\n\r\n                        // revert(abi.encodeWithSignature(\r\n                        //     \"Panic(uint256)\", 0x11\r\n                        // ))\r\n                        revert(Error_selector_offset, Panic_error_length)\r\n                    }\r\n                }\r\n\r\n                break\r\n            }\r\n\r\n            // Update order status and fill amount, packing struct values.\r\n            // [denominator: 15 bytes] [numerator: 15 bytes]\r\n            // [isCancelled: 1 byte] [isValidated: 1 byte]\r\n            sstore(\r\n                orderStatusSlot,\r\n                or(\r\n                    OrderStatus_ValidatedAndNotCancelled,\r\n                    or(\r\n                        shl(\r\n                            OrderStatus_filledNumerator_offset,\r\n                            filledNumerator\r\n                        ),\r\n                        shl(OrderStatus_filledDenominator_offset, denominator)\r\n                    )\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to check the compatibility of two offer\r\n     *      or consideration items for contract orders.  Note that the itemType\r\n     *      and identifier are reset in cases where criteria = 0 (collection-\r\n     *      wide offers), which means that a contract offerer has full latitude\r\n     *      to choose any identifier it wants mid-flight, in contrast to the\r\n     *      normal behavior, where the fulfiller can pick which identifier to\r\n     *      receive by providing a CriteriaResolver.\r\n     *\r\n     * @param originalItem The original offer or consideration item.\r\n     * @param newItem      The new offer or consideration item.\r\n     *\r\n     * @return isInvalid Error buffer indicating if items are incompatible.\r\n     */\r\n    function _compareItems(\r\n        MemoryPointer originalItem,\r\n        MemoryPointer newItem\r\n    ) internal pure returns (uint256 isInvalid) {\r\n        assembly {\r\n            let itemType := mload(originalItem)\r\n            let identifier := mload(add(originalItem, Common_identifier_offset))\r\n\r\n            // Set returned identifier for criteria-based items w/ criteria = 0.\r\n            if and(gt(itemType, 3), iszero(identifier)) {\r\n                // replace item type\r\n                itemType := sub(3, eq(itemType, 4))\r\n                identifier := mload(add(newItem, Common_identifier_offset))\r\n            }\r\n\r\n            let originalAmount := mload(add(originalItem, Common_amount_offset))\r\n            let newAmount := mload(add(newItem, Common_amount_offset))\r\n\r\n            isInvalid := iszero(\r\n                and(\r\n                    // originalItem.token == newItem.token &&\r\n                    // originalItem.itemType == newItem.itemType\r\n                    and(\r\n                        eq(\r\n                            mload(add(originalItem, Common_token_offset)),\r\n                            mload(add(newItem, Common_token_offset))\r\n                        ),\r\n                        eq(itemType, mload(newItem))\r\n                    ),\r\n                    // originalItem.identifier == newItem.identifier &&\r\n                    // originalItem.startAmount == originalItem.endAmount\r\n                    and(\r\n                        eq(\r\n                            identifier,\r\n                            mload(add(newItem, Common_identifier_offset))\r\n                        ),\r\n                        eq(\r\n                            originalAmount,\r\n                            mload(add(originalItem, Common_endAmount_offset))\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to check the compatibility of two recipients\r\n     *      on consideration items for contract orders. This check is skipped if\r\n     *      no recipient is originally supplied.\r\n     *\r\n     * @param originalRecipient The original consideration item recipient.\r\n     * @param newRecipient      The new consideration item recipient.\r\n     *\r\n     * @return isInvalid Error buffer indicating if recipients are incompatible.\r\n     */\r\n    function _checkRecipients(\r\n        address originalRecipient,\r\n        address newRecipient\r\n    ) internal pure returns (uint256 isInvalid) {\r\n        assembly {\r\n            isInvalid := iszero(\r\n                or(\r\n                    iszero(originalRecipient),\r\n                    eq(newRecipient, originalRecipient)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to generate a contract order. When a\r\n     *      collection-wide criteria-based item (criteria = 0) is provided as an\r\n     *      input to a contract order, the contract offerer has full latitude to\r\n     *      choose any identifier it wants mid-flight, which differs from the\r\n     *      usual behavior.  For regular criteria-based orders with\r\n     *      identifierOrCriteria = 0, the fulfiller can pick which identifier to\r\n     *      receive by providing a CriteriaResolver. For contract offers with\r\n     *      identifierOrCriteria = 0, Seaport does not expect a corresponding\r\n     *      CriteriaResolver, and will revert if one is provided.\r\n     *\r\n     * @param orderParameters The parameters for the order.\r\n     * @param context         The context for generating the order.\r\n     * @param revertOnInvalid Whether to revert on invalid input.\r\n     *\r\n     * @return orderHash   The order hash.\r\n     * @return numerator   The numerator.\r\n     * @return denominator The denominator.\r\n     */\r\n    function _getGeneratedOrder(\r\n        OrderParameters memory orderParameters,\r\n        bytes memory context,\r\n        bool revertOnInvalid\r\n    )\r\n        internal\r\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\r\n    {\r\n        // Ensure that consideration array length is equal to the total original\r\n        // consideration items value.\r\n        if (\r\n            orderParameters.consideration.length !=\r\n            orderParameters.totalOriginalConsiderationItems\r\n        ) {\r\n            _revertConsiderationLengthNotEqualToTotalOriginal();\r\n        }\r\n\r\n        {\r\n            address offerer = orderParameters.offerer;\r\n            bool success;\r\n            (MemoryPointer cdPtr, uint256 size) = _encodeGenerateOrder(\r\n                orderParameters,\r\n                context\r\n            );\r\n            assembly {\r\n                success := call(gas(), offerer, 0, cdPtr, size, 0, 0)\r\n            }\r\n\r\n            {\r\n                // Note: overflow impossible; nonce can't increment that high.\r\n                uint256 contractNonce;\r\n                unchecked {\r\n                    // Note: nonce will be incremented even for skipped orders,\r\n                    // and  even if generateOrder's return data does not satisfy\r\n                    // all the constraints. This is the case when errorBuffer\r\n                    // != 0 and revertOnInvalid == false.\r\n                    contractNonce = _contractNonces[offerer]++;\r\n                }\r\n\r\n                assembly {\r\n                    // Shift offerer address up 96 bytes and combine with nonce.\r\n                    orderHash := xor(\r\n                        contractNonce,\r\n                        shl(ContractOrder_orderHash_offerer_shift, offerer)\r\n                    )\r\n                }\r\n            }\r\n\r\n            // Revert or skip if the call to generate the contract order failed.\r\n            if (!success) {\r\n                return _revertOrReturnEmpty(revertOnInvalid, orderHash);\r\n            }\r\n        }\r\n\r\n        // From this point onward, do not allow for skipping orders as the\r\n        // contract offerer may have modified state in expectation of any named\r\n        // consideration items being sent to their designated recipients.\r\n\r\n        // Decode the returned contract order and/or update the error buffer.\r\n        (\r\n            uint256 errorBuffer,\r\n            OfferItem[] memory offer,\r\n            ConsiderationItem[] memory consideration\r\n        ) = _convertGetGeneratedOrderResult(_decodeGenerateOrderReturndata)();\r\n\r\n        // Revert if the returndata could not be decoded correctly.\r\n        if (errorBuffer != 0) {\r\n            _revertInvalidContractOrder(orderHash);\r\n        }\r\n\r\n        {\r\n            // Designate lengths.\r\n            uint256 originalOfferLength = orderParameters.offer.length;\r\n            uint256 newOfferLength = offer.length;\r\n\r\n            // Explicitly specified offer items cannot be removed.\r\n            if (originalOfferLength > newOfferLength) {\r\n                _revertInvalidContractOrder(orderHash);\r\n            }\r\n\r\n            // Iterate over each specified offer (e.g. minimumReceived) item.\r\n            for (uint256 i = 0; i < originalOfferLength; ) {\r\n                // Retrieve the pointer to the originally supplied item.\r\n                MemoryPointer mPtrOriginal = orderParameters\r\n                    .offer[i]\r\n                    .toMemoryPointer();\r\n\r\n                // Retrieve the pointer to the newly returned item.\r\n                MemoryPointer mPtrNew = offer[i].toMemoryPointer();\r\n\r\n                // Compare the items and update the error buffer accordingly.\r\n                errorBuffer |=\r\n                    _cast(\r\n                        mPtrOriginal\r\n                            .offset(Common_amount_offset)\r\n                            .readUint256() >\r\n                            mPtrNew.offset(Common_amount_offset).readUint256()\r\n                    ) |\r\n                    _compareItems(mPtrOriginal, mPtrNew);\r\n\r\n                // Increment the array (cannot overflow as index starts at 0).\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            // Assign the returned offer item in place of the original item.\r\n            orderParameters.offer = offer;\r\n        }\r\n\r\n        {\r\n            // Designate lengths & memory locations.\r\n            ConsiderationItem[] memory originalConsiderationArray = (\r\n                orderParameters.consideration\r\n            );\r\n            uint256 newConsiderationLength = consideration.length;\r\n\r\n            // New consideration items cannot be created.\r\n            if (newConsiderationLength > originalConsiderationArray.length) {\r\n                _revertInvalidContractOrder(orderHash);\r\n            }\r\n\r\n            // Iterate over returned consideration & do not exceed maximumSpent.\r\n            for (uint256 i = 0; i < newConsiderationLength; ) {\r\n                // Retrieve the pointer to the originally supplied item.\r\n                MemoryPointer mPtrOriginal = originalConsiderationArray[i]\r\n                    .toMemoryPointer();\r\n\r\n                // Retrieve the pointer to the newly returned item.\r\n                MemoryPointer mPtrNew = consideration[i].toMemoryPointer();\r\n\r\n                // Compare the items and update the error buffer accordingly\r\n                // and ensure that the recipients are equal when provided.\r\n                errorBuffer |=\r\n                    _cast(\r\n                        mPtrNew.offset(Common_amount_offset).readUint256() >\r\n                            mPtrOriginal\r\n                                .offset(Common_amount_offset)\r\n                                .readUint256()\r\n                    ) |\r\n                    _compareItems(mPtrOriginal, mPtrNew) |\r\n                    _checkRecipients(\r\n                        mPtrOriginal\r\n                            .offset(ConsiderItem_recipient_offset)\r\n                            .readAddress(),\r\n                        mPtrNew\r\n                            .offset(ConsiderItem_recipient_offset)\r\n                            .readAddress()\r\n                    );\r\n\r\n                // Increment the array (cannot overflow as index starts at 0).\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            // Assign returned consideration item in place of the original item.\r\n            orderParameters.consideration = consideration;\r\n        }\r\n\r\n        // Revert if any item comparison failed.\r\n        if (errorBuffer != 0) {\r\n            _revertInvalidContractOrder(orderHash);\r\n        }\r\n\r\n        // Return order hash and full fill amount (numerator & denominator = 1).\r\n        return (orderHash, 1, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\r\n     *      only the offerer or the zone of a given order may cancel it. Callers\r\n     *      should ensure that the intended order was cancelled by calling\r\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\r\n     *      Also note that contract orders are not cancellable.\r\n     *\r\n     * @param orders The orders to cancel.\r\n     *\r\n     * @return cancelled A boolean indicating whether the supplied orders were\r\n     *                   successfully cancelled.\r\n     */\r\n    function _cancel(\r\n        OrderComponents[] calldata orders\r\n    ) internal returns (bool cancelled) {\r\n        // Ensure that the reentrancy guard is not currently set.\r\n        _assertNonReentrant();\r\n\r\n        // Declare variables outside of the loop.\r\n        OrderStatus storage orderStatus;\r\n\r\n        // Declare a variable for tracking invariants in the loop.\r\n        bool anyInvalidCallerOrContractOrder;\r\n\r\n        // Skip overflow check as for loop is indexed starting at zero.\r\n        unchecked {\r\n            // Read length of the orders array from memory and place on stack.\r\n            uint256 totalOrders = orders.length;\r\n\r\n            // Iterate over each order.\r\n            for (uint256 i = 0; i < totalOrders; ) {\r\n                // Retrieve the order.\r\n                OrderComponents calldata order = orders[i];\r\n\r\n                address offerer = order.offerer;\r\n                address zone = order.zone;\r\n                OrderType orderType = order.orderType;\r\n\r\n                assembly {\r\n                    // If caller is neither the offerer nor zone, or a contract\r\n                    // order is present, flag anyInvalidCallerOrContractOrder.\r\n                    anyInvalidCallerOrContractOrder := or(\r\n                        anyInvalidCallerOrContractOrder,\r\n                        // orderType == CONTRACT ||\r\n                        // !(caller == offerer || caller == zone)\r\n                        or(\r\n                            eq(orderType, 4),\r\n                            iszero(\r\n                                or(eq(caller(), offerer), eq(caller(), zone))\r\n                            )\r\n                        )\r\n                    )\r\n                }\r\n\r\n                bytes32 orderHash = _deriveOrderHash(\r\n                    _toOrderParametersReturnType(\r\n                        _decodeOrderComponentsAsOrderParameters\r\n                    )(order.toCalldataPointer()),\r\n                    order.counter\r\n                );\r\n\r\n                // Retrieve the order status using the derived order hash.\r\n                orderStatus = _orderStatus[orderHash];\r\n\r\n                // Update the order status as not valid and cancelled.\r\n                orderStatus.isValidated = false;\r\n                orderStatus.isCancelled = true;\r\n\r\n                // Emit an event signifying that the order has been cancelled.\r\n                emit OrderCancelled(orderHash, offerer, zone);\r\n\r\n                // Increment counter inside body of loop for gas efficiency.\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        if (anyInvalidCallerOrContractOrder) {\r\n            _revertCannotCancelOrder();\r\n        }\r\n\r\n        // Return a boolean indicating that orders were successfully cancelled.\r\n        cancelled = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to validate an arbitrary number of orders, thereby\r\n     *      registering their signatures as valid and allowing the fulfiller to\r\n     *      skip signature verification on fulfillment. Note that validated\r\n     *      orders may still be unfulfillable due to invalid item amounts or\r\n     *      other factors; callers should determine whether validated orders are\r\n     *      fulfillable by simulating the fulfillment call prior to execution.\r\n     *      Also note that anyone can validate a signed order, but only the\r\n     *      offerer can validate an order without supplying a signature.\r\n     *\r\n     * @param orders The orders to validate.\r\n     *\r\n     * @return validated A boolean indicating whether the supplied orders were\r\n     *                   successfully validated.\r\n     */\r\n    function _validate(\r\n        Order[] memory orders\r\n    ) internal returns (bool validated) {\r\n        // Ensure that the reentrancy guard is not currently set.\r\n        _assertNonReentrant();\r\n\r\n        // Declare variables outside of the loop.\r\n        OrderStatus storage orderStatus;\r\n        bytes32 orderHash;\r\n        address offerer;\r\n\r\n        // Skip overflow check as for loop is indexed starting at zero.\r\n        unchecked {\r\n            // Read length of the orders array from memory and place on stack.\r\n            uint256 totalOrders = orders.length;\r\n\r\n            // Iterate over each order.\r\n            for (uint256 i = 0; i < totalOrders; ++i) {\r\n                // Retrieve the order.\r\n                Order memory order = orders[i];\r\n\r\n                // Retrieve the order parameters.\r\n                OrderParameters memory orderParameters = order.parameters;\r\n\r\n                // Skip contract orders.\r\n                if (orderParameters.orderType == OrderType.CONTRACT) {\r\n                    continue;\r\n                }\r\n\r\n                // Move offerer from memory to the stack.\r\n                offerer = orderParameters.offerer;\r\n\r\n                // Get current counter & use it w/ params to derive order hash.\r\n                orderHash = _assertConsiderationLengthAndGetOrderHash(\r\n                    orderParameters\r\n                );\r\n\r\n                // Retrieve the order status using the derived order hash.\r\n                orderStatus = _orderStatus[orderHash];\r\n\r\n                // Ensure order is fillable and retrieve the filled amount.\r\n                _verifyOrderStatus(\r\n                    orderHash,\r\n                    orderStatus,\r\n                    false, // Signifies that partially filled orders are valid.\r\n                    true // Signifies to revert if the order is invalid.\r\n                );\r\n\r\n                // If the order has not already been validated...\r\n                if (!orderStatus.isValidated) {\r\n                    // Ensure that consideration array length is equal to the\r\n                    // total original consideration items value.\r\n                    if (\r\n                        orderParameters.consideration.length !=\r\n                        orderParameters.totalOriginalConsiderationItems\r\n                    ) {\r\n                        _revertConsiderationLengthNotEqualToTotalOriginal();\r\n                    }\r\n\r\n                    // Verify the supplied signature.\r\n                    _verifySignature(offerer, orderHash, order.signature);\r\n\r\n                    // Update order status to mark the order as valid.\r\n                    orderStatus.isValidated = true;\r\n\r\n                    // Emit an event signifying the order has been validated.\r\n                    emit OrderValidated(orderHash, orderParameters);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Return a boolean indicating that orders were successfully validated.\r\n        validated = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to retrieve the status of a given order by\r\n     *      hash, including whether the order has been cancelled or validated\r\n     *      and the fraction of the order that has been filled.\r\n     *\r\n     * @param orderHash The order hash in question.\r\n     *\r\n     * @return isValidated A boolean indicating whether the order in question\r\n     *                     has been validated (i.e. previously approved or\r\n     *                     partially filled).\r\n     * @return isCancelled A boolean indicating whether the order in question\r\n     *                     has been cancelled.\r\n     * @return totalFilled The total portion of the order that has been filled\r\n     *                     (i.e. the \"numerator\").\r\n     * @return totalSize   The total size of the order that is either filled or\r\n     *                     unfilled (i.e. the \"denominator\").\r\n     */\r\n    function _getOrderStatus(\r\n        bytes32 orderHash\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            bool isValidated,\r\n            bool isCancelled,\r\n            uint256 totalFilled,\r\n            uint256 totalSize\r\n        )\r\n    {\r\n        // Retrieve the order status using the order hash.\r\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\r\n\r\n        // Return the fields on the order status.\r\n        return (\r\n            orderStatus.isValidated,\r\n            orderStatus.isCancelled,\r\n            orderStatus.numerator,\r\n            orderStatus.denominator\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to either revert or return an empty tuple\r\n     *      depending on the value of `revertOnInvalid`.\r\n     *\r\n     * @param revertOnInvalid   Whether to revert on invalid input.\r\n     * @param contractOrderHash The contract order hash.\r\n     *\r\n     * @return orderHash   The order hash.\r\n     * @return numerator   The numerator.\r\n     * @return denominator The denominator.\r\n     */\r\n    function _revertOrReturnEmpty(\r\n        bool revertOnInvalid,\r\n        bytes32 contractOrderHash\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\r\n    {\r\n        if (revertOnInvalid) {\r\n            _revertInvalidContractOrder(contractOrderHash);\r\n        }\r\n\r\n        return (contractOrderHash, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to check whether a given order type indicates\r\n     *      that partial fills are not supported (e.g. only \"full fills\" are\r\n     *      allowed for the order in question).\r\n     *\r\n     * @param orderType   The order type in question.\r\n     * @param numerator   The numerator in question.\r\n     * @param denominator The denominator in question.\r\n     *\r\n     * @return isFullOrder A boolean indicating whether the order type only\r\n     *                     supports full fills.\r\n     */\r\n    function _doesNotSupportPartialFills(\r\n        OrderType orderType,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    ) internal pure returns (bool isFullOrder) {\r\n        // The \"full\" order types are even, while \"partial\" order types are odd.\r\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper. The\r\n        // check is only necessary if numerator is less than denominator.\r\n        assembly {\r\n            // Equivalent to `uint256(orderType) & 1 == 0`.\r\n            isFullOrder := and(\r\n                lt(numerator, denominator),\r\n                iszero(and(orderType, 1))\r\n            )\r\n        }\r\n    }\r\n}\r\ncontract BasicOrderFulfiller is OrderValidator {\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) OrderValidator(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\r\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\r\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\r\n     *      permutations are supported: Native token to ERC721, Native token to\r\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\r\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\r\n     *      order to be eligible for fulfillment via this method, it must\r\n     *      contain a single offer item (though that item may have a greater\r\n     *      amount if the item is not an ERC721). An arbitrary number of\r\n     *      \"additional recipients\" may also be supplied which will each receive\r\n     *      native tokens or ERC20 items from the fulfiller as consideration.\r\n     *      Refer to the documentation for a more comprehensive summary of how\r\n     *      to utilize this method and what orders are compatible with it.\r\n     *\r\n     * @param parameters Additional information on the fulfilled order. Note\r\n     *                   that the offerer and the fulfiller must first approve\r\n     *                   this contract (or their chosen conduit if indicated)\r\n     *                   before any tokens can be transferred. Also note that\r\n     *                   contract recipients of ERC1155 consideration items must\r\n     *                   implement `onERC1155Received` in order to receive those\r\n     *                   items.\r\n     *\r\n     * @return A boolean indicating whether the order has been fulfilled.\r\n     */\r\n    function _validateAndFulfillBasicOrder(\r\n        BasicOrderParameters calldata parameters\r\n    ) internal returns (bool) {\r\n        // Declare enums for order type & route to extract from basicOrderType.\r\n        BasicOrderRouteType route;\r\n        OrderType orderType;\r\n\r\n        // Declare additional recipient item type to derive from the route type.\r\n        ItemType additionalRecipientsItemType;\r\n\r\n        bytes32 orderHash;\r\n\r\n        // Utilize assembly to extract the order type and the basic order route.\r\n        assembly {\r\n            // Read basicOrderType from calldata.\r\n            let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)\r\n\r\n            // Mask all but 2 least-significant bits to derive the order type.\r\n            orderType := and(basicOrderType, 3)\r\n\r\n            // Divide basicOrderType by four to derive the route.\r\n            route := shr(2, basicOrderType)\r\n\r\n            // If route > 1 additionalRecipient items are ERC20 (1) else native\r\n            // token (0).\r\n            additionalRecipientsItemType := gt(route, 1)\r\n        }\r\n\r\n        {\r\n            // Declare temporary variable for enforcing payable status.\r\n            bool correctPayableStatus;\r\n\r\n            // Utilize assembly to compare the route to the callvalue.\r\n            assembly {\r\n                // route 0 and 1 are payable, otherwise route is not payable.\r\n                correctPayableStatus := eq(\r\n                    additionalRecipientsItemType,\r\n                    iszero(callvalue())\r\n                )\r\n            }\r\n\r\n            // Revert if msg.value has not been supplied as part of payable\r\n            // routes or has been supplied as part of non-payable routes.\r\n            if (!correctPayableStatus) {\r\n                _revertInvalidMsgValue(msg.value);\r\n            }\r\n        }\r\n\r\n        // Declare more arguments that will be derived from route and calldata.\r\n        address additionalRecipientsToken;\r\n        ItemType offeredItemType;\r\n        bool offerTypeIsAdditionalRecipientsType;\r\n\r\n        // Declare scope for received item type to manage stack pressure.\r\n        {\r\n            ItemType receivedItemType;\r\n\r\n            // Utilize assembly to retrieve function arguments and cast types.\r\n            assembly {\r\n                // Check if offered item type == additional recipient item type.\r\n                offerTypeIsAdditionalRecipientsType := gt(route, 3)\r\n\r\n                // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\r\n                additionalRecipientsToken := calldataload(\r\n                    add(\r\n                        BasicOrder_considerationToken_cdPtr,\r\n                        mul(\r\n                            offerTypeIsAdditionalRecipientsType,\r\n                            BasicOrder_common_params_size\r\n                        )\r\n                    )\r\n                )\r\n\r\n                // If route > 2, receivedItemType is route - 2. If route is 2,\r\n                // the receivedItemType is ERC20 (1). Otherwise, it is native\r\n                // token (0).\r\n                receivedItemType := byte(route, BasicOrder_receivedItemByteMap)\r\n\r\n                // If route > 3, offeredItemType is ERC20 (1). Route is 2 or 3,\r\n                // offeredItemType = route. Route is 0 or 1, it is route + 2.\r\n                offeredItemType := byte(route, BasicOrder_offeredItemByteMap)\r\n            }\r\n\r\n            // Derive & validate order using parameters and update order status.\r\n            orderHash = _prepareBasicFulfillmentFromCalldata(\r\n                parameters,\r\n                orderType,\r\n                receivedItemType,\r\n                additionalRecipientsItemType,\r\n                additionalRecipientsToken,\r\n                offeredItemType\r\n            );\r\n        }\r\n\r\n        // Declare conduitKey argument used by transfer functions.\r\n        bytes32 conduitKey;\r\n\r\n        // Utilize assembly to derive conduit (if relevant) based on route.\r\n        assembly {\r\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\r\n            conduitKey := calldataload(\r\n                add(\r\n                    BasicOrder_offererConduit_cdPtr,\r\n                    shl(OneWordShift, offerTypeIsAdditionalRecipientsType)\r\n                )\r\n            )\r\n        }\r\n\r\n        // Transfer tokens based on the route.\r\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\r\n            // Ensure neither consideration token nor identifier are set. Note\r\n            // that dirty upper bits in the consideration token will still cause\r\n            // this error to be thrown.\r\n            assembly {\r\n                if or(\r\n                    calldataload(BasicOrder_considerationToken_cdPtr),\r\n                    calldataload(BasicOrder_considerationIdentifier_cdPtr)\r\n                ) {\r\n                    // Store left-padded selector with push4 (reduces bytecode),\r\n                    // mem[28:32] = selector\r\n                    mstore(0, UnusedItemParameters_error_selector)\r\n\r\n                    // revert(abi.encodeWithSignature(\"UnusedItemParameters()\"))\r\n                    revert(\r\n                        Error_selector_offset,\r\n                        UnusedItemParameters_error_length\r\n                    )\r\n                }\r\n            }\r\n\r\n            // Transfer the ERC721 or ERC1155 item, bypassing the accumulator.\r\n            _transferIndividual721Or1155Item(offeredItemType, conduitKey);\r\n\r\n            // Transfer native to recipients, return excess to caller & wrap up.\r\n            _transferNativeTokensAndFinalize();\r\n        } else {\r\n            // Initialize an accumulator array. From this point forward, no new\r\n            // memory regions can be safely allocated until the accumulator is\r\n            // no longer being utilized, as the accumulator operates in an\r\n            // open-ended fashion from this memory pointer; existing memory may\r\n            // still be accessed and modified, however.\r\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\r\n\r\n            // Choose transfer method for ERC721 or ERC1155 item based on route.\r\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\r\n                // Transfer ERC721 to caller using offerer's conduit preference.\r\n                _transferERC721(\r\n                    parameters.offerToken,\r\n                    parameters.offerer,\r\n                    msg.sender,\r\n                    parameters.offerIdentifier,\r\n                    parameters.offerAmount,\r\n                    conduitKey,\r\n                    accumulator\r\n                );\r\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\r\n                // Transfer ERC1155 to caller with offerer's conduit preference.\r\n                _transferERC1155(\r\n                    parameters.offerToken,\r\n                    parameters.offerer,\r\n                    msg.sender,\r\n                    parameters.offerIdentifier,\r\n                    parameters.offerAmount,\r\n                    conduitKey,\r\n                    accumulator\r\n                );\r\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\r\n                // Transfer ERC721 to offerer using caller's conduit preference.\r\n                _transferERC721(\r\n                    parameters.considerationToken,\r\n                    msg.sender,\r\n                    parameters.offerer,\r\n                    parameters.considerationIdentifier,\r\n                    parameters.considerationAmount,\r\n                    conduitKey,\r\n                    accumulator\r\n                );\r\n            } else {\r\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\r\n\r\n                // Transfer ERC1155 to offerer with caller's conduit preference.\r\n                _transferERC1155(\r\n                    parameters.considerationToken,\r\n                    msg.sender,\r\n                    parameters.offerer,\r\n                    parameters.considerationIdentifier,\r\n                    parameters.considerationAmount,\r\n                    conduitKey,\r\n                    accumulator\r\n                );\r\n            }\r\n\r\n            // Transfer ERC20 tokens to all recipients and wrap up.\r\n            _transferERC20AndFinalize(\r\n                offerTypeIsAdditionalRecipientsType,\r\n                accumulator\r\n            );\r\n\r\n            // Trigger any remaining accumulated transfers via call to conduit.\r\n            _triggerIfArmed(accumulator);\r\n        }\r\n\r\n        // Determine whether order is restricted and, if so, that it is valid.\r\n        _assertRestrictedBasicOrderValidity(orderHash, orderType, parameters);\r\n\r\n        // Clear the reentrancy guard.\r\n        _clearReentrancyGuard();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to prepare fulfillment of a basic order with\r\n     *      manual calldata and memory access. This calculates the order hash,\r\n     *      emits an OrderFulfilled event, and asserts basic order validity.\r\n     *      Note that calldata offsets must be validated as this function\r\n     *      accesses constant calldata pointers for dynamic types that match\r\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\r\n     *      offsets. Checking that the offsets were produced by default encoding\r\n     *      will ensure that other functions using Solidity's calldata accessors\r\n     *      (which calculate pointers from the stored offsets) are reading the\r\n     *      same data as the order hash is derived from. Also note that this\r\n     *      function accesses memory directly.\r\n     *\r\n     * @param parameters                   The parameters of the basic order.\r\n     * @param orderType                    The order type.\r\n     * @param receivedItemType             The item type of the initial\r\n     *                                     consideration item on the order.\r\n     * @param additionalRecipientsItemType The item type of any additional\r\n     *                                     consideration item on the order.\r\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\r\n     *                                     applicable) for any additional\r\n     *                                     consideration item on the order.\r\n     * @param offeredItemType              The item type of the offered item on\r\n     *                                     the order.\r\n     * @return orderHash The calculated order hash.\r\n     */\r\n    function _prepareBasicFulfillmentFromCalldata(\r\n        BasicOrderParameters calldata parameters,\r\n        OrderType orderType,\r\n        ItemType receivedItemType,\r\n        ItemType additionalRecipientsItemType,\r\n        address additionalRecipientsToken,\r\n        ItemType offeredItemType\r\n    ) internal returns (bytes32 orderHash) {\r\n        // Ensure this function cannot be triggered during a reentrant call.\r\n        _setReentrancyGuard(false); // Native tokens rejected during execution.\r\n\r\n        // Verify that calldata offsets for all dynamic types were produced by\r\n        // default encoding. This ensures that the constants used for calldata\r\n        // pointers to dynamic types are the same as those calculated by\r\n        // Solidity using their offsets. Also verify that the basic order type\r\n        // is within range.\r\n        _assertValidBasicOrderParameters();\r\n\r\n        // Check for invalid time and missing original consideration items.\r\n        // Utilize assembly so that constant calldata pointers can be applied.\r\n        assembly {\r\n            // Ensure current timestamp is between order start time & end time.\r\n            if or(\r\n                gt(calldataload(BasicOrder_startTime_cdPtr), timestamp()),\r\n                iszero(gt(calldataload(BasicOrder_endTime_cdPtr), timestamp()))\r\n            ) {\r\n                // Store left-padded selector with push4 (reduces bytecode),\r\n                // mem[28:32] = selector\r\n                mstore(0, InvalidTime_error_selector)\r\n\r\n                // Store arguments.\r\n                mstore(\r\n                    InvalidTime_error_startTime_ptr,\r\n                    calldataload(BasicOrder_startTime_cdPtr)\r\n                )\r\n                mstore(\r\n                    InvalidTime_error_endTime_ptr,\r\n                    calldataload(BasicOrder_endTime_cdPtr)\r\n                )\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"InvalidTime(uint256,uint256)\",\r\n                //     startTime,\r\n                //     endTime\r\n                // ))\r\n                revert(Error_selector_offset, InvalidTime_error_length)\r\n            }\r\n\r\n            // Ensure consideration array length isn't less than total original.\r\n            if lt(\r\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr),\r\n                calldataload(BasicOrder_totalOriginalAdditionalRecipients_cdPtr)\r\n            ) {\r\n                // Store left-padded selector with push4 (reduces bytecode),\r\n                // mem[28:32] = selector\r\n                mstore(0, MissingOriginalConsiderationItems_error_selector)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"MissingOriginalConsiderationItems()\"\r\n                // ))\r\n                revert(\r\n                    Error_selector_offset,\r\n                    MissingOriginalConsiderationItems_error_length\r\n                )\r\n            }\r\n        }\r\n\r\n        {\r\n            /**\r\n             * First, handle consideration items. Memory Layout:\r\n             *  0x60: final hash of the array of consideration item hashes\r\n             *  0x80-0x160: reused space for EIP712 hashing of each item\r\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\r\n             *   - 0xa0: itemType\r\n             *   - 0xc0: token\r\n             *   - 0xe0: identifier\r\n             *   - 0x100: startAmount\r\n             *   - 0x120: endAmount\r\n             *   - 0x140: recipient\r\n             *  0x160-END_ARR: array of consideration item hashes\r\n             *   - 0x160: primary consideration item EIP712 hash\r\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\r\n             *  END_ARR: beginning of data for OrderFulfilled event\r\n             *   - END_ARR + 0x120: length of ReceivedItem array\r\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\r\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\r\n             */\r\n\r\n            // Load consideration item typehash from runtime and place on stack.\r\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\r\n\r\n            // Utilize assembly to enable reuse of memory regions and use\r\n            // constant pointers when possible.\r\n            assembly {\r\n                /*\r\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\r\n                 * primary consideration item of the basic order.\r\n                 */\r\n\r\n                // Write ConsiderationItem type hash and item type to memory.\r\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\r\n                mstore(\r\n                    BasicOrder_considerationItem_itemType_ptr,\r\n                    receivedItemType\r\n                )\r\n\r\n                // Copy calldata region with (token, identifier, amount) from\r\n                // BasicOrderParameters to ConsiderationItem. The\r\n                // considerationAmount is written to startAmount and endAmount\r\n                // as basic orders do not have dynamic amounts.\r\n                calldatacopy(\r\n                    BasicOrder_considerationItem_token_ptr,\r\n                    BasicOrder_considerationToken_cdPtr,\r\n                    ThreeWords\r\n                )\r\n\r\n                // Copy calldata region with considerationAmount and offerer\r\n                // from BasicOrderParameters to endAmount and recipient in\r\n                // ConsiderationItem.\r\n                calldatacopy(\r\n                    BasicOrder_considerationItem_endAmount_ptr,\r\n                    BasicOrder_considerationAmount_cdPtr,\r\n                    TwoWords\r\n                )\r\n\r\n                // Calculate EIP712 ConsiderationItem hash and store it in the\r\n                // array of EIP712 consideration hashes.\r\n                mstore(\r\n                    BasicOrder_considerationHashesArray_ptr,\r\n                    keccak256(\r\n                        BasicOrder_considerationItem_typeHash_ptr,\r\n                        EIP712_ConsiderationItem_size\r\n                    )\r\n                )\r\n\r\n                /*\r\n                 * 2. Write a ReceivedItem struct for the primary consideration\r\n                 * item to the consideration array in OrderFulfilled.\r\n                 */\r\n\r\n                // Get the length of the additional recipients array.\r\n                let totalAdditionalRecipients := calldataload(\r\n                    BasicOrder_additionalRecipients_length_cdPtr\r\n                )\r\n\r\n                // Calculate pointer to length of OrderFulfilled consideration\r\n                // array.\r\n                let eventConsiderationArrPtr := add(\r\n                    OrderFulfilled_consideration_length_baseOffset,\r\n                    shl(OneWordShift, totalAdditionalRecipients)\r\n                )\r\n\r\n                // Set the length of the consideration array to the number of\r\n                // additional recipients, plus one for the primary consideration\r\n                // item.\r\n                mstore(\r\n                    eventConsiderationArrPtr,\r\n                    add(totalAdditionalRecipients, 1)\r\n                )\r\n\r\n                // Overwrite the consideration array pointer so it points to the\r\n                // body of the first element\r\n                eventConsiderationArrPtr := add(\r\n                    eventConsiderationArrPtr,\r\n                    OneWord\r\n                )\r\n\r\n                // Set itemType at start of the ReceivedItem memory region.\r\n                mstore(eventConsiderationArrPtr, receivedItemType)\r\n\r\n                // Copy calldata region (token, identifier, amount & recipient)\r\n                // from BasicOrderParameters to ReceivedItem memory.\r\n                calldatacopy(\r\n                    add(eventConsiderationArrPtr, Common_token_offset),\r\n                    BasicOrder_considerationToken_cdPtr,\r\n                    FourWords\r\n                )\r\n\r\n                /*\r\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\r\n                 * additional recipients and add a ReceivedItem for each to the\r\n                 * consideration array in the OrderFulfilled event. The original\r\n                 * additional recipients are all the consideration items signed\r\n                 * by the offerer aside from the primary consideration items of\r\n                 * the order. Uses memory region from 0x80-0x160 as a buffer for\r\n                 * calculating EIP712 ConsiderationItem hashes.\r\n                 */\r\n\r\n                // Put pointer to consideration hashes array on the stack.\r\n                // This will be updated as each additional recipient is hashed\r\n                let\r\n                    considerationHashesPtr\r\n                := BasicOrder_considerationHashesArray_ptr\r\n\r\n                // Write item type, token, & identifier for additional recipient\r\n                // to memory region for hashing EIP712 ConsiderationItem; these\r\n                // values will be reused for each recipient.\r\n                mstore(\r\n                    BasicOrder_considerationItem_itemType_ptr,\r\n                    additionalRecipientsItemType\r\n                )\r\n                mstore(\r\n                    BasicOrder_considerationItem_token_ptr,\r\n                    additionalRecipientsToken\r\n                )\r\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\r\n\r\n                // Declare a stack variable where all additional recipients will\r\n                // be combined to guard against providing dirty upper bits.\r\n                let combinedAdditionalRecipients\r\n\r\n                // Read length of the additionalRecipients array from calldata\r\n                // and iterate.\r\n                totalAdditionalRecipients := calldataload(\r\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\r\n                )\r\n                let i := 0\r\n                for {} lt(i, totalAdditionalRecipients) {\r\n                    i := add(i, 1)\r\n                } {\r\n                    /*\r\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\r\n                     */\r\n\r\n                    // Retrieve calldata pointer for additional recipient.\r\n                    let additionalRecipientCdPtr := add(\r\n                        BasicOrder_additionalRecipients_data_cdPtr,\r\n                        mul(AdditionalRecipient_size, i)\r\n                    )\r\n\r\n                    // Copy startAmount from calldata to the ConsiderationItem\r\n                    // struct.\r\n                    calldatacopy(\r\n                        BasicOrder_considerationItem_startAmount_ptr,\r\n                        additionalRecipientCdPtr,\r\n                        OneWord\r\n                    )\r\n\r\n                    // Copy endAmount and recipient from calldata to the\r\n                    // ConsiderationItem struct.\r\n                    calldatacopy(\r\n                        BasicOrder_considerationItem_endAmount_ptr,\r\n                        additionalRecipientCdPtr,\r\n                        AdditionalRecipient_size\r\n                    )\r\n\r\n                    // Include the recipient as part of combined recipients.\r\n                    combinedAdditionalRecipients := or(\r\n                        combinedAdditionalRecipients,\r\n                        calldataload(add(additionalRecipientCdPtr, OneWord))\r\n                    )\r\n\r\n                    // Add 1 word to the pointer as part of each loop to reduce\r\n                    // operations needed to get local offset into the array.\r\n                    considerationHashesPtr := add(\r\n                        considerationHashesPtr,\r\n                        OneWord\r\n                    )\r\n\r\n                    // Calculate EIP712 ConsiderationItem hash and store it in\r\n                    // the array of consideration hashes.\r\n                    mstore(\r\n                        considerationHashesPtr,\r\n                        keccak256(\r\n                            BasicOrder_considerationItem_typeHash_ptr,\r\n                            EIP712_ConsiderationItem_size\r\n                        )\r\n                    )\r\n\r\n                    /*\r\n                     * Write ReceivedItem to OrderFulfilled data.\r\n                     */\r\n\r\n                    // At this point, eventConsiderationArrPtr points to the\r\n                    // beginning of the ReceivedItem struct of the previous\r\n                    // element in the array. Increase it by the size of the\r\n                    // struct to arrive at the pointer for the current element.\r\n                    eventConsiderationArrPtr := add(\r\n                        eventConsiderationArrPtr,\r\n                        ReceivedItem_size\r\n                    )\r\n\r\n                    // Write itemType to the ReceivedItem struct.\r\n                    mstore(\r\n                        eventConsiderationArrPtr,\r\n                        additionalRecipientsItemType\r\n                    )\r\n\r\n                    // Write token to the next word of the ReceivedItem struct.\r\n                    mstore(\r\n                        add(eventConsiderationArrPtr, OneWord),\r\n                        additionalRecipientsToken\r\n                    )\r\n\r\n                    // Copy endAmount & recipient words to ReceivedItem struct.\r\n                    calldatacopy(\r\n                        add(\r\n                            eventConsiderationArrPtr,\r\n                            ReceivedItem_amount_offset\r\n                        ),\r\n                        additionalRecipientCdPtr,\r\n                        TwoWords\r\n                    )\r\n                }\r\n\r\n                /*\r\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\r\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\r\n                 * Note that it is set at 0x60 \u2014 all other memory begins at\r\n                 * 0x80. 0x60 is the \"zero slot\" and will be restored at the end\r\n                 * of the assembly section and before required by the compiler.\r\n                 */\r\n                mstore(\r\n                    receivedItemsHash_ptr,\r\n                    keccak256(\r\n                        BasicOrder_considerationHashesArray_ptr,\r\n                        shl(OneWordShift, add(totalAdditionalRecipients, 1))\r\n                    )\r\n                )\r\n\r\n                /*\r\n                 * 5. Add a ReceivedItem for each tip to the consideration array\r\n                 * in the OrderFulfilled event. The tips are all the\r\n                 * consideration items that were not signed by the offerer and\r\n                 * were provided by the fulfiller.\r\n                 */\r\n\r\n                // Overwrite length to length of the additionalRecipients array.\r\n                totalAdditionalRecipients := calldataload(\r\n                    BasicOrder_additionalRecipients_length_cdPtr\r\n                )\r\n\r\n                for {} lt(i, totalAdditionalRecipients) {\r\n                    i := add(i, 1)\r\n                } {\r\n                    // Retrieve calldata pointer for additional recipient.\r\n                    let additionalRecipientCdPtr := add(\r\n                        BasicOrder_additionalRecipients_data_cdPtr,\r\n                        mul(AdditionalRecipient_size, i)\r\n                    )\r\n\r\n                    // At this point, eventConsiderationArrPtr points to the\r\n                    // beginning of the ReceivedItem struct of the previous\r\n                    // element in the array. Increase it by the size of the\r\n                    // struct to arrive at the pointer for the current element.\r\n                    eventConsiderationArrPtr := add(\r\n                        eventConsiderationArrPtr,\r\n                        ReceivedItem_size\r\n                    )\r\n\r\n                    // Write itemType to the ReceivedItem struct.\r\n                    mstore(\r\n                        eventConsiderationArrPtr,\r\n                        additionalRecipientsItemType\r\n                    )\r\n\r\n                    // Write token to the next word of the ReceivedItem struct.\r\n                    mstore(\r\n                        add(eventConsiderationArrPtr, OneWord),\r\n                        additionalRecipientsToken\r\n                    )\r\n\r\n                    // Copy endAmount & recipient words to ReceivedItem struct.\r\n                    calldatacopy(\r\n                        add(\r\n                            eventConsiderationArrPtr,\r\n                            ReceivedItem_amount_offset\r\n                        ),\r\n                        additionalRecipientCdPtr,\r\n                        TwoWords\r\n                    )\r\n\r\n                    // Include the recipient as part of combined recipients.\r\n                    combinedAdditionalRecipients := or(\r\n                        combinedAdditionalRecipients,\r\n                        calldataload(add(additionalRecipientCdPtr, OneWord))\r\n                    )\r\n                }\r\n\r\n                // Ensure no dirty upper bits on combined additional recipients.\r\n                if gt(combinedAdditionalRecipients, MaskOverLastTwentyBytes) {\r\n                    // Store left-padded selector with push4 (reduces bytecode),\r\n                    // mem[28:32] = selector\r\n                    mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\r\n\r\n                    // revert(abi.encodeWithSignature(\r\n                    //     \"InvalidBasicOrderParameterEncoding()\"\r\n                    // ))\r\n                    revert(\r\n                        Error_selector_offset,\r\n                        InvalidBasicOrderParameterEncoding_error_length\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        {\r\n            /**\r\n             * Next, handle offered items. Memory Layout:\r\n             *  EIP712 data for OfferItem\r\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\r\n             *   - 0xa0:  itemType\r\n             *   - 0xc0:  token\r\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\r\n             *   - 0x100: startAmount\r\n             *   - 0x120: endAmount\r\n             */\r\n\r\n            // Place offer item typehash on the stack.\r\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\r\n\r\n            // Utilize assembly to enable reuse of memory regions when possible.\r\n            assembly {\r\n                /*\r\n                 * 1. Calculate OfferItem EIP712 hash\r\n                 */\r\n\r\n                // Write the OfferItem typeHash to memory.\r\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\r\n\r\n                // Write the OfferItem item type to memory.\r\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\r\n\r\n                // Copy calldata region with (offerToken, offerIdentifier,\r\n                // offerAmount) from OrderParameters to (token, identifier,\r\n                // startAmount) in OfferItem struct. The offerAmount is written\r\n                // to startAmount and endAmount as basic orders do not have\r\n                // dynamic amounts.\r\n                calldatacopy(\r\n                    BasicOrder_offerItem_token_ptr,\r\n                    BasicOrder_offerToken_cdPtr,\r\n                    ThreeWords\r\n                )\r\n\r\n                // Copy offerAmount from calldata to endAmount in OfferItem\r\n                // struct.\r\n                calldatacopy(\r\n                    BasicOrder_offerItem_endAmount_ptr,\r\n                    BasicOrder_offerAmount_cdPtr,\r\n                    OneWord\r\n                )\r\n\r\n                // Compute EIP712 OfferItem hash, write result to scratch space:\r\n                //   `keccak256(abi.encode(offeredItem))`\r\n                mstore(\r\n                    0,\r\n                    keccak256(\r\n                        BasicOrder_offerItem_typeHash_ptr,\r\n                        EIP712_OfferItem_size\r\n                    )\r\n                )\r\n\r\n                /*\r\n                 * 2. Calculate hash of array of EIP712 hashes and write the\r\n                 * result to the corresponding OfferItem struct:\r\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\r\n                 */\r\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\r\n\r\n                /*\r\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\r\n                 */\r\n                let eventConsiderationArrPtr := add(\r\n                    OrderFulfilled_offer_length_baseOffset,\r\n                    shl(\r\n                        OneWordShift,\r\n                        calldataload(\r\n                            BasicOrder_additionalRecipients_length_cdPtr\r\n                        )\r\n                    )\r\n                )\r\n\r\n                // Set a length of 1 for the offer array.\r\n                mstore(eventConsiderationArrPtr, 1)\r\n\r\n                // Write itemType to the SpentItem struct.\r\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\r\n\r\n                // Copy calldata region with (offerToken, offerIdentifier,\r\n                // offerAmount) from OrderParameters to (token, identifier,\r\n                // amount) in SpentItem struct.\r\n                calldatacopy(\r\n                    add(eventConsiderationArrPtr, AdditionalRecipient_size),\r\n                    BasicOrder_offerToken_cdPtr,\r\n                    ThreeWords\r\n                )\r\n            }\r\n        }\r\n\r\n        {\r\n            /**\r\n             * Once consideration items and offer items have been handled,\r\n             * derive the final order hash. Memory Layout:\r\n             *  0x80-0x1c0: EIP712 data for order\r\n             *   - 0x80:   Order EIP-712 typehash (constant)\r\n             *   - 0xa0:   orderParameters.offerer\r\n             *   - 0xc0:   orderParameters.zone\r\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\r\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\r\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\r\n             *   - 0x140:  orderParameters.startTime\r\n             *   - 0x160:  orderParameters.endTime\r\n             *   - 0x180:  orderParameters.zoneHash\r\n             *   - 0x1a0:  orderParameters.salt\r\n             *   - 0x1c0:  orderParameters.conduitKey\r\n             *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\r\n             */\r\n\r\n            // Read the offerer from calldata and place on the stack.\r\n            address offerer;\r\n            assembly {\r\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\r\n            }\r\n\r\n            // Read offerer's current counter from storage and place on stack.\r\n            uint256 counter = _getCounter(offerer);\r\n\r\n            // Load order typehash from runtime code and place on stack.\r\n            bytes32 typeHash = _ORDER_TYPEHASH;\r\n\r\n            assembly {\r\n                // Set the OrderItem typeHash in memory.\r\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\r\n\r\n                // Copy offerer and zone from OrderParameters in calldata to the\r\n                // Order struct.\r\n                calldatacopy(\r\n                    BasicOrder_order_offerer_ptr,\r\n                    BasicOrder_offerer_cdPtr,\r\n                    TwoWords\r\n                )\r\n\r\n                // Copy receivedItemsHash from zero slot to the Order struct.\r\n                mstore(\r\n                    BasicOrder_order_considerationHashes_ptr,\r\n                    mload(receivedItemsHash_ptr)\r\n                )\r\n\r\n                // Write the supplied orderType to the Order struct.\r\n                mstore(BasicOrder_order_orderType_ptr, orderType)\r\n\r\n                // Copy startTime, endTime, zoneHash, salt & conduit from\r\n                // calldata to the Order struct.\r\n                calldatacopy(\r\n                    BasicOrder_order_startTime_ptr,\r\n                    BasicOrder_startTime_cdPtr,\r\n                    FiveWords\r\n                )\r\n\r\n                // Write offerer's counter, retrieved from storage, to struct.\r\n                mstore(BasicOrder_order_counter_ptr, counter)\r\n\r\n                // Compute the EIP712 Order hash.\r\n                orderHash := keccak256(\r\n                    BasicOrder_order_typeHash_ptr,\r\n                    EIP712_Order_size\r\n                )\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            /**\r\n             * After the order hash has been derived, emit OrderFulfilled event:\r\n             *   event OrderFulfilled(\r\n             *     bytes32 orderHash,\r\n             *     address indexed offerer,\r\n             *     address indexed zone,\r\n             *     address fulfiller,\r\n             *     SpentItem[] offer,\r\n             *       > (itemType, token, id, amount)\r\n             *     ReceivedItem[] consideration\r\n             *       > (itemType, token, id, amount, recipient)\r\n             *   )\r\n             * topic0 - OrderFulfilled event signature\r\n             * topic1 - offerer\r\n             * topic2 - zone\r\n             * data:\r\n             *  - 0x00: orderHash\r\n             *  - 0x20: fulfiller\r\n             *  - 0x40: offer arr ptr (0x80)\r\n             *  - 0x60: consideration arr ptr (0x120)\r\n             *  - 0x80: offer arr len (1)\r\n             *  - 0xa0: offer.itemType\r\n             *  - 0xc0: offer.token\r\n             *  - 0xe0: offer.identifier\r\n             *  - 0x100: offer.amount\r\n             *  - 0x120: 1 + recipients.length\r\n             *  - 0x140: recipient 0\r\n             */\r\n\r\n            // Derive pointer to start of OrderFulfilled event data.\r\n            let eventDataPtr := add(\r\n                OrderFulfilled_baseOffset,\r\n                shl(\r\n                    OneWordShift,\r\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr)\r\n                )\r\n            )\r\n\r\n            // Write the order hash to the head of the event's data region.\r\n            mstore(eventDataPtr, orderHash)\r\n\r\n            // Write the fulfiller (i.e. the caller) next for receiver argument.\r\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\r\n\r\n            // Write the SpentItem and ReceivedItem array offsets (constants).\r\n            mstore(\r\n                // SpentItem array offset\r\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\r\n                OrderFulfilled_offer_body_offset\r\n            )\r\n            mstore(\r\n                // ReceivedItem array offset\r\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\r\n                OrderFulfilled_consideration_body_offset\r\n            )\r\n\r\n            // Derive total data size including SpentItem and ReceivedItem data.\r\n            // SpentItem portion is already included in the baseSize constant,\r\n            // as there can only be one element in the array.\r\n            let dataSize := add(\r\n                OrderFulfilled_baseSize,\r\n                mul(\r\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\r\n                    ReceivedItem_size\r\n                )\r\n            )\r\n\r\n            // Emit OrderFulfilled log with three topics (the event signature\r\n            // as well as the two indexed arguments, the offerer and the zone).\r\n            log3(\r\n                // Supply the pointer for event data in memory.\r\n                eventDataPtr,\r\n                // Supply the size of event data in memory.\r\n                dataSize,\r\n                // Supply the OrderFulfilled event signature.\r\n                OrderFulfilled_selector,\r\n                // Supply the first topic (the offerer).\r\n                calldataload(BasicOrder_offerer_cdPtr),\r\n                // Supply the second topic (the zone).\r\n                calldataload(BasicOrder_zone_cdPtr)\r\n            )\r\n\r\n            // Restore the zero slot.\r\n            mstore(ZeroSlot, 0)\r\n\r\n            // Update the free memory pointer so that event data is persisted.\r\n            mstore(FreeMemoryPointerSlot, add(eventDataPtr, dataSize))\r\n        }\r\n\r\n        // Verify and update the status of the derived order.\r\n        _validateBasicOrderAndUpdateStatus(orderHash, parameters.signature);\r\n\r\n        // Return the derived order hash.\r\n        return orderHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\r\n     *      from a given originator to a given recipient. The accumulator will\r\n     *      be bypassed, meaning that this function should be utilized in cases\r\n     *      where multiple item transfers can be accumulated into a single\r\n     *      conduit call. Sufficient approvals must be set, either on the\r\n     *      respective conduit or on this contract. Note that this function may\r\n     *      only be safely called as part of basic orders, as it assumes a\r\n     *      specific calldata encoding structure that must first be validated.\r\n     *\r\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\r\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\r\n     *                   if any, to source token approvals from. The zero hash\r\n     *                   signifies that no conduit should be used, with direct\r\n     *                   approvals set on this contract.\r\n     */\r\n    function _transferIndividual721Or1155Item(\r\n        ItemType itemType,\r\n        bytes32 conduitKey\r\n    ) internal {\r\n        // Retrieve token, from, identifier, and amount from calldata using\r\n        // fixed calldata offsets based on strict basic parameter encoding.\r\n        address token;\r\n        address from;\r\n        uint256 identifier;\r\n        uint256 amount;\r\n        assembly {\r\n            token := calldataload(BasicOrder_offerToken_cdPtr)\r\n            from := calldataload(BasicOrder_offerer_cdPtr)\r\n            identifier := calldataload(BasicOrder_offerIdentifier_cdPtr)\r\n            amount := calldataload(BasicOrder_offerAmount_cdPtr)\r\n        }\r\n\r\n        // Determine if the transfer is to be performed via a conduit.\r\n        if (conduitKey != bytes32(0)) {\r\n            // Use free memory pointer as calldata offset for the conduit call.\r\n            uint256 callDataOffset;\r\n\r\n            // Utilize assembly to place each argument in free memory.\r\n            assembly {\r\n                // Retrieve the free memory pointer and use it as the offset.\r\n                callDataOffset := mload(FreeMemoryPointerSlot)\r\n\r\n                // Write ConduitInterface.execute.selector to memory.\r\n                mstore(callDataOffset, Conduit_execute_signature)\r\n\r\n                // Write the offset to the ConduitTransfer array in memory.\r\n                mstore(\r\n                    add(\r\n                        callDataOffset,\r\n                        Conduit_execute_ConduitTransfer_offset_ptr\r\n                    ),\r\n                    Conduit_execute_ConduitTransfer_ptr\r\n                )\r\n\r\n                // Write the length of the ConduitTransfer array to memory.\r\n                mstore(\r\n                    add(\r\n                        callDataOffset,\r\n                        Conduit_execute_ConduitTransfer_length_ptr\r\n                    ),\r\n                    Conduit_execute_ConduitTransfer_length\r\n                )\r\n\r\n                // Write the item type to memory.\r\n                mstore(\r\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\r\n                    itemType\r\n                )\r\n\r\n                // Write the token to memory.\r\n                mstore(\r\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\r\n                    token\r\n                )\r\n\r\n                // Write the transfer source to memory.\r\n                mstore(\r\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\r\n                    from\r\n                )\r\n\r\n                // Write the transfer recipient (the caller) to memory.\r\n                mstore(\r\n                    add(callDataOffset, Conduit_execute_transferTo_ptr),\r\n                    caller()\r\n                )\r\n\r\n                // Write the token identifier to memory.\r\n                mstore(\r\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\r\n                    identifier\r\n                )\r\n\r\n                // Write the transfer amount to memory.\r\n                mstore(\r\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\r\n                    amount\r\n                )\r\n            }\r\n\r\n            // Perform the call to the conduit.\r\n            _callConduitUsingOffsets(\r\n                conduitKey,\r\n                callDataOffset,\r\n                OneConduitExecute_size\r\n            );\r\n        } else {\r\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\r\n            if (itemType == ItemType.ERC721) {\r\n                // Ensure that exactly one 721 item is being transferred.\r\n                if (amount != 1) {\r\n                    _revertInvalidERC721TransferAmount(amount);\r\n                }\r\n\r\n                // Perform transfer to caller via the token contract directly.\r\n                _performERC721Transfer(token, from, msg.sender, identifier);\r\n            } else {\r\n                // Perform transfer to caller via the token contract directly.\r\n                _performERC1155Transfer(\r\n                    token,\r\n                    from,\r\n                    msg.sender,\r\n                    identifier,\r\n                    amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer Ether (or other native tokens) to a\r\n     *      given recipient as part of basic order fulfillment. Note that\r\n     *      conduits are not utilized for native tokens as the transferred\r\n     *      amount must be provided as msg.value. Also note that this function\r\n     *      may only be safely called as part of basic orders, as it assumes a\r\n     *      specific calldata encoding structure that must first be validated.\r\n     */\r\n    function _transferNativeTokensAndFinalize() internal {\r\n        // Put native token value supplied by the caller on the stack.\r\n        uint256 nativeTokensRemaining = msg.value;\r\n\r\n        // Retrieve consideration amount, offerer, and total size of additional\r\n        // recipients data from calldata using fixed offsets and place on stack.\r\n        uint256 amount;\r\n        address payable to;\r\n        uint256 totalAdditionalRecipientsDataSize;\r\n        assembly {\r\n            amount := calldataload(BasicOrder_considerationAmount_cdPtr)\r\n            to := calldataload(BasicOrder_offerer_cdPtr)\r\n            totalAdditionalRecipientsDataSize := shl(\r\n                AdditionalRecipient_size_shift,\r\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr)\r\n            )\r\n        }\r\n\r\n        uint256 additionalRecipientAmount;\r\n        address payable recipient;\r\n\r\n        // Skip overflow check as for loop is indexed starting at zero.\r\n        unchecked {\r\n            // Iterate over additional recipient data by two-word element.\r\n            for (\r\n                uint256 i = 0;\r\n                i < totalAdditionalRecipientsDataSize;\r\n                i += AdditionalRecipient_size\r\n            ) {\r\n                assembly {\r\n                    // Retrieve calldata pointer for additional recipient.\r\n                    let additionalRecipientCdPtr := add(\r\n                        BasicOrder_additionalRecipients_data_cdPtr,\r\n                        i\r\n                    )\r\n\r\n                    additionalRecipientAmount := calldataload(\r\n                        additionalRecipientCdPtr\r\n                    )\r\n                    recipient := calldataload(\r\n                        add(OneWord, additionalRecipientCdPtr)\r\n                    )\r\n                }\r\n\r\n                // Ensure that sufficient native tokens are available.\r\n                if (additionalRecipientAmount > nativeTokensRemaining) {\r\n                    _revertInsufficientNativeTokensSupplied();\r\n                }\r\n\r\n                // Reduce native token value available. Skip underflow check as\r\n                // subtracted value is confirmed above as less than remaining.\r\n                nativeTokensRemaining -= additionalRecipientAmount;\r\n\r\n                // Transfer native tokens to the additional recipient.\r\n                _transferNativeTokens(recipient, additionalRecipientAmount);\r\n            }\r\n        }\r\n\r\n        // Ensure that sufficient native tokens are still available.\r\n        if (amount > nativeTokensRemaining) {\r\n            _revertInsufficientNativeTokensSupplied();\r\n        }\r\n\r\n        // Transfer native tokens to the offerer.\r\n        _transferNativeTokens(to, amount);\r\n\r\n        // If any native tokens remain after transfers, return to the caller.\r\n        if (nativeTokensRemaining > amount) {\r\n            // Skip underflow check as nativeTokensRemaining > amount.\r\n            unchecked {\r\n                // Transfer remaining native tokens to the caller.\r\n                _transferNativeTokens(\r\n                    payable(msg.sender),\r\n                    nativeTokensRemaining - amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\r\n     *      part of basic order fulfillment. Note that this function may only be\r\n     *      safely called as part of basic orders, as it assumes a specific\r\n     *      calldata encoding structure that must first be validated. Also note\r\n     *      that basic order parameters are retrieved using fixed offsets, this\r\n     *      requires that strict basic order encoding has already been verified.\r\n     *\r\n     * @param fromOfferer A boolean indicating whether to decrement amount from\r\n     *                    the offered amount.\r\n     * @param accumulator An open-ended array that collects transfers to execute\r\n     *                    against a given conduit in a single call.\r\n     */\r\n    function _transferERC20AndFinalize(\r\n        bool fromOfferer,\r\n        bytes memory accumulator\r\n    ) internal {\r\n        // Declare from and to variables determined by fromOfferer value.\r\n        address from;\r\n        address to;\r\n\r\n        // Declare token and amount variables determined by fromOfferer value.\r\n        address token;\r\n        uint256 amount;\r\n\r\n        // Declare and check identifier variable within an isolated scope.\r\n        {\r\n            // Declare identifier variable determined by fromOfferer value.\r\n            uint256 identifier;\r\n\r\n            // Set ERC20 token transfer variables based on fromOfferer boolean.\r\n            if (fromOfferer) {\r\n                // Use offerer as from value, msg.sender as to value, and offer\r\n                // token, identifier, & amount values if token is from offerer.\r\n                assembly {\r\n                    from := calldataload(BasicOrder_offerer_cdPtr)\r\n                    to := caller()\r\n                    token := calldataload(BasicOrder_offerToken_cdPtr)\r\n                    identifier := calldataload(BasicOrder_offerIdentifier_cdPtr)\r\n                    amount := calldataload(BasicOrder_offerAmount_cdPtr)\r\n                }\r\n            } else {\r\n                // Otherwise, use msg.sender as from value, offerer as to value,\r\n                // and consideration token, identifier, and amount values.\r\n                assembly {\r\n                    from := caller()\r\n                    to := calldataload(BasicOrder_offerer_cdPtr)\r\n                    token := calldataload(BasicOrder_considerationToken_cdPtr)\r\n                    identifier := calldataload(\r\n                        BasicOrder_considerationIdentifier_cdPtr\r\n                    )\r\n                    amount := calldataload(BasicOrder_considerationAmount_cdPtr)\r\n                }\r\n            }\r\n\r\n            // Ensure that no identifier is supplied.\r\n            if (identifier != 0) {\r\n                _revertUnusedItemParameters();\r\n            }\r\n        }\r\n\r\n        // Determine the appropriate conduit to utilize.\r\n        bytes32 conduitKey;\r\n\r\n        // Utilize assembly to derive conduit (if relevant) based on route.\r\n        assembly {\r\n            // Use offerer conduit if fromOfferer, fulfiller conduit otherwise.\r\n            conduitKey := calldataload(\r\n                sub(\r\n                    BasicOrder_fulfillerConduit_cdPtr,\r\n                    shl(OneWordShift, fromOfferer)\r\n                )\r\n            )\r\n        }\r\n\r\n        // Retrieve total size of additional recipients data and place on stack.\r\n        uint256 totalAdditionalRecipientsDataSize;\r\n        assembly {\r\n            totalAdditionalRecipientsDataSize := shl(\r\n                AdditionalRecipient_size_shift,\r\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr)\r\n            )\r\n        }\r\n\r\n        uint256 additionalRecipientAmount;\r\n        address recipient;\r\n\r\n        // Iterate over each additional recipient.\r\n        for (uint256 i = 0; i < totalAdditionalRecipientsDataSize; ) {\r\n            assembly {\r\n                // Retrieve calldata pointer for additional recipient.\r\n                let additionalRecipientCdPtr := add(\r\n                    BasicOrder_additionalRecipients_data_cdPtr,\r\n                    i\r\n                )\r\n\r\n                additionalRecipientAmount := calldataload(\r\n                    additionalRecipientCdPtr\r\n                )\r\n                recipient := calldataload(\r\n                    add(OneWord, additionalRecipientCdPtr)\r\n                )\r\n            }\r\n\r\n            // Decrement the amount to transfer to fulfiller if indicated.\r\n            if (fromOfferer) {\r\n                amount -= additionalRecipientAmount;\r\n            }\r\n\r\n            // Transfer ERC20 tokens to additional recipient given approval.\r\n            _transferERC20(\r\n                token,\r\n                from,\r\n                recipient,\r\n                additionalRecipientAmount,\r\n                conduitKey,\r\n                accumulator\r\n            );\r\n\r\n            // Skip overflow check as for loop is indexed starting at zero.\r\n            unchecked {\r\n                i += AdditionalRecipient_size;\r\n            }\r\n        }\r\n\r\n        // Transfer ERC20 token amount (from account must have proper approval).\r\n        _transferERC20(token, from, to, amount, conduitKey, accumulator);\r\n    }\r\n}\r\ninterface CriteriaResolutionErrors {\r\n    /**\r\n     * @dev Revert with an error when providing a criteria resolver that refers\r\n     *      to an order that has not been supplied.\r\n     *\r\n     * @param side The side of the order that was not supplied.\r\n     */\r\n    error OrderCriteriaResolverOutOfRange(Side side);\r\n\r\n    /**\r\n     * @dev Revert with an error if an offer item still has unresolved criteria\r\n     *      after applying all criteria resolvers.\r\n     *\r\n     * @param orderIndex The index of the order that contains the offer item.\r\n     * @param offerIndex The index of the offer item that still has unresolved\r\n     *                   criteria.\r\n     */\r\n    error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex);\r\n\r\n    /**\r\n     * @dev Revert with an error if a consideration item still has unresolved\r\n     *      criteria after applying all criteria resolvers.\r\n     *\r\n     * @param orderIndex         The index of the order that contains the\r\n     *                           consideration item.\r\n     * @param considerationIndex The index of the consideration item that still\r\n     *                           has unresolved criteria.\r\n     */\r\n    error UnresolvedConsiderationCriteria(\r\n        uint256 orderIndex,\r\n        uint256 considerationIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a criteria resolver that refers\r\n     *      to an order with an offer item that has not been supplied.\r\n     */\r\n    error OfferCriteriaResolverOutOfRange();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a criteria resolver that refers\r\n     *      to an order with a consideration item that has not been supplied.\r\n     */\r\n    error ConsiderationCriteriaResolverOutOfRange();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a criteria resolver that refers\r\n     *      to an order with an item that does not expect a criteria to be\r\n     *      resolved.\r\n     */\r\n    error CriteriaNotEnabledForItem();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a criteria resolver that\r\n     *      contains an invalid proof with respect to the given item and\r\n     *      chosen identifier.\r\n     */\r\n    error InvalidProof();\r\n}\r\n\r\ncontract CriteriaResolution is CriteriaResolutionErrors {\r\n    /**\r\n     * @dev Internal pure function to apply criteria resolvers containing\r\n     *      specific token identifiers and associated proofs to order items.\r\n     *\r\n     * @param advancedOrders     The orders to apply criteria resolvers to.\r\n     * @param criteriaResolvers  An array where each element contains a\r\n     *                           reference to a specific order as well as that\r\n     *                           order's offer or consideration, a token\r\n     *                           identifier, and a proof that the supplied token\r\n     *                           identifier is contained in the order's merkle\r\n     *                           root. Note that a root of zero indicates that\r\n     *                           any transferable token identifier is valid and\r\n     *                           that no proof needs to be supplied.\r\n     */\r\n    function _applyCriteriaResolvers(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        CriteriaResolver[] memory criteriaResolvers\r\n    ) internal pure {\r\n        // Skip overflow checks as all for loops are indexed starting at zero.\r\n        unchecked {\r\n            // Retrieve length of criteria resolvers array and place on stack.\r\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\r\n\r\n            // Retrieve length of orders array and place on stack.\r\n            uint256 totalAdvancedOrders = advancedOrders.length;\r\n\r\n            // Iterate over each criteria resolver.\r\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\r\n                // Retrieve the criteria resolver.\r\n                CriteriaResolver memory criteriaResolver = (\r\n                    criteriaResolvers[i]\r\n                );\r\n\r\n                // Read the order index from memory and place it on the stack.\r\n                uint256 orderIndex = criteriaResolver.orderIndex;\r\n\r\n                // Ensure that the order index is in range.\r\n                if (orderIndex >= totalAdvancedOrders) {\r\n                    _revertOrderCriteriaResolverOutOfRange(\r\n                        criteriaResolver.side\r\n                    );\r\n                }\r\n\r\n                // Retrieve the referenced advanced order.\r\n                AdvancedOrder memory advancedOrder = advancedOrders[orderIndex];\r\n\r\n                // Skip criteria resolution for order if not fulfilled.\r\n                if (advancedOrder.numerator == 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Retrieve the parameters for the order.\r\n                OrderParameters memory orderParameters = (\r\n                    advancedOrder.parameters\r\n                );\r\n\r\n                {\r\n                    // Get a pointer to the list of items to give to\r\n                    // _updateCriteriaItem. If the resolver refers to a\r\n                    // consideration item, this array pointer will be replaced\r\n                    // with the consideration array.\r\n                    OfferItem[] memory items = orderParameters.offer;\r\n\r\n                    // Read component index from memory and place it on stack.\r\n                    uint256 componentIndex = criteriaResolver.index;\r\n\r\n                    // Get error selector for `OfferCriteriaResolverOutOfRange`.\r\n                    uint256 errorSelector = (\r\n                        OfferCriteriaResolverOutOfRange_error_selector\r\n                    );\r\n\r\n                    // If the resolver refers to a consideration item...\r\n                    if (criteriaResolver.side != Side.OFFER) {\r\n                        // Get the pointer to `orderParameters.consideration`\r\n                        // Using the array directly has a significant impact on\r\n                        // the optimized compiler output.\r\n                        MemoryPointer considerationPtr = orderParameters\r\n                            .toMemoryPointer()\r\n                            .pptr(OrderParameters_consideration_head_offset);\r\n\r\n                        // Replace the items pointer with a pointer to the\r\n                        // consideration array.\r\n                        assembly {\r\n                            items := considerationPtr\r\n                        }\r\n\r\n                        // Replace the error selector with the selector for\r\n                        // `ConsiderationCriteriaResolverOutOfRange`.\r\n                        errorSelector = (\r\n                            ConsiderationCriteriaResolverOutOfRange_err_selector\r\n                        );\r\n                    }\r\n\r\n                    // Ensure that the component index is in range.\r\n                    if (componentIndex >= items.length) {\r\n                        assembly {\r\n                            // Revert with either\r\n                            // `OfferCriteriaResolverOutOfRange()` or\r\n                            // `ConsiderationCriteriaResolverOutOfRange()`,\r\n                            // depending on whether the resolver refers to a\r\n                            // consideration item.\r\n                            mstore(0, errorSelector)\r\n                            // revert(abi.encodeWithSignature(\r\n                            //    \"OfferCriteriaResolverOutOfRange()\"\r\n                            // ))\r\n                            // or\r\n                            // revert(abi.encodeWithSignature(\r\n                            //    \"ConsiderationCriteriaResolverOutOfRange()\"\r\n                            // ))\r\n                            revert(Error_selector_offset, Selector_length)\r\n                        }\r\n                    }\r\n\r\n                    // Apply the criteria resolver to the item in question.\r\n                    _updateCriteriaItem(\r\n                        items,\r\n                        componentIndex,\r\n                        criteriaResolver\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Iterate over each advanced order.\r\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\r\n                // Retrieve the advanced order.\r\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\r\n\r\n                // Skip criteria resolution for order if not fulfilled.\r\n                if (advancedOrder.numerator == 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Retrieve the parameters for the order.\r\n                OrderParameters memory orderParameters = (\r\n                    advancedOrder.parameters\r\n                );\r\n\r\n                // Read consideration length from memory and place on stack.\r\n                uint256 totalItems = orderParameters.consideration.length;\r\n\r\n                // Iterate over each consideration item on the order.\r\n                for (uint256 j = 0; j < totalItems; ++j) {\r\n                    // Ensure item type no longer indicates criteria usage.\r\n                    if (\r\n                        _isItemWithCriteria(\r\n                            orderParameters.consideration[j].itemType\r\n                        )\r\n                    ) {\r\n                        _revertUnresolvedConsiderationCriteria(i, j);\r\n                    }\r\n                }\r\n\r\n                // Read offer length from memory and place on stack.\r\n                totalItems = orderParameters.offer.length;\r\n\r\n                // Iterate over each offer item on the order.\r\n                for (uint256 j = 0; j < totalItems; ++j) {\r\n                    // Ensure item type no longer indicates criteria usage.\r\n                    if (\r\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\r\n                    ) {\r\n                        _revertUnresolvedOfferCriteria(i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to update a criteria item.\r\n     *\r\n     * @param offer             The offer containing the item to update.\r\n     * @param componentIndex    The index of the item to update.\r\n     * @param criteriaResolver  The criteria resolver to use to update the item.\r\n     */\r\n    function _updateCriteriaItem(\r\n        OfferItem[] memory offer,\r\n        uint256 componentIndex,\r\n        CriteriaResolver memory criteriaResolver\r\n    ) internal pure {\r\n        // Retrieve relevant item using the component index.\r\n        OfferItem memory offerItem = offer[componentIndex];\r\n\r\n        // Read item type and criteria from memory & place on stack.\r\n        ItemType itemType = offerItem.itemType;\r\n\r\n        // Ensure the specified item type indicates criteria usage.\r\n        if (!_isItemWithCriteria(itemType)) {\r\n            _revertCriteriaNotEnabledForItem();\r\n        }\r\n\r\n        uint256 identifierOrCriteria = offerItem.identifierOrCriteria;\r\n\r\n        // If criteria is not 0 (i.e. a collection-wide criteria-based item)...\r\n        if (identifierOrCriteria != uint256(0)) {\r\n            // Verify identifier inclusion in criteria root using proof.\r\n            _verifyProof(\r\n                criteriaResolver.identifier,\r\n                identifierOrCriteria,\r\n                criteriaResolver.criteriaProof\r\n            );\r\n        } else if (criteriaResolver.criteriaProof.length != 0) {\r\n            // Revert if non-empty proof is supplied for a collection-wide item.\r\n            _revertInvalidProof();\r\n        }\r\n\r\n        // Update item type to remove criteria usage.\r\n        // Use assembly to operate on ItemType enum as a number.\r\n        ItemType newItemType;\r\n        assembly {\r\n            // Item type 4 becomes 2 and item type 5 becomes 3.\r\n            newItemType := sub(3, eq(itemType, 4))\r\n        }\r\n        offerItem.itemType = newItemType;\r\n\r\n        // Update identifier w/ supplied identifier.\r\n        offerItem.identifierOrCriteria = criteriaResolver.identifier;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to check whether a given item type represents\r\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\r\n     *      resolved to one of a number of different identifiers at the time of\r\n     *      order fulfillment).\r\n     *\r\n     * @param itemType The item type in question.\r\n     *\r\n     * @return withCriteria A boolean indicating that the item type in question\r\n     *                      represents a criteria-based item.\r\n     */\r\n    function _isItemWithCriteria(\r\n        ItemType itemType\r\n    ) internal pure returns (bool withCriteria) {\r\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\r\n        assembly {\r\n            withCriteria := gt(itemType, 3)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to ensure that a given element is contained\r\n     *      in a merkle root via a supplied proof.\r\n     *\r\n     * @param leaf  The element for which to prove inclusion.\r\n     * @param root  The merkle root that inclusion will be proved against.\r\n     * @param proof The merkle proof.\r\n     */\r\n    function _verifyProof(\r\n        uint256 leaf,\r\n        uint256 root,\r\n        bytes32[] memory proof\r\n    ) internal pure {\r\n        // Declare a variable that will be used to determine proof validity.\r\n        bool isValid;\r\n\r\n        // Utilize assembly to efficiently verify the proof against the root.\r\n        assembly {\r\n            // Store the leaf at the beginning of scratch space.\r\n            mstore(0, leaf)\r\n\r\n            // Derive the hash of the leaf to use as the initial proof element.\r\n            let computedHash := keccak256(0, OneWord)\r\n\r\n            // Get memory start location of the first element in proof array.\r\n            let data := add(proof, OneWord)\r\n\r\n            // Iterate over each proof element to compute the root hash.\r\n            for {\r\n                // Left shift by 5 is equivalent to multiplying by 0x20.\r\n                let end := add(data, shl(OneWordShift, mload(proof)))\r\n            } lt(data, end) {\r\n                // Increment by one word at a time.\r\n                data := add(data, OneWord)\r\n            } {\r\n                // Get the proof element.\r\n                let loadedData := mload(data)\r\n\r\n                // Sort proof elements and place them in scratch space.\r\n                // Slot of `computedHash` in scratch space.\r\n                // If the condition is true: 0x20, otherwise: 0x00.\r\n                let scratch := shl(OneWordShift, gt(computedHash, loadedData))\r\n\r\n                // Store elements to hash contiguously in scratch space. Scratch\r\n                // space is 64 bytes (0x00 - 0x3f) & both elements are 32 bytes.\r\n                mstore(scratch, computedHash)\r\n                mstore(xor(scratch, OneWord), loadedData)\r\n\r\n                // Derive the updated hash.\r\n                computedHash := keccak256(0, TwoWords)\r\n            }\r\n\r\n            // Compare the final hash to the supplied root.\r\n            isValid := eq(computedHash, root)\r\n        }\r\n\r\n        // Revert if computed hash does not equal supplied root.\r\n        if (!isValid) {\r\n            _revertInvalidProof();\r\n        }\r\n    }\r\n}\r\ninterface AmountDerivationErrors {\r\n    /**\r\n     * @dev Revert with an error when attempting to apply a fraction as part of\r\n     *      a partial fill that does not divide the target amount cleanly.\r\n     */\r\n    error InexactFraction();\r\n}\r\ncontract AmountDeriver is AmountDerivationErrors {\r\n    /**\r\n     * @dev Internal view function to derive the current amount of a given item\r\n     *      based on the current price, the starting price, and the ending\r\n     *      price. If the start and end prices differ, the current price will be\r\n     *      interpolated on a linear basis. Note that this function expects that\r\n     *      the startTime parameter of orderParameters is not greater than the\r\n     *      current block timestamp and that the endTime parameter is greater\r\n     *      than the current block timestamp. If this condition is not upheld,\r\n     *      duration / elapsed / remaining variables will underflow.\r\n     *\r\n     * @param startAmount The starting amount of the item.\r\n     * @param endAmount   The ending amount of the item.\r\n     * @param startTime   The starting time of the order.\r\n     * @param endTime     The end time of the order.\r\n     * @param roundUp     A boolean indicating whether the resultant amount\r\n     *                    should be rounded up or down.\r\n     *\r\n     * @return amount The current amount.\r\n     */\r\n    function _locateCurrentAmount(\r\n        uint256 startAmount,\r\n        uint256 endAmount,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool roundUp\r\n    ) internal view returns (uint256 amount) {\r\n        // Only modify end amount if it doesn't already equal start amount.\r\n        if (startAmount != endAmount) {\r\n            // Declare variables to derive in the subsequent unchecked scope.\r\n            uint256 duration;\r\n            uint256 elapsed;\r\n            uint256 remaining;\r\n\r\n            // Skip underflow checks as startTime <= block.timestamp < endTime.\r\n            unchecked {\r\n                // Derive the duration for the order and place it on the stack.\r\n                duration = endTime - startTime;\r\n\r\n                // Derive time elapsed since the order started & place on stack.\r\n                elapsed = block.timestamp - startTime;\r\n\r\n                // Derive time remaining until order expires and place on stack.\r\n                remaining = duration - elapsed;\r\n            }\r\n\r\n            // Aggregate new amounts weighted by time with rounding factor.\r\n            uint256 totalBeforeDivision = ((startAmount * remaining) +\r\n                (endAmount * elapsed));\r\n\r\n            // Use assembly to combine operations and skip divide-by-zero check.\r\n            assembly {\r\n                // Multiply by iszero(iszero(totalBeforeDivision)) to ensure\r\n                // amount is set to zero if totalBeforeDivision is zero,\r\n                // as intermediate overflow can occur if it is zero.\r\n                amount := mul(\r\n                    iszero(iszero(totalBeforeDivision)),\r\n                    // Subtract 1 from the numerator and add 1 to the result if\r\n                    // roundUp is true to get the proper rounding direction.\r\n                    // Division is performed with no zero check as duration\r\n                    // cannot be zero as long as startTime < endTime.\r\n                    add(\r\n                        div(sub(totalBeforeDivision, roundUp), duration),\r\n                        roundUp\r\n                    )\r\n                )\r\n            }\r\n\r\n            // Return the current amount.\r\n            return amount;\r\n        }\r\n\r\n        // Return the original amount as startAmount == endAmount.\r\n        return endAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to return a fraction of a given value and to\r\n     *      ensure the resultant value does not have any fractional component.\r\n     *      Note that this function assumes that zero will never be supplied as\r\n     *      the denominator parameter; invalid / undefined behavior will result\r\n     *      should a denominator of zero be provided.\r\n     *\r\n     * @param numerator   A value indicating the portion of the order that\r\n     *                    should be filled.\r\n     * @param denominator A value indicating the total size of the order. Note\r\n     *                    that this value cannot be equal to zero.\r\n     * @param value       The value for which to compute the fraction.\r\n     *\r\n     * @return newValue The value after applying the fraction.\r\n     */\r\n    function _getFraction(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 value\r\n    ) internal pure returns (uint256 newValue) {\r\n        // Return value early in cases where the fraction resolves to 1.\r\n        if (numerator == denominator) {\r\n            return value;\r\n        }\r\n\r\n        // Ensure fraction can be applied to the value with no remainder. Note\r\n        // that the denominator cannot be zero.\r\n        assembly {\r\n            // Ensure new value contains no remainder via mulmod operator.\r\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\r\n            if mulmod(value, numerator, denominator) {\r\n                // Store left-padded selector with push4, mem[28:32] = selector\r\n                mstore(0, InexactFraction_error_selector)\r\n\r\n                // revert(abi.encodeWithSignature(\"InexactFraction()\"))\r\n                revert(Error_selector_offset, InexactFraction_error_length)\r\n            }\r\n        }\r\n\r\n        // Multiply the numerator by the value and ensure no overflow occurs.\r\n        uint256 valueTimesNumerator = value * numerator;\r\n\r\n        // Divide and check for remainder. Note that denominator cannot be zero.\r\n        assembly {\r\n            // Perform division without zero check.\r\n            newValue := div(valueTimesNumerator, denominator)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to apply a fraction to a consideration\r\n     * or offer item.\r\n     *\r\n     * @param startAmount     The starting amount of the item.\r\n     * @param endAmount       The ending amount of the item.\r\n     * @param numerator       A value indicating the portion of the order that\r\n     *                        should be filled.\r\n     * @param denominator     A value indicating the total size of the order.\r\n     * @param startTime       The starting time of the order.\r\n     * @param endTime         The end time of the order.\r\n     * @param roundUp         A boolean indicating whether the resultant\r\n     *                        amount should be rounded up or down.\r\n     *\r\n     * @return amount The received item to transfer with the final amount.\r\n     */\r\n    function _applyFraction(\r\n        uint256 startAmount,\r\n        uint256 endAmount,\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool roundUp\r\n    ) internal view returns (uint256 amount) {\r\n        // If start amount equals end amount, apply fraction to end amount.\r\n        if (startAmount == endAmount) {\r\n            // Apply fraction to end amount.\r\n            amount = _getFraction(numerator, denominator, endAmount);\r\n        } else {\r\n            // Otherwise, apply fraction to both and interpolated final amount.\r\n            amount = _locateCurrentAmount(\r\n                _getFraction(numerator, denominator, startAmount),\r\n                _getFraction(numerator, denominator, endAmount),\r\n                startTime,\r\n                endTime,\r\n                roundUp\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ncontract OrderFulfiller is\r\n    BasicOrderFulfiller,\r\n    CriteriaResolution,\r\n    AmountDeriver\r\n{\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(\r\n        address conduitController\r\n    ) BasicOrderFulfiller(conduitController) {}\r\n\r\n    /**\r\n     * @dev Internal function to validate an order and update its status, adjust\r\n     *      prices based on current time, apply criteria resolvers, determine\r\n     *      what portion to fill, and transfer relevant tokens.\r\n     *\r\n     * @param advancedOrder       The order to fulfill as well as the fraction\r\n     *                            to fill. Note that all offer and consideration\r\n     *                            components must divide with no remainder for\r\n     *                            the partial fill to be valid.\r\n     * @param criteriaResolvers   An array where each element contains a\r\n     *                            reference to a specific offer or\r\n     *                            consideration, a token identifier, and a proof\r\n     *                            that the supplied token identifier is\r\n     *                            contained in the order's merkle root. Note\r\n     *                            that a criteria of zero indicates that any\r\n     *                            (transferable) token identifier is valid and\r\n     *                            that no proof needs to be supplied.\r\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\r\n     *                            any, to source the fulfiller's token approvals\r\n     *                            from. The zero hash signifies that no conduit\r\n     *                            should be used, with direct approvals set on\r\n     *                            Consideration.\r\n     * @param recipient           The intended recipient for all received items.\r\n     *\r\n     * @return A boolean indicating whether the order has been fulfilled.\r\n     */\r\n    function _validateAndFulfillAdvancedOrder(\r\n        AdvancedOrder memory advancedOrder,\r\n        CriteriaResolver[] memory criteriaResolvers,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient\r\n    ) internal returns (bool) {\r\n        // Ensure this function cannot be triggered during a reentrant call.\r\n        _setReentrancyGuard(\r\n            // Native tokens accepted during execution for contract order types.\r\n            advancedOrder.parameters.orderType == OrderType.CONTRACT\r\n        );\r\n\r\n        // Validate order, update status, and determine fraction to fill.\r\n        (\r\n            bytes32 orderHash,\r\n            uint256 fillNumerator,\r\n            uint256 fillDenominator\r\n        ) = _validateOrderAndUpdateStatus(advancedOrder, true);\r\n\r\n        // Create an array with length 1 containing the order.\r\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\r\n\r\n        // Populate the order as the first and only element of the new array.\r\n        advancedOrders[0] = advancedOrder;\r\n\r\n        // Apply criteria resolvers using generated orders and details arrays.\r\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\r\n\r\n        // Retrieve the order parameters after applying criteria resolvers.\r\n        OrderParameters memory orderParameters = advancedOrders[0].parameters;\r\n\r\n        // Perform each item transfer with the appropriate fractional amount.\r\n        _applyFractionsAndTransferEach(\r\n            orderParameters,\r\n            fillNumerator,\r\n            fillDenominator,\r\n            fulfillerConduitKey,\r\n            recipient\r\n        );\r\n\r\n        // Declare empty bytes32 array and populate with the order hash.\r\n        bytes32[] memory orderHashes = new bytes32[](1);\r\n        orderHashes[0] = orderHash;\r\n\r\n        // Ensure restricted orders have a valid submitter or pass a zone check.\r\n        _assertRestrictedAdvancedOrderValidity(\r\n            advancedOrders[0],\r\n            orderHashes,\r\n            orderHash\r\n        );\r\n\r\n        // Emit an event signifying that the order has been fulfilled.\r\n        _emitOrderFulfilledEvent(\r\n            orderHash,\r\n            orderParameters.offerer,\r\n            orderParameters.zone,\r\n            recipient,\r\n            orderParameters.offer,\r\n            orderParameters.consideration\r\n        );\r\n\r\n        // Clear the reentrancy guard.\r\n        _clearReentrancyGuard();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer each item contained in a given single\r\n     *      order fulfillment after applying a respective fraction to the amount\r\n     *      being transferred.\r\n     *\r\n     * @param orderParameters     The parameters for the fulfilled order.\r\n     * @param numerator           A value indicating the portion of the order\r\n     *                            that should be filled.\r\n     * @param denominator         A value indicating the total order size.\r\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\r\n     *                            any, to source the fulfiller's token approvals\r\n     *                            from. The zero hash signifies that no conduit\r\n     *                            should be used, with direct approvals set on\r\n     *                            Consideration.\r\n     * @param recipient           The intended recipient for all received items.\r\n     */\r\n    function _applyFractionsAndTransferEach(\r\n        OrderParameters memory orderParameters,\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient\r\n    ) internal {\r\n        // Read start time & end time from order parameters and place on stack.\r\n        uint256 startTime = orderParameters.startTime;\r\n        uint256 endTime = orderParameters.endTime;\r\n\r\n        // Initialize an accumulator array. From this point forward, no new\r\n        // memory regions can be safely allocated until the accumulator is no\r\n        // longer being utilized, as the accumulator operates in an open-ended\r\n        // fashion from this memory pointer; existing memory may still be\r\n        // accessed and modified, however.\r\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\r\n\r\n        // As of solidity 0.6.0, inline assembly cannot directly access function\r\n        // definitions, but can still access locally scoped function variables.\r\n        // This means that a local variable to reference the internal function\r\n        // definition (using the same type), along with a local variable with\r\n        // the desired type, must first be created. Then, the original function\r\n        // pointer can be recast to the desired type.\r\n\r\n        /**\r\n         * Repurpose existing OfferItem memory regions on the offer array for\r\n         * the order by overriding the _transfer function pointer to accept a\r\n         * modified OfferItem argument in place of the usual ReceivedItem:\r\n         *\r\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\r\n         *   ItemType itemType; ------------> ItemType itemType;\r\n         *   address token; ----------------> address token;\r\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\r\n         *   uint256 startAmount; ----------> uint256 amount;\r\n         *   uint256 endAmount; ------------> address recipient;\r\n         */\r\n\r\n        // Declare a nested scope to minimize stack depth.\r\n        unchecked {\r\n            // Read offer array length from memory and place on stack.\r\n            uint256 totalOfferItems = orderParameters.offer.length;\r\n\r\n            // Create a variable to indicate whether the order has any\r\n            // native offer items\r\n            uint256 anyNativeItems;\r\n\r\n            // Iterate over each offer on the order.\r\n            // Skip overflow check as for loop is indexed starting at zero.\r\n            for (uint256 i = 0; i < totalOfferItems; ++i) {\r\n                // Retrieve the offer item.\r\n                OfferItem memory offerItem = orderParameters.offer[i];\r\n\r\n                // Offer items for the native token can not be received outside\r\n                // of a match order function except as part of a contract order.\r\n                {\r\n                    ItemType itemType = offerItem.itemType;\r\n                    assembly {\r\n                        anyNativeItems := or(anyNativeItems, iszero(itemType))\r\n                    }\r\n                }\r\n\r\n                // Declare an additional nested scope to minimize stack depth.\r\n                {\r\n                    // Apply fill fraction to get offer item amount to transfer.\r\n                    uint256 amount = _applyFraction(\r\n                        offerItem.startAmount,\r\n                        offerItem.endAmount,\r\n                        numerator,\r\n                        denominator,\r\n                        startTime,\r\n                        endTime,\r\n                        false\r\n                    );\r\n\r\n                    // Utilize assembly to set overloaded offerItem arguments.\r\n                    assembly {\r\n                        // Write new fractional amount to startAmount as amount.\r\n                        mstore(\r\n                            add(offerItem, ReceivedItem_amount_offset),\r\n                            amount\r\n                        )\r\n\r\n                        // Write recipient to endAmount.\r\n                        mstore(\r\n                            add(offerItem, ReceivedItem_recipient_offset),\r\n                            recipient\r\n                        )\r\n                    }\r\n                }\r\n\r\n                // Transfer the item from the offerer to the recipient.\r\n                _toOfferItemInput(_transfer)(\r\n                    offerItem,\r\n                    orderParameters.offerer,\r\n                    orderParameters.conduitKey,\r\n                    accumulator\r\n                );\r\n            }\r\n\r\n            // If a non-contract order has native offer items, throw with an\r\n            // `InvalidNativeOfferItem` custom error.\r\n            {\r\n                OrderType orderType = orderParameters.orderType;\r\n                uint256 invalidNativeOfferItem;\r\n                assembly {\r\n                    invalidNativeOfferItem := and(\r\n                        // Note that this check requires that there are no order\r\n                        // types beyond the current set (0-4).  It will need to\r\n                        // be modified if more order types are added.\r\n                        lt(orderType, 4),\r\n                        anyNativeItems\r\n                    )\r\n                }\r\n                if (invalidNativeOfferItem != 0) {\r\n                    _revertInvalidNativeOfferItem();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Declare a variable for the available native token balance.\r\n        uint256 nativeTokenBalance;\r\n\r\n        /**\r\n         * Repurpose existing ConsiderationItem memory regions on the\r\n         * consideration array for the order by overriding the _transfer\r\n         * function pointer to accept a modified ConsiderationItem argument in\r\n         * place of the usual ReceivedItem:\r\n         *\r\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\r\n         *   ItemType itemType; ------------> ItemType itemType;\r\n         *   address token; ----------------> address token;\r\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\r\n         *   uint256 startAmount; ----------> uint256 amount;\r\n         *   uint256 endAmount;        /----> address recipient;\r\n         *   address recipient; ------/\r\n         */\r\n\r\n        // Declare a nested scope to minimize stack depth.\r\n        unchecked {\r\n            // Read consideration array length from memory and place on stack.\r\n            uint256 totalConsiderationItems = orderParameters\r\n                .consideration\r\n                .length;\r\n\r\n            // Iterate over each consideration item on the order.\r\n            // Skip overflow check as for loop is indexed starting at zero.\r\n            for (uint256 i = 0; i < totalConsiderationItems; ++i) {\r\n                // Retrieve the consideration item.\r\n                ConsiderationItem memory considerationItem = (\r\n                    orderParameters.consideration[i]\r\n                );\r\n\r\n                // Apply fraction & derive considerationItem amount to transfer.\r\n                uint256 amount = _applyFraction(\r\n                    considerationItem.startAmount,\r\n                    considerationItem.endAmount,\r\n                    numerator,\r\n                    denominator,\r\n                    startTime,\r\n                    endTime,\r\n                    true\r\n                );\r\n\r\n                // Use assembly to set overloaded considerationItem arguments.\r\n                assembly {\r\n                    // Write derived fractional amount to startAmount as amount.\r\n                    mstore(\r\n                        add(considerationItem, ReceivedItem_amount_offset),\r\n                        amount\r\n                    )\r\n\r\n                    // Write original recipient to endAmount as recipient.\r\n                    mstore(\r\n                        add(considerationItem, ReceivedItem_recipient_offset),\r\n                        mload(\r\n                            add(\r\n                                considerationItem,\r\n                                ConsiderationItem_recipient_offset\r\n                            )\r\n                        )\r\n                    )\r\n                }\r\n\r\n                // Reduce available value if offer spent ETH or a native token.\r\n                if (considerationItem.itemType == ItemType.NATIVE) {\r\n                    // Get the current available balance of native tokens.\r\n                    assembly {\r\n                        nativeTokenBalance := selfbalance()\r\n                    }\r\n\r\n                    // Ensure that sufficient native tokens are still available.\r\n                    if (amount > nativeTokenBalance) {\r\n                        _revertInsufficientNativeTokensSupplied();\r\n                    }\r\n                }\r\n\r\n                // Transfer item from caller to recipient specified by the item.\r\n                _toConsiderationItemInput(_transfer)(\r\n                    considerationItem,\r\n                    msg.sender,\r\n                    fulfillerConduitKey,\r\n                    accumulator\r\n                );\r\n            }\r\n        }\r\n\r\n        // Trigger any remaining accumulated transfers via call to the conduit.\r\n        _triggerIfArmed(accumulator);\r\n\r\n        // Determine whether any native token balance remains.\r\n        assembly {\r\n            nativeTokenBalance := selfbalance()\r\n        }\r\n\r\n        // Return any remaining native token balance to the caller.\r\n        if (nativeTokenBalance != 0) {\r\n            _transferNativeTokens(payable(msg.sender), nativeTokenBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\r\n     *      translated into SpentItems and ConsiderationItems are translated\r\n     *      into ReceivedItems.\r\n     *\r\n     * @param orderHash     The order hash.\r\n     * @param offerer       The offerer for the order.\r\n     * @param zone          The zone for the order.\r\n     * @param recipient     The recipient of the order, or the null address if\r\n     *                      the order was fulfilled via order matching.\r\n     * @param offer         The offer items for the order.\r\n     * @param consideration The consideration items for the order.\r\n     */\r\n    function _emitOrderFulfilledEvent(\r\n        bytes32 orderHash,\r\n        address offerer,\r\n        address zone,\r\n        address recipient,\r\n        OfferItem[] memory offer,\r\n        ConsiderationItem[] memory consideration\r\n    ) internal {\r\n        // Cast already-modified offer memory region as spent items.\r\n        SpentItem[] memory spentItems;\r\n        assembly {\r\n            spentItems := offer\r\n        }\r\n\r\n        // Cast already-modified consideration memory region as received items.\r\n        ReceivedItem[] memory receivedItems;\r\n        assembly {\r\n            receivedItems := consideration\r\n        }\r\n\r\n        // Emit an event signifying that the order has been fulfilled.\r\n        emit OrderFulfilled(\r\n            orderHash,\r\n            offerer,\r\n            zone,\r\n            recipient,\r\n            spentItems,\r\n            receivedItems\r\n        );\r\n    }\r\n}\r\ninterface FulfillmentApplicationErrors {\r\n    /**\r\n     * @dev Revert with an error when a fulfillment is provided that does not\r\n     *      declare at least one component as part of a call to fulfill\r\n     *      available orders.\r\n     */\r\n    error MissingFulfillmentComponentOnAggregation(Side side);\r\n\r\n    /**\r\n     * @dev Revert with an error when a fulfillment is provided that does not\r\n     *      declare at least one offer component and at least one consideration\r\n     *      component.\r\n     */\r\n    error OfferAndConsiderationRequiredOnFulfillment();\r\n\r\n    /**\r\n     * @dev Revert with an error when the initial offer item named by a\r\n     *      fulfillment component does not match the type, token, identifier,\r\n     *      or conduit preference of the initial consideration item.\r\n     *\r\n     * @param fulfillmentIndex The index of the fulfillment component that\r\n     *                         does not match the initial offer item.\r\n     */\r\n    error MismatchedFulfillmentOfferAndConsiderationComponents(\r\n        uint256 fulfillmentIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when an order or item index are out of range\r\n     *      or a fulfillment component does not match the type, token,\r\n     *      identifier, or conduit preference of the initial consideration item.\r\n     */\r\n    error InvalidFulfillmentComponentData();\r\n}\r\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\r\n    /**\r\n     * @dev Internal pure function to match offer items to consideration items\r\n     *      on a group of orders via a supplied fulfillment.\r\n     *\r\n     * @param advancedOrders          The orders to match.\r\n     * @param offerComponents         An array designating offer components to\r\n     *                                match to consideration components.\r\n     * @param considerationComponents An array designating consideration\r\n     *                                components to match to offer components.\r\n     *                                Note that each consideration amount must\r\n     *                                be zero in order for the match operation\r\n     *                                to be valid.\r\n     * @param fulfillmentIndex        The index of the fulfillment being\r\n     *                                applied.\r\n     *\r\n     * @return execution The transfer performed as a result of the fulfillment.\r\n     */\r\n    function _applyFulfillment(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        FulfillmentComponent[] memory offerComponents,\r\n        FulfillmentComponent[] memory considerationComponents,\r\n        uint256 fulfillmentIndex\r\n    ) internal pure returns (Execution memory execution) {\r\n        // Ensure 1+ of both offer and consideration components are supplied.\r\n        if (\r\n            offerComponents.length == 0 || considerationComponents.length == 0\r\n        ) {\r\n            _revertOfferAndConsiderationRequiredOnFulfillment();\r\n        }\r\n\r\n        // Declare a new Execution struct.\r\n        Execution memory considerationExecution;\r\n\r\n        // Validate & aggregate consideration items to new Execution object.\r\n        _aggregateValidFulfillmentConsiderationItems(\r\n            advancedOrders,\r\n            considerationComponents,\r\n            considerationExecution\r\n        );\r\n\r\n        // Retrieve the consideration item from the execution struct.\r\n        ReceivedItem memory considerationItem = considerationExecution.item;\r\n\r\n        // Skip aggregating offer items if no consideration items are available.\r\n        if (considerationItem.amount == 0) {\r\n            // Set the offerer and recipient to null address and the item type\r\n            // to a non-native item type if the execution amount is zero. This\r\n            // will cause the execution item to be skipped.\r\n            considerationExecution.offerer = address(0);\r\n            considerationExecution.item.recipient = payable(0);\r\n            considerationExecution.item.itemType = ItemType.ERC20;\r\n            return considerationExecution;\r\n        }\r\n\r\n        // Recipient does not need to be specified because it will always be set\r\n        // to that of the consideration.\r\n        // Validate & aggregate offer items to Execution object.\r\n        _aggregateValidFulfillmentOfferItems(\r\n            advancedOrders,\r\n            offerComponents,\r\n            execution\r\n        );\r\n\r\n        // Ensure offer & consideration item types, tokens, & identifiers match.\r\n        // (a != b || c != d || e != f) == (((a ^ b) | (c ^ d) | (e ^ f)) != 0),\r\n        // but the second expression requires less gas to evaluate.\r\n        if (\r\n            ((uint8(execution.item.itemType) ^\r\n                uint8(considerationItem.itemType)) |\r\n                (uint160(execution.item.token) ^\r\n                    uint160(considerationItem.token)) |\r\n                (execution.item.identifier ^ considerationItem.identifier)) != 0\r\n        ) {\r\n            _revertMismatchedFulfillmentOfferAndConsiderationComponents(\r\n                fulfillmentIndex\r\n            );\r\n        }\r\n\r\n        // If total consideration amount exceeds the offer amount...\r\n        if (considerationItem.amount > execution.item.amount) {\r\n            // Retrieve the first consideration component from the fulfillment.\r\n            FulfillmentComponent memory targetComponent = (\r\n                considerationComponents[0]\r\n            );\r\n\r\n            // Skip underflow check as the conditional being true implies that\r\n            // considerationItem.amount > execution.item.amount.\r\n            unchecked {\r\n                // Add excess consideration item amount to original order array.\r\n                advancedOrders[targetComponent.orderIndex]\r\n                    .parameters\r\n                    .consideration[targetComponent.itemIndex]\r\n                    .startAmount = (considerationItem.amount -\r\n                    execution.item.amount);\r\n            }\r\n        } else {\r\n            // Retrieve the first offer component from the fulfillment.\r\n            FulfillmentComponent memory targetComponent = offerComponents[0];\r\n\r\n            // Skip underflow check as the conditional being false implies that\r\n            // execution.item.amount >= considerationItem.amount.\r\n            unchecked {\r\n                // Add excess offer item amount to the original array of orders.\r\n                advancedOrders[targetComponent.orderIndex]\r\n                    .parameters\r\n                    .offer[targetComponent.itemIndex]\r\n                    .startAmount = (execution.item.amount -\r\n                    considerationItem.amount);\r\n            }\r\n\r\n            // Reduce total offer amount to equal the consideration amount.\r\n            execution.item.amount = considerationItem.amount;\r\n        }\r\n\r\n        // Reuse consideration recipient.\r\n        execution.item.recipient = considerationItem.recipient;\r\n\r\n        // Return the final execution that will be triggered for relevant items.\r\n        return execution; // Execution(considerationItem, offerer, conduitKey);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to aggregate offer or consideration items\r\n     *      from a group of orders into a single execution via a supplied array\r\n     *      of fulfillment components. Items that are not available to aggregate\r\n     *      will not be included in the aggregated execution.\r\n     *\r\n     * @param advancedOrders        The orders to aggregate.\r\n     * @param side                  The side (i.e. offer or consideration).\r\n     * @param fulfillmentComponents An array designating item components to\r\n     *                              aggregate if part of an available order.\r\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\r\n     *                              any, to source the fulfiller's token\r\n     *                              approvals from. The zero hash signifies that\r\n     *                              no conduit should be used, with approvals\r\n     *                              set directly on this contract.\r\n     * @param recipient             The intended recipient for all received\r\n     *                              items.\r\n     *\r\n     * @return execution The transfer performed as a result of the fulfillment.\r\n     */\r\n    function _aggregateAvailable(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        Side side,\r\n        FulfillmentComponent[] memory fulfillmentComponents,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient\r\n    ) internal view returns (Execution memory execution) {\r\n        // Skip overflow / underflow checks; conditions checked or unreachable.\r\n        unchecked {\r\n            // Retrieve fulfillment components array length and place on stack.\r\n            // Ensure at least one fulfillment component has been supplied.\r\n            if (fulfillmentComponents.length == 0) {\r\n                _revertMissingFulfillmentComponentOnAggregation(side);\r\n            }\r\n\r\n            // Retrieve the received item on the execution being returned.\r\n            ReceivedItem memory item = execution.item;\r\n\r\n            // If the fulfillment components are offer components...\r\n            if (side == Side.OFFER) {\r\n                // Set the supplied recipient on the execution item.\r\n                item.recipient = payable(recipient);\r\n\r\n                // Return execution for aggregated items provided by offerer.\r\n                _aggregateValidFulfillmentOfferItems(\r\n                    advancedOrders,\r\n                    fulfillmentComponents,\r\n                    execution\r\n                );\r\n            } else {\r\n                // Otherwise, fulfillment components are consideration\r\n                // components. Return execution for aggregated items provided by\r\n                // the fulfiller.\r\n                _aggregateValidFulfillmentConsiderationItems(\r\n                    advancedOrders,\r\n                    fulfillmentComponents,\r\n                    execution\r\n                );\r\n\r\n                // Set the caller as the offerer on the execution.\r\n                execution.offerer = msg.sender;\r\n\r\n                // Set fulfiller conduit key as the conduit key on execution.\r\n                execution.conduitKey = fulfillerConduitKey;\r\n            }\r\n\r\n            // Set the offerer and recipient to null address and the item type\r\n            // to a non-native item type if the execution amount is zero. This\r\n            // will cause the execution item to be skipped.\r\n            if (item.amount == 0) {\r\n                execution.offerer = address(0);\r\n                item.recipient = payable(0);\r\n                item.itemType = ItemType.ERC20;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to aggregate a group of offer items using\r\n     *      supplied directives on which component items are candidates for\r\n     *      aggregation, skipping items on orders that are not available.\r\n     *\r\n     * @param advancedOrders  The orders to aggregate offer items from.\r\n     * @param offerComponents An array of FulfillmentComponent structs\r\n     *                        indicating the order index and item index of each\r\n     *                        candidate offer item for aggregation.\r\n     * @param execution       The execution to apply the aggregation to.\r\n     */\r\n    function _aggregateValidFulfillmentOfferItems(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        FulfillmentComponent[] memory offerComponents,\r\n        Execution memory execution\r\n    ) internal pure {\r\n        assembly {\r\n            // Declare a variable for the final aggregated item amount.\r\n            let amount\r\n\r\n            // Declare a variable to track errors encountered with amount.\r\n            let errorBuffer\r\n\r\n            // Declare a variable for the hash of itemType, token, & identifier.\r\n            let dataHash\r\n\r\n            // Iterate over each offer component.\r\n            for {\r\n                // Create variable to track position in offerComponents head.\r\n                let fulfillmentHeadPtr := offerComponents\r\n\r\n                // Get position one word past last element in head of array.\r\n                let endPtr := add(\r\n                    offerComponents,\r\n                    shl(OneWordShift, mload(offerComponents))\r\n                )\r\n            } lt(fulfillmentHeadPtr, endPtr) {\r\n\r\n            } {\r\n                // Increment position in considerationComponents head.\r\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\r\n\r\n                // Retrieve the order index using the fulfillment pointer.\r\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\r\n\r\n                // Ensure that the order index is not out of range.\r\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\r\n                    throwInvalidFulfillmentComponentData()\r\n                }\r\n\r\n                // Read advancedOrders[orderIndex] pointer from its array head.\r\n                let orderPtr := mload(\r\n                    // Calculate head position of advancedOrders[orderIndex].\r\n                    add(\r\n                        add(advancedOrders, OneWord),\r\n                        shl(OneWordShift, orderIndex)\r\n                    )\r\n                )\r\n\r\n                // Read the pointer to OrderParameters from the AdvancedOrder.\r\n                let paramsPtr := mload(orderPtr)\r\n\r\n                // Retrieve item index using an offset of fulfillment pointer.\r\n                let itemIndex := mload(\r\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\r\n                )\r\n\r\n                let offerItemPtr\r\n                {\r\n                    // Load the offer array pointer.\r\n                    let offerArrPtr := mload(\r\n                        add(paramsPtr, OrderParameters_offer_head_offset)\r\n                    )\r\n\r\n                    // If the offer item index is out of range or the numerator\r\n                    // is zero, skip this item.\r\n                    if or(\r\n                        iszero(lt(itemIndex, mload(offerArrPtr))),\r\n                        iszero(\r\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\r\n                        )\r\n                    ) {\r\n                        continue\r\n                    }\r\n\r\n                    // Retrieve offer item pointer using the item index.\r\n                    offerItemPtr := mload(\r\n                        add(\r\n                            // Get pointer to beginning of receivedItem.\r\n                            add(offerArrPtr, OneWord),\r\n                            // Calculate offset to pointer for desired order.\r\n                            shl(OneWordShift, itemIndex)\r\n                        )\r\n                    )\r\n                }\r\n\r\n                // Declare a separate scope for the amount update.\r\n                {\r\n                    // Retrieve amount pointer using consideration item pointer.\r\n                    let amountPtr := add(offerItemPtr, Common_amount_offset)\r\n\r\n                    // Add offer item amount to execution amount.\r\n                    let newAmount := add(amount, mload(amountPtr))\r\n\r\n                    // Update error buffer:\r\n                    // 1 = zero amount, 2 = overflow, 3 = both.\r\n                    errorBuffer := or(\r\n                        errorBuffer,\r\n                        or(\r\n                            shl(1, lt(newAmount, amount)),\r\n                            iszero(mload(amountPtr))\r\n                        )\r\n                    )\r\n\r\n                    // Update the amount to the new, summed amount.\r\n                    amount := newAmount\r\n\r\n                    // Zero out amount on original item to indicate it is spent.\r\n                    mstore(amountPtr, 0)\r\n                }\r\n\r\n                // Retrieve ReceivedItem pointer from Execution.\r\n                let receivedItem := mload(execution)\r\n\r\n                // Check if this is the first valid fulfillment item.\r\n                switch iszero(dataHash)\r\n                case 1 {\r\n                    // On first valid item, populate the received item in memory\r\n                    // for later comparison.\r\n\r\n                    // Set the item type on the received item.\r\n                    mstore(receivedItem, mload(offerItemPtr))\r\n\r\n                    // Set the token on the received item.\r\n                    mstore(\r\n                        add(receivedItem, Common_token_offset),\r\n                        mload(add(offerItemPtr, Common_token_offset))\r\n                    )\r\n\r\n                    // Set the identifier on the received item.\r\n                    mstore(\r\n                        add(receivedItem, Common_identifier_offset),\r\n                        mload(add(offerItemPtr, Common_identifier_offset))\r\n                    )\r\n\r\n                    // Set offerer on returned execution using order pointer.\r\n                    mstore(\r\n                        add(execution, Execution_offerer_offset),\r\n                        mload(paramsPtr)\r\n                    )\r\n\r\n                    // Set execution conduitKey via order pointer offset.\r\n                    mstore(\r\n                        add(execution, Execution_conduit_offset),\r\n                        mload(add(paramsPtr, OrderParameters_conduit_offset))\r\n                    )\r\n\r\n                    // Calculate the hash of (itemType, token, identifier).\r\n                    dataHash := keccak256(\r\n                        receivedItem,\r\n                        ReceivedItem_CommonParams_size\r\n                    )\r\n\r\n                    // If component index > 0, swap component pointer with\r\n                    // pointer to first component so that any remainder after\r\n                    // fulfillment can be added back to the first item.\r\n                    let firstFulfillmentHeadPtr := add(offerComponents, OneWord)\r\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\r\n                        let firstFulfillmentPtr := mload(\r\n                            firstFulfillmentHeadPtr\r\n                        )\r\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\r\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\r\n                    }\r\n                }\r\n                default {\r\n                    // Compare every subsequent item to the first.\r\n                    if or(\r\n                        or(\r\n                            // The offerer must match on both items.\r\n                            xor(\r\n                                mload(paramsPtr),\r\n                                mload(add(execution, Execution_offerer_offset))\r\n                            ),\r\n                            // The conduit key must match on both items.\r\n                            xor(\r\n                                mload(\r\n                                    add(\r\n                                        paramsPtr,\r\n                                        OrderParameters_conduit_offset\r\n                                    )\r\n                                ),\r\n                                mload(add(execution, Execution_conduit_offset))\r\n                            )\r\n                        ),\r\n                        // The itemType, token, and identifier must match.\r\n                        xor(\r\n                            dataHash,\r\n                            keccak256(\r\n                                offerItemPtr,\r\n                                ReceivedItem_CommonParams_size\r\n                            )\r\n                        )\r\n                    ) {\r\n                        // Throw if any of the requirements are not met.\r\n                        throwInvalidFulfillmentComponentData()\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Write final amount to execution.\r\n            mstore(add(mload(execution), Common_amount_offset), amount)\r\n\r\n            // Determine whether the error buffer contains a nonzero error code.\r\n            if errorBuffer {\r\n                // If errorBuffer is 1, an item had an amount of zero.\r\n                if eq(errorBuffer, 1) {\r\n                    // Store left-padded selector with push4 (reduces bytecode)\r\n                    // mem[28:32] = selector\r\n                    mstore(0, MissingItemAmount_error_selector)\r\n\r\n                    // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\r\n                    revert(\r\n                        Error_selector_offset,\r\n                        MissingItemAmount_error_length\r\n                    )\r\n                }\r\n\r\n                // If errorBuffer is not 1 or 0, the sum overflowed.\r\n                // Panic!\r\n                throwOverflow()\r\n            }\r\n\r\n            // Declare function for reverts on invalid fulfillment data.\r\n            function throwInvalidFulfillmentComponentData() {\r\n                // Store left-padded selector (uses push4 and reduces code size)\r\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"InvalidFulfillmentComponentData()\"\r\n                // ))\r\n                revert(\r\n                    Error_selector_offset,\r\n                    InvalidFulfillmentComponentData_error_length\r\n                )\r\n            }\r\n\r\n            // Declare function for reverts due to arithmetic overflows.\r\n            function throwOverflow() {\r\n                // Store the Panic error signature.\r\n                mstore(0, Panic_error_selector)\r\n                // Store the arithmetic (0x11) panic code.\r\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\r\n                // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\r\n                revert(Error_selector_offset, Panic_error_length)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to aggregate a group of consideration items\r\n     *      using supplied directives on which component items are candidates\r\n     *      for aggregation, skipping items on orders that are not available.\r\n     *      Note that this function depends on memory layout affected by an\r\n     *      earlier call to _validateOrdersAndPrepareToFulfill.  The memory for\r\n     *      the consideration arrays needs to be updated before calling\r\n     *      _aggregateValidFulfillmentConsiderationItems.\r\n     *      _validateOrdersAndPrepareToFulfill is called in _matchAdvancedOrders\r\n     *      and _fulfillAvailableAdvancedOrders in the current version.\r\n     *\r\n     * @param advancedOrders          The orders to aggregate consideration\r\n     *                                items from.\r\n     * @param considerationComponents An array of FulfillmentComponent structs\r\n     *                                indicating the order index and item index\r\n     *                                of each candidate consideration item for\r\n     *                                aggregation.\r\n     * @param execution               The execution to apply the aggregation to.\r\n     */\r\n    function _aggregateValidFulfillmentConsiderationItems(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        FulfillmentComponent[] memory considerationComponents,\r\n        Execution memory execution\r\n    ) internal pure {\r\n        // Utilize assembly in order to efficiently aggregate the items.\r\n        assembly {\r\n            // Declare a variable for the final aggregated item amount.\r\n            let amount\r\n\r\n            // Create variable to track errors encountered with amount.\r\n            let errorBuffer\r\n\r\n            // Declare variable for hash(itemType, token, identifier, recipient)\r\n            let dataHash\r\n\r\n            // Iterate over each consideration component.\r\n            for {\r\n                // Track position in considerationComponents head.\r\n                let fulfillmentHeadPtr := considerationComponents\r\n\r\n                // Get position one word past last element in head of array.\r\n                let endPtr := add(\r\n                    considerationComponents,\r\n                    shl(OneWordShift, mload(considerationComponents))\r\n                )\r\n            } lt(fulfillmentHeadPtr, endPtr) {\r\n\r\n            } {\r\n                // Increment position in considerationComponents head.\r\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\r\n\r\n                // Retrieve the order index using the fulfillment pointer.\r\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\r\n\r\n                // Ensure that the order index is not out of range.\r\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\r\n                    throwInvalidFulfillmentComponentData()\r\n                }\r\n\r\n                // Read advancedOrders[orderIndex] pointer from its array head.\r\n                let orderPtr := mload(\r\n                    // Calculate head position of advancedOrders[orderIndex].\r\n                    add(\r\n                        add(advancedOrders, OneWord),\r\n                        shl(OneWordShift, orderIndex)\r\n                    )\r\n                )\r\n\r\n                // Retrieve item index using an offset of fulfillment pointer.\r\n                let itemIndex := mload(\r\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\r\n                )\r\n\r\n                let considerationItemPtr\r\n                {\r\n                    // Load consideration array pointer.\r\n                    let considerationArrPtr := mload(\r\n                        add(\r\n                            // Read OrderParameters pointer from AdvancedOrder.\r\n                            mload(orderPtr),\r\n                            OrderParameters_consideration_head_offset\r\n                        )\r\n                    )\r\n\r\n                    // If the consideration item index is out of range or the\r\n                    // numerator is zero, skip this item.\r\n                    if or(\r\n                        iszero(lt(itemIndex, mload(considerationArrPtr))),\r\n                        iszero(\r\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\r\n                        )\r\n                    ) {\r\n                        continue\r\n                    }\r\n\r\n                    // Retrieve consideration item pointer using the item index.\r\n                    considerationItemPtr := mload(\r\n                        add(\r\n                            // Get pointer to beginning of receivedItem.\r\n                            add(considerationArrPtr, OneWord),\r\n                            // Calculate offset to pointer for desired order.\r\n                            shl(OneWordShift, itemIndex)\r\n                        )\r\n                    )\r\n                }\r\n\r\n                // Declare a separate scope for the amount update.\r\n                {\r\n                    // Retrieve amount pointer using consideration item pointer.\r\n                    let amountPtr := add(\r\n                        considerationItemPtr,\r\n                        Common_amount_offset\r\n                    )\r\n\r\n                    // Add consideration item amount to execution amount.\r\n                    let newAmount := add(amount, mload(amountPtr))\r\n\r\n                    // Update error buffer:\r\n                    // 1 = zero amount, 2 = overflow, 3 = both.\r\n                    errorBuffer := or(\r\n                        errorBuffer,\r\n                        or(\r\n                            shl(1, lt(newAmount, amount)),\r\n                            iszero(mload(amountPtr))\r\n                        )\r\n                    )\r\n\r\n                    // Update the amount to the new, summed amount.\r\n                    amount := newAmount\r\n\r\n                    // Zero out original item amount to indicate it is credited.\r\n                    mstore(amountPtr, 0)\r\n                }\r\n\r\n                // Retrieve ReceivedItem pointer from Execution.\r\n                let receivedItem := mload(execution)\r\n\r\n                switch iszero(dataHash)\r\n                case 1 {\r\n                    // On first valid item, populate the received item in\r\n                    // memory for later comparison.\r\n\r\n                    // Set the item type on the received item.\r\n                    mstore(receivedItem, mload(considerationItemPtr))\r\n\r\n                    // Set the token on the received item.\r\n                    mstore(\r\n                        add(receivedItem, Common_token_offset),\r\n                        mload(add(considerationItemPtr, Common_token_offset))\r\n                    )\r\n\r\n                    // Set the identifier on the received item.\r\n                    mstore(\r\n                        add(receivedItem, Common_identifier_offset),\r\n                        mload(\r\n                            add(considerationItemPtr, Common_identifier_offset)\r\n                        )\r\n                    )\r\n\r\n                    // Set the recipient on the received item. Note that this\r\n                    // depends on the memory layout established by the\r\n                    // _validateOrdersAndPrepareToFulfill function.\r\n                    mstore(\r\n                        add(receivedItem, ReceivedItem_recipient_offset),\r\n                        mload(\r\n                            add(\r\n                                considerationItemPtr,\r\n                                ReceivedItem_recipient_offset\r\n                            )\r\n                        )\r\n                    )\r\n\r\n                    // Calculate the hash of (itemType, token, identifier,\r\n                    // recipient). This is run after amount is set to zero, so\r\n                    // there will be one blank word after identifier included in\r\n                    // the hash buffer.\r\n                    dataHash := keccak256(\r\n                        considerationItemPtr,\r\n                        ReceivedItem_size\r\n                    )\r\n\r\n                    // If component index > 0, swap component pointer with\r\n                    // pointer to first component so that any remainder after\r\n                    // fulfillment can be added back to the first item.\r\n                    let firstFulfillmentHeadPtr := add(\r\n                        considerationComponents,\r\n                        OneWord\r\n                    )\r\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\r\n                        let firstFulfillmentPtr := mload(\r\n                            firstFulfillmentHeadPtr\r\n                        )\r\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\r\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\r\n                    }\r\n                }\r\n                default {\r\n                    // Compare every subsequent item to the first; the item\r\n                    // type, token, identifier and recipient must match.\r\n                    if xor(\r\n                        dataHash,\r\n                        // Calculate the hash of (itemType, token, identifier,\r\n                        // recipient). This is run after amount is set to zero,\r\n                        // so there will be one blank word after identifier\r\n                        // included in the hash buffer.\r\n                        keccak256(considerationItemPtr, ReceivedItem_size)\r\n                    ) {\r\n                        // Throw if any of the requirements are not met.\r\n                        throwInvalidFulfillmentComponentData()\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Retrieve ReceivedItem pointer from Execution.\r\n            let receivedItem := mload(execution)\r\n\r\n            // Write final amount to execution.\r\n            mstore(add(receivedItem, Common_amount_offset), amount)\r\n\r\n            // Determine whether the error buffer contains a nonzero error code.\r\n            if errorBuffer {\r\n                // If errorBuffer is 1, an item had an amount of zero.\r\n                if eq(errorBuffer, 1) {\r\n                    // Store left-padded selector with push4, mem[28:32]\r\n                    mstore(0, MissingItemAmount_error_selector)\r\n\r\n                    // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\r\n                    revert(\r\n                        Error_selector_offset,\r\n                        MissingItemAmount_error_length\r\n                    )\r\n                }\r\n\r\n                // If errorBuffer is not 1 or 0, `amount` overflowed.\r\n                // Panic!\r\n                throwOverflow()\r\n            }\r\n\r\n            // Declare function for reverts on invalid fulfillment data.\r\n            function throwInvalidFulfillmentComponentData() {\r\n                // Store the InvalidFulfillmentComponentData error signature.\r\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\r\n\r\n                // revert(abi.encodeWithSignature(\r\n                //     \"InvalidFulfillmentComponentData()\"\r\n                // ))\r\n                revert(\r\n                    Error_selector_offset,\r\n                    InvalidFulfillmentComponentData_error_length\r\n                )\r\n            }\r\n\r\n            // Declare function for reverts due to arithmetic overflows.\r\n            function throwOverflow() {\r\n                // Store the Panic error signature.\r\n                mstore(0, Panic_error_selector)\r\n                // Store the arithmetic (0x11) panic code.\r\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\r\n                // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\r\n                revert(Error_selector_offset, Panic_error_length)\r\n            }\r\n        }\r\n    }\r\n}\r\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\r\n    /**\r\n     * @dev Derive and set hashes, reference chainId, and associated domain\r\n     *      separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\r\n\r\n    /**\r\n     * @notice Internal function to attempt to fill a group of orders, fully or\r\n     *         partially, with an arbitrary number of items for offer and\r\n     *         consideration per order alongside criteria resolvers containing\r\n     *         specific token identifiers and associated proofs. Any order that\r\n     *         is not currently active, has already been fully filled, or has\r\n     *         been cancelled will be omitted. Remaining offer and consideration\r\n     *         items will then be aggregated where possible as indicated by the\r\n     *         supplied offer and consideration component arrays and aggregated\r\n     *         items will be transferred to the fulfiller or to each intended\r\n     *         recipient, respectively. Note that a failing item transfer or an\r\n     *         issue with order formatting will cause the entire batch to fail.\r\n     *\r\n     * @param advancedOrders            The orders to fulfill along with the\r\n     *                                  fraction of those orders to attempt to\r\n     *                                  fill. Note that both the offerer and the\r\n     *                                  fulfiller must first approve this\r\n     *                                  contract (or a conduit if indicated by\r\n     *                                  the order) to transfer any relevant\r\n     *                                  tokens on their behalf and that\r\n     *                                  contracts must implement\r\n     *                                  `onERC1155Received` in order to receive\r\n     *                                  ERC1155 tokens as consideration. Also\r\n     *                                  note that all offer and consideration\r\n     *                                  components must have no remainder after\r\n     *                                  multiplication of the respective amount\r\n     *                                  with the supplied fraction for an\r\n     *                                  order's partial fill amount to be\r\n     *                                  considered valid.\r\n     * @param criteriaResolvers         An array where each element contains a\r\n     *                                  reference to a specific offer or\r\n     *                                  consideration, a token identifier, and a\r\n     *                                  proof that the supplied token identifier\r\n     *                                  is contained in the merkle root held by\r\n     *                                  the item in question's criteria element.\r\n     *                                  Note that an empty criteria indicates\r\n     *                                  that any (transferable) token\r\n     *                                  identifier on the token in question is\r\n     *                                  valid and that no associated proof needs\r\n     *                                  to be supplied.\r\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\r\n     *                                  indicating which offer items to attempt\r\n     *                                  to aggregate when preparing executions.\r\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\r\n     *                                  indicating which consideration items to\r\n     *                                  attempt to aggregate when preparing\r\n     *                                  executions.\r\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\r\n     *                                  if any, to source the fulfiller's token\r\n     *                                  approvals from. The zero hash signifies\r\n     *                                  that no conduit should be used (and\r\n     *                                  direct approvals set on Consideration).\r\n     * @param recipient                 The intended recipient for all received\r\n     *                                  items.\r\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\r\n     *\r\n     * @return availableOrders An array of booleans indicating if each order\r\n     *                         with an index corresponding to the index of the\r\n     *                         returned boolean was fulfillable or not.\r\n     * @return executions      An array of elements indicating the sequence of\r\n     *                         transfers performed as part of matching the given\r\n     *                         orders.\r\n     */\r\n    function _fulfillAvailableAdvancedOrders(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        CriteriaResolver[] memory criteriaResolvers,\r\n        FulfillmentComponent[][] memory offerFulfillments,\r\n        FulfillmentComponent[][] memory considerationFulfillments,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient,\r\n        uint256 maximumFulfilled\r\n    )\r\n        internal\r\n        returns (\r\n            bool[] memory /* availableOrders */,\r\n            Execution[] memory /* executions */\r\n        )\r\n    {\r\n        // Validate orders, apply amounts, & determine if they utilize conduits.\r\n        (\r\n            bytes32[] memory orderHashes,\r\n            bool containsNonOpen\r\n        ) = _validateOrdersAndPrepareToFulfill(\r\n                advancedOrders,\r\n                criteriaResolvers,\r\n                false, // Signifies that invalid orders should NOT revert.\r\n                maximumFulfilled,\r\n                recipient\r\n            );\r\n\r\n        // Aggregate used offer and consideration items and execute transfers.\r\n        return\r\n            _executeAvailableFulfillments(\r\n                advancedOrders,\r\n                offerFulfillments,\r\n                considerationFulfillments,\r\n                fulfillerConduitKey,\r\n                recipient,\r\n                orderHashes,\r\n                containsNonOpen\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to validate a group of orders, update their\r\n     *      statuses, reduce amounts by their previously filled fractions, apply\r\n     *      criteria resolvers, and emit OrderFulfilled events. Note that this\r\n     *      function needs to be called before\r\n     *      _aggregateValidFulfillmentConsiderationItems to set the memory\r\n     *      layout that _aggregateValidFulfillmentConsiderationItems depends on.\r\n     *\r\n     * @param advancedOrders    The advanced orders to validate and reduce by\r\n     *                          their previously filled amounts.\r\n     * @param criteriaResolvers An array where each element contains a reference\r\n     *                          to a specific order as well as that order's\r\n     *                          offer or consideration, a token identifier, and\r\n     *                          a proof that the supplied token identifier is\r\n     *                          contained in the order's merkle root. Note that\r\n     *                          a root of zero indicates that any transferable\r\n     *                          token identifier is valid and that no proof\r\n     *                          needs to be supplied.\r\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\r\n     *                          order being invalid; setting this to false will\r\n     *                          instead cause the invalid order to be skipped.\r\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\r\n     * @param recipient         The intended recipient for all items that do not\r\n     *                          already have a designated recipient and are not\r\n     *                          already used as part of a provided fulfillment.\r\n     *\r\n     * @return orderHashes     The hashes of the orders being fulfilled.\r\n     * @return containsNonOpen A boolean indicating whether any restricted or\r\n     *                         contract orders are present within the provided\r\n     *                         array of advanced orders.\r\n     */\r\n    function _validateOrdersAndPrepareToFulfill(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        CriteriaResolver[] memory criteriaResolvers,\r\n        bool revertOnInvalid,\r\n        uint256 maximumFulfilled,\r\n        address recipient\r\n    ) internal returns (bytes32[] memory orderHashes, bool containsNonOpen) {\r\n        // Ensure this function cannot be triggered during a reentrant call.\r\n        _setReentrancyGuard(true); // Native tokens accepted during execution.\r\n\r\n        // Declare an error buffer indicating status of any native offer items.\r\n        // Native tokens may only be provided as part of contract orders or when\r\n        // fulfilling via matchOrders or matchAdvancedOrders; if bits indicating\r\n        // these conditions are not met have been set, throw.\r\n        uint256 invalidNativeOfferItemErrorBuffer;\r\n\r\n        // Use assembly to set the value for the second bit of the error buffer.\r\n        assembly {\r\n            /**\r\n             * Use the 231st bit of the error buffer to indicate whether the\r\n             * current function is not matchAdvancedOrders or matchOrders.\r\n             *\r\n             * sig                                func\r\n             * -----------------------------------------------------------------\r\n             * 1010100000010111010001000 0 000100 matchOrders\r\n             * 1111001011010001001010110 0 010010 matchAdvancedOrders\r\n             * 1110110110011000101001010 1 110100 fulfillAvailableOrders\r\n             * 1000011100100000000110110 1 000001 fulfillAvailableAdvancedOrders\r\n             *                           ^ 7th bit\r\n             */\r\n            invalidNativeOfferItemErrorBuffer := and(\r\n                NonMatchSelector_MagicMask,\r\n                calldataload(0)\r\n            )\r\n        }\r\n\r\n        // Declare variables for later use.\r\n        AdvancedOrder memory advancedOrder;\r\n        uint256 terminalMemoryOffset;\r\n\r\n        unchecked {\r\n            // Read length of orders array and place on the stack.\r\n            uint256 totalOrders = advancedOrders.length;\r\n\r\n            // Track the order hash for each order being fulfilled.\r\n            orderHashes = new bytes32[](totalOrders);\r\n\r\n            // Determine the memory offset to terminate on during loops.\r\n            terminalMemoryOffset = (totalOrders + 1) << OneWordShift;\r\n        }\r\n\r\n        // Skip overflow checks as all for loops are indexed starting at zero.\r\n        unchecked {\r\n            // Declare inner variables.\r\n            OfferItem[] memory offer;\r\n            ConsiderationItem[] memory consideration;\r\n\r\n            // Iterate over each order.\r\n            for (uint256 i = OneWord; i < terminalMemoryOffset; i += OneWord) {\r\n                // Retrieve order using assembly to bypass out-of-range check.\r\n                assembly {\r\n                    advancedOrder := mload(add(advancedOrders, i))\r\n                }\r\n\r\n                // Determine if max number orders have already been fulfilled.\r\n                if (maximumFulfilled == 0) {\r\n                    // Mark fill fraction as zero as the order will not be used.\r\n                    advancedOrder.numerator = 0;\r\n\r\n                    // Continue iterating through the remaining orders.\r\n                    continue;\r\n                }\r\n\r\n                // Validate it, update status, and determine fraction to fill.\r\n                (\r\n                    bytes32 orderHash,\r\n                    uint256 numerator,\r\n                    uint256 denominator\r\n                ) = _validateOrderAndUpdateStatus(\r\n                        advancedOrder,\r\n                        revertOnInvalid\r\n                    );\r\n\r\n                // Do not track hash or adjust prices if order is not fulfilled.\r\n                if (numerator == 0) {\r\n                    // Mark fill fraction as zero if the order is not fulfilled.\r\n                    advancedOrder.numerator = 0;\r\n\r\n                    // Continue iterating through the remaining orders.\r\n                    continue;\r\n                }\r\n\r\n                // Otherwise, track the order hash in question.\r\n                assembly {\r\n                    mstore(add(orderHashes, i), orderHash)\r\n                }\r\n\r\n                // Decrement the number of fulfilled orders.\r\n                // Skip underflow check as the condition before\r\n                // implies that maximumFulfilled > 0.\r\n                --maximumFulfilled;\r\n\r\n                // Place the start time for the order on the stack.\r\n                uint256 startTime = advancedOrder.parameters.startTime;\r\n\r\n                // Place the end time for the order on the stack.\r\n                uint256 endTime = advancedOrder.parameters.endTime;\r\n\r\n                // Retrieve array of offer items for the order in question.\r\n                offer = advancedOrder.parameters.offer;\r\n\r\n                // Read length of offer array and place on the stack.\r\n                uint256 totalOfferItems = offer.length;\r\n\r\n                {\r\n                    // Determine the order type, used to check for eligibility\r\n                    // for native token offer items as well as for the presence\r\n                    // of restricted and contract orders (or non-open orders).\r\n                    OrderType orderType = advancedOrder.parameters.orderType;\r\n\r\n                    // Utilize assembly to efficiently check for order types.\r\n                    // Note that these checks expect that there are no order\r\n                    // types beyond the current set (0-4) and will need to be\r\n                    // modified if more order types are added.\r\n                    assembly {\r\n                        // Declare a variable indicating if the order is not a\r\n                        // contract order. Cache in scratch space to avoid stack\r\n                        // depth errors.\r\n                        let isNonContract := lt(orderType, 4)\r\n                        mstore(0, isNonContract)\r\n\r\n                        // Update the variable indicating if the order is not an\r\n                        // open order, remaining set if it has been set already.\r\n                        containsNonOpen := or(containsNonOpen, gt(orderType, 1))\r\n                    }\r\n                }\r\n\r\n                // Iterate over each offer item on the order.\r\n                for (uint256 j = 0; j < totalOfferItems; ++j) {\r\n                    // Retrieve the offer item.\r\n                    OfferItem memory offerItem = offer[j];\r\n\r\n                    // If the offer item is for the native token and the order\r\n                    // type is not a contract order type, set the first bit of\r\n                    // the error buffer to true.\r\n                    assembly {\r\n                        invalidNativeOfferItemErrorBuffer := or(\r\n                            invalidNativeOfferItemErrorBuffer,\r\n                            lt(mload(offerItem), mload(0))\r\n                        )\r\n                    }\r\n\r\n                    // Apply order fill fraction to offer item end amount.\r\n                    uint256 endAmount = _getFraction(\r\n                        numerator,\r\n                        denominator,\r\n                        offerItem.endAmount\r\n                    );\r\n\r\n                    // Reuse same fraction if start and end amounts are equal.\r\n                    if (offerItem.startAmount == offerItem.endAmount) {\r\n                        // Apply derived amount to both start and end amount.\r\n                        offerItem.startAmount = endAmount;\r\n                    } else {\r\n                        // Apply order fill fraction to offer item start amount.\r\n                        offerItem.startAmount = _getFraction(\r\n                            numerator,\r\n                            denominator,\r\n                            offerItem.startAmount\r\n                        );\r\n                    }\r\n\r\n                    // Adjust offer amount using current time; round down.\r\n                    uint256 currentAmount = _locateCurrentAmount(\r\n                        offerItem.startAmount,\r\n                        endAmount,\r\n                        startTime,\r\n                        endTime,\r\n                        false // round down\r\n                    );\r\n\r\n                    // Update amounts in memory to match the current amount.\r\n                    // Note that the end amount is used to track spent amounts.\r\n                    offerItem.startAmount = currentAmount;\r\n                    offerItem.endAmount = currentAmount;\r\n                }\r\n\r\n                // Retrieve array of consideration items for order in question.\r\n                consideration = (advancedOrder.parameters.consideration);\r\n\r\n                // Read length of consideration array and place on the stack.\r\n                uint256 totalConsiderationItems = consideration.length;\r\n\r\n                // Iterate over each consideration item on the order.\r\n                for (uint256 j = 0; j < totalConsiderationItems; ++j) {\r\n                    // Retrieve the consideration item.\r\n                    ConsiderationItem memory considerationItem = (\r\n                        consideration[j]\r\n                    );\r\n\r\n                    // Apply fraction to consideration item end amount.\r\n                    uint256 endAmount = _getFraction(\r\n                        numerator,\r\n                        denominator,\r\n                        considerationItem.endAmount\r\n                    );\r\n\r\n                    // Reuse same fraction if start and end amounts are equal.\r\n                    if (\r\n                        considerationItem.startAmount ==\r\n                        considerationItem.endAmount\r\n                    ) {\r\n                        // Apply derived amount to both start and end amount.\r\n                        considerationItem.startAmount = endAmount;\r\n                    } else {\r\n                        // Apply fraction to consideration item start amount.\r\n                        considerationItem.startAmount = _getFraction(\r\n                            numerator,\r\n                            denominator,\r\n                            considerationItem.startAmount\r\n                        );\r\n                    }\r\n\r\n                    // Adjust consideration amount using current time; round up.\r\n                    uint256 currentAmount = (\r\n                        _locateCurrentAmount(\r\n                            considerationItem.startAmount,\r\n                            endAmount,\r\n                            startTime,\r\n                            endTime,\r\n                            true // round up\r\n                        )\r\n                    );\r\n\r\n                    considerationItem.startAmount = currentAmount;\r\n\r\n                    // Utilize assembly to manually \"shift\" the recipient value,\r\n                    // then to copy the start amount to the recipient.\r\n                    // Note that this sets up the memory layout that is\r\n                    // subsequently relied upon by\r\n                    // _aggregateValidFulfillmentConsiderationItems.\r\n                    assembly {\r\n                        // Derive the pointer to the recipient using the item\r\n                        // pointer along with the offset to the recipient.\r\n                        let considerationItemRecipientPtr := add(\r\n                            considerationItem,\r\n                            ConsiderationItem_recipient_offset // recipient\r\n                        )\r\n\r\n                        // Write recipient to endAmount, as endAmount is not\r\n                        // used from this point on and can be repurposed to fit\r\n                        // the layout of a ReceivedItem.\r\n                        mstore(\r\n                            add(\r\n                                considerationItem,\r\n                                ReceivedItem_recipient_offset // old endAmount\r\n                            ),\r\n                            mload(considerationItemRecipientPtr)\r\n                        )\r\n\r\n                        // Write startAmount to recipient, as recipient is not\r\n                        // used from this point on and can be repurposed to\r\n                        // track received amounts.\r\n                        mstore(considerationItemRecipientPtr, currentAmount)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the first bit is set, a native offer item was encountered on an\r\n        // order that is not a contract order. If the 231st bit is set in the\r\n        // error buffer, the current function is not matchOrders or\r\n        // matchAdvancedOrders. If the value is 1 + (1 << 230), then both the\r\n        // 1st and 231st bits were set; in that case, revert with an error.\r\n        if (\r\n            invalidNativeOfferItemErrorBuffer ==\r\n            NonMatchSelector_InvalidErrorValue\r\n        ) {\r\n            _revertInvalidNativeOfferItem();\r\n        }\r\n\r\n        // Apply criteria resolvers to each order as applicable.\r\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\r\n\r\n        // Emit an event for each order signifying that it has been fulfilled.\r\n        // Skip overflow checks as all for loops are indexed starting at zero.\r\n        unchecked {\r\n            bytes32 orderHash;\r\n\r\n            // Iterate over each order.\r\n            for (uint256 i = OneWord; i < terminalMemoryOffset; i += OneWord) {\r\n                assembly {\r\n                    orderHash := mload(add(orderHashes, i))\r\n                }\r\n\r\n                // Do not emit an event if no order hash is present.\r\n                if (orderHash == bytes32(0)) {\r\n                    continue;\r\n                }\r\n\r\n                // Retrieve order using assembly to bypass out-of-range check.\r\n                assembly {\r\n                    advancedOrder := mload(add(advancedOrders, i))\r\n                }\r\n\r\n                // Retrieve parameters for the order in question.\r\n                OrderParameters memory orderParameters = (\r\n                    advancedOrder.parameters\r\n                );\r\n\r\n                // Emit an OrderFulfilled event.\r\n                _emitOrderFulfilledEvent(\r\n                    orderHash,\r\n                    orderParameters.offerer,\r\n                    orderParameters.zone,\r\n                    recipient,\r\n                    orderParameters.offer,\r\n                    orderParameters.consideration\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to fulfill a group of validated orders, fully or\r\n     *      partially, with an arbitrary number of items for offer and\r\n     *      consideration per order and to execute transfers. Any order that is\r\n     *      not currently active, has already been fully filled, or has been\r\n     *      cancelled will be omitted. Remaining offer and consideration items\r\n     *      will then be aggregated where possible as indicated by the supplied\r\n     *      offer and consideration component arrays and aggregated items will\r\n     *      be transferred to the fulfiller or to each intended recipient,\r\n     *      respectively. Note that a failing item transfer or an issue with\r\n     *      order formatting will cause the entire batch to fail.\r\n     *\r\n     * @param advancedOrders            The orders to fulfill along with the\r\n     *                                  fraction of those orders to attempt to\r\n     *                                  fill. Note that both the offerer and the\r\n     *                                  fulfiller must first approve this\r\n     *                                  contract (or the conduit if indicated by\r\n     *                                  the order) to transfer any relevant\r\n     *                                  tokens on their behalf and that\r\n     *                                  contracts must implement\r\n     *                                  `onERC1155Received` in order to receive\r\n     *                                  ERC1155 tokens as consideration. Also\r\n     *                                  note that all offer and consideration\r\n     *                                  components must have no remainder after\r\n     *                                  multiplication of the respective amount\r\n     *                                  with the supplied fraction for an\r\n     *                                  order's partial fill amount to be\r\n     *                                  considered valid.\r\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\r\n     *                                  indicating which offer items to attempt\r\n     *                                  to aggregate when preparing executions.\r\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\r\n     *                                  indicating which consideration items to\r\n     *                                  attempt to aggregate when preparing\r\n     *                                  executions.\r\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\r\n     *                                  if any, to source the fulfiller's token\r\n     *                                  approvals from. The zero hash signifies\r\n     *                                  that no conduit should be used, with\r\n     *                                  direct approvals set on Consideration.\r\n     * @param recipient                 The intended recipient for all items\r\n     *                                  that do not already have a designated\r\n     *                                  recipient and are not already used as\r\n     *                                  part of a provided fulfillment.\r\n     * @param orderHashes               An array of order hashes for each order.\r\n     * @param containsNonOpen           A boolean indicating whether any\r\n     *                                  restricted or contract orders are\r\n     *                                  present within the provided array of\r\n     *                                  advanced orders.\r\n     *\r\n     * @return availableOrders An array of booleans indicating if each order\r\n     *                         with an index corresponding to the index of the\r\n     *                         returned boolean was fulfillable or not.\r\n     * @return executions      An array of elements indicating the sequence of\r\n     *                         transfers performed as part of matching the given\r\n     *                         orders.\r\n     */\r\n    function _executeAvailableFulfillments(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        FulfillmentComponent[][] memory offerFulfillments,\r\n        FulfillmentComponent[][] memory considerationFulfillments,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient,\r\n        bytes32[] memory orderHashes,\r\n        bool containsNonOpen\r\n    )\r\n        internal\r\n        returns (bool[] memory availableOrders, Execution[] memory executions)\r\n    {\r\n        // Retrieve length of offer fulfillments array and place on the stack.\r\n        uint256 totalOfferFulfillments = offerFulfillments.length;\r\n\r\n        // Retrieve length of consideration fulfillments array & place on stack.\r\n        uint256 totalConsiderationFulfillments = (\r\n            considerationFulfillments.length\r\n        );\r\n\r\n        // Allocate an execution for each offer and consideration fulfillment.\r\n        executions = new Execution[](\r\n            totalOfferFulfillments + totalConsiderationFulfillments\r\n        );\r\n\r\n        // Skip overflow checks as all for loops are indexed starting at zero.\r\n        unchecked {\r\n            // Track number of filtered executions.\r\n            uint256 totalFilteredExecutions = 0;\r\n\r\n            // Iterate over each offer fulfillment.\r\n            for (uint256 i = 0; i < totalOfferFulfillments; ) {\r\n                // Derive aggregated execution corresponding with fulfillment.\r\n                Execution memory execution = _aggregateAvailable(\r\n                    advancedOrders,\r\n                    Side.OFFER,\r\n                    offerFulfillments[i],\r\n                    fulfillerConduitKey,\r\n                    recipient\r\n                );\r\n\r\n                // If the execution is filterable...\r\n                if (_isFilterableExecution(execution)) {\r\n                    // Increment total filtered executions.\r\n                    ++totalFilteredExecutions;\r\n                } else {\r\n                    // Otherwise, assign the execution to the executions array.\r\n                    executions[i - totalFilteredExecutions] = execution;\r\n                }\r\n\r\n                // Increment iterator.\r\n                ++i;\r\n            }\r\n\r\n            // Iterate over each consideration fulfillment.\r\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ) {\r\n                // Derive aggregated execution corresponding with fulfillment.\r\n                Execution memory execution = _aggregateAvailable(\r\n                    advancedOrders,\r\n                    Side.CONSIDERATION,\r\n                    considerationFulfillments[i],\r\n                    fulfillerConduitKey,\r\n                    address(0) // unused\r\n                );\r\n\r\n                // If the execution is filterable...\r\n                if (_isFilterableExecution(execution)) {\r\n                    // Increment total filtered executions.\r\n                    ++totalFilteredExecutions;\r\n                } else {\r\n                    // Otherwise, assign the execution to the executions array.\r\n                    executions[\r\n                        i + totalOfferFulfillments - totalFilteredExecutions\r\n                    ] = execution;\r\n                }\r\n\r\n                // Increment iterator.\r\n                ++i;\r\n            }\r\n\r\n            // If some number of executions have been filtered...\r\n            if (totalFilteredExecutions != 0) {\r\n                // reduce the total length of the executions array.\r\n                assembly {\r\n                    mstore(\r\n                        executions,\r\n                        sub(mload(executions), totalFilteredExecutions)\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        // Revert if no orders are available.\r\n        if (executions.length == 0) {\r\n            _revertNoSpecifiedOrdersAvailable();\r\n        }\r\n\r\n        // Perform final checks and return.\r\n        availableOrders = _performFinalChecksAndExecuteOrders(\r\n            advancedOrders,\r\n            executions,\r\n            orderHashes,\r\n            recipient,\r\n            containsNonOpen\r\n        );\r\n\r\n        return (availableOrders, executions);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to perform a final check that each consideration\r\n     *      item for an arbitrary number of fulfilled orders has been met and to\r\n     *      trigger associated executions, transferring the respective items.\r\n     *\r\n     * @param advancedOrders  The orders to check and perform executions for.\r\n     * @param executions      An array of elements indicating the sequence of\r\n     *                        transfers to perform when fulfilling the given\r\n     *                        orders.\r\n     * @param orderHashes     An array of order hashes for each order.\r\n     * @param recipient       The intended recipient for all items that do not\r\n     *                        already have a designated recipient and are not\r\n     *                        used as part of a provided fulfillment.\r\n     * @param containsNonOpen A boolean indicating whether any restricted or\r\n     *                        contract orders are present within the provided\r\n     *                        array of advanced orders.\r\n     *\r\n     * @return availableOrders An array of booleans indicating if each order\r\n     *                         with an index corresponding to the index of the\r\n     *                         returned boolean was fulfillable or not.\r\n     */\r\n    function _performFinalChecksAndExecuteOrders(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        Execution[] memory executions,\r\n        bytes32[] memory orderHashes,\r\n        address recipient,\r\n        bool containsNonOpen\r\n    ) internal returns (bool[] memory /* availableOrders */) {\r\n        // Retrieve the length of the advanced orders array and place on stack.\r\n        uint256 totalOrders = advancedOrders.length;\r\n\r\n        // Initialize array for tracking available orders.\r\n        bool[] memory availableOrders = new bool[](totalOrders);\r\n\r\n        // Initialize an accumulator array. From this point forward, no new\r\n        // memory regions can be safely allocated until the accumulator is no\r\n        // longer being utilized, as the accumulator operates in an open-ended\r\n        // fashion from this memory pointer; existing memory may still be\r\n        // accessed and modified, however.\r\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\r\n\r\n        {\r\n            // Declare a variable for the available native token balance.\r\n            uint256 nativeTokenBalance;\r\n\r\n            // Retrieve the length of the executions array and place on stack.\r\n            uint256 totalExecutions = executions.length;\r\n\r\n            // Iterate over each execution.\r\n            for (uint256 i = 0; i < totalExecutions; ) {\r\n                // Retrieve the execution and the associated received item.\r\n                Execution memory execution = executions[i];\r\n                ReceivedItem memory item = execution.item;\r\n\r\n                // If execution transfers native tokens, reduce value available.\r\n                if (item.itemType == ItemType.NATIVE) {\r\n                    // Get the current available balance of native tokens.\r\n                    assembly {\r\n                        nativeTokenBalance := selfbalance()\r\n                    }\r\n\r\n                    // Ensure that sufficient native tokens are still available.\r\n                    if (item.amount > nativeTokenBalance) {\r\n                        _revertInsufficientNativeTokensSupplied();\r\n                    }\r\n                }\r\n\r\n                // Transfer the item specified by the execution.\r\n                _transfer(\r\n                    item,\r\n                    execution.offerer,\r\n                    execution.conduitKey,\r\n                    accumulator\r\n                );\r\n\r\n                // Skip overflow check as for loop is indexed starting at zero.\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Skip overflow checks as all for loops are indexed starting at zero.\r\n        unchecked {\r\n            // Iterate over each order.\r\n            for (uint256 i = 0; i < totalOrders; ++i) {\r\n                // Retrieve the order in question.\r\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\r\n\r\n                // Skip the order in question if not being not fulfilled.\r\n                if (advancedOrder.numerator == 0) {\r\n                    // Explicitly set availableOrders at the given index to\r\n                    // guard against the possibility of dirtied memory.\r\n                    availableOrders[i] = false;\r\n                    continue;\r\n                }\r\n\r\n                // Mark the order as available.\r\n                availableOrders[i] = true;\r\n\r\n                // Retrieve the order parameters.\r\n                OrderParameters memory parameters = advancedOrder.parameters;\r\n\r\n                {\r\n                    // Retrieve offer items.\r\n                    OfferItem[] memory offer = parameters.offer;\r\n\r\n                    // Read length of offer array & place on the stack.\r\n                    uint256 totalOfferItems = offer.length;\r\n\r\n                    // Iterate over each offer item to restore it.\r\n                    for (uint256 j = 0; j < totalOfferItems; ++j) {\r\n                        // Retrieve the offer item in question.\r\n                        OfferItem memory offerItem = offer[j];\r\n\r\n                        // Transfer to recipient if unspent amount is not zero.\r\n                        // Note that the transfer will not be reflected in the\r\n                        // executions array.\r\n                        if (offerItem.startAmount != 0) {\r\n                            _transfer(\r\n                                _fromOfferItemToReceivedItemWithRecipient(\r\n                                    offerItem,\r\n                                    recipient\r\n                                ),\r\n                                parameters.offerer,\r\n                                parameters.conduitKey,\r\n                                accumulator\r\n                            );\r\n                        }\r\n\r\n                        // Restore original amount on the offer item.\r\n                        offerItem.startAmount = offerItem.endAmount;\r\n                    }\r\n                }\r\n\r\n                {\r\n                    // Read consideration items & ensure they are fulfilled.\r\n                    ConsiderationItem[] memory consideration = (\r\n                        parameters.consideration\r\n                    );\r\n\r\n                    // Read length of consideration array & place on stack.\r\n                    uint256 totalConsiderationItems = consideration.length;\r\n\r\n                    // Iterate over each consideration item.\r\n                    for (uint256 j = 0; j < totalConsiderationItems; ++j) {\r\n                        ConsiderationItem memory considerationItem = (\r\n                            consideration[j]\r\n                        );\r\n\r\n                        // Retrieve remaining amount on consideration item.\r\n                        uint256 unmetAmount = considerationItem.startAmount;\r\n\r\n                        // Revert if the remaining amount is not zero.\r\n                        if (unmetAmount != 0) {\r\n                            _revertConsiderationNotMet(i, j, unmetAmount);\r\n                        }\r\n\r\n                        // Utilize assembly to restore the original value.\r\n                        assembly {\r\n                            // Write recipient to startAmount.\r\n                            mstore(\r\n                                add(\r\n                                    considerationItem,\r\n                                    ReceivedItem_amount_offset\r\n                                ),\r\n                                mload(\r\n                                    add(\r\n                                        considerationItem,\r\n                                        ConsiderationItem_recipient_offset\r\n                                    )\r\n                                )\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Trigger any accumulated transfers via call to the conduit.\r\n        _triggerIfArmed(accumulator);\r\n\r\n        // Determine whether any native token balance remains.\r\n        uint256 remainingNativeTokenBalance;\r\n        assembly {\r\n            remainingNativeTokenBalance := selfbalance()\r\n        }\r\n\r\n        // Return any remaining native token balance to the caller.\r\n        if (remainingNativeTokenBalance != 0) {\r\n            _transferNativeTokens(\r\n                payable(msg.sender),\r\n                remainingNativeTokenBalance\r\n            );\r\n        }\r\n\r\n        // If any restricted or contract orders are present in the group of\r\n        // orders being fulfilled, perform any validateOrder or ratifyOrder\r\n        // calls after all executions and related transfers are complete.\r\n        if (containsNonOpen) {\r\n            // Iterate over each order a second time.\r\n            for (uint256 i = 0; i < totalOrders; ) {\r\n                // Ensure the order in question is being fulfilled.\r\n                if (availableOrders[i]) {\r\n                    // Check restricted orders and contract orders.\r\n                    _assertRestrictedAdvancedOrderValidity(\r\n                        advancedOrders[i],\r\n                        orderHashes,\r\n                        orderHashes[i]\r\n                    );\r\n                }\r\n\r\n                // Skip overflow checks as for loop is indexed starting at zero.\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Clear the reentrancy guard.\r\n        _clearReentrancyGuard();\r\n\r\n        // Return the array containing available orders.\r\n        return availableOrders;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to emit an OrdersMatched event using the same\r\n     *      memory region as the existing order hash array.\r\n     *\r\n     * @param orderHashes An array of order hashes to include as an argument for\r\n     *                    the OrdersMatched event.\r\n     */\r\n    function _emitOrdersMatched(bytes32[] memory orderHashes) internal {\r\n        assembly {\r\n            // Load the array length from memory.\r\n            let length := mload(orderHashes)\r\n\r\n            // Get the full size of the event data - one word for the offset,\r\n            // one for the array length and one per hash.\r\n            let dataSize := add(TwoWords, shl(OneWordShift, length))\r\n\r\n            // Get pointer to start of data, reusing word before array length\r\n            // for the offset.\r\n            let dataPointer := sub(orderHashes, OneWord)\r\n\r\n            // Cache the existing word in memory at the offset pointer.\r\n            let cache := mload(dataPointer)\r\n\r\n            // Write an offset of 32.\r\n            mstore(dataPointer, OneWord)\r\n\r\n            // Emit the OrdersMatched event.\r\n            log1(dataPointer, dataSize, OrdersMatchedTopic0)\r\n\r\n            // Restore the cached word.\r\n            mstore(dataPointer, cache)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to match an arbitrary number of full or partial\r\n     *      orders, each with an arbitrary number of items for offer and\r\n     *      consideration, supplying criteria resolvers containing specific\r\n     *      token identifiers and associated proofs as well as fulfillments\r\n     *      allocating offer components to consideration components.\r\n     *\r\n     * @param advancedOrders    The advanced orders to match. Note that both the\r\n     *                          offerer and fulfiller on each order must first\r\n     *                          approve this contract (or their conduit if\r\n     *                          indicated by the order) to transfer any relevant\r\n     *                          tokens on their behalf and each consideration\r\n     *                          recipient must implement `onERC1155Received` in\r\n     *                          order to receive ERC1155 tokens. Also note that\r\n     *                          the offer and consideration components for each\r\n     *                          order must have no remainder after multiplying\r\n     *                          the respective amount with the supplied fraction\r\n     *                          in order for the group of partial fills to be\r\n     *                          considered valid.\r\n     * @param criteriaResolvers An array where each element contains a reference\r\n     *                          to a specific order as well as that order's\r\n     *                          offer or consideration, a token identifier, and\r\n     *                          a proof that the supplied token identifier is\r\n     *                          contained in the order's merkle root. Note that\r\n     *                          an empty root indicates that any (transferable)\r\n     *                          token identifier is valid and that no associated\r\n     *                          proof needs to be supplied.\r\n     * @param fulfillments      An array of elements allocating offer components\r\n     *                          to consideration components. Note that each\r\n     *                          consideration component must be fully met in\r\n     *                          order for the match operation to be valid.\r\n     * @param recipient         The intended recipient for all unspent offer\r\n     *                          item amounts.\r\n     *\r\n     * @return executions An array of elements indicating the sequence of\r\n     *                    transfers performed as part of matching the given\r\n     *                    orders.\r\n     */\r\n    function _matchAdvancedOrders(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        CriteriaResolver[] memory criteriaResolvers,\r\n        Fulfillment[] memory fulfillments,\r\n        address recipient\r\n    ) internal returns (Execution[] memory /* executions */) {\r\n        // Validate orders, update order status, and determine item amounts.\r\n        (\r\n            bytes32[] memory orderHashes,\r\n            bool containsNonOpen\r\n        ) = _validateOrdersAndPrepareToFulfill(\r\n                advancedOrders,\r\n                criteriaResolvers,\r\n                true, // Signifies that invalid orders should revert.\r\n                advancedOrders.length,\r\n                recipient\r\n            );\r\n\r\n        // Emit OrdersMatched event, providing an array of matched order hashes.\r\n        _emitOrdersMatched(orderHashes);\r\n\r\n        // Fulfill the orders using the supplied fulfillments and recipient.\r\n        return\r\n            _fulfillAdvancedOrders(\r\n                advancedOrders,\r\n                fulfillments,\r\n                orderHashes,\r\n                recipient,\r\n                containsNonOpen\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to fulfill an arbitrary number of orders, either\r\n     *      full or partial, after validating, adjusting amounts, and applying\r\n     *      criteria resolvers.\r\n     *\r\n     * @param advancedOrders  The orders to match, including a fraction to\r\n     *                        attempt to fill for each order.\r\n     * @param fulfillments    An array of elements allocating offer components\r\n     *                        to consideration components. Note that the final\r\n     *                        amount of each consideration component must be\r\n     *                        zero for a match operation to be considered valid.\r\n     * @param orderHashes     An array of order hashes for each order.\r\n     * @param recipient       The intended recipient for all items that do not\r\n     *                        already have a designated recipient and are not\r\n     *                        used as part of a provided fulfillment.\r\n     * @param containsNonOpen A boolean indicating whether any restricted or\r\n     *                        contract orders are present within the provided\r\n     *                        array of advanced orders.\r\n     *\r\n     * @return executions An array of elements indicating the sequence of\r\n     *                    transfers performed as part of matching the given\r\n     *                    orders.\r\n     */\r\n    function _fulfillAdvancedOrders(\r\n        AdvancedOrder[] memory advancedOrders,\r\n        Fulfillment[] memory fulfillments,\r\n        bytes32[] memory orderHashes,\r\n        address recipient,\r\n        bool containsNonOpen\r\n    ) internal returns (Execution[] memory executions) {\r\n        // Retrieve fulfillments array length and place on the stack.\r\n        uint256 totalFulfillments = fulfillments.length;\r\n\r\n        // Allocate executions by fulfillment and apply them to each execution.\r\n        executions = new Execution[](totalFulfillments);\r\n\r\n        // Skip overflow checks as all for loops are indexed starting at zero.\r\n        unchecked {\r\n            // Track number of filtered executions.\r\n            uint256 totalFilteredExecutions = 0;\r\n\r\n            // Iterate over each fulfillment.\r\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\r\n                /// Retrieve the fulfillment in question.\r\n                Fulfillment memory fulfillment = fulfillments[i];\r\n\r\n                // Derive the execution corresponding with the fulfillment.\r\n                Execution memory execution = _applyFulfillment(\r\n                    advancedOrders,\r\n                    fulfillment.offerComponents,\r\n                    fulfillment.considerationComponents,\r\n                    i\r\n                );\r\n\r\n                // If the execution is filterable...\r\n                if (_isFilterableExecution(execution)) {\r\n                    // Increment total filtered executions.\r\n                    ++totalFilteredExecutions;\r\n                } else {\r\n                    // Otherwise, assign the execution to the executions array.\r\n                    executions[i - totalFilteredExecutions] = execution;\r\n                }\r\n            }\r\n\r\n            // If some number of executions have been filtered...\r\n            if (totalFilteredExecutions != 0) {\r\n                // reduce the total length of the executions array.\r\n                assembly {\r\n                    mstore(\r\n                        executions,\r\n                        sub(mload(executions), totalFilteredExecutions)\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        // Perform final checks and execute orders.\r\n        _performFinalChecksAndExecuteOrders(\r\n            advancedOrders,\r\n            executions,\r\n            orderHashes,\r\n            recipient,\r\n            containsNonOpen\r\n        );\r\n\r\n        // Return the executions array.\r\n        return executions;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to determine whether a given execution is\r\n     *      filterable and may be removed from the executions array. The offerer\r\n     *      and the recipient must be the same address and the item type cannot\r\n     *      indicate a native token transfer.\r\n     *\r\n     * @param execution The execution to check for filterability.\r\n     *\r\n     * @return filterable A boolean indicating whether the execution in question\r\n     *                    can be filtered from the executions array.\r\n     */\r\n    function _isFilterableExecution(\r\n        Execution memory execution\r\n    ) internal pure returns (bool filterable) {\r\n        // Utilize assembly to efficiently determine if execution is filterable.\r\n        assembly {\r\n            // Retrieve the received item referenced by the execution.\r\n            let item := mload(execution)\r\n\r\n            // Determine whether the execution is filterable.\r\n            filterable := and(\r\n                // Determine if offerer and recipient are the same address.\r\n                eq(\r\n                    // Retrieve the recipient's address from the received item.\r\n                    mload(add(item, ReceivedItem_recipient_offset)),\r\n                    // Retrieve the offerer's address from the execution.\r\n                    mload(add(execution, Execution_offerer_offset))\r\n                ),\r\n                // Determine if received item's item type is non-zero, thereby\r\n                // indicating that the execution does not involve native tokens.\r\n                iszero(iszero(mload(item)))\r\n            )\r\n        }\r\n    }\r\n}\r\ncontract Consideration is ConsiderationInterface, OrderCombiner {\r\n    /**\r\n     * @notice Derive and set hashes, reference chainId, and associated domain\r\n     *         separator during deployment.\r\n     *\r\n     * @param conduitController A contract that deploys conduits, or proxies\r\n     *                          that may optionally be used to transfer approved\r\n     *                          ERC20/721/1155 tokens.\r\n     */\r\n    constructor(address conduitController) OrderCombiner(conduitController) {}\r\n\r\n    /**\r\n     * @notice Accept native token transfers during execution that may then be\r\n     *         used to facilitate native token transfers, where any tokens that\r\n     *         remain will be transferred to the caller. Native tokens are only\r\n     *         acceptable mid-fulfillment (and not during basic fulfillment).\r\n     */\r\n    receive() external payable {\r\n        // Ensure the reentrancy guard is currently set to accept native tokens.\r\n        _assertAcceptingNativeTokens();\r\n    }\r\n\r\n    /**\r\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\r\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\r\n     *         item, or an ERC1155 item as consideration. Six permutations are\r\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\r\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\r\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\r\n     *         be eligible for fulfillment via this method, it must contain a\r\n     *         single offer item (though that item may have a greater amount if\r\n     *         the item is not an ERC721). An arbitrary number of \"additional\r\n     *         recipients\" may also be supplied which will each receive native\r\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\r\n     *         to the documentation for a more comprehensive summary of how to\r\n     *         utilize this method and what orders are compatible with it.\r\n     *\r\n     * @param parameters Additional information on the fulfilled order. Note\r\n     *                   that the offerer and the fulfiller must first approve\r\n     *                   this contract (or their chosen conduit if indicated)\r\n     *                   before any tokens can be transferred. Also note that\r\n     *                   contract recipients of ERC1155 consideration items must\r\n     *                   implement `onERC1155Received` to receive those items.\r\n     *\r\n     * @return fulfilled A boolean indicating whether the order has been\r\n     *                   successfully fulfilled.\r\n     */\r\n    function fulfillBasicOrder(\r\n        BasicOrderParameters calldata parameters\r\n    ) external payable override returns (bool fulfilled) {\r\n        // Validate and fulfill the basic order.\r\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\r\n    }\r\n\r\n    /**\r\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\r\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\r\n     *         item, or an ERC1155 item as consideration. Six permutations are\r\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\r\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\r\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\r\n     *         be eligible for fulfillment via this method, it must contain a\r\n     *         single offer item (though that item may have a greater amount if\r\n     *         the item is not an ERC721). An arbitrary number of \"additional\r\n     *         recipients\" may also be supplied which will each receive native\r\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\r\n     *         to the documentation for a more comprehensive summary of how to\r\n     *         utilize this method and what orders are compatible with it. Note\r\n     *         that this function costs less gas than `fulfillBasicOrder` due to\r\n     *         the zero bytes in the function selector (0x00000000) which also\r\n     *         results in earlier function dispatch.\r\n     *\r\n     * @param parameters Additional information on the fulfilled order. Note\r\n     *                   that the offerer and the fulfiller must first approve\r\n     *                   this contract (or their chosen conduit if indicated)\r\n     *                   before any tokens can be transferred. Also note that\r\n     *                   contract recipients of ERC1155 consideration items must\r\n     *                   implement `onERC1155Received` to receive those items.\r\n     *\r\n     * @return fulfilled A boolean indicating whether the order has been\r\n     *                   successfully fulfilled.\r\n     */\r\n    function fulfillBasicOrder_efficient_6GL6yc(\r\n        BasicOrderParameters calldata parameters\r\n    ) external payable override returns (bool fulfilled) {\r\n        // Validate and fulfill the basic order.\r\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\r\n    }\r\n\r\n    /**\r\n     * @notice Fulfill an order with an arbitrary number of items for offer and\r\n     *         consideration. Note that this function does not support\r\n     *         criteria-based orders or partial filling of orders (though\r\n     *         filling the remainder of a partially-filled order is supported).\r\n     *\r\n     * @custom:param order        The order to fulfill. Note that both the\r\n     *                            offerer and the fulfiller must first approve\r\n     *                            this contract (or the corresponding conduit if\r\n     *                            indicated) to transfer any relevant tokens on\r\n     *                            their behalf and that contracts must implement\r\n     *                            `onERC1155Received` to receive ERC1155 tokens\r\n     *                            as consideration.\r\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\r\n     *                            any, to source the fulfiller's token approvals\r\n     *                            from. The zero hash signifies that no conduit\r\n     *                            should be used (and direct approvals set on\r\n     *                            this contract).\r\n     *\r\n     * @return fulfilled A boolean indicating whether the order has been\r\n     *                   successfully fulfilled.\r\n     */\r\n    function fulfillOrder(\r\n        /**\r\n         * @custom:name order\r\n         */\r\n        Order calldata,\r\n        bytes32 fulfillerConduitKey\r\n    ) external payable override returns (bool fulfilled) {\r\n        // Convert order to \"advanced\" order, then validate and fulfill it.\r\n        fulfilled = _validateAndFulfillAdvancedOrder(\r\n            _toAdvancedOrderReturnType(_decodeOrderAsAdvancedOrder)(\r\n                CalldataStart.pptr()\r\n            ),\r\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\r\n            fulfillerConduitKey,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Fill an order, fully or partially, with an arbitrary number of\r\n     *         items for offer and consideration alongside criteria resolvers\r\n     *         containing specific token identifiers and associated proofs.\r\n     *\r\n     * @custom:param advancedOrder     The order to fulfill along with the\r\n     *                                 fraction of the order to attempt to fill.\r\n     *                                 Note that both the offerer and the\r\n     *                                 fulfiller must first approve this\r\n     *                                 contract (or their conduit if indicated\r\n     *                                 by the order) to transfer any relevant\r\n     *                                 tokens on their behalf and that contracts\r\n     *                                 must implement `onERC1155Received` to\r\n     *                                 receive ERC1155 tokens as consideration.\r\n     *                                 Also note that all offer and\r\n     *                                 consideration components must have no\r\n     *                                 remainder after multiplication of the\r\n     *                                 respective amount with the supplied\r\n     *                                 fraction for the partial fill to be\r\n     *                                 considered valid.\r\n     * @custom:param criteriaResolvers An array where each element contains a\r\n     *                                 reference to a specific offer or\r\n     *                                 consideration, a token identifier, and a\r\n     *                                 proof that the supplied token identifier\r\n     *                                 is contained in the merkle root held by\r\n     *                                 the item in question's criteria element.\r\n     *                                 Note that an empty criteria indicates\r\n     *                                 that any (transferable) token identifier\r\n     *                                 on the token in question is valid and\r\n     *                                 that no associated proof needs to be\r\n     *                                 supplied.\r\n     * @param fulfillerConduitKey      A bytes32 value indicating what conduit,\r\n     *                                 if any, to source the fulfiller's token\r\n     *                                 approvals from. The zero hash signifies\r\n     *                                 that no conduit should be used (and\r\n     *                                 direct approvals set on this contract).\r\n     * @param recipient                The intended recipient for all received\r\n     *                                 items, with `address(0)` indicating that\r\n     *                                 the caller should receive the items.\r\n     *\r\n     * @return fulfilled A boolean indicating whether the order has been\r\n     *                   successfully fulfilled.\r\n     */\r\n    function fulfillAdvancedOrder(\r\n        /**\r\n         * @custom:name advancedOrder\r\n         */\r\n        AdvancedOrder calldata,\r\n        /**\r\n         * @custom:name criteriaResolvers\r\n         */\r\n        CriteriaResolver[] calldata,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient\r\n    ) external payable override returns (bool fulfilled) {\r\n        // Validate and fulfill the order.\r\n        fulfilled = _validateAndFulfillAdvancedOrder(\r\n            _toAdvancedOrderReturnType(_decodeAdvancedOrder)(\r\n                CalldataStart.pptr()\r\n            ),\r\n            _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\r\n                CalldataStart.pptr(\r\n                    Offset_fulfillAdvancedOrder_criteriaResolvers\r\n                )\r\n            ),\r\n            fulfillerConduitKey,\r\n            _substituteCallerForEmptyRecipient(recipient)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\r\n     *         of items for offer and consideration. Any order that is not\r\n     *         currently active, has already been fully filled, or has been\r\n     *         cancelled will be omitted. Remaining offer and consideration\r\n     *         items will then be aggregated where possible as indicated by the\r\n     *         supplied offer and consideration component arrays and aggregated\r\n     *         items will be transferred to the fulfiller or to each intended\r\n     *         recipient, respectively. Note that a failing item transfer or an\r\n     *         issue with order formatting will cause the entire batch to fail.\r\n     *         Note that this function does not support criteria-based orders or\r\n     *         partial filling of orders (though filling the remainder of a\r\n     *         partially-filled order is supported).\r\n     *\r\n     * @custom:param orders                    The orders to fulfill. Note that\r\n     *                                         both the offerer and the\r\n     *                                         fulfiller must first approve this\r\n     *                                         contract (or the corresponding\r\n     *                                         conduit if indicated) to transfer\r\n     *                                         any relevant tokens on their\r\n     *                                         behalf and that contracts must\r\n     *                                         implement `onERC1155Received` to\r\n     *                                         receive ERC1155 tokens as\r\n     *                                         consideration.\r\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\r\n     *                                         arrays indicating which offer\r\n     *                                         items to attempt to aggregate\r\n     *                                         when preparing executions. Note\r\n     *                                         that any offer items not included\r\n     *                                         as part of a fulfillment will be\r\n     *                                         sent unaggregated to the caller.\r\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\r\n     *                                         arrays indicating which\r\n     *                                         consideration items to attempt to\r\n     *                                         aggregate when preparing\r\n     *                                         executions.\r\n     * @param fulfillerConduitKey              A bytes32 value indicating what\r\n     *                                         conduit, if any, to source the\r\n     *                                         fulfiller's token approvals from.\r\n     *                                         The zero hash signifies that no\r\n     *                                         conduit should be used (and\r\n     *                                         direct approvals set on this\r\n     *                                         contract).\r\n     * @param maximumFulfilled                 The maximum number of orders to\r\n     *                                         fulfill.\r\n     *\r\n     * @return availableOrders An array of booleans indicating if each order\r\n     *                         with an index corresponding to the index of the\r\n     *                         returned boolean was fulfillable or not.\r\n     * @return executions      An array of elements indicating the sequence of\r\n     *                         transfers performed as part of matching the given\r\n     *                         orders.\r\n     */\r\n    function fulfillAvailableOrders(\r\n        /**\r\n         * @custom:name orders\r\n         */\r\n        Order[] calldata,\r\n        /**\r\n         * @custom:name offerFulfillments\r\n         */\r\n        FulfillmentComponent[][] calldata,\r\n        /**\r\n         * @custom:name considerationFulfillments\r\n         */\r\n        FulfillmentComponent[][] calldata,\r\n        bytes32 fulfillerConduitKey,\r\n        uint256 maximumFulfilled\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        returns (\r\n            bool[] memory /* availableOrders */,\r\n            Execution[] memory /* executions */\r\n        )\r\n    {\r\n        // Convert orders to \"advanced\" orders and fulfill all available orders.\r\n        return\r\n            _fulfillAvailableAdvancedOrders(\r\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\r\n                    CalldataStart.pptr()\r\n                ), // Convert to advanced orders.\r\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\r\n                _toNestedFulfillmentComponentsReturnType(\r\n                    _decodeNestedFulfillmentComponents\r\n                )(\r\n                    CalldataStart.pptr(\r\n                        Offset_fulfillAvailableOrders_offerFulfillments\r\n                    )\r\n                ),\r\n                _toNestedFulfillmentComponentsReturnType(\r\n                    _decodeNestedFulfillmentComponents\r\n                )(\r\n                    CalldataStart.pptr(\r\n                        Offset_fulfillAvailableOrders_considerationFulfillments\r\n                    )\r\n                ),\r\n                fulfillerConduitKey,\r\n                msg.sender,\r\n                maximumFulfilled\r\n            );\r\n    }\r\n\r\n    function fulfillAvailableAdvancedOrders(\r\n        /**\r\n         * @custom:name advancedOrders\r\n         */\r\n        AdvancedOrder[] calldata,\r\n        /**\r\n         * @custom:name criteriaResolvers\r\n         */\r\n        CriteriaResolver[] calldata,\r\n        /**\r\n         * @custom:name offerFulfillments\r\n         */\r\n        FulfillmentComponent[][] calldata,\r\n        /**\r\n         * @custom:name considerationFulfillments\r\n         */\r\n        FulfillmentComponent[][] calldata,\r\n        bytes32 fulfillerConduitKey,\r\n        address recipient,\r\n        uint256 maximumFulfilled\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        returns (\r\n            bool[] memory /* availableOrders */,\r\n            Execution[] memory /* executions */\r\n        )\r\n    {\r\n        // Fulfill all available orders.\r\n        return\r\n            _fulfillAvailableAdvancedOrders(\r\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\r\n                    CalldataStart.pptr()\r\n                ),\r\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\r\n                    CalldataStart.pptr(\r\n                        Offset_fulfillAvailableAdvancedOrders_criteriaResolvers\r\n                    )\r\n                ),\r\n                _toNestedFulfillmentComponentsReturnType(\r\n                    _decodeNestedFulfillmentComponents\r\n                )(\r\n                    CalldataStart.pptr(\r\n                        Offset_fulfillAvailableAdvancedOrders_offerFulfillments\r\n                    )\r\n                ),\r\n                _toNestedFulfillmentComponentsReturnType(\r\n                    _decodeNestedFulfillmentComponents\r\n                )(\r\n                    CalldataStart.pptr(\r\n                        Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts\r\n                    )\r\n                ),\r\n                fulfillerConduitKey,\r\n                _substituteCallerForEmptyRecipient(recipient),\r\n                maximumFulfilled\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Match an arbitrary number of orders, each with an arbitrary\r\n     *         number of items for offer and consideration along with a set of\r\n     *         fulfillments allocating offer components to consideration\r\n     *         components. Note that this function does not support\r\n     *         criteria-based or partial filling of orders (though filling the\r\n     *         remainder of a partially-filled order is supported). Any unspent\r\n     *         offer item amounts or native tokens will be transferred to the\r\n     *         caller.\r\n     *\r\n     * @custom:param orders       The orders to match. Note that both the\r\n     *                            offerer and fulfiller on each order must first\r\n     *                            approve this contract (or their conduit if\r\n     *                            indicated by the order) to transfer any\r\n     *                            relevant tokens on their behalf and each\r\n     *                            consideration recipient must implement\r\n     *                            `onERC1155Received` to receive ERC1155 tokens.\r\n     * @custom:param fulfillments An array of elements allocating offer\r\n     *                            components to consideration components. Note\r\n     *                            that each consideration component must be\r\n     *                            fully met for the match operation to be valid,\r\n     *                            and that any unspent offer items will be sent\r\n     *                            unaggregated to the caller.\r\n     *\r\n     * @return executions An array of elements indicating the sequence of\r\n     *                    transfers performed as part of matching the given\r\n     *                    orders. Note that unspent offer item amounts or native\r\n     *                    tokens will not be reflected as part of this array.\r\n     */\r\n    function matchOrders(\r\n        /**\r\n         * @custom:name orders\r\n         */\r\n        Order[] calldata,\r\n        /**\r\n         * @custom:name fulfillments\r\n         */\r\n        Fulfillment[] calldata\r\n    ) external payable override returns (Execution[] memory /* executions */) {\r\n        // Convert to advanced, validate, and match orders using fulfillments.\r\n        return\r\n            _matchAdvancedOrders(\r\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\r\n                    CalldataStart.pptr()\r\n                ),\r\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\r\n                _toFulfillmentsReturnType(_decodeFulfillments)(\r\n                    CalldataStart.pptr(Offset_matchOrders_fulfillments)\r\n                ),\r\n                msg.sender\r\n            );\r\n    }\r\n    function matchAdvancedOrders(\r\n        /**\r\n         * @custom:name advancedOrders\r\n         */\r\n        AdvancedOrder[] calldata,\r\n        /**\r\n         * @custom:name criteriaResolvers\r\n         */\r\n        CriteriaResolver[] calldata,\r\n        /**\r\n         * @custom:name fulfillments\r\n         */\r\n        Fulfillment[] calldata,\r\n        address recipient\r\n    ) external payable override returns (Execution[] memory /* executions */) {\r\n        // Validate and match the advanced orders using supplied fulfillments.\r\n        return\r\n            _matchAdvancedOrders(\r\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\r\n                    CalldataStart.pptr()\r\n                ),\r\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\r\n                    CalldataStart.pptr(\r\n                        Offset_matchAdvancedOrders_criteriaResolvers\r\n                    )\r\n                ),\r\n                _toFulfillmentsReturnType(_decodeFulfillments)(\r\n                    CalldataStart.pptr(Offset_matchAdvancedOrders_fulfillments)\r\n                ),\r\n                _substituteCallerForEmptyRecipient(recipient)\r\n            );\r\n    }\r\n\r\n    function cancel(\r\n        OrderComponents[] calldata orders\r\n    ) external override returns (bool cancelled) {\r\n        // Cancel the orders.\r\n        cancelled = _cancel(orders);\r\n    }\r\n\r\n    function validate(\r\n        Order[] calldata\r\n    ) external override returns (bool /* validated */) {\r\n        return\r\n            _validate(_toOrdersReturnType(_decodeOrders)(CalldataStart.pptr()));\r\n    }\r\n\r\n    function incrementCounter() external override returns (uint256 newCounter) {\r\n        // Increment current counter for the supplied offerer.  Note that the\r\n        // counter is incremented by a large, quasi-random interval.\r\n        newCounter = _incrementCounter();\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the order hash for a given order.\r\n     *\r\n     * @custom:param order The components of the order.\r\n     *\r\n     * @return orderHash The order hash.\r\n     */\r\n    function getOrderHash(\r\n        /**\r\n         * @custom:name order\r\n         */\r\n        OrderComponents calldata\r\n    ) external view override returns (bytes32 orderHash) {\r\n        CalldataPointer orderPointer = CalldataStart.pptr();\r\n\r\n        // Derive order hash by supplying order parameters along with counter.\r\n        orderHash = _deriveOrderHash(\r\n            _toOrderParametersReturnType(\r\n                _decodeOrderComponentsAsOrderParameters\r\n            )(orderPointer),\r\n            // Read order counter\r\n            orderPointer.offset(OrderParameters_counter_offset).readUint256()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the status of a given order by hash, including whether\r\n     *         the order has been cancelled or validated and the fraction of the\r\n     *         order that has been filled. Since the _orderStatus[orderHash]\r\n     *         does not get set for contract orders, getOrderStatus will always\r\n     *         return (false, false, 0, 0) for those hashes. Note that this\r\n     *         function is susceptible to view reentrancy and so should be used\r\n     *         with care when calling from other contracts.\r\n     *\r\n     * @param orderHash The order hash in question.\r\n     *\r\n     * @return isValidated A boolean indicating whether the order in question\r\n     *                     has been validated (i.e. previously approved or\r\n     *                     partially filled).\r\n     * @return isCancelled A boolean indicating whether the order in question\r\n     *                     has been cancelled.\r\n     * @return totalFilled The total portion of the order that has been filled\r\n     *                     (i.e. the \"numerator\").\r\n     * @return totalSize   The total size of the order that is either filled or\r\n     *                     unfilled (i.e. the \"denominator\").\r\n     */\r\n    function getOrderStatus(\r\n        bytes32 orderHash\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bool isValidated,\r\n            bool isCancelled,\r\n            uint256 totalFilled,\r\n            uint256 totalSize\r\n        )\r\n    {\r\n        // Retrieve the order status using the order hash.\r\n        return _getOrderStatus(orderHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the current counter for a given offerer.\r\n     *\r\n     * @param offerer The offerer in question.\r\n     *\r\n     * @return counter The current counter.\r\n     */\r\n    function getCounter(\r\n        address offerer\r\n    ) external view override returns (uint256 counter) {\r\n        // Return the counter for the supplied offerer.\r\n        counter = _getCounter(offerer);\r\n    }\r\n\r\n    function information()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            string memory version,\r\n            bytes32 domainSeparator,\r\n            address conduitController\r\n        )\r\n    {\r\n        // Return the information for this contract.\r\n        return _information();\r\n    }\r\n\r\n    function getContractOffererNonce(\r\n        address contractOfferer\r\n    ) external view override returns (uint256 nonce) {\r\n        nonce = _contractNonces[contractOfferer];\r\n    }\r\n    function name()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return _name();\r\n    }\r\n}\r\ncontract Saori is Consideration {\r\n    constructor(address conduitController) Consideration(conduitController) {}\r\n    function _name() internal pure override returns (string memory) {\r\n        // Return the name of the contract.\r\n        assembly {\r\n            mstore(0x20, 0x20)\r\n            mstore(0x47, 0x07536561706f7274)\r\n            return(0x20, 0x60)\r\n        }\r\n    }\r\n    function _nameString() internal pure override returns (string memory) {\r\n        // Return the name of the contract.\r\n        return \"Seaport\";\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BadSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotCancelOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationLengthNotEqualToTotalOriginal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CriteriaNotEnabledForItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InexactFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNativeTokensSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid1155BatchTransferEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidCallToConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidContractOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFulfillmentComponentData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeOfferItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidRestrictedOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fulfillmentIndex\",\"type\":\"uint256\"}],\"name\":\"MismatchedFulfillmentOfferAndConsiderationComponents\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"MissingFulfillmentComponentOnAggregation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NativeTokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferAndConsiderationRequiredOnFulfillment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"OrderCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"}],\"name\":\"UnresolvedConsiderationCriteria\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"}],\"name\":\"UnresolvedOfferCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnusedItemParameters\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"CounterIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OrderParameters\",\"name\":\"orderParameters\",\"type\":\"tuple\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"fulfillAdvancedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder_efficient_6GL6yc\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"}],\"name\":\"fulfillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractOfferer\",\"type\":\"address\"}],\"name\":\"getContractOffererNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"information\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"matchAdvancedOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"matchOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Saori", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000304f889b41c450113a05e887d53770ec19e0a7fc", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://795fa12dcf264c149aea8e6dc2797889d754cc244eed8cdc1cdaf886f022bddf"}