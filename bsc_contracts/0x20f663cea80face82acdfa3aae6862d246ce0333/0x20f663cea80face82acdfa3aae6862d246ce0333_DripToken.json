{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dripCustom/dripToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.25;\\n\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'only owner');\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n}\\n\\ncontract Whitelist is Ownable {\\n    mapping(address => bool) public whitelist;\\n\\n    event WhitelistedAddressAdded(address addr);\\n    event WhitelistedAddressRemoved(address addr);\\n\\n    /**\\n     * @dev Throws if called by any account that's not whitelisted.\\n     */\\n    modifier onlyWhitelisted() {\\n        require(whitelist[msg.sender], 'not whitelisted');\\n        _;\\n    }\\n\\n    /**\\n     * @dev add an address to the whitelist\\n     * @param addr address\\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\\n     */\\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\\n        if (!whitelist[addr]) {\\n            whitelist[addr] = true;\\n            emit WhitelistedAddressAdded(addr);\\n            success = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev add addresses to the whitelist\\n     * @param addrs addresses\\n     * @return true if at least one address was added to the whitelist,\\n     * false if all addresses were already in the whitelist\\n     */\\n    function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\\n        for (uint256 i = 0; i < addrs.length; i++) {\\n            if (addAddressToWhitelist(addrs[i])) {\\n                success = true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev remove an address from the whitelist\\n     * @param addr address\\n     * @return true if the address was removed from the whitelist,\\n     * false if the address wasn't in the whitelist in the first place\\n     */\\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\\n        if (whitelist[addr]) {\\n            whitelist[addr] = false;\\n            emit WhitelistedAddressRemoved(addr);\\n            success = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev remove addresses from the whitelist\\n     * @param addrs addresses\\n     * @return true if at least one address was removed from the whitelist,\\n     * false if all addresses weren't in the whitelist in the first place\\n     */\\n    function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\\n        for (uint256 i = 0; i < addrs.length; i++) {\\n            if (removeAddressFromWhitelist(addrs[i])) {\\n                success = true;\\n            }\\n        }\\n    }\\n\\n}\\n\\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\\ninterface BEP20Basic {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is BEP20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev total number of tokens in existence\\n    */\\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender]);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n/**\\n * @title BEP20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract BEP20 is BEP20Basic {\\n    function allowance(address owner, address spender) public view returns (uint256);\\n\\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\\n\\n    function approve(address spender, uint256 value) public returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @title Standard BEP20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * @dev https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract StandardToken is BEP20, BasicToken {\\n\\n    mapping(address => mapping(address => uint256)) internal allowed;\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[_from]);\\n        require(_value <= allowed[_from][msg.sender]);\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     *\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     *\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     *\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\\n        uint oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\\n/**\\n * @title Mintable token\\n * @dev Simple BEP20 Token example, with mintable token creation\\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\\n */\\ncontract MintableToken is StandardToken, Whitelist {\\n    event Mint(address indexed to, uint256 amount);\\n    event MintFinished();\\n\\n    bool public mintingFinished = false;\\n\\n    modifier canMint() {\\n        require(!mintingFinished);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function to mint tokens\\n     * @param _to The address that will receive the minted tokens.\\n     * @param _amount The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address _to, uint256 _amount) onlyWhitelisted canMint public returns (bool) {\\n        require(_to != address(0));\\n        totalSupply_ = totalSupply_.add(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n        emit Mint(_to, _amount);\\n        emit Transfer(address(0), _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to stop minting new tokens.\\n     * @return True if the operation was successful.\\n     */\\n    function finishMinting() onlyWhitelisted canMint public returns (bool) {\\n        mintingFinished = true;\\n        emit MintFinished();\\n        return true;\\n    }\\n}\\n\\ncontract DripToken is MintableToken {\\n\\n    struct Stats {\\n        uint256 txs;\\n        uint256 minted;\\n    }\\n\\n    string public constant name = \\\"DRIP Token\\\";\\n    string public constant symbol = \\\"DRIP\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public constant MAX_INT = 2**256 - 1;\\n    uint256 public constant targetSupply = MAX_INT;\\n    uint256 public totalTxs;\\n    uint256 public players;\\n    uint256 private mintedSupply_;\\n\\n    mapping(address => Stats) private stats;\\n\\n    address public vaultAddress;\\n    uint8 constant internal taxDefault = 10; // 10% tax on transfers\\n\\n    mapping (address => uint8) private _customTaxRate;\\n    mapping (address => bool) private _hasCustomTax;\\n\\n    mapping (address => bool) private _isExcluded;\\n    address[] private _excluded;\\n\\n    event TaxPayed(address from, address vault, uint256 amount);\\n    /**\\n     * @dev default constructor\\n     */\\n    constructor(uint256 _initialMint) Ownable() public {\\n        addAddressToWhitelist(owner);\\n        mint(owner, _initialMint * 1e18);\\n        removeAddressFromWhitelist(owner);\\n    }\\n\\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\\n        vaultAddress = _newVaultAddress;\\n    }\\n\\n    /**\\n     * @dev Function to mint tokens (onlyOwner)\\n     * @param _to The address that will receive the minted tokens.\\n     * @param _amount The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address _to, uint256 _amount) public returns (bool) {\\n\\n        //Never fail, just don't mint if over\\n        if (_amount == 0 || mintedSupply_.add(_amount) > targetSupply) {\\n            return false;\\n        }\\n\\n        //Mint\\n        super.mint(_to, _amount);\\n        mintedSupply_ = mintedSupply_.add(_amount);\\n\\n        if (mintedSupply_ == targetSupply) {\\n            mintingFinished = true;\\n            emit MintFinished();\\n        }\\n\\n        /* Members */\\n        if (stats[_to].txs == 0) {\\n            players += 1;\\n        }\\n\\n        stats[_to].txs += 1;\\n        stats[_to].minted += _amount;\\n\\n        totalTxs += 1;\\n\\n        return true;\\n\\n    }\\n\\n    /**\\n     * @dev Override so that minting cannot be accidentally terminated\\n     */\\n    function finishMinting() onlyOwner canMint public returns (bool) {\\n        return false;\\n    }\\n\\n    function calculateTransactionTax(uint256 _value, uint8 _tax) internal returns (uint256 adjustedValue, uint256 taxAmount){\\n        taxAmount = _value.mul(_tax).div(100);\\n        adjustedValue = _value.mul(SafeMath.sub(100, _tax)).div(100);\\n        return (adjustedValue, taxAmount);\\n    }\\n\\n    /** @dev Transfers (using transferFrom) */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n\\n        (uint256 adjustedValue, uint256 taxAmount) = calculateTransferTaxes(_from, _value);\\n\\n        if (taxAmount > 0){\\n            require(super.transferFrom(_from, vaultAddress, taxAmount));\\n            emit TaxPayed(_from, vaultAddress, taxAmount);\\n        }\\n        require(super.transferFrom(_from, _to, adjustedValue));\\n\\n        /* Members */\\n        if (stats[_to].txs == 0) {\\n            players += 1;\\n        }\\n\\n        stats[_to].txs += 1;\\n        stats[_from].txs += 1;\\n\\n        totalTxs += 1;\\n\\n        return true;\\n\\n\\n    }\\n\\n    /** @dev Transfers */\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n\\n        (uint256 adjustedValue, uint256 taxAmount) = calculateTransferTaxes(msg.sender, _value);\\n\\n        if (taxAmount > 0){\\n            require(super.transfer(vaultAddress, taxAmount));\\n            emit TaxPayed(msg.sender, vaultAddress, taxAmount);\\n        }\\n        require(super.transfer(_to, adjustedValue));\\n\\n        /* Members */\\n        if (stats[_to].txs == 0) {\\n            players += 1;\\n        }\\n\\n        stats[_to].txs += 1;\\n        stats[msg.sender].txs += 1;\\n\\n        totalTxs += 1;\\n\\n        return true;\\n    }\\n\\n    function calculateTransferTaxes(address _from, uint256 _value) public view returns (uint256 adjustedValue, uint256 taxAmount){\\n        adjustedValue = _value;\\n        taxAmount = 0;\\n\\n        if (!_isExcluded[_from]) {\\n            uint8 taxPercent = taxDefault; // set to default tax 10%\\n\\n            // set custom tax rate if applicable\\n            if (_hasCustomTax[_from]){\\n                taxPercent = _customTaxRate[_from];\\n            }\\n\\n            (adjustedValue, taxAmount) = calculateTransactionTax(_value, taxPercent);\\n        }\\n        return (adjustedValue, taxAmount);\\n    }\\n\\n    /** @dev Returns the supply still available to mint */\\n    function remainingMintableSupply() public view returns (uint256) {\\n        return targetSupply.sub(mintedSupply_);\\n    }\\n\\n    /**\\n     * @dev Returns the cap for the token minting.\\n     */\\n    function cap() public view returns (uint256) {\\n        return targetSupply;\\n    }\\n\\n    /**\\n    * @dev total number of minted tokens\\n    */\\n    function mintedSupply() public view returns (uint256) {\\n        return mintedSupply_;\\n    }\\n\\n    /** @dev stats of player, (txs, minted) */\\n    function statsOf(address player) public view returns (uint256, uint256, uint256){\\n        return (balanceOf(player), stats[player].txs, stats[player].minted);\\n    }\\n\\n    ///** @dev Returns the number of tokens minted by the player */\\n    function mintedBy(address player) public view returns (uint256){\\n        return stats[player].minted;\\n    }\\n\\n    function setAccountCustomTax(address account, uint8 taxRate) external onlyOwner() {\\n        require(taxRate >= 0 && taxRate <= 100, \\\"Invalid tax amount\\\");\\n        _hasCustomTax[account] = true;\\n        _customTaxRate[account] = taxRate;\\n    }\\n\\n    function removeAccountCustomTax(address account) external onlyOwner() {\\n        _hasCustomTax[account] = false;\\n    }\\n\\n    function excludeAccount(address account) external onlyOwner() {\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n        _isExcluded[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeAccount(address account) external onlyOwner() {\\n        require(_isExcluded[account], \\\"Account is already excluded\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _isExcluded[account] = false;\\n                delete _excluded[_excluded.length - 1];\\n                break;\\n            }\\n        }\\n    }\\n\\n    function isExcluded(address account) public view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingMintableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"mintedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"taxRate\",\"type\":\"uint8\"}],\"name\":\"setAccountCustomTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAccountCustomTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateTransferTaxes\",\"outputs\":[{\"name\":\"adjustedValue\",\"type\":\"uint256\"},{\"name\":\"taxAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVaultAddress\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialMint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TaxPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "DripToken", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000f4240", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}