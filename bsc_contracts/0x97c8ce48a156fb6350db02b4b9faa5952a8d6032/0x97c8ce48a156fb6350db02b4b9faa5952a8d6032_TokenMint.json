{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenMint.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\nimport \\\"./Token.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract TokenMint is Whitelist {\\r\\n\\r\\n//    using Address for address;\\r\\n\\r\\n    event Mint(address indexed source, address indexed to, uint256 amount);\\r\\n\\r\\n    address public tokenAddress;\\r\\n    Token private token;\\r\\n    address public exchangeableToken;\\r\\n    //TODO maybe add function that can disable exchangeable token/exchange mint\\r\\n\\r\\n    \\r\\n    constructor(address _tokenAddress) Ownable() public {\\r\\n\\r\\n        tokenAddress = _tokenAddress;\\r\\n\\r\\n        //Only the mint should own its paired token\\r\\n        token = Token(tokenAddress);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function mint(address beneficiary, uint256 tokenAmount) onlyWhitelisted public returns (uint256){\\r\\n        require(tokenAmount > 0, \\\"can't mint 0\\\");\\r\\n\\r\\n        if (token.mint(beneficiary, tokenAmount)) {\\r\\n            emit Mint(msg.sender, beneficiary, tokenAmount);\\r\\n            return tokenAmount;\\r\\n        }\\r\\n\\r\\n        return 0;\\r\\n\\r\\n    }\\r\\n    function mintForExchange(address beneficiary, uint256 tokenAmount) internal {\\r\\n        if (token.mint(beneficiary, tokenAmount)) {\\r\\n            emit Mint(msg.sender, beneficiary, tokenAmount);\\r\\n            //return tokenAmount;\\r\\n        }\\r\\n    }\\r\\n    function setExchangeableToken(address _exchangeableToken) public onlyOwner() {\\r\\n        exchangeableToken = _exchangeableToken;\\r\\n    }\\r\\n\\r\\n    function exchangeTokens(uint amount) public {\\r\\n        require(amount > 0, \\\"can't exchange 0 tokens\\\");\\r\\n        address beneficiary = msg.sender;\\r\\n        IERC20(exchangeableToken).transferFrom(beneficiary, address(this), amount);\\r\\n\\r\\n        mintForExchange(beneficiary, amount);\\r\\n    }\\r\\n    \\r\\n    function remainingMintableSupply() public view returns (uint256) {\\r\\n        return token.remainingMintableSupply();\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/Whitelist.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\ncontract Whitelist is Ownable {\\r\\n    mapping(address => bool) public whitelist;\\r\\n\\r\\n    event WhitelistedAddressAdded(address addr);\\r\\n    event WhitelistedAddressRemoved(address addr);\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account that's not whitelisted.\\r\\n     */\\r\\n    modifier onlyWhitelisted() {\\r\\n        require(whitelist[msg.sender], 'not whitelisted');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add an address to the whitelist\\r\\n     * @param addr address\\r\\n     * @return success true if the address was added to the whitelist, false if the address was already in the whitelist\\r\\n     */\\r\\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\\r\\n        if (!whitelist[addr]) {\\r\\n            whitelist[addr] = true;\\r\\n            emit WhitelistedAddressAdded(addr);\\r\\n            success = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add addresses to the whitelist\\r\\n     * @param addrs addresses\\r\\n     * @return success true if at least one address was added to the whitelist,\\r\\n     * false if all addresses were already in the whitelist\\r\\n     */\\r\\n    function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\\r\\n        for (uint256 i = 0; i < addrs.length; i++) {\\r\\n            if (addAddressToWhitelist(addrs[i])) {\\r\\n                success = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an address from the whitelist\\r\\n     * @param addr address\\r\\n     * @return success true if the address was removed from the whitelist,\\r\\n     * false if the address wasn't in the whitelist in the first place\\r\\n     */\\r\\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\\r\\n        if (whitelist[addr]) {\\r\\n            whitelist[addr] = false;\\r\\n            emit WhitelistedAddressRemoved(addr);\\r\\n            success = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove addresses from the whitelist\\r\\n     * @param addrs addresses\\r\\n     * @return success successtrue if at least one address was removed from the whitelist,\\r\\n     * false if all addresses weren't in the whitelist in the first place\\r\\n     */\\r\\n    function removeAddressesFromWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\\r\\n        for (uint256 i = 0; i < addrs.length; i++) {\\r\\n            if (removeAddressFromWhitelist(addrs[i])) {\\r\\n                success = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nabstract contract Token {\\r\\n    function mint(address _to, uint256 _amount) public virtual returns (bool);\\r\\n    function mintedSupply() public virtual view returns (uint256);\\r\\n    function mintedBy(address player) public virtual view returns (uint256);\\r\\n    function remainingMintableSupply() public virtual view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n    address public owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exchangeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeableToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingMintableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeableToken\",\"type\":\"address\"}],\"name\":\"setExchangeableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenMint", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000053804a5b71f82164a0e33dfbb176e16780c38dce", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}