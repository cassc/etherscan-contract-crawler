{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CrosswiseLpFarm11.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ninterface ICrossFactory {\\r\\n    function isPairDelisted(address _address) external view returns (bool);\\r\\n}\\r\\n\\r\\n// File: contracts\\\\interfaces\\\\ICrossRouter02.sol\\r\\n\\r\\ninterface ICrssReferral {\\r\\n    /**\\r\\n     * @dev Record referral.\\r\\n     */\\r\\n    function recordReferral(address user, address referrer) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Record referral commission.\\r\\n     */\\r\\n    function recordReferralCommission(address referrer, uint256 commission)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n     * @dev Get the referrer address that referred the user.\\r\\n     */\\r\\n    function getReferrer(address user) external view returns (address);\\r\\n\\r\\n    function getOutstandingCommission(address _referrer)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 amount);\\r\\n\\r\\n    function debitOutstandingCommission(address _referrer, uint256 _debit)\\r\\n        external;\\r\\n\\r\\n    function getTotalComission(address _referrer)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function updateOperator(address _newPayer) external;\\r\\n}\\r\\n\\r\\ninterface ICRSS is IERC20 {\\r\\n    /* */\\r\\n\\r\\n    function changeFarmAddress(address _address) external;\\r\\n\\r\\n    function controlledMint(uint256 _amount) external;\\r\\n    /* */\\r\\n}\\r\\n\\r\\ninterface ICrossFarm {\\r\\n    function updatePoolDepositFee(uint256 _pid, uint256 _newFee) external;\\r\\n\\r\\n    function updateEarlyWithdrawTax(uint256 _newFee) external;\\r\\n\\r\\n    function depositFeeExclusionStatus(address _address, uint256 _value)\\r\\n        external;\\r\\n\\r\\n    function changeRouter(address _token, address _router) external;\\r\\n\\r\\n    function updateContractAddress(uint256 _id, address _address) external;\\r\\n\\r\\n    function add(\\r\\n        uint256 _allocPoint,\\r\\n        IERC20 _lpToken,\\r\\n        address _token0,\\r\\n        address _token1,\\r\\n        uint256 _depositFee,\\r\\n        uint256 _swapTreshold,\\r\\n        uint256 _lockTime,\\r\\n        uint256 _endBlock,\\r\\n        address _router,\\r\\n        bool _withUpdate\\r\\n    ) external;\\r\\n\\r\\n    // Update the given pool's ERC20 allocation point. Can only be called by the owner.\\r\\n    function set(\\r\\n        uint256 _pid,\\r\\n        uint256 _allocPoint,\\r\\n        uint256 _depositFee,\\r\\n        uint256 _lockTime,\\r\\n        uint256 _swapTreshold,\\r\\n        uint256 _endBlock,\\r\\n        bool _withUpdate\\r\\n    ) external;\\r\\n\\r\\n    function setRewardPerBlock(uint256 _amount, bool _withUpdate) external;\\r\\n\\r\\n    function getAdditionalPoolInfo(uint256 _pid)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 depositFee,\\r\\n            uint256 lockTime,\\r\\n            uint256 fundedUntil,\\r\\n            uint256 allocationPoints,\\r\\n            uint256 totalAllocationPoints,\\r\\n            address lpTokenAddress\\r\\n        );\\r\\n\\r\\n    function userPoolFarmInfo(address _user, uint256 _pid)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 stakedLp,\\r\\n            uint256 claimableRewards,\\r\\n            uint256 timeUntilWithdrawUnlocked,\\r\\n            bool compounding\\r\\n        );\\r\\n}\\r\\n\\r\\n// Farm distributes CRSS and LP token rewards to each user based on staked LP.\\r\\n// this Sushiswap arch Masterchef contract was used as base,\\r\\n// https://github.com/SashimiProject/sashimiswap/blob/master/contracts/MasterChef.sol\\r\\n// Added autocompounding and vesting feature as well as a dozen or so smaller features like locked pools, referral feature, deposit fee etc.\\r\\ncontract CrossLPFarmV2 is Ownable, ReentrancyGuard, ICrossFarm {\\r\\n    //using SafeMath for uint256;\\r\\n    // using SafeERC20 for IERC20;\\r\\n\\r\\n    // Info of each user.\\r\\n    struct UserInfo {\\r\\n        uint256 amount; // How many LP tokens the user has provided.\\r\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\r\\n        //\\r\\n        // We do some fancy math here. Basically, any point in time, the amount of ERC20s\\r\\n        // entitled to a user but is pending to be distributed is:\\r\\n        //\\r\\n        //   pending reward = (user.amount * pool.accERC20PerShare) - user.rewardDebt\\r\\n        //\\r\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\r\\n        //   1. The pool's `accERC20PerShare` (and `lastRewardBlock`) gets updated.\\r\\n        //   2. User receives the pending reward sent to his/her address.\\r\\n        //   3. User's `amount` gets updated.\\r\\n        //   4. User's `rewardDebt` gets updated.\\r\\n        /******** */\\r\\n        uint256 lastLockDeposit;\\r\\n        bool isCompounding; //user setting which continously gives users rewards in lpToken instead of CRSS when turned on\\r\\n        //rewards between compounding and non-compounding subpools are divided based on total deposit percentages for these subpools\\r\\n        /******** */\\r\\n    }\\r\\n\\r\\n    // Info of each pool.\\r\\n    struct PoolInfo {\\r\\n        IERC20 lpToken; // Address of LP token contract.\\r\\n        uint256 allocPoint; // How many allocation points assigned to this pool. ERC20s to distribute per block.\\r\\n        uint256 lastRewardBlock; // Last block number that ERC20s distribution occurs.\\r\\n        uint256 accERC20PerShare; // Accumulated ERC20s per share, times 1e36.\\r\\n        /******** */\\r\\n        uint256 compoundRewards; //current amount of CRSS value for compunding in this pool,\\r\\n        // this CRSS token amount is converted to LP token of the pool in question once swap treshold is reached\\r\\n        //these two are required to correctly split CRSS token rewards, and determine LP rewards\\r\\n        uint256 compoundingTokens; // total number of deposited LP tokens in compound\\r\\n        uint256 nonCompoundingTokens; //total number of deposited LP tokens not compounded\\r\\n        uint256 endBlock;\\r\\n        /******** */\\r\\n    }\\r\\n\\r\\n    struct LpPair {\\r\\n        address token0;\\r\\n        address token1;\\r\\n    }\\r\\n\\r\\n    // ERC20 tokens rewarded per block.\\r\\n    uint256 public rewardPerBlock;\\r\\n\\r\\n    // Info of each pool.\\r\\n    PoolInfo[] public poolInfo;\\r\\n    // Info of each user that stakes LP tokens.\\r\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\r\\n    //stores a router for each token so auto-compound can correctly ajdust for any different token on the same chain\\r\\n    mapping(address => address) public tokenToRouter;\\r\\n    //amount off crss required to initiate conversion from CRSS => LP token\\r\\n    mapping(uint256 => uint256) public poolSwapTreshold;\\r\\n\\r\\n    // pool specific, determines min wait time in blocks before withdrawing after deposit, 0 means its turned off\\r\\n    //when pool lock time is > 0, early withdrawal tax occurs if => user \\\"lastLockDeposit\\\" + pool \\\"poolLocktime\\\" > block.number\\r\\n    mapping(uint256 => uint256) public poolLocktime;\\r\\n\\r\\n    //mapping(address => uint256) public userVestTimes;\\r\\n    mapping(uint256 => LpPair) public pairInfo;\\r\\n\\r\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\r\\n    uint256 public totalAllocPoint = 0;\\r\\n    //penalty for withdrawing before locktime period expired in a pool that has a lock\\r\\n    //demominator 10 000 => 100%, 1 => 0.01%  adjustable, universal, max 20%\\r\\n    uint256 public earlyWithdrawTax;\\r\\n    //too many state vars..\\r\\n    address[] public contractAddresses; //0  crss token, 1  vesting, 2 accountant, 3 CRSS factory\\r\\n    address private adminSetter;\\r\\n    //demominator 10 000 => 100%, 1 => 0.01%  adjustable, max 10%\\r\\n    mapping(uint256 => uint256) public poolDepositFee;\\r\\n    //this calculates deposit fee in reverse for gas savings, 10000 value means user is excluded from fees,9999 is 99.99% adjusted amount or 0.001% tax, 4000 is 60% tax, 9900 is 1% tax\\r\\n    //if 0, pool specific poolDepositFee is applied\\r\\n    mapping(address => uint256) public userAdjustedDeposit;\\r\\n\\r\\n    event PoolUpdated(\\r\\n        PoolInfo pool,\\r\\n        uint256 lockTime,\\r\\n        uint256 swapTreshold,\\r\\n        uint256 depositFee\\r\\n    );\\r\\n    event PoolCreated(\\r\\n        PoolInfo pool,\\r\\n        uint256 lockTime,\\r\\n        uint256 swapTreshold,\\r\\n        uint256 depositFee\\r\\n    );\\r\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event EmergencyWithdraw(\\r\\n        address indexed user,\\r\\n        uint256 indexed pid,\\r\\n        uint256 amount\\r\\n    );\\r\\n   function changeAdminSetter(address _newAdmin) external {\\r\\n        require(msg.sender == adminSetter, \\\"fCRSS:Restricted access\\\");\\r\\n        adminSetter = _newAdmin;\\r\\n    }\\r\\n\\r\\n    function changeControlCenter(address _address) public  {\\r\\n        require(\\r\\n            _msgSender() == adminSetter || _msgSender() == owner(),\\r\\n            \\\"CRSS:Only admin setter and CC\\\"\\r\\n        );\\r\\n        \\r\\n        require(owner() != _address, \\\"fCRSS:Restricted access\\\");\\r\\n        _transferOwnership(_address);\\r\\n    }\\r\\n\\r\\n    function getAdminSetter()public view returns(address){\\r\\n        return adminSetter;\\r\\n    }\\r\\n\\r\\n    constructor(address[] memory _contractAddresses,address _adminSetter) ReentrancyGuard() Ownable(){\\r\\n        for (uint256 i = 0; i < _contractAddresses.length; i++) {\\r\\n            contractAddresses.push(_contractAddresses[i]);\\r\\n        }\\r\\n        IERC20(_contractAddresses[0]).approve(\\r\\n            _contractAddresses[1],\\r\\n            type(uint256).max\\r\\n        );\\r\\n        adminSetter = _adminSetter;\\r\\n    }\\r\\n\\r\\n    // Add a new lp to the pool. Can only be called by the owner. block.timestamp\\r\\n    // DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\r\\n    function add(\\r\\n        uint256 _allocPoint,\\r\\n        IERC20 _lpToken,\\r\\n        address _token0,\\r\\n        address _token1,\\r\\n        uint256 _depositFee,\\r\\n        uint256 _swapTreshold,\\r\\n        uint256 _lockTime,\\r\\n        uint256 _endBlock,\\r\\n        address _router,\\r\\n        bool _withUpdate\\r\\n    ) public onlyOwner {\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n        totalAllocPoint += _allocPoint;\\r\\n        uint256 index = poolLength();\\r\\n        poolInfo.push(\\r\\n            PoolInfo({\\r\\n                lpToken: _lpToken,\\r\\n                allocPoint: _allocPoint,\\r\\n                lastRewardBlock: block.number,\\r\\n                accERC20PerShare: 0,\\r\\n                compoundRewards: 0,\\r\\n                compoundingTokens: 0,\\r\\n                nonCompoundingTokens: 0,\\r\\n                endBlock: _endBlock\\r\\n            })\\r\\n        );\\r\\n\\r\\n        poolDepositFee[index] = _depositFee;\\r\\n        poolSwapTreshold[index] = _swapTreshold;\\r\\n        poolLocktime[index] = _lockTime;\\r\\n        pairInfo[index] = LpPair({token0: _token0, token1: _token1});\\r\\n        tokenToRouter[address(_lpToken)] = _router;\\r\\n\\r\\n        _lpToken.approve(contractAddresses[1], type(uint256).max);\\r\\n        //_lpToken.approve(_router, type(uint256).max);\\r\\n        emit PoolCreated(\\r\\n            poolInfo[poolInfo.length - 1],\\r\\n            _lockTime,\\r\\n            _swapTreshold,\\r\\n            _depositFee\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Update some of the given pool's parameters. Can only be called by the owner.\\r\\n    function set(\\r\\n        uint256 _pid,\\r\\n        uint256 _allocPoint,\\r\\n        uint256 _depositFee,\\r\\n        uint256 _lockTime,\\r\\n        uint256 _swapTreshold,\\r\\n        uint256 _endBlock,\\r\\n        bool _withUpdate\\r\\n    ) public onlyOwner {\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n        totalAllocPoint =\\r\\n            (totalAllocPoint + _allocPoint) -\\r\\n            poolInfo[_pid].allocPoint;\\r\\n        poolInfo[_pid].allocPoint = _allocPoint;\\r\\n        poolInfo[_pid].endBlock = _endBlock;\\r\\n        poolDepositFee[_pid] = _depositFee;\\r\\n        poolSwapTreshold[_pid] = _swapTreshold;\\r\\n        poolLocktime[_pid] = _lockTime;\\r\\n\\r\\n        emit PoolUpdated(poolInfo[_pid], _lockTime, _swapTreshold, _depositFee);\\r\\n    }\\r\\n\\r\\n    //mass update of all pools just before changing reward per block is very important in order not to give higher rewards than intended in updatePool()\\r\\n    function setRewardPerBlock(uint256 _amount, bool _withUpdate)\\r\\n        external\\r\\n        override(ICrossFarm)\\r\\n        onlyOwner\\r\\n    {\\r\\n        //require(msg.sender == contractAddresses[0]);\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n\\r\\n        rewardPerBlock = _amount;\\r\\n    }\\r\\n\\r\\n    function getCorePoolInfo(uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (PoolInfo memory)\\r\\n    {\\r\\n        return poolInfo[_pid];\\r\\n    }\\r\\n\\r\\n    function getAdditionalPoolInfo(uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 depositFee,\\r\\n            uint256 lockTime,\\r\\n            uint256 fundedUntil,\\r\\n            uint256 allocationPoints,\\r\\n            uint256 totalAllocationPoints,\\r\\n            address lpTokenAddress\\r\\n        )\\r\\n    {\\r\\n        PoolInfo memory pool = poolInfo[_pid];\\r\\n\\r\\n        depositFee = poolDepositFee[_pid];\\r\\n        lockTime = poolLocktime[_pid];\\r\\n        uint256 _endBlock = poolInfo[_pid].endBlock;\\r\\n        if (_endBlock > block.number) {\\r\\n            fundedUntil = _endBlock - block.number;\\r\\n        } else if (_endBlock == 0) {\\r\\n            fundedUntil = type(uint256).max;\\r\\n        } else {\\r\\n            fundedUntil = 0;\\r\\n        }\\r\\n        allocationPoints = pool.allocPoint;\\r\\n        totalAllocationPoints = totalAllocPoint;\\r\\n        lpTokenAddress = address(pool.lpToken);\\r\\n    }\\r\\n\\r\\n    function userPoolFarmInfo(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint256 stakedLp,\\r\\n            uint256 claimableRewards,\\r\\n            uint256 timeUntilWithdrawUnlocked,\\r\\n            bool compounding\\r\\n        )\\r\\n    {\\r\\n        UserInfo memory user = userInfo[_pid][_user];\\r\\n\\r\\n        stakedLp = user.amount;\\r\\n        claimableRewards = userPending(_user, _pid);\\r\\n\\r\\n        timeUntilWithdrawUnlocked = user.lastLockDeposit + poolLocktime[_pid] <=\\r\\n            block.number\\r\\n            ? 0\\r\\n            : (user.lastLockDeposit + poolLocktime[_pid]) - block.number;\\r\\n        compounding = user.isCompounding;\\r\\n    }\\r\\n\\r\\n    function getPoolDepositFee(uint256 _pid) public view returns (uint256) {\\r\\n        return poolDepositFee[_pid];\\r\\n    }\\r\\n\\r\\n    function getPoolLocktime(uint256 _pid) public view returns (uint256) {\\r\\n        return poolLocktime[_pid];\\r\\n    }\\r\\n\\r\\n    function poolFundedUntil(uint256 _pid) public view returns (uint256) {\\r\\n        return poolInfo[_pid].endBlock - block.number;\\r\\n    }\\r\\n\\r\\n    // Number of LP pools\\r\\n    function poolLength() public view returns (uint256) {\\r\\n        return poolInfo.length;\\r\\n    }\\r\\n\\r\\n    function isUserCompounding(uint256 _pid, address _address)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return userInfo[_pid][_address].isCompounding;\\r\\n    }\\r\\n\\r\\n    // View function to see deposited LP for a user.\\r\\n    function deposited(uint256 _pid, address _user)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return userInfo[_pid][_user].amount;\\r\\n    }\\r\\n\\r\\n    function extendedWithdraw(uint256 _pid, uint256 _amount)\\r\\n        public\\r\\n        nonReentrant\\r\\n    {\\r\\n        if (userInfo[_pid][msg.sender].isCompounding) {\\r\\n            compoundWithdraw(_pid, _amount);\\r\\n        } else {\\r\\n            withdraw(_pid, _amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function extendedDeposit(uint256 _pid, uint256 _amount)\\r\\n        public\\r\\n        nonReentrant\\r\\n    {\\r\\n        require(\\r\\n            ICrossFactory(contractAddresses[3]).isPairDelisted(\\r\\n                address(poolInfo[_pid].lpToken)\\r\\n            ) != true,\\r\\n            \\\"fCRRS:Can't deposit to delisted pair\\\"\\r\\n        );\\r\\n        require(_amount > 0, \\\"fCRRS:Zero value deposit\\\");\\r\\n        if (userInfo[_pid][msg.sender].isCompounding) {\\r\\n            compoundDeposit(_pid, _amount);\\r\\n        } else {\\r\\n            deposit(_pid, _amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function userPending(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 pendingReward)\\r\\n    {\\r\\n        if (userInfo[_pid][_user].isCompounding == true) {\\r\\n            pendingReward = getPendingCompoundRewards(_pid, _user);\\r\\n        } else {\\r\\n            pendingReward = pendingCRSS(_pid, _user);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimRewards(uint256 _pid, uint32 _vestTime) public nonReentrant {\\r\\n        if (userInfo[_pid][msg.sender].isCompounding) {\\r\\n            claimCompoundRewards(_pid, msg.sender, _vestTime);\\r\\n        } else {\\r\\n            normalClaimRewards(_pid, msg.sender, _vestTime);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function massClaim(uint256[] memory _pids, uint32 _vestTime)\\r\\n        public\\r\\n        nonReentrant\\r\\n    {\\r\\n        for (uint256 i = 0; i < _pids.length; i++) {\\r\\n            if (isUserCompounding(_pids[i], msg.sender)) {\\r\\n                claimCompoundRewards(_pids[i], msg.sender, _vestTime);\\r\\n            } else {\\r\\n                normalClaimRewards(_pids[i], msg.sender, _vestTime);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Update reward variables for all pools. Be careful of gas spending!\\r\\n    function massUpdatePools() public {\\r\\n        uint256 length = poolInfo.length;\\r\\n        for (uint256 pid = 0; pid < length; ++pid) {\\r\\n            if (poolInfo[pid].allocPoint != 0) {\\r\\n                updatePool(pid);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // View function to see pending ERC20s for a user.\\r\\n    function pendingCRSS(uint256 _pid, address _user)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        PoolInfo memory pool = poolInfo[_pid];\\r\\n        UserInfo memory user = userInfo[_pid][_user];\\r\\n        uint256 accERC20PerShare = pool.accERC20PerShare;\\r\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\r\\n        uint256 blockNumber = block.number;\\r\\n        if (pool.endBlock <= blockNumber && pool.endBlock != 0) {\\r\\n            return (user.amount * accERC20PerShare) / 1e36 - user.rewardDebt;\\r\\n        }\\r\\n        if (blockNumber > pool.lastRewardBlock && lpSupply != 0) {\\r\\n            uint256 nrOfBlocks = blockNumber - pool.lastRewardBlock;\\r\\n            uint256 erc20Reward = (nrOfBlocks *\\r\\n                rewardPerBlock *\\r\\n                pool.allocPoint) / totalAllocPoint;\\r\\n            accERC20PerShare =\\r\\n                accERC20PerShare +\\r\\n                ((erc20Reward * 1e36) / lpSupply);\\r\\n        }\\r\\n\\r\\n        return\\r\\n            (((user.amount * accERC20PerShare) / 1e36 - user.rewardDebt) * 3) /\\r\\n            10;\\r\\n    }\\r\\n\\r\\n    function getPendingCompoundRewards(uint256 _pid, address _user)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 reward)\\r\\n    {\\r\\n        UserInfo memory user = userInfo[_pid][_user];\\r\\n        if (user.isCompounding == true || user.amount > 0) {\\r\\n            PoolInfo memory pool = poolInfo[_pid];\\r\\n            uint256 compoundRewards = IERC20(address(pool.lpToken)).balanceOf(\\r\\n                address(this)\\r\\n            ) -\\r\\n                pool.compoundingTokens -\\r\\n                pool.nonCompoundingTokens;\\r\\n            uint256 userReward = (user.amount * compoundRewards) /\\r\\n                pool.compoundingTokens -\\r\\n                user.rewardDebt;\\r\\n            reward = (userReward * 3) / 10;\\r\\n            return reward;\\r\\n        } else return 0;\\r\\n    }\\r\\n\\r\\n    // Update reward variables of the given pool to be up-to-date.\\r\\n    function updatePool(uint256 _pid) public {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n\\r\\n        uint256 currentBlock = block.number;\\r\\n        if (pool.endBlock <= currentBlock && pool.endBlock != 0) {\\r\\n            return;\\r\\n        }\\r\\n        if (currentBlock <= pool.lastRewardBlock) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        //uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\r\\n        /*if (lpSupply == 0) {\\r\\n            pool.lastRewardBlock = currentBlock;\\r\\n            return;\\r\\n        }*/\\r\\n\\r\\n        uint256 compoundedLpTokens = pool.compoundingTokens;\\r\\n        uint256 nonCompoundedLpTokens = pool.nonCompoundingTokens;\\r\\n        uint256 totalActiveDeposit = compoundedLpTokens + nonCompoundedLpTokens;\\r\\n        if (totalActiveDeposit == 0) {\\r\\n            pool.lastRewardBlock = currentBlock;\\r\\n            return;\\r\\n        }\\r\\n        uint256 nrOfBlocks = currentBlock - pool.lastRewardBlock;\\r\\n        uint256 totalCrssReward = (nrOfBlocks *\\r\\n            rewardPerBlock *\\r\\n            pool.allocPoint) / totalAllocPoint;\\r\\n        uint256 nonCompoundReward = (totalCrssReward * nonCompoundedLpTokens) /\\r\\n            totalActiveDeposit;\\r\\n        uint256 compoundReward = (totalCrssReward * compoundedLpTokens) /\\r\\n            totalActiveDeposit;\\r\\n        uint256 crssToMint = compoundReward + nonCompoundReward;\\r\\n        ICRSS(contractAddresses[0]).controlledMint(crssToMint);\\r\\n        /* */\\r\\n        if (nonCompoundedLpTokens > 0) {\\r\\n            pool.accERC20PerShare =\\r\\n                pool.accERC20PerShare +\\r\\n                ((nonCompoundReward * 1e36) / nonCompoundedLpTokens);\\r\\n        }\\r\\n        uint256 newCompRewards = pool.compoundRewards + compoundReward;\\r\\n        pool.compoundRewards = newCompRewards;\\r\\n        pool.lastRewardBlock = block.number;\\r\\n    }\\r\\n\\r\\n    function claimCompoundRewards(\\r\\n        uint256 _pid,\\r\\n        address _user,\\r\\n        uint32 _vestTime\\r\\n    ) private {\\r\\n        require(\\r\\n            _vestTime > 0 && _vestTime <= 12,\\r\\n            \\\"fCRSS:Wrong vest time selected\\\"\\r\\n        );\\r\\n        updatePool(_pid);\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n\\r\\n        //if pool specific swap treshold is reached, initiate required token swaps and execute addLiquidity() to get new LP tokens\\r\\n        if (poolSwapTreshold[_pid] <= pool.compoundRewards) {\\r\\n            address crssToken = contractAddresses[0];\\r\\n            address poolRouterAddress = tokenToRouter[address(pool.lpToken)];\\r\\n            LpPair memory lpInfo = pairInfo[_pid];\\r\\n            (address token0, address token1) = (lpInfo.token0, lpInfo.token1);\\r\\n            if (token0 == crssToken) {\\r\\n                uint256 poolCompoundRewards = pool.compoundRewards;\\r\\n                pool.compoundRewards = 0;\\r\\n                address[] memory path = new address[](2);\\r\\n\\r\\n                path[0] = crssToken;\\r\\n                path[1] = token1;\\r\\n                (bool success0, ) = poolRouterAddress.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        0x5c11d795,\\r\\n                        poolCompoundRewards / 2,\\r\\n                        0,\\r\\n                        path,\\r\\n                        address(this),\\r\\n                        block.timestamp + 100\\r\\n                    )\\r\\n                );\\r\\n\\r\\n                require(success0, \\\"fCRSS:Swap call failed\\\");\\r\\n                (bool success1, ) = poolRouterAddress.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        0xe8e33700,\\r\\n                        crssToken,\\r\\n                        token1,\\r\\n                        poolCompoundRewards / 2,\\r\\n                        IERC20(token1).balanceOf(address(this)),\\r\\n                        0,\\r\\n                        0,\\r\\n                        address(this),\\r\\n                        block.timestamp + 100\\r\\n                    )\\r\\n                );\\r\\n                require(success1, \\\"fCRSS:Add liquidity call failed\\\");\\r\\n            } else if (token1 == crssToken) {\\r\\n                uint256 poolCompoundRewards = pool.compoundRewards;\\r\\n                pool.compoundRewards = 0;\\r\\n\\r\\n                address[] memory path = new address[](2);\\r\\n\\r\\n                path[0] = crssToken;\\r\\n                path[1] = token0;\\r\\n                (bool success0, ) = poolRouterAddress.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        0x5c11d795,\\r\\n                        poolCompoundRewards / 2,\\r\\n                        0,\\r\\n                        path,\\r\\n                        address(this),\\r\\n                        block.timestamp + 100\\r\\n                    )\\r\\n                );\\r\\n\\r\\n                require(success0, \\\"fCRSS:Swap call failed\\\");\\r\\n                (bool success1, ) = poolRouterAddress.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        0xe8e33700,\\r\\n                        crssToken,\\r\\n                        token0,\\r\\n                        poolCompoundRewards / 2,\\r\\n                        IERC20(token0).balanceOf(address(this)),\\r\\n                        0,\\r\\n                        0,\\r\\n                        address(this),\\r\\n                        block.timestamp + 100\\r\\n                    )\\r\\n                );\\r\\n                require(success1, \\\"fCRSS:Add liquidity call failed\\\");\\r\\n            } else {\\r\\n                address wBnb = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\r\\n                {\\r\\n                    address[] memory path = new address[](2);\\r\\n\\r\\n                    path[0] = crssToken;\\r\\n                    path[1] = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\r\\n                    (bool success0, ) = tokenToRouter[wBnb].call(\\r\\n                        abi.encodeWithSelector(\\r\\n                            0x5c11d795,\\r\\n                            pool.compoundRewards,\\r\\n                            0,\\r\\n                            path,\\r\\n                            address(this),\\r\\n                            block.timestamp + 100\\r\\n                        )\\r\\n                    );\\r\\n\\r\\n                    require(success0, \\\"fCRSS:Swap call failed\\\");\\r\\n                }\\r\\n\\r\\n                pool.compoundRewards = 0;\\r\\n                uint256 amountBnb = IERC20(wBnb).balanceOf(address(this));\\r\\n                if (token0 != wBnb) {\\r\\n                    address tokenRouterAddress0 = tokenToRouter[token0];\\r\\n                    address routerAddress0 = tokenRouterAddress0 != address(0)\\r\\n                        ? tokenRouterAddress0\\r\\n                        : poolRouterAddress;\\r\\n                    address[] memory path = new address[](2);\\r\\n\\r\\n                    path[0] = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\r\\n                    path[1] = token0;\\r\\n                    (bool success0, ) = routerAddress0.call(\\r\\n                        abi.encodeWithSelector(\\r\\n                            0x5c11d795,\\r\\n                            amountBnb / 2,\\r\\n                            0,\\r\\n                            path,\\r\\n                            address(this),\\r\\n                            block.timestamp + 100\\r\\n                        )\\r\\n                    );\\r\\n\\r\\n                    require(success0, \\\"fCRSS:Swap call failed\\\");\\r\\n                }\\r\\n                if (token1 != wBnb) {\\r\\n                    address tokenRouterAddress1 = tokenToRouter[token1];\\r\\n                    address routerAddress1 = tokenRouterAddress1 != address(0)\\r\\n                        ? tokenRouterAddress1\\r\\n                        : poolRouterAddress;\\r\\n                    address[] memory path = new address[](2);\\r\\n\\r\\n                    path[0] = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\r\\n                    path[1] = token1;\\r\\n                    (bool success0, ) = routerAddress1.call(\\r\\n                        abi.encodeWithSelector(\\r\\n                            0x5c11d795,\\r\\n                            amountBnb / 2,\\r\\n                            0,\\r\\n                            path,\\r\\n                            address(this),\\r\\n                            block.timestamp + 100\\r\\n                        )\\r\\n                    );\\r\\n\\r\\n                    require(success0, \\\"fCRSS:Swap call failed\\\");\\r\\n                }\\r\\n                (bool success1, ) = poolRouterAddress.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        0xe8e33700,\\r\\n                        token0,\\r\\n                        token1,\\r\\n                        IERC20(token0).balanceOf(address(this)),\\r\\n                        IERC20(token1).balanceOf(address(this)),\\r\\n                        0,\\r\\n                        0,\\r\\n                        address(this),\\r\\n                        block.timestamp + 100\\r\\n                    )\\r\\n                );\\r\\n                require(success1, \\\"fCRSS:Add liquidity call failed\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 totalLp = IERC20(address(pool.lpToken)).balanceOf(\\r\\n            address(this)\\r\\n        );\\r\\n        uint256 compoundRewards = (totalLp - pool.compoundingTokens) -\\r\\n            pool.nonCompoundingTokens;\\r\\n\\r\\n        uint256 userReward = (user.amount * compoundRewards) /\\r\\n            pool.compoundingTokens -\\r\\n            user.rewardDebt;\\r\\n        if (userReward > 0) {\\r\\n            ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                _pid,\\r\\n                _user,\\r\\n                userReward,\\r\\n                address(pool.lpToken),\\r\\n                uint64(block.timestamp),\\r\\n                _vestTime\\r\\n            );\\r\\n        }\\r\\n        user.rewardDebt =\\r\\n            (user.amount * (compoundRewards - userReward)) /\\r\\n            pool.compoundingTokens;\\r\\n    }\\r\\n\\r\\n    function normalClaimRewards(\\r\\n        uint256 _pid,\\r\\n        address _user,\\r\\n        uint32 _vestTime\\r\\n    ) private {\\r\\n        require(\\r\\n            _vestTime > 0 && _vestTime <= 12,\\r\\n            \\\"fCRSS:Wrong vest time selected\\\"\\r\\n        );\\r\\n\\r\\n        updatePool(_pid);\\r\\n        uint256 poolAccPerShare = poolInfo[_pid].accERC20PerShare;\\r\\n        UserInfo storage user = userInfo[_pid][_user];\\r\\n        uint256 pendingAmount = (user.amount * poolAccPerShare) /\\r\\n            1e36 -\\r\\n            user.rewardDebt;\\r\\n\\r\\n        if (pendingAmount > 0) {\\r\\n            ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                _pid,\\r\\n                _user,\\r\\n                pendingAmount,\\r\\n                contractAddresses[0],\\r\\n                uint64(block.timestamp),\\r\\n                _vestTime\\r\\n            );\\r\\n        }\\r\\n\\r\\n        user.rewardDebt = (user.amount * poolAccPerShare) / 1e36;\\r\\n    }\\r\\n\\r\\n    function switchCollectOption(uint256 _pid) public nonReentrant {\\r\\n        address _user = _msgSender();\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][_user];\\r\\n        updatePool(_pid);\\r\\n\\r\\n        uint256 depositedAmount = user.amount;\\r\\n        if (user.isCompounding) {\\r\\n            uint256 lpRewards = (IERC20(pool.lpToken).balanceOf(address(this)) -\\r\\n                pool.nonCompoundingTokens) - pool.compoundingTokens;\\r\\n            uint256 userReward = (depositedAmount * lpRewards) /\\r\\n                pool.compoundingTokens -\\r\\n                user.rewardDebt;\\r\\n\\r\\n            if (userReward > 0) {\\r\\n                ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                        _pid,\\r\\n                        _user,\\r\\n                        userReward,\\r\\n                        address(pool.lpToken),\\r\\n                        uint64(block.timestamp),\\r\\n                        uint32(1)\\r\\n                    );\\r\\n            }\\r\\n            if (depositedAmount > 0) {\\r\\n                pool.nonCompoundingTokens += depositedAmount;\\r\\n                pool.compoundingTokens -= depositedAmount;\\r\\n            }\\r\\n            user.rewardDebt = (depositedAmount * pool.accERC20PerShare) / 1e36;\\r\\n            user.isCompounding = false;\\r\\n        } else {\\r\\n            uint256 pendingAmount = (user.amount * pool.accERC20PerShare) /\\r\\n                1e36 -\\r\\n                user.rewardDebt;\\r\\n            if (pendingAmount > 0) {\\r\\n                //uint32 oneMonth = 6 * 6 * 24 * 3044;\\r\\n                ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                        _pid,\\r\\n                        _user,\\r\\n                        pendingAmount,\\r\\n                        contractAddresses[0],\\r\\n                        uint64(block.timestamp),\\r\\n                        uint32(1)\\r\\n                    );\\r\\n                //erc20.transfer(vestingContract, pendingAmount);\\r\\n            }\\r\\n            if (depositedAmount > 0) {\\r\\n                pool.compoundingTokens += depositedAmount;\\r\\n                pool.nonCompoundingTokens -= depositedAmount;\\r\\n            }\\r\\n\\r\\n            uint256 lpRewards = (IERC20(pool.lpToken).balanceOf(address(this)) -\\r\\n                pool.nonCompoundingTokens) - pool.compoundingTokens;\\r\\n            user.rewardDebt =\\r\\n                (depositedAmount * (lpRewards - lpRewards)) /\\r\\n                pool.compoundingTokens;\\r\\n            user.isCompounding = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Deposit LP tokens to Farm for ERC20 allocation.\\r\\n    function deposit(uint256 _pid, uint256 _amount) private {\\r\\n        require(_amount > 0, \\\"fCRRS:Zero value deposit\\\");\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        updatePool(_pid);\\r\\n\\r\\n        pool.lpToken.transferFrom(address(msg.sender), address(this), _amount);\\r\\n\\r\\n        uint256 adjustedAmount = _amount;\\r\\n        uint256 userFeeAdjusted = userAdjustedDeposit[msg.sender];\\r\\n        uint256 depositTaxAmount = userFeeAdjusted == 0\\r\\n            ? (_amount * poolDepositFee[_pid]) / 10000\\r\\n            : _amount - ((_amount * userFeeAdjusted) / 10000);\\r\\n        adjustedAmount -= depositTaxAmount;\\r\\n        if (depositTaxAmount > 0) {\\r\\n            IERC20(pool.lpToken).transfer(\\r\\n                contractAddresses[2],\\r\\n                depositTaxAmount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (poolLocktime[_pid] > 0) {\\r\\n            user.lastLockDeposit = block.number;\\r\\n        } else user.lastLockDeposit = 0;\\r\\n\\r\\n        if (user.amount > 0) {\\r\\n            uint256 pendingAmount = (user.amount * pool.accERC20PerShare) /\\r\\n                1e36 -\\r\\n                user.rewardDebt;\\r\\n            if (pendingAmount > 0) {\\r\\n                //uint32 oneMonth = 6 * 6 * 24 * 3044;\\r\\n                ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                        _pid,\\r\\n                        msg.sender,\\r\\n                        pendingAmount,\\r\\n                        contractAddresses[0],\\r\\n                        uint64(block.timestamp),\\r\\n                        uint32(1)\\r\\n                    );\\r\\n            }\\r\\n        }\\r\\n        pool.nonCompoundingTokens += adjustedAmount;\\r\\n        user.amount += adjustedAmount;\\r\\n        user.rewardDebt = (user.amount * pool.accERC20PerShare) / 1e36;\\r\\n\\r\\n        emit Deposit(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    function compoundDeposit(uint256 _pid, uint256 _amount) private {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        require(_amount > 0, \\\"fCRRS:Zero value deposit\\\");\\r\\n\\r\\n        updatePool(_pid);\\r\\n        pool.lpToken.transferFrom(address(msg.sender), address(this), _amount);\\r\\n        uint256 lpRewards = (IERC20(address(pool.lpToken)).balanceOf(\\r\\n            address(this)\\r\\n        ) - pool.compoundingTokens) - pool.nonCompoundingTokens;\\r\\n        uint256 userReward = (user.amount * lpRewards) /\\r\\n            pool.compoundingTokens -\\r\\n            user.rewardDebt;\\r\\n\\r\\n        uint256 adjustedAmount = _amount;\\r\\n        uint256 depositTaxAmount = userAdjustedDeposit[msg.sender] == 0\\r\\n            ? (_amount * poolDepositFee[_pid]) / 10000\\r\\n            : _amount - ((_amount * userAdjustedDeposit[msg.sender]) / 10000);\\r\\n        adjustedAmount -= depositTaxAmount;\\r\\n        if (depositTaxAmount > 0) {\\r\\n            IERC20(pool.lpToken).transfer(\\r\\n                contractAddresses[2],\\r\\n                depositTaxAmount\\r\\n            );\\r\\n        }\\r\\n        if (poolLocktime[_pid] > 0) {\\r\\n            user.lastLockDeposit = block.number;\\r\\n        } else user.lastLockDeposit = 0;\\r\\n        pool.compoundingTokens += adjustedAmount;\\r\\n        user.amount += adjustedAmount;\\r\\n        //uint32 oneMonth = 6 * 6 * 24 * 3044; //1 month == 30.44 days (30.4375)\\r\\n\\r\\n        if (userReward > 0) {\\r\\n            ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                _pid,\\r\\n                msg.sender,\\r\\n                userReward,\\r\\n                address(pool.lpToken),\\r\\n                uint64(block.timestamp),\\r\\n                uint32(1)\\r\\n            );\\r\\n        }\\r\\n        user.rewardDebt =\\r\\n            (user.amount * (lpRewards - userReward)) /\\r\\n            pool.compoundingTokens;\\r\\n\\r\\n        emit Deposit(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    // Withdraw LP tokens from Farm.\\r\\n    function withdraw(uint256 _pid, uint256 _amount) private {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        require(user.amount >= _amount, \\\"fCRRS:Withdraw exceeds balance\\\");\\r\\n        require(_amount > 0, \\\"fCRRS:Zero value withdraw\\\");\\r\\n        updatePool(_pid);\\r\\n        uint256 pendingAmount = (user.amount * pool.accERC20PerShare) /\\r\\n            1e36 -\\r\\n            user.rewardDebt;\\r\\n\\r\\n        if (_amount > 0) {\\r\\n            user.amount -= _amount;\\r\\n            pool.nonCompoundingTokens -= _amount;\\r\\n            uint256 poolLockLength = getPoolLocktime(_pid);\\r\\n            if (\\r\\n                poolLockLength > 0 &&\\r\\n                user.lastLockDeposit + poolLockLength > block.number\\r\\n            ) {\\r\\n                uint256 earlyTax = (_amount * earlyWithdrawTax) / 10000;\\r\\n                pool.lpToken.transfer(contractAddresses[2], earlyTax);\\r\\n                pool.lpToken.transfer(address(msg.sender), _amount - earlyTax);\\r\\n            } else {\\r\\n                pool.lpToken.transfer(address(msg.sender), _amount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        user.rewardDebt = (user.amount * pool.accERC20PerShare) / 1e36;\\r\\n\\r\\n        if (pendingAmount > 0) {\\r\\n            //uint32 oneMonth = 6 * 6 * 24 * 3044; //1 month == 30.44 days (30.4375)\\r\\n\\r\\n            ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                _pid,\\r\\n                msg.sender,\\r\\n                pendingAmount,\\r\\n                contractAddresses[0],\\r\\n                uint64(block.timestamp),\\r\\n                uint32(1)\\r\\n            );\\r\\n            //erc20.transfer(vestingContract, pendingAmount);\\r\\n        }\\r\\n        emit Withdraw(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    function _isPoolLocked(uint256 _pid) public view returns (bool) {\\r\\n        return poolLocktime[_pid] > 0;\\r\\n    }\\r\\n\\r\\n    function compoundWithdraw(uint256 _pid, uint256 _amount) private {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        require(user.amount >= _amount, \\\"fCRRS:Withdraw exceeds balance\\\");\\r\\n        require(_amount > 0, \\\"fCRRS:Zero value withdraw\\\");\\r\\n        updatePool(_pid);\\r\\n        uint256 lpReward = (IERC20(pool.lpToken).balanceOf(address(this)) -\\r\\n            pool.compoundingTokens) - pool.nonCompoundingTokens;\\r\\n        uint256 pendingAmount = (user.amount * lpReward) /\\r\\n            pool.compoundingTokens -\\r\\n            user.rewardDebt;\\r\\n\\r\\n        if (_amount > 0) {\\r\\n            user.amount -= _amount;\\r\\n            pool.nonCompoundingTokens -= _amount;\\r\\n\\r\\n            uint256 poolLockLength = getPoolLocktime(_pid);\\r\\n            if (\\r\\n                poolLockLength > 0 &&\\r\\n                user.lastLockDeposit + poolLockLength > block.number\\r\\n            ) {\\r\\n                uint256 earlyTax = (_amount * earlyWithdrawTax) / 10000;\\r\\n                pool.lpToken.transfer(contractAddresses[2], earlyTax);\\r\\n                pool.lpToken.transfer(address(msg.sender), _amount - earlyTax);\\r\\n            } else {\\r\\n                pool.lpToken.transfer(address(msg.sender), _amount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (pendingAmount > 0) {\\r\\n            //uint32 oneMonth = 6 * 6 * 24 * 3044; //1 month == 30.44 days (30.4375)\\r\\n\\r\\n            ICrossVesting(contractAddresses[1]).initiateFarmVestingInstance(\\r\\n                _pid,\\r\\n                msg.sender,\\r\\n                pendingAmount,\\r\\n                address(pool.lpToken),\\r\\n                uint64(block.timestamp),\\r\\n                uint32(1)\\r\\n            );\\r\\n        }\\r\\n        user.rewardDebt = ((user.amount * (lpReward - pendingAmount)) /\\r\\n            pool.compoundingTokens);\\r\\n\\r\\n        emit Withdraw(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\r\\n    function emergencyWithdraw(uint256 _pid) public nonReentrant {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        uint256 poolLockLength = getPoolLocktime(_pid);\\r\\n        if (\\r\\n            poolLockLength > 0 &&\\r\\n            user.lastLockDeposit + poolLockLength > block.number\\r\\n        ) {\\r\\n            uint256 earlyTax = (user.amount * earlyWithdrawTax) / 10000;\\r\\n            pool.lpToken.transfer(contractAddresses[2], earlyTax);\\r\\n            pool.lpToken.transfer(address(msg.sender), user.amount - earlyTax);\\r\\n        } else {\\r\\n            pool.lpToken.transfer(address(msg.sender), user.amount);\\r\\n        }\\r\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\r\\n        user.amount = 0;\\r\\n        user.rewardDebt = 0;\\r\\n    }\\r\\n\\r\\n    function updatePoolDepositFee(uint256 _pid, uint256 _newFee)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(_newFee <= 1000, \\\"fCRSS:Max deposit fee is 10%\\\");\\r\\n        poolDepositFee[_pid] = _newFee;\\r\\n    }\\r\\n\\r\\n    function updateEarlyWithdrawTax(uint256 _newFee) external onlyOwner {\\r\\n        require(_newFee <= 2000, \\\"fCRSS:Max early withdraw penalty is 20%\\\");\\r\\n        earlyWithdrawTax = _newFee;\\r\\n    }\\r\\n\\r\\n    function depositFeeExclusionStatus(address _address, uint256 _value)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(\\r\\n            userAdjustedDeposit[_address] != _value,\\r\\n            \\\"CRSS:Already set value\\\"\\r\\n        );\\r\\n        userAdjustedDeposit[_address] = _value;\\r\\n    }\\r\\n\\r\\n    function changeRouter(address _token, address _router) public onlyOwner {\\r\\n        tokenToRouter[_token] = _router;\\r\\n    }\\r\\n\\r\\n    function updateContractAddress(uint256 _id, address _address)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        contractAddresses[_id] = _address;\\r\\n    }\\r\\n\\r\\n    function getCurrentBlockAndTimestamp()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 blockNumber, uint256 timestampInSeconds)\\r\\n    {\\r\\n        blockNumber = block.number;\\r\\n        timestampInSeconds = block.timestamp;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IsCRSS is IERC20 {\\r\\n    function enter(uint256 _amount) external;\\r\\n\\r\\n    function leave(uint256 _amount) external;\\r\\n\\r\\n    function enterFor(uint256 _amount, address _to) external;\\r\\n\\r\\n    function killswitch() external;\\r\\n\\r\\n    function setCompoundingEnabled(bool _enabled) external;\\r\\n\\r\\n    function setMaxTxAndWalletBPS(uint256 _pid, uint256 bps) external;\\r\\n\\r\\n    function rescueToken(address _token, uint256 _amount) external;\\r\\n\\r\\n    function rescueETH(uint256 _amount) external;\\r\\n\\r\\n    function excludeFromDividends(address account, bool excluded) external;\\r\\n\\r\\n    function upgradeDividend(address payable newDividendTracker) external;\\r\\n\\r\\n    function impactFeeStatus(bool _value) external;\\r\\n\\r\\n    function setImpactFeeReceiver(address _feeReceiver) external;\\r\\n\\r\\n    function CRSStoSCRSS(uint256 _crssAmount, bool _impactFeeOn)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 crssAmount,\\r\\n            uint256 swapFee,\\r\\n            uint256 impactFee\\r\\n        );\\r\\n\\r\\n    function sCRSStoCRSS(uint256 _sCrssAmount, bool _impactFeeOn)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 crssAmount,\\r\\n            uint256 swapFee,\\r\\n            uint256 impactFee\\r\\n        );\\r\\n\\r\\n    event TradingHalted(uint256 timestamp);\\r\\n    event TradingResumed(uint256 timestamp);\\r\\n}\\r\\n\\r\\ninterface ICrossVesting {\\r\\n    struct VestingInstance {\\r\\n        uint256 tokenAmount;\\r\\n        address tokenAddress; //these 3 take 1 memory slot\\r\\n        uint64 startTimestamp;\\r\\n        uint32 vestingPeriod;\\r\\n    }\\r\\n\\r\\n    struct UserVesting {\\r\\n        uint128 lpTokensVesting;\\r\\n        uint128 crssVesting;\\r\\n    }\\r\\n\\r\\n    function initiateFarmVestingInstance(\\r\\n        uint256 _pid,\\r\\n        address _address,\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        uint64 _startTimestamp,\\r\\n        uint32 _vestingPeriod\\r\\n    ) external;\\r\\n\\r\\n    function userPoolVestInfo(address _user, uint256 _pid)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            VestingInstance[] memory userVestingInstances,\\r\\n            uint256 vestingCrss,\\r\\n            uint256 vestingLpTokens,\\r\\n            uint256 vestedCrss,\\r\\n            uint256 vestedLpTokens,\\r\\n            uint256 withdrawnCrss,\\r\\n            uint256 withdrawnLpTokens,\\r\\n            uint256 nextUnlock\\r\\n        );\\r\\n}\\r\\n\\r\\ncontract CrosswiseVesting is Ownable,ReentrancyGuard {\\r\\n    struct VestingInstance {\\r\\n        uint256 tokenAmount;\\r\\n        address tokenAddress; //these 3 take 1 memory slot\\r\\n        uint64 startTimestamp;\\r\\n        uint32 vestingPeriod;\\r\\n    }\\r\\n\\r\\n    struct UserVesting {\\r\\n        uint128 lpTokensVesting;\\r\\n        uint128 crssVesting;\\r\\n    }\\r\\n\\r\\n    address public referralContract;\\r\\n    address public crssAddress;\\r\\n    address public sCrssAddress;\\r\\n    address public accountant;\\r\\n    address public adminSetter;\\r\\n    address public lpFarmAddress;\\r\\n\\r\\n    mapping(address => uint256) public totalVesting;\\r\\n    uint256 public compoundFee; //5% or 500( / 10000)\\r\\n    mapping(address => uint256) private pendingReferralRewards;\\r\\n    mapping(address => mapping(uint256 => VestingInstance[]))\\r\\n        public vestingInstances;\\r\\n    mapping(address => mapping(uint256 => uint256)) public userCrssWithdrawn;\\r\\n    mapping(address => mapping(uint256 => uint256))\\r\\n        public userLpTokensWithdrawn;\\r\\n    mapping(uint256 => uint256) public rewardMultiplier;\\r\\n    mapping(address => mapping(address => uint256)) public userEarnings;\\r\\n\\r\\n    string private constant e_restrictedAccess = \\\"vCRSS:Restricted access\\\";\\r\\n    event UserFarmVest(\\r\\n        address user,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        uint256 vestPeriod\\r\\n    );\\r\\n    event BulkCollect(address user, uint256 userReward, uint256 numOfClaimed);\\r\\n    event CrossFarmVest(address user, uint256 amount, uint256 vestingPeriod);\\r\\n    event BulkHarvest(\\r\\n        address user,\\r\\n        uint256 pid,\\r\\n        uint256 crssAmount,\\r\\n        uint256 lpAmount\\r\\n    );\\r\\n    event MassHarvest(\\r\\n        address user,\\r\\n        uint256[] _pids,\\r\\n        uint256 crssAmount,\\r\\n        uint256 lpAmount\\r\\n    );\\r\\n\\r\\n    constructor(\\r\\n        address _crssAddress,\\r\\n        address _sCrssAddress,\\r\\n        address _accountant,\\r\\n        address _referral\\r\\n    ) {\\r\\n        initiateRewardMultiplier(\\r\\n            [\\r\\n                1000,\\r\\n                1156,\\r\\n                1245,\\r\\n                1389,\\r\\n                1549,\\r\\n                1728,\\r\\n                1928,\\r\\n                2151,\\r\\n                2400,\\r\\n                2678,\\r\\n                2988,\\r\\n                3333\\r\\n            ]\\r\\n        );\\r\\n        crssAddress = _crssAddress;\\r\\n        sCrssAddress = _sCrssAddress;\\r\\n        accountant = _accountant;\\r\\n        referralContract = _referral;\\r\\n        compoundFee = 500;\\r\\n        adminSetter = msg.sender;\\r\\n        //approve sCRSS address so enterFor() can work\\r\\n        IERC20(_crssAddress).approve(_sCrssAddress, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function initiateFarmVestingInstance(\\r\\n        uint256 _pid,\\r\\n        address _address,\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        uint64 _startTimestamp,\\r\\n        uint32 _vestingPeriod\\r\\n    ) public nonReentrant {\\r\\n        IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _amount);\\r\\n        uint32 vestPeriodInSeconds = 6 * 6 * 24 * 3044 * _vestingPeriod; // 1 month => 30.44 days (30.4375)\\r\\n        //uint256 rewardsMultiplier = rewardMultiplier[_vestingPeriod];\\r\\n        //uint256 adjustedReward = (rewardsMultiplier * _amount) / 3333;\\r\\n        uint256 adjustedReward = getRewardMultiplier(_vestingPeriod, _amount) /\\r\\n            3333;\\r\\n        vestingInstances[_address][_pid].push(\\r\\n            VestingInstance({\\r\\n                tokenAmount: adjustedReward,\\r\\n                tokenAddress: _tokenAddress,\\r\\n                startTimestamp: _startTimestamp,\\r\\n                vestingPeriod: vestPeriodInSeconds\\r\\n            })\\r\\n        );\\r\\n        if (_tokenAddress == crssAddress) {\\r\\n            address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n                _address\\r\\n            );\\r\\n            if (referrer != address(0)) {\\r\\n                pendingReferralRewards[referrer] += (adjustedReward / 100);\\r\\n            } else {\\r\\n                pendingReferralRewards[accountant] += (adjustedReward / 100);\\r\\n            }\\r\\n        }\\r\\n        totalVesting[_tokenAddress] += adjustedReward;\\r\\n        emit UserFarmVest(_address, _tokenAddress, _amount, _vestingPeriod);\\r\\n    }\\r\\n\\r\\n    function massHarvest(uint256[] memory _pids) public nonReentrant {\\r\\n        uint256 totalCrss;\\r\\n        uint256 totalLp;\\r\\n\\r\\n        for (uint256 x = 0; x < _pids.length; x++) {\\r\\n            uint256 pidCrss;\\r\\n            uint256 pidLpTokens;\\r\\n            address lpToken = address(0);\\r\\n            for (\\r\\n                uint256 y = 0;\\r\\n                y < vestingInstances[msg.sender][_pids[x]].length;\\r\\n                y\\r\\n            ) {\\r\\n                uint256 pidIndex = _pids[x];\\r\\n                VestingInstance memory vestingInstance = vestingInstances[\\r\\n                    msg.sender\\r\\n                ][pidIndex][y];\\r\\n                if (\\r\\n                    vestingInstance.vestingPeriod +\\r\\n                        vestingInstance.startTimestamp <=\\r\\n                    block.timestamp\\r\\n                ) {\\r\\n                    if (vestingInstance.tokenAddress != crssAddress) {\\r\\n                        pidLpTokens += vestingInstance.tokenAmount;\\r\\n                        if (lpToken == address(0)) {\\r\\n                            lpToken = vestingInstance.tokenAddress;\\r\\n                        }\\r\\n                    } else {\\r\\n                        pidCrss += vestingInstance.tokenAmount;\\r\\n                    }\\r\\n\\r\\n                    vestingInstances[msg.sender][pidIndex][\\r\\n                        y\\r\\n                    ] = vestingInstances[msg.sender][pidIndex][\\r\\n                        vestingInstances[msg.sender][pidIndex].length - 1\\r\\n                    ];\\r\\n                    vestingInstances[msg.sender][pidIndex].pop();\\r\\n                } else y++;\\r\\n            }\\r\\n            userLpTokensWithdrawn[msg.sender][_pids[x]] += pidLpTokens;\\r\\n            userCrssWithdrawn[msg.sender][_pids[x]] += pidCrss;\\r\\n            totalCrss += pidCrss;\\r\\n            totalLp += pidLpTokens;\\r\\n            if (lpToken != address(0) && pidLpTokens > 0) {\\r\\n                uint256 userCompoundFee = (pidLpTokens * compoundFee) / 10000;\\r\\n                IERC20(lpToken).transfer(accountant, userCompoundFee);\\r\\n                IERC20(lpToken).transfer(\\r\\n                    msg.sender,\\r\\n                    pidLpTokens - userCompoundFee\\r\\n                );\\r\\n                totalVesting[lpToken] -= pidLpTokens;\\r\\n            }\\r\\n        }\\r\\n        // require(totalCrss > 0 || totalLp > 0, \\\"vCRSS:No unlocked rewards\\\");\\r\\n\\r\\n        if (totalCrss > 0) {\\r\\n            address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n                msg.sender\\r\\n            );\\r\\n            if (referrer != address(0)) {\\r\\n                // referralRewards[referrer] -= (totalCrss / 100);\\r\\n                pendingReferralRewards[referrer] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    referrer,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            } else {\\r\\n                pendingReferralRewards[accountant] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    accountant,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            }\\r\\n            IERC20(crssAddress).transfer(msg.sender, totalCrss);\\r\\n            totalVesting[crssAddress] -= totalCrss;\\r\\n        }\\r\\n\\r\\n        emit MassHarvest(msg.sender, _pids, totalCrss, totalLp);\\r\\n    }\\r\\n\\r\\n    //all CRSS rewards will be automatically converted to sCRSS in one transaction\\r\\n    function sCrssMassHarvest(uint256[] memory _pids) public nonReentrant {\\r\\n        uint256 totalCrss;\\r\\n        uint256 totalLp;\\r\\n\\r\\n        for (uint256 x = 0; x < _pids.length; x++) {\\r\\n            uint256 pidCrss;\\r\\n            uint256 pidLpTokens;\\r\\n            address lpToken = address(0);\\r\\n            for (uint256 y = 0; y < vestingInstances[msg.sender][x].length; y) {\\r\\n                VestingInstance memory vestingInstance = vestingInstances[\\r\\n                    msg.sender\\r\\n                ][x][y];\\r\\n                if (\\r\\n                    vestingInstance.vestingPeriod +\\r\\n                        vestingInstance.startTimestamp <=\\r\\n                    block.timestamp\\r\\n                ) {\\r\\n                    if (vestingInstance.tokenAddress != crssAddress) {\\r\\n                        pidLpTokens += vestingInstance.tokenAmount;\\r\\n                        if (lpToken == address(0)) {\\r\\n                            lpToken = vestingInstance.tokenAddress;\\r\\n                        }\\r\\n                    } else {\\r\\n                        pidCrss += vestingInstance.tokenAmount;\\r\\n                    }\\r\\n\\r\\n                    vestingInstances[msg.sender][x][y] = vestingInstances[\\r\\n                        msg.sender\\r\\n                    ][x][vestingInstances[msg.sender][x].length - 1];\\r\\n                    vestingInstances[msg.sender][x].pop();\\r\\n                } else y++;\\r\\n            }\\r\\n            userLpTokensWithdrawn[msg.sender][x] += pidLpTokens;\\r\\n            userCrssWithdrawn[msg.sender][x] += pidCrss;\\r\\n            totalCrss += pidCrss;\\r\\n            totalLp += pidLpTokens;\\r\\n            if (lpToken != address(0) && pidLpTokens > 0) {\\r\\n                uint256 userCompoundFee = (pidLpTokens * compoundFee) / 10000;\\r\\n                IERC20(lpToken).transfer(accountant, userCompoundFee);\\r\\n                IERC20(lpToken).transfer(\\r\\n                    msg.sender,\\r\\n                    pidLpTokens - userCompoundFee\\r\\n                );\\r\\n            }\\r\\n            totalVesting[lpToken] -= pidLpTokens;\\r\\n        }\\r\\n        // require(totalCrss > 0 || totalLp > 0, \\\"vCRSS:No unlocked rewards\\\");\\r\\n\\r\\n        if (totalCrss > 0) {\\r\\n            address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n                msg.sender\\r\\n            );\\r\\n\\r\\n            if (referrer != address(0)) {\\r\\n                // referralRewards[referrer] -= (totalCrss / 100);\\r\\n                pendingReferralRewards[referrer] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    referrer,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            } else {\\r\\n                pendingReferralRewards[accountant] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    accountant,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            }\\r\\n            IsCRSS(sCrssAddress).enterFor(totalCrss, msg.sender);\\r\\n            totalVesting[crssAddress] -= totalCrss;\\r\\n        }\\r\\n\\r\\n        emit MassHarvest(msg.sender, _pids, totalCrss, totalLp);\\r\\n    }\\r\\n\\r\\n    function bulkHarvest(uint256 _pid) public nonReentrant {\\r\\n        uint256 totalCrss;\\r\\n        uint256 totalLp;\\r\\n        address lpToken = address(0);\\r\\n        for (uint256 i = 0; i < vestingInstances[msg.sender][_pid].length; i) {\\r\\n            VestingInstance memory vestingInstance = vestingInstances[\\r\\n                msg.sender\\r\\n            ][_pid][i];\\r\\n            if (\\r\\n                vestingInstance.vestingPeriod +\\r\\n                    vestingInstance.startTimestamp <=\\r\\n                block.timestamp\\r\\n            ) {\\r\\n                if (vestingInstance.tokenAddress != crssAddress) {\\r\\n                    totalLp += vestingInstance.tokenAmount;\\r\\n                    if (lpToken == address(0)) {\\r\\n                        lpToken = vestingInstance.tokenAddress;\\r\\n                    }\\r\\n                } else {\\r\\n                    totalCrss += vestingInstance.tokenAmount;\\r\\n                }\\r\\n\\r\\n                vestingInstances[msg.sender][_pid][i] = vestingInstances[\\r\\n                    msg.sender\\r\\n                ][_pid][vestingInstances[msg.sender][_pid].length - 1];\\r\\n                vestingInstances[msg.sender][_pid].pop();\\r\\n            } else i++;\\r\\n        }\\r\\n        // require(totalCrss > 0 || totalLp > 0, \\\"vCRSS:No unlocked rewards\\\");\\r\\n        if (lpToken != address(0)) {\\r\\n            userLpTokensWithdrawn[msg.sender][_pid] += totalLp;\\r\\n            uint256 userCompoundFee = (totalLp * compoundFee) / 10000;\\r\\n            IERC20(lpToken).transfer(accountant, userCompoundFee);\\r\\n            IERC20(lpToken).transfer(msg.sender, totalLp - userCompoundFee);\\r\\n            totalVesting[lpToken] -= totalLp;\\r\\n        }\\r\\n        if (totalCrss > 0) {\\r\\n            userCrssWithdrawn[msg.sender][_pid] += totalCrss;\\r\\n\\r\\n            address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n                msg.sender\\r\\n            );\\r\\n            if (referrer != address(0)) {\\r\\n                // referralRewards[referrer] -= (totalCrss / 100);\\r\\n                pendingReferralRewards[referrer] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    referrer,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            } else {\\r\\n                pendingReferralRewards[accountant] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    accountant,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            }\\r\\n            IERC20(crssAddress).transfer(msg.sender, totalCrss);\\r\\n            totalVesting[crssAddress] -= totalCrss;\\r\\n        }\\r\\n\\r\\n        emit BulkHarvest(msg.sender, _pid, totalCrss, totalLp);\\r\\n    }\\r\\n\\r\\n    function sCrssBulkHarvest(uint256 _pid) public nonReentrant {\\r\\n        uint256 totalCrss;\\r\\n        uint256 totalLp;\\r\\n        address lpToken = address(0);\\r\\n        \\r\\n        for (uint256 i = 0; i < vestingInstances[msg.sender][_pid].length; i) {\\r\\n            VestingInstance memory vestingInstance = vestingInstances[\\r\\n                msg.sender\\r\\n            ][_pid][i];\\r\\n            if (\\r\\n                vestingInstance.vestingPeriod +\\r\\n                    vestingInstance.startTimestamp <=\\r\\n                block.timestamp\\r\\n            ) {\\r\\n                if (vestingInstance.tokenAddress != crssAddress) {\\r\\n                    totalLp += vestingInstance.tokenAmount;\\r\\n                    if (lpToken == address(0)) {\\r\\n                        lpToken = vestingInstance.tokenAddress;\\r\\n                    }\\r\\n                } else {\\r\\n                    totalCrss += vestingInstance.tokenAmount;\\r\\n                }\\r\\n\\r\\n                vestingInstances[msg.sender][_pid][i] = vestingInstances[\\r\\n                    msg.sender\\r\\n                ][_pid][vestingInstances[msg.sender][_pid].length - 1];\\r\\n                vestingInstances[msg.sender][_pid].pop();\\r\\n            } else i++;\\r\\n        }\\r\\n        // require(totalCrss > 0 || totalLp > 0, \\\"vCRSS:No unlocked rewards\\\");\\r\\n        if (lpToken != address(0)) {\\r\\n            userLpTokensWithdrawn[msg.sender][_pid] += totalLp;\\r\\n            uint256 userCompoundFee = (totalLp * compoundFee) / 10000;\\r\\n            IERC20(lpToken).transfer(accountant, userCompoundFee);\\r\\n            IERC20(lpToken).transfer(msg.sender, totalLp - userCompoundFee);\\r\\n            totalVesting[lpToken] -= totalLp;\\r\\n        }\\r\\n        if (totalCrss > 0) {\\r\\n            userCrssWithdrawn[msg.sender][_pid] += totalCrss;\\r\\n\\r\\n            address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n                msg.sender\\r\\n            );\\r\\n            if (referrer != address(0)) {\\r\\n                // referralRewards[referrer] -= (totalCrss / 100);\\r\\n                pendingReferralRewards[referrer] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    referrer,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            } else {\\r\\n                pendingReferralRewards[accountant] -= (totalCrss / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    accountant,\\r\\n                    totalCrss / 100\\r\\n                );\\r\\n            }\\r\\n            IsCRSS(sCrssAddress).enterFor(totalCrss, msg.sender);\\r\\n            totalVesting[crssAddress] -= totalCrss;\\r\\n        }\\r\\n\\r\\n        emit BulkHarvest(msg.sender, _pid, totalCrss, totalLp);\\r\\n    }\\r\\n\\r\\n    function initiateRewardMultiplier(uint16[12] memory _multiplier) private {\\r\\n        /* require(\\r\\n            msg.sender == address(this),\\r\\n            \\\"vCRSS:Called once during contract creation\\\"\\r\\n        );*/\\r\\n        for (uint256 i = 0; i < _multiplier.length; i++) {\\r\\n            uint256 multiplier = uint256(_multiplier[i]);\\r\\n            rewardMultiplier[i + 1] = multiplier;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function userPoolVestInfo(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            VestingInstance[] memory userVestingInstances,\\r\\n            uint256 vestingCrss,\\r\\n            uint256 vestingLpTokens,\\r\\n            uint256 vestedCrss,\\r\\n            uint256 vestedLpTokens,\\r\\n            uint256 withdrawnCrss,\\r\\n            uint256 withdrawnLpTokens,\\r\\n            uint256 nextUnlock\\r\\n        )\\r\\n    {\\r\\n        (withdrawnCrss, withdrawnLpTokens) = getUserEarned(_user, _pid);\\r\\n        (\\r\\n            vestedCrss,\\r\\n            vestedLpTokens,\\r\\n            vestingCrss,\\r\\n            vestingLpTokens,\\r\\n            nextUnlock\\r\\n        ) = getUserVestingVestedAndNextUnlocked(_user, _pid);\\r\\n        userVestingInstances = getVestInstances(_user, _pid);\\r\\n    }\\r\\n\\r\\n    function userFarmPoolInfo(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 stakedLp, //total LP tokens deposited by user in this pool\\r\\n            uint256 claimableRewards, //amount of CRSS or LP tokens ready to be vested, in CRSS is user is not compounding,in LP token if user is compounding\\r\\n            uint256 timeUntilWithdrawUnlocked, //amount of time left to wait before withdrawing deposited LP tokens in a locked pool without early withdraw tax\\r\\n            bool compounding, // same as isUserCompounding()\\r\\n            VestingInstance[] memory userVestingInstances, //array of all user vesting instances for this pool\\r\\n            uint256 vestingCrss,\\r\\n            uint256 vestingLpTokens,\\r\\n            uint256 vestedCrss, //unlocked/withdrawable crss\\r\\n            uint256 vestedLpTokens, //unlocked/withdrawable lpTokens\\r\\n            uint256 withdrawnCrss,\\r\\n            uint256 withdrawnLpTokens,\\r\\n            uint256 nextUnlock //time in seconds until next vesting instance is unlocked\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            stakedLp,\\r\\n            claimableRewards,\\r\\n            timeUntilWithdrawUnlocked,\\r\\n            compounding\\r\\n        ) = ICrossFarm(lpFarmAddress).userPoolFarmInfo(_user, _pid);\\r\\n\\r\\n        (withdrawnCrss, withdrawnLpTokens) = getUserEarned(_user, _pid);\\r\\n        (\\r\\n            vestedCrss,\\r\\n            vestedLpTokens,\\r\\n            vestingCrss,\\r\\n            vestingLpTokens,\\r\\n            nextUnlock\\r\\n        ) = getUserVestingVestedAndNextUnlocked(_user, _pid);\\r\\n\\r\\n        userVestingInstances = getVestInstances(_user, _pid);\\r\\n    }\\r\\n\\r\\n    function getVestInstances(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (VestingInstance[] memory)\\r\\n    {\\r\\n        return vestingInstances[_user][_pid];\\r\\n    }\\r\\n\\r\\n    function getUserEarned(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 withdrawnCrss, uint256 withdrawnLpTokens)\\r\\n    {\\r\\n        withdrawnCrss = userCrssWithdrawn[_user][_pid];\\r\\n        withdrawnLpTokens = userLpTokensWithdrawn[_user][_pid];\\r\\n    }\\r\\n\\r\\n    function getMultiplier(uint256 _numOfMonths) public view returns (uint256) {\\r\\n        return rewardMultiplier[_numOfMonths];\\r\\n    }\\r\\n\\r\\n    function getRewardMultiplier(uint256 _numOfMonths, uint256 _reward)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return rewardMultiplier[_numOfMonths] * _reward;\\r\\n    }\\r\\n\\r\\n    function getUserPending(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 crssVested, uint256 lpTokensVested)\\r\\n    {\\r\\n        uint256 currentBlock = block.timestamp;\\r\\n        address crssToken = crssAddress;\\r\\n        for (uint256 i = 0; i < vestingInstances[_user][_pid].length; i++) {\\r\\n            VestingInstance memory userInstance = vestingInstances[_user][_pid][\\r\\n                i\\r\\n            ];\\r\\n\\r\\n            if (\\r\\n                userInstance.vestingPeriod + userInstance.startTimestamp <=\\r\\n                currentBlock\\r\\n            ) {\\r\\n                if (userInstance.tokenAddress == crssToken) {\\r\\n                    crssVested += userInstance.tokenAmount;\\r\\n                } else {\\r\\n                    lpTokensVested += userInstance.tokenAmount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserVestingAndVested(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 crssVested,\\r\\n            uint256 lpTokensVested,\\r\\n            uint256 crssVesting,\\r\\n            uint256 lpTokensVesting\\r\\n        )\\r\\n    {\\r\\n        uint256 currentBlock = block.timestamp;\\r\\n        address crssToken = crssAddress;\\r\\n        for (uint256 i = 0; i < vestingInstances[_user][_pid].length; i++) {\\r\\n            VestingInstance memory userInstance = vestingInstances[_user][_pid][\\r\\n                i\\r\\n            ];\\r\\n            if (userInstance.tokenAddress == crssToken) {\\r\\n                crssVesting += userInstance.tokenAmount;\\r\\n                if (\\r\\n                    userInstance.vestingPeriod + userInstance.startTimestamp <=\\r\\n                    currentBlock\\r\\n                ) {\\r\\n                    crssVested += userInstance.tokenAmount;\\r\\n                }\\r\\n            } else {\\r\\n                lpTokensVesting += userInstance.tokenAmount;\\r\\n                if (\\r\\n                    userInstance.vestingPeriod + userInstance.startTimestamp <=\\r\\n                    currentBlock\\r\\n                ) {\\r\\n                    lpTokensVested += userInstance.tokenAmount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserVestingVestedAndNextUnlocked(address _user, uint256 _pid)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 crssVested,\\r\\n            uint256 lpTokensVested,\\r\\n            uint256 crssVesting,\\r\\n            uint256 lpTokensVesting,\\r\\n            uint256 nextUnlocked\\r\\n        )\\r\\n    {\\r\\n        uint256 currentTimestamp = block.timestamp;\\r\\n        nextUnlocked = type(uint256).max;\\r\\n        for (uint256 i = 0; i < vestingInstances[_user][_pid].length; i++) {\\r\\n            VestingInstance memory userInstance = vestingInstances[_user][_pid][\\r\\n                i\\r\\n            ];\\r\\n            uint256 unlockedIn = userInstance.startTimestamp +\\r\\n                userInstance.vestingPeriod >\\r\\n                currentTimestamp\\r\\n                ? (userInstance.startTimestamp + userInstance.vestingPeriod) -\\r\\n                    currentTimestamp\\r\\n                : 0;\\r\\n            if (unlockedIn < nextUnlocked && unlockedIn > 0) {\\r\\n                nextUnlocked = unlockedIn;\\r\\n            }\\r\\n            if (userInstance.tokenAddress == crssAddress) {\\r\\n                crssVesting += userInstance.tokenAmount;\\r\\n\\r\\n                if (unlockedIn == 0) {\\r\\n                    crssVested += userInstance.tokenAmount;\\r\\n                }\\r\\n            } else {\\r\\n                lpTokensVesting += userInstance.tokenAmount;\\r\\n                if (unlockedIn == 0) {\\r\\n                    lpTokensVested += userInstance.tokenAmount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (nextUnlocked == type(uint256).max) {\\r\\n            nextUnlocked = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimRewards(uint256 _pid, uint256 _id) public nonReentrant {\\r\\n        VestingInstance memory vestingInstance = vestingInstances[msg.sender][\\r\\n            _pid\\r\\n        ][_id];\\r\\n        uint32 vestingDuration = uint32(block.timestamp) -\\r\\n            uint32(vestingInstance.startTimestamp);\\r\\n        require(\\r\\n            vestingDuration >= vestingInstance.vestingPeriod,\\r\\n            \\\"vCRSS:Rewards not unlocked yet\\\"\\r\\n        );\\r\\n\\r\\n        uint256 adjustedReward = vestingInstance.tokenAmount;\\r\\n        if (vestingInstance.tokenAddress != crssAddress) {\\r\\n            uint256 userCompoundFee = (adjustedReward * compoundFee) / 10000;\\r\\n            IERC20(vestingInstance.tokenAddress).transfer(\\r\\n                accountant,\\r\\n                userCompoundFee\\r\\n            );\\r\\n            adjustedReward -= userCompoundFee;\\r\\n\\r\\n            //totalVesting[vestingInstance.tokenAddress] -= adjustedReward;\\r\\n            userLpTokensWithdrawn[msg.sender][_pid] += adjustedReward;\\r\\n        } else {\\r\\n            address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n                msg.sender\\r\\n            );\\r\\n            if (referrer != address(0)) {\\r\\n                pendingReferralRewards[referrer] -= (adjustedReward / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    referrer,\\r\\n                    adjustedReward / 100\\r\\n                );\\r\\n            } else {\\r\\n                pendingReferralRewards[accountant] -= (adjustedReward / 100);\\r\\n                ICrssReferral(referralContract).recordReferralCommission(\\r\\n                    accountant,\\r\\n                    adjustedReward / 100\\r\\n                );\\r\\n            }\\r\\n            userCrssWithdrawn[msg.sender][_pid] += adjustedReward;\\r\\n        }\\r\\n        vestingInstances[msg.sender][_pid][_id] = vestingInstances[msg.sender][\\r\\n            _pid\\r\\n        ][vestingInstances[msg.sender][_pid].length - 1];\\r\\n        vestingInstances[msg.sender][_pid].pop();\\r\\n        IERC20(vestingInstance.tokenAddress).transfer(\\r\\n            msg.sender,\\r\\n            adjustedReward\\r\\n        );\\r\\n        totalVesting[vestingInstance.tokenAddress] -= adjustedReward;\\r\\n    }\\r\\n\\r\\n    function claimRewardsToVault(uint256 _pid, uint256 _id)\\r\\n        public\\r\\n        nonReentrant\\r\\n    {\\r\\n        VestingInstance memory vestingInstance = vestingInstances[msg.sender][\\r\\n            _pid\\r\\n        ][_id];\\r\\n        require(\\r\\n            vestingInstance.tokenAddress == crssAddress,\\r\\n            \\\"vCRSS:Only CRSS rewards allowed\\\"\\r\\n        );\\r\\n        uint32 currentTimestamp = uint32(block.timestamp);\\r\\n        uint32 vestingDuration = currentTimestamp -\\r\\n            uint32(vestingInstance.startTimestamp);\\r\\n\\r\\n        require(\\r\\n            vestingDuration >= vestingInstance.vestingPeriod,\\r\\n            \\\"vCRSS:Rewards not unlocked yet \\\"\\r\\n        );\\r\\n\\r\\n        uint256 adjustedReward = vestingInstance.tokenAmount;\\r\\n\\r\\n        userCrssWithdrawn[msg.sender][_pid] += adjustedReward;\\r\\n        address referrer = ICrssReferral(referralContract).getReferrer(\\r\\n            msg.sender\\r\\n        );\\r\\n        if (referrer != address(0)) {\\r\\n            pendingReferralRewards[referrer] -= (adjustedReward / 100);\\r\\n            ICrssReferral(referralContract).recordReferralCommission(\\r\\n                referrer,\\r\\n                adjustedReward / 100\\r\\n            );\\r\\n        } else {\\r\\n            pendingReferralRewards[accountant] -= (adjustedReward / 100);\\r\\n            ICrssReferral(referralContract).recordReferralCommission(\\r\\n                accountant,\\r\\n                adjustedReward / 100\\r\\n            );\\r\\n        }\\r\\n\\r\\n        vestingInstances[msg.sender][_pid][_id] = vestingInstances[msg.sender][\\r\\n            _pid\\r\\n        ][vestingInstances[msg.sender][_pid].length - 1];\\r\\n        vestingInstances[msg.sender][_pid].pop();\\r\\n        IsCRSS(sCrssAddress).enterFor(adjustedReward, msg.sender);\\r\\n        totalVesting[crssAddress] -= adjustedReward;\\r\\n    }\\r\\n\\r\\n    function getPendingReferralRewards(address _referrer)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return pendingReferralRewards[_referrer];\\r\\n    }\\r\\n\\r\\n    function changeAdminSetter(address _newAdmin) external {\\r\\n        require(msg.sender == adminSetter, \\\"vCRSS:Restricted access\\\");\\r\\n        adminSetter = _newAdmin;\\r\\n    }\\r\\n    \\r\\n    function changeControlCenter(address _address) public  {\\r\\n        require(\\r\\n            _msgSender() == adminSetter || _msgSender() == owner(),\\r\\n            \\\"CRSS:Only admin setter and CC\\\"\\r\\n        );\\r\\n        \\r\\n        require(owner() != _address, \\\"vCRSS:Restricted access\\\");\\r\\n        _transferOwnership(_address);\\r\\n    }\\r\\n\\r\\n    function getAdminSetter()public view returns(address){\\r\\n        return adminSetter;\\r\\n    }\\r\\n\\r\\n    function changeCompoundFee(uint256 _newFee) public onlyOwner{\\r\\n        require(compoundFee <= 2000, \\\"vCRSS:Max compound fee percentage is 20%\\\");\\r\\n        compoundFee = _newFee;\\r\\n    }\\r\\n\\r\\n    function setReferralAddress(address _newAddress) public onlyOwner{\\r\\n        referralContract = _newAddress;\\r\\n    }\\r\\n\\r\\n    function setFarmAddress(address _newAddress) public onlyOwner{\\r\\n        lpFarmAddress = _newAddress;\\r\\n    }\\r\\n\\r\\n    function setAccountantAddress(address _newAddress) public onlyOwner{\\r\\n        accountant = _newAddress;\\r\\n    }\\r\\n\\r\\n\\r\\n    function claimAccountantRewards(address _tokenAddress, uint256 _amount)\\r\\n        external\\r\\n    {\\r\\n        require(msg.sender == accountant, e_restrictedAccess);\\r\\n        uint256 accountantShare = IERC20(_tokenAddress).balanceOf(\\r\\n            address(this)\\r\\n        ) - totalVesting[_tokenAddress];\\r\\n        require(_amount >= accountantShare, \\\"vCRSS:Exceeds allowed amount\\\");\\r\\n        IERC20(_tokenAddress).transfer(accountant, _amount);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_crssAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sCrssAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_accountant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numOfClaimed\",\"type\":\"uint256\"}],\"name\":\"BulkCollect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"crssAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"BulkHarvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"}],\"name\":\"CrossFarmVest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"crssAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"MassHarvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestPeriod\",\"type\":\"uint256\"}],\"name\":\"UserFarmVest\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accountant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"bulkHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdminSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"changeCompoundFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeControlCenter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claimAccountantRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"claimRewardsToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crssAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdminSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numOfMonths\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"getPendingReferralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numOfMonths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"getRewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getUserEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawnCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnLpTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getUserPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crssVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensVested\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getUserVestingAndVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crssVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crssVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensVesting\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getUserVestingVestedAndNextUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crssVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crssVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensVesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextUnlocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getVestInstances\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"vestingPeriod\",\"type\":\"uint32\"}],\"internalType\":\"struct CrosswiseVesting.VestingInstance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_vestingPeriod\",\"type\":\"uint32\"}],\"name\":\"initiateFarmVestingInstance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFarmAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"}],\"name\":\"massHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sCrssAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"sCrssBulkHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"}],\"name\":\"sCrssMassHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setAccountantAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setFarmAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setReferralAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCrssWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"userFarmPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeUntilWithdrawUnlocked\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"compounding\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"vestingPeriod\",\"type\":\"uint32\"}],\"internalType\":\"struct CrosswiseVesting.VestingInstance[]\",\"name\":\"userVestingInstances\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"vestingCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingLpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedLpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnLpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextUnlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userLpTokensWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"userPoolVestInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"vestingPeriod\",\"type\":\"uint32\"}],\"internalType\":\"struct CrosswiseVesting.VestingInstance[]\",\"name\":\"userVestingInstances\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"vestingCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingLpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedLpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnCrss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnLpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextUnlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingInstances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"vestingPeriod\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrosswiseVesting", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000faca2b369724e73cf29f0f60d9b0db579af006df000000000000000000000000c7ffc95a172c082b5971c973c52d4d5067af8753000000000000000000000000d6bf1a6645422ac584b48eddfdc94a076d19c9d60000000000000000000000005133d315fa94bba9155bc7bce4891923ef0228f6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}