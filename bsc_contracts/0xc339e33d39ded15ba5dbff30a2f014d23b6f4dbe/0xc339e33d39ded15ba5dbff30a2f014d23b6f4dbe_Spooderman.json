{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Spooder.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at BscScan.com on 2021-09-25\\n*/\\n\\n/**\\n \\nSpooder is the son of the famous and now trending coin Floki on Binance Smart BSC!\\n100% Legit Team | Experience Team in 5+ Projects | Extraordinary Potential\\n\\n*/\\n\\n// SPDX-License-Identifier: NOLICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n\\n\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\n\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IFactory{\\n        function createPair(address tokenA, address tokenB) external returns (address pair);\\n        function getPair(address tokenA, address tokenB) external view returns (address pair);\\n}\\n\\ninterface IRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline) external;\\n}\\n\\n\\n//\\\"ETH\\\" symb is used for better uniswap-core integration\\n//uniswap is use due to their better repo management\\n\\ncontract Spooderman is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _rOwned;\\n    mapping (address => uint256) private _tOwned;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n    mapping (address => bool) private _isExcludedFromFee;\\n    mapping (address => bool) private _isExcluded;\\n    mapping (address => bool) private _isBot;\\n    \\n\\n    address[] private _excluded;\\n\\n    bool public tradingEnabled;\\n    bool public swapEnabled;\\n    bool public buyBackEnabled = false;\\n    bool private swapping;\\n\\n    IRouter public router;\\n    address public pair;\\n\\n    uint8 private constant _decimals = 9;\\n    uint256 private constant MAX = ~uint256(0);\\n\\n    uint256 private _tTotal = 1000000000000000 * 10**_decimals;\\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\\n\\n    uint256 public maxBuyAmount = _tTotal.mul(2).div(100);\\n    uint256 public maxSellAmount = _tTotal.mul(1).div(100);\\n    uint256 public swapTokensAtAmount = 500000000000 * 10**_decimals;\\n    uint256 public _maxWalletSize = 20000000000000 * 10**9; \\n    uint256 public buyBackUpperLimit = 1 * 10**18;\\n\\n    address public marketingAddress = 0xD5388b2991DDdf21d3Ee6F8F8fAeA2DDA9Fe4c74;\\n    address public operationsAddress = 0xD5388b2991DDdf21d3Ee6F8F8fAeA2DDA9Fe4c74;\\n    address public constant deadAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n    string private constant _name = \\\"Spooderman\\\";\\n    string private constant _symbol = \\\"SPOOD\\\";\\n\\n\\n    struct feeRatesStruct {\\n      uint256 rfi;\\n      uint256 operations;\\n      uint256 marketing;\\n      uint256 liquidity;\\n      uint256 buyback;\\n    }\\n\\n\\n    feeRatesStruct public feeRates = feeRatesStruct(\\n     {rfi: 0,\\n      operations: 0,\\n      marketing: 0,\\n      liquidity: 0,\\n      buyback: 5\\n    });\\n\\n    feeRatesStruct public sellFeeRates = feeRatesStruct(\\n    {rfi: 0,\\n     operations: 2,\\n     marketing: 0,\\n     liquidity: 3,\\n     buyback: 10\\n    });\\n\\n    struct TotFeesPaidStruct{\\n        uint256 rfi;\\n        uint256 operations;\\n        uint256 marketing;\\n        uint256 liquidity;\\n        uint256 buyBack;\\n    }\\n    TotFeesPaidStruct public totFeesPaid;\\n\\n    struct valuesFromGetValues{\\n      uint256 rAmount;\\n      uint256 rTransferAmount;\\n      uint256 rRfi;\\n      uint256 rOperations;\\n      uint256 rMarketing;\\n      uint256 rLiquidity;\\n      uint256 rBuyback;\\n      uint256 tTransferAmount;\\n      uint256 tRfi;\\n      uint256 tOperations;\\n      uint256 tMarketing;\\n      uint256 tLiquidity;\\n      uint256 tBuyback;\\n    }\\n\\n    event FeesChanged();\\n    event TradingEnabled(uint256 startDate);\\n    event UpdatedRouter(address oldRouter, address newRouter);\\n\\n    modifier lockTheSwap {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    constructor (address routerAddress) {\\n        IRouter _router = IRouter(routerAddress);\\n        address _pair = IFactory(_router.factory())\\n            .createPair(address(this), _router.WETH());\\n\\n        router = _router;\\n        pair = _pair;\\n\\n        _rOwned[owner()] = _rTotal;\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[marketingAddress]=true;\\n        _isExcludedFromFee[operationsAddress] = true;\\n\\n        emit Transfer(address(0), owner(), _tTotal);\\n    }\\n\\n    //std ERC20:\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    //override ERC20:\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcluded[account]) return _tOwned[account];\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender]+addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function isExcludedFromReward(address account) public view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n\\n    function deliver(uint256 tAmount) public {\\n        address sender = _msgSender();\\n        require(!_isExcluded[sender], \\\"Excluded addresses cannot call this function\\\");\\n        valuesFromGetValues memory s = _getValues(tAmount, true, false);\\n        _rOwned[sender] = _rOwned[sender].sub(s.rAmount);\\n        _rTotal = _rTotal.sub(s.rAmount);\\n        totFeesPaid.rfi += tAmount;\\n    }\\n\\n    \\n    function reflectionFromToken(uint256 tAmount, bool deductTransferRfi) public view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferRfi) {\\n            valuesFromGetValues memory s = _getValues(tAmount, true, false);\\n            return s.rAmount;\\n        } else {\\n            valuesFromGetValues memory s = _getValues(tAmount, true, false);\\n            return s.rTransferAmount;\\n        }\\n    }\\n\\n    function startTrading() external onlyOwner{\\n        tradingEnabled = true;\\n        swapEnabled = true;\\n        emit TradingEnabled(block.timestamp);\\n    }\\n\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate =  _getRate();\\n        return rAmount/currentRate;\\n    }\\n\\n    //@dev kept original RFI naming -> \\\"reward\\\" as in reflection\\n    function excludeFromReward(address account) public onlyOwner() {\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n        if(_rOwned[account] > 0) {\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\n        }\\n        _isExcluded[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner() {\\n        require(_isExcluded[account], \\\"Account is not excluded\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _tOwned[account] = 0;\\n                _isExcluded[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n\\n    function excludeFromFee(address account) public onlyOwner {\\n        _isExcludedFromFee[account] = true;\\n    }\\n\\n    function includeInFee(address account) public onlyOwner {\\n        _isExcludedFromFee[account] = false;\\n    }\\n\\n\\n    function isExcludedFromFee(address account) public view returns(bool) {\\n        return _isExcludedFromFee[account];\\n    }\\n\\n   function setMaxWalletPercent(uint256 maxWallPercent) external onlyOwner() {\\n        _maxWalletSize = _tTotal.mul(maxWallPercent).div(\\n            10**2\\n        );\\n   }   \\n   \\n    function setFeeRates(uint256 _rfi, uint256 _operations, uint256 _marketing, uint256 _liquidity, uint256 _buyback) external onlyOwner {\\n        feeRates.rfi = _rfi;\\n        feeRates.operations = _operations;\\n        feeRates.marketing = _marketing;\\n        feeRates.liquidity = _liquidity;\\n        feeRates.buyback = _buyback;\\n        emit FeesChanged();\\n    }\\n\\n    function setSellFeeRates(uint256 _rfi, uint256 _operations, uint256 _marketing, uint256 _liquidity, uint256 _buyback) external onlyOwner{\\n        sellFeeRates.rfi = _rfi;\\n        sellFeeRates.operations = _operations;\\n        sellFeeRates.marketing = _marketing;\\n        sellFeeRates.liquidity = _liquidity;\\n        sellFeeRates.buyback = _buyback;\\n        emit FeesChanged();\\n    }\\n\\n    function _reflectRfi(uint256 rRfi, uint256 tRfi) private {\\n        _rTotal -=rRfi;\\n        totFeesPaid.rfi +=tRfi;\\n    }\\n\\n    function _takeOperations(uint256 rOperations, uint256 tOperations) private {\\n        totFeesPaid.operations +=tOperations;\\n        if(_isExcluded[address(this)]){\\n             _tOwned[address(this)]+=tOperations;\\n        }\\n        _rOwned[address(this)] +=rOperations;\\n\\n    }\\n\\n    function _takeBuyback(uint256 rBuyback, uint256 tBuyback) private {\\n        totFeesPaid.buyBack +=tBuyback;\\n\\n        if(_isExcluded[address(this)])\\n        {\\n            _tOwned[address(this)]+=tBuyback;\\n        }\\n        _rOwned[address(this)] +=rBuyback;\\n    }\\n\\n    function _takeLiquidity(uint256 rLiquidity, uint256 tLiquidity) private {\\n        totFeesPaid.liquidity +=tLiquidity;\\n\\n        if(_isExcluded[address(this)])\\n        {\\n            _tOwned[address(this)]+=tLiquidity;\\n        }\\n        _rOwned[address(this)] +=rLiquidity;\\n    }\\n\\n    function _takeMarketing(uint256 rMarketing, uint256 tMarketing) private {\\n        totFeesPaid.marketing +=tMarketing;\\n\\n        if(_isExcluded[marketingAddress])\\n        {\\n            _tOwned[marketingAddress]+=tMarketing;\\n        }\\n        _rOwned[marketingAddress] +=rMarketing;\\n    }\\n\\n\\n    function _getValues(uint256 tAmount, bool takeFee, bool isSale) private view returns (valuesFromGetValues memory to_return) {\\n        to_return = _getTValues(tAmount, takeFee, isSale);\\n        (to_return.rAmount, to_return.rTransferAmount, to_return.rRfi,to_return.rOperations, to_return.rMarketing, to_return.rLiquidity, to_return.rBuyback) = _getRValues(to_return, tAmount, takeFee, _getRate());\\n        return to_return;\\n    }\\n\\n    function _getTValues(uint256 tAmount, bool takeFee, bool isSale) private view returns (valuesFromGetValues memory s) {\\n\\n        if(!takeFee) {\\n          s.tTransferAmount = tAmount;\\n          return s;\\n        }\\n\\n        if(isSale){\\n            s.tRfi = tAmount*sellFeeRates.rfi/1000;\\n            s.tOperations = tAmount*sellFeeRates.operations/1000;\\n            s.tMarketing = tAmount*sellFeeRates.marketing/1000;\\n            s.tLiquidity = tAmount*sellFeeRates.liquidity/1000;\\n            s.tBuyback = tAmount*sellFeeRates.buyback/1000;\\n            s.tTransferAmount = tAmount-s.tRfi-s.tOperations-s.tMarketing-s.tLiquidity-s.tBuyback;\\n        }\\n        else{\\n            s.tRfi = tAmount*feeRates.rfi/1000;\\n            s.tOperations = tAmount*feeRates.operations/1000;\\n            s.tMarketing = tAmount*feeRates.marketing/1000;\\n            s.tLiquidity = tAmount*feeRates.liquidity/1000;\\n            s.tBuyback = tAmount*feeRates.buyback/1000;\\n            s.tTransferAmount = tAmount-s.tRfi-s.tOperations-s.tMarketing-s.tLiquidity-s.tBuyback;\\n        }\\n        return s;\\n    }\\n\\n    function _getRValues(valuesFromGetValues memory s, uint256 tAmount, bool takeFee, uint256 currentRate) private pure returns (uint256 rAmount, uint256 rTransferAmount, uint256 rRfi, uint256 rOperations,uint256 rMarketing, uint256 rLiquidity, uint256 rBuyback) {\\n        rAmount = tAmount*currentRate;\\n\\n        if(!takeFee) {\\n          return(rAmount, rAmount, 0,0,0,0,0);\\n        }\\n\\n        rRfi = s.tRfi*currentRate;\\n        rOperations = s.tOperations*currentRate;\\n        rMarketing = s.tMarketing*currentRate;\\n        rLiquidity = s.tLiquidity*currentRate;\\n        rBuyback = s.tBuyback*currentRate;\\n        rTransferAmount =  rAmount-rRfi-rOperations-rMarketing-rLiquidity-rBuyback;\\n        return (rAmount, rTransferAmount, rRfi,rOperations,rMarketing,rLiquidity, rBuyback);\\n    }\\n\\n    function _getRate() private view returns(uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply/tSupply;\\n    }\\n\\n    function _getCurrentSupply() private view returns(uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\\n            rSupply = rSupply-_rOwned[_excluded[i]];\\n            tSupply = tSupply-_tOwned[_excluded[i]];\\n        }\\n        if (rSupply < _rTotal/_tTotal) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n      \\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        require(amount <= balanceOf(from),\\\"You are trying to transfer more than your balance\\\");\\n        require(!_isBot[from] && !_isBot[to], \\\"Fuck you Bots\\\");\\n\\n        if(!_isExcludedFromFee[from] && !_isExcludedFromFee[to]){\\n            require(tradingEnabled, \\\"Trading is not enabled yet\\\");\\n        }\\n\\n        if( from != owner() &&\\n            to != owner() &&\\n            to != address(0) &&\\n            to != address(0xdead) &&\\n            from == pair){\\n            require(amount <= maxBuyAmount, \\\"you are exceeding maxBuyAmount\\\");\\n           uint256 walletCurrentBalance = balanceOf(to);\\n            require(walletCurrentBalance + amount <= _maxWalletSize, \\\"Exceeds maximum wallet token amount\\\");\\n        }\\n\\n        if( from != owner() &&\\n            to != owner() &&\\n            to != address(0) &&\\n            to != address(0xdead) &&\\n            from == pair){\\n            require(amount <= maxSellAmount, \\\"Amount is exceeding maxSellAmount\\\");\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n        if(!swapping && swapEnabled && canSwap && from != pair){\\n            uint256 balance = address(this).balance;\\n            if (buyBackEnabled && balance > uint256(1 * 10**18) && to == pair) {\\n                if (balance > buyBackUpperLimit) balance = buyBackUpperLimit;\\n                buyBackTokens(balance.div(100));\\n            }\\n\\n            swapAndLiquify(swapTokensAtAmount);\\n        }\\n        bool isSale;\\n        if(to == pair) isSale = true;\\n\\n        _tokenTransfer(from, to, amount, !(_isExcludedFromFee[from] || _isExcludedFromFee[to]), isSale);\\n    }\\n\\n\\n    //this method is responsible for taking all fee, if takeFee is true\\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isSale) private {\\n\\n        valuesFromGetValues memory s = _getValues(tAmount, takeFee, isSale);\\n\\n        if (_isExcluded[sender] ) {  //from excluded\\n                _tOwned[sender] = _tOwned[sender]-tAmount;\\n        }\\n        if (_isExcluded[recipient]) { //to excluded\\n                _tOwned[recipient] = _tOwned[recipient]+s.tTransferAmount;\\n        }\\n\\n        _rOwned[sender] = _rOwned[sender]-s.rAmount;\\n        _rOwned[recipient] = _rOwned[recipient]+s.rTransferAmount;\\n        _reflectRfi(s.rRfi, s.tRfi);\\n        _takeOperations(s.rOperations,s.tOperations);\\n        _takeLiquidity(s.rLiquidity,s.tLiquidity);\\n        _takeMarketing(s.rMarketing, s.tMarketing);\\n        _takeBuyback(s.rBuyback, s.tBuyback);\\n        emit Transfer(sender, recipient, s.tTransferAmount);\\n        emit Transfer(sender, address(this), s.tLiquidity + s.tOperations + s.tBuyback);\\n        emit Transfer(sender, marketingAddress, s.tMarketing);\\n\\n    }\\n\\n    function buyBackTokens(uint256 amount) private lockTheSwap{\\n    \\tif (amount > 0) {\\n    \\t    swapETHForTokens(amount);\\n\\t    }\\n    }\\n\\n    function swapETHForTokens(uint256 amount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = router.WETH();\\n        path[1] = address(this);\\n\\n      // make the swap\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\\n            0, // accept any amount of Tokens\\n            path,\\n            deadAddress, // Burn address\\n            block.timestamp.add(300)\\n        );\\n     }\\n\\n    function swapAndLiquify(uint256 tokens) private lockTheSwap{\\n         // Split the contract balance into halves\\n        uint256 denominator= (feeRates.liquidity + feeRates.buyback + feeRates.operations) * 2;\\n        uint256 tokensToAddLiquidityWith = tokens * feeRates.liquidity / denominator;\\n        uint256 toSwap = tokens - tokensToAddLiquidityWith;\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        swapTokensForBNB(toSwap);\\n\\n        uint256 deltaBalance = address(this).balance - initialBalance;\\n        uint256 unitBalance= deltaBalance / (denominator - feeRates.liquidity);\\n        uint256 bnbToAddLiquidityWith = unitBalance * feeRates.liquidity;\\n\\n        if(bnbToAddLiquidityWith > 0){\\n            // Add liquidity to pancake\\n            addLiquidity(tokensToAddLiquidityWith, bnbToAddLiquidityWith);\\n        }\\n\\n        // Send BNB to operationsWallet\\n        uint256 operationsAmt = unitBalance * 2 * feeRates.operations;\\n        if(operationsAmt > 0){\\n          payable(operationsAddress).transfer(operationsAmt);\\n        }\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(router), tokenAmount);\\n\\n        // add the liquidity\\n        router.addLiquidityETH{value: bnbAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            owner(),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapTokensForBNB(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n\\n        _approve(address(this), address(router), tokenAmount);\\n\\n        // make the swap\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n    }\\n\\n\\n    function updateMarketingWallet(address newWallet) external onlyOwner{\\n        require(marketingAddress != newWallet ,'Wallet already set');\\n        marketingAddress = newWallet;\\n        _isExcludedFromFee[marketingAddress];\\n    }\\n\\n    function updateOperationsWallet(address newWallet) external onlyOwner{\\n        require(operationsAddress != newWallet ,'Wallet already set');\\n        operationsAddress = newWallet;\\n        _isExcludedFromFee[operationsAddress];\\n    }\\n\\n    function setMaxBuyAndSellAmount(uint256 _maxBuyamount, uint256 _maxSellAmount) external onlyOwner{\\n        maxBuyAmount = _maxBuyamount * 10**9;\\n        maxSellAmount = _maxSellAmount * 10**9;\\n    }\\n\\n    function updateSwapTokensAtAmount(uint256 amount) external onlyOwner{\\n        swapTokensAtAmount = amount * 10**_decimals;\\n    }\\n\\n    function updateSwapEnabled(bool _enabled) external onlyOwner{\\n        swapEnabled = _enabled;\\n    }\\n\\n    function updateBuybackEnabled(bool _enabled) external onlyOwner{\\n        buyBackEnabled = _enabled;\\n    }\\n\\n    function setAntibot(address account, bool _bot) external onlyOwner{\\n        require(_isBot[account] != _bot, 'Value already set');\\n        _isBot[account] = _bot;\\n    }\\n\\n    function setBuybackUpperLimit(uint256 buyBackLimit) external onlyOwner() {\\n        buyBackUpperLimit = buyBackLimit * 10**15;\\n    }\\n\\n    function isBot(address account) public view returns(bool){\\n        return _isBot[account];\\n    }\\n\\n    //Use this in case BNB are sent to the contract by mistake\\n    function rescueBNB(uint256 weiAmount) external onlyOwner{\\n        require(address(this).balance >= weiAmount, \\\"insufficient BNB balance\\\");\\n        payable(msg.sender).transfer(weiAmount);\\n    }\\n\\n    function rescueBEP20Tokens(address tokenAddress) external onlyOwner{\\n        IERC20(tokenAddress).transfer(msg.sender, IERC20(tokenAddress).balanceOf(address(this)));\\n    }\\n\\n    /// @dev Update router address in case of pancakeswap migration\\n    function setRouterAddress(address newRouter) external onlyOwner {\\n        require(newRouter != address(router));\\n        IRouter _newRouter = IRouter(newRouter);\\n        address get_pair = IFactory(_newRouter.factory()).getPair(address(this), _newRouter.WETH());\\n        if (get_pair == address(0)) {\\n            pair = IFactory(_newRouter.factory()).createPair(address(this), _newRouter.WETH());\\n        }\\n        else {\\n            pair = get_pair;\\n        }\\n        router = _newRouter;\\n    }\\n\\n    receive() external payable{\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"UpdatedRouter\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxWalletSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackUpperLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyback\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferRfi\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"rescueBEP20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"rescueBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFeeRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyback\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bot\",\"type\":\"bool\"}],\"name\":\"setAntibot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyBackLimit\",\"type\":\"uint256\"}],\"name\":\"setBuybackUpperLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_operations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyback\",\"type\":\"uint256\"}],\"name\":\"setFeeRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBuyamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSellAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxBuyAndSellAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_operations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyback\",\"type\":\"uint256\"}],\"name\":\"setSellFeeRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totFeesPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBack\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"updateBuybackEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateOperationsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Spooderman", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}