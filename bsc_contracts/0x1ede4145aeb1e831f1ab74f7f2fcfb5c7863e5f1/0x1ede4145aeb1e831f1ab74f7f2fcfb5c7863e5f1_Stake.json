{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface ISocialStakeNft {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function mint(address to, uint256 id) external;\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    function renounceOwnership() external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function setStakeContract(address _address) external;\r\n\r\n    function stakeContract() external view returns (address);\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\ninterface IStake {\r\n    error UbxsTransferError();\r\n    error OnlyNftOwnerCanBurn();\r\n    error OnlyNftOwnerCanClaim();\r\n    error AmountMustBeBiggerThanMinAmount();\r\n    error AmountMustBeLessThanMaxAmount();\r\n    error InsufficientRewardAmount();\r\n    error NoReferer();\r\n    error InvalidReferer();\r\n    error RefererMustBeStaker();\r\n    error RefSeasonIsAlreadyActive();\r\n    error RefSeasonIsNotActive();\r\n    error InvalidSeason();\r\n    error RefSeasonIsNotFinished();\r\n    error YouAreNotRefererThisSeason();\r\n    error YouAreNotWithinOnePercentThisSeason();\r\n    error OnlySocialVoteContract();\r\n    error UserNameIsAlreadyTaken();\r\n    error AlreadyHasUsername();\r\n\r\n    event Staked(\r\n        uint256 indexed tokenId,\r\n        address indexed staker,\r\n        address indexed referer,\r\n        uint256 amount\r\n    );\r\n    event RewardClaimed(\r\n        uint256 indexed tokenId,\r\n        address indexed staker,\r\n        uint256 amount\r\n    );\r\n    event YouAreNotWinner();\r\n    event WinnerClaimed(\r\n        uint256 indexed seasonId,\r\n        address indexed winner,\r\n        uint256 amount\r\n    );\r\n    event SeasonRefGainPoolIncreasedBy(\r\n        uint256 indexed seasonId,\r\n        uint256 amount\r\n    );\r\n    event RewardAdded(uint256 indexed addedUbxsAmount);\r\n    event CurrentReward(uint256 indexed currentRewardAmount);\r\n    event RefSeasonStarted(uint256 indexed seasonId);\r\n    event Burned(\r\n        uint256 indexed tokenId,\r\n        uint256 withdrawnAmount,\r\n        uint256 seizedAmount\r\n    );\r\n    event RefSeasonFinalized(\r\n        uint256 indexed seasonId,\r\n        uint256 totalAmountBelowOnePercent,\r\n        uint256 seasonTotalRefGainPool,\r\n        uint256 refererCount\r\n    );\r\n\r\n    event UserNameSelected(address indexed user, string username);\r\n    event RefererRewardPercantageChanged(uint256);\r\n    event RefSeasonRewardPercantageChanged(uint256);\r\n    event MinAmountChanged(uint256);\r\n    event MaxAmountChanged(uint256);\r\n    event BaseAprChanged(uint256);\r\n    event NftAprIncreasedBy(uint256 indexed tokenId, uint256 increasedBy);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```solidity\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ncontract Stake is Ownable, Pausable, IStake {\r\n    modifier onlySocialVoteContract() {\r\n        if (msg.sender != socialVoteContract) revert OnlySocialVoteContract();\r\n        _;\r\n    }\r\n\r\n    struct StakeData {\r\n        uint256 mintedAt;\r\n        uint256 amount;\r\n        uint256 apr;\r\n        uint256 lastWithdrawTime;\r\n    }\r\n\r\n    struct Referer {\r\n        address addr;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct RefSeason {\r\n        uint256 endDate;\r\n        //fill in claim\r\n        uint256 totalAmountBelowOnePercent;\r\n        // fill in stake\r\n        uint256 seasonTotalRefGainPool;\r\n        //fill in stake\r\n        uint256 refererCount;\r\n        mapping(uint256 => Referer) referers;\r\n        mapping(address => bool) isWinner;\r\n        mapping(address => uint256) userId;\r\n        bool finalized;\r\n    }\r\n\r\n    ISocialStakeNft public immutable nft;\r\n    IERC20 public immutable ubxs;\r\n\r\n    uint256 public counter;\r\n    // %24 = 24_000 / 100_000\r\n    uint256 public baseApr = 24000;\r\n    uint256 public baseAprDominator = 100000;\r\n    uint256 public minAmount = 1_000 * 10**6;\r\n    uint256 public maxAmount = 10_000 * 10**6;\r\n    uint256 public refererRewardPercantage = 10000;\r\n    uint256 public refSeasonRewardPercantage = 15000;\r\n    uint256 public rewardToBeDistributed;\r\n    uint256 public activeRefSeasonId;\r\n    // top %1 of the refers is eligible to Claim Ref Rewards\r\n    // 10 / 100 = %1t\r\n    uint256 public refSeasonLeaderBoardTresholdPercantage = 1000;\r\n    // %0,001, 1 / 100000\r\n    uint256 public socialVoteAprIncreasedBy = 10;\r\n\r\n    address public socialVoteContract;\r\n\r\n    uint256 public refererBaseAprIncrease = 1000;\r\n\r\n    //tokenId =>\r\n    mapping(uint256 => StakeData) public stakes;\r\n\r\n    //seasonId => season\r\n    mapping(uint256 => RefSeason) public refSeason;\r\n\r\n    mapping(address => string) public username;\r\n    mapping(string => address) public addressOfUsername;\r\n\r\n    mapping(address => address) public userReferers;\r\n    mapping(address => uint256) public userReferalCount;\r\n\r\n    constructor(address _ubxs, address _nft) {\r\n        ubxs = IERC20(_ubxs);\r\n        nft = ISocialStakeNft(_nft);\r\n        IERC20(_ubxs).approve(msg.sender, type(uint256).max);\r\n    }\r\n\r\n    /*\r\n        if voter\r\n        @param voteCount how many link does the voter vote\r\n        else poster\r\n        @param voteCount avarage points of the post\r\n    */\r\n    function increaseApr(uint256 tokenId, uint256 voteCountOrAvaragePoints)\r\n        external\r\n        onlySocialVoteContract\r\n    {\r\n        // if voter if count = 5 ,total apr increased by %0,0005\r\n        // if poster if avararagePoint = 5 ,total apr increased by %0,0005\r\n        uint256 totalIncreasedBy = voteCountOrAvaragePoints *\r\n            socialVoteAprIncreasedBy;\r\n\r\n        StakeData storage data = stakes[tokenId];\r\n        data.apr += totalIncreasedBy;\r\n        if (data.apr <= 100_000) {\r\n            //time diff between today and nft release date\r\n            uint256 timeDiff = (data.mintedAt + 365 days) - block.timestamp;\r\n            uint256 totalNewReward = calculateReward(\r\n                data.amount,\r\n                totalIncreasedBy,\r\n                timeDiff\r\n            );\r\n\r\n            if (rewardToBeDistributed < totalNewReward)\r\n                revert InsufficientRewardAmount();\r\n\r\n            rewardToBeDistributed -= totalNewReward;\r\n            emit NftAprIncreasedBy(tokenId, totalIncreasedBy);\r\n        }\r\n    }\r\n\r\n    function addReward(uint256 amount) external onlyOwner {\r\n        rewardToBeDistributed += amount;\r\n\r\n        bool success = ubxs.transferFrom(msg.sender, address(this), amount);\r\n        if (!success) revert UbxsTransferError();\r\n        emit RewardAdded(amount);\r\n    }\r\n\r\n    function startRefSeason(uint256 _endDate) external onlyOwner {\r\n        if (block.timestamp < refSeason[activeRefSeasonId].endDate)\r\n            revert RefSeasonIsAlreadyActive();\r\n        activeRefSeasonId++;\r\n        refSeason[activeRefSeasonId].endDate = _endDate;\r\n        emit RefSeasonStarted(activeRefSeasonId);\r\n    }\r\n\r\n    function claimRefSeasonRewards(uint256 seasonId) external {\r\n        if (seasonId > activeRefSeasonId) revert InvalidSeason();\r\n        if (\r\n            seasonId == activeRefSeasonId &&\r\n            block.timestamp < refSeason[activeRefSeasonId].endDate\r\n        ) revert RefSeasonIsNotFinished();\r\n\r\n        RefSeason storage season = refSeason[seasonId];\r\n\r\n        // 10 % 1000 = %1\r\n        uint256 treshold = (season.seasonTotalRefGainPool *\r\n            refSeasonLeaderBoardTresholdPercantage) / baseAprDominator;\r\n\r\n        if (!season.finalized) {\r\n            uint256 totalAmountBelowOnePercent;\r\n            uint256 len = season.refererCount;\r\n            uint256 winnersCount;\r\n            for (uint256 i = 1; i <= len; i++) {\r\n                Referer memory r = season.referers[i];\r\n                if (r.amount > treshold) {\r\n                    season.isWinner[r.addr] = true;\r\n                    winnersCount++;\r\n                } else {\r\n                    totalAmountBelowOnePercent += r.amount;\r\n                }\r\n            }\r\n            season.finalized = true;\r\n            season.totalAmountBelowOnePercent = totalAmountBelowOnePercent;\r\n            emit RefSeasonFinalized(\r\n                seasonId,\r\n                totalAmountBelowOnePercent,\r\n                season.seasonTotalRefGainPool,\r\n                season.refererCount\r\n            );\r\n        }\r\n        if (season.isWinner[msg.sender]) {\r\n            uint256 userId = season.userId[msg.sender];\r\n            Referer storage r = season.referers[userId];\r\n\r\n            uint256 rewardBelowOnePercent = (season.totalAmountBelowOnePercent *\r\n                r.amount) / (100 * season.seasonTotalRefGainPool);\r\n\r\n            uint256 totalWinnerReward = rewardBelowOnePercent + r.amount;\r\n            season.isWinner[msg.sender] = false;\r\n\r\n            bool success = ubxs.transfer(msg.sender, totalWinnerReward);\r\n            if (!success) revert UbxsTransferError();\r\n\r\n            emit WinnerClaimed(seasonId, msg.sender, totalWinnerReward);\r\n        } else {\r\n            emit YouAreNotWinner();\r\n        }\r\n    }\r\n\r\n    function stake(uint256 amount, address referer) external whenNotPaused {\r\n        if (amount < minAmount) revert AmountMustBeBiggerThanMinAmount();\r\n        if (amount > maxAmount) revert AmountMustBeLessThanMaxAmount();\r\n\r\n        if (referer == address(0)) revert NoReferer();\r\n        if (referer == msg.sender) revert InvalidReferer();\r\n\r\n        if (nft.balanceOf(referer) == 0) revert RefererMustBeStaker();\r\n\r\n        uint256 userBaseApr = baseApr +\r\n            userReferalCount[msg.sender] *\r\n            refererBaseAprIncrease;\r\n\r\n        if (userBaseApr > 100000) {\r\n            userBaseApr = 100000;\r\n        }\r\n\r\n        uint256 refererReward = (amount * refererRewardPercantage) /\r\n            baseAprDominator;\r\n        uint256 aprReward = (amount * userBaseApr) / baseAprDominator;\r\n        uint256 refSeasonReward;\r\n\r\n        RefSeason storage season = refSeason[activeRefSeasonId];\r\n\r\n        if (userReferers[msg.sender] == address(0)) {\r\n            userReferers[msg.sender] = referer;\r\n            userReferalCount[referer]++;\r\n        } else {\r\n            referer = userReferers[msg.sender];\r\n        }\r\n\r\n        // if season is active\r\n        if (season.endDate > block.timestamp) {\r\n            refSeasonReward =\r\n                (amount * refSeasonRewardPercantage) /\r\n                baseAprDominator;\r\n            season.seasonTotalRefGainPool += refSeasonReward;\r\n\r\n            //if it is not the referers first reference\r\n            if (season.userId[referer] != 0) {\r\n                season\r\n                    .referers[season.userId[referer]]\r\n                    .amount += refSeasonReward;\r\n            }\r\n            // if it the referers firs reference\r\n            else {\r\n                // first referers userId will start from 1,\r\n                // if it 0 it means user is not a referer\r\n                season.refererCount++;\r\n\r\n                season.userId[referer] = season.refererCount;\r\n                season.referers[season.userId[referer]] = Referer(\r\n                    referer,\r\n                    refSeasonReward\r\n                );\r\n            }\r\n            emit SeasonRefGainPoolIncreasedBy(\r\n                activeRefSeasonId,\r\n                refSeasonReward\r\n            );\r\n        } else {}\r\n\r\n        uint256 totalReward = aprReward + refererReward + refSeasonReward;\r\n\r\n        if (rewardToBeDistributed < totalReward)\r\n            revert InsufficientRewardAmount();\r\n\r\n        rewardToBeDistributed -= totalReward;\r\n\r\n        stakes[++counter] = StakeData({\r\n            mintedAt: block.timestamp,\r\n            amount: amount,\r\n            apr: userBaseApr,\r\n            lastWithdrawTime: block.timestamp\r\n        });\r\n\r\n        nft.mint(msg.sender, counter);\r\n\r\n        emit Staked(counter, msg.sender, referer, amount);\r\n\r\n        emit CurrentReward(rewardToBeDistributed);\r\n\r\n        //user stakes his tokens\r\n        bool success = ubxs.transferFrom(msg.sender, address(this), amount);\r\n        if (!success) revert UbxsTransferError();\r\n\r\n        //send Reward to referer\r\n        success = ubxs.transfer(referer, refererReward);\r\n        if (!success) revert UbxsTransferError();\r\n    }\r\n\r\n    function claimReward(uint256 tokenId) external {\r\n        address owner = nft.ownerOf(tokenId);\r\n        if (owner != msg.sender) revert OnlyNftOwnerCanClaim();\r\n        StakeData memory data = stakes[tokenId];\r\n\r\n        uint256 timeDiff = block.timestamp - data.lastWithdrawTime;\r\n        if (timeDiff > 365 days) timeDiff = 365 days;\r\n\r\n        uint256 rewardAmount = calculateReward(data.amount, data.apr, timeDiff);\r\n        stakes[tokenId].lastWithdrawTime = block.timestamp;\r\n\r\n        emit RewardClaimed(tokenId, msg.sender, rewardAmount);\r\n\r\n        bool success = ubxs.transfer(msg.sender, rewardAmount);\r\n        if (!success) revert UbxsTransferError();\r\n    }\r\n\r\n    function calculateReward(\r\n        uint256 amount,\r\n        uint256 apr,\r\n        uint256 timeDiff\r\n    ) internal view returns (uint256) {\r\n        uint256 rewardPercentage = apr * timeDiff;\r\n        uint256 rewardAmount = (amount * rewardPercentage) /\r\n            (baseAprDominator * 365 days);\r\n\r\n        return rewardAmount;\r\n    }\r\n\r\n    function getWithdrawableAmount(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        StakeData memory data = stakes[tokenId];\r\n        uint256 timeDiff = block.timestamp - data.lastWithdrawTime;\r\n        if (timeDiff > 365 days) timeDiff = 365 days;\r\n\r\n        return calculateReward(data.amount, data.apr, timeDiff);\r\n    }\r\n\r\n    function burn(uint256 tokenId) external {\r\n        address owner = nft.ownerOf(tokenId);\r\n        if (owner != msg.sender) revert OnlyNftOwnerCanBurn();\r\n\r\n        StakeData memory data = stakes[tokenId];\r\n        uint256 timeDiff = block.timestamp - data.mintedAt;\r\n        uint256 withdrawAmount;\r\n        uint256 unlockTime = (data.mintedAt + 365 days);\r\n        // punishment-seize\r\n        if (timeDiff < 365 days) {\r\n            withdrawAmount = (data.amount * timeDiff) / 365 days;\r\n            //calculate remaining reward\r\n            uint256 remainingAprReward = calculateReward(\r\n                data.amount,\r\n                data.apr,\r\n                unlockTime - data.lastWithdrawTime\r\n            );\r\n            // add punishment of his stake and the remaining of his rewards to the prize pool\r\n            rewardToBeDistributed +=\r\n                (data.amount - withdrawAmount) +\r\n                remainingAprReward;\r\n        } else {\r\n            withdrawAmount = data.amount;\r\n\r\n            // if user tries to burn without taking rewards\r\n            if (data.lastWithdrawTime < unlockTime) {\r\n                uint256 unclaimedRewards = calculateReward(\r\n                    data.amount,\r\n                    data.apr,\r\n                    unlockTime - data.lastWithdrawTime\r\n                );\r\n                rewardToBeDistributed += unclaimedRewards;\r\n            }\r\n        }\r\n\r\n        delete stakes[tokenId];\r\n        nft.burn(tokenId);\r\n\r\n        emit Burned(tokenId, withdrawAmount, data.amount - withdrawAmount);\r\n\r\n        emit CurrentReward(rewardToBeDistributed);\r\n\r\n        bool success = ubxs.transfer(msg.sender, withdrawAmount);\r\n        if (!success) revert UbxsTransferError();\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function takeUserName(string calldata _username) external {\r\n        if (keccak256(bytes(username[msg.sender])) != keccak256(bytes(\"\")))\r\n            revert AlreadyHasUsername();\r\n\r\n        if (addressOfUsername[_username] != address(0))\r\n            revert UserNameIsAlreadyTaken();\r\n\r\n        username[msg.sender] = _username;\r\n        addressOfUsername[_username] = msg.sender;\r\n        emit UserNameSelected(msg.sender, _username);\r\n    }\r\n\r\n    function getRefSeasonReferers(uint256 seasonId, uint256 userId)\r\n        external\r\n        view\r\n        returns (Referer memory)\r\n    {\r\n        return refSeason[seasonId].referers[userId];\r\n    }\r\n\r\n    function getRefSeasonIsWinner(uint256 seasonId, address user)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return refSeason[seasonId].isWinner[user];\r\n    }\r\n\r\n    function getRefSeasonUserId(uint256 seasonId, address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return refSeason[seasonId].userId[user];\r\n    }\r\n\r\n    function setBaseApr(uint256 _apr) external onlyOwner {\r\n        baseApr = _apr;\r\n        emit BaseAprChanged(_apr);\r\n    }\r\n\r\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\r\n        minAmount = _minAmount;\r\n        emit MinAmountChanged(_minAmount);\r\n    }\r\n\r\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\r\n        maxAmount = _maxAmount;\r\n        emit MaxAmountChanged(_maxAmount);\r\n    }\r\n\r\n    function setRefererRewardPercantage(uint256 _refererRewardPercantage)\r\n        external\r\n        onlyOwner\r\n    {\r\n        refererRewardPercantage = _refererRewardPercantage;\r\n        emit RefererRewardPercantageChanged(_refererRewardPercantage);\r\n    }\r\n\r\n    function setRefSeasonRewardPercantage(uint256 _refSeasonRewardPercantage)\r\n        external\r\n        onlyOwner\r\n    {\r\n        refSeasonRewardPercantage = _refSeasonRewardPercantage;\r\n        emit RefSeasonRewardPercantageChanged(_refSeasonRewardPercantage);\r\n    }\r\n\r\n    function setSocialVoteContract(address _addr) external onlyOwner {\r\n        socialVoteContract = _addr;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ubxs\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyHasUsername\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountMustBeBiggerThanMinAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountMustBeLessThanMaxAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientRewardAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReferer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSeason\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReferer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyNftOwnerCanBurn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyNftOwnerCanClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlySocialVoteContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefSeasonIsAlreadyActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefSeasonIsNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefSeasonIsNotFinished\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefererMustBeStaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UbxsTransferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UserNameIsAlreadyTaken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"YouAreNotRefererThisSeason\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"YouAreNotWithinOnePercentThisSeason\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BaseAprChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizedAmount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentRewardAmount\",\"type\":\"uint256\"}],\"name\":\"CurrentReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MaxAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MinAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasedBy\",\"type\":\"uint256\"}],\"name\":\"NftAprIncreasedBy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmountBelowOnePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seasonTotalRefGainPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refererCount\",\"type\":\"uint256\"}],\"name\":\"RefSeasonFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefSeasonRewardPercantageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"}],\"name\":\"RefSeasonStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefererRewardPercantageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"addedUbxsAmount\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SeasonRefGainPoolIncreasedBy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"}],\"name\":\"UserNameSelected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WinnerClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"YouAreNotWinner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeRefSeasonId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"addressOfUsername\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseApr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAprDominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"}],\"name\":\"claimRefSeasonRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRefSeasonIsWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"getRefSeasonReferers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Stake.Referer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seasonId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRefSeasonUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteCountOrAvaragePoints\",\"type\":\"uint256\"}],\"name\":\"increaseApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract ISocialStakeNft\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refSeason\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountBelowOnePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seasonTotalRefGainPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refererCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refSeasonLeaderBoardTresholdPercantage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refSeasonRewardPercantage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refererBaseAprIncrease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refererRewardPercantage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToBeDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"}],\"name\":\"setBaseApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"name\":\"setMinAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refSeasonRewardPercantage\",\"type\":\"uint256\"}],\"name\":\"setRefSeasonRewardPercantage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refererRewardPercantage\",\"type\":\"uint256\"}],\"name\":\"setRefererRewardPercantage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setSocialVoteContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"socialVoteAprIncreasedBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"socialVoteContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"name\":\"startRefSeason\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"takeUserName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ubxs\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReferalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReferers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"username\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Stake", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f1960e29b2ca581a38c5c474e123f420f8092db000000000000000000000000d11c48df7b27b9fec92b72f510bd1f3a78c190f3", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://efd5dcdf10c5205039e443c2b7f94969d520465c7f22d5c1115a88edca656188"}