{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IContractExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IContractExecutor Interface\\n * @notice This interface defines the execute function used to interact with external contracts.\\n */\\ninterface IContractExecutor {\\n    /**\\n     * @notice Executes a call to an external contract.\\n     * @dev Execution logic is left up to the implementation.\\n     * @param target The address of the contract to be called\\n     * @param callData The calldata to be sent\\n     * @param nativeValue The amount of native token (e.g., Ether) to be sent along with the call\\n     * @return bytes The data returned from the executed call\\n     */\\n    function executeContract(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOperators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from './IOwnable.sol';\\nimport { IContractExecutor } from './IContractExecutor.sol';\\n\\n/**\\n * @title IOperators Interface\\n * @notice Interface for an access control mechanism where operators have exclusive\\n * permissions to execute functions.\\n */\\ninterface IOperators is IOwnable, IContractExecutor {\\n    error NotOperator();\\n    error InvalidOperator();\\n    error OperatorAlreadyAdded();\\n    error NotAnOperator();\\n    error ExecutionFailed();\\n\\n    event OperatorAdded(address indexed operator);\\n    event OperatorRemoved(address indexed operator);\\n\\n    /**\\n     * @notice Check if an account is an operator.\\n     * @param account Address of the account to check\\n     * @return bool True if the account is an operator, false otherwise\\n     */\\n    function isOperator(address account) external view returns (bool);\\n\\n    /**\\n     * @notice Adds an operator.\\n     * @param operator The address to add as an operator\\n     */\\n    function addOperator(address operator) external;\\n\\n    /**\\n     * @notice Removes an operator.\\n     * @param operator The address of the operator to remove\\n     */\\n    function removeOperator(address operator) external;\\n\\n    /**\\n     * @notice Executes an external contract call.\\n     * @dev Execution logic is left up to the implementation.\\n     * @param target The contract to call\\n     * @param callData The data to call the target contract with\\n     * @param nativeValue The amount of native asset to send with the call\\n     * @return bytes The data returned from the contract call\\n     */\\n    function executeContract(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IOwnable Interface\\n * @notice IOwnable is an interface that abstracts the implementation of a\\n * contract with ownership control features. It's commonly used in upgradable\\n * contracts and includes the functionality to get current owner, transfer\\n * ownership, and propose and accept ownership.\\n */\\ninterface IOwnable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidOwnerAddress();\\n\\n    event OwnershipTransferStarted(address indexed newOwner);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return address The address of the current owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the pending owner of the contract.\\n     * @return address The address of the pending owner\\n     */\\n    function pendingOwner() external view returns (address);\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new address\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Proposes to transfer the contract's ownership to a new address.\\n     * The new owner needs to accept the ownership explicitly.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Transfers ownership to the pending owner.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Operators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOperators } from '../interfaces/IOperators.sol';\\nimport { Ownable } from './Ownable.sol';\\n\\n/**\\n * @title Operators\\n * @notice This contract provides an access control mechanism, where an owner can register\\n * operator accounts that can call arbitrary contracts on behalf of this contract.\\n * @dev The owner account is initially set as the deployer address.\\n */\\ncontract Operators is Ownable, IOperators {\\n    mapping(address => bool) public operators;\\n\\n    /**\\n     * @notice Sets the initial owner of the contract.\\n     */\\n    constructor(address initialOwner) Ownable(initialOwner) {}\\n\\n    /**\\n     * @notice Modifier that requires the `msg.sender` to be an operator.\\n     * @dev Reverts with a NotOperator error if the condition is not met.\\n     */\\n    modifier onlyOperator() {\\n        if (!operators[msg.sender]) revert NotOperator();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns whether an address is an operator.\\n     * @param account Address to check\\n     * @return boolean whether the address is an operator\\n     */\\n    function isOperator(address account) external view returns (bool) {\\n        return operators[account];\\n    }\\n\\n    /**\\n     * @notice Adds an address as an operator.\\n     * @dev Can only be called by the current owner.\\n     * @param operator address to be added as operator\\n     */\\n    function addOperator(address operator) external onlyOwner {\\n        if (operator == address(0)) revert InvalidOperator();\\n        if (operators[operator]) revert OperatorAlreadyAdded();\\n\\n        operators[operator] = true;\\n\\n        emit OperatorAdded(operator);\\n    }\\n\\n    /**\\n     * @notice Removes an address as an operator.\\n     * @dev Can only be called by the current owner.\\n     * @param operator address to be removed as operator\\n     */\\n    function removeOperator(address operator) external onlyOwner {\\n        if (operator == address(0)) revert InvalidOperator();\\n        if (!operators[operator]) revert NotAnOperator();\\n\\n        operators[operator] = false;\\n\\n        emit OperatorRemoved(operator);\\n    }\\n\\n    /**\\n     * @notice Allows an operator to execute arbitrary functions on any smart contract.\\n     * @dev Can only be called by an operator.\\n     * @param target address of the contract to execute the function on. Existence is not checked.\\n     * @param callData ABI encoded function call to execute on target\\n     * @param nativeValue The amount of native asset to send with the call. If `nativeValue` is set to `0`, then `msg.value` is forwarded instead.\\n     * @return data return data from executed function call\\n     */\\n    function executeContract(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) external payable onlyOperator returns (bytes memory) {\\n        if (nativeValue == 0) {\\n            nativeValue = msg.value;\\n        }\\n\\n        (bool success, bytes memory data) = target.call{ value: nativeValue }(callData);\\n        if (!success) {\\n            revert ExecutionFailed();\\n        }\\n\\n        return data;\\n    }\\n\\n    /**\\n     * @notice This function enables the contract to accept native value transfers.\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from '../interfaces/IOwnable.sol';\\n\\n/**\\n * @title Ownable\\n * @notice A contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The owner account is set through ownership transfer. This module makes\\n * it possible to transfer the ownership of the contract to a new account in one\\n * step, as well as to an interim pending owner. In the second flow the ownership does not\\n * change until the pending owner accepts the ownership transfer.\\n */\\nabstract contract Ownable is IOwnable {\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n    // keccak256('ownership-transfer')\\n    bytes32 internal constant _OWNERSHIP_TRANSFER_SLOT =\\n        0x9855384122b55936fbfb8ca5120e63c6537a1ac40caf6ae33502b3c5da8c87d1;\\n\\n    /**\\n     * @notice Initializes the contract by transferring ownership to the owner parameter.\\n     * @param _owner Address to set as the initial owner of the contract\\n     */\\n    constructor(address _owner) {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @notice Modifier that throws an error if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert NotOwner();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return owner_ The current owner of the contract\\n     */\\n    function owner() public view returns (address owner_) {\\n        assembly {\\n            owner_ := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pending owner of the contract.\\n     * @return owner_ The pending owner of the contract\\n     */\\n    function pendingOwner() public view returns (address owner_) {\\n        assembly {\\n            owner_ := sload(_OWNERSHIP_TRANSFER_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account `newOwner`.\\n     * @dev Can only be called by the current owner.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Propose to transfer ownership of the contract to a new account `newOwner`.\\n     * @dev Can only be called by the current owner. The ownership does not change\\n     * until the new owner accepts the ownership transfer.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external virtual onlyOwner {\\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\\n\\n        emit OwnershipTransferStarted(newOwner);\\n\\n        assembly {\\n            sstore(_OWNERSHIP_TRANSFER_SLOT, newOwner)\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts ownership of the contract.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external virtual {\\n        address newOwner = pendingOwner();\\n        if (newOwner != msg.sender) revert InvalidOwner();\\n\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Internal function to transfer ownership of the contract to a new account `newOwner`.\\n     * @dev Called in the constructor to set the initial owner.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\\n\\n        emit OwnershipTransferred(newOwner);\\n\\n        assembly {\\n            sstore(_OWNER_SLOT, newOwner)\\n            sstore(_OWNERSHIP_TRANSFER_SLOT, 0)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAnOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorAlreadyAdded\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nativeValue\",\"type\":\"uint256\"}],\"name\":\"executeContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Operators", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000006f24a47fc8ae5441eb47effc3665e70e69ac3f05", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}