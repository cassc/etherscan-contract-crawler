{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/// @title HotVip\r\n/// @notice A reflect token that takes a cut on each transfer and redistributes the fees back to the token holders\r\n/// @dev The contract is based on the concept of two spaces T and R and a converion rate between them. The reason\r\n/// is the contract gets a fee on each transfer and it needs to re-distribute to each token holder. However, this would\r\n/// be impossible if done via a naive for loop. Instead, a deflation mechanism is utilized so that the tokens you hold are worth more.\r\n/// This is similar to the concept of reserve ration from the traditional finance\r\ncontract HotVip is IERC20, Ownable {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public immutable decimals;\r\n\r\n  uint256 private constant MAX = type(uint256).max;\r\n  // this is the base figure we divide to get a fine grained percentage \r\n  uint256 constant public FEE_BASE = 10_000;\r\n\r\n  uint256 private immutable tTotal;\r\n  uint256 private rTotal;\r\n  uint256 public tFeeTotal;\r\n  uint256 public taxFee;\r\n  uint256 private prevTaxFee;\r\n  uint256 public immutable maxTaxFee;\r\n\r\n  mapping (address => uint256) private rOwned;\r\n  mapping (address => uint256) private tOwned;\r\n  \r\n  address[] private excluded;\r\n  mapping (address => bool) public isExcluded;\r\n  mapping (address => bool) public isExcludedFromFee;\r\n\r\n  mapping (address => mapping (address => uint256)) private allowances;\r\n\r\n  event TaxFeeUpdated(uint256 taxFee);\r\n\r\n  /// @notice Ctor\r\n  /// @param _name the token name\r\n  /// @param _symbol the token symbol\r\n  /// @param _decimals the token decimals\r\n  /// @param _totalSupply the total supply\r\n  /// @param _taxFee the fee applicable on each transfer and will be distributed to the holders\r\n  /// @param _maxTaxFee the max fee that can ever be applied\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _totalSupply,\r\n    uint256 _taxFee,\r\n    uint256 _maxTaxFee\r\n  ) {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n\r\n    tTotal = _totalSupply;\r\n    taxFee = _taxFee;\r\n    maxTaxFee = _maxTaxFee;\r\n    rTotal = (MAX - (MAX % _totalSupply));\r\n\r\n    rOwned[_msgSender()] = rTotal;\r\n    emit Transfer(address(0), _msgSender(), _totalSupply);\r\n  }\r\n\r\n  /* ----------------------- ERC20 Implementation----------------------- */\r\n  function totalSupply() public view override returns (uint256) {\r\n    return tTotal;\r\n  }\r\n\r\n  function balanceOf(address account) public view virtual override returns (uint256) {\r\n    if (isExcluded[account]) return tOwned[account];\r\n\r\n    return tokenFromReflection(rOwned[account]);\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n\r\n    uint256 currentAllowance = allowances[sender][_msgSender()];\r\n    require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n    unchecked {\r\n      _approve(sender, _msgSender(), currentAllowance - amount);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view override returns (uint256) {\r\n    return allowances[owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount) public override returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n    _approve(_msgSender(), spender, allowances[_msgSender()][spender] + addedValue);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n    uint256 currentAllowance = allowances[_msgSender()][spender];\r\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n    unchecked {\r\n      _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint256 amount) internal {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /* ----------------------- Reflect logic Implementation----------------------- */\r\n\r\n  /// @dev Transfer the given amount to the recipient account\r\n  /// @param sender the account that sends the tokens\r\n  /// @param recipient the account that will receive the tokens\r\n  /// @param amount the amount that is sent\r\n  function _transfer(address sender, address recipient, uint256 amount) internal {\r\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n    require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n    if(isExcludedFromFee[sender] || isExcludedFromFee[recipient]) {\r\n      removeAllFee();\r\n    }\r\n\r\n    bool isSenderExcluded = isExcluded[sender];\r\n    bool isRecipientExcluded = isExcluded[recipient];\r\n\r\n    if (isSenderExcluded && !isRecipientExcluded) {\r\n      transferFromExcluded(sender, recipient, amount);\r\n    } else if (!isSenderExcluded && isRecipientExcluded) {\r\n      transferToExcluded(sender, recipient, amount);\r\n    } else if (isSenderExcluded && isRecipientExcluded) {\r\n      transferBothExcluded(sender, recipient, amount);\r\n    } else {\r\n      transferStandard(sender, recipient, amount);\r\n    }\r\n\r\n    if(isExcludedFromFee[sender] || isExcludedFromFee[recipient]) {\r\n      restoreAllFee();\r\n    }\r\n  }\r\n  \r\n  /// @dev Temporarily sets the fees to 0\r\n  function removeAllFee() private {\r\n    if(taxFee == 0) return;\r\n    \r\n    prevTaxFee = taxFee;\r\n    taxFee = 0;\r\n  }\r\n    \r\n  /// @dev Restores the previous values of the fees\r\n  function restoreAllFee() private {\r\n    taxFee = prevTaxFee;\r\n  }\r\n\r\n  /// @dev The standard transfer logic of the reflect token when none of sender or recipient is excluded\r\n  /// @param sender the account that sends the tokens\r\n  /// @param recipient the account that will receive the tokens\r\n  /// @param amount the amount that is sent\r\n  function transferStandard(address sender, address recipient, uint256 amount) private {\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee\r\n    ) = getValues(amount);\r\n\r\n    rOwned[sender] -= rAmount;\r\n    rOwned[recipient] += rTransferAmount;\r\n    reflectFee(rFee, tFee);\r\n\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  /// @dev Transfer logic applied when the sender is an exluced account\r\n  /// exlcluded accounts need to update both the T and R balances i.e. tOwned and rOwned\r\n  /// @param sender the account that sends the tokens\r\n  /// @param recipient the account that will receive the tokens\r\n  /// @param amount the amount that is sent\r\n  function transferFromExcluded(address sender, address recipient, uint256 amount) private {\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee\r\n    ) = getValues(amount);\r\n\r\n    tOwned[sender] -= amount;\r\n    rOwned[sender] -= rAmount;\r\n    rOwned[recipient] += rTransferAmount;\r\n    reflectFee(rFee, tFee);\r\n\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  /// @dev Transfer logic applied when the recipient is an exluced account\r\n  /// exlcluded accounts need to update both the T and R balances i.e. tOwned and rOwned\r\n  /// @param sender the account that sends the tokens\r\n  /// @param recipient the account that will receive the tokens\r\n  /// @param amount the amount that is sent\r\n  function transferToExcluded(address sender, address recipient, uint256 amount) private {\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee\r\n    ) = getValues(amount);\r\n\r\n    rOwned[sender] -= rAmount;\r\n    tOwned[recipient] += tTransferAmount;\r\n    rOwned[recipient] += rTransferAmount;\r\n    reflectFee(rFee, tFee);\r\n\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  /// @dev Transfer logic applied when both sender and recipient are excluded\r\n  /// exlcluded accounts need to update both the T and R balances i.e. tOwned and rOwned\r\n  /// @param sender the account that sends the tokens\r\n  /// @param recipient the account that will receive the tokens\r\n  /// @param amount the amount that is sent\r\n  function transferBothExcluded(address sender, address recipient, uint256 amount) private {\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee\r\n    ) = getValues(amount);\r\n\r\n    tOwned[sender] -= amount;\r\n    rOwned[sender] -= rAmount;\r\n    tOwned[recipient] += tTransferAmount;\r\n    rOwned[recipient] += rTransferAmount;\r\n    reflectFee(rFee, tFee);\r\n\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  /// @dev Returns the T and R current supply\r\n  /// @return the t and r current supply\r\n  function getCurrentSupply() private view returns(uint256, uint256) {\r\n    uint256 rSupply = rTotal;\r\n    uint256 tSupply = tTotal;\r\n\r\n    // excluded addresses and their balances should not be used. This is because\r\n    // those balances do fo require any conversion from rSpace to tSpace since their\r\n    // balances are already in the tSpace\r\n    for (uint256 i = 0; i < excluded.length; i++) {\r\n      if (rOwned[excluded[i]] > rSupply || tOwned[excluded[i]] > tSupply) { \r\n        return (rTotal, tTotal);\r\n      }\r\n      \r\n      rSupply = rSupply - rOwned[excluded[i]];\r\n      tSupply = tSupply - tOwned[excluded[i]];\r\n    }\r\n\r\n    if (rSupply < rTotal / tTotal) {\r\n      return (rTotal, tTotal);\r\n    }\r\n\r\n    return (rSupply, tSupply);\r\n  }\r\n\r\n  /// @dev The current rate that does the transition between t and r spaces\r\n  /// @return The current rate\r\n  function getRate() private view returns(uint256) {\r\n    (uint256 rSupply, uint256 tSupply) = getCurrentSupply();\r\n    \r\n    return rSupply / tSupply;\r\n  }\r\n\r\n  /// @dev Calculates the values of the tSpace and rSpace\r\n  /// @param amount this is the amount of tokens transfered. This value is in the tSpace\r\n  /// @return tSpace and rSpace values values\r\n  function getValues(uint256 amount) private view returns (uint256, uint256, uint256, uint256, uint256) {\r\n    (uint256 tTransferAmount, uint256 tFee) = getTValues(amount);\r\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = getRValues(amount, tFee);\r\n\r\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\r\n  }\r\n\r\n  /// @dev Calculates the values of the tSpace\r\n  /// @param amount this is the amount of tokens transfered. This value is in the tSpace\r\n  /// @return tSpace  values values\r\n  function getTValues(uint256 amount) private view returns (uint256, uint256) {\r\n    uint256 tFee = calculateFee(amount, taxFee);\r\n    uint256 tTransferAmount = amount - tFee;\r\n    return (tTransferAmount, tFee);\r\n  }\r\n\r\n  /// @dev Calculates the values of the rSpace\r\n  /// @param amount this is the amount of tokens transfered. This value is in the tSpace\r\n  /// @param tFee the reflect fee amount. This value is in the tSpace\r\n  /// @return tSpace  values values\r\n  function getRValues(uint256 amount, uint256 tFee) private view returns (uint256, uint256, uint256) {\r\n    uint256 currentRate = getRate();\r\n    uint256 rAmount = amount * currentRate;\r\n    uint256 rFee = tFee * currentRate;\r\n    uint256 rTransferAmount = rAmount - rFee;\r\n\r\n    return (rAmount, rTransferAmount, rFee);\r\n  }\r\n\r\n  /// @notice Allows any token holder to essentially donate an amount of tokens to all other token holders\r\n  /// @param amount amount to donate\r\n  function reflect(uint256 amount) external {\r\n    address sender = _msgSender();\r\n    require(!isExcluded[sender], \"Excluded addresses cannot call this function\");\r\n\r\n    (uint256 rAmount,,,,) = getValues(amount);\r\n    rOwned[sender] -= rAmount;\r\n    rTotal -= rAmount;\r\n    tFeeTotal += amount;\r\n  }\r\n\r\n  /// @dev Updates the values that define the conversion rate that will be used in the next interaction\r\n  /// @param rFee the fee amount. This value is in the rSpace\r\n  /// @param tFee the fee amount. This value is in the tSpace\r\n  function reflectFee(uint256 rFee, uint256 tFee) private {\r\n    rTotal -= rFee;\r\n    tFeeTotal += tFee;\r\n  }\r\n\r\n  /// @dev Finds total fee on the given amount\r\n  /// @param fee the fee value\r\n  /// @param amount the transfer amount\r\n  /// @return the fee amount in the tSpace\r\n  function calculateFee(uint256 amount, uint256 fee) private pure returns (uint256) {\r\n    return (amount * fee) / FEE_BASE;\r\n  }\r\n\r\n  /// @notice Conversion from the rSpace to the tSpace\r\n  /// @param rAmount the amount in the rSpace\r\n  /// @return the corresponding amount in the tSpace\r\n  function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n    require(rAmount <= rTotal, \"Amount must be less than total reflections\");\r\n    uint256 currentRate = getRate();\r\n\r\n    return rAmount / currentRate;\r\n  }\r\n\r\n  /// @notice The opposie of tokenFromReflection. Converts a value in the tSpace to the rSpace\r\n  /// @param tAmount amount in the tSpace\r\n  /// @param deductTransferFee this will dry-run a transfer that will calculate the net amount after the fee\r\n  /// @return the corresponding amount in the rSpace\r\n  function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\r\n    require(tAmount <= tTotal, \"Amount must be less than supply\");\r\n    (uint256 rAmount, uint256 rTransferAmount,,,) = getValues(tAmount);\r\n    \r\n    return deductTransferFee \r\n      ? rTransferAmount \r\n      : rAmount;\r\n  }\r\n\r\n  /// @notice Adds the given account to the list of excluded accounts.\r\n  /// Excluded accounts are not going to receive any of the reflect fees\r\n  /// @param account account to be excluded\r\n  function excludeAccount(address account) public onlyOwner {\r\n    require(!isExcluded[account], \"Account is already excluded\");\r\n    \r\n    // excluded account operate in the T space, so we need to find and set the t balance\r\n    if(rOwned[account] > 0) {\r\n      tOwned[account] = tokenFromReflection(rOwned[account]);\r\n    }\r\n\r\n    isExcluded[account] = true;\r\n    excluded.push(account);\r\n  }\r\n\r\n  /// @notice Opposite of excludeAccount\r\n  /// @param account account to be included\r\n  function includeAccount(address account) external onlyOwner {\r\n    require(isExcluded[account], \"Account is not excluded\");\r\n\r\n    for (uint256 i = 0; i < excluded.length; i++) {\r\n      if (excluded[i] == account) {\r\n        excluded[i] = excluded[excluded.length - 1];\r\n        // recalculate rOwned. The reason we do this is because if the account is included again\r\n        // it will continue from the state it was left when it was excluded. More specifically,\r\n        // the rOwned will the based on the rate at the time of exclusion. However, when the accounts\r\n        // is included again the old rate is obsolete thus the user's R balance should also be updated\r\n        // accoording to the current rate\r\n        rOwned[account] = tOwned[account] * getRate();\r\n        tOwned[account] = 0;\r\n        isExcluded[account] = false;\r\n        excluded.pop();\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Adds the given account to the list of excluded from fees accounts.\r\n  /// If an account is exluded from fees then their transfers do get taxed\r\n  /// @param account account to be excluded\r\n  function excludeFromFee(address account) public onlyOwner {\r\n    isExcludedFromFee[account] = true;\r\n  }\r\n  \r\n  /// @notice Opposite of excludeFromFee\r\n  /// @param account account to be included\r\n  function includeInFee(address account) public onlyOwner {\r\n    isExcludedFromFee[account] = false;\r\n  }\r\n\r\n  /// @notice Allows the owner to update the reflect fee\r\n  /// @param _taxFee the new tax fee\r\n  function updateTaxFee(uint256 _taxFee) external onlyOwner {\r\n    require(_taxFee <= maxTaxFee, \"tax fee exceeds limit\");\r\n    \r\n    taxFee = _taxFee;\r\n    emit TaxFeeUpdated(taxFee);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_taxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTaxFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"}],\"name\":\"TaxFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTaxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reflect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxFee\",\"type\":\"uint256\"}],\"name\":\"updateTaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HotVip", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "1000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000015747ab143e3537ff000000000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000000d486f7420446f6720546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006484f54444f470000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a12f8d91112fafa5fce02b4c23d2307a94e9cb09ff898110c82c4a593e6fd6d3"}