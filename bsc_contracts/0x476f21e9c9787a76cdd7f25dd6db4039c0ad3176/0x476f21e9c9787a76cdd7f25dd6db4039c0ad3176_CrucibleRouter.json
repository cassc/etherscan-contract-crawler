{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/crucible/CrucibleRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"../common/uniswap/IUniswapV2Router01.sol\\\";\\nimport \\\"../common/uniswap/IUniswapV2Factory.sol\\\";\\nimport \\\"../common/uniswap/IWETH.sol\\\";\\nimport \\\"../taxing/IGeneralTaxDistributor.sol\\\";\\nimport \\\"./ICrucibleToken.sol\\\";\\nimport \\\"../common/IStakeFor.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./CrucibleFactory.sol\\\";\\nimport \\\"../taxing/HasTaxDistributor.sol\\\";\\nimport \\\"../common/signature/MultiSigCheckable.sol\\\";\\nimport \\\"../common/signature/Allocatable.sol\\\";\\nimport \\\"../common/SafeAmount.sol\\\";\\n\\n/**\\n @notice The Crucible Router\\n @author Ferrum Network\\n */\\ncontract CrucibleRouter is MultiSigCheckable, HasTaxDistributor, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    string public constant NAME = \\\"FERRUM_CRUCIBLE_ROUTER\\\";\\n    string public constant VERSION = \\\"000.001\\\";\\n\\n    // Using a struct to reduced number of variable in methods.\\n    struct Amounts {\\n        uint256 base;\\n        uint256 pair;\\n        bool isWeth;\\n    }\\n\\n    mapping(address => uint256) public openCaps;\\n    mapping(address => uint16) public delegatedGroupIds;\\n    mapping(address => bool) public allowedAmms;\\n\\n    modifier amm(address _amm) {\\n        require(allowedAmms[_amm], \\\"CR: amm not allowed\\\");\\n        _;\\n    }\\n\\n    constructor() EIP712(NAME, VERSION) {}\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     @notice Can upgrade router on a crucible\\n     @param crucible The crucible \\n     @param newRouter The new router\\n     @dev Only callable by admin for router upgrade in future\\n     */\\n    function upgradeRouter(address crucible, address newRouter\\n    ) external onlyOwner {\\n        require(crucible != address(0), \\\"CR: crucible required\\\");\\n        require(newRouter != address(0), \\\"CR: newRouter required\\\");\\n        ICrucibleToken(crucible).upgradeRouter(newRouter);\\n    }\\n\\n    /**\\n     @notice Removes the amm router\\n     @param amm The amm router\\n     */\\n    function removeAmm(address amm\\n    ) external onlyOwner {\\n        delete allowedAmms[amm];\\n    }\\n\\n    bytes32 constant ALLOW_AMM = keccak256(\\\"AllowAmm(address amm)\\\");\\n    /**\\n     @notice Allows an AMM to be used for liquidity.\\n     @param amm The amm router\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function allowAmm(\\n        address amm,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) governanceGroupId(expectedGroupId) {\\n        bytes32 message = keccak256(\\n            abi.encode(ALLOW_AMM, amm, salt, expiry)\\n        );\\n        verifyUniqueSalt(\\n            message,\\n            salt,\\n            expectedGroupId,\\n            multiSignature\\n        );\\n        allowedAmms[amm] = true;\\n    }\\n\\n    bytes32 constant DELEGATE_GROUP_ID =\\n        keccak256(\\\"DelegateGroupId(address crucible,uint16 delegatedGroupId)\\\");\\n    /**\\n     @notice Sets a delageted group ID. Once set this group ID can \\n         produce signatures for allocations.\\n     @param crucible The crucible\\n     @param delegatedGroupId The delegated group ID\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function delegateGroupId(\\n        address crucible,\\n        uint16 delegatedGroupId,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        bytes32 message = keccak256(\\n            abi.encode(DELEGATE_GROUP_ID, crucible, delegatedGroupId, salt, expiry)\\n        );\\n        verifyUniqueSalt(\\n            message,\\n            salt,\\n            expectedGid(crucible, expectedGroupId),\\n            multiSignature\\n        );\\n        delegatedGroupIds[crucible] = delegatedGroupId;\\n    }\\n\\n    bytes32 constant UPDATE_CRUCIBLE_FEES =\\n        keccak256(\\\"UpdateCrucibleFees(address crucible,uint64 newFeeOnTransferX10000,uint64 newFeeOnWithdrawX10000,bytes32 salt,uint64 expiry)\\\");\\n    /**\\n     @notice Sets the open cap for a crucible\\n     @param crucible The crucible address\\n     @param newFeeOnTransferX10000 The new fee on transfer\\n     @param newFeeOnWithdrawX10000 The new fee on withdraw\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function updateCrucibleFees(\\n        address crucible,\\n        uint64 newFeeOnTransferX10000,\\n        uint64 newFeeOnWithdrawX10000,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        bytes32 message = keccak256(\\n            abi.encode(UPDATE_CRUCIBLE_FEES, crucible, newFeeOnTransferX10000, newFeeOnWithdrawX10000, salt, expiry)\\n        );\\n        verifyUniqueSalt(\\n            message,\\n            salt,\\n            expectedGid(crucible, expectedGroupId),\\n            multiSignature\\n        );\\n        ICrucibleToken(crucible).updateCrucibleFees(newFeeOnTransferX10000, newFeeOnWithdrawX10000);\\n    }\\n\\n    bytes32 constant SET_OPEN_CAP =\\n        keccak256(\\\"SetOpenCap(address crucible,uint256 cap,bytes32 salt,uint64 expiry)\\\");\\n    /**\\n     @notice Sets the open cap for a crucible\\n     @param crucible The crucible address\\n     @param cap The cap\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function setOpenCap(\\n        address crucible,\\n        uint256 cap,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        bytes32 message = keccak256(\\n            abi.encode(SET_OPEN_CAP, crucible, cap, salt, expiry)\\n        );\\n        verifyUniqueSalt(\\n            message,\\n            salt,\\n            expectedGid(crucible, expectedGroupId),\\n            multiSignature\\n        );\\n        openCaps[crucible] = cap;\\n    }\\n\\n    bytes32 constant DEPOSIT_METHOD =\\n        keccak256(\\n            \\\"Deposit(address to,address crucible,uint256 amount,bytes32 salt,uint64 expiry)\\\"\\n        );\\n    /**\\n     @notice Deposits into a crucible\\n     @param to The receiver of crucible tokens\\n     @param crucible The crucible address\\n     @param amount The deposit amount\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     @return The amount deposited\\n     */\\n    function deposit(\\n        address to,\\n        address crucible,\\n        uint256 amount,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) nonReentrant returns (uint256) {\\n        require(amount != 0, \\\"CR: amount required\\\");\\n        require(to != address(0), \\\"CR: to required\\\");\\n        require(crucible != address(0), \\\"CR: crucible required\\\");\\n        if (multiSignature.length != 0) {\\n            verifyDepositSignature(\\n                to,\\n                crucible,\\n                amount,\\n                salt,\\n                expiry,\\n                expectedGroupId,\\n                multiSignature\\n            );\\n        } else {\\n            amount = amountFromOpenCap(crucible, amount);\\n        }\\n        address token = ICrucibleToken(crucible).baseToken();\\n        require(SafeAmount.safeTransferFrom(token, msg.sender, crucible, amount) != 0, \\\"CR: nothing transferred\\\");\\n        return ICrucibleToken(crucible).deposit(to);\\n    }\\n\\n    /**\\n     @notice Deposit into crucible without allocation\\n     @param to Address of the receiver of crucible\\n     @param crucible The crucible token\\n     @param amount The amount to be deposited\\n     @return The deposited amount\\n     */\\n    function depositOpen(\\n        address to,\\n        address crucible,\\n        uint256 amount\\n    ) external nonReentrant returns (uint256) {\\n        require(amount != 0, \\\"CR: amount required\\\");\\n        require(to != address(0), \\\"CR: to required\\\");\\n        require(crucible != address(0), \\\"CR: crucible required\\\");\\n        address token = ICrucibleToken(crucible).baseToken();\\n        amount = amountFromOpenCap(crucible, amount);\\n        require(SafeAmount.safeTransferFrom(token, msg.sender, crucible, amount) != 0, \\\"CR: nothing transferred\\\");\\n        return ICrucibleToken(crucible).deposit(to);\\n    }\\n\\n    /**\\n     @notice Deposit and stake in one transaction\\n     @param to Address of the reciever of stake\\n     @param crucible The crucible address\\n     @param amount The amount to be deposited\\n     @param stake The staking contract address\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function depositAndStake(\\n        address to,\\n        address crucible,\\n        uint256 amount,\\n        address stake,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) nonReentrant external {\\n        require(amount != 0, \\\"CR: amount required\\\");\\n        require(to != address(0), \\\"CR: to required\\\");\\n        require(crucible != address(0), \\\"CR: crucible required\\\");\\n        require(stake != address(0), \\\"CR: stake required\\\");\\n        if (multiSignature.length != 0) {\\n            verifyDepositSignature(\\n                to,\\n                crucible,\\n                amount,\\n                salt,\\n                expiry,\\n                expectedGroupId,\\n                multiSignature\\n            );\\n        } else {\\n            amount = amountFromOpenCap(crucible, amount);\\n        }\\n\\n        address token = ICrucibleToken(crucible).baseToken();\\n        require(SafeAmount.safeTransferFrom(token, msg.sender, crucible, amount) != 0, \\\"CR: nothing transferred\\\");\\n        require(ICrucibleToken(crucible).deposit(stake) != 0, \\\"CR: nothing depositted\\\");\\n        IStakeFor(stake).stakeFor(to, crucible);\\n    }\\n\\n    /**\\n     @notice Deposit and add liquidity and stake the LP token in one transaction\\n     @param to Address of the reciever of stake\\n     @param crucible The crucible address\\n     @param pairToken The pair token for liquidity\\n     @param baseAmount The amount of the base token\\n     @param pairAmount The amount of the pair token\\n     @param ammRouter The UNIV2 compatible AMM router for liquidity adding\\n     @param stake The staking contract address\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function depositAddLiquidityStake(\\n        address to,\\n        address crucible,\\n        address pairToken,\\n        uint256 baseAmount,\\n        uint256 pairAmount,\\n        address ammRouter,\\n        address stake,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint256 deadline,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) nonReentrant amm(ammRouter) external {\\n        if (multiSignature.length != 0) {\\n            verifyDepositSig(\\n                to,\\n                crucible,\\n                pairToken,\\n                baseAmount,\\n                pairAmount,\\n                ammRouter,\\n                stake,\\n                salt,\\n                expiry,\\n                expectedGroupId,\\n                multiSignature\\n            );\\n        } else {\\n            baseAmount = amountFromOpenCap(crucible, baseAmount);\\n        }\\n        {\\n        pairAmount = SafeAmount.safeTransferFrom(\\n            pairToken,\\n            msg.sender,\\n            address(this),\\n            pairAmount\\n        );\\n        baseAmount = _depositToken(crucible, baseAmount);\\n        Amounts memory amounts = Amounts({\\n            base: baseAmount,\\n            pair: pairAmount,\\n            isWeth: false\\n        });\\n        _addDepositToLiquidity(\\n            stake,\\n            crucible,\\n            pairToken,\\n            amounts,\\n            IUniswapV2Router01(ammRouter),\\n            deadline\\n        );\\n        }\\n        {\\n            address pool = IUniswapV2Factory(IUniswapV2Router01(ammRouter).factory())\\n                .getPair(pairToken, crucible);\\n            require(pool != address(0), \\\"CR: pool does not exist\\\");\\n            IStakeFor(stake).stakeFor(to, pool);\\n        }\\n    }\\n\\n    /**\\n     @notice Deposit and add liquidity with ETH and stake the LP token in one transaction\\n     @param to Address of the reciever of stake\\n     @param crucible The crucible address\\n     @param baseAmount The amount of the base token\\n     @param ammRouter The UNIV2 compatible AMM router for liquidity adding\\n     @param stake The staking contract address\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function depositAddLiquidityStakeETH(\\n        address to,\\n        address crucible,\\n        uint256 baseAmount,\\n        address ammRouter,\\n        address stake,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 deadline,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external nonReentrant amm(ammRouter) payable {\\n        address weth = IUniswapV2Router01(ammRouter).WETH();\\n        if (multiSignature.length != 0) {\\n            verifyDepositSig(\\n                to,\\n                crucible,\\n                weth,\\n                baseAmount,\\n                msg.value,\\n                ammRouter,\\n                stake,\\n                salt,\\n                expiry,\\n                expectedGroupId,\\n                multiSignature\\n            );\\n        } else {\\n            baseAmount = amountFromOpenCap(crucible, baseAmount);\\n        }\\n        IWETH(weth).deposit{value: msg.value}();\\n        baseAmount = _depositToken(crucible, baseAmount);\\n        Amounts memory amounts = Amounts({\\n            base: baseAmount,\\n            pair: msg.value,\\n            isWeth: true\\n        });\\n        _addDepositToLiquidity(\\n            stake,\\n            crucible,\\n            weth,\\n            amounts,\\n            IUniswapV2Router01(ammRouter),\\n            deadline\\n        );\\n        {\\n            address pool = IUniswapV2Factory(IUniswapV2Router01(ammRouter).factory())\\n                .getPair(weth, crucible);\\n            require(pool != address(0), \\\"CR: pool does not exist\\\");\\n            IStakeFor(stake).stakeFor(to, pool);\\n        }\\n    }\\n\\n    /**\\n     @notice Sakes for another address\\n     @dev Use this with crucible users to reduce the need for another approval request\\n     @param to Address of the reciever of stake\\n     @param token The token\\n     @param stake The staking contract address\\n     @param amount The amount of stake\\n     */\\n    function stakeFor(\\n        address to,\\n        address token,\\n        address stake,\\n        uint256 amount\\n    ) external {\\n        require(to != address(0), \\\"CR: Invalid to\\\");\\n        require(token != address(0), \\\"CR: Invalid token\\\");\\n        require(stake != address(0), \\\"CR: Invalid stake\\\");\\n        require(amount != 0, \\\"CR: Invalid amount\\\");\\n        flushTaxDistributor(token);\\n        require(SafeAmount.safeTransferFrom(token, msg.sender, stake, amount) != 0, \\\"CR: nothing transferred\\\");\\n        IStakeFor(stake).stakeFor(to, token);\\n    }\\n\\n    bytes32 constant OVERRIDE_FEE_METHOD =\\n        keccak256(\\n            \\\"OverrideFee(address crucible,address target,uint8 overrideType,uint64 newFeeX10000,bytes32 salt,uint64 expiry)\\\"\\n        );\\n    /**\\n     @notice Overrides the fee for a given address\\n     @param crucible The crucible address\\n     @param target The fee target\\n     @param overrideType The type of override\\n     @param newFeeX10000 The new fee on the 10k basis\\n     @param salt The signature salt\\n     @param expiry Signature expiry\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function overrideFee(\\n        address crucible,\\n        address target,\\n        ICrucibleToken.OverrideState overrideType,\\n        uint64 newFeeX10000,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        bytes32 message = keccak256(\\n            abi.encode(\\n                OVERRIDE_FEE_METHOD,\\n                crucible,\\n                target,\\n                uint8(overrideType),\\n                newFeeX10000,\\n                salt,\\n                expiry\\n            )\\n        );\\n        verifyUniqueSalt(\\n            message,\\n            salt,\\n            expectedGid(crucible, expectedGroupId),\\n            multiSignature\\n        );\\n        ICrucibleToken(crucible).overrideFee(\\n            target,\\n            overrideType,\\n            newFeeX10000\\n        );\\n    }\\n\\n    /**\\n     @notice Verifies the deposite signature\\n     @param to The to address\\n     @param crucible The crucible\\n     @param amount The amount\\n     @param salt The salt\\n     @param expiry The expiry\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function verifyDepositSignature(\\n        address to,\\n        address crucible,\\n        uint256 amount,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) private {\\n        bytes32 message = keccak256(\\n            abi.encode(DEPOSIT_METHOD, to, crucible, amount, salt, expiry)\\n        );\\n        verifyUniqueSalt(\\n            message,\\n            salt,\\n            expectedGid(crucible, expectedGroupId),\\n            multiSignature\\n        );\\n    }\\n\\n    /**\\n     @notice Return amount left from the open cap\\n     @param crucible The crucible\\n     @param amount The amount\\n     @return The cap\\n     */\\n    function amountFromOpenCap(address crucible, uint256 amount\\n    ) private returns (uint256) {\\n        uint256 cap = openCaps[crucible];\\n        require(cap != 0, \\\"CR: Crucible not open\\\");\\n        if (cap > amount) {\\n            cap = cap - amount;\\n        } else {\\n            amount = cap;\\n            cap = 0;\\n        }\\n        openCaps[crucible] = cap;\\n        return amount;\\n    }\\n\\n    /**\\n     @notice Adds deposit to liquidity\\n     @param to The to address\\n     @param crucible The crucible\\n     @param pairToken The pair token\\n     @param amounts The amounts array\\n     @param ammRouter The amm router\\n     @param deadline The deadline\\n     */\\n    function _addDepositToLiquidity(\\n        address to,\\n        address crucible,\\n        address pairToken,\\n        Amounts memory amounts,\\n        IUniswapV2Router01 ammRouter,\\n        uint256 deadline\\n    ) private {\\n        approveIfRequired(crucible, address(ammRouter), amounts.base);\\n        approveIfRequired(pairToken, address(ammRouter), amounts.pair);\\n        (uint256 amountA, uint256 amountB, ) = ammRouter.addLiquidity(\\n            crucible,\\n            pairToken,\\n            amounts.base,\\n            amounts.pair,\\n            0,\\n            0,\\n            to,\\n            deadline\\n        );\\n        uint256 crucibleLeft = amounts.base - amountA;\\n        if (crucibleLeft != 0) {\\n            IERC20(crucible).transfer(msg.sender, crucibleLeft);\\n        }\\n        uint256 pairLeft = amounts.pair - amountB;\\n        if (pairLeft != 0) {\\n            if (amounts.isWeth) {\\n                IWETH(pairToken).withdraw(pairLeft);\\n                SafeAmount.safeTransferETH(msg.sender, pairLeft); // refund dust eth, if any. No need to check the return value\\n            } else {\\n                IERC20(pairToken).safeTransfer(msg.sender, pairLeft);\\n            }\\n        }\\n    }\\n\\n    bytes32 DEPOSIT_ADD_LIQUIDITY_STAKE_METHOD =\\n        keccak256(\\n            \\\"DepositAddLiquidityStake(address to,address crucible,address pairToken,uint256 baseAmount,uint256 pairAmount,address ammRouter,address stake,bytes32 salt,uint64 expiry)\\\"\\n        );\\n    /**\\n     @notice Verifies the deposite signature\\n     @param to The to address\\n     @param crucible The crucible\\n     @param pairToken The pair token\\n     @param baseAmount The base amount\\n     @param pairAmount The pair amount\\n     @param ammRouter The amm router\\n     @param stake The stake\\n     @param salt The salt\\n     @param expiry The expiry\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function verifyDepositSig(\\n        address to,\\n        address crucible,\\n        address pairToken,\\n        uint256 baseAmount,\\n        uint256 pairAmount,\\n        address ammRouter,\\n        address stake,\\n        bytes32 salt,\\n        uint64 expiry,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) private expiryRange(expiry) {\\n        bytes32 message = keccak256(\\n            abi.encode(\\n                DEPOSIT_ADD_LIQUIDITY_STAKE_METHOD,\\n                to,\\n                crucible,\\n                pairToken,\\n                baseAmount,\\n                pairAmount,\\n                ammRouter,\\n                stake,\\n                salt,\\n                expiry\\n            )\\n        );\\n        verifyUniqueMessageDigest(\\n            message,\\n            expectedGid(crucible, expectedGroupId),\\n            multiSignature\\n        );\\n    }\\n\\n    /**\\n     @notice Approves the contract on the amm router if required\\n     @param token The token\\n     @param router The router\\n     @param amount The amount\\n     */\\n    function approveIfRequired(\\n        address token,\\n        address router,\\n        uint256 amount\\n    ) private {\\n        uint256 allowance = IERC20(token).allowance(address(this), router);\\n        if (allowance < amount) {\\n            if (allowance != 0) {\\n                IERC20(token).safeApprove(router, 0);\\n            }\\n            IERC20(token).safeApprove(router, type(uint256).max);\\n        }\\n    }\\n\\n    /**\\n     @notice Deposits token into crucible\\n     @param crucible The crucible\\n     @param amount The amount\\n     @return deposited The deposited amount\\n     */\\n    function _depositToken(address crucible, uint256 amount\\n    ) private returns (uint256 deposited) {\\n        address token = ICrucibleToken(crucible).baseToken();\\n        require(SafeAmount.safeTransferFrom(token, msg.sender, crucible, amount) != 0, \\\"CR: nothing transferred\\\");\\n        deposited = ICrucibleToken(crucible).deposit(address(this));\\n        require(deposited != 0, \\\"CR: nothing was deposited\\\");\\n    }\\n\\n    /**\\n     @notice Returns the expected group ID\\n     @param crucible The crucible\\n     @param expected Initially expected group ID\\n     @return gid The expected group ID\\n     */\\n    function expectedGid(address crucible, uint64 expected\\n    ) private view returns (uint64 gid) {\\n        gid = expected;\\n        require(\\n            expected < 256 || delegatedGroupIds[crucible] == expected,\\n            \\\"CR: bad groupId\\\"\\n        );\\n        require(gid != 0, \\\"CR: gov or delegate groupId required\\\");\\n    }\\n\\n    /**\\n     @notice Flushes the tax distributor to allow stakes have fees.\\n      Otherwise the tax dist balance may cause the safeTransferFrom\\n      to believe there is a reentrancy attack and fail the transaction.\\n     @param token The token\\n     */\\n    function flushTaxDistributor(address token) private {\\n        IGeneralTaxDistributor(taxDistributor).distributeTaxAvoidOrigin(token, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/uniswap/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n// {\\\"mode\\\":\\\"full\\\",\\\"isActive\\\":false}\"\r\n    },\r\n    \"contracts/common/uniswap/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"\r\n    },\r\n    \"contracts/common/uniswap/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/taxing/IGeneralTaxDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IGeneralTaxDistributor {\\n    function distributeTax(address token) external returns (uint256);\\n    function distributeTaxAvoidOrigin(address token, address origin) external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/crucible/ICrucibleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\ninterface ICrucibleToken {\\n    enum OverrideState {\\n        Default,\\n        OverrideIn,\\n        OverrideOut,\\n        OverrideBoth\\n    }\\n\\n    function deposit(address to) external returns (uint256);\\n\\n    function withdraw(address to, uint256 amount)\\n        external\\n        returns (uint256, uint256);\\n\\n    function baseToken() external returns (address);\\n\\n    function overrideFee(\\n        address target,\\n        OverrideState overrideType,\\n        uint64 newFeeX10000\\n    ) external;\\n\\n    function updateCrucibleFees(\\n        uint64 newFeeOnTransferX10000,\\n        uint64 newFeeOnWithdrawX10000\\n    ) external;\\n\\n    function upgradeRouter(address router) external;\\n}\\n\"\r\n    },\r\n    \"contracts/common/IStakeFor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IStakeFor {\\n    function stakeFor(address staker, address token) external returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crucible/CrucibleFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"../common/IBurnable.sol\\\";\\nimport \\\"../common/IFerrumDeployer.sol\\\";\\nimport \\\"./ICrucibleFactory.sol\\\";\\nimport \\\"./CrucibleTokenDeployer.sol\\\";\\nimport \\\"../staking/factory/NoDelegateCall.sol\\\";\\nimport \\\"../common/strings/StringLib.sol\\\";\\nimport \\\"../common/WithAdmin.sol\\\";\\n\\n/// @title Factory for generating crucible tokens\\n/// @author Ferrum Network\\ncontract CrucibleFactory is\\n    CrucibleTokenDeployer,\\n    NoDelegateCall,\\n    ICrucibleFactory,\\n    WithAdmin\\n{\\n    uint64 constant MAX_FEE = 10000;\\n    address public immutable override router;\\n    mapping(bytes32 => address) private crucible;\\n\\n    event CrucibleCreated(\\n        address token,\\n        address baseToken,\\n        uint256 feeOnTransferX10000,\\n        uint256 feeOnWithdrawX10000\\n    );\\n\\n    constructor() {\\n        (router) = abi.decode(\\n            IFerrumDeployer(msg.sender).initData(),\\n            (address)\\n        );\\n    }\\n\\n    /**\\n    @notice Returns the crucible address\\n    @param baseToken The base token address\\n    @param feeOnTransferX10000 Fee on transfer rate per 10k\\n    @param feeOnWithdrawX10000 Fee on withdraw rate per 10k\\n    @return The crucible address if any\\n     */\\n    function getCrucible(\\n        address baseToken,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) external view override returns (address) {\\n        return\\n            crucible[\\n                crucibleKey(baseToken, feeOnTransferX10000, feeOnWithdrawX10000)\\n            ];\\n    }\\n\\n    /**\\n    @notice Creates a crucible\\n    @param baseToken The base token address\\n    @param feeOnTransferX10000 Fee on transfer rate per 10k\\n    @param feeOnWithdrawX10000 Fee on withdraw rate per 10k\\n    @return token The created crucible address\\n     */\\n    function createCrucible(\\n        address baseToken,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) external noDelegateCall returns (address token) {\\n        return\\n            _createCrucible(\\n                baseToken,\\n                safeName(baseToken),\\n                safeSymbol(baseToken),\\n                feeOnTransferX10000,\\n                feeOnWithdrawX10000\\n            );\\n    }\\n\\n    /**\\n    @notice Creates a crucible directly\\n    @dev To be used only by contract admin in case normal crucible generation\\n         cannot succeed.\\n    @return token The created crucible token address\\n     */\\n    function createCrucibleDirect(\\n        address baseToken,\\n        string memory name,\\n        string memory symbol,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) external onlyAdmin returns (address token) {\\n        bytes32 key = validateCrucible(\\n            baseToken,\\n            name,\\n            symbol,\\n            feeOnTransferX10000,\\n            feeOnWithdrawX10000\\n        );\\n        return\\n            _createCrucibleWithName(\\n                key,\\n                baseToken,\\n                name,\\n                symbol,\\n                feeOnTransferX10000,\\n                feeOnWithdrawX10000\\n            );\\n    }\\n\\n    /**\\n    @notice Tokens accumulated in the factory can be burned by anybody.\\n    @param token The token address\\n     */\\n    function burn(address token\\n    ) external {\\n        uint256 amount = IERC20(token).balanceOf(address(this));\\n        IBurnable(token).burn(amount);\\n    }\\n\\n    /**\\n     @notice Creats a crucible\\n     @param baseToken The base token\\n     @param name The name\\n     @param symbol The symbol\\n     @param feeOnTransferX10000 Fee on transfer over 10k\\n     @param feeOnWithdrawX10000 Fee on withdraw over 10k\\n     @return token The crucible token address\\n     */\\n    function _createCrucible(\\n        address baseToken,\\n        string memory name,\\n        string memory symbol,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) internal returns (address token) {\\n        bytes32 key = validateCrucible(\\n            baseToken,\\n            name,\\n            symbol,\\n            feeOnTransferX10000,\\n            feeOnWithdrawX10000\\n        );\\n        string memory feeOnT = StringLib.uint2str(feeOnTransferX10000);\\n        string memory feeOnW = StringLib.uint2str(feeOnWithdrawX10000);\\n        string memory cName = string(\\n            abi.encodePacked(\\\"Crucible: \\\", name, \\\" \\\", feeOnT, \\\"X\\\", feeOnW)\\n        );\\n        string memory cSymbol = string(\\n            abi.encodePacked(symbol, feeOnT, \\\"X\\\", feeOnW)\\n        );\\n        token = _createCrucibleWithName(\\n            key,\\n            baseToken,\\n            cName,\\n            cSymbol,\\n            feeOnTransferX10000,\\n            feeOnWithdrawX10000\\n        );\\n    }\\n\\n    /**\\n     @notice Validates crucible parameters\\n     @param baseToken The base token\\n     @param name The name\\n     @param symbol The symbol\\n     @param feeOnTransferX10000 Fee on transfer over 10k\\n     @param feeOnWithdrawX10000 Fee on withdraw over 10k\\n     */\\n    function validateCrucible(\\n        address baseToken,\\n        string memory name,\\n        string memory symbol,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) internal view returns (bytes32 key) {\\n        require(bytes(name).length != 0, \\\"CF: name is required\\\");\\n        require(bytes(symbol).length != 0, \\\"CF: symbol is required\\\");\\n        require(\\n            feeOnTransferX10000 != 0 || feeOnWithdrawX10000 != 0,\\n            \\\"CF: at least one fee is required\\\"\\n        );\\n        require(feeOnTransferX10000 < MAX_FEE, \\\"CF: fee too high\\\");\\n        require(feeOnWithdrawX10000 < MAX_FEE, \\\"CF: fee too high\\\");\\n        key = crucibleKey(baseToken, feeOnTransferX10000, feeOnWithdrawX10000);\\n        require(crucible[key] == address(0), \\\"CF: already exists\\\");\\n    }\\n\\n    /**\\n     @notice Creates a crucible wit the given name\\n     @param key The crucible key\\n     @param baseToken The base token\\n     @param cName The name\\n     @param cSymbol The symbol\\n     @param feeOnTransferX10000 Fee on transfer over 10k\\n     @param feeOnWithdrawX10000 Fee on withdraw over 10k\\n     */\\n    function _createCrucibleWithName(\\n        bytes32 key,\\n        address baseToken,\\n        string memory cName,\\n        string memory cSymbol,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) internal returns (address token) {\\n        token = deploy(\\n            address(this),\\n            baseToken,\\n            feeOnTransferX10000,\\n            feeOnWithdrawX10000,\\n            cName,\\n            cSymbol\\n        );\\n        crucible[key] = token;\\n        emit CrucibleCreated(\\n            token,\\n            baseToken,\\n            feeOnTransferX10000,\\n            feeOnWithdrawX10000\\n        );\\n    }\\n\\n    /**\\n     @notice Returns a name or default\\n     @param token The token\\n     @return The name\\n     */\\n    function safeName(address token\\n    ) internal view returns (string memory) {\\n        (bool succ, bytes memory data) = token.staticcall(\\n            abi.encodeWithSignature((\\\"name()\\\"))\\n        );\\n        if (succ) {\\n            return abi.decode(data, (string));\\n        } else {\\n            return \\\"Crucible\\\";\\n        }\\n    }\\n\\n    /**\\n     @notice returns the symbol or default\\n     @param token The token\\n     @return The symbol\\n     */\\n    function safeSymbol(address token\\n    ) internal view returns (string memory) {\\n        (bool succ, bytes memory data) = token.staticcall(\\n            abi.encodeWithSignature((\\\"symbol()\\\"))\\n        );\\n        require(succ, \\\"CF: Token has no symbol\\\");\\n        return abi.decode(data, (string));\\n    }\\n\\n    /**\\n     @notice Creates a key for crucible\\n     @param baseToken The base token\\n     @param feeOnTransferX10000 Fee on transfer over 10k\\n     @param feeOnWithdrawX10000 Fee on withdraw over 10k\\n     @return The key\\n     */\\n    function crucibleKey(\\n        address baseToken,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) private pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    baseToken,\\n                    feeOnTransferX10000,\\n                    feeOnWithdrawX10000\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/taxing/HasTaxDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IHasTaxDistributor.sol\\\";\\n\\n/**\\n @notice A contract that uses tax distributer\\n */\\ncontract HasTaxDistributor is Ownable, IHasTaxDistributor {\\n\\taddress public override taxDistributor;\\n\\n    /**\\n     @notice Sets the tax distributor. Only owner can call this function\\n     @param _taxDistributor The tax distributor\\n     */\\n\\tfunction setTaxDistributor(address _taxDistributor) external onlyOwner {\\n\\t\\ttaxDistributor = _taxDistributor;\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/common/signature/MultiSigCheckable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../WithAdmin.sol\\\";\\nimport \\\"./MultiSigLib.sol\\\";\\n\\n/**\\n @notice\\n    Base class for contracts handling multisig transactions\\n      Rules:\\n      - First set up the master governance quorum (groupId 1). onlyOwner\\n\\t  - Owner can remove public or custom quorums, but cannot remove governance\\n\\t  quorums.\\n\\t  - Once master governance is setup, governance can add / remove any quorums\\n\\t  - All actions can only be submitted to chain by admin or owner\\n */\\nabstract contract MultiSigCheckable is WithAdmin, EIP712 {\\n    uint16 public constant GOVERNANCE_GROUP_ID_MAX = 256;\\n    uint32 constant WEEK = 3600 * 24 * 7;\\n    struct Quorum {\\n        address id;\\n        uint64 groupId; // GroupId: 0 => General, 1 => Governance, >1 => Custom\\n        uint16 minSignatures;\\n        // If the quorum is owned, only owner can change its config.\\n        // Owner must be a governence q (id <256)\\n        uint8 ownerGroupId;\\n    }\\n    event QuorumCreated(Quorum quorum);\\n    event QuorumUpdated(Quorum quorum);\\n    event AddedToQuorum(address quorumId, address subscriber);\\n    event RemovedFromQuorum(address quorumId, address subscriber);\\n\\n    mapping(bytes32 => bool) public usedHashes;\\n    mapping(address => Quorum) public quorumSubscriptions; // Repeating quorum defs to reduce reads\\n    mapping(address => Quorum) public quorums;\\n    mapping(address => uint256) public quorumsSubscribers;\\n    address[] public quorumList; // Only for transparency. Not used. To sanity check quorums offchain\\n\\n    modifier governanceGroupId(uint64 expectedGroupId) {\\n        require(\\n            expectedGroupId < GOVERNANCE_GROUP_ID_MAX,\\n            \\\"MSC: must be governance\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier expiryRange(uint64 expiry) {\\n        require(block.timestamp < expiry, \\\"CR: signature timed out\\\");\\n        require(expiry < block.timestamp + WEEK, \\\"CR: expiry too far\\\");\\n        _;\\n    }\\n\\n    /**\\n     @notice Force remove from quorum (if managed)\\n        to allow last resort option in case a quorum\\n        goes rogue. Overwrite if you don't need an admin control\\n        No check on minSig so if the no of members drops below\\n        minSig, the quorum becomes unusable.\\n     @param _address The address to be removed from quorum\\n     */\\n    function forceRemoveFromQuorum(address _address)\\n        external\\n        virtual\\n        onlyAdmin\\n    {\\n        Quorum memory q = quorumSubscriptions[_address];\\n        require(q.id != address(0), \\\"MSC: subscription not found\\\");\\n        _removeFromQuorum(_address, q.id);\\n    }\\n\\n    bytes32 constant REMOVE_FROM_QUORUM_METHOD =\\n        keccak256(\\\"RemoveFromQuorum(address _address,bytes32 salt,uint64 expiry)\\\");\\n\\n    /**\\n     @notice Removes an address from the quorum. Note the number of addresses \\n      in the quorum cannot drop below minSignatures\\n     @param _address The address to remove\\n     @param salt The signature salt\\n     @param expiry The expiry\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function removeFromQuorum(\\n        address _address,\\n        bytes32 salt,\\n        uint64 expiry,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        require(_address != address(0), \\\"MSC: address required\\\");\\n        require(salt != 0, \\\"MSC: salt required\\\");\\n        Quorum memory q = quorumSubscriptions[_address];\\n        require(q.id != address(0), \\\"MSC: subscription not found\\\");\\n        bytes32 message = keccak256(\\n            abi.encode(REMOVE_FROM_QUORUM_METHOD, _address, salt, expiry)\\n        );\\n        uint64 expectedGroupId = q.ownerGroupId != 0\\n            ? q.ownerGroupId\\n            : q.groupId;\\n        verifyUniqueSalt(message, salt, expectedGroupId, multiSignature);\\n        uint256 subs = quorumsSubscribers[q.id];\\n        require(subs >= q.minSignatures + 1, \\\"MSC: quorum becomes ususable\\\");\\n        _removeFromQuorum(_address, q.id);\\n    }\\n\\n    bytes32 constant ADD_TO_QUORUM_METHOD =\\n        keccak256(\\n            \\\"AddToQuorum(address _address,address quorumId,bytes32 salt,uint64 expiry)\\\"\\n        );\\n\\n    /**\\n     @notice Adds an address to the quorum\\n     @param _address The address to be added\\n     @param quorumId The quorum ID\\n     @param salt The signature salt\\n     @param expiry The expiry\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function addToQuorum(\\n        address _address,\\n        address quorumId,\\n        bytes32 salt,\\n        uint64 expiry,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        require(quorumId != address(0), \\\"MSC: quorumId required\\\");\\n        require(_address != address(0), \\\"MSC: address required\\\");\\n        require(salt != 0, \\\"MSC: salt required\\\");\\n        bytes32 message = keccak256(\\n            abi.encode(ADD_TO_QUORUM_METHOD, _address, quorumId, salt, expiry)\\n        );\\n        Quorum memory q = quorums[quorumId];\\n        require(q.id != address(0), \\\"MSC: quorum not found\\\");\\n        uint64 expectedGroupId = q.ownerGroupId != 0\\n            ? q.ownerGroupId\\n            : q.groupId;\\n        verifyUniqueSalt(message, salt, expectedGroupId, multiSignature);\\n        quorumSubscriptions[_address] = q;\\n        quorumsSubscribers[q.id] += 1;\\n        emit AddedToQuorum(quorumId, _address);\\n    }\\n\\n    bytes32 constant UPDATE_MIN_SIGNATURE_MEHTOD =\\n        keccak256(\\n            \\\"UpdateMinSignature(address quorumId,uint16 minSignature,bytes32 salt,uint64 expiry)\\\"\\n        );\\n\\n    /**\\n     @notice Updates the min signature for a quorum\\n     @param quorumId The quorum ID\\n     @param minSignature The new minSignature\\n     @param salt The signature salt\\n     @param expiry The expiry\\n     @param multiSignature The multisig encoded signature\\n     */\\n    function updateMinSignature(\\n        address quorumId,\\n        uint16 minSignature,\\n        bytes32 salt,\\n        uint64 expiry,\\n        bytes memory multiSignature\\n    ) external expiryRange(expiry) {\\n        require(quorumId != address(0), \\\"MSC: quorumId required\\\");\\n        require(minSignature > 0, \\\"MSC: minSignature required\\\");\\n        require(salt != 0, \\\"MSC: salt required\\\");\\n        Quorum memory q = quorums[quorumId];\\n        require(q.id != address(0), \\\"MSC: quorumId not found\\\");\\n        require(\\n            quorumsSubscribers[q.id] >= minSignature,\\n            \\\"MSC: minSignature is too large\\\"\\n        );\\n        bytes32 message = keccak256(\\n            abi.encode(\\n                UPDATE_MIN_SIGNATURE_MEHTOD,\\n                quorumId,\\n                minSignature,\\n                salt,\\n                expiry\\n            )\\n        );\\n        uint64 expectedGroupId = q.ownerGroupId != 0\\n            ? q.ownerGroupId\\n            : q.groupId;\\n        verifyUniqueSalt(message, salt, expectedGroupId, multiSignature);\\n        quorums[quorumId].minSignatures = minSignature;\\n    }\\n\\n    bytes32 constant CANCEL_SALTED_SIGNATURE =\\n        keccak256(\\\"CancelSaltedSignature(bytes32 salt)\\\");\\n\\n    /**\\n     @notice Cancel a salted signature\\n        Remove this method if public can create groupIds.\\n        People can write bots to prevent a person to execute a signed message.\\n        This is useful for cases that the signers have signed a message\\n        and decide to change it.\\n        They can cancel the salt first, then issue a new signed message.\\n     @param salt The signature salt\\n     @param expectedGroupId Expected group ID for the signature\\n     @param multiSignature The multisig encoded signature\\n    */\\n    function cancelSaltedSignature(\\n        bytes32 salt,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) external virtual {\\n        require(salt != 0, \\\"MSC: salt required\\\");\\n        bytes32 message = keccak256(abi.encode(CANCEL_SALTED_SIGNATURE, salt));\\n        require(\\n            expectedGroupId != 0 && expectedGroupId < 256,\\n            \\\"MSC: not governance groupId\\\"\\n        );\\n        verifyUniqueSalt(message, salt, expectedGroupId, multiSignature);\\n    }\\n\\n    /**\\n    @notice Initialize a quorum\\n        Override this to allow public creatig new quorums.\\n        If you allow public creating quorums, you MUST NOT have\\n        customized groupIds. Make sure groupId is created from\\n        hash of a quorum and is not duplicate.\\n    @param quorumId The unique quorumID\\n    @param groupId The groupID, which can be shared by quorums (if managed)\\n    @param minSignatures The minimum number of signatures for the quorum\\n    @param ownerGroupId The owner group ID. Can modify this quorum (if managed)\\n    @param addresses List of addresses in the quorum\\n    */\\n    function initialize(\\n        address quorumId,\\n        uint64 groupId,\\n        uint16 minSignatures,\\n        uint8 ownerGroupId,\\n        address[] calldata addresses\\n    ) public virtual onlyAdmin {\\n        _initialize(quorumId, groupId, minSignatures, ownerGroupId, addresses);\\n    }\\n\\n    /**\\n     @notice Initializes a quorum\\n     @param quorumId The quorum ID\\n     @param groupId The group ID\\n     @param minSignatures The min signatures\\n     @param ownerGroupId The owner group ID\\n     @param addresses The initial addresses in the quorum\\n     */\\n    function _initialize(\\n        address quorumId,\\n        uint64 groupId,\\n        uint16 minSignatures,\\n        uint8 ownerGroupId,\\n        address[] calldata addresses\\n    ) internal virtual {\\n        require(quorumId != address(0), \\\"MSC: quorumId required\\\");\\n        require(addresses.length > 0, \\\"MSC: addresses required\\\");\\n        require(minSignatures != 0, \\\"MSC: minSignatures required\\\");\\n        require(\\n            minSignatures <= addresses.length,\\n            \\\"MSC: minSignatures too large\\\"\\n        );\\n        require(quorums[quorumId].id == address(0), \\\"MSC: already initialized\\\");\\n        Quorum memory q = Quorum({\\n            id: quorumId,\\n            groupId: groupId,\\n            minSignatures: minSignatures,\\n            ownerGroupId: ownerGroupId\\n        });\\n        quorums[quorumId] = q;\\n        quorumList.push(quorumId);\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            require(\\n                quorumSubscriptions[addresses[i]].id == address(0),\\n                \\\"MSC: only one quorum per subscriber\\\"\\n            );\\n            quorumSubscriptions[addresses[i]] = q;\\n        }\\n        quorumsSubscribers[quorumId] = addresses.length;\\n        emit QuorumCreated(q);\\n    }\\n\\n    /**\\n     @notice Remove an address from the quorum\\n     @param _address the address\\n     @param qId The quorum ID\\n     */\\n    function _removeFromQuorum(address _address, address qId) internal {\\n        delete quorumSubscriptions[_address];\\n        quorumsSubscribers[qId] = quorumsSubscribers[qId] - 1;\\n        emit RemovedFromQuorum(qId, _address);\\n    }\\n\\n    /**\\n     @notice Checking salt's uniqueness because same message can be signed with different people.\\n     @param message The message to verify\\n     @param salt The salt to be unique\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The signatures formatted as a multisig\\n     */\\n    function verifyUniqueSalt(\\n        bytes32 message,\\n        bytes32 salt,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) internal {\\n        require(multiSignature.length != 0, \\\"MSC: multiSignature required\\\");\\n        (, bool result) = tryVerify(message, expectedGroupId, multiSignature);\\n        require(result, \\\"MSC: Invalid signature\\\");\\n        require(!usedHashes[salt], \\\"MSC: Message already used\\\");\\n        usedHashes[salt] = true;\\n    }\\n\\n    /**\\n     @notice Verifies the a unique un-salted message\\n     @param message The message hash\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The signatures formatted as a multisig\\n     */\\n    function verifyUniqueMessageDigest(\\n        bytes32 message,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) internal {\\n        require(multiSignature.length != 0, \\\"MSC: multiSignature required\\\");\\n        (bytes32 salt, bool result) = tryVerify(\\n            message,\\n            expectedGroupId,\\n            multiSignature\\n        );\\n        require(result, \\\"MSC: Invalid signature\\\");\\n        require(!usedHashes[salt], \\\"MSC: Message digest already used\\\");\\n        usedHashes[salt] = true;\\n    }\\n\\n    /**\\n     @notice Tries to verify a digest message\\n     @param digest The digest\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The signatures formatted as a multisig\\n     @return result Identifies success or failure\\n     */\\n    function tryVerifyDigest(\\n        bytes32 digest,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) internal view returns (bool result) {\\n        (result, ) = tryVerifyDigestWithAddress(\\n            digest,\\n            expectedGroupId,\\n            multiSignature\\n        );\\n    }\\n\\n    /**\\n     @notice Returns if the digest can be verified\\n     @param digest The digest\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The signatures formatted as a multisig\\n     @return result Identifies success or failure\\n     @return signers Lis of signers\\n     */\\n    function tryVerifyDigestWithAddress(\\n        bytes32 digest,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) internal view returns (bool result, address[] memory signers) {\\n        require(multiSignature.length != 0, \\\"MSC: multiSignature required\\\");\\n        MultiSigLib.Sig[] memory signatures = MultiSigLib.parseSig(\\n            multiSignature\\n        );\\n        require(signatures.length > 0, \\\"MSC: no zero len signatures\\\");\\n        signers = new address[](signatures.length);\\n\\n        address _signer = ECDSA.recover(\\n            digest,\\n            signatures[0].v,\\n            signatures[0].r,\\n            signatures[0].s\\n        );\\n        address quorumId = quorumSubscriptions[_signer].id;\\n        if (quorumId == address(0)) {\\n            return (false, new address[](0));\\n        }\\n        Quorum memory q = quorums[quorumId];\\n        for (uint256 i = 1; i < signatures.length; i++) {\\n            // console.log(\\\"About to do signature\\\", i);\\n            // console.logBytes32(_domainSeparatorV4());\\n            // console.logBytes32(digest);\\n            _signer = ECDSA.recover(\\n                digest,\\n                signatures[i].v,\\n                signatures[i].r,\\n                signatures[i].s\\n            );\\n            // console.log(\\\"Signer\\\", _signer);\\n            quorumId = quorumSubscriptions[_signer].id;\\n            if (quorumId == address(0)) {\\n                return (false, new address[](0));\\n            }\\n            require(\\n                q.id == quorumId,\\n                \\\"MSC: all signers must be of same quorum\\\"\\n            );\\n\\n            require(\\n                expectedGroupId == 0 || q.groupId == expectedGroupId,\\n                \\\"MSC: invalid groupId for signer\\\"\\n            );\\n            signers[i] = _signer;\\n        }\\n        require(\\n            signatures.length >= q.minSignatures,\\n            \\\"MSC: not enough signatures\\\"\\n        );\\n        return (true, signers);\\n    }\\n\\n    /**\\n     @notice Tries to verify a message hash\\n        @dev example message;\\n\\n        bytes32 constant METHOD_SIG =\\n            keccak256(\\\"WithdrawSigned(address token,address payee,uint256 amount,bytes32 salt)\\\");\\n        bytes32 message = keccak256(abi.encode(\\n          METHOD_SIG,\\n          token,\\n          payee,\\n          amount,\\n          salt\\n     @param message The message\\n     @param expectedGroupId The expected group ID\\n     @param multiSignature The signatures formatted as a multisig\\n    */\\n    function tryVerify(\\n        bytes32 message,\\n        uint64 expectedGroupId,\\n        bytes memory multiSignature\\n    ) internal view returns (bytes32 digest, bool result) {\\n        digest = _hashTypedDataV4(message);\\n        result = tryVerifyDigest(digest, expectedGroupId, multiSignature);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/signature/Allocatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./SigCheckable.sol\\\";\\nimport \\\"../WithAdmin.sol\\\";\\n\\nabstract contract Allocatable is SigCheckable, WithAdmin {\\n    mapping(address => bool) public signers;\\n\\n    function addSigner(address _signer) external onlyOwner() {\\n        require(_signer != address(0), \\\"Bad signer\\\");\\n        signers[_signer] = true;\\n    }\\n\\n    function removeSigner(address _signer) external onlyOwner() {\\n        require(_signer != address(0), \\\"Bad signer\\\");\\n        delete signers[_signer];\\n    }\\n\\n    bytes32 constant AMOUNT_SIGNED_METHOD =\\n        keccak256(\\\"AmountSigned(bytes4 method, address token,address payee,address to,uint256 amount,uint64 expiry,bytes32 salt)\\\");\\n    function amountSignedMessage(\\n\\t\\t\\tbytes4 method,\\n            address token,\\n            address payee,\\n            address to,\\n            uint256 amount,\\n\\t\\t\\tuint64 expiry,\\n            bytes32 salt)\\n    internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n          AMOUNT_SIGNED_METHOD,\\n\\t\\t  method,\\n          token,\\n          payee,\\n\\t\\t  to,\\n          amount,\\n\\t\\t  expiry,\\n          salt));\\n    }\\n\\n    function verifyAmountUnique(\\n\\t\\t\\tbytes4 method,\\n            address token,\\n            address payee,\\n            address to,\\n            uint256 amount,\\n            bytes32 salt,\\n\\t\\t\\tuint64 expiry,\\n            bytes memory signature)\\n    internal {\\n\\t\\trequire(expiry == 0 || block.timestamp > expiry, \\\"Allocatable: sig expired\\\");\\n        bytes32 message = amountSignedMessage(method, token, payee, to, amount, expiry, salt);\\n        address _signer = signerUnique(message, signature);\\n        require(signers[_signer], \\\"Allocatable: Invalid signer\\\");\\n\\t}\\n\\n    function verifyAmount(\\n\\t\\t\\tbytes4 method,\\n            address token,\\n            address payee,\\n            address to,\\n            uint256 amount,\\n            bytes32 salt,\\n\\t\\t\\tuint64 expiry,\\n            bytes memory signature)\\n    internal view {\\n\\t\\trequire(expiry == 0 || block.timestamp > expiry, \\\"Allocatable: sig expired\\\");\\n        bytes32 message = amountSignedMessage(method, token, payee, to, amount, expiry, salt);\\n        (,address _signer) = signer(message, signature);\\n        require(signers[_signer], \\\"Allocatable: Invalid signer\\\");\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/common/SafeAmount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary SafeAmount {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     @notice transfer tokens from. Incorporate fee on transfer tokens\\n     @param token The token\\n     @param from From address\\n     @param to To address\\n     @param amount The amount\\n     @return result The actual amount transferred\\n     */\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount) internal returns (uint256 result) {\\n        uint256 preBalance = IERC20(token).balanceOf(to);\\n        IERC20(token).safeTransferFrom(from, to, amount);\\n        uint256 postBalance = IERC20(token).balanceOf(to);\\n        result = postBalance - preBalance;\\n        require(result <= amount, \\\"SA: actual amount larger than transfer amount\\\");\\n    }\\n\\n    /**\\n     @notice Sends ETH\\n     @param to The to address\\n     @param value The amount\\n     */\\n\\tfunction safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/IBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBurnable {\\n    function burn(uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/common/IFerrumDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IFerrumDeployer {\\n    function initData() external returns (bytes memory);\\n}\"\r\n    },\r\n    \"contracts/crucible/ICrucibleFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\ninterface ICrucibleFactory {\\n    function getCrucible(\\n        address baseToken,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000\\n    ) external view returns (address);\\n\\n    function router() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/crucible/CrucibleTokenDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"./CrucibleToken.sol\\\";\\n\\nabstract contract CrucibleTokenDeployer is ICrucibleTokenDeployer {\\n    struct Parameters {\\n        address factory;\\n        address baseToken;\\n        uint64 feeOnTransferX10000;\\n        uint64 feeOnWithdrawX10000;\\n        string name;\\n        string symbol;\\n    }\\n\\n    Parameters public override parameters;\\n\\n    /**\\n     @notice Deploys a crucible token\\n     @param factory The factory\\n     @param baseToken The base token\\n     @param feeOnTransferX10000 Fee on transfer rate per 10k\\n     @param feeOnWithdrawX10000 Fee on withdraw rate per 10k\\n     @param name The name\\n     @param symbol The symbol\\n     @return token The deployed token address\\n     */\\n    function deploy(\\n        address factory,\\n        address baseToken,\\n        uint64 feeOnTransferX10000,\\n        uint64 feeOnWithdrawX10000,\\n        string memory name,\\n        string memory symbol\\n    ) internal returns (address token) {\\n        parameters = Parameters({\\n            factory: factory,\\n            baseToken: baseToken,\\n            feeOnTransferX10000: feeOnTransferX10000,\\n            feeOnWithdrawX10000: feeOnWithdrawX10000,\\n            name: name,\\n            symbol: symbol\\n        });\\n\\n        token = address(\\n            new CrucibleToken{\\n                salt: keccak256(\\n                    abi.encode(\\n                        baseToken,\\n                        feeOnTransferX10000,\\n                        feeOnWithdrawX10000\\n                    )\\n                )\\n            }()\\n        );\\n        delete parameters;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/factory/NoDelegateCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @title Prevents delegatecall to a contract\\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\\nabstract contract NoDelegateCall {\\n    /// @dev The original address of this contract\\n    address private immutable original;\\n\\n    constructor() {\\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\\n        // In other words, this variable won't change when it's checked at runtime.\\n        original = address(this);\\n    }\\n\\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\\n    function checkNotDelegateCall() private view {\\n        require(address(this) == original);\\n    }\\n\\n    /// @notice Prevents delegatecall into the modified method\\n    modifier noDelegateCall() {\\n        checkNotDelegateCall();\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/strings/StringLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary StringLib {\\n\\t// Taken from: \\n\\t// https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\\n\\tfunction uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len;\\n        while (_i != 0) {\\n            k = k-1;\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n\\tfunction strToB32(string memory s) internal pure returns (bytes32 len, bytes32 b1, bytes32 b2) {\\n\\t\\tbytes memory t = bytes(s);\\n\\t\\tassembly {\\n\\t\\t\\tlen := mload(s)\\n\\t\\t\\tb1 := mload(add(s, 32))\\n\\t\\t}\\n\\t\\tif (t.length >= 16) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tb2 := mload(add(s, 64))\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tb2 = 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction b32ToStr(bytes32 len, bytes32 b1, bytes32 b2, uint256 maxLen) internal pure returns (string memory str) {\\n\\t\\trequire(maxLen <= 64, \\\"maxLen\\\");\\n\\t\\tbytes memory t;\\n\\t\\tuint256 l = uint256(len);\\n\\t\\tif (l > maxLen) {\\n\\t\\t\\tlen = bytes32(maxLen);\\n\\t\\t}\\n\\t\\tassembly {\\n\\t\\t\\tmstore(t, len)\\n\\t\\t\\tmstore(add(t, 32), b1)\\n\\t\\t}\\n\\t\\tif (uint256(len) >= 16) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(add(t, 64), b2)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tstr = string(t);\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/common/WithAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract WithAdmin is Ownable {\\n\\taddress public admin;\\n\\tevent AdminSet(address admin);\\n\\n\\tfunction setAdmin(address _admin) external onlyOwner {\\n\\t\\tadmin = _admin;\\n\\t\\temit AdminSet(_admin);\\n\\t}\\n\\n\\tmodifier onlyAdmin() {\\n\\t\\trequire(msg.sender == admin || msg.sender == owner(), \\\"WA: not admin\\\");\\n\\t\\t_;\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/crucible/CrucibleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"./ICrucibleToken.sol\\\";\\nimport \\\"./ICrucibleTokenDeployer.sol\\\";\\nimport \\\"./ICrucibleFactory.sol\\\";\\nimport \\\"../taxing/IHasTaxDistributor.sol\\\";\\nimport \\\"../taxing/IGeneralTaxDistributor.sol\\\";\\nimport \\\"../common/ERC20/ERC20.sol\\\";\\nimport \\\"../common/math/FullMath.sol\\\";\\nimport \\\"../staking/library/TokenReceivable.sol\\\";\\n\\ncontract CrucibleToken is ERC20, TokenReceivable, ICrucibleToken {\\n    uint256 constant MAX_FEE_X10k = 0.6 * 10000;\\n\\n    struct FeeOverride {\\n        OverrideState over;\\n        uint64 feeX10000;\\n    }\\n\\n    address public immutable factory;\\n    address public router;\\n    address public override baseToken; // Remocing immutables to allow etherscan verification to work. Hopefully etherscan gives us a solution\\n    uint64 public feeOnTransferX10000;\\n    uint64 public feeOnWithdrawX10000;\\n    mapping(address => FeeOverride) public feeOverrides;\\n\\n    event Withdrawn(uint256 amount, uint256 fee, address from, address to);\\n    event Deposited(address token, uint256 amount, address to);\\n    event FeeSet(address target, OverrideState overrideType, uint64 feeX10k);\\n    event FeesUpdated(uint64 feeOnTransferX10000, uint64 feeOnWithdrawX10000);\\n\\n    modifier onlyRouter() {\\n        require(msg.sender == router, \\\"CT: not allowed\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        address token;\\n        address fac;\\n        (\\n            fac,\\n            token,\\n            feeOnTransferX10000,\\n            feeOnWithdrawX10000,\\n            name,\\n            symbol\\n        ) = ICrucibleTokenDeployer(msg.sender).parameters();\\n        decimals = safeDecimals(token);\\n        baseToken = token;\\n        router = ICrucibleFactory(fac).router();\\n        factory = fac;\\n    }\\n\\n    /**\\n     @notice Upgrades a router\\n     @param _router The new router\\n     @dev Can only be called by the current router\\n     */\\n    function upgradeRouter(address _router\\n    ) external override onlyRouter {\\n        require(_router != address(0), \\\"CT: router required\\\");\\n        router = _router;\\n    }\\n\\n    /**\\n     @notice Allow overriding the global crucible fees. Only router action\\n     @param newFeeOnTransferX10000 Fee on transfer\\n     @param newFeeOnWithdrawX10000 Fee on withdraw\\n     */\\n    function updateCrucibleFees(\\n        uint64 newFeeOnTransferX10000,\\n        uint64 newFeeOnWithdrawX10000\\n    ) external override onlyRouter {\\n        require(newFeeOnTransferX10000 < MAX_FEE_X10k, \\\"CT: fee too large\\\");\\n        require(newFeeOnWithdrawX10000 < MAX_FEE_X10k, \\\"CT: fee too large\\\");\\n        feeOnTransferX10000 = newFeeOnTransferX10000;\\n        feeOnWithdrawX10000 = newFeeOnWithdrawX10000;\\n        emit FeesUpdated(feeOnTransferX10000, feeOnWithdrawX10000);\\n    }\\n\\n    /**\\n     @notice Overrides fee for a target\\n     @param target The target to be overriden\\n     @param overrideType The type of override\\n     @param newFeeX10000 The new fee\\n     @dev Can only be called by the router\\n     */\\n    function overrideFee(\\n        address target,\\n        OverrideState overrideType,\\n        uint64 newFeeX10000\\n    ) external override onlyRouter {\\n        require(newFeeX10000 < MAX_FEE_X10k, \\\"CT: fee too large\\\");\\n        feeOverrides[target] = FeeOverride({\\n            over: overrideType,\\n            feeX10000: newFeeX10000\\n        });\\n        emit FeeSet(target, overrideType, newFeeX10000);\\n    }\\n\\n    /**\\n     @notice Deposits into the crucible\\n        Can only be called by the router\\n     @param to Receiver of minted tokens\\n     @return amount The deposited amount\\n     */\\n    function deposit(address to\\n    ) external override onlyRouter returns (uint256 amount) {\\n        amount = sync(baseToken);\\n        require(amount != 0, \\\"CT: empty\\\");\\n        _mint(to, amount);\\n        emit Deposited(baseToken, amount, to);\\n    }\\n\\n    /**\\n     @notice Withdraws from the crucible\\n     @param to Receiver of minted tokens\\n     @param amount The amount to withdraw\\n     @return fee The fee\\n     @return withdrawn The withdrawn amounts\\n     */\\n    function withdraw(address to, uint256 amount\\n    ) external override returns (uint256 fee, uint256 withdrawn) {\\n        (fee, withdrawn) = _withdraw(msg.sender, to, amount);\\n    }\\n\\n    /*\\n     @notice Burn the underlying asset. If not burnable, send to the factory.\\n     @param amount Amount to burn\\n     */\\n    function burn(uint256 amount\\n    ) external virtual {\\n        require(amount != 0, \\\"CT: amount required\\\");\\n        doBurn(msg.sender, amount);\\n    }\\n\\n    /*\\n     @notice Burn the underlying asset. If not burnable, send to the factory.\\n     @param from The address to burn from\\n     @param amount Amount to burn\\n     */\\n    function burnFrom(address from, uint256 amount\\n    ) external virtual {\\n        require(from != address(0), \\\"CT: from required\\\");\\n        require(amount != 0, \\\"CT: amount required\\\");\\n        uint256 decreasedAllowance = allowance[from][msg.sender] - amount;\\n\\n        _approve(from, msg.sender, decreasedAllowance);\\n        doBurn(from, amount);\\n    }\\n\\n    /**\\n     @notice Withdraws from crucible\\n     @param from From address\\n     @param to To address\\n     @param amount The amount\\n     @return fee The fee\\n     @return withdrawn The withdrawn amount\\n     */\\n    function _withdraw(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual returns (uint256 fee, uint256 withdrawn) {\\n        fee = calculateFeeX10000(amount, feeOnWithdrawX10000);\\n        withdrawn = amount - fee;\\n        address td = IHasTaxDistributor(router).taxDistributor();\\n        if (fee != 0) {\\n            tax(from, td, fee);\\n        }\\n        _burn(from, withdrawn);\\n        sendToken(baseToken, to, withdrawn);\\n        emit Withdrawn(amount, fee, from, to);\\n    }\\n\\n    /**\\n     @notice Burns tokens. Send base tokens to factory to be locke or burned later\\n     @param from The from address\\n     @param amount The amount\\n     */\\n    function doBurn(address from, uint256 amount\\n    ) internal {\\n        sendToken(baseToken, factory, amount);\\n        _burn(from, amount);\\n    }\\n\\n    /**\\n     @notice Overrides the ERC20 transfer method\\n     @param sender The sender\\n     @param recipient The recipient\\n     @param amount The amount\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual override {\\n        FeeOverride memory overFrom = feeOverrides[sender];\\n        FeeOverride memory overTo = feeOverrides[recipient];\\n        address td = IHasTaxDistributor(router).taxDistributor();\\n        if (sender == td || recipient == td) {\\n            _doTransfer(sender, recipient, amount);\\n            return;\\n        }\\n\\n        uint256 feeRatioX10k = 0;\\n        bool overriden = false;\\n        if (\\n            overFrom.over == OverrideState.OverrideOut ||\\n            overFrom.over == OverrideState.OverrideBoth\\n        ) {\\n            feeRatioX10k = overFrom.feeX10000;\\n            overriden = true;\\n        }\\n        if (\\n            (overTo.over == OverrideState.OverrideIn ||\\n                overTo.over == OverrideState.OverrideBoth) &&\\n            overTo.feeX10000 >= feeRatioX10k\\n        ) {\\n            feeRatioX10k = overTo.feeX10000;\\n            overriden = true;\\n        }\\n        if (feeRatioX10k == 0 && !overriden) {\\n            feeRatioX10k = feeOnTransferX10000;\\n        }\\n        uint256 fee = feeRatioX10k == 0 ? 0 : calculateFeeX10000(amount, feeRatioX10k);\\n        amount = amount - fee;\\n        if (fee != 0) {\\n            tax(sender, td, fee);\\n        }\\n        _doTransfer(sender, recipient, amount);\\n    }\\n\\n    /**\\n     @notice Just does the transfer\\n     @param sender The sender\\n     @param recipient The recipient\\n     @param amount The amount\\n     */\\n    function _doTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        ERC20._transfer(sender, recipient, amount);\\n    }\\n\\n    /**\\n     @notice charges the tax\\n     @param from From address\\n     @param taxDist The tax distributor contract\\n     @param amount The tax amount\\n     */\\n    function tax(\\n        address from,\\n        address taxDist,\\n        uint256 amount\\n    ) internal {\\n        _doTransfer(from, taxDist, amount);\\n        IGeneralTaxDistributor(taxDist).distributeTaxAvoidOrigin(address(this), from);\\n    }\\n\\n    /**\\n     @notice Gets the decimals or default\\n     @param token The token\\n     @return The decimals\\n     */\\n    function safeDecimals(address token\\n    ) private view returns (uint8) {\\n        (bool succ, bytes memory data) = token.staticcall(\\n            abi.encodeWithSignature((\\\"decimals()\\\"))\\n        );\\n        if (succ) {\\n            return abi.decode(data, (uint8));\\n        } else {\\n            return 18;\\n        }\\n    }\\n\\n    /**\\n     @notice Calculates the fee\\n     @param amount The amount\\n     @param feeX10000 The fee rate\\n     @return The fee amount\\n     */\\n    function calculateFeeX10000(uint256 amount, uint256 feeX10000\\n    ) private pure returns (uint256) {\\n        return FullMath.mulDiv(amount, feeX10000, 10000);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crucible/ICrucibleTokenDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\ninterface ICrucibleTokenDeployer {\\n    function parameters()\\n        external\\n        returns (\\n            address,\\n            address,\\n            uint64,\\n            uint64,\\n            string memory,\\n            string memory\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/taxing/IHasTaxDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IHasTaxDistributor {\\n\\tfunction taxDistributor() external returns (address);\\n}\"\r\n    },\r\n    \"contracts/common/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nabstract contract ERC20 {\\n    using SafeMath for uint;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals = 18;\\n    uint  public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) internal {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) internal virtual {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint).max) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/math/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n        // uint256 twos = -denominator & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/staking/library/TokenReceivable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @notice Library for handling safe token transactions including fee per transaction tokens.\\n */\\nabstract contract TokenReceivable is ReentrancyGuard {\\n  using SafeERC20 for IERC20;\\n  mapping(address => uint256) public inventory; // Amount of received tokens that are accounted for\\n\\n  /**\\n   @notice Sync the inventory of a token based on amount changed\\n   @param token The token address\\n   @return amount The changed amount\\n   */\\n  function sync(address token) internal nonReentrant returns (uint256 amount) {\\n    uint256 inv = inventory[token];\\n    uint256 balance = IERC20(token).balanceOf(address(this));\\n    amount = balance - inv;\\n    inventory[token] = balance;\\n  }\\n\\n  /**\\n   @notice Safely sends a token out and updates the inventory\\n   @param token The token address\\n   @param payee The payee\\n   @param amount The amount\\n   */\\n  function sendToken(address token, address payee, uint256 amount) internal nonReentrant {\\n    inventory[token] = inventory[token] - amount;\\n    IERC20(token).safeTransfer(payee, amount);\\n  }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/signature/MultiSigLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary MultiSigLib {\\n\\tstruct Sig { uint8 v; bytes32 r; bytes32 s; }\\n\\n\\t/**\\n\\t * Signature is encoded as below:\\n\\t * every two bytes32, is an (r, s) pair.\\n\\t * last bytes32 is the v's array.\\n\\t * If we have more than 32 sigs, more\\n\\t * bytes at the end are dedicated to vs.\\n\\t */\\n\\tfunction parseSig(bytes memory multiSig)\\n\\tinternal pure returns (Sig[] memory sigs) {\\n\\t\\tuint cnt = multiSig.length / 32;\\n\\t\\tcnt = cnt * 32 * 2 / (2*32+1);\\n\\t\\tuint vLen = (multiSig.length / 32) - cnt;\\n\\t\\trequire(cnt - (cnt / 2 * 2) == 0, \\\"MSL: Invalid sig size\\\");\\n\\t\\tsigs = new Sig[](cnt / 2);\\n\\t\\tuint rPtr = 0x20;\\n\\t\\tuint sPtr = 0x40;\\n\\t\\tuint vPtr = multiSig.length - (vLen * 0x20) + 1;\\n\\t\\tfor (uint i=0; i<cnt / 2; i++) {\\n\\t\\t\\tbytes32 r;\\n\\t\\t\\tbytes32 s;\\n\\t\\t\\tuint8 v;\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tr := mload(add(multiSig, rPtr))\\n\\t\\t\\t\\t\\ts := mload(add(multiSig, sPtr))\\n\\t\\t\\t\\t\\tv := mload(add(multiSig, vPtr))\\n\\t\\t\\t}\\n\\t\\t\\trPtr = rPtr + 0x40;\\n\\t\\t\\tsPtr = sPtr + 0x40;\\n\\t\\t\\tvPtr = vPtr + 1;\\n\\n\\t\\t\\tsigs[i].v = v;\\n\\t\\t\\tsigs[i].r = r;\\n\\t\\t\\tsigs[i].s = s;\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/common/signature/SigCheckable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n @dev Make sure to define method signatures\\n */\\nabstract contract SigCheckable is EIP712 {\\n    mapping(bytes32=>bool) public usedHashes;\\n\\n    function signerUnique(\\n        bytes32 message,\\n        bytes memory signature) internal returns (address _signer) {\\n        bytes32 digest;\\n        (digest, _signer) = signer(message, signature);\\n        require(!usedHashes[digest], \\\"Message already used\\\");\\n        usedHashes[digest] = true;\\n    }\\n\\n    /*\\n        @dev example message;\\n\\n        bytes32 constant METHOD_SIG =\\n            keccak256(\\\"WithdrawSigned(address token,address payee,uint256 amount,bytes32 salt)\\\");\\n        bytes32 message = keccak256(abi.encode(\\n          METHOD_SIG,\\n          token,\\n          payee,\\n          amount,\\n          salt\\n    */\\n    function signer(\\n        bytes32 message,\\n        bytes memory signature) internal view returns (bytes32 digest, address _signer) {\\n        digest = _hashTypedDataV4(message);\\n        _signer = ECDSA.recover(digest, signature);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quorumId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"AddedToQuorum\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"groupId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"minSignatures\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"ownerGroupId\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct MultiSigCheckable.Quorum\",\"name\":\"quorum\",\"type\":\"tuple\"}],\"name\":\"QuorumCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"groupId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"minSignatures\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"ownerGroupId\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct MultiSigCheckable.Quorum\",\"name\":\"quorum\",\"type\":\"tuple\"}],\"name\":\"QuorumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quorumId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"RemovedFromQuorum\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GOVERNANCE_GROUP_ID_MAX\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quorumId\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"addToQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"amm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"allowAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedAmms\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"cancelSaltedSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"delegatedGroupId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"delegateGroupId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegatedGroupIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pairToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pairAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"depositAddLiquidityStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"deadline\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"depositAddLiquidityStakeETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"depositAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositOpen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"forceRemoveFromQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quorumId\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"groupId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"minSignatures\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"ownerGroupId\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"openCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum ICrucibleToken.OverrideState\",\"name\":\"overrideType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"newFeeX10000\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"overrideFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quorumList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"quorumSubscriptions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"groupId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"minSignatures\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"ownerGroupId\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"quorums\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"groupId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"minSignatures\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"ownerGroupId\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"quorumsSubscribers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"amm\",\"type\":\"address\"}],\"name\":\"removeAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"removeFromQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"setOpenCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_taxDistributor\",\"type\":\"address\"}],\"name\":\"setTaxDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"newFeeOnTransferX10000\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"newFeeOnWithdrawX10000\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expectedGroupId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"updateCrucibleFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quorumId\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"minSignature\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expiry\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"multiSignature\",\"type\":\"bytes\"}],\"name\":\"updateMinSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crucible\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"upgradeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CrucibleRouter", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}