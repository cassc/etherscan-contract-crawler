{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/hooks/PoolHook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\nimport {IPoolHook} from \\\"../interfaces/IPoolHook.sol\\\";\\nimport {Side, IPool} from \\\"../interfaces/IPool.sol\\\";\\nimport {IMintableErc20} from \\\"../interfaces/IMintableErc20.sol\\\";\\nimport {ILevelOracle} from \\\"../interfaces/ILevelOracle.sol\\\";\\nimport {IReferralController} from \\\"../interfaces/IReferralController.sol\\\";\\nimport {ITradingContest} from \\\"../interfaces/ITradingContest.sol\\\";\\n\\ninterface IPoolForHook {\\n    function oracle() external view returns (ILevelOracle);\\n}\\n\\ncontract PoolHook is Ownable, IPoolHook {\\n    uint8 constant lyLevelDecimals = 18;\\n    uint256 constant VALUE_PRECISION = 1e30;\\n\\n    address public immutable pool;\\n    IMintableErc20 public immutable lyLevel;\\n\\n    IReferralController public immutable referralController;\\n    ITradingContest public immutable tradingContest;\\n\\n    constructor(address _lyLevel, address _pool, address _referralController, address _tradingContest) {\\n        require(_lyLevel != address(0), \\\"PoolHook:invalidAddress\\\");\\n        require(_pool != address(0), \\\"PoolHook:invalidAddress\\\");\\n        require(_referralController != address(0), \\\"PoolHook:invalidAddress\\\");\\n        require(_tradingContest != address(0), \\\"PoolHook:invalidAddress\\\");\\n\\n        lyLevel = IMintableErc20(_lyLevel);\\n        pool = _pool;\\n        referralController = IReferralController(_referralController);\\n        tradingContest = ITradingContest(_tradingContest);\\n    }\\n\\n    function validatePool(address sender) internal view {\\n        require(sender == pool, \\\"PoolHook:!pool\\\");\\n    }\\n\\n    modifier onlyPool() {\\n        validatePool(msg.sender);\\n        _;\\n    }\\n\\n    function postIncreasePosition(\\n        address _owner,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side,\\n        bytes calldata _extradata\\n    ) external onlyPool {\\n        (uint256 _sizeChange,, uint256 _feeValue) = abi.decode(_extradata, (uint256, uint256, uint256));\\n        _updateReferralData(_owner, _feeValue);\\n        _mintLyLevel(_owner, _feeValue);\\n        _sentTradingRecord(_owner, _sizeChange);\\n        emit PostIncreasePositionExecuted(pool, _owner, _indexToken, _collateralToken, _side, _extradata);\\n    }\\n\\n    function postDecreasePosition(\\n        address _owner,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side,\\n        bytes calldata _extradata\\n    ) external onlyPool {\\n        (uint256 _sizeChange, /* uint256 collateralValue */, uint256 _feeValue) =\\n            abi.decode(_extradata, (uint256, uint256, uint256));\\n        _updateReferralData(_owner, _feeValue);\\n        _mintLyLevel(_owner, _feeValue);\\n        _sentTradingRecord(_owner, _sizeChange);\\n        emit PostDecreasePositionExecuted(msg.sender, _owner, _indexToken, _collateralToken, _side, _extradata);\\n    }\\n\\n    function postLiquidatePosition(\\n        address _owner,\\n        address _indexToken,\\n        address _collateralToken,\\n        Side _side,\\n        bytes calldata _extradata\\n    ) external onlyPool {\\n        (uint256 _sizeChange, /* uint256 collateralValue */, uint256 _feeValue) =\\n            abi.decode(_extradata, (uint256, uint256, uint256));\\n        _updateReferralData(_owner, _feeValue);\\n        _mintLyLevel(_owner, _feeValue);\\n        _sentTradingRecord(_owner, _sizeChange);\\n        emit PostLiquidatePositionExecuted(msg.sender, _owner, _indexToken, _collateralToken, _side, _extradata);\\n    }\\n\\n    function postSwap(address _user, address _tokenIn, address _tokenOut, bytes calldata _data) external onlyPool {\\n        ( /*uint256 amountIn*/ , /* uint256 amountOut */, uint256 swapFee, bytes memory extradata) =\\n            abi.decode(_data, (uint256, uint256, uint256, bytes));\\n        (address benificier) = extradata.length != 0 ? abi.decode(extradata, (address)) : (address(0));\\n        benificier = benificier == address(0) ? _user : benificier;\\n        uint256 priceIn = _getPrice(_tokenIn, false);\\n        _updateReferralData(benificier, swapFee * priceIn);\\n        _mintLyLevel(benificier, swapFee * priceIn);\\n        emit PostSwapExecuted(msg.sender, _user, _tokenIn, _tokenOut, _data);\\n    }\\n\\n    // ========= Internal function ========\\n\\n    function _updateReferralData(address _trader, uint256 _value) internal {\\n        if (address(referralController) != address(0) && _trader != address(0)) {\\n            referralController.updateFee(_trader, _value);\\n        }\\n    }\\n\\n    function _sentTradingRecord(address _trader, uint256 _value) internal {\\n        if (_value > 0 && _trader != address(0) && address(tradingContest) != address(0)) {\\n            tradingContest.record(_trader, _value);\\n        }\\n    }\\n\\n    function _mintLyLevel(address _trader, uint256 _value) internal {\\n        if (_value == 0 || _trader == address(0)) {\\n            return;\\n        }\\n        uint256 _lyTokenAmount = (_value * 10 ** lyLevelDecimals) / VALUE_PRECISION;\\n        lyLevel.mint(_trader, _lyTokenAmount);\\n    }\\n\\n    function _getPrice(address token, bool max) internal view returns (uint256) {\\n        ILevelOracle oracle = IPoolForHook(pool).oracle();\\n        return oracle.getPrice(token, max);\\n    }\\n\\n    event ReferralControllerSet(address controller);\\n    event TradingIncentiveSet(address tradingRecord);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPoolHook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {Side, IPool} from \\\"./IPool.sol\\\";\\n\\ninterface IPoolHook {\\n    function postIncreasePosition(\\n        address owner,\\n        address indexToken,\\n        address collateralToken,\\n        Side side,\\n        bytes calldata extradata\\n    ) external;\\n\\n    function postDecreasePosition(\\n        address owner,\\n        address indexToken,\\n        address collateralToken,\\n        Side side,\\n        bytes calldata extradata\\n    ) external;\\n\\n    function postLiquidatePosition(\\n        address owner,\\n        address indexToken,\\n        address collateralToken,\\n        Side side,\\n        bytes calldata extradata\\n    ) external;\\n\\n    function postSwap(address user, address tokenIn, address tokenOut, bytes calldata data) external;\\n\\n    event PreIncreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PostIncreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PreDecreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PostDecreasePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PreLiquidatePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n    event PostLiquidatePositionExecuted(\\n        address pool, address owner, address indexToken, address collateralToken, Side side, bytes extradata\\n    );\\n\\n    event PostSwapExecuted(address pool, address user, address tokenIn, address tokenOut, bytes data);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport {SignedInt} from \\\"../lib/SignedInt.sol\\\";\\n\\nenum Side {\\n    LONG,\\n    SHORT\\n}\\n\\nstruct TokenWeight {\\n    address token;\\n    uint256 weight;\\n}\\n\\ninterface IPool {\\n    function increasePosition(\\n        address _account,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _sizeChanged,\\n        Side _side\\n    ) external;\\n\\n    function decreasePosition(\\n        address _account,\\n        address _indexToken,\\n        address _collateralToken,\\n        uint256 _desiredCollateralReduce,\\n        uint256 _sizeChanged,\\n        Side _side,\\n        address _receiver\\n    ) external;\\n\\n    function liquidatePosition(address _account, address _indexToken, address _collateralToken, Side _side) external;\\n\\n    function validateToken(address indexToken, address collateralToken, Side side, bool isIncrease)\\n        external\\n        view\\n        returns (bool);\\n\\n    function swap(address _tokenIn, address _tokenOut, uint256 _minOut, address _to, bytes calldata extradata)\\n        external;\\n\\n    function addLiquidity(address _tranche, address _token, uint256 _amountIn, uint256 _minLpAmount, address _to)\\n        external;\\n\\n    function removeLiquidity(address _tranche, address _tokenOut, uint256 _lpAmount, uint256 _minOut, address _to)\\n        external;\\n\\n    // =========== EVENTS ===========\\n    event SetOrderManager(address indexed orderManager);\\n    event IncreasePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        uint256 collateralValue,\\n        uint256 sizeChanged,\\n        Side side,\\n        uint256 indexPrice,\\n        uint256 feeValue\\n    );\\n    event UpdatePosition(\\n        bytes32 indexed key,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 entryPrice,\\n        uint256 entryInterestRate,\\n        uint256 reserveAmount,\\n        uint256 indexPrice\\n    );\\n    event DecreasePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        uint256 collateralChanged,\\n        uint256 sizeChanged,\\n        Side side,\\n        uint256 indexPrice,\\n        SignedInt pnl,\\n        uint256 feeValue\\n    );\\n    event ClosePosition(\\n        bytes32 indexed key,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 entryPrice,\\n        uint256 entryInterestRate,\\n        uint256 reserveAmount\\n    );\\n    event LiquidatePosition(\\n        bytes32 indexed key,\\n        address account,\\n        address collateralToken,\\n        address indexToken,\\n        Side side,\\n        uint256 size,\\n        uint256 collateralValue,\\n        uint256 reserveAmount,\\n        uint256 indexPrice,\\n        SignedInt pnl,\\n        uint256 feeValue\\n    );\\n    event DaoFeeWithdrawn(address indexed token, address recipient, uint256 amount);\\n    event DaoFeeReduced(address indexed token, uint256 amount);\\n    event FeeDistributorSet(address indexed feeDistributor);\\n    event LiquidityAdded(\\n        address indexed tranche, address indexed sender, address token, uint256 amount, uint256 lpAmount, uint256 fee\\n    );\\n    event LiquidityRemoved(\\n        address indexed tranche, address indexed sender, address token, uint256 lpAmount, uint256 amountOut, uint256 fee\\n    );\\n    event TokenWeightSet(TokenWeight[]);\\n    event Swap(\\n        address indexed sender, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, uint256 fee\\n    );\\n    event PositionFeeSet(uint256 positionFee, uint256 liquidationFee);\\n    event DaoFeeSet(uint256 value);\\n    event SwapFeeSet(\\n        uint256 baseSwapFee, uint256 taxBasisPoint, uint256 stableCoinBaseSwapFee, uint256 stableCoinTaxBasisPoint\\n    );\\n    event InterestAccrued(address indexed token, uint256 borrowIndex);\\n    event MaxLeverageChanged(uint256 maxLeverage);\\n    event TokenWhitelisted(address indexed token);\\n    event TokenDelisted(address indexed token);\\n    event OracleChanged(address indexed oldOracle, address indexed newOracle);\\n    event InterestRateSet(uint256 interestRate, uint256 interval);\\n    event PoolHookChanged(address indexed hook);\\n    event TrancheAdded(address indexed lpToken);\\n    event TokenRiskFactorUpdated(address indexed token);\\n    event PnLDistributed(address indexed asset, address indexed tranche, uint256 amount, bool hasProfit);\\n    event MaintenanceMarginChanged(uint256 ratio);\\n    event AddRemoveLiquidityFeeSet(uint256 value);\\n    event MaxGlobalPositionSizeSet(address indexed token, uint256 maxLongRatios, uint256 maxShortSize);\\n    event PoolControllerChanged(address controller);\\n    event AssetRebalanced();\\n    event MaxLiquiditySet(address token, uint256 maxLiquidity);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMintableErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMintableErc20 is IERC20 {\\n    function mint(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILevelOracle.sol\": {\r\n      \"content\": \"pragma solidity >= 0.8.0;\\n\\ninterface ILevelOracle {\\n    /**\\n     * @notice get price of single token\\n     * @param token address of token to consult\\n     * @param max if true returns max price and vice versa\\n     */\\n    function getPrice(address token, bool max) external view returns (uint256);\\n\\n    function getMultiplePrices(address[] calldata tokens, bool max) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice returns chainlink price used when liquidate\\n     */\\n    function getReferencePrice(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice returns timestamp of last posted price\\n     */\\n    function lastAnswerTimestamp(address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IReferralController.sol\": {\r\n      \"content\": \"pragma solidity 0.8.15;\\n\\ninterface IReferralController {\\n    function updateFee(address _trader, uint256 _value) external;\\n    function setReferrer(address _trader, address _referrer) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITradingContest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\ninterface ITradingContest {\\n    function record(address _user, uint256 _value) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/SignedInt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.0;\\n\\nimport {SafeCast} from \\\"../lib/SafeCast.sol\\\";\\n\\nuint256 constant POS = 1;\\nuint256 constant NEG = 0;\\n\\n/// SignedInt is integer number with sign. It value range is -(2 ^ 256 - 1) to (2 ^ 256 - 1)\\nstruct SignedInt {\\n    /// @dev sig = 1 -> positive, sig = 0 is negative\\n    /// using uint256 which take up full word to optimize gas and contract size\\n    uint256 sig;\\n    uint256 abs;\\n}\\n\\nlibrary SignedIntOps {\\n    using SafeCast for uint256;\\n\\n    function frac(int256 a, uint256 num, uint256 denom) internal pure returns (int256) {\\n        return a * num.toInt256() / denom.toInt256();\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return x < 0 ? uint256(-x) : uint256(x);\\n    }\\n\\n    function asTuple(int256 x) internal pure returns (SignedInt memory) {\\n        return SignedInt({abs: abs(x), sig: x < 0 ? NEG : POS});\\n    }\\n\\n    function lowerCap(int256 x, uint256 maxAbs) internal pure returns (int256) {\\n        int256 min = -maxAbs.toInt256();\\n        return x > min ? x : min;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/lib/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/ma/SafeCast.solth)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Extract from OpenZeppelin SafeCast to shorten revert message\\n */\\nlibrary SafeCast {\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value < 0\\\");\\n        return uint256(value);\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value > int256.max\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lyLevel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referralController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tradingContest\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"PostDecreasePositionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"PostIncreasePositionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"PostLiquidatePositionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"PostSwapExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"PreDecreasePositionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"PreIncreasePositionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"indexToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"PreLiquidatePositionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"ReferralControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tradingRecord\",\"type\":\"address\"}],\"name\":\"TradingIncentiveSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"lyLevel\",\"outputs\":[{\"internalType\":\"contract IMintableErc20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_extradata\",\"type\":\"bytes\"}],\"name\":\"postDecreasePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_extradata\",\"type\":\"bytes\"}],\"name\":\"postIncreasePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"enum Side\",\"name\":\"_side\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_extradata\",\"type\":\"bytes\"}],\"name\":\"postLiquidatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"postSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralController\",\"outputs\":[{\"internalType\":\"contract IReferralController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingContest\",\"outputs\":[{\"internalType\":\"contract ITradingContest\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolHook", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000095883611685a20936ec935b0a33f82e11d478e3d000000000000000000000000a5abfb56a78d2bd4689b25b8a77fd49bb06758740000000000000000000000005e60606dc9fcaa6891f63c9288e4bf0bb016d79c00000000000000000000000030a55981b400f6c45971bc0a8f58100df7e9cb13", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}