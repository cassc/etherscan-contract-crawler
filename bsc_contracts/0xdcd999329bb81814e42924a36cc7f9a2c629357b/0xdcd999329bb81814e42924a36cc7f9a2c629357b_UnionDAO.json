{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n \r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n \r\nlibrary SafeMath {\r\n \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n  \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n \r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n \r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n \r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n \r\ncontract Ownable is Context {\r\n    address internal _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ncontract BurnToken{\r\n    IERC20  public tokenUD;\r\n    IERC20  public TOKENRECV;\r\n    constructor (IERC20 _tokenUD,IERC20 _TokenRecv){\r\n        tokenUD = _tokenUD;\r\n        TOKENRECV = _TokenRecv;\r\n    }\r\n    function burnTkoen() public{\r\n        require(msg.sender == address(TOKENRECV),\"Ownable: caller is not the tokenRecv\"); \r\n        uint256 tokenUDBalance = tokenUD.balanceOf(address(this));\r\n        if (tokenUDBalance > 0) {\r\n            tokenUD.transfer(address(0), tokenUDBalance);//burn\r\n        }\r\n    }\r\n}\r\ncontract TokenRecv {\r\n    address public owner;\r\n    IERC20  public tokenUD;\r\n    IERC20  public usdt;\r\n    IERC20  public wbnb;\r\n    IERC20  public eth;\r\n    IERC20  public btc;\r\n    BurnToken public BURNTOKEN;\r\n\r\n    IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == address(tokenUD), \"Ownable: caller is not the token\");\r\n        _;\r\n    }\r\n    constructor (IERC20 _tokenUD) {\r\n        owner = tx.origin;\r\n        tokenUD = _tokenUD;\r\n        BURNTOKEN = new BurnToken(tokenUD,IERC20(address(this)));\r\n\r\n        usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        wbnb = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n        eth  = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n        btc  = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n        \r\n    }\r\n\r\n    function APPOVE() public {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        usdt.approve(address(tokenUD), type(uint).max);\r\n        wbnb.approve(address(tokenUD), type(uint).max);\r\n        eth.approve(address(tokenUD), type(uint).max);\r\n        btc.approve(address(tokenUD), type(uint).max);\r\n        usdt.approve(address(uniswapV2Router), type(uint).max);\r\n        tokenUD.approve(address(uniswapV2Router), type(uint).max);\r\n    }\r\n\r\n    function swapTokensForTokens(uint256 tokenAmount, address token0,address token1,address token2,address token3) public onlyToken {\r\n        uint256 pathlegth = 2;\r\n        if(token2 != address(0) && token3 == address(0)){\r\n            pathlegth = 3;\r\n        }\r\n        if(token2 != address(0) && token3 != address(0)){\r\n            pathlegth = 4;\r\n        }\r\n        address[] memory path = new address[](pathlegth);\r\n        path[0] = token0;\r\n        path[1] = token1;\r\n        if(token2 != address(0) && token3 == address(0)){\r\n            path[2] = token2;\r\n        }\r\n        if(token2 != address(0) && token3 != address(0)){\r\n            path[2] = token2;\r\n            path[3] = token3;\r\n        }\r\n        address REV = token0 == address(usdt) ? address(BURNTOKEN) : address(this);\r\n        \r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            REV,\r\n            block.timestamp\r\n        );\r\n        BURNTOKEN.burnTkoen();\r\n    }\r\n    function withdarm (address tokenAddress) public {\r\n        require(msg.sender == owner);\r\n        uint256 tokenAmount = IERC20(tokenAddress).balanceOf(address(this));\r\n        uint256 BNBAmount   = address(this).balance;\r\n        if (tokenAmount > 0) {\r\n            IERC20(tokenAddress).transfer(owner, tokenAmount);\r\n        }\r\n        if (BNBAmount > 0) {\r\n             payable(owner).transfer(BNBAmount);\r\n        }\r\n    }\r\n}\r\n \r\ncontract Bouns{\r\n    constructor (IERC20 _tokenUD) {}\r\n}\r\n\r\ncontract PerSale{\r\n    constructor (IERC20 _tokenUD) {}\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n    external\r\n    returns (\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 liquidity\r\n    );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n    external\r\n    payable\r\n    returns (\r\n        uint256 amountToken,\r\n        uint256 amountETH,\r\n        uint256 liquidity\r\n    );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n \r\ncontract UnionDAO is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n\tstring  private _name    = \"UnionDAO\";\r\n    string  private _symbol  = \"UnionDAO\";\r\n    uint8   private _decimals = 18;\r\n\taddress public  _uniswapV2Pair;\r\n\r\n    address private LastAddress;\r\n    \r\n    address      private addressInviter;\r\n    address      private addressUsdtRecipient;\r\n    address      private ecology;\r\n    address      private operation;\r\n    address      private Address0;\r\n\r\n    address      public USDTaddress = 0x55d398326f99059fF775485246999027B3197955;\r\n    address      public WBNBaddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address      public ETHaddress  = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\r\n    address      public BTCaddress  = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\r\n\r\n\r\n    address[]    public Lpholder;\r\n\r\n    IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    TokenRecv    public TOKENRECV ;\r\n    Bouns        public BOUNS;\r\n    PerSale      public PERSALE;\r\n\t\t\r\n    IERC20       public USDT  = IERC20(USDTaddress);\r\n    IERC20       public ETH   = IERC20(ETHaddress);\r\n    IERC20       public BTC   = IERC20(BTCaddress);\r\n\r\n\tuint256 private _tTotal    = 10000000 * 10**18;\r\n\tuint256 public _MinSupply  =  1000000 * 10**18;\r\n    uint256 public _Dividend;\r\n    uint256 public PerNumMAX  = 1;\r\n\r\n    uint256 public StartTime         = 1659182400;\r\n    uint256 public PrivatePlacement  = 1000;\r\n\r\n    uint256 public UDprice     = 0;\r\n    uint256 public UDpriceTime = 0;\r\n \r\n    uint256 public currentIndex;\r\n    uint256 public distributorGas = 500000;\r\n\r\n    uint256 public IncreasePriceFund;\r\n    uint256 public ETHFund;\r\n    uint256 public BTCFund;\r\n    bool    public swapping = false;\r\n\r\n    struct DeopHistory {\r\n        uint256 amount;\r\n    }\r\n\r\n\tmapping(address => address)                     public  inviter;\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\tmapping(address => uint256)                     private _balanceOf;\r\n\r\n\r\n    mapping(address => uint256)                     public  coinReleased;\r\n    mapping(address => DeopHistory[])               public  deopsitList;\r\n    mapping(address => uint256)                     public  PrivateCoinNum;\r\n    mapping(address => uint256)                     public  PrivateNum;\r\n\r\n    mapping(address => address)                     public beforeList;\r\n\r\n    mapping(address => uint256)                     public LPholderIndexes;\r\n    mapping(address => bool)                        public _updated;\r\n    mapping(address => address[])                   public InviterList;\r\n\r\n\tconstructor(address _addressInviter,address _addressUsdtRecipient,address _ecology, address _operation,address _Address0,address _rev){\r\n        addressInviter = _addressInviter;\r\n        addressUsdtRecipient = _addressUsdtRecipient;\r\n        ecology = _ecology;\r\n        operation = _operation;\r\n        Address0 = _Address0 ;\r\n\r\n        _approve(address(this), address(uniswapV2Router), type(uint).max);\r\n        USDT.approve(address(uniswapV2Router), type(uint).max);\r\n\r\n        TOKENRECV = new TokenRecv(IERC20(address(this)));\r\n        BOUNS     = new Bouns(IERC20(address(this)));\r\n        PERSALE   = new PerSale(IERC20(address(this)));\r\n\r\n        inviter[Address0] = address(this);\r\n        \r\n        _owner = msg.sender;\r\n        \r\n        _balanceOf[address(PERSALE)] = 1000000*10**18;\r\n        _balanceOf[address(BOUNS)]   = 8000000*10**18;\r\n        _balanceOf[_rev]             = 1000000*10**18;\r\n\r\n        emit Transfer(address(0), address(PERSALE), 1000000* 10**18);\r\n        emit Transfer(address(0), address(BOUNS),   8000000* 10**18);\r\n        emit Transfer(address(0), _rev,             1000000* 10**18);\r\n\r\n    }\r\n    receive() external payable {}\r\n \r\n\tfunction name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balanceOf[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool){\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender,address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            _allowances[sender][msg.sender].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)public virtual returns (bool) {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool){\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\tfunction _approve( address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    //private placement deposit function\r\n    function PrivateDeposit(uint256 num) public {\r\n        require (inviter[msg.sender] != address(0),\"You don't have inviter\");\r\n        require (PrivatePlacement > 0,\"Private Placement is over\");\r\n        require ((PrivateNum[msg.sender] + num ) <= PerNumMAX,\"num is too large\");\r\n        USDT.transferFrom(msg.sender,addressUsdtRecipient,num*100*10**18);\r\n        PrivatePlacement = PrivatePlacement.sub(num);\r\n        PrivateNum[msg.sender] = PrivateNum[msg.sender].add(num);\r\n        PrivateCoinNum[msg.sender] = PrivateCoinNum[msg.sender].add(num*990*10**18);\r\n\r\n        DeopHistory memory depo = DeopHistory({\r\n            amount: num*990*10**18\r\n        });\r\n        deopsitList[msg.sender].push(depo);\r\n\r\n        _balanceOf[address(PERSALE)] = _balanceOf[address(PERSALE)].sub(num*10*10**18);\r\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].add(num*10*10**18);\r\n        emit Transfer(address(PERSALE), msg.sender, num*10*10**18);\r\n    }\r\n    //private placement withdarm function\r\n    function PrivateWithdarw(uint256 withdarmNum,address to) private {\r\n        if(PrivateCanWithdarw(to) == 0) return;\r\n        uint256 amount = PrivateCanWithdarw(to) > withdarmNum ? withdarmNum : PrivateCanWithdarw(to);\r\n\r\n        if(_balanceOf[address(PERSALE)] < amount) return;\r\n        _balanceOf[address(PERSALE)] = _balanceOf[address(PERSALE)].sub(amount);\r\n        _takeTransfer(address(PERSALE), to, amount);\r\n\r\n        coinReleased[to] += amount;\r\n        PrivateCoinNum[to] -= amount;\r\n    }\r\n    //Private placement can withdarm function\r\n    function PrivateCanWithdarw(address to) public view returns(uint256){\r\n        uint256 Released = 0;\r\n        uint256 totalRelease = 0;\r\n        uint256 monthRelease = 0;\r\n        if(PrivateCoinNum[to] > 0){\r\n            for (uint256 i = 0; i<deopsitList[to].length; i++)  {         \r\n                uint256 createTime = StartTime.sub(2592000);//30 days\r\n                uint256 sinceMonths = ((block.timestamp.sub(createTime)).div(24).div(3600).div(30));\r\n                monthRelease = deopsitList[to][i].amount.div(5);\r\n                if(sinceMonths >= 5){\r\n                    sinceMonths = 5;\r\n                }\r\n                totalRelease += sinceMonths.mul(monthRelease);\r\n            }\r\n            if(totalRelease > coinReleased[to]){\r\n                Released = totalRelease - coinReleased[to];\r\n            }\r\n        }\r\n        return Released;\r\n    }\r\n\r\n    // set inviter function\r\n    function SetInviter (address from, address to,uint256 amount) private {//returns (bool) {\r\n        if(inviter[to]==address(0) && !from.isContract() && !to.isContract() && amount > 0 ){\r\n            beforeList[from]=to;\r\n        }\r\n        if(inviter[from]==address(0) && beforeList[to]==from && !from.isContract() && !to.isContract() && amount > 0 ){\r\n            inviter[from]=to;\r\n            InviterList[to].push(from);\r\n        }\r\n        if(from == _uniswapV2Pair && inviter[to]==address(0)){\r\n            inviter[to] = addressInviter;\r\n        }\r\n    }\r\n\r\n    // set lp holder\r\n    function SetPoolList(address lp) private{\r\n        if (_updated[lp]) {\r\n            if (IERC20(_uniswapV2Pair).balanceOf(lp) == 0) quitLp(lp);\r\n            return;\r\n        }\r\n        if (IERC20(_uniswapV2Pair).balanceOf(lp) == 0) return;\r\n        addLpholder(lp);\r\n        _updated[lp] = true;\r\n    }\r\n\r\n    function addLpholder(address lp) internal {\r\n        LPholderIndexes[lp] = Lpholder.length;\r\n        Lpholder.push(lp);\r\n    }\r\n\r\n    function quitLp(address lp) private {\r\n        removeLpholder(lp);\r\n        _updated[lp] = false;\r\n    }\r\n\r\n    function removeLpholder(address lp) internal {\r\n        Lpholder[LPholderIndexes[lp]] = Lpholder[Lpholder.length - 1];\r\n        LPholderIndexes[Lpholder[Lpholder.length - 1]] = LPholderIndexes[lp];\r\n        Lpholder.pop();\r\n    }\r\n    //return single user performance\r\n    function LpAmount(address lp) public view returns(uint256){\r\n        uint256 amount = IERC20(_uniswapV2Pair).balanceOf(lp);\r\n        for(uint i = 0; i < InviterList[lp].length; i++){\r\n            amount = amount.add(IERC20(_uniswapV2Pair).balanceOf(InviterList[lp][i]));\r\n            for(uint j = 0; j < InviterList[InviterList[lp][i]].length; j++){\r\n                amount = amount.add(IERC20(_uniswapV2Pair).balanceOf(InviterList[InviterList[lp][i]][j]));\r\n                // for(uint k = 0; k < InviterList[InviterList[InviterList[lp][i]][j]].length ;k++){\r\n                //     amount = amount.add(IERC20(_uniswapV2Pair).balanceOf(InviterList[InviterList[InviterList[lp][i]][j]][k]));\r\n                // }\r\n            }\r\n        }\r\n        return amount;\r\n    }\r\n    //BTC Performance and Dividend\r\n    function BTCPerformance() private { \r\n        address[] memory Lplist = new address[](Lpholder.length);\r\n        uint256[] memory LpPerformance = new uint256[](Lpholder.length);\r\n        uint256 sum = 0;\r\n        for(uint i=0; i < Lpholder.length; i++){\r\n            Lplist[i] = Lpholder[i];\r\n            LpPerformance[i] = LpAmount(Lpholder[i]);\r\n            sum = sum.add(LpAmount(Lpholder[i]));\r\n        }\r\n        quickSort(LpPerformance, Lplist, int(0), int(LpPerformance.length - 1));\r\n        uint256 Lplistlength = Lplist.length >= 108 ? 108 : Lplist.length;\r\n        uint256 nowbanance = BTC.balanceOf(address(TOKENRECV));\r\n\r\n        for(uint i = 0; i < Lplistlength; i++){\r\n            uint256 amount = nowbanance.mul(LpPerformance[i]).div(sum);\r\n            if(amount > 0) BTC.transferFrom(address(TOKENRECV),Lplist[i],amount);\r\n        }\r\n    }\r\n\r\n    function quickSort(uint[] memory arr, address[] memory addr,  int left, int right) private view {\r\n        int i = left;\r\n        int j = right;\r\n        if(i==j) return;\r\n        uint pivot = arr[uint(left + (right - left) / 2)];\r\n        while (i <= j) {\r\n            while (arr[uint(i)] > pivot) i++;\r\n            while (pivot > arr[uint(j)]) j--;\r\n            if (i <= j) {\r\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\r\n                (addr[uint(i)], addr[uint(j)]) = (addr[uint(j)], addr[uint(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(arr, addr, left, j);\r\n        if (i < right)\r\n            quickSort(arr, addr, i, right);\r\n    }\r\n\r\n    //ETH Dividend\r\n    function ETHDividend(uint256 gas) private {\r\n        uint256 LpholderCount = Lpholder.length;\r\n        uint256 nowbanance = ETH.balanceOf(address(TOKENRECV));\r\n        if (LpholderCount == 0 || nowbanance <= 1000) return;\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 iterations = 0;\r\n\r\n        while (gasUsed < gas && iterations < LpholderCount) {\r\n            if (currentIndex >= LpholderCount) {\r\n                currentIndex = 0;\r\n            }\r\n            uint256 amount = nowbanance.mul(IERC20(_uniswapV2Pair).balanceOf(Lpholder[currentIndex])).div(IERC20(_uniswapV2Pair).totalSupply());\r\n            if (ETH.balanceOf(address(TOKENRECV)) < amount) return;\r\n            ETH.transferFrom(address(TOKENRECV),Lpholder[currentIndex], amount);\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n\tfunction _transfer(address from, address to, uint256 amount ) private {\r\n        //require(amount>0,\"Transfer amount must be more than zero\");\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n\t\t//require(from != to, \"ERC20: transfer from self address\");\r\n        require(_balanceOf[from] >= amount, \"Transfer amount must be less than balance\");\r\n        SetInviter(from,to,amount);// set inviter\r\n        if (!swapping && IncreasePriceFund >= 10**14 && to == _uniswapV2Pair) {\r\n            swapping = true;\r\n            swapUDForUsdtEthBtc(IncreasePriceFund,ETHFund,BTCFund);\r\n            swapUsdtforUD();\r\n            IncreasePriceFund = 0;\r\n            ETHFund = 0;\r\n            BTCFund = 0;\r\n            swapping = false;\r\n        }\r\n        if(swapping){\r\n            _balanceOf[from] = _balanceOf[from].sub(amount);\r\n            _balanceOf[to] = _balanceOf[to].add(amount);\r\n            if(to == address(0)) _tTotal = _tTotal.sub(amount);\r\n            emit Transfer(from, to, amount);            \r\n        }\r\n\r\n        if(!swapping){\r\n            _balanceOf[from] = _balanceOf[from].sub(amount);\r\n            if (to == address(0)){\r\n                _takeburnFee(from,amount);\r\n            }\r\n            if (to == address(this)){\r\n                BTCPerformance();\r\n                _balanceOf[from] = _balanceOf[from].add(amount);\r\n            }\r\n            if (from != _uniswapV2Pair && to != _uniswapV2Pair && to != address(0) && to != address(this)) {\r\n                if(_uniswapV2Pair == address(0)){\r\n                    _takeTransfer(from,to,amount);\r\n                }else{\r\n                    if(_tTotal >= _MinSupply){\r\n                        _takeTransfer(from,to,amount.mul(92).div(100));\r\n                        _takeburnFee(from,amount.mul(8).div(100));\r\n                    }else{\r\n                        _takeTransfer(from,to,amount);\r\n                    }\r\n                    SetPoolList(from);\r\n                    SetPoolList(to);\r\n                }\r\n            }\r\n            if (from == _uniswapV2Pair && to != _uniswapV2Pair){ //swap USDT for UD and  remove liquify\r\n                PrivateWithdarw(amount,to);\r\n\r\n                if(block.timestamp < StartTime){\r\n                    require(amount +_balanceOf[to] <= 1020*10**18,\"require amount < 1020\");\r\n                }\r\n                if(_balanceOf[address(BOUNS)] >= amount.mul(16).div(100) && _Dividend <= 8000000*10**18){\r\n                    _takeInviterFee(to,amount);\r\n                }\r\n                _takeTransfer(from,to,amount.mul(92).div(100));\r\n                _takeTransfer(from,ecology,amount.mul(1).div(100));\r\n                _takeTransfer(from,operation,amount.mul(1).div(100));\r\n\r\n                _takeTransfer(from,address(TOKENRECV),amount.mul(6).div(100));\r\n                \r\n                IncreasePriceFund = IncreasePriceFund.add(amount.mul(1).div(100));\r\n                ETHFund = ETHFund.add(amount.mul(5).div(100));\r\n                SetPoolList(to);\r\n                if(LastAddress == address(0)) {LastAddress = to;}\r\n                SetPoolList(LastAddress);\r\n                LastAddress = to;\r\n                ETHDividend(distributorGas);\r\n            }\r\n            if(from !=_uniswapV2Pair && to == _uniswapV2Pair){ //swap UD for USDT and add liquify\r\n                if(_tTotal >= _MinSupply){\r\n                    _takeTransfer(from,to,amount.mul(92).div(100));\r\n                    _takeburnFee(from,amount.mul(1).div(100));    \r\n                }else{\r\n                    _takeTransfer(from,to,amount.mul(93).div(100));\r\n                }\r\n                _takeTransfer(from,address(TOKENRECV),amount.mul(7).div(100));\r\n\r\n                IncreasePriceFund = IncreasePriceFund.add(amount.mul(1).div(100));\r\n                ETHFund = ETHFund.add(amount.mul(5).div(100));\r\n                BTCFund = BTCFund.add(amount.mul(1).div(100));\r\n                SetPoolList(from);\r\n                if(LastAddress == address(0)) {LastAddress = from;}\r\n                SetPoolList(LastAddress);\r\n                LastAddress = from;\r\n                ETHDividend(distributorGas);\r\n            }\r\n            \r\n        }\r\n\t}\r\n\r\n    function swapUDForUsdtEthBtc(uint256 UDforUsdt,uint256 UDforEth,uint256 UDforBtc) private {\r\n        if(UDforUsdt >= 10**14){TOKENRECV.swapTokensForTokens(UDforUsdt,address(this),USDTaddress,address(0),address(0));}\r\n        if(UDforEth  >= 10**14){TOKENRECV.swapTokensForTokens(UDforEth, address(this),USDTaddress,WBNBaddress,ETHaddress);}\r\n        if(UDforBtc  >= 10**14){TOKENRECV.swapTokensForTokens(UDforBtc, address(this),USDTaddress,WBNBaddress,BTCaddress);}\r\n    }\r\n    function swapUsdtforUD() private {\r\n        if(UDprice == 0){\r\n            UDprice = getPrice();\r\n            UDpriceTime = (block.timestamp / 86400) * 86400;\r\n        }\r\n        else if(UDprice <= getPrice().mul(70).div(100) && UDpriceTime.add(86400) >= block.timestamp){\r\n            uint256 USDTAmount = USDT.balanceOf(address(TOKENRECV));\r\n            TOKENRECV.swapTokensForTokens(USDTAmount,USDTaddress,address(this),address(0),address(0));\r\n            UDprice = getPrice();\r\n        }\r\n        else if(UDpriceTime.add(86400) < block.timestamp) {\r\n            UDprice = getPrice();\r\n            UDpriceTime = (block.timestamp / 86400) * 86400;\r\n        }\r\n    }\r\n\t\r\n    function _takeburnFee(address sender,uint256 tAmount) private {\r\n        _balanceOf[address(0)] = _balanceOf[address(0)].add(tAmount);\r\n        _tTotal = _tTotal.sub(tAmount);\r\n        emit Transfer(sender, address(0), tAmount);\r\n    }\r\n    function _takeTransfer(address sender,address to,uint256 rAmount) private {\r\n        _balanceOf[to] = _balanceOf[to].add(rAmount);\r\n        emit Transfer(sender, to, rAmount);\r\n    }\r\n    function _takeInviterFee(address recipient, uint256 tAmount) private {\r\n        address cur = recipient;\r\n        for (int256 i = 0; i < 8; i++) {\r\n            uint256 rate = 0;\r\n            cur = inviter[cur];\r\n            uint256 inviterNum = InviterList[cur].length;\r\n            bool a = getEqUSDT(cur) >= 100*10**18 ? true : false;\r\n            if(block.timestamp  <= StartTime + 1200){\r\n                a = true;\r\n            }\r\n            if       (i == 0 && inviterNum >=1 && a){\r\n                rate = 80;\r\n            } else if(i == 1 && inviterNum >=2 && a){\r\n                rate = 30;\r\n            } else if(i == 2 && inviterNum >=3 && a){\r\n                rate = 20;\r\n            } else if(i == 3 && inviterNum >=4 && a){\r\n                rate = 10;\r\n            } else if(i == 4 && inviterNum >=5 && a){\r\n                rate = 5;\r\n            } else if(i == 5 && inviterNum >=6 && a){\r\n                rate = 5;\r\n            } else if(i == 6 && inviterNum >=7 && a){\r\n                rate = 5;\r\n            } else if(i == 7 && inviterNum >=8 && a){\r\n                rate = 5;\r\n            } \r\n            if (cur == address(0) || cur.isContract()) {\r\n                break;\r\n            }\r\n            if(rate != 0){\r\n                uint256 curTAmount = tAmount.div(1000).mul(rate);\r\n                _balanceOf[address(BOUNS)] = _balanceOf[address(BOUNS)].sub(curTAmount);\r\n                _balanceOf[cur] = _balanceOf[cur].add(curTAmount);\r\n                _Dividend = _Dividend.add(curTAmount);\r\n                emit Transfer(address(BOUNS), cur, curTAmount);\r\n            }\r\n        }\r\n    }\r\n\t\r\n\tfunction setLpAddress(address _address) public virtual onlyOwner {\r\n        require(_address != address(0), \"Ownable: new addess is the zero address\");\r\n        _uniswapV2Pair = _address;\r\n    }\r\n\r\n    function setTime (uint256 starttime) public virtual onlyOwner{\r\n        StartTime = starttime;\r\n    }\r\n    function setSwapping(bool _swapping) public virtual onlyOwner{\r\n        swapping = _swapping;\r\n    }\r\n\r\n    function setGas(uint256 _gas) public virtual onlyOwner{\r\n        distributorGas = _gas;\r\n    }\r\n    function setPerNumMax(uint256 num) public virtual onlyOwner{\r\n        PerNumMAX = num;\r\n    }\r\n\r\n    function getPrice() public view returns(uint256){\r\n        uint256 UDPrice;\r\n        uint256 UDAmount  = balanceOf(_uniswapV2Pair);\r\n        uint256 USDTAmount = USDT.balanceOf(_uniswapV2Pair);\r\n        UDPrice = UDAmount.mul(10**18).div(USDTAmount);\r\n        return UDPrice;\r\n    }\r\n    function getEqUSDT(address _address) public view returns (uint256){\r\n        return _balanceOf[_address].mul(10**18).div(getPrice());\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressInviter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressUsdtRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ecology\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Address0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rev\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOUNS\",\"outputs\":[{\"internalType\":\"contract Bouns\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BTC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BTCFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BTCaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETHFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETHaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IncreasePriceFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"InviterList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LPholderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"LpAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Lpholder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERSALE\",\"outputs\":[{\"internalType\":\"contract PerSale\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PerNumMAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PrivateCanWithdarw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PrivateCoinNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"PrivateDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PrivateNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PrivatePlacement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKENRECV\",\"outputs\":[{\"internalType\":\"contract TokenRecv\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UDprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UDpriceTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNBaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Dividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MinSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_updated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"beforeList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"coinReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deopsitList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getEqUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"setGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLpAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setPerNumMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapping\",\"type\":\"bool\"}],\"name\":\"setSwapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapping\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UnionDAO", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007268cda7d5b67e5fb2a22f89a6019e3eb1ee3328000000000000000000000000dd44065c0bbaa5e3ebeeec852fa3b25a1ea6d75d0000000000000000000000007439c8a2d2fe33dd393215f6a2370e93ed4852b5000000000000000000000000bd57b3a550332c005549e82addb2a2a191489ad10000000000000000000000002d230843b1367f0e9332bbce1f45a30b44d84544000000000000000000000000c07ed5b61daafedbd7dabf962a3049e9770c9c7e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d2079c7542e5be31ac8428afe6dd981c8733704d7af972e3e942652a0d80b555"}