{"SourceCode": "pragma solidity 0.5.8;\r\n\r\n/**\r\n *\r\n * https://moonshots.farm\r\n * \r\n * Want to own the next 1000x SHIB/DOGE/HEX token? Farm a new/trending moonshot every other day, automagically!\r\n *\r\n */\r\n\r\ncontract BiswapVault {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath128 for uint128;\r\n\r\n\tERC20 constant bones = ERC20(0x08426874d46f90e5E527604fA5E3e30486770Eb3);\r\n\tERC20 constant biswap = ERC20(0x965F527D9159dCe6288a2219DB51fc6Eef120dD1);\r\n\tERC20 constant wbnb = ERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n\r\n\tSyrupPool constant biswapPool = SyrupPool(0xDbc1A13490deeF9c3C12b44FE77b503c1B061739);\r\n\tBonesStaking bonesStaking = BonesStaking(0x57D3Ac2c209D9De02A80700C1D1C2cA4BC029b04);\r\n\t\r\n\tUniswapV2 constant cakeV2 = UniswapV2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\tMoonshotGovernance constant governance = MoonshotGovernance(0x7cE91cEa92e6934ec2AAA577C94a13E27c8a4F21);\r\n\r\n\tmapping(address => uint16[]) public playersSnapshotDays; // Epochs player changed balance \r\n\tmapping(address => uint128[]) public playersSnapshotBalances; // Balances for the above epochs\r\n\t\r\n\tmapping(address => mapping(uint256 => bool)) public playersSnapshotsClaimed;\r\n\tuint256[] public totalDepositSnapshots;\r\n\tuint256[] public farmedAmountSnapshots; // Amount of tokens farmed by epoch\r\n\taddress[] public farmedTokensSnapshots; // Address which was farmed by epoch\r\n\r\n\tuint256 public totalShares;\r\n\tuint256 public pricePerShare = 10 ** 18;\r\n\tuint256 constant internal magnitude = 2 ** 64;\r\n\r\n\tuint256 public lockPeriod = 30; // Moonshots unlock after 30 snapshots (60 days)\r\n\tuint256 constant withdrawPeriod = 15; // Moonshots expire in 15 snapshots (30 days to claim)\r\n\tuint256 public lastSnapshot;\r\n\r\n\tuint256 public pendingBonesAlloc;\r\n\tuint256 public pendingFeesAlloc;\r\n\tuint256 public cashoutTax = 20; // 0.2% withdraw fee to prevent abuse\r\n\taddress blobby = msg.sender;\r\n\r\n\tconstructor() public {\r\n\t\twbnb.approve(address(bonesStaking), 2 ** 255);\r\n\t\tbones.approve(address(bonesStaking), 2 ** 255);\r\n\t\tbiswap.approve(address(biswapPool), 2 ** 255);\r\n\t\tbiswap.approve(address(cakeV2), 2 ** 255);\r\n\t}\r\n\t\r\n\tfunction() payable external { /* Payable */ }\r\n\r\n\tfunction deposit(uint128 amount) external {\r\n\t\taddress farmer = msg.sender;\r\n\t\trequire(farmer == tx.origin);\r\n\t\trequire(biswap.transferFrom(address(farmer), address(this), amount));\r\n\t\tpullOutstandingDivs();\r\n\r\n\t\tbiswapPool.enterStaking(amount);\r\n\r\n\t\tuint256 sharesGained = (uint256(amount) * (10 ** 18)) / pricePerShare;\r\n\t\ttotalShares += sharesGained;\r\n\r\n\t\tuint128 oldBalance;\r\n\t\tuint256 length = playersSnapshotBalances[farmer].length;\r\n\t\tif (length > 0) {\r\n\t\t\toldBalance = playersSnapshotBalances[farmer][length - 1];\r\n\t\t}\r\n\t\tupdateBalance(oldBalance.add(uint128(sharesGained)), farmer);\r\n\t}\r\n\r\n\tfunction updateBalance(uint128 newBalance, address farmer) internal {\r\n\t\tuint256 length = playersSnapshotDays[farmer].length;\r\n\t\tif (length > 0 && playersSnapshotDays[farmer][length - 1] == epoch()) {\r\n\t\t\tplayersSnapshotBalances[farmer][length - 1] = newBalance;\r\n\t\t} else {\r\n\t\t\tplayersSnapshotDays[farmer].push(epoch());\r\n\t\t\tplayersSnapshotBalances[farmer].push(newBalance);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction pullOutstandingDivs() public {\r\n\t\tif (totalShares > 0) {\r\n\t\t\tuint256 beforeBalance = biswap.balanceOf(address(this));\r\n\t\t\tbiswapPool.leaveStaking(0);\r\n\r\n\t\t\tuint256 divsGained = biswap.balanceOf(address(this)) - beforeBalance;\r\n\t\t\tuint256 bonesShare = (divsGained * 5) / 100; // 5% to bones stakers\r\n\t\t\tuint256 toCompound = (divsGained - bonesShare) / 2; // Half biswap farmed gets compounded, other half yolos into the x100 moonshot coins\r\n\t\t\tbiswapPool.enterStaking(toCompound);\r\n\t\t\tpricePerShare += toCompound * (10 ** 18) / totalShares;\r\n\t\t\tpendingBonesAlloc += bonesShare;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction cashout(uint128 amount) external {\r\n\t\taddress farmer = msg.sender;\r\n\t\tpullOutstandingDivs();\r\n\r\n\t\tuint256 shares = (uint256(amount) * (10 ** 18)) / pricePerShare;\r\n\t\ttotalShares = totalShares.sub(shares);\r\n\r\n\t\tuint256 length = playersSnapshotBalances[farmer].length;\r\n\t\trequire(length > 0);\r\n\t\tuint128 oldBalance = playersSnapshotBalances[farmer][length - 1];\r\n\t\tupdateBalance(oldBalance.sub(uint128(shares)), farmer);\r\n\r\n\t\tbiswapPool.leaveStaking(amount);\r\n\r\n\t\tuint256 fee = (amount * cashoutTax) / 10000;\r\n\t\tpendingFeesAlloc += fee;\r\n\t\trequire(biswap.transfer(farmer, amount - fee));\r\n\t}\r\n\r\n\tfunction claimYield(uint256 index) external {\r\n\t\trequire(!playersSnapshotsClaimed[msg.sender][index]);\r\n\t\trequire(index.add(lockPeriod) < epoch() && epoch() <= index.add(lockPeriod + withdrawPeriod)); // 60 + 30 days to claim\r\n\t\tuint256 playersBalance = playersBalanceOnDay(index);\r\n\t\tif (playersBalance > 0) {\r\n\t\t\tuint256 divs = (farmedAmountSnapshots[index] * playersBalance) / totalDepositSnapshots[index];\r\n\t\t\tif (divs > 0) {\r\n\t\t\t\tplayersSnapshotsClaimed[msg.sender][index] = true;\r\n\t\t\t\tif (farmedTokensSnapshots[index] == address(bones)) {\r\n\t\t\t\t\tbonesStaking.depositFor(msg.sender, divs);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tERC20(farmedTokensSnapshots[index]).transfer(msg.sender, divs);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction pullBonusBones() external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\tgovernance.pullWeeklyRewards();\r\n\t}\r\n\r\n\tfunction updateBonesStaking(address newStaking) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\tbonesStaking = BonesStaking(newStaking);\r\n\t\twbnb.approve(address(bonesStaking), 2 ** 255);\r\n\t\tbones.approve(address(bonesStaking), 2 ** 255);\r\n\t}\r\n\r\n\tfunction sweepCake(uint256 amount, uint256 minBNB) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\tpendingBonesAlloc = pendingBonesAlloc.sub(amount);\r\n\r\n\t\taddress[] memory path = new address[](2);\r\n        path[0] = address(biswap);\r\n        path[1] = address(wbnb);\r\n        \r\n        cakeV2.swapExactTokensForTokens(amount, minBNB, path, address(this), 2 ** 255);\r\n\t\tbonesStaking.distributeDivs(wbnb.balanceOf(address(this)));\r\n\t}\r\n\r\n\tfunction sweepExpired(uint256 index, uint256 tokens, uint256 minBNB, bool sweepBNB, bool pullInstead) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\trequire(epoch() > index.add(lockPeriod + withdrawPeriod)); // 60 + 30 days passed\r\n\t\tERC20 moonshot = ERC20(farmedTokensSnapshots[index]);\r\n\r\n\t\tuint256 amount = tokens;\r\n\t\tif (amount == 0) {\r\n\t\t\tamount = moonshot.balanceOf(address(this));\r\n\t\t}\r\n\r\n\t\tif (amount > 0) {\r\n\t\t\tif (pullInstead) { // If liquidity no longer exists can just remove expired token\r\n\t\t\t\tmoonshot.transfer(blobby, amount);\r\n\t\t\t} else {\r\n\t\t\t\taddress[] memory path = new address[](2);\r\n\t\t\t\tpath[0] = address(moonshot);\r\n\t\t\t\tpath[1] = address(wbnb);\r\n\t\t\t\tcakeV2.swapExactTokensForTokens(amount, minBNB, path, address(this), 2 ** 255);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sweepBNB) { // Once dust gets enough, sweep to use as LP/buybacks/burns\r\n\t\t\twbnb.transfer(blobby, wbnb.balanceOf(address(this)));\r\n\t\t}\r\n\t}\r\n\r\n\t// Incase anyone mistakely sends unrelated tokens to this contract\r\n\tfunction sweepLostTokens(address token, uint256 amount, address recipient) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\trequire(token != address(biswap));\r\n\r\n\t\tuint256 start = farmedTokensSnapshots.length - 1;\r\n\t\tfor (uint256 i = 0; i < 90; i++) {\r\n\t\t\t// Token address cannot be in any of the last 90 snapshots\r\n\t\t\trequire(token != farmedTokensSnapshots[start - i]);\r\n\t\t}\r\n\t\tERC20(token).transfer(recipient, amount);\r\n\t}\r\n\r\n\tfunction sweepFees(address recipient, uint256 amount) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\tpendingFeesAlloc = pendingFeesAlloc.sub(amount);\r\n\t\tbiswap.transfer(recipient, amount);\r\n\t}\r\n\r\n\tfunction updateFee(uint256 newAmount) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\trequire(newAmount <= 50); // 0.5% max\r\n\t\tcashoutTax = newAmount;\r\n\t}\r\n\r\n\tfunction updateLockPeriod(uint256 newLockPeriod) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\trequire(newLockPeriod <= 60 && newLockPeriod >= 15); // So can be slightly tweaked if necessary\r\n\t\tlockPeriod = newLockPeriod;\r\n\t}\r\n\r\n\tfunction buyMoonshots(uint256 amount, uint256 minTokens) public {\r\n\t\trequire(msg.sender == blobby);\r\n\r\n\t\tuint256 length = farmedTokensSnapshots.length;\r\n\t\trequire(length > 0);\r\n\t\taddress moonshot = farmedTokensSnapshots[length - 1];\r\n\r\n        require(amount <= moonshotAlloc());\r\n\t\tif (amount > 0) {\r\n\t\t\taddress[] memory path = new address[](3);\r\n        \tpath[0] = address(biswap);\r\n        \tpath[1] = address(wbnb);\r\n\t\t\tpath[2] = address(moonshot);\r\n        \tcakeV2.swapExactTokensForTokens(amount, minTokens, path, address(this), 2 ** 255);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction snapshotMoonshotDivs(address nextToken, uint256 minTokens) external {\r\n\t\trequire(msg.sender == blobby);\r\n\t\trequire(now > lastSnapshot + 23 hours);\r\n\r\n\t\tuint256 length = farmedTokensSnapshots.length;\r\n\t\tif (length > 0) { // No prior gains when adding first token\r\n\t\t\taddress priorMoonshot = farmedTokensSnapshots[length - 1];\r\n\t\t\tif (minTokens > 0) { // Can buy more tokens before snapshot\r\n\t\t\t\tbuyMoonshots(moonshotAlloc(), minTokens);\r\n\t\t\t}\r\n\t\t\tfarmedAmountSnapshots.push(ERC20(priorMoonshot).balanceOf(address(this)));\r\n\t\t\ttotalDepositSnapshots.push(totalShares); // Store amount owned and amount farming (for divs calc)\r\n\t\t}\r\n\r\n\t\tfarmedTokensSnapshots.push(nextToken); // Move onto next moonshot token\r\n\t\tERC20(nextToken).approve(address(cakeV2), 2 ** 255);\r\n\t\tlastSnapshot = now;\r\n\t}\r\n\r\n\r\n\r\n\tfunction moonshotAlloc() view public returns (uint256) {\r\n\t\treturn(biswap.balanceOf(address(this)) - (pendingBonesAlloc + pendingFeesAlloc));\r\n\t}\r\n\r\n\tfunction cakeBalance(address farmer) view public returns (uint256) {\r\n\t\tuint256 pendingPricePerShare = pricePerShare;\r\n\t\tuint256 pendingCompoundCake = (biswapPool.pendingBSW(0, address(this)) * 475) / 1000;\r\n\t\tpendingPricePerShare += (pendingCompoundCake * (10 ** 18)) / totalShares;\r\n\r\n\t\tuint256 length = playersSnapshotBalances[farmer].length;\r\n\t\tif (length > 0) {\r\n\t\t\treturn (playersSnapshotBalances[farmer][length - 1] * pendingPricePerShare) / (10 ** 18);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction totalCakeBalance() view public returns (uint256) {\r\n\t\treturn (totalShares * pricePerShare) / (10 ** 18);\r\n\t}\r\n\r\n\tfunction epoch() public view returns (uint16) {\r\n\t\treturn uint16(farmedTokensSnapshots.length - 1);\r\n\t}\r\n\t\r\n\tfunction playersBalanceOnDay(uint256 search) public view returns (uint256) {\r\n\t\tfor (uint256 i = playersSnapshotDays[msg.sender].length; i > 0; i--) {\r\n\t\t\tuint256 day = playersSnapshotDays[msg.sender][i - 1];\r\n\t\t\tif (day <= search) {\r\n\t\t\t\treturn playersSnapshotBalances[msg.sender][i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction availableYields(uint256 offset, uint256 amount) external view returns (address[] memory, uint256[] memory, bool[] memory) {\r\n        uint256 results = amount;\r\n        if (results > farmedTokensSnapshots.length - offset) {\r\n            results = farmedTokensSnapshots.length - offset;\r\n        }\r\n\r\n        address[] memory tokens = new address[](results);\r\n        uint256[] memory yields = new uint256[](results);\r\n\t\tbool[] memory claimed = new bool[](results);\r\n\r\n\t\tuint256 start = farmedTokensSnapshots.length - (offset + 1);\r\n\t\tfor (uint256 i = 0; i < results; i++) {\r\n\t\t\t(tokens[i], yields[i], claimed[i]) = availableYield(start);\r\n\t\t\tstart--;\r\n\t\t}\r\n\r\n\t\treturn (tokens, yields, claimed);\r\n\t}\r\n\t\r\n\tfunction availableYield(uint256 index) public view returns (address, uint256, bool) {\r\n\t\tuint256 yieldShare;\r\n\t\tif (index < farmedAmountSnapshots.length) {\r\n\t\t\tyieldShare = (farmedAmountSnapshots[index] * playersBalanceOnDay(index)) / totalDepositSnapshots[index];\r\n\t\t}\r\n\t\treturn (farmedTokensSnapshots[index], yieldShare, playersSnapshotsClaimed[msg.sender][index]);\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\ninterface BonesStaking {\r\n\tfunction depositFor(address player, uint256 amount) external;\r\n\tfunction distributeDivs(uint256 amount) external;\r\n}\r\n\r\ninterface MoonshotGovernance {\r\n\tfunction pullWeeklyRewards() external;\r\n}\r\n\r\ninterface SyrupPool {\r\n\tfunction enterStaking(uint256 _amount) external;\r\n\tfunction leaveStaking(uint256 _amount) external;\r\n\tfunction emergencyWithdraw(uint256 _pid) external;\r\n\tfunction pendingBSW(uint256 _pid, address _user) external view returns (uint256); \r\n}\r\n\r\ninterface WBNB {\r\n\tfunction withdraw(uint wad) external;\r\n}\r\n\r\ninterface UniswapV2 {\r\n\tfunction swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n\tfunction addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ninterface ERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction balanceOf(address who) external view returns (uint256);\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\tfunction approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\r\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\tfunction burn(uint256 amount) external;\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\nlibrary SafeMath128 {\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n\t\tuint128 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"cashout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepLostTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"claimYield\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minBNB\",\"type\":\"uint256\"}],\"name\":\"sweepCake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"search\",\"type\":\"uint256\"}],\"name\":\"playersBalanceOnDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmedTokensSnapshots\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nextToken\",\"type\":\"address\"},{\"name\":\"minTokens\",\"type\":\"uint256\"}],\"name\":\"snapshotMoonshotDivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"availableYields\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playersSnapshotDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playersSnapshotsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moonshotAlloc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playersSnapshotBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullBonusBones\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweepFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLockPeriod\",\"type\":\"uint256\"}],\"name\":\"updateLockPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minTokens\",\"type\":\"uint256\"}],\"name\":\"buyMoonshots\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"farmer\",\"type\":\"address\"}],\"name\":\"cakeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricePerShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmedAmountSnapshots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDepositSnapshots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"minBNB\",\"type\":\"uint256\"},{\"name\":\"sweepBNB\",\"type\":\"bool\"},{\"name\":\"pullInstead\",\"type\":\"bool\"}],\"name\":\"sweepExpired\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStaking\",\"type\":\"address\"}],\"name\":\"updateBonesStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingBonesAlloc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cashoutTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"availableYield\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingFeesAlloc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCakeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSnapshot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullOutstandingDivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "BiswapVault", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://99975b879bb5e793ae65f7574b3e196b6192c4643350010ea8d08a1e6a5e0cae"}