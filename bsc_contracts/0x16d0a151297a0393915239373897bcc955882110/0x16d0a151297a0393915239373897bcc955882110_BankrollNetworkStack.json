{"SourceCode": "/*\r\n    SPDX-License-Identifier: MIT\r\n    A Bankteller Production\r\n    Bankroll Network\r\n    Copyright 2021\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface Token {\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n/*\r\n * @dev Stack is a perpetual rewards contract the collects 8% fee on buys/sells for a dividend pool that drips 2% daily.\r\n * A 2% fee is paid instantly to ELEPHANT token holders on buys/sells as buybacks that are burned\r\n*/\r\n\r\n\r\ncontract BankrollNetworkStack  is Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyBagholders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyStronghands {\r\n        require(myDividends() > 0);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n\r\n    event onLeaderBoard(\r\n        address indexed customerAddress,\r\n        uint256 invested,\r\n        uint256 tokens,\r\n        uint256 soldTokens,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingeth,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethEarned,\r\n        uint timestamp\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethReinvested,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethWithdrawn,\r\n        uint timestamp\r\n    );\r\n\r\n\r\n    event onTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens,\r\n        uint timestamp\r\n    );\r\n\r\n    event onBalance(\r\n        uint256 balance,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onBuyBack(\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onDonation(\r\n        address indexed from,\r\n        uint256 amount,\r\n        uint timestamp\r\n    );\r\n\r\n    // Onchain Stats!!!\r\n    struct Stats {\r\n        uint invested;\r\n        uint reinvested;\r\n        uint withdrawn;\r\n        uint rewarded;\r\n        uint contributed;\r\n        uint transferredTokens;\r\n        uint receivedTokens;\r\n        uint xInvested;\r\n        uint xReinvested;\r\n        uint xRewarded;\r\n        uint xContributed;\r\n        uint xWithdrawn;\r\n        uint xTransferredTokens;\r\n        uint xReceivedTokens;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    /// @dev 15% dividends for token purchase\r\n    uint8 constant internal entryFee_ = 10;\r\n\r\n\r\n    /// @dev 5% dividends for token selling\r\n    uint8 constant internal exitFee_ = 10;\r\n\r\n    uint8 constant internal dripFee = 80;  //80% of fees go to drip, the rest to the Swap buyback\r\n\r\n    uint8 constant payoutRate_ = 2;\r\n\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) private tokenBalanceLedger_;\r\n    mapping(address => int256) private payoutsTo_;\r\n    mapping(address => Stats) private stats;\r\n    //on chain referral tracking\r\n    uint256 private tokenSupply_;\r\n    uint256 private profitPerShare_;\r\n    uint256 public totalDeposits;\r\n    uint256 internal lastBalance_;\r\n\r\n    uint public players;\r\n    uint public totalTxs;\r\n    uint public dividendBalance_;\r\n    uint public elephantReserve_;\r\n    uint public lastPayout;\r\n    uint public totalClaims;\r\n    uint public totalBuyBack;\r\n    uint public firstBlock;\r\n    uint public firstTimestamp;\r\n\r\n    uint256 public balanceInterval = 6 hours;\r\n    uint256 public distributionInterval = 2 seconds;\r\n\r\n    address public tokenAddress;\r\n    address public elephantAddress =  address(0xE283D0e3B8c102BAdF5E8166B73E02D96d92F688);\r\n    address public graveyardAddress = address(0xF7cC784BD260eafC1193D337fFcEA4D6ddA0dd71);\r\n    address public router = address(0x10ED43C718714eb63d5aA57B78B54704E256024E); \r\n\r\n    /* \r\n    Pancake v2 Mainnet - 0x10ed43c718714eb63d5aa57b78b54704e256024e\r\n    Uniswap v2 Rinkeby Testnet - 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a\r\n    */\r\n\r\n    IUniswapV2Router02 public  uniswapV2Router;\r\n    IUniswapV2Router02 public  tokenUniswapV2Router;\r\n\r\n    Token private token;\r\n    Token private elephantToken;\r\n    Token private wethToken;\r\n    \r\n    bool public buybackEnabled = true; \r\n\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(address _tokenAddress, address _tokenRouter) Ownable() public {\r\n        \r\n        require(_tokenAddress != address(0) && _tokenRouter != address(0), \"Token and liquidity router must be set\");\r\n\r\n        tokenAddress = _tokenAddress;\r\n        token = Token(_tokenAddress);\r\n\r\n        elephantToken = Token(elephantAddress);\r\n\r\n        uniswapV2Router = IUniswapV2Router02(router);\r\n        \r\n        tokenUniswapV2Router = IUniswapV2Router02(_tokenRouter);\r\n        \r\n         //Sanity check router\r\n        require(tokenUniswapV2Router.WETH() == uniswapV2Router.WETH(), \"Router is not compatible\");\r\n        \r\n        wethToken = Token(uniswapV2Router.WETH());\r\n\r\n        lastPayout = block.timestamp;\r\n        firstBlock = block.number;\r\n        firstTimestamp = block.timestamp;\r\n    }\r\n\r\n    //Public function \r\n    function sweep() public {\r\n        if (elephantReserve_ >  0){\r\n                totalBuyBack = totalBuyBack.add(buyback(elephantReserve_));\r\n                elephantReserve_ = 0;\r\n        }\r\n    }\r\n    \r\n    //If enabled  the elephantReserve is funded\r\n    function enableBuyback(bool enable) onlyOwner public {\r\n        buybackEnabled = enable;\r\n    }\r\n    \r\n    function updateTokenRouter(address _tokenRouter) onlyOwner public {\r\n        require(_tokenRouter != address(0), \"Router must be set\");\r\n        tokenUniswapV2Router = IUniswapV2Router02(_tokenRouter);\r\n        \r\n        //Sanity check router\r\n        require(tokenUniswapV2Router.WETH() == uniswapV2Router.WETH(), \"Router is not compatible\");\r\n    }\r\n\r\n    //Execute the buyback against the router using WETH as a bridge\r\n    function buyback(uint tokenAmount) private returns (uint) {\r\n        address[] memory path;\r\n        bool isWETH = tokenAddress == uniswapV2Router.WETH();\r\n        \r\n        if (!isWETH){\r\n            path = new address[](2);\r\n            path[0] = tokenAddress;\r\n            path[1] = uniswapV2Router.WETH();\r\n            \r\n            //Need to be able to approve the collateral token for transfer against where its liquidity may reside in the future\r\n            //Pancake and others will maintain interfaces for legacy applications\r\n            require(token.approve(address(tokenUniswapV2Router), tokenAmount));\r\n            \r\n            uint initial = wethToken.balanceOf(address(this));\r\n            \r\n            tokenUniswapV2Router.swapExactTokensForTokens(\r\n                tokenAmount,\r\n                0, // accept any amount of Elephant\r\n                path,\r\n                address(this), //send it here first so we can find out how much ELEPHANT we receieved\r\n                block.timestamp.add(1 minutes)\r\n            );\r\n            \r\n            //update the tokenAmount with the difference in WETH\r\n            tokenAmount = wethToken.balanceOf(address(this)).sub(initial);\r\n            \r\n            \r\n        }\r\n        \r\n        //We always have WETH sourced from the best liquidity pool for the core asset if necessary\r\n        path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = elephantAddress;\r\n       \r\n        //Need to be able to approve the collateral token for transfer\r\n        require(wethToken.approve(address(uniswapV2Router), tokenAmount));\r\n\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of Elephant\r\n            path,\r\n            address(this), //send it here first so we can find out how much ELEPHANT we receieved\r\n            block.timestamp.add(1 minutes)\r\n        );\r\n\r\n        //transfer elephant tokens (buyback)\r\n        uint _balance = elephantToken.balanceOf(address(this));\r\n        elephantToken.transfer(graveyardAddress, _balance);\r\n\r\n        emit onBuyBack(_balance, block.timestamp);\r\n        return _balance;\r\n\r\n    }\r\n\r\n\r\n    /// @dev This is how you pump pure \"drip\" dividends into the system\r\n    function donatePool(uint amount) public returns (uint256) {\r\n        require(token.transferFrom(msg.sender, address(this),amount));\r\n\r\n        dividendBalance_ += amount;\r\n\r\n        emit onDonation(msg.sender, amount,now);\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy(uint buy_amount) public returns (uint256)  {\r\n        return buyFor(msg.sender, buy_amount);\r\n    }\r\n\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress, uint buy_amount) public returns (uint256)  {\r\n        require(token.transferFrom(msg.sender, address(this), buy_amount));\r\n        totalDeposits += buy_amount;\r\n        uint amount = purchaseTokens(_customerAddress, buy_amount);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to return any TRX/ETH accidentally sent to the contract\r\n     */\r\n    //to recieve ETH from uniswapV2Router when swaping\r\n    receive() external payable {}\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() onlyStronghands public {\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends();\r\n        // retrieve ref. bonus later in the code\r\n\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(msg.sender, _dividends);\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens, now);\r\n\r\n        //Stats\r\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\r\n        stats[_customerAddress].xReinvested += 1;\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() onlyStronghands public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends();\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n\r\n        // lambo delivery service\r\n        token.transfer(_customerAddress,_dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\r\n        stats[_customerAddress].xWithdrawn += 1;\r\n        totalTxs += 1;\r\n        totalClaims += _dividends;\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends, now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n\r\n    /// @dev Liquifies tokens to eth.\r\n    function sell(uint256 _amountOfTokens) onlyBagholders public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_amountOfTokens, exitFee_) / 100;\r\n        uint256 _taxedeth = SafeMath.sub(_amountOfTokens, _undividedDividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens + (_taxedeth * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedeth, now);\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from the caller to a new holder.\r\n    *  Zero fees\r\n    */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders external returns (bool) {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (myDividends() > 0) {\r\n            withdraw();\r\n        }\r\n\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);\r\n\r\n\r\n\r\n        /* Members\r\n            A player can be initialized by buying or receiving and we want to add the user ASAP\r\n         */\r\n        if (stats[_toAddress].invested == 0 && stats[_toAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        //Stats\r\n        stats[_customerAddress].xTransferredTokens += 1;\r\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\r\n        stats[_toAddress].receivedTokens += _amountOfTokens;\r\n        stats[_toAddress].xReceivedTokens += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onTransfer(_customerAddress, _toAddress, _amountOfTokens,now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        emit onLeaderBoard(_toAddress,\r\n            stats[_toAddress].invested,\r\n            tokenBalanceLedger_[_toAddress],\r\n            stats[_toAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    /**\r\n     * @dev Method to view the current eth stored in the contract\r\n     */\r\n    function totalTokenBalance() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     */\r\n    function myDividends() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function tokenBalance(address _customerAddress) public view returns (uint256) {\r\n        return _customerAddress.balance;\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.add(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethToSpend) public pure returns (uint256) {\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethToSpend, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_ethToSpend, _dividends);\r\n        uint256 _amountOfTokens = _taxedeth;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateethReceived(uint256 _tokensToSell) public view returns (uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _eth = _tokensToSell;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n        return _taxedeth;\r\n    }\r\n\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) public view returns (uint256[14] memory){\r\n        Stats memory s = stats[_customerAddress];\r\n        uint256[14] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested];\r\n        return statArray;\r\n    }\r\n\r\n\r\n    function dailyEstimate(address _customerAddress) public view returns (uint256){\r\n        uint256 share = dividendBalance_.mul(payoutRate_).div(100);\r\n\r\n        return (tokenSupply_ > 0) ? share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_) : 0;\r\n    }\r\n\r\n\r\n    function allocateFees(uint fee) private {\r\n\r\n        // 1/5 paid out instantly to Elephant holders\r\n        uint256 instant = fee.div(5); \r\n\r\n       \r\n        //If buy backs are enabled split the fee\r\n        if (buybackEnabled) {\r\n             \r\n             //add the instant fee to the reserve\r\n            elephantReserve_ = elephantReserve_.add(instant);\r\n            dividendBalance_ = dividendBalance_.add(fee).sub(instant);\r\n        } else {\r\n            //add the entire fee to the dividend balance\r\n            //this only happens when there is an issue with the buy back process.\r\n            //If Pancake upgrades liquidity pools\r\n            dividendBalance_ = dividendBalance_.add(fee); \r\n        }\r\n        \r\n    }\r\n\r\n    function distribute() private {\r\n\r\n        if (now.safeSub(lastBalance_) > balanceInterval) {\r\n            emit onBalance(totalTokenBalance(), now);\r\n            lastBalance_ = now;\r\n        }\r\n\r\n\r\n        if (SafeMath.safeSub(now, lastPayout) > distributionInterval && tokenSupply_ > 0) {\r\n\r\n            //A portion of the dividend is paid out according to the rate\r\n            uint256 share = dividendBalance_.mul(payoutRate_).div(100).div(24 hours);\r\n            //divide the profit by seconds in the day\r\n            uint256 profit = share * now.safeSub(lastPayout);\r\n            //share times the amount of time elapsed\r\n            dividendBalance_ = dividendBalance_.safeSub(profit);\r\n\r\n            //Apply divs\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (profit * magnitude) / tokenSupply_);\r\n\r\n            lastPayout = now;\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingeth) internal returns (uint256) {\r\n\r\n        /* Members */\r\n        if (stats[_customerAddress].invested == 0 && stats[_customerAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        totalTxs += 1;\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_incomingeth, entryFee_) / 100;\r\n        uint256 _amountOfTokens = SafeMath.sub(_incomingeth, _undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenPurchase(_customerAddress, _incomingeth, _amountOfTokens, now);\r\n\r\n        // yes we know that the safemath function automatically rules out the \"greater then\" equation.\r\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\r\n\r\n\r\n        // we can't give people infinite eth\r\n        if (tokenSupply_ > 0) {\r\n            // add tokens to the pool\r\n            tokenSupply_ += _amountOfTokens;\r\n\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really i know you think you do but you don't\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n\r\n        //Stats\r\n        stats[_customerAddress].invested += _incomingeth;\r\n        stats[_customerAddress].xInvested += 1;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /* @dev Subtracts two numbers, else returns zero */\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        if (b > a) {\r\n            return 0;\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBuyBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onDonation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onLeaderBoard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingeth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balanceInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"buyFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateethReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendBalance_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donatePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"elephantAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"elephantReserve_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"graveyardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"internalType\":\"uint256[14]\",\"name\":\"\",\"type\":\"uint256[14]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenUniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenRouter\",\"type\":\"address\"}],\"name\":\"updateTokenRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BankrollNetworkStack", "CompilerVersion": "v0.6.8+commit.0bbfe453", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2d18ef230e8c613533a5ff985773567871bce60205c54f9ad9fdda711b362f44"}