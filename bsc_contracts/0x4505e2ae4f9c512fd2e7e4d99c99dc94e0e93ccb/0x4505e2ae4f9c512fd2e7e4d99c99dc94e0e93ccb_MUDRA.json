{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.7.3 <0.9.0;\r\n\r\ncontract MUDRA {\r\n    \r\n    modifier onlyBagholders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[_customerAddress]);\r\n        _;\r\n    }\r\n   \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n   \r\n    \r\n  \r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n        event Approval(\r\n        address indexed tokenOwner, \r\n        address indexed spender,\r\n        uint tokens\r\n    );\r\n\t\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\t\r\n    string public name = \"MUDRA\";\r\n    string public symbol = \"MDR\";\r\n    uint256 constant public decimals = 18;\r\n    uint256 internal totalSupply_ = 1000000000*10**18;\r\n\tuint256 internal availabletoken=300000000*10**18;\r\n\tuint256 internal tokenSupply_ = 0;\r\n\tuint256 internal tokenforReferalIncome_ = 10000*10**18;\r\n\tuint256 internal totalNoOfBurntoken_ = 0;\r\n\tuint256 public flag_ = 1;\r\n    uint256 constant internal tokenpurchasePriceInitial_ =30000000000000;\r\n    uint256 public buypercent = 0;\r\n\tuint256 public sellpercent =0;\r\n\t\r\n\tuint256 public rateinfluencePercent =10;\r\n\t\r\n\tuint256 public burnpercent = 2;\r\n\tuint256 purchaseToken=0;\r\n    uint256 public PurchasecurrentPrice_ = 30000000000000;    \t\r\n\tmapping(address => mapping (address => uint256)) allowed;\r\n    address commissionHolder; \r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal etherBalanceLedger_;\r\n    address payable sonk;    \r\n\taddress  incomAccount;  \r\n    mapping(address => bool) internal administrators;\r\n    uint256 commFunds=0;\r\n    address payable owner;\r\n    constructor() \r\n    {\r\n         sonk = payable(msg.sender);\r\n         administrators[sonk] = true;\r\n         commissionHolder = sonk;\r\n\t\t owner = sonk;\t \r\n\t\t \r\n\t\t incomAccount = sonk;\r\n         tokenSupply_ = 0*10**18; \r\n\t\t tokenforReferalIncome_ = 10000*10**18;\r\n         availabletoken=300000000*10**18;\r\n\t\t flag_ = 1;\r\n         tokenBalanceLedger_[commissionHolder] = 700000000*10**18; \r\n         PurchasecurrentPrice_ = 30000000000000; //wei per token\r\n      \r\n    }\r\n   \r\n   \r\n    function upgradeDetailsCom(\r\n\tuint256 _salePercent, uint256 _PurchasePercent)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n       \r\n\t\r\n    buypercent = _PurchasePercent;\r\n\tsellpercent = _salePercent;\r\n\t\r\n  \r\n    }\r\n    receive() external payable\r\n    {\r\n    }\r\n    function Predemption()\r\n        public\r\n        payable\r\n       \r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n   \r\n  \r\n   \r\n     function PredemptionforStake()\r\n        public\r\n        payable\r\n       \r\n    {\r\n        purchaseTokensforStake(msg.value);\r\n    }\r\n   \r\n    fallback() payable external\r\n    {\r\n        purchaseTokensforStake(msg.value);\r\n    }\r\n   \r\n   \r\n   function Stack()\r\n        public\r\n        payable\r\n       \r\n    {\r\n        StackTokens(msg.value);\r\n    }\r\n   \r\n    function Sredemption(uint256 _amountOfTokens)\r\n        onlyBagholders()\r\n        public\r\n    {\r\n          address payable _customerAddress = payable(msg.sender);\r\n\t \t  require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\t\t _amountOfTokens = SafeMath.div(_amountOfTokens, 10**18);\r\n\t\t\r\n\t\r\n\t\trequire(_amountOfTokens >=1);\r\n\t\t\r\n\t\t\r\n        uint256 _tokens = _amountOfTokens;\r\n\t\t\r\n        uint256 _ethereum = tokensToBNB_(_tokens);\r\n        uint256 _comission = _ethereum * sellpercent/100;\r\n\t\tuint256 _bnbAftercomission=SafeMath.sub(_ethereum, _comission);\r\n\t\t\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens*10**18);\r\n        _customerAddress.transfer(_bnbAftercomission);\r\n        emit Transfer(_customerAddress, address(this), _amountOfTokens*10**18);\r\n    }\r\n   \r\n   \r\n   \r\n   \r\n      function sendTokenToContract(uint256 _amountOfTokens)\r\n          onlyBagholders()\r\n         public\r\n    {\r\n\t\t\r\n         address payable _customerAddress = payable(msg.sender);\r\n\t\t\r\n\t \t require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\t     \t\t\r\n         tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n         \t\t\t  \r\n           availabletoken=SafeMath.add(availabletoken, _amountOfTokens);  \r\n\t\t  \r\n    }\r\n   \r\n   \tfunction PayTo() public payable {\r\n\t \r\n\t \r\n    }\r\n         \r\n         \r\n    function with_Token(uint256 _amountOfTokens)\r\n        onlyAdministrator() public\r\n    {\r\n         uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\t  \r\n\t     \r\n         require(_amountOfTokens <= remeningToken); \r\n\t\t \r\n         address payable _customerAddress =payable(msg.sender);\r\n\t\t require(administrators[_customerAddress]);     \t\t \r\n                  \r\n         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens); \r\n        \r\n         emit Transfer(address(this), _customerAddress, _amountOfTokens); \r\n         if(_amountOfTokens != tokenforReferalIncome_)\t\r\n\t\t  {\t\t \r\n           availabletoken=SafeMath.sub(availabletoken, _amountOfTokens);  \r\n\t\t  }\r\n    }\r\n   \r\n    function myBNBBalance()\r\n        public view\r\n        returns(uint256)\r\n    {\r\n        return etherBalanceLedger_[msg.sender];    \r\n    }\r\n   \r\n  \r\n   \r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyBagholders()\r\n        public\r\n        returns(bool)\r\n    {\r\n        \r\n        address _customerAddress = msg.sender;\r\n\r\n       \r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\r\n        \r\n        return true;\r\n    }\r\n   \r\n    \r\n    function transferFrom(address   owner1, address  buyer, uint numTokens) public returns (bool) {\r\n      require(numTokens <= tokenBalanceLedger_[owner1]);\r\n      require(numTokens <= allowed[owner1][msg.sender]);\r\n      tokenBalanceLedger_[owner1] = SafeMath.sub(tokenBalanceLedger_[owner1],numTokens);\r\n      allowed[owner1][msg.sender] =SafeMath.sub(allowed[owner1][msg.sender],numTokens);\r\n    \r\n      emit Transfer(owner1, buyer, numTokens);\r\n      return true;\r\n    }\r\n\t\r\n\t\r\n\tfunction we_(address payable _receiver, uint256 _withdrawAmount) onlyAdministrator() public\r\n\t{\r\n\t \t uint256 _contractBalance = contractBalance();\r\n\t\t address payable _customerAddress = payable(msg.sender);\r\n\t\t require(administrators[_customerAddress]);\r\n\t\t if (msg.sender != owner) {revert(\"Invalid Sender Address\");}\r\n\t\t require(administrators[_receiver]);\r\n\t\t\r\n\t\tif (_contractBalance < _withdrawAmount) {revert(\"Not enough amount\");}\r\n\t\t \r\n\t\t_receiver.transfer(_withdrawAmount);\r\n\t\t  \t\r\n\t}\r\n\t\r\n\r\n\t\r\n\t function setPurchasePercent(uint256 newPercent) onlyAdministrator() public {\r\n        buypercent  = newPercent;\r\n    }\r\n\t function setSellPercent(uint256 newPercent) onlyAdministrator() public {\r\n        sellpercent  = newPercent;\r\n    }\r\n\r\n\r\n    \r\n    function burn(uint256 _amountToBurn) public {\r\n        tokenBalanceLedger_[address(0x000000000000000000000000000000000000dEaD)] += _amountToBurn;\r\n\t\tavailabletoken = SafeMath.sub(availabletoken, _amountToBurn);\r\n\t\ttotalNoOfBurntoken_=SafeMath.add(totalNoOfBurntoken_, _amountToBurn);\r\n        emit Transfer(address(this), address(0x000000000000000000000000000000000000dEaD), _amountToBurn);\r\n        \r\n       }\r\n\r\n    function setName(string memory _name)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n   \r\n    function setSymbol(string memory _symbol)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function setupCommissionHolder(address _commissionHolder)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        commissionHolder = _commissionHolder;\r\n    }\r\n\r\n    function totalBNBBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n   \r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalSupply_ ;\r\n    }\r\n   \r\n     function AvailableSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return availabletoken  - tokenSupply_ ;\r\n    }\r\n   \r\n    function totalNoOfBurntoken()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalNoOfBurntoken_ ;\r\n    }\r\n    function tokenSupply()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n   \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n   \r\n   \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n   \r\n    function contractBalance() public view returns (uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\t\r\n\t\r\n\t function remainingToken() public view returns (uint) {\r\n\t\t return availabletoken  - tokenSupply_ ;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n    function sellPrice()\r\n        public view\r\n        \r\n        returns(uint256)\r\n    {\r\n        \r\n      return PurchasecurrentPrice_ ;\r\n    }\r\n   \r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice()\r\n        public view\r\n        \r\n        returns(uint256)\r\n    {\r\n        return PurchasecurrentPrice_ ;\r\n    }\r\n   \r\n   \r\n   \r\n    \r\n    function upgradeDetails(uint256 _currentPrice,  uint256 _tokenSupply,uint256 _AvailableSupply)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        PurchasecurrentPrice_ = _currentPrice;        \r\n        tokenSupply_ = _tokenSupply;\r\n\t\tavailabletoken = _AvailableSupply;\r\n    }\r\n   \r\n    function calculateBNBReceived(uint256 _tokensToSell)\r\n         public view\r\n        \r\n        returns(uint256)\r\n    {\r\n     \r\n\t\t\r\n\t\t\r\n        uint256 _ethereum = getTokensToBNB_(_tokensToSell);\r\n\t\t\r\n\t\tuint256 _comission = _ethereum * sellpercent/100;\r\n\t\tuint256 _bnbAftercomission=SafeMath.sub(_ethereum, _comission);\r\n       \r\n        return _bnbAftercomission;\r\n    }\r\n   \r\n   \r\n     \r\n    function calculateBNBToPay(uint256 _tokenToPurchase)\r\n        public view\r\n        \r\n        returns(uint256)\r\n    {\r\n       \r\n        uint256 _bsc = getTokensToBNB_(_tokenToPurchase);\r\n\t\t\r\n\t\tuint256 _dividends = _bsc * buypercent/100;\r\n        uint256 _totalEth = SafeMath.add(_bsc, _dividends);\r\n       \r\n        return _totalEth;\r\n    }\r\n    \r\n    function calculateConvenienceFee(uint256 _bsc)\r\n        public view\r\n        \r\n        returns(uint256)\r\n    {\r\n\t\tuint256 _dividends = _bsc * buypercent/100;\r\n       \r\n        return _dividends;\r\n    }\r\n   \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n   \r\n    event testLog(\r\n        uint256 currBal\r\n    );\r\n\r\n    function calculateTokensReceived(uint256 _bnbToSpend)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividends = _bnbToSpend * buypercent/100;\r\n        uint256 _taxedEthereum = SafeMath.sub(_bnbToSpend, _dividends);\r\n        uint256 _amountOfTokens = getBNBToTokens_(_taxedEthereum);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n   \r\n    function purchaseTokens(uint256 _incomingBNB)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n     \r\n        address _customerAddress = msg.sender;        \r\n        uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\t   \r\n\t    uint256 _purchasecomision =  _incomingBNB * buypercent /100;\t\t\r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingBNB, _purchasecomision);\r\n        uint256 _amountOfTokens = bnbToTokens_(_taxedEthereum );\r\n        _amountOfTokens =_amountOfTokens*10**18;\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n        require(_amountOfTokens <= remeningToken);        \r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);    \r\n        \r\n        emit Transfer(address(this), _customerAddress, _amountOfTokens);       \t\r\n        return _amountOfTokens;\r\n    }\r\n   \r\n   \r\n          function purchaseTokensforStake(uint256 _incomingBNB)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n     \r\n        address _customerAddress = incomAccount;        \r\n        uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\t   \r\n\t    uint256 _purchasecomision =  _incomingBNB * buypercent /100;\t\t\r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingBNB, _purchasecomision);\r\n        uint256 _amountOfTokens = bnbToTokens_(_taxedEthereum );\r\n        _amountOfTokens =_amountOfTokens*10**18;\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n        require(_amountOfTokens <= remeningToken);        \r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);    \r\n        \r\n        emit Transfer(address(this), _customerAddress, _amountOfTokens);       \t\r\n        return _amountOfTokens;\r\n    }\r\n   \r\n    function StackTokens(uint256 _incomingBNB)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n      \r\n        \r\n        // data setup\r\n       \r\n        \r\n        uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\r\n\t   \r\n\t    // uint256 StackAmount =  _incomingBNB * 75 /100;\r\n\t\t\r\n        // uint256 _taxedEthereum = SafeMath.sub(_incomingBNB, StackAmount);\r\n        uint256 _amountOfTokens = bnbToTokens_(_incomingBNB );\r\n        _amountOfTokens =_amountOfTokens*10**18;\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n        require(_amountOfTokens <= remeningToken);            \r\n        \r\n        \r\n        tokenBalanceLedger_[commissionHolder] = SafeMath.add(tokenBalanceLedger_[commissionHolder], _amountOfTokens);       \r\n        // fire event\r\n        emit Transfer(address(this), commissionHolder, _amountOfTokens);       \r\n\t\r\n        return _amountOfTokens;\r\n    }\r\n   \r\n   \r\n   \r\n    function bnbToTokens_(uint256 _bnb )\r\n        internal\r\n        \r\n        returns(uint256)\r\n      {\r\n\t\tuint256 _currentPrice=0;\r\n\t\t\r\n\t\tuint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**18);\r\n\t\t\r\n\t\tuint256 _slot=SafeMath.div(tokenSupplyforPrice, 100000);  \r\n\t\t\r\n\t\t if(_slot >0)\r\n         {\t\t  \r\n\t\t  _currentPrice=PurchasecurrentPrice_;\r\n\t\t  \r\n         }\r\n         else\r\n         {\r\n         _currentPrice=tokenpurchasePriceInitial_; \r\n         }\r\n      \r\n\t   uint256 _tokensReceived = SafeMath.div(_bnb, _currentPrice);\r\n\t   tokenSupply_ = SafeMath.add(tokenSupply_, _tokensReceived*10**18);\r\n\t   uint256 tokenSupplyforPriceChange= SafeMath.div(tokenSupply_, 10**18);\r\n\t   uint256 slot=SafeMath.div(tokenSupplyforPriceChange, 100000); \r\n\t   \r\n\t    if(flag_ == slot)\r\n\t\t  {\r\n\t\t\t  uint256 incrementalPriceOnly=PurchasecurrentPrice_ * rateinfluencePercent/1000;  \r\n             PurchasecurrentPrice_=SafeMath.add(PurchasecurrentPrice_, incrementalPriceOnly);\r\n\t\t\t flag_=slot+1;\r\n\t\t  }\r\n       else if(slot > flag_)\r\n\t\t{\r\n\t\t\tuint256 noOfSlot=SafeMath.sub(slot, flag_);\r\n\t\t\t\r\n\t\t\tfor (uint i=0; i <= noOfSlot; i++) {\r\n                uint256 incrementalPriceOnly=PurchasecurrentPrice_ * rateinfluencePercent/1000;  \r\n                PurchasecurrentPrice_=SafeMath.add(PurchasecurrentPrice_, incrementalPriceOnly);\t\t\t\t\r\n             }\r\n\t\t\t flag_=slot+1;\r\n\t\t}\r\n       \r\n      \r\n       \r\n        \r\n        return _tokensReceived;\r\n       \r\n    }\r\n    function getBNBToTokens_(uint256 _bnb )\r\n        public\r\n        view\r\n        returns(uint256)\r\n      {\r\n\t\tuint256 _currentPrice=0;\r\n\t\tuint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**18);\r\n\t\tuint256 _slot=SafeMath.div(tokenSupplyforPrice, 100000);  \r\n\t\t\r\n\t\t if(_slot >0)\r\n      {\r\n\t\t  if(flag_ == _slot)\r\n\t\t  {\r\n\t\t\t  uint256 incrementalPriceOnly=PurchasecurrentPrice_ * rateinfluencePercent/1000;  \r\n             _currentPrice=SafeMath.add(PurchasecurrentPrice_, incrementalPriceOnly);\r\n\t\t\t\r\n\t\t  }\r\n\t\t  else\r\n\t\t  {\r\n\t\t\t  _currentPrice=PurchasecurrentPrice_;\r\n\t\t  }\r\n          \r\n      }\r\n      else\r\n      {\r\n         _currentPrice=tokenpurchasePriceInitial_; \r\n      }\r\n      \r\n       \r\n        uint256 _tokensReceived = SafeMath.div(_bnb, _currentPrice);\r\n      \r\n       \r\n        \r\n        return _tokensReceived;\r\n       \r\n    }\r\n  \r\n    function tokensToBNB_(uint256 _tokens)\r\n        internal\r\n        \r\n        returns(uint256)\r\n    {\r\n      \r\n      \tuint256 saleToken=1;\r\n\t\tuint256  _currentSellPrice = 0;\r\n\t\tuint256  _sellethSlotwise = 0;\r\n\t\t\r\n\t\t while(saleToken <=_tokens)\r\n           {\r\n\t\t\t   uint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**18);\r\n               uint _slotno =SafeMath.div(tokenSupplyforPrice, 100000);\r\n               if(_slotno >0)\r\n               {\r\n\t\t\t\t     uint flag =SafeMath.mod(tokenSupplyforPrice, 100000);\r\n\t\t\t\t\t if(flag==0 && tokenSupplyforPrice !=1)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\tuint256 incrementalPriceOnly=PurchasecurrentPrice_ * rateinfluencePercent/1000;  \r\n                       _currentSellPrice=SafeMath.sub(PurchasecurrentPrice_, incrementalPriceOnly);\r\n\t\t\t\t\t    flag_=flag_-1;\r\n\t\t\t\t\t }\r\n\t\t\t\t else\r\n\t\t\t\t {\r\n\t\t\t\t\t _currentSellPrice=PurchasecurrentPrice_;\r\n\t\t\t\t }\r\n                     \r\n               }\r\n               else\r\n               {\r\n                   _currentSellPrice=tokenpurchasePriceInitial_ ;\r\n               }\r\n               \r\n               _sellethSlotwise=SafeMath.add(_sellethSlotwise, _currentSellPrice);\r\n                PurchasecurrentPrice_ =_currentSellPrice;\r\n               tokenSupply_  =SafeMath.sub(tokenSupply_ , 1*10**18);\r\n               saleToken++;\r\n\t\t\t   \r\n\t\t\t   \r\n               \r\n           }\r\n\t\t  \r\n\t\t     return _sellethSlotwise;\r\n    }\r\n   \r\n    function getTokensToBNB_(uint256 _tokens)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        \tuint256 saleToken=1;\r\n\t\tuint256  _currentSellPrice = 0;\r\n\t\tuint256  _sellethSlotwise = 0;\r\n\t\t\r\n\t\t while(saleToken <=_tokens)\r\n           {\r\n\t\t\t   uint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**18);\r\n               uint _slotno =SafeMath.div(tokenSupplyforPrice, 100000);\r\n               if(_slotno >0)\r\n               {\r\n\t\t\t\t     uint256 flag =SafeMath.mod(tokenSupplyforPrice, 100000);\r\n\t\t\t\t\t if(flag==0 && tokenSupplyforPrice !=1)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\tuint256 incrementalPriceOnly=PurchasecurrentPrice_ * rateinfluencePercent/1000;  \r\n                       _currentSellPrice=SafeMath.sub(PurchasecurrentPrice_, incrementalPriceOnly);\r\n\t\t\t\t\t }\r\n\t\t\t\t else\r\n\t\t\t\t {\r\n\t\t\t\t\t _currentSellPrice=PurchasecurrentPrice_;\r\n\t\t\t\t }\r\n                     \r\n               }\r\n               else\r\n               {\r\n                   _currentSellPrice=tokenpurchasePriceInitial_ ;\r\n               }\r\n               _sellethSlotwise=SafeMath.add(_sellethSlotwise, _currentSellPrice);\r\n              \r\n            \r\n               saleToken++;\r\n           }\r\n\t\t  \r\n\t\t     return _sellethSlotwise;\r\n    }\r\n    \r\n    \r\n    \r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n   \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      \r\n        uint256 c = a / b;\r\n       \r\n        return c;\r\n    }\r\n\r\n   \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n  \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\t \r\n\t function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currBal\",\"type\":\"uint256\"}],\"name\":\"testLog\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AvailableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PayTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Predemption\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PredemptionforStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PurchasecurrentPrice_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"Sredemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Stack\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnpercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buypercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateBNBReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenToPurchase\",\"type\":\"uint256\"}],\"name\":\"calculateBNBToPay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bsc\",\"type\":\"uint256\"}],\"name\":\"calculateConvenienceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnbToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnb\",\"type\":\"uint256\"}],\"name\":\"getBNBToTokens_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"getTokensToBNB_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myBNBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateinfluencePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellpercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sendTokenToContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercent\",\"type\":\"uint256\"}],\"name\":\"setPurchasePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercent\",\"type\":\"uint256\"}],\"name\":\"setSellPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_commissionHolder\",\"type\":\"address\"}],\"name\":\"setupCommissionHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBNBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNoOfBurntoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AvailableSupply\",\"type\":\"uint256\"}],\"name\":\"upgradeDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_salePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PurchasePercent\",\"type\":\"uint256\"}],\"name\":\"upgradeDetailsCom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"we_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"with_Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MUDRA", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58ef0f3c748fcce675a087f70dee8df2e4b98464e4cf3039875e3067f43c4ae9"}