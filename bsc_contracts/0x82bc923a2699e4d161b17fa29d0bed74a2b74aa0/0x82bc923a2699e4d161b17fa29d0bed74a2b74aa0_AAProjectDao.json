{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"MyDealSafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"MyDealSafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"MyDealSafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"MyDealSafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"MyDealSafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\ninterface IBEP20 {\r\n \r\n  function totalSupply() external view returns (uint256);\r\n\r\n \r\n  function decimals() external view returns (uint8);\r\n\r\n \r\n  function symbol() external view returns (string memory);\r\n\r\n \r\n  function name() external view returns (string memory);\r\n\r\n \r\n  function getOwner() external view returns (address);\r\n\r\n  function balanceOf(address account) external returns (uint256);\r\n\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n \r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n \r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  \r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Context {\r\n  // Empty internal constructor, to prevent people from mistakenly deploying\r\n  // an instance of this contract, which should be used via inheritance.\r\n  constructor ()  { }\r\n\r\n  function _msgSender() internal view returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor ()  {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n \r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint256);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ncontract FutureEarnings {\r\n    using SafeMath for uint256;\r\n    // \u65b0\u589e\u5173\u4e8e\u672a\u6765\u6536\u76ca\u7684\u53c2\u6570\r\n    mapping (address => uint256[]) internal  _startUpdateTime;\r\n    mapping (address => uint256[]) internal _lastUpdateTime;\r\n    mapping (address => uint256[]) internal _endUpdateTime;\r\n    mapping (address => uint256[]) internal _baseMonetaryLimitReward;\r\n    mapping (address => uint256[]) internal _baseMonetaryLimitRate;\r\n    mapping (address => uint256[]) internal _settleType;\r\n\r\n    // \u5df2\u89e3\u51bb\u5df2\u7ed3\u7b97\u91d1\u989d\r\n    mapping (address => uint256) internal _releasedAndSettledMoney;\r\n    // \u5df2\u89e3\u51bb\u672a\u7ed3\u7b97\u91d1\u989d\r\n    mapping (address => uint256) internal _releasedAndUnsettledMoney;\r\n    // \u672a\u89e3\u51bb\u672a\u7ed3\u7b97\u91d1\u989d\r\n    mapping (address => uint256) internal _unreleasedAndUnsettledMoney;\r\n    // \u672a\u6765\u603b\u6536\u76ca\u91d1\u989d - \u6c47\u603b\r\n    mapping (address => uint256) internal _allFutureEarningsMoney;\r\n    \r\n\r\n   \r\n\r\n    //mapping (address => uint256[]) private _;\r\n    \r\n    // \u662f\u5426\u662f\u6b63\u5f0f\u4e0a\u7ebf\u4ea7\u54c1\uff0c\u5982\u679c\u662f\u7684\u8bdd\uff0c\u4f1a\u6709\u4e00\u4e9b\u529f\u80fd\u9650\u5236\r\n    bool internal isProductFlag;\r\n    address internal ownerAddress;\r\n    uint256 internal calculateAmountBaseNum;\r\n\r\n    constructor(address _owner)  {\r\n        ownerAddress = _owner;\r\n        isProductFlag = true;\r\n        calculateAmountBaseNum = 100000;\r\n    }\r\n\r\n    modifier onlyOwnerAddress() {\r\n        require(ownerAddress == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    event AddEduFutureEarningsLog(address addr,\r\n        uint256 startUpdateTime,\r\n        uint256 lastUpdateTime,\r\n        uint256 endUpdateTime,\r\n        uint256 settleType,\r\n        uint256 countMoney, \r\n        uint256 tempRewardMonetaryLimitRate);\r\n    event LogTypeUint256(string str, uint256 vars);\r\n\r\n    function setIsProductFlag(bool flag) public onlyOwnerAddress{\r\n        isProductFlag = flag;\r\n    }\r\n\r\n    // \u83b7\u53d6-\u5df2\u89e3\u51bb\u5df2\u7ed3\u7b97\u91d1\u989d\r\n    function getReleasedAndSettledMoney(address addr) public  view returns(uint256){\r\n        return _releasedAndSettledMoney[addr];\r\n    }\r\n    // \u83b7\u53d6-\u5df2\u89e3\u51bb\u672a\u7ed3\u7b97\u91d1\u989d\r\n    function getReleasedAndUnsettledMoney(address addr) public  view returns(uint256){   \r\n        uint256 retUnfreezeAmount     = 0;\r\n        uint256 retfreezeAmount       = 0;\r\n        (retUnfreezeAmount,retfreezeAmount) =  getRewardsByAddressViewVersion( addr);\r\n        return retUnfreezeAmount;\r\n    }\r\n    // \u83b7\u53d6-\u672a\u89e3\u51bb\u672a\u7ed3\u7b97\u91d1\u989d\r\n    function getUnreleasedAndUnsettledMoney(address addr) public  view returns(uint256){\r\n        return _allFutureEarningsMoney[addr] - getReleasedAndUnsettledMoney(addr) - getReleasedAndSettledMoney(addr);\r\n    }\r\n\r\n    function setCalculateAmountBaseNum(uint256 num) public onlyOwnerAddress{\r\n        calculateAmountBaseNum = num;\r\n    }\r\n    \r\n    // \u4fee\u6539\u672a\u6765\u6536\u76ca\u4fe1\u606f\r\n    function waitDelShowUpdateEduByAddr(\r\n        address addr,\r\n        uint256 i,\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c,\r\n        uint256 d,\r\n        uint256 e,\r\n        uint256 f\r\n    ) internal onlyOwnerAddress{\r\n        if( isProductFlag == false){\r\n             _startUpdateTime[addr][i] = a;\r\n            _lastUpdateTime[addr][i] = b;\r\n            _endUpdateTime[addr][i] = c;\r\n            _settleType[addr][i] = d;\r\n            _baseMonetaryLimitReward[addr][i] = e;\r\n            _baseMonetaryLimitRate[addr][i] = f;\r\n            \r\n        }\r\n    }\r\n    \r\n    function getCurrentTimestamp() public  view returns (uint256) {\r\n            uint256 timestamp = block.timestamp;\r\n            require(timestamp > 0, \"Invalid timestamp\");\r\n            return timestamp;\r\n    }\r\n\r\n    // \u4e3a\u67d0\u4e2a\u5730\u5740\u589e\u52a0\u672a\u6765\u6536\u76ca\r\n    function addEduFutureEarnings(\r\n        address addr,\r\n        uint256 startUpdateTime,\r\n        uint256 lastUpdateTime,\r\n        uint256 endUpdateTime,\r\n        uint256 settleType,\r\n        uint256 countMoney, \r\n        uint256 tempRewardMonetaryLimitRate\r\n    ) public onlyOwnerAddress{\r\n        // \u65b0\u589e\u989d\u5ea6\u8ba1\u7b97\u5b9e\u4f8b\r\n        if(startUpdateTime > lastUpdateTime){\r\n            lastUpdateTime = startUpdateTime;\r\n        }\r\n        if(endUpdateTime < lastUpdateTime){\r\n            endUpdateTime = lastUpdateTime;\r\n        }\r\n        if(endUpdateTime < startUpdateTime){\r\n            endUpdateTime = startUpdateTime;\r\n        }\r\n        _startUpdateTime[addr].push( startUpdateTime );\r\n        _lastUpdateTime[addr].push(  lastUpdateTime );\r\n        _endUpdateTime[addr].push( endUpdateTime );\r\n        _settleType[addr].push( settleType );\r\n        _baseMonetaryLimitReward[addr].push( countMoney );\r\n        _baseMonetaryLimitRate[addr].push( tempRewardMonetaryLimitRate );\r\n        \r\n        _allFutureEarningsMoney[addr] = _allFutureEarningsMoney[addr] + countMoney * 305 / 100;\r\n        _unreleasedAndUnsettledMoney[addr] = _unreleasedAndUnsettledMoney[addr] + countMoney  * 305 / 100;\r\n        \r\n    }\r\n\r\n    // \u4e3a\u67d0\u4e2a\u5730\u5740\u589e\u52a0\u672a\u6765\u6536\u76ca\r\n    function addEduFutureEarnings2(\r\n        address addr,\r\n        uint256 startUpdateTime,\r\n        uint256 lastUpdateTime,\r\n        uint256 endUpdateTime,\r\n        uint256 settleType,\r\n        uint256 countMoney, \r\n        uint256 tempRewardMonetaryLimitRate\r\n    ) public onlyOwnerAddress{\r\n        // \u65b0\u589e\u989d\u5ea6\u8ba1\u7b97\u5b9e\u4f8b\r\n        if(startUpdateTime > lastUpdateTime){\r\n            lastUpdateTime = startUpdateTime;\r\n        }\r\n        if(endUpdateTime < lastUpdateTime){\r\n            endUpdateTime = lastUpdateTime;\r\n        }\r\n        if(endUpdateTime < startUpdateTime){\r\n            endUpdateTime = startUpdateTime;\r\n        }\r\n        _startUpdateTime[addr].push( startUpdateTime );\r\n        _lastUpdateTime[addr].push(  lastUpdateTime );\r\n        _endUpdateTime[addr].push( endUpdateTime );\r\n        _settleType[addr].push( settleType );\r\n        _baseMonetaryLimitReward[addr].push( countMoney );\r\n        _baseMonetaryLimitRate[addr].push( tempRewardMonetaryLimitRate );\r\n        \r\n        _allFutureEarningsMoney[addr] = _allFutureEarningsMoney[addr] + countMoney;\r\n        _unreleasedAndUnsettledMoney[addr] = _unreleasedAndUnsettledMoney[addr] + countMoney;\r\n    }\r\n\r\n    function EduFutureEarnings(\r\n        address addr,\r\n        uint256 i\r\n    ) public  onlyOwnerAddress view returns(uint256,uint256,uint256,uint256,uint256,uint256){\r\n        return (\r\n            _startUpdateTime[addr][i],\r\n            _lastUpdateTime[addr][i],\r\n            _endUpdateTime[addr][i],\r\n            _settleType[addr][i],\r\n            _baseMonetaryLimitReward[addr][i],\r\n            _baseMonetaryLimitRate[addr][i]\r\n        );\r\n    }\r\n\r\n\r\n    function getRewardsByAddress(address addr, bool isSettleFlag) public  onlyOwnerAddress returns(uint256,uint256){\r\n        uint256 retUnfreezeAmount     = 0;\r\n        uint256 retfreezeAmount       = 0;\r\n        uint256 tempRetUnfreezeAmount = 0;\r\n        uint256 tempRetfreezeAmount   = 0;\r\n        if ( _startUpdateTime[addr].length == 0 ) {\r\n            retUnfreezeAmount = 0;\r\n            retfreezeAmount   = 0;\r\n        } else {\r\n            for (uint i = 0; i < _startUpdateTime[addr].length; i++) {\r\n                (tempRetUnfreezeAmount,tempRetfreezeAmount) = calculateEarningsByAddressOrder(addr,i,isSettleFlag);\r\n                retUnfreezeAmount = retUnfreezeAmount + tempRetUnfreezeAmount;\r\n                tempRetUnfreezeAmount = 0;\r\n                retfreezeAmount = retfreezeAmount + tempRetfreezeAmount;\r\n                tempRetfreezeAmount = 0;\r\n            }    \r\n        }   \r\n        if(isSettleFlag == true){\r\n           \r\n             // \u672a\u89e3\u51bb\u672a\u7ed3\u7b97\r\n            if( (_unreleasedAndUnsettledMoney[addr] < retUnfreezeAmount) || (_allFutureEarningsMoney[addr] - _unreleasedAndUnsettledMoney[addr]) < _releasedAndSettledMoney[addr]){\r\n                emit LogTypeUint256(\"retUnfreezeAmount\", retUnfreezeAmount);\r\n                emit LogTypeUint256(\"retfreezeAmount\", retfreezeAmount);\r\n                emit LogTypeUint256(\"_releasedAndSettledMoney\", _releasedAndSettledMoney[addr]);\r\n                emit LogTypeUint256(\"_releasedAndUnsettledMoney\", _releasedAndUnsettledMoney[addr]);\r\n                emit LogTypeUint256(\"_unreleasedAndUnsettledMoney\", _unreleasedAndUnsettledMoney[addr] );\r\n            }else{\r\n                if( retUnfreezeAmount > 0 ){\r\n                     // \u5df2\u89e3\u51bb\u5df2\u7ed3\u7b97\r\n                    _releasedAndSettledMoney[addr]   =  _releasedAndSettledMoney[addr] + retUnfreezeAmount;\r\n                    // \u672a\u89e3\u51bb\u672a\u7ed3\u7b97\r\n                    _unreleasedAndUnsettledMoney[addr] = _unreleasedAndUnsettledMoney[addr] - retUnfreezeAmount;\r\n                    // \u5df2\u89e3\u51bb\u672a\u7ed3\u7b97\r\n                    _releasedAndUnsettledMoney[addr] = 0;\r\n                \r\n                    // \u5df2\u89e3\u51bb\u672a\u7ed3\u7b97\r\n                    //_releasedAndUnsettledMoney[addr] = _allFutureEarningsMoney[addr] - _unreleasedAndUnsettledMoney[addr] - _releasedAndSettledMoney[addr];\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        return (retUnfreezeAmount, retfreezeAmount);\r\n    }\r\n\r\n    // \u8ba1\u7b97\u67d0\u4e00\u4e2a\u5730\u5740\u7684\u672a\u6765\u6536\u76ca\u60c5\u51b5\r\n    function calculateEarningsByAddressOrder(\r\n        address addr,\r\n        uint256 i,\r\n        bool isSettleFlag\r\n    ) internal  onlyOwnerAddress  returns(uint256,uint256){\r\n        uint256 retUnfreezeAmount;\r\n        uint256 retfreezeAmount;\r\n        if (i >= _startUpdateTime[addr].length){\r\n            retUnfreezeAmount = 0;\r\n            retfreezeAmount = 0;\r\n        }else{\r\n            uint256 newCurrentTimestamp = getCurrentTimestamp();\r\n            if(_lastUpdateTime[addr][i] > newCurrentTimestamp){\r\n                newCurrentTimestamp = _lastUpdateTime[addr][i];\r\n            }\r\n            if(_endUpdateTime[addr][i] < getCurrentTimestamp()){\r\n                newCurrentTimestamp = _endUpdateTime[addr][i];\r\n            }\r\n           \r\n            retUnfreezeAmount = calculateEarningsDiffAmountByTime( addr , i ,newCurrentTimestamp ,_lastUpdateTime[addr][i] );\r\n            //retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,newCurrentTimestamp );\r\n            retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,_lastUpdateTime[addr][i] ) - retUnfreezeAmount;\r\n            if( isSettleFlag == true ){\r\n                if(retUnfreezeAmount > 0 ){\r\n                    // \u4fee\u6539\u6700\u540e\u65f6\u95f4\r\n                    if( _settleType[addr][i] == 1 ){\r\n                        _lastUpdateTime[addr][i] = getCurrentTimestamp();\r\n                    }\r\n                    if( _settleType[addr][i] != 1  && _settleType[addr][i] != 2  ){\r\n                        _lastUpdateTime[addr][i] = getCurrentTimestamp();\r\n                    }\r\n                    if( _settleType[addr][i] == 2 ){\r\n                        _lastUpdateTime[addr][i] = _lastUpdateTime[addr][i] + (getCurrentTimestamp()-_lastUpdateTime[addr][i]) / 86400 * 86400;\r\n                    }\r\n                    // \u5df2\u89e3\u51bb\u5df2\u7ed3\u7b97\r\n                    //_releasedAndSettledMoney[addr]   = getReleasedAndSettledMoney(addr) + retUnfreezeAmount;\r\n                    // \u5df2\u89e3\u51bb\u672a\u7ed3\u7b97\r\n                   // _releasedAndUnsettledMoney[addr] = getReleasedAndUnsettledMoney(addr) - retUnfreezeAmount;\r\n                    // \u672a\u89e3\u51bb\u672a\u7ed3\u7b97\r\n                    //_unreleasedAndUnsettledMoney[addr] = getUnreleasedAndUnsettledMoney(addr) - retUnfreezeAmount;\r\n                }\r\n            }\r\n        }\r\n        return (retUnfreezeAmount,retfreezeAmount);\r\n    }\r\n\r\n    function getRewardsByAddressViewVersion(address addr) public view onlyOwnerAddress returns(uint256,uint256){\r\n        uint256 retUnfreezeAmount     = 0;\r\n        uint256 retfreezeAmount       = 0;\r\n        uint256 tempRetUnfreezeAmount = 0;\r\n        uint256 tempRetfreezeAmount   = 0;\r\n        if ( _startUpdateTime[addr].length == 0 ) {\r\n            retUnfreezeAmount = 0;\r\n            retfreezeAmount   = 0;\r\n        } else {\r\n            for (uint i = 0; i < _startUpdateTime[addr].length; i++) {\r\n                (tempRetUnfreezeAmount,tempRetfreezeAmount) = calculateEarningsByAddressOrderViewVersion(addr,i);\r\n                retUnfreezeAmount = retUnfreezeAmount + tempRetUnfreezeAmount;\r\n                tempRetUnfreezeAmount = 0;\r\n                retfreezeAmount = retfreezeAmount + tempRetfreezeAmount;\r\n                tempRetfreezeAmount = 0;\r\n            }    \r\n        }   \r\n       \r\n        return (retUnfreezeAmount, retfreezeAmount);\r\n    }\r\n\r\n    // \u8ba1\u7b97\u67d0\u4e00\u4e2a\u5730\u5740\u7684\u672a\u6765\u6536\u76ca\u60c5\u51b5\r\n    function calculateEarningsByAddressOrderViewVersion(\r\n        address addr,\r\n        uint256 i\r\n    ) internal   view returns(uint256,uint256){\r\n        uint256 retUnfreezeAmount;\r\n        uint256 retfreezeAmount;\r\n        if (i >= _startUpdateTime[addr].length){\r\n            retUnfreezeAmount = 0;\r\n            retfreezeAmount = 0;\r\n        }else{\r\n            uint256 newCurrentTimestamp = getCurrentTimestamp();\r\n            if(_lastUpdateTime[addr][i] > newCurrentTimestamp){\r\n                newCurrentTimestamp = _lastUpdateTime[addr][i];\r\n            }\r\n            if(_endUpdateTime[addr][i] < getCurrentTimestamp()){\r\n                newCurrentTimestamp = _endUpdateTime[addr][i];\r\n            }\r\n           \r\n            retUnfreezeAmount = calculateEarningsDiffAmountByTime( addr , i ,newCurrentTimestamp ,_lastUpdateTime[addr][i] );\r\n            //retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,newCurrentTimestamp );\r\n            retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,_lastUpdateTime[addr][i] ) - retUnfreezeAmount;\r\n           \r\n        }\r\n        return (retUnfreezeAmount,retfreezeAmount);\r\n    }\r\n\r\n\r\n    function calculateEarningsDiffAmountByTime(\r\n        address addr,\r\n        uint256 i,\r\n        uint256 addr01Time,\r\n        uint256 addr02Time\r\n\r\n    ) public  view returns(uint256){\r\n        uint256 retAmount = 0;\r\n        if (i >= _startUpdateTime[addr].length){\r\n            retAmount = 0;\r\n            return retAmount;\r\n        }\r\n        if(addr01Time <= addr02Time){\r\n            retAmount = 0;\r\n        }else{\r\n            // \u6309\u7167 \u5929 \u8ba1\u7b97-\u8ba1\u7b97\u662f\u6bcf\u79d2\u90fd\u6709\u8ba1\u7b97\uff0c\u624d\u4f1a\u6709\u6536\u76ca\r\n            if( _settleType[addr][i] == 1){\r\n                retAmount =  (addr01Time - addr02Time)  * _baseMonetaryLimitRate[addr][i] * _baseMonetaryLimitReward[addr][i] / 86400 / calculateAmountBaseNum;\r\n            }\r\n            // \u6309\u7167 \u5929 \u8ba1\u7b97-\u8ba1\u7b97\u5f0f\u6bcf24\u5c0f\u65f6\u624d\u6709\u8ba1\u7b97\uff0c\u8ba2\u5355\u768424\u4ee5\u540e\u624d\u7b971\u5929\uff0c\u624d\u4f1a\u6709\u6536\u76ca\r\n            if( _settleType[addr][i] == 2){\r\n                retAmount =  (addr01Time - addr02Time) / 86400 * _baseMonetaryLimitRate[addr][i] * _baseMonetaryLimitReward[addr][i] / calculateAmountBaseNum;\r\n            }\r\n            // \u6309\u7167 \u5929 \u8ba1\u7b97-\u8ba1\u7b97\u662f\u6bcf\u79d2\u90fd\u6709\u8ba1\u7b97\uff0c\u624d\u4f1a\u6709\u6536\u76ca\r\n            if( _settleType[addr][i] != 1 && _settleType[addr][i] != 2){\r\n                retAmount =  (addr01Time - addr02Time)  * _baseMonetaryLimitRate[addr][i] * _baseMonetaryLimitReward[addr][i] / 86400 / calculateAmountBaseNum;\r\n            }\r\n        }\r\n        return retAmount;\r\n    }\r\n\r\n}\r\ncontract AutomatedRiskControlBaseSystem {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public _priceCalBasePrice;\r\n    uint256 public _priceCalLastTimes;\r\n    uint256 public _priceCalStartTimes;\r\n    bool    public _priceCalTriggerFlag;\r\n\r\n    uint256 public triggerRate;\r\n    uint256 public triggerPercentNum;\r\n    // \u4eca\u65e5\u989d\u5ea6\r\n    uint256 public triggerDayRewardEduAmount;\r\n    // \u7528\u4e8e\u6d4b\u7b97\u4ef7\u683c\u7684\u57fa\u7840\u6570\u5b57\r\n    uint256 public _priceCalBaseAmount;\r\n    address public ownerAddress;\r\n    // \u4ea4\u6613\u8d27\u5e01\u5bf9\u5730\u5740\r\n    address public pairAddress;\r\n    address public routerAddress;\r\n    address public tokenAAddress;\r\n    uint256 public tokenAAddressDecial;\r\n    address public tokenBAddress;\r\n    uint256 public tokenBAddressDecial;\r\n\r\n    // \u4ef7\u683c\u4f59\u989d\u7684\u57fa\u7840\u53c2\u8003\u6570\u5b57\r\n    uint256 public pricePredictionBaseAmount;\r\n    uint256 public triggerDayRewardEduAmountComparisonRateNum;\r\n    uint256 public triggerDayRewardEduAmountComparisonRateBase;\r\n    uint256 public triggerDayRewardAddEduRate;\r\n    uint256 public triggerDayRewardAddEduRateBase;\r\n    // \u89e6\u53d1\u989d\u5ea6\u65f6\uff0c\u91ca\u653e\u7684\u8d27\u5e01\u5bf9\u7684\u6570\u91cf\uff0c\u5355\u4f4d\u662f\u6807\u51c6\u5927\u5355\u4f4d\uff0c\u6bd4\u59821000\u4e2aBUSD\r\n    uint256 public eduRewardBaseCalAmount;\r\n\r\n    constructor( address _owner )  {\r\n        ownerAddress = _owner;\r\n\r\n        _priceCalBaseAmount = 10000;\r\n        // \u6bcf\u5929\u7684\u516b\u70b9\u540e\r\n        _priceCalStartTimes = 0;\r\n        _priceCalLastTimes  = 10 * 86400;\r\n        _priceCalTriggerFlag = false;\r\n        \r\n        // \u89e6\u53d1\u989d\u5ea6\u5956\u52b1\u7684\u6bd4\u4f8b\u53c2\u6570\r\n        triggerPercentNum = 10000;\r\n        triggerRate       = 500;\r\n        triggerDayRewardEduAmount = 0;\r\n\r\n        //\u65b0\u589e\u6d4b\u8bd5\r\n        triggerDayRewardEduAmount = 100000 * (10 ** 6);\r\n\r\n        pricePredictionBaseAmount = 10 ** 18;\r\n        // 1.4\u7684\u4ef7\u683c\u6bd4\r\n        triggerDayRewardEduAmountComparisonRateNum = 1400;\r\n        triggerDayRewardEduAmountComparisonRateBase = 1000;\r\n        triggerDayRewardAddEduRate = 10;\r\n        triggerDayRewardAddEduRateBase = 100;\r\n        // \u89e6\u53d1\u989d\u5ea6\u65f6\uff0c\u91ca\u653e\u7684\u8d27\u5e01\u5bf9\u7684\u6570\u91cf\uff0c\u5355\u4f4d\u662f\u6807\u51c6\u5927\u5355\u4f4d\uff0c\u6bd4\u59821000\u4e2aBUSD\r\n        eduRewardBaseCalAmount = 1000;\r\n    }\r\n\r\n    modifier onlyOwnerAddress() {\r\n        require(ownerAddress == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n     // \u4e8b\u4ef6---->\u51fd\u6570\u8bb0\u5f55\u4e8b\u4ef6\uff0c\u4fbf\u4e8e\u542f\u52a8\u65e5\u5fd7\u51fd\u6570\r\n    event logFunction(string funcName);\r\n    event logFunctionAddress(string funcName,address addr);\r\n    event logFunctionUnit256(string funcName,uint256 addr);\r\n    event logFunctionBool(string funcName,bool addr);\r\n\r\n    function getPricePredictionBaseAmount() public onlyOwnerAddress view returns(uint256){\r\n        return pricePredictionBaseAmount;\r\n    }\r\n\r\n    function setPricePredictionBaseAmount(uint256 amount) public onlyOwnerAddress {\r\n        pricePredictionBaseAmount = amount;\r\n    }\r\n\r\n    function getRouterAddress() public onlyOwnerAddress view returns(address){\r\n        return routerAddress;\r\n    }\r\n\r\n    function setRouterAddress(address addr) public onlyOwnerAddress {\r\n        //if( routerAddress == address(0) ){\r\n            routerAddress = addr;\r\n        //}\r\n    }\r\n\r\n    \r\n\r\n    function getPairAddress() public onlyOwnerAddress view returns(address){\r\n        return pairAddress;\r\n    }\r\n\r\n    function setPairAddress(address addr) public onlyOwnerAddress {\r\n        //if( routerAddress == address(0) ){\r\n            pairAddress = addr;\r\n        //}\r\n    }\r\n\r\n\r\n\r\n    function getTokenAAddress() public onlyOwnerAddress view returns(address,uint256){\r\n        return (tokenAAddress,tokenAAddressDecial);\r\n    }\r\n\r\n    function setTokenAAddress(address addr,uint8 _tokenAAddressDecial) public onlyOwnerAddress {\r\n        //if( tokenAAddress == address(0) ){\r\n             tokenAAddress = addr;\r\n             tokenAAddressDecial = _tokenAAddressDecial;\r\n        //}\r\n    }\r\n\r\n    function getTokenBAddress() public onlyOwnerAddress view returns(address,uint256){\r\n        return (tokenBAddress,tokenBAddressDecial);\r\n    }\r\n\r\n    function setTokenBAddress(address addr,uint8 _tokenBAddressDecial) public onlyOwnerAddress {\r\n        //if( tokenBAddress == address(0) ){\r\n            tokenBAddress = addr;\r\n            tokenBAddressDecial = _tokenBAddressDecial;\r\n        //}\r\n    }\r\n\r\n    function getTriggerUseRate() private view onlyOwnerAddress returns(uint256){\r\n        return triggerPercentNum / triggerRate;\r\n    }\r\n\r\n    function getTriggerDayRewardEduAmount() public view onlyOwnerAddress returns(uint256){\r\n        uint256 retAmount = 0;\r\n        if( (block.timestamp -_priceCalLastTimes) / 86400 > 0  ){\r\n            retAmount = 0;\r\n        }else{\r\n            retAmount = triggerDayRewardEduAmount;\r\n        }\r\n        return retAmount;\r\n    }\r\n\r\n    function subTriggerDayRewardEduAmount(uint256 amount) public onlyOwnerAddress{\r\n        require(amount <= triggerDayRewardEduAmount,\"ERROR:amount > triggerDayRewardEduAmount\");\r\n        triggerDayRewardEduAmount = triggerDayRewardEduAmount - amount; \r\n    }\r\n    // \u4e3b\u8981\u7684\u8bb0\u5f55\u4ef7\u683c\u7684\u89e6\u53d1\u51fd\u6570\r\n    function changeNowPrice() public onlyOwnerAddress   {\r\n        uint256 curPrice = getPairPrice();\r\n        \r\n        if( curPrice > 0){    \r\n            uint256 curDay   = (_priceCalLastTimes - _priceCalStartTimes) / 86400;\r\n            if( (block.timestamp - _priceCalStartTimes) / 86400 != curDay ){\r\n                _priceCalBasePrice = curPrice;\r\n                _priceCalLastTimes = (block.timestamp - _priceCalStartTimes) / 86400 * 86400 + _priceCalStartTimes;\r\n                _priceCalTriggerFlag = false;\r\n                triggerDayRewardEduAmount = 0;\r\n            }\r\n\r\n            if( _priceCalTriggerFlag == false ){\r\n                if( isTriggerRewardCheck( curPrice ) ){\r\n                    _priceCalTriggerFlag = true;\r\n                    triggerDayRewardEduAmount = getPredictEduInfo(curPrice);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function getPredictEduInfo(uint256 curPrice) internal view onlyOwnerAddress returns(uint256){\r\n        //uint256 curPrice = getPairPrice();\r\n        //emit logFunctionUnit256(\"getPredictEduInfo-->curPrice\",curPrice);\r\n        uint256 diffDecial = tokenBAddressDecial - tokenAAddressDecial;\r\n        uint256  _triggerDayRewardEduAmount = eduRewardBaseCalAmount * (10 ** diffDecial) * (10 ** tokenAAddressDecial) / curPrice ;    \r\n        //emit logFunctionUnit256(\"getPredictEduInfo-->_triggerDayRewardEduAmount\",_triggerDayRewardEduAmount);\r\n\r\n        uint256 comparePrice = triggerDayRewardEduAmountComparisonRateNum * (10 ** diffDecial) / triggerDayRewardEduAmountComparisonRateBase  ;\r\n        //emit logFunctionUnit256(\"getPredictEduInfo-->comparePrice\",comparePrice);\r\n\r\n        uint256 retEdu = 0;\r\n\r\n        if( curPrice < comparePrice ){\r\n            retEdu = _triggerDayRewardEduAmount - _triggerDayRewardEduAmount * (  comparePrice - curPrice ) * triggerDayRewardAddEduRate / comparePrice / triggerDayRewardAddEduRateBase;\r\n        }else{\r\n            retEdu = _triggerDayRewardEduAmount + _triggerDayRewardEduAmount * (  curPrice - comparePrice ) * triggerDayRewardAddEduRate / comparePrice / triggerDayRewardAddEduRateBase;\r\n        }\r\n        //emit logFunctionUnit256(\"getPredictEduInfo-->retEdu\",retEdu);\r\n        return retEdu; \r\n    }\r\n\r\n    function setPriceCalTriggerFlag(bool flag) private onlyOwnerAddress{\r\n        _priceCalTriggerFlag = flag;\r\n    }\r\n\r\n    function isTriggerRewardCheck(uint256 curPrice) private view returns(bool){\r\n        bool flag = false;\r\n        \r\n        if( curPrice <= 0){\r\n            return false;\r\n        }\r\n\r\n        // \u68c0\u6d4b\u4eca\u65e5\u4ef7\u683c\u4e0b\u8dcc\u65f6\uff0c\u4e14\u4e0b\u8dcc\u6bd4\u4f8b\u8d85\u8fc7 triggerRate * triggerPercentNum * 100 \u7684\u767e\u5206\u6bd4\u7387\r\n        if( curPrice < _priceCalBasePrice  ){\r\n            if( _priceCalBasePrice / (_priceCalBasePrice - curPrice) * triggerRate  <  triggerPercentNum  ){\r\n                 return true;\r\n            }\r\n        }\r\n        /*\r\n        // \u68c0\u6d4b\u4eca\u65e5\u4ef7\u683c\u4e0b\u8dcc\u65f6\uff0c\u4e14\u4e0b\u8dcc\u6bd4\u4f8b\u8d85\u8fc7 triggerRate * triggerPercentNum * 100 \u7684\u767e\u5206\u6bd4\u7387\r\n        if(curPrice < _priceCalBasePrice &&  _priceCalBasePrice / (_priceCalBasePrice - curPrice) * triggerRate  <  triggerPercentNum  ){\r\n            return true;\r\n        }*/\r\n        return flag;\r\n    }\r\n\r\n    function isTriggerReward() public view returns(bool){\r\n        return _priceCalTriggerFlag;\r\n    }\r\n\r\n    function isOpenGetPrice() private view returns(bool){\r\n        //if( pairAddress == address(0) || routerAddress == address(0) || tokenAAddress == address(0) || tokenBAddress == address(0) || tokenAAddressDecial <= 0 ||  tokenBAddressDecial <= 0 ){\r\n        //emit logFunctionAddress(\"isOpenGetPrice---->tokenAAddress\", tokenAAddress);\r\n        if( tokenAAddress == address(0)){\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n     // \u83b7\u53d6\u6307\u5b9a\u4ee3\u5e01\u5bf9\u7684\u5b9e\u65f6\u4ef7\u683c\r\n    function getPairPrice() public view returns (uint256) {\r\n        //if( isOpenGetPrice() ){\r\n          //  return 0;\r\n        //}\r\n        uint256 priceNum = 0;\r\n        if( isOpenGetPrice() == false ){\r\n            priceNum = 0;\r\n            return priceNum;\r\n        }\r\n        \r\n        IPancakePair pair = IPancakePair(pairAddress);\r\n        //emit logFunctionAddress(\"getPairPrice---->pairAddress\", pairAddress);\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        //emit logFunctionUnit256(\"getPairPrice---->reserve0\", reserve0);\r\n        //emit logFunctionUnit256(\"getPairPrice---->reserve1\", reserve0);\r\n        if( pair.token0() == tokenAAddress ){\r\n            priceNum =  reserve1 / reserve0;\r\n        }else{\r\n            priceNum =  reserve0 / reserve1;\r\n        }\r\n\r\n        //emit logFunctionUnit256(\"getPairPrice---->priceNum\", priceNum);\r\n        return priceNum;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract BEP20USDT is Context, IBEP20, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) internal _balances;\r\n  mapping (address => uint256) internal _freeze_balances;\r\n  mapping (address => uint256) internal _unfreeze_balances;\r\n\r\n  mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n  uint256 internal _totalSupply;\r\n  uint8 internal _decimals;\r\n  string internal _symbol;\r\n  string internal _name;\r\n  \r\n  address[] internal  _uniswapSendAddressList;\r\n  address internal  uniswapOnlyAddress;\r\n\r\n  mapping (address => address) internal _leaderAddressList;\r\n  uint256 internal _checkSetLeaderTransferAmount;\r\n  uint256[] internal _personRate;\r\n  bool internal _isCreateDynamicRewards;\r\n  uint256 internal _maxDynamicRewardsAmount;\r\n\r\n  uint256 internal _minHasAmountToGetPersonAward;\r\n  address internal _feeRecieveAddress;\r\n  uint256 internal _buyRate;\r\n  uint256 internal _sellRate;\r\n  uint256 internal _buyRateAfterDynamicRewardsOver;\r\n  uint256 internal _sellRateAfterDynamicRewardsOver;\r\n  uint256 internal _baseRateAmount;\r\n\r\n  address internal _feeCoderTeamAddress;\r\n  uint256 internal _feeCoderTeamRate;\r\n  address internal _feeFirstTeamAddress;\r\n  uint256 internal _feeFirstTeamRate;\r\n  address internal _feeOperateTeamAddress;\r\n  uint256 internal _feeOperateTeamRate;\r\n  address internal _feePoolTeamAddress;\r\n  uint256 internal _feePoolTeamRate;\r\n  address internal _feeBlackholeTeamAddress;\r\n  uint256 internal _feeBlackholeTeamRate;\r\n\r\n\r\n  constructor()  {\r\n    \r\n  }\r\n\r\n \r\n\r\n\r\n \r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() public override view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n   /**\r\n   * @dev Returns the bep token owner.\r\n   */\r\n  function getOwner() public override view returns (address) {\r\n    return owner();\r\n  }\r\n\r\n  \r\n  /**\r\n   * @dev See {BEP20-totalSupply}.\r\n   */\r\n  function totalSupply() public override view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() public override view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the token name.\r\n  */\r\n  function name() public override view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev See {BEP20-balanceOf}.\r\n   */\r\n  function balanceOf(address account)  public virtual override  returns (uint256) {\r\n    //return _balances[account];\r\n    account;\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender) public override view returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `recipient` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n \r\n\r\n  /**\r\n   * @dev See {BEP20-approve}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount) public override returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {BEP20};\r\n   *\r\n   * Requirements:\r\n   * - `sender` and `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for `sender`'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {BEP20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {BEP20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n    return true;\r\n  }\r\n\r\n\r\n  \r\n  event SetLeaderAddress(address indexed onePerson, address indexed firstPerson);\r\n  event FirstPersonAward(address indexed onePerson, address indexed firstPerson,uint256 amount);\r\n  event setPersonRateBySortLog(uint8 i,uint64 rate);\r\n  event SellFeeByAddressLog(address addr,uint256 amount,uint feeAmount);\r\n  /**\r\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n   *\r\n   * This is internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `sender` cannot be the zero address.\r\n   * - `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual{\r\n   \r\n    \r\n  }\r\n\r\n  function _transferOrigin(address sender, address recipient, uint256 amount) internal{\r\n      _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n      _balances[recipient] = _balances[recipient].add(amount);\r\n      emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  function _transferOriginNoLog(address sender, address recipient, uint256 amount) internal{\r\n      _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n      _balances[recipient] = _balances[recipient].add(amount);\r\n      // emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  function _transferOriginSpecialLog(address sender, address recipient, uint256 amount,uint256 logAmount) internal{\r\n      _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n      _balances[recipient] = _balances[recipient].add(amount);\r\n      emit Transfer(sender, recipient, logAmount);\r\n  }\r\n\r\n  function _transferOriginSpecialNoLog(address sender, address recipient, uint256 amount,uint256 logAmount) internal{\r\n      sender;\r\n      recipient;\r\n      logAmount;\r\n      _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n      _balances[recipient] = _balances[recipient].add(amount);\r\n      //emit Transfer(sender, recipient, logAmount);\r\n  }\r\n  \r\n\r\n \r\n  \r\n \r\n\r\n  function updateLeaderByTransfer(address sender, address recipient, uint256 amount) internal{\r\n    if(  amount == _checkSetLeaderTransferAmount  ){\r\n        if( getLeaderAddressByAddress(sender)  == address(0)  ){\r\n           if( !isInUniSwapAddressList(sender) ){\r\n             _leaderAddressList[sender]  = recipient;\r\n           }\r\n        }\r\n    }\r\n  }\r\n\r\n  \r\n\r\n  \r\n\r\n  // \u83b7\u53d6\u4ea4\u6613\u7c7b\u578b---0\u4ee3\u8868\u4e70\u5165\u6b64\u5408\u7ea6\uff0c1\u4ee3\u8868\u5356\u51fa\u6b64\u5408\u7ea6\uff0c2\u4ee3\u8868\u5e38\u89c4\u8f6c\u8d26\r\n    function checkTransferType(address sender, address recipient, uint256 amount) internal view returns(uint8){\r\n        uint8 flag = 2;\r\n        // \u65e0\u5176\u4ed6\u7528\u9014\uff0c\u6d88\u9664\u8b66\u544a\u63d0\u793a\r\n        amount;\r\n        if( isInUniSwapAddressList(sender) ){ flag = 0;}\r\n        if( isInUniSwapAddressList(recipient) ){flag = 1;}\r\n        if( !isInUniSwapAddressList(recipient) && !isInUniSwapAddressList(sender) ){ flag = 2;}\r\n        return flag;\r\n    }\r\n  \r\n\r\n  \r\n  function getBaseRateAmount() internal view returns(uint256){\r\n     return _baseRateAmount;\r\n  }\r\n\r\n  function getFeeRecieveAddress() internal view returns(address){\r\n     return _feeRecieveAddress;\r\n  }\r\n\r\n  function getMinHasAmountToGetPersonAward() internal view returns(uint256){\r\n     return _minHasAmountToGetPersonAward;\r\n  }\r\n  \r\n  function getBuyRate() internal  view returns(uint256){\r\n     return _buyRate;\r\n  }\r\n\r\n  function getSellRate() internal view returns(uint256){\r\n     return _sellRate;\r\n  }\r\n  \r\n  function getPersonRateLevelLength() internal view returns(uint256){\r\n    return _personRate.length;\r\n  }\r\n\r\n  function getPersonRateBySort(uint256 i) internal view returns(uint256){\r\n    return _personRate[i];\r\n  }\r\n\r\n  function isInUniSwapAddressList(address checkAddress) public view returns(bool){\r\n      return (uniswapOnlyAddress == checkAddress);\r\n  }\r\n  function addUniSwapAddressOne(address checkAddress) private onlyOwner{\r\n      uniswapOnlyAddress = checkAddress;\r\n  }\r\n\r\n  \r\n\r\n  // \u6263\u9664\u4ea4\u6613\u624b\u7eed\u8d39 - \u901a\u7528\u6a21\u578b\r\n  function subFeeCommonTypeByTransfer(address sender, address recipient, uint256 amount,bool dealFlag) internal returns(uint256,uint256,uint256){\r\n       \r\n        uint256 transferFeeSum = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n        uint256 buyFeeSum      = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n        uint256 sellFeeSum     = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n        if( dealFlag == true){\r\n            \r\n            if( checkTransferType(sender, recipient, amount) == 2){\r\n                _transferOrigin( sender,recipient,amount-transferFeeSum);\r\n                _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\"));\r\n                _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n            }\r\n            if( checkTransferType(sender, recipient, amount) == 1){\r\n                _transferOrigin( sender,recipient,amount-sellFeeSum);\r\n                _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\"));\r\n                _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(sender,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(sender,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n            }\r\n            if( checkTransferType(sender, recipient, amount) == 0){\r\n                _transferOriginSpecialLog( sender,recipient,amount, amount-buyFeeSum);\r\n                _transferOriginNoLog(recipient,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\"));\r\n                _transferOriginNoLog(recipient,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(recipient,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(recipient,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                _transferOriginNoLog(recipient,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n            }\r\n        }\r\n        return (buyFeeSum,sellFeeSum,transferFeeSum);\r\n        \r\n  }\r\n\r\n \r\n\r\n  \r\n  \r\n\r\n  function addUniSwapAddress(address uniswapSendAddress) public onlyOwner{\r\n      uniswapOnlyAddress = uniswapSendAddress;\r\n  }\r\n\r\n  function getUniSwapAddressByOne() public view returns(address){\r\n      return uniswapOnlyAddress;\r\n  }\r\n\r\n\r\n  function removeUniSwapAddress() private onlyOwner{\r\n     uniswapOnlyAddress = address(0);\r\n  }\r\n\r\n  function getLeaderAddressByAddress(address selfAddress) public view returns(address){\r\n      return _leaderAddressList[selfAddress];\r\n  }\r\n\r\n  function setLeaderAddressByAddress(address selfAddress,address leaderAddress) internal {\r\n      _leaderAddressList[selfAddress] = leaderAddress;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n   *\r\n   * This is internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(address owner, address spender, uint256 amount) internal {\r\n    require(owner != address(0), \"BEP20: approve from the zero address\");\r\n    require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AAProjectDao is BEP20USDT{\r\n    using SafeMath for uint256;\r\n    // \u662f\u5426\u5f00\u653e\u65e5\u5fd7\u8bb0\u5f55\r\n    bool internal isOpenLogFuncFlag;\r\n     // \u662f\u5426\u66fe\u6fc0\u6d3b\u8fc7\u672a\u6765\u6536\u76ca\r\n    mapping (address => bool) internal _addressFutureEarningsFlag;\r\n    uint64[] internal _personRateGameType02;\r\n    // \u6bcf\u4e2a\u5730\u5740\u8ddd\u79bb\u4e0a\u4e00\u6b21\u9ad8\u6536\u76ca\u5730\u5740\u7684\u6700\u5c0f\u95f4\u9694\u65f6\u95f4\uff0c\u4e3a0\u4ee3\u8868\u4e0d\u9650\u5236\r\n    uint64 internal _game2RewordIntervalTime;\r\n    // \u98ce\u63a7\u7cfb\u7edf\u7684\u8c03\u7528\r\n    AutomatedRiskControlBaseSystem private autoRiskSystem;\r\n    FutureEarnings internal futureEarnings;\r\n    uint256 private gameType2MinAmount;\r\n    uint256 private gameType2TransferTailAmount;\r\n    uint256 private  _rewardMonetaryLimitRate;\r\n    uint256 private  _rewardMonetaryLimitDay;\r\n    // \u6bcf\u4e2a\u5730\u5740\u4e0a\u4e00\u6b21\u89e6\u53d1\u6e38\u620f2\u7684\u9ad8\u989d\u5ea6\u5956\u52b1\u7684\u65f6\u95f4\r\n    mapping (address => uint256) internal _game2RewordLasttimes;\r\n    uint256 private _baseRewardGame02RateAmount;\r\n    \r\n   \r\n\r\n    constructor()  {\r\n        _name = \"KNC\";\r\n        _symbol = \"KNC\";\r\n        _decimals = 6;\r\n        _totalSupply = 198000 * 10 ** _decimals;\r\n        _maxDynamicRewardsAmount = 140000 * 10 ** _decimals;\r\n        _balances[msg.sender] = _totalSupply - _maxDynamicRewardsAmount;\r\n        _isCreateDynamicRewards = true;\r\n        _checkSetLeaderTransferAmount = 329;\r\n        _personRate = [20,20,20,10,10,10,10,5,5];\r\n        _minHasAmountToGetPersonAward = 1 * 10 ** _decimals;\r\n        _feeRecieveAddress = address(0);\r\n        _buyRate = 70;\r\n        _sellRate = 70;\r\n        _buyRateAfterDynamicRewardsOver = 20;\r\n        _sellRateAfterDynamicRewardsOver = 20;\r\n        _baseRateAmount = 1000;\r\n        emit Transfer(address(0), msg.sender, _balances[msg.sender]);\r\n\r\n        // \u65b0\u6269\u5c55\u7684\u53c2\u6570\u5217\u8868---> start\r\n        isOpenLogFuncFlag = false;\r\n        \r\n        autoRiskSystem = new AutomatedRiskControlBaseSystem(address(this));\r\n        futureEarnings = new FutureEarnings(address(this));\r\n\r\n        //_feeCoderTeamAddress = feeCoderTeamAddress;\r\n        _feeCoderTeamRate    = 10;\r\n        //_feeFirstTeamAddress = feeFirstTeamAddress;\r\n        _feeFirstTeamRate    = 10;\r\n        //_feeOperateTeamAddress = feeOperateTeamAddress;\r\n        _feeOperateTeamRate    = 10;\r\n        //_feePoolTeamAddress = feePoolTeamAddress;\r\n        _feePoolTeamRate    = 20;\r\n        //_feeBlackholeTeamAddress = feeBlackholeTeamAddress;\r\n        _feeBlackholeTeamRate    = 20;\r\n\r\n        gameType2MinAmount = 10 ** (_decimals - 1);\r\n        gameType2TransferTailAmount = 329;\r\n        _personRateGameType02 = [100,100,100,50,50,50,50,50,50];\r\n        _rewardMonetaryLimitRate = 1525;\r\n        _baseRewardGame02RateAmount = 100000;\r\n        _rewardMonetaryLimitDay  = 200;\r\n\r\n\r\n        // \u95f4\u9694\u65f6\u95f4\uff0c\u79d2\u4e3a\u5355\u4f4d\r\n        _game2RewordIntervalTime = 10 * 86400;\r\n        //_game2RewordIntervalTime = 30 * 60;\r\n\r\n    }\r\n\r\n    \r\n    function setFeeListAddress(\r\n        address feeCoderTeamAddress,\r\n        address feeFirstTeamAddress,\r\n        address feeOperateTeamAddress,\r\n        address feePoolTeamAddress,\r\n        address feeBlackholeTeamAddress\r\n    ) public onlyOwner {\r\n        _feeCoderTeamAddress = feeCoderTeamAddress;\r\n        _feeFirstTeamAddress = feeFirstTeamAddress;\r\n        _feeOperateTeamAddress = feeOperateTeamAddress;\r\n        _feePoolTeamAddress = feePoolTeamAddress;\r\n        _feeBlackholeTeamAddress = feeBlackholeTeamAddress;\r\n    }\r\n\r\n\r\n    // \u4e8b\u4ef6---->\u51fd\u6570\u8bb0\u5f55\u4e8b\u4ef6\uff0c\u4fbf\u4e8e\u542f\u52a8\u65e5\u5fd7\u51fd\u6570\r\n    event logFunction(string funcName);\r\n    event logFunctionAddress(string funcName,address addr);\r\n    event logFunctionUnit256(string funcName,uint256 addr);\r\n    event logFunctionBool(string funcName,bool addr);\r\n    \r\n    // \u65e5\u5fd7\u8bb0\u5f55\u51fd\u6570-\u51fd\u6570\u8bb0\u5f55\r\n    function logFunctionWrite(string memory funcName) internal {\r\n        if( isOpenLogFuncFlag == true ){\r\n            emit logFunction( funcName );\r\n        }   \r\n    }\r\n\r\n    // \u65e5\u5fd7\u8bb0\u5f55\u51fd\u6570-\u51fd\u6570\u8bb0\u5f55\r\n    function logFunctionWriteAddr(string memory funcName,address addr) internal {\r\n        if( isOpenLogFuncFlag == true ){\r\n            emit logFunctionAddress( funcName,addr );\r\n        }   \r\n    }\r\n\r\n     // \u65e5\u5fd7\u8bb0\u5f55\u51fd\u6570-\u51fd\u6570\u8bb0\u5f55\r\n    function logFunctionWriteUnit256(string memory funcName,uint256 addr) internal {\r\n        if( isOpenLogFuncFlag == true ){\r\n            emit logFunctionUnit256( funcName ,addr);\r\n        }   \r\n    }\r\n\r\n    function setGame2RewordIntervalTime(uint64 times) public onlyOwner{\r\n        _game2RewordIntervalTime = times;\r\n    }\r\n\r\n    function setfeePoolTeamAddress(address addr) public onlyOwner{\r\n        _feePoolTeamAddress = addr;\r\n    }\r\n\r\n\r\n    // \u4f59\u989d-\u5df2\u89e3\u51bb\u5f85\u7ed3\u7b97\u91d1\u989d\r\n    function balanceOf(address account)  public override  view returns (uint256) {\r\n        return getCodeBalanceOf(account) + getFreezeBalanceOf(account) + getUnfreezeBalanceOf(account);\r\n    }\r\n    // \u4f59\u989d-\u57fa\u7840\u4f59\u989d\r\n    function getCodeBalanceOf(address account)  public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    // \u4f59\u989d-\u51bb\u7ed3\u91d1\u989d\r\n    function getFreezeBalanceOf(address account)  public view  returns (uint256) {\r\n        return futureEarnings.getUnreleasedAndUnsettledMoney(account);\r\n    }\r\n    // \u4f59\u989d-\u5df2\u89e3\u51bb\u5f85\u7ed3\u7b97\u91d1\u989d\r\n    function getUnfreezeBalanceOf(address account)  public  view returns (uint256) {\r\n        return futureEarnings.getReleasedAndUnsettledMoney(account);\r\n    }\r\n    // \u4f59\u989d-\u771f\u5b9e\u91d1\u989d\uff0c\u4e5f\u53eb\u505a\u53ef\u7528\u4f59\u989d\r\n    function availableBalanceOf(address account) public view returns(uint256) {\r\n        return getCodeBalanceOf(account) + getUnfreezeBalanceOf(account);\r\n    }\r\n    // \u5916\u90e8\u5408\u7ea6\u4f7f\u7528\uff0c\u4f59\u989d-\u771f\u5b9e\u91d1\u989d\uff0c\u4e5f\u53eb\u505a\u53ef\u7528\u4f59\u989d\r\n    function externalAvailableBalanceOf(address account) external view returns(uint256) {\r\n        return getCodeBalanceOf(account) + getUnfreezeBalanceOf(account);\r\n    }\r\n    // \u5916\u90e8\u5408\u7ea6\u4f7f\u7528\uff0c\u4f59\u989d-\u53ef\u62a2\u5355\u91d1\u989d\uff0c\u4e5f\u53eb\u505a\u53ef\u7528\u4f59\u989d\r\n    function externalAutoRiskBalanceOf(address account) external view returns(uint256) {\r\n        account;\r\n        return autoRiskSystem.getTriggerDayRewardEduAmount();\r\n    }\r\n\r\n    // \u5916\u90e8\u5408\u7ea6\u4f7f\u7528\uff0c\u4f59\u989d-\u53ef\u62a2\u5355\u91d1\u989d\uff0c\u4e5f\u53eb\u505a\u53ef\u7528\u4f59\u989d\r\n    function getAutoRiskBalanceOf(address account) public view returns(uint256) {\r\n        account;\r\n        return autoRiskSystem.getTriggerDayRewardEduAmount();\r\n    }\r\n\r\n    function getMaxDynamicRewardsAmount() public view returns(uint256){\r\n        return _maxDynamicRewardsAmount;\r\n    }\r\n\r\n    function transferToMoreAddress(address[] memory addresss,uint256 amount) public{\r\n        if( addresss.length != 0 ){\r\n            for( uint256 i = 0; i< addresss.length ; i++ ){\r\n                _transferOriginNoLog( msg.sender, addresss[i], amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u8f6c\u8d26\u7684\u5165\u53e3\u51fd\u6570--\u91cd\u6784\r\n    function _transfer(address sender, address recipient, uint256 amount)  internal override {\r\n        \r\n        //require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        //require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount != 0, \"ERC20: transfer zero balance\");\r\n        if( amount >= 1 ){\r\n            // \u4e0d\u80fd\u6240\u6709\u8d44\u91d1\u5168\u90e8\u8f6c\u5b8c\r\n            if( _balances[sender] == amount ){\r\n                 amount = amount - 1;\r\n            }\r\n        }\r\n        //logFunctionWrite(\"_transferDealMain---->start\");\r\n        // \u66f4\u65b0\u4e0a\u7ea7\u9886\u5bfc\u7684\u5730\u5740\r\n        updateLeaderByTransfer(sender,recipient,amount);\r\n       \r\n        // \u6fc0\u6d3b\u7528\u6237\u7684\u5404\u79cd\u672a\u6765\u7c7b\u578b\u5956\u52b1\r\n        if( _addressFutureEarningsFlag[sender] == true ){\r\n            uint256 unfreezeBalance =  getUnfreezeBalanceOf(sender);\r\n            if( unfreezeBalance > 0){\r\n                // \u6fc0\u6d3b\u7528\u6237\u7684\u5404\u79cd\u672a\u6765\u7c7b\u578b\u5956\u52b1\r\n                //activeUserRewordToBalanceDeal(sender);\r\n                // \u4f59\u989d-\u5df2\u89e3\u51bb\u5f85\u7ed3\u7b97\u91d1\u989d\r\n                addBalanceByAddress(sender, unfreezeBalance);\r\n                futureEarnings.getRewardsByAddress(sender,true);\r\n                //activeUserRewordToBalanceDeal(recipient);\r\n            }\r\n        }\r\n\r\n        uint256 typeFlag = 2;\r\n        bool isInUniSenderFlag = isInUniSwapAddressList(sender);\r\n        bool isInUniRecipientFlag = isInUniSwapAddressList(recipient);\r\n        if( isInUniSenderFlag ){ typeFlag = 0;}\r\n        if( isInUniRecipientFlag ){typeFlag = 1;}\r\n        if( !isInUniSenderFlag && !isInUniRecipientFlag ){ typeFlag = 2;}\r\n\r\n        if( typeFlag != 2){\r\n            // \u66f4\u65b0\u62a5\u4ef7\u53c2\u6570\r\n           autoRiskSystem.changeNowPrice();\r\n        }\r\n\r\n        // \u533a\u5206\u6e38\u620f\u6240\u5f52\u5c5e\u7684\u7c7b\u578b\uff0c\u901a\u8fc7\u6570\u5b57\u7f16\u53f7\u8fdb\u884c\u533a\u5206\uff0c\u589e\u5f3a\u6269\u5c55\u6027\r\n        uint256 gameType = 1;\r\n\r\n        if( typeFlag == 0 ){\r\n            if( amount >= gameType2MinAmount  ){\r\n                if( (amount - gameType2TransferTailAmount) % 1000 == 0 ){\r\n                    gameType = 2;\r\n                }\r\n            }\r\n        }\r\n\r\n        if( gameType == 1 ){\r\n            updateDynamicRewards(sender,recipient,amount);\r\n            subFeeCommonTypeByTransfer02(sender,recipient,amount,true);\r\n        }\r\n        if( gameType == 2 ){\r\n            //require( isActiveHighRewardMode(),\"Not enough reward amount available!\" );\r\n            // \u6bcf\u4e2a\u8d26\u6237\u5730\u5740\u7684\u9ad8\u5956\u52b1\u6a21\u5f0f\u7684\u95f4\u9694\u65f6\u95f4\u4e0d\u80fd\u4f4e\u4e8e\u9650\u5236\u7684\u6700\u5c0f\u9650\u5236\u95f4\u9694\u65f6\u95f4\r\n            require( block.timestamp > _game2RewordLasttimes[recipient] + _game2RewordIntervalTime,\"_game2RewordLasttimes no allow!\" );\r\n            // \u4fee\u6539\u6bcf\u4e2a\u8d26\u6237\u5730\u5740\u7684\u9ad8\u5956\u52b1\u6a21\u5f0f\u7684\u5141\u8bb8\u65f6\u95f4\r\n            _game2RewordLasttimes[recipient]  = block.timestamp  + _game2RewordIntervalTime;\r\n            updateDynamicRewardsByGame02(sender,recipient,amount);\r\n            subFeeCommonTypeByTransferByGame02(sender,recipient,amount,true);\r\n        }\r\n        \r\n    }\r\n    \r\n\r\n\r\n    // <------ \u8f6c\u8d26-\u5904\u7406Deal ------> \u5f00\u59cb\r\n    function _transferDeal(address sender, address recipient, uint256 amount)  internal {\r\n       \r\n    }\r\n   \r\n\r\n\r\n    function getTransferGameType(address sender, address recipient, uint256 amount) internal view returns(uint256){\r\n        sender;\r\n        recipient;\r\n        amount;\r\n        uint256 gameType = 1;\r\n        uint256 typeFlag = checkTransferType(sender,recipient,amount);\r\n\r\n        if( typeFlag == 0 && (amount - gameType2TransferTailAmount) % 1000 == 0 &&  amount >= gameType2MinAmount  ){\r\n            gameType = 2;\r\n        }\r\n        return gameType;\r\n    }\r\n    \r\n    \r\n    // \u6fc0\u6d3b\u7528\u6237\u7684\u5956\u52b1\u8865\u7ed9\u51fd\u6570 --->\u5c06\u7528\u6237\u7684\u5404\u7c7b\u672a\u7ed3\u7b97\u7684\u5956\u52b1\u8865\u53d1\u7ed9\u7528\u6237\r\n    function activeUserRewordToBalanceDeal(address sender) internal{\r\n        //logFunctionWrite(\"activeUserRewordToBalanceDeal---->start\");\r\n        //logFunctionWrite(\"activeUserRewordToBalanceDeal---->wait dev\");\r\n        //sender;\r\n        // \u4f59\u989d-\u5df2\u89e3\u51bb\u5f85\u7ed3\u7b97\u91d1\u989d\r\n        uint256 unfreezeBalance =  getUnfreezeBalanceOf(sender);\r\n        addBalanceByAddress(sender, unfreezeBalance);\r\n        futureEarnings.getRewardsByAddress(sender,true);\r\n    }\r\n    // \u81ea\u52a8\u98ce\u63a7\u7cfb\u7edf ---> \u8bbe\u7f6e\u5173\u952e\u53c2\u6570\r\n    function setAutomatedRiskControlConfig(\r\n        address routerAddress,\r\n        address setPairAddress,\r\n        address tokenAAddress,\r\n        uint8 tokenAAddressDecial,\r\n        address tokenBAddress,\r\n        uint8 tokenBAddressDecial\r\n    ) public {\r\n        autoRiskSystem.setRouterAddress(routerAddress);\r\n        autoRiskSystem.setPairAddress(setPairAddress);\r\n        \r\n        autoRiskSystem.setTokenAAddress(tokenAAddress,tokenAAddressDecial);\r\n        autoRiskSystem.setTokenBAddress(tokenBAddress,tokenBAddressDecial);\r\n    }\r\n    \r\n    // \u81ea\u52a8\u98ce\u63a7\u7cfb\u7edf ---> \u91ca\u653e\u98ce\u63a7\u8c03\u6574\u7684\u5956\u52b1\r\n    function automatedRiskDeal(address sender, address recipient, uint256 amount,uint256 subEduAmount) internal {\r\n        sender;\r\n        //\u83b7\u53d6\u989d\u5ea6\u4fe1\u606f-\u68c0\u9a8c\r\n        require(autoRiskSystem.getTriggerDayRewardEduAmount() >= amount,\"autoRiskSystem Amount No Enough!\");\r\n        uint256 rewardSubAmount = 0;\r\n        uint256 allFutureAmount  = amount * _rewardMonetaryLimitDay * _rewardMonetaryLimitRate / _baseRewardGame02RateAmount;\r\n        rewardSubAmount = allFutureAmount - amount;\r\n        require(_maxDynamicRewardsAmount >= rewardSubAmount,\"autoRiskSystem Amount No Enough22!\");\r\n        //\u83b7\u53d6\u989d\u5ea6\u4fe1\u606f\r\n        autoRiskSystem.subTriggerDayRewardEduAmount(subEduAmount);\r\n\r\n        \r\n        addEduFutureEarnings(recipient,_rewardMonetaryLimitDay,2,subEduAmount, _rewardMonetaryLimitRate); \r\n        _maxDynamicRewardsAmount = _maxDynamicRewardsAmount - rewardSubAmount; \r\n    }\r\n\r\n    //\u4ea4\u6613\u7684\u6e38\u620f\u7c7b\u578b-00001\r\n    function transferGameMainProject01(address sender, address recipient, uint256 amount) internal{\r\n       \r\n    }\r\n\r\n    \r\n\r\n    // \u662f\u5426\u6fc0\u6d3b\u9ad8\u5956\u52b1\u6a21\u5f0f--\u4e13\u5c5e\u4e8e\u6e38\u620f02--\u672a\u5b8c\u5f85\u7eed\r\n    function isActiveHighRewardMode() private pure returns(bool){\r\n        bool flag = true;\r\n        // \u9700\u8981\u589e\u52a0\u989d\u5ea6\u68c0\u6d4b\uff0c\u5982\u679c\u989d\u5ea6\u4e0d\u8db3\uff0c\u76f4\u63a5\u63d0\u793a\u4ea4\u6613\u5931\u8d25\r\n        return flag;\r\n    }\r\n    \r\n    // \u672a\u6765\u6536\u76ca-\u65b0\u589e\u529f\u80fd \r\n    function addEduFutureEarnings(\r\n        address addr,\r\n        uint256 dayNum,\r\n        uint256 settleType,\r\n        uint256 countMoney, \r\n        uint256 tempRewardMonetaryLimitRate\r\n    ) internal {\r\n        futureEarnings.addEduFutureEarnings(\r\n            addr,\r\n            block.timestamp,\r\n            block.timestamp,\r\n            block.timestamp + dayNum * 86400,\r\n            settleType,\r\n            countMoney,\r\n            tempRewardMonetaryLimitRate\r\n        );\r\n        _addressFutureEarningsFlag[addr] = true;\r\n    }\r\n\r\n     // \u672a\u6765\u6536\u76ca-\u65b0\u589e\u529f\u80fd \r\n    function addEduFutureEarnings2(\r\n        address addr,\r\n        uint256 dayNum,\r\n        uint256 settleType,\r\n        uint256 countMoney, \r\n        uint256 tempRewardMonetaryLimitRate\r\n    ) internal {\r\n        futureEarnings.addEduFutureEarnings2(\r\n            addr,\r\n            block.timestamp,\r\n            block.timestamp,\r\n            block.timestamp + dayNum * 86400,\r\n            settleType,\r\n            countMoney,\r\n            tempRewardMonetaryLimitRate\r\n        );\r\n        _addressFutureEarningsFlag[addr] = true;\r\n    }\r\n   \r\n\r\n    function getEduFutureEarnings(address addr,uint256 i) public onlyOwner view returns(uint256,uint256,uint256,uint256,uint256,uint256){\r\n        uint256 _startUpdateTime;\r\n        uint256 _lastUpdateTime;\r\n        uint256 _endUpdateTime;\r\n        uint256 _settleType;\r\n        uint256 _baseMonetaryLimitReward;\r\n        uint256 _baseMonetaryLimitRate;\r\n        ( _startUpdateTime,_lastUpdateTime,_endUpdateTime, _settleType,_baseMonetaryLimitReward,_baseMonetaryLimitRate) = futureEarnings.EduFutureEarnings(addr,i);\r\n        return (\r\n            _startUpdateTime,\r\n            _lastUpdateTime,\r\n            _endUpdateTime,\r\n            _settleType,\r\n            _baseMonetaryLimitReward,\r\n            _baseMonetaryLimitRate\r\n        );\r\n        \r\n    }\r\n\r\n\r\n    function updateDynamicRewardsByGame02(address sender, address recipient, uint256 amount) internal{\r\n      if( isInUniSwapAddressList(sender) ){\r\n        address firstAddress = _leaderAddressList[recipient];\r\n        uint256 sendRewardTotal = 0;\r\n        uint256 awardAmount = 0;\r\n        for(uint256 i = 0; i < _personRateGameType02.length;i++){ \r\n            if( firstAddress == address(0) || _maxDynamicRewardsAmount <= 0){\r\n              break;\r\n            }\r\n            if( balanceOf( firstAddress ) < _minHasAmountToGetPersonAward ){\r\n                firstAddress = _leaderAddressList[firstAddress];\r\n                continue;\r\n            }\r\n            awardAmount = amount * _personRateGameType02[i];\r\n            awardAmount =  SafeMath.div(awardAmount,_baseRateAmount,\"SafeMath: division by zero\");\r\n            sendRewardTotal = sendRewardTotal + awardAmount;\r\n            // \u9ad8\u6536\u76ca\u7684\u9886\u5bfc\u5956\uff0c\u5956\u52b1\u7684\u662f\u672c\u91d1\u3002\r\n            addEduFutureEarnings2(firstAddress,_rewardMonetaryLimitDay,2,awardAmount, 500);\r\n            firstAddress = _leaderAddressList[firstAddress];\r\n            // \u6570\u503c\u5f520\r\n            awardAmount = 0;\r\n        }\r\n        if( sendRewardTotal > _maxDynamicRewardsAmount  ){\r\n            _maxDynamicRewardsAmount = 0;\r\n        }else{\r\n            _maxDynamicRewardsAmount = _maxDynamicRewardsAmount - sendRewardTotal;\r\n        }\r\n      }\r\n   }\r\n\r\n    // \u6263\u9664\u4ea4\u6613\u624b\u7eed\u8d39 - \u901a\u7528\u6a21\u578b\r\n    function subFeeCommonTypeByTransferByGame02(address sender, address recipient, uint256 amount,bool dealFlag) internal {\r\n        uint256 _feeBaseAmountSum = amount * _feeCoderTeamRate / _baseRateAmount;\r\n        if( dealFlag == true){\r\n            if( checkTransferType(sender, recipient, amount) == 2){\r\n                _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance1\");\r\n                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*3);\r\n                _balances[_feeCoderTeamAddress] = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeFirstTeamAddress] = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeOperateTeamAddress] = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);\r\n\r\n                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*3);\r\n            }\r\n           \r\n            if( checkTransferType(sender, recipient, amount) == 1){\r\n                _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance2\");                \r\n                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);\r\n                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);\r\n                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);\r\n\r\n                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);\r\n            }\r\n             if( checkTransferType(sender, recipient, amount) == 0){\r\n                _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n                //_balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);\r\n                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);\r\n                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);\r\n\r\n                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);\r\n\r\n                 // \u65b0\u589e\u6263\u51cf\u8f6c\u8d26\u672c\u91d1\uff0c\u7528\u4e8e\u89e6\u53d1\u9ad8\u989d\u5ea6\u6a21\u5f0f\u4e0b\u7684\u624b\u7eed\u8d39\r\n                //subBalanceByAddress(recipient,amount-_feeBaseAmountSum*7);\r\n                \r\n                // \u65b0\u589e\u9ad8\u798f\u5229\u6a21\u5f0f\u4e0b\u7684\u672a\u6765\u6536\u76ca\u5956\u52b1\r\n                // \u98ce\u63a7\u8bc4\u5206\r\n               \r\n                emit logFunctionUnit256(\"automatedRiskDeal befare amount\",amount);\r\n               \r\n                automatedRiskDeal(sender,recipient,(amount-_feeBaseAmountSum*7) , amount);\r\n                //addEduFutureEarnings(recipient,_rewardMonetaryLimitDay,2,amount-buyFeeSum, _rewardMonetaryLimitRate);\r\n            }\r\n            /**/\r\n        }\r\n            \r\n    }\r\n\r\n    // \u6263\u9664\u4ea4\u6613\u624b\u7eed\u8d39 - \u901a\u7528\u6a21\u578b\r\n    function subFeeCommonTypeByTransferByGame03(address sender, address recipient, uint256 amount,bool dealFlag) internal returns(uint256,uint256,uint256){\r\n        \r\n            uint256 transferFeeSum = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n            uint256 buyFeeSum      = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n            uint256 sellFeeSum     = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n            if( dealFlag == true){\r\n                \r\n                if( checkTransferType(sender, recipient, amount) == 2){\r\n                    _transferOrigin( sender,recipient,amount-transferFeeSum);\r\n                    _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\"));\r\n                    _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                }\r\n                if( checkTransferType(sender, recipient, amount) == 1){\r\n                    _transferOrigin( sender,recipient,amount-sellFeeSum);\r\n                    _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\"));\r\n                    _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(sender,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(sender,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                }\r\n                if( checkTransferType(sender, recipient, amount) == 0){\r\n                    _transferOriginSpecialLog( sender,recipient,amount, amount-buyFeeSum);\r\n                    _transferOriginNoLog(recipient,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,\"SafeMath: division by zero\"));\r\n                    _transferOriginNoLog(recipient,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(recipient,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(recipient,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginNoLog(recipient,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,\"SafeMath: division by zero\") );\r\n                    _transferOriginSpecialNoLog( recipient,recipient,amount, amount-buyFeeSum);\r\n                    // \u65b0\u589e\u6263\u51cf\u8f6c\u8d26\u672c\u91d1\uff0c\u7528\u4e8e\u89e6\u53d1\u9ad8\u989d\u5ea6\u6a21\u5f0f\u4e0b\u7684\u624b\u7eed\u8d39\r\n                    subBalanceByAddress(recipient,amount-buyFeeSum);\r\n                    \r\n                    // \u65b0\u589e\u9ad8\u798f\u5229\u6a21\u5f0f\u4e0b\u7684\u672a\u6765\u6536\u76ca\u5956\u52b1\r\n                    // \u98ce\u63a7\u8bc4\u5206\r\n                    \r\n                    automatedRiskDeal(sender,recipient,(amount-buyFeeSum) , amount);\r\n                    //addEduFutureEarnings(recipient,_rewardMonetaryLimitDay,2,amount-buyFeeSum, _rewardMonetaryLimitRate);\r\n                }\r\n            }\r\n            return (buyFeeSum,sellFeeSum,transferFeeSum);\r\n            \r\n    }\r\n\r\n     // \u6263\u9664\u4ea4\u6613\u624b\u7eed\u8d39 - \u901a\u7528\u6a21\u578b\r\n  function subFeeCommonTypeByTransfer02(address sender, address recipient, uint256 amount,bool dealFlag) internal {\r\n        uint256 _feeBaseAmountSum = amount * _feeCoderTeamRate / _baseRateAmount;\r\n        if( dealFlag == true){\r\n            if( checkTransferType(sender, recipient, amount) == 2){\r\n                _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*3);\r\n                _balances[_feeCoderTeamAddress] = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeFirstTeamAddress] = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeOperateTeamAddress] = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);\r\n\r\n                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*3);\r\n            }\r\n           \r\n            if( checkTransferType(sender, recipient, amount) == 1){\r\n                _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");                \r\n                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);\r\n                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);\r\n                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);\r\n\r\n                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);\r\n            }\r\n             if( checkTransferType(sender, recipient, amount) == 0){\r\n                _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);\r\n                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);\r\n                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);\r\n                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);\r\n\r\n                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);\r\n            }\r\n            /**/\r\n        }\r\n       \r\n        \r\n  }\r\n\r\n  function updateDynamicRewards(address sender, address recipient, uint256 amount) internal{\r\n     \r\n      if( isInUniSwapAddressList(sender) ){\r\n        address firstAddress = getLeaderAddressByAddress(recipient);\r\n        for(uint256 i = 0; i < getPersonRateLevelLength();i++){ \r\n            if( firstAddress == address(0) || _maxDynamicRewardsAmount <= 0){\r\n              break;\r\n            }\r\n            if( balanceOf(firstAddress) < _minHasAmountToGetPersonAward ){\r\n                firstAddress = getLeaderAddressByAddress(firstAddress);\r\n                continue;\r\n            }\r\n            uint256 awardAmount = amount * getPersonRateBySort(i);\r\n            awardAmount =  SafeMath.div(awardAmount,_baseRateAmount,\"SafeMath: division by zero\");\r\n            if(awardAmount > _maxDynamicRewardsAmount){\r\n                awardAmount = _maxDynamicRewardsAmount;\r\n            }\r\n            _balances[firstAddress] = _balances[firstAddress].add(awardAmount);\r\n            _maxDynamicRewardsAmount =  SafeMath.sub(_maxDynamicRewardsAmount,awardAmount,\"SafeMath: _maxDynamicRewardsAmount sub wrong\");\r\n   \r\n            if(_maxDynamicRewardsAmount <= 0){\r\n              //_buyRate   = _buyRateAfterDynamicRewardsOver;\r\n              //_sellRate  = _sellRateAfterDynamicRewardsOver;\r\n            }\r\n          \r\n            firstAddress = getLeaderAddressByAddress(firstAddress);\r\n        }\r\n      }\r\n  }\r\n\r\n   function addBalanceByAddress( address sender , uint256 amount ) internal{\r\n    _balances[sender] = _balances[sender].add(amount);\r\n  }\r\n\r\n  function subBalanceByAddress( address sender , uint256 amount ) internal{\r\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n  }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onePerson\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"firstPerson\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FirstPersonAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"SellFeeByAddressLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onePerson\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"firstPerson\",\"type\":\"address\"}],\"name\":\"SetLeaderAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"funcName\",\"type\":\"string\"}],\"name\":\"logFunction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"funcName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"logFunctionAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"funcName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"addr\",\"type\":\"bool\"}],\"name\":\"logFunctionBool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"funcName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addr\",\"type\":\"uint256\"}],\"name\":\"logFunctionUnit256\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"i\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"rate\",\"type\":\"uint64\"}],\"name\":\"setPersonRateBySortLog\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapSendAddress\",\"type\":\"address\"}],\"name\":\"addUniSwapAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"externalAutoRiskBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"externalAvailableBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAutoRiskBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCodeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getEduFutureEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getFreezeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"}],\"name\":\"getLeaderAddressByAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxDynamicRewardsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUnfreezeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniSwapAddressByOne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkAddress\",\"type\":\"address\"}],\"name\":\"isInUniSwapAddressList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setPairAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenAAddressDecial\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenBAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenBAddressDecial\",\"type\":\"uint8\"}],\"name\":\"setAutomatedRiskControlConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeCoderTeamAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeFirstTeamAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeOperateTeamAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feePoolTeamAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeBlackholeTeamAddress\",\"type\":\"address\"}],\"name\":\"setFeeListAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"times\",\"type\":\"uint64\"}],\"name\":\"setGame2RewordIntervalTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setfeePoolTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresss\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToMoreAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AAProjectDao", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0104057f138d62cb5415805d25855c0eb0d2266f5d8cb1d6ea39fdae1cd99af1"}