{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/BPool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./BToken.sol\\\";\\r\\nimport \\\"./BMath.sol\\\";\\r\\n\\r\\ncontract BPool is BToken, BMath {\\r\\n\\r\\n    struct Record {\\r\\n        bool bound;   // is token bound to pool\\r\\n        uint index;   // private\\r\\n        uint denorm;  // denormalized weight\\r\\n        uint balance;\\r\\n    }\\r\\n\\r\\n    event LOG_SWAP(\\r\\n        address indexed caller,\\r\\n        address indexed tokenIn,\\r\\n        address indexed tokenOut,\\r\\n        uint256         tokenAmountIn,\\r\\n        uint256         tokenAmountOut\\r\\n    );\\r\\n\\r\\n    event LOG_JOIN(\\r\\n        address indexed caller,\\r\\n        address indexed tokenIn,\\r\\n        uint256         tokenAmountIn\\r\\n    );\\r\\n\\r\\n    event LOG_EXIT(\\r\\n        address indexed caller,\\r\\n        address indexed tokenOut,\\r\\n        uint256         tokenAmountOut\\r\\n    );\\r\\n\\r\\n    event LOG_CALL(\\r\\n        bytes4  indexed sig,\\r\\n        address indexed caller,\\r\\n        bytes           data\\r\\n    ) anonymous;\\r\\n\\r\\n    modifier _logs_() {\\r\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier _lock_() {\\r\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\r\\n        _mutex = true;\\r\\n        _;\\r\\n        _mutex = false;\\r\\n    }\\r\\n\\r\\n    modifier _viewlock_() {\\r\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier _onlyController() {\\r\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier _onlyFinalized() {\\r\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier _onlyNotFinalized() {\\r\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    bool private _mutex;\\r\\n\\r\\n    address private _factory;    // BFactory address to push token exitFee to\\r\\n    address private _controller; // has CONTROL role\\r\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\r\\n\\r\\n    // `setSwapFee` and `finalize` require CONTROL\\r\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\r\\n    uint private _swapFee;\\r\\n    bool private _finalized;\\r\\n\\r\\n    address[] private _tokens;\\r\\n    mapping(address=>Record) private  _records;\\r\\n    uint private _totalWeight;\\r\\n\\r\\n    constructor() public {\\r\\n        _controller = msg.sender;\\r\\n        _factory = msg.sender;\\r\\n        _swapFee = MIN_FEE;\\r\\n        _publicSwap = false;\\r\\n        _finalized = false;\\r\\n    }\\r\\n\\r\\n    function isPublicSwap()\\r\\n        external view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _publicSwap;\\r\\n    }\\r\\n\\r\\n    function isFinalized()\\r\\n        external view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _finalized;\\r\\n    }\\r\\n\\r\\n    function isBound(address t)\\r\\n        external view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _records[t].bound;\\r\\n    }\\r\\n\\r\\n    function getNumTokens()\\r\\n        external view\\r\\n        returns (uint) \\r\\n    {\\r\\n        return _tokens.length;\\r\\n    }\\r\\n\\r\\n    function getCurrentTokens()\\r\\n        external view _viewlock_\\r\\n        returns (address[] memory tokens)\\r\\n    {\\r\\n        return _tokens;\\r\\n    }\\r\\n\\r\\n    function getFinalTokens()\\r\\n        external view\\r\\n        _viewlock_\\r\\n        _onlyNotFinalized\\r\\n        returns (address[] memory tokens)\\r\\n    {\\r\\n        return _tokens;\\r\\n    }\\r\\n\\r\\n    function getDenormalizedWeight(address token)\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint)\\r\\n    {\\r\\n\\r\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        return _records[token].denorm;\\r\\n    }\\r\\n\\r\\n    function getTotalDenormalizedWeight()\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint)\\r\\n    {\\r\\n        return _totalWeight;\\r\\n    }\\r\\n\\r\\n    function getNormalizedWeight(address token)\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint)\\r\\n    {\\r\\n\\r\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        uint denorm = _records[token].denorm;\\r\\n        return bdiv(denorm, _totalWeight);\\r\\n    }\\r\\n\\r\\n    function getBalance(address token)\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint)\\r\\n    {\\r\\n\\r\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        return _records[token].balance;\\r\\n    }\\r\\n\\r\\n    function getSwapFee()\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint)\\r\\n    {\\r\\n        return _swapFee;\\r\\n    }\\r\\n\\r\\n    function getController()\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (address)\\r\\n    {\\r\\n        return _controller;\\r\\n    }\\r\\n\\r\\n    function setSwapFee(uint swapFee)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyFinalized\\r\\n        _onlyController\\r\\n    { \\r\\n        require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\r\\n        require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\r\\n        _swapFee = swapFee;\\r\\n    }\\r\\n\\r\\n    function setController(address manager)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyController\\r\\n    {\\r\\n        _controller = manager;\\r\\n    }\\r\\n\\r\\n    function setPublicSwap(bool public_)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyFinalized\\r\\n        _onlyController\\r\\n    {\\r\\n        _publicSwap = public_;\\r\\n    }\\r\\n\\r\\n    function finalize()\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyFinalized\\r\\n        _onlyController\\r\\n    {\\r\\n        require(_tokens.length >= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\r\\n\\r\\n        _finalized = true;\\r\\n        _publicSwap = true;\\r\\n\\r\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\r\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\r\\n    }\\r\\n\\r\\n\\r\\n    function bind(address token, uint balance, uint denorm)\\r\\n        external\\r\\n        _logs_\\r\\n        _onlyController\\r\\n        _onlyFinalized\\r\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\r\\n    {\\r\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\r\\n\\r\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\r\\n\\r\\n        _records[token] = Record({\\r\\n            bound: true,\\r\\n            index: _tokens.length,\\r\\n            denorm: 0,    // balance and denorm will be validated\\r\\n            balance: 0   // and set by `rebind`\\r\\n        });\\r\\n        _tokens.push(token);\\r\\n        rebind(token, balance, denorm);\\r\\n    }\\r\\n\\r\\n    function rebind(address token, uint balance, uint denorm)\\r\\n        public\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyController\\r\\n        _onlyFinalized\\r\\n    {\\r\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n\\r\\n        require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\r\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\r\\n        require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\r\\n\\r\\n        // Adjust the denorm and totalWeight\\r\\n        uint oldWeight = _records[token].denorm;\\r\\n        if (denorm > oldWeight) {\\r\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\r\\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\r\\n        } else if (denorm < oldWeight) {\\r\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\r\\n        }        \\r\\n        _records[token].denorm = denorm;\\r\\n\\r\\n        // Adjust the balance record and actual token balance\\r\\n        uint oldBalance = _records[token].balance;\\r\\n        _records[token].balance = balance;\\r\\n        if (balance > oldBalance) {\\r\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\r\\n        } else if (balance < oldBalance) {\\r\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\r\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\r\\n            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\r\\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\r\\n            _pushUnderlying(token, _factory, tokenExitFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function unbind(address token)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyController\\r\\n        _onlyFinalized\\r\\n    {\\r\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n\\r\\n        uint tokenBalance = _records[token].balance;\\r\\n        uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\r\\n\\r\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\r\\n\\r\\n        // Swap the token-to-unbind with the last token,\\r\\n        // then delete the last token\\r\\n        uint index = _records[token].index;\\r\\n        uint last = _tokens.length - 1;\\r\\n        _tokens[index] = _tokens[last];\\r\\n        _records[_tokens[index]].index = index;\\r\\n        _tokens.pop();\\r\\n        _records[token] = Record({\\r\\n            bound: false,\\r\\n            index: 0,\\r\\n            denorm: 0,\\r\\n            balance: 0\\r\\n        });\\r\\n\\r\\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\r\\n        _pushUnderlying(token, _factory, tokenExitFee);\\r\\n    }\\r\\n\\r\\n    // Absorb any tokens that have been sent to this contract into the pool\\r\\n    function gulp(address token)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n    {\\r\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function getSpotPrice(address tokenIn, address tokenOut)\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint spotPrice)\\r\\n    {\\r\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        Record storage inRecord = _records[tokenIn];\\r\\n        Record storage outRecord = _records[tokenOut];\\r\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\r\\n    }\\r\\n\\r\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\r\\n        external view\\r\\n        _viewlock_\\r\\n        returns (uint spotPrice)\\r\\n    {\\r\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        Record storage inRecord = _records[tokenIn];\\r\\n        Record storage outRecord = _records[tokenOut];\\r\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\r\\n    }\\r\\n\\r\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\r\\n        external\\r\\n        _onlyNotFinalized\\r\\n        _logs_\\r\\n        _lock_\\r\\n    {\\r\\n        uint poolTotal = totalSupply();\\r\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\r\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\r\\n\\r\\n        for (uint i = 0; i < _tokens.length; i++) {\\r\\n            address t = _tokens[i];\\r\\n            uint bal = _records[t].balance;\\r\\n            uint tokenAmountIn = bmul(ratio, bal);\\r\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\r\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\r\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\r\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\r\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\r\\n        }\\r\\n        _mintPoolShare(poolAmountOut);\\r\\n        _pushPoolShare(msg.sender, poolAmountOut);\\r\\n    }\\r\\n\\r\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\r\\n        external\\r\\n        _logs_\\r\\n        _onlyNotFinalized\\r\\n        _lock_\\r\\n    {\\r\\n        uint poolTotal = totalSupply();\\r\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\r\\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\r\\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\\r\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\r\\n\\r\\n        _pullPoolShare(msg.sender, poolAmountIn);\\r\\n        _pushPoolShare(_factory, exitFee);\\r\\n        _burnPoolShare(pAiAfterExitFee);\\r\\n\\r\\n        for (uint i = 0; i < _tokens.length; i++) {\\r\\n            address t = _tokens[i];\\r\\n            uint bal = _records[t].balance;\\r\\n            uint tokenAmountOut = bmul(ratio, bal);\\r\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\r\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\r\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\r\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\r\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    function swapExactAmountIn(\\r\\n        address tokenIn,\\r\\n        uint tokenAmountIn,\\r\\n        address tokenOut,\\r\\n        uint minAmountOut,\\r\\n        uint maxPrice\\r\\n    )\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\r\\n    {\\r\\n\\r\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\r\\n\\r\\n        Record storage inRecord = _records[address(tokenIn)];\\r\\n        Record storage outRecord = _records[address(tokenOut)];\\r\\n\\r\\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\r\\n\\r\\n        uint spotPriceBefore = calcSpotPrice(\\r\\n                                    inRecord.balance,\\r\\n                                    inRecord.denorm,\\r\\n                                    outRecord.balance,\\r\\n                                    outRecord.denorm,\\r\\n                                    _swapFee\\r\\n                                );\\r\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\r\\n\\r\\n        tokenAmountOut = calcOutGivenIn(\\r\\n                            inRecord.balance,\\r\\n                            inRecord.denorm,\\r\\n                            outRecord.balance,\\r\\n                            outRecord.denorm,\\r\\n                            tokenAmountIn,\\r\\n                            _swapFee\\r\\n                        );\\r\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\r\\n\\r\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\r\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\r\\n\\r\\n        spotPriceAfter = calcSpotPrice(\\r\\n                                inRecord.balance,\\r\\n                                inRecord.denorm,\\r\\n                                outRecord.balance,\\r\\n                                outRecord.denorm,\\r\\n                                _swapFee\\r\\n                            );\\r\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");     \\r\\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\r\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\r\\n\\r\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\r\\n\\r\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\r\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\r\\n\\r\\n        return (tokenAmountOut, spotPriceAfter);\\r\\n    }\\r\\n\\r\\n    function swapExactAmountOut(\\r\\n        address tokenIn,\\r\\n        uint maxAmountIn,\\r\\n        address tokenOut,\\r\\n        uint tokenAmountOut,\\r\\n        uint maxPrice\\r\\n    )\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_ \\r\\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\r\\n    {\\r\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\r\\n\\r\\n        Record storage inRecord = _records[address(tokenIn)];\\r\\n        Record storage outRecord = _records[address(tokenOut)];\\r\\n\\r\\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\r\\n\\r\\n        uint spotPriceBefore = calcSpotPrice(\\r\\n                                    inRecord.balance,\\r\\n                                    inRecord.denorm,\\r\\n                                    outRecord.balance,\\r\\n                                    outRecord.denorm,\\r\\n                                    _swapFee\\r\\n                                );\\r\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\r\\n\\r\\n        tokenAmountIn = calcInGivenOut(\\r\\n                            inRecord.balance,\\r\\n                            inRecord.denorm,\\r\\n                            outRecord.balance,\\r\\n                            outRecord.denorm,\\r\\n                            tokenAmountOut,\\r\\n                            _swapFee\\r\\n                        );\\r\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\r\\n\\r\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\r\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\r\\n\\r\\n        spotPriceAfter = calcSpotPrice(\\r\\n                                inRecord.balance,\\r\\n                                inRecord.denorm,\\r\\n                                outRecord.balance,\\r\\n                                outRecord.denorm,\\r\\n                                _swapFee\\r\\n                            );\\r\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\r\\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\r\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\r\\n\\r\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\r\\n\\r\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\r\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\r\\n\\r\\n        return (tokenAmountIn, spotPriceAfter);\\r\\n    }\\r\\n\\r\\n\\r\\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyNotFinalized\\r\\n        returns (uint poolAmountOut)\\r\\n\\r\\n    {        \\r\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\r\\n\\r\\n        Record storage inRecord = _records[tokenIn];\\r\\n\\r\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\r\\n                            inRecord.balance,\\r\\n                            inRecord.denorm,\\r\\n                            _totalSupply,\\r\\n                            _totalWeight,\\r\\n                            tokenAmountIn,\\r\\n                            _swapFee\\r\\n                        );\\r\\n\\r\\n        require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\r\\n\\r\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\r\\n\\r\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\r\\n\\r\\n        _mintPoolShare(poolAmountOut);\\r\\n        _pushPoolShare(msg.sender, poolAmountOut);\\r\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\r\\n\\r\\n        return poolAmountOut;\\r\\n    }\\r\\n\\r\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyNotFinalized\\r\\n        returns (uint tokenAmountIn)\\r\\n    {\\r\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n\\r\\n        Record storage inRecord = _records[tokenIn];\\r\\n\\r\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\r\\n                            inRecord.balance,\\r\\n                            inRecord.denorm,\\r\\n                            _totalSupply,\\r\\n                            _totalWeight,\\r\\n                            poolAmountOut,\\r\\n                            _swapFee\\r\\n                        );\\r\\n\\r\\n        require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\r\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\r\\n        \\r\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\r\\n\\r\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\r\\n\\r\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\r\\n\\r\\n        _mintPoolShare(poolAmountOut);\\r\\n        _pushPoolShare(msg.sender, poolAmountOut);\\r\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\r\\n\\r\\n        return tokenAmountIn;\\r\\n    }\\r\\n\\r\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyNotFinalized\\r\\n        returns (uint tokenAmountOut)\\r\\n    {\\r\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n\\r\\n        Record storage outRecord = _records[tokenOut];\\r\\n\\r\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\r\\n                            outRecord.balance,\\r\\n                            outRecord.denorm,\\r\\n                            _totalSupply,\\r\\n                            _totalWeight,\\r\\n                            poolAmountIn,\\r\\n                            _swapFee\\r\\n                        );\\r\\n\\r\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\r\\n        \\r\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\r\\n\\r\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\r\\n\\r\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\r\\n\\r\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\r\\n\\r\\n        _pullPoolShare(msg.sender, poolAmountIn);\\r\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\r\\n        _pushPoolShare(_factory, exitFee);\\r\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\r\\n\\r\\n        return tokenAmountOut;\\r\\n    }\\r\\n\\r\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\r\\n        external\\r\\n        _logs_\\r\\n        _lock_\\r\\n        _onlyNotFinalized\\r\\n        returns (uint poolAmountIn)\\r\\n    {\\r\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\r\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\r\\n\\r\\n        Record storage outRecord = _records[tokenOut];\\r\\n\\r\\n        poolAmountIn = calcPoolInGivenSingleOut(\\r\\n                            outRecord.balance,\\r\\n                            outRecord.denorm,\\r\\n                            _totalSupply,\\r\\n                            _totalWeight,\\r\\n                            tokenAmountOut,\\r\\n                            _swapFee\\r\\n                        );\\r\\n\\r\\n        require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\r\\n        require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\r\\n\\r\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\r\\n\\r\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\r\\n\\r\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\r\\n\\r\\n        _pullPoolShare(msg.sender, poolAmountIn);\\r\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\r\\n        _pushPoolShare(_factory, exitFee);\\r\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);        \\r\\n\\r\\n        return poolAmountIn;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ==\\r\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\r\\n    // You must `_lock_` or otherwise ensure reentry-safety\\r\\n\\r\\n    function _pullUnderlying(address erc20, address from, uint amount)\\r\\n        internal\\r\\n    {\\r\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\r\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\r\\n    }\\r\\n\\r\\n    function _pushUnderlying(address erc20, address to, uint amount)\\r\\n        internal\\r\\n    {\\r\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\r\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\r\\n    }\\r\\n\\r\\n    function _pullPoolShare(address from, uint amount)\\r\\n        internal\\r\\n    {\\r\\n        _pull(from, amount);\\r\\n    }\\r\\n\\r\\n    function _pushPoolShare(address to, uint amount)\\r\\n        internal\\r\\n    {\\r\\n        _push(to, amount);\\r\\n    }\\r\\n\\r\\n    function _mintPoolShare(uint amount)\\r\\n        internal\\r\\n    {\\r\\n        _mint(amount);\\r\\n    }\\r\\n\\r\\n    function _burnPoolShare(uint amount)\\r\\n        internal\\r\\n    {\\r\\n        _burn(amount);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./BNum.sol\\\";\\r\\nimport \\\"../utils/PCToken.sol\\\";\\r\\n\\r\\n// Highly opinionated token implementation\\r\\n\\r\\ncontract BTokenKase is BNum {\\r\\n\\r\\n    mapping(address => uint)                   internal _balance;\\r\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\r\\n    uint internal _totalSupply;\\r\\n\\r\\n    event Approval(address indexed src, address indexed dst, uint amt);\\r\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\r\\n\\r\\n    function _mint(uint amt) internal {\\r\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\r\\n        _totalSupply = badd(_totalSupply, amt);\\r\\n        emit Transfer(address(0), address(this), amt);\\r\\n    }\\r\\n\\r\\n    function _burn(uint amt) internal {\\r\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_KAL\\\");\\r\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\r\\n        _totalSupply = bsub(_totalSupply, amt);\\r\\n        emit Transfer(address(this), address(0), amt);\\r\\n    }\\r\\n\\r\\n    function _move(address src, address dst, uint amt) internal {\\r\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_KAL\\\");\\r\\n        _balance[src] = bsub(_balance[src], amt);\\r\\n        _balance[dst] = badd(_balance[dst], amt);\\r\\n        emit Transfer(src, dst, amt);\\r\\n    }\\r\\n\\r\\n    function _push(address to, uint amt) internal {\\r\\n        _move(address(this), to, amt);\\r\\n    }\\r\\n\\r\\n    function _pull(address from, uint amt) internal {\\r\\n        _move(from, address(this), amt);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BToken is BTokenKase, IERC20 {\\r\\n\\r\\n    string  private _name     = \\\"Buni Pool Token\\\";\\r\\n    string  private _symbol   = \\\"BPT\\\";\\r\\n    uint8   private _decimals = 18;\\r\\n\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns(uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function allowance(address src, address dst) external view override returns (uint) {\\r\\n        return _allowance[src][dst];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address whom) external view override returns (uint) {\\r\\n        return _balance[whom];\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function approve(address dst, uint amt) external override returns (bool) {\\r\\n        _allowance[msg.sender][dst] = amt;\\r\\n        emit Approval(msg.sender, dst, amt);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\r\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\r\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\r\\n        uint oldValue = _allowance[msg.sender][dst];\\r\\n        if (amt > oldValue) {\\r\\n            _allowance[msg.sender][dst] = 0;\\r\\n        } else {\\r\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\r\\n        }\\r\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address dst, uint amt) external override returns (bool) {\\r\\n        _move(msg.sender, dst, amt);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\r\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_KTOKEN_BAD_CALLER\\\");\\r\\n        _move(src, dst, amt);\\r\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\r\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\r\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BMath.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./BNum.sol\\\";\\r\\n\\r\\ncontract BMath is BConst, BNum {\\r\\n    /**********************************************************************************************\\r\\n    // calcSpotPrice                                                                             //\\r\\n    // sP = spotPrice                                                                            //\\r\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\r\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\r\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\r\\n    // wO = tokenWeightOut                                                                       //\\r\\n    // sF = swapFee                                                                              //\\r\\n    **********************************************************************************************/\\r\\n    function calcSpotPrice(\\r\\n        uint tokenBalanceIn,\\r\\n        uint tokenWeightIn,\\r\\n        uint tokenBalanceOut,\\r\\n        uint tokenWeightOut,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint spotPrice)\\r\\n    {\\r\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\r\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\r\\n        uint ratio = bdiv(numer, denom);\\r\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\r\\n        return  (spotPrice = bmul(ratio, scale));\\r\\n    }\\r\\n\\r\\n    /**********************************************************************************************\\r\\n    // calcOutGivenIn                                                                            //\\r\\n    // aO = tokenAmountOut                                                                       //\\r\\n    // bO = tokenBalanceOut                                                                      //\\r\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\r\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\r\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\r\\n    // wO = tokenWeightOut                                                                       //\\r\\n    // sF = swapFee                                                                              //\\r\\n    **********************************************************************************************/\\r\\n    function calcOutGivenIn(\\r\\n        uint tokenBalanceIn,\\r\\n        uint tokenWeightIn,\\r\\n        uint tokenBalanceOut,\\r\\n        uint tokenWeightOut,\\r\\n        uint tokenAmountIn,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint tokenAmountOut)\\r\\n    {\\r\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\r\\n        uint adjustedIn = bsub(BONE, swapFee);\\r\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\r\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\r\\n        uint foo = bpow(y, weightRatio);\\r\\n        uint bar = bsub(BONE, foo);\\r\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\r\\n        return tokenAmountOut;\\r\\n    }\\r\\n\\r\\n    /**********************************************************************************************\\r\\n    // calcInGivenOut                                                                            //\\r\\n    // aI = tokenAmountIn                                                                        //\\r\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\r\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\r\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\r\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\r\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\r\\n    // sF = swapFee                                                                              //\\r\\n    **********************************************************************************************/\\r\\n    function calcInGivenOut(\\r\\n        uint tokenBalanceIn,\\r\\n        uint tokenWeightIn,\\r\\n        uint tokenBalanceOut,\\r\\n        uint tokenWeightOut,\\r\\n        uint tokenAmountOut,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint tokenAmountIn)\\r\\n    {\\r\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\r\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\r\\n        uint y = bdiv(tokenBalanceOut, diff);\\r\\n        uint foo = bpow(y, weightRatio);\\r\\n        foo = bsub(foo, BONE);\\r\\n        tokenAmountIn = bsub(BONE, swapFee);\\r\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\r\\n        return tokenAmountIn;\\r\\n    }\\r\\n\\r\\n    /**********************************************************************************************\\r\\n    // calcPoolOutGivenSingleIn                                                                  //\\r\\n    // pAo = poolAmountOut         /                                              \\\\              //\\r\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\r\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\r\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\r\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\r\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\r\\n    // sF = swapFee                \\\\                                              /              //\\r\\n    **********************************************************************************************/\\r\\n    function calcPoolOutGivenSingleIn(\\r\\n        uint tokenBalanceIn,\\r\\n        uint tokenWeightIn,\\r\\n        uint poolSupply,\\r\\n        uint totalWeight,\\r\\n        uint tokenAmountIn,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint poolAmountOut)\\r\\n    {\\r\\n        // Charge the trading fee for the proportion of tokenAi\\r\\n        ///  which is implicitly traded to the other pool tokens.\\r\\n        // That proportion is (1- weightTokenIn)\\r\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\r\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\r\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\r\\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\r\\n\\r\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\r\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\r\\n\\r\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\r\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\r\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\r\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\r\\n        return poolAmountOut;\\r\\n    }\\r\\n\\r\\n    /**********************************************************************************************\\r\\n    // calcSingleInGivenPoolOut                                                                  //\\r\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\r\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\r\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\r\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\r\\n    // wI = weightIn                              /      wI  \\\\                                   //\\r\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\r\\n    // sF = swapFee                               \\\\      tW  /                                   //\\r\\n    **********************************************************************************************/\\r\\n    function calcSingleInGivenPoolOut(\\r\\n        uint tokenBalanceIn,\\r\\n        uint tokenWeightIn,\\r\\n        uint poolSupply,\\r\\n        uint totalWeight,\\r\\n        uint poolAmountOut,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint tokenAmountIn)\\r\\n    {\\r\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\r\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\r\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\r\\n      \\r\\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\r\\n        uint boo = bdiv(BONE, normalizedWeight); \\r\\n        uint tokenInRatio = bpow(poolRatio, boo);\\r\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\r\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\r\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \\r\\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\r\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\r\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\r\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\r\\n        return tokenAmountIn;\\r\\n    }\\r\\n\\r\\n    /**********************************************************************************************\\r\\n    // calcSingleOutGivenPoolIn                                                                  //\\r\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\r\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\r\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\r\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\r\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\r\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\r\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\r\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\r\\n    **********************************************************************************************/\\r\\n    function calcSingleOutGivenPoolIn(\\r\\n        uint tokenBalanceOut,\\r\\n        uint tokenWeightOut,\\r\\n        uint poolSupply,\\r\\n        uint totalWeight,\\r\\n        uint poolAmountIn,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint tokenAmountOut)\\r\\n    {\\r\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\r\\n        // charge exit fee on the pool token side\\r\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\r\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\r\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\r\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\r\\n     \\r\\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\r\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\r\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\r\\n\\r\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\r\\n\\r\\n        // charge swap fee on the output token side \\r\\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\r\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\r\\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\r\\n        return tokenAmountOut;\\r\\n    }\\r\\n\\r\\n    /**********************************************************************************************\\r\\n    // calcPoolInGivenSingleOut                                                                  //\\r\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\r\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\r\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\r\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\r\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\r\\n    // tW = totalWeight           -------------------------------------------------------------  //\\r\\n    // sF = swapFee                                        ( 1 - eF )                            //\\r\\n    // eF = exitFee                                                                              //\\r\\n    **********************************************************************************************/\\r\\n    function calcPoolInGivenSingleOut(\\r\\n        uint tokenBalanceOut,\\r\\n        uint tokenWeightOut,\\r\\n        uint poolSupply,\\r\\n        uint totalWeight,\\r\\n        uint tokenAmountOut,\\r\\n        uint swapFee\\r\\n    )\\r\\n        public pure\\r\\n        returns (uint poolAmountIn)\\r\\n    {\\r\\n\\r\\n        // charge swap fee on the output token side \\r\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\r\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\r\\n        uint zoo = bsub(BONE, normalizedWeight);\\r\\n        uint zar = bmul(zoo, swapFee); \\r\\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\r\\n\\r\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\r\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\r\\n\\r\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\r\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\r\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\r\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\r\\n\\r\\n        // charge exit fee on the pool token side\\r\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\r\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\r\\n        return poolAmountIn;\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BNum.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./BConst.sol\\\";\\r\\n\\r\\ncontract BNum is BConst {\\r\\n\\r\\n    function btoi(uint a)\\r\\n        internal pure \\r\\n        returns (uint)\\r\\n    {\\r\\n        return a / BONE;\\r\\n    }\\r\\n\\r\\n    function bfloor(uint a)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        return btoi(a) * BONE;\\r\\n    }\\r\\n\\r\\n    function badd(uint a, uint b)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        uint c = a + b;\\r\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function bsub(uint a, uint b)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        (uint c, bool flag) = bsubSign(a, b);\\r\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function bsubSign(uint a, uint b)\\r\\n        internal pure\\r\\n        returns (uint, bool)\\r\\n    {\\r\\n        if (a >= b) {\\r\\n            return (a - b, false);\\r\\n        } else {\\r\\n            return (b - a, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bmul(uint a, uint b)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        uint c0 = a * b;\\r\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\r\\n        uint c1 = c0 + (BONE / 2);\\r\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\r\\n        uint c2 = c1 / BONE;\\r\\n        return c2;\\r\\n    }\\r\\n\\r\\n    function bdiv(uint a, uint b)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\r\\n        uint c0 = a * BONE;\\r\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\r\\n        uint c1 = c0 + (b / 2);\\r\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\r\\n        uint c2 = c1 / b;\\r\\n        return c2;\\r\\n    }\\r\\n\\r\\n    // DSMath.wpow\\r\\n    function bpowi(uint a, uint n)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        uint z = n % 2 != 0 ? a : BONE;\\r\\n\\r\\n        for (n /= 2; n != 0; n /= 2) {\\r\\n            a = bmul(a, a);\\r\\n\\r\\n            if (n % 2 != 0) {\\r\\n                z = bmul(z, a);\\r\\n            }\\r\\n        }\\r\\n        return z;\\r\\n    }\\r\\n\\r\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\r\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\r\\n    // of approximation of b^0.w\\r\\n    function bpow(uint base, uint exp)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\r\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\r\\n\\r\\n        uint whole  = bfloor(exp);   \\r\\n        uint remain = bsub(exp, whole);\\r\\n\\r\\n        uint wholePow = bpowi(base, btoi(whole));\\r\\n\\r\\n        if (remain == 0) {\\r\\n            return wholePow;\\r\\n        }\\r\\n\\r\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\r\\n        return bmul(wholePow, partialResult);\\r\\n    }\\r\\n\\r\\n    function bpowApprox(uint base, uint exp, uint precision)\\r\\n        internal pure\\r\\n        returns (uint)\\r\\n    {\\r\\n        // term 0:\\r\\n        uint a     = exp;\\r\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\r\\n        uint term = BONE;\\r\\n        uint sum   = term;\\r\\n        bool negative = false;\\r\\n\\r\\n\\r\\n        // term(k) = numer / denom \\r\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\r\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\r\\n        // continue until term is less than precision\\r\\n        for (uint i = 1; term >= precision; i++) {\\r\\n            uint bigK = i * BONE;\\r\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\r\\n            term = bmul(term, bmul(c, x));\\r\\n            term = bdiv(term, bigK);\\r\\n            if (term == 0) break;\\r\\n\\r\\n            if (xneg) negative = !negative;\\r\\n            if (cneg) negative = !negative;\\r\\n            if (negative) {\\r\\n                sum = bsub(sum, term);\\r\\n            } else {\\r\\n                sum = badd(sum, term);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return sum;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/PCToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n// Imports\\r\\n\\r\\nimport \\\"./BuniSafeMath.sol\\\";\\r\\nimport \\\"./BuniConstants.sol\\\";\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n// Contracts\\r\\n\\r\\n/* solhint-disable func-order */\\r\\n\\r\\n/**\\r\\n * @author Buni Labs\\r\\n * @title Highly opinionated token implementation\\r\\n*/\\r\\ncontract PCToken is IERC20 {\\r\\n    using BuniSafeMath for uint;\\r\\n\\r\\n    // State variables\\r\\n    string public constant NAME = \\\"Buni Smart Pool\\\";\\r\\n    uint8 public constant DECIMALS = 18;\\r\\n\\r\\n    // No leading underscore per naming convention (non-private)\\r\\n    // Cannot call totalSupply (name conflict)\\r\\n    // solhint-disable-next-line private-vars-leading-underscore\\r\\n    uint internal varTotalSupply;\\r\\n\\r\\n    mapping(address => uint) private _balance;\\r\\n    mapping(address => mapping(address => uint)) private _allowance;\\r\\n\\r\\n    string private _symbol;\\r\\n    string private _name;\\r\\n\\r\\n    // Event declarations\\r\\n\\r\\n    // See definitions above; must be redeclared to be emitted from this contract\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    // Function declarations\\r\\n\\r\\n    /**\\r\\n     * @notice Base token constructor\\r\\n     * @param tokenSymbol - the token symbol\\r\\n     */\\r\\n    constructor (string memory tokenSymbol, string memory tokenName) public {\\r\\n        _symbol = tokenSymbol;\\r\\n        _name = tokenName;\\r\\n    }\\r\\n\\r\\n    // External functions\\r\\n\\r\\n    /**\\r\\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\\r\\n     * @param owner - owner of the tokens\\r\\n     * @param spender - entity allowed to spend the tokens\\r\\n     * @return uint - remaining amount spender is allowed to transfer\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view override returns (uint) {\\r\\n        return _allowance[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Getter for current account balance\\r\\n     * @param account - address we're checking the balance of\\r\\n     * @return uint - token balance in the account\\r\\n     */\\r\\n    function balanceOf(address account) external view override returns (uint) {\\r\\n        return _balance[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve owner (sender) to spend a certain amount\\r\\n     * @dev emits an Approval event\\r\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\r\\n     * @param amount - number of tokens being approved\\r\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\r\\n     */\\r\\n    function approve(address spender, uint amount) external override returns (bool) {\\r\\n        /* In addition to the increase/decreaseApproval functions, could\\r\\n           avoid the \\\"approval race condition\\\" by only allowing calls to approve\\r\\n           when the current approval amount is 0\\r\\n        \\r\\n           require(_allowance[msg.sender][spender] == 0, \\\"ERR_RACE_CONDITION\\\");\\r\\n           Some token contracts (e.g., KNC), already revert if you call approve \\r\\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\\r\\n           and safeApprove function when adding tokens to the pool.\\r\\n        */\\r\\n\\r\\n        _allowance[msg.sender][spender] = amount;\\r\\n\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\\r\\n     * @dev emits an Approval event\\r\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\r\\n     * @param amount - number of tokens being approved\\r\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\r\\n     */\\r\\n    function increaseApproval(address spender, uint amount) external returns (bool) {\\r\\n        _allowance[msg.sender][spender] = BuniSafeMath.badd(_allowance[msg.sender][spender], amount);\\r\\n\\r\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\\r\\n     * @dev emits an Approval event\\r\\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\\r\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\r\\n     * @param amount - number of tokens being approved\\r\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\r\\n     */\\r\\n    function decreaseApproval(address spender, uint amount) external returns (bool) {\\r\\n        uint oldValue = _allowance[msg.sender][spender];\\r\\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\\r\\n        if (amount >= oldValue) {\\r\\n            _allowance[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowance[msg.sender][spender] = BuniSafeMath.bsub(oldValue, amount);\\r\\n        }\\r\\n\\r\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer the given amount from sender (caller) to recipient\\r\\n     * @dev _move emits a Transfer event if successful\\r\\n     * @param recipient - entity receiving the tokens\\r\\n     * @param amount - number of tokens being transferred\\r\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\r\\n     */\\r\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\r\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\r\\n\\r\\n        _move(msg.sender, recipient, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer the given amount from sender to recipient\\r\\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\\r\\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\\r\\n     * @param recipient - recipient of the tokens\\r\\n     * @param amount - number of tokens being transferred\\r\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\r\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\r\\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \\\"ERR_PCTOKEN_BAD_CALLER\\\");\\r\\n\\r\\n        _move(sender, recipient, amount);\\r\\n\\r\\n        // memoize for gas optimization\\r\\n        uint oldAllowance = _allowance[sender][msg.sender];\\r\\n\\r\\n        // If the sender is not the caller, adjust the allowance by the amount transferred\\r\\n        if (msg.sender != sender && oldAllowance != uint(-1)) {\\r\\n            _allowance[sender][msg.sender] = BuniSafeMath.bsub(oldAllowance, amount);\\r\\n\\r\\n            emit Approval(msg.sender, recipient, _allowance[sender][msg.sender]);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // public functions\\r\\n\\r\\n    /**\\r\\n     * @notice Getter for the total supply\\r\\n     * @dev declared external for gas optimization\\r\\n     * @return uint - total number of tokens in existence\\r\\n     */\\r\\n    function totalSupply() external view override returns (uint) {\\r\\n        return varTotalSupply;\\r\\n    }\\r\\n\\r\\n    // Public functions\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     *      We allow the user to set this name (as well as the symbol).\\r\\n     *      Alternatives are 1) A fixed string (original design)\\r\\n     *                       2) A fixed string plus the user-defined symbol\\r\\n     *                          return string(abi.encodePacked(NAME, \\\"-\\\", _symbol));\\r\\n     */\\r\\n    function name() external view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n     * called.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() external pure returns (uint8) {\\r\\n        return DECIMALS;\\r\\n    }\\r\\n\\r\\n    // internal functions\\r\\n\\r\\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\\r\\n    // Emit a transfer amount from the null address to this contract\\r\\n    function _mint(uint amount) internal virtual {\\r\\n        _balance[address(this)] = BuniSafeMath.badd(_balance[address(this)], amount);\\r\\n        varTotalSupply = BuniSafeMath.badd(varTotalSupply, amount);\\r\\n\\r\\n        emit Transfer(address(0), address(this), amount);\\r\\n    }\\r\\n\\r\\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\\r\\n    // Emit a transfer amount from this contract to the null address\\r\\n    function _burn(uint amount) internal virtual {\\r\\n        // Can't burn more than we have\\r\\n        // Remove require for gas optimization - bsub will revert on underflow\\r\\n        // require(_balance[address(this)] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\r\\n\\r\\n        _balance[address(this)] = BuniSafeMath.bsub(_balance[address(this)], amount);\\r\\n        varTotalSupply = BuniSafeMath.bsub(varTotalSupply, amount);\\r\\n\\r\\n        emit Transfer(address(this), address(0), amount);\\r\\n    }\\r\\n\\r\\n    // Transfer tokens from sender to recipient\\r\\n    // Adjust balances, and emit a Transfer event\\r\\n    function _move(address sender, address recipient, uint amount) internal virtual {\\r\\n        // Can't send more than sender has\\r\\n        // Remove require for gas optimization - bsub will revert on underflow\\r\\n        // require(_balance[sender] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\r\\n\\r\\n        _balance[sender] = BuniSafeMath.bsub(_balance[sender], amount);\\r\\n        _balance[recipient] = BuniSafeMath.badd(_balance[recipient], amount);\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    // Transfer from this contract to recipient\\r\\n    // Emits a transfer event if successful\\r\\n    function _push(address recipient, uint amount) internal {\\r\\n        _move(address(this), recipient, amount);\\r\\n    }\\r\\n\\r\\n    // Transfer from recipient to this contract\\r\\n    // Emits a transfer event if successful\\r\\n    function _pull(address sender, uint amount) internal {\\r\\n        _move(sender, address(this), amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BConst.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ncontract BConst {\\r\\n    uint public constant BONE              = 10**18;\\r\\n\\r\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\r\\n    uint public constant MAX_BOUND_TOKENS  = 8;\\r\\n\\r\\n    uint public constant MIN_FEE           = BONE / 10**6;\\r\\n    uint public constant MAX_FEE           = BONE / 10;\\r\\n    uint public constant EXIT_FEE          = 0;\\r\\n\\r\\n    uint public constant MIN_WEIGHT        = BONE;\\r\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\r\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\r\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\r\\n\\r\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\r\\n\\r\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\r\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\r\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\r\\n\\r\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\r\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/BuniSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n\\r\\n// Imports\\r\\n\\r\\nimport \\\"./BuniConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @author Buni Labs\\r\\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\\r\\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\\r\\n */\\r\\nlibrary BuniSafeMath {\\r\\n    /**\\r\\n     * @notice Safe addition\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @dev if we are adding b to a, the resulting sum must be greater than a\\r\\n     * @return - sum of operands; throws if overflow\\r\\n     */\\r\\n    function badd(uint a, uint b) internal pure returns (uint) {\\r\\n        uint c = a + b;\\r\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe unsigned subtraction\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @dev Do a signed subtraction, and check that it produces a positive value\\r\\n     *      (i.e., a - b is valid if b <= a)\\r\\n     * @return - a - b; throws if underflow\\r\\n     */\\r\\n    function bsub(uint a, uint b) internal pure returns (uint) {\\r\\n        (uint c, bool negativeResult) = bsubSign(a, b);\\r\\n        require(!negativeResult, \\\"ERR_SUB_UNDERFLOW\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe signed subtraction\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @dev Do a signed subtraction\\r\\n     * @return - difference between a and b, and a flag indicating a negative result\\r\\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\\r\\n     */\\r\\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\r\\n        if (b <= a) {\\r\\n            return (a - b, false);\\r\\n        } else {\\r\\n            return (b - a, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe multiplication\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @dev Multiply safely (and efficiently), rounding down\\r\\n     * @return - product of operands; throws if overflow or rounding error\\r\\n     */\\r\\n    function bmul(uint a, uint b) internal pure returns (uint) {\\r\\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // Standard overflow check: a/a*b=b\\r\\n        uint c0 = a * b;\\r\\n        require(c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\r\\n\\r\\n        // Round to 0 if x*y < BONE/2?\\r\\n        uint c1 = c0 + (BuniConstants.BONE / 2);\\r\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\r\\n        uint c2 = c1 / BuniConstants.BONE;\\r\\n        return c2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe division\\r\\n     * @param dividend - first operand\\r\\n     * @param divisor - second operand\\r\\n     * @dev Divide safely (and efficiently), rounding down\\r\\n     * @return - quotient; throws if overflow or rounding error\\r\\n     */\\r\\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\\r\\n        require(divisor != 0, \\\"ERR_DIV_ZERO\\\");\\r\\n\\r\\n        // Gas optimization\\r\\n        if (dividend == 0){\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint c0 = dividend * BuniConstants.BONE;\\r\\n        require(c0 / dividend == BuniConstants.BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\r\\n\\r\\n        uint c1 = c0 + (divisor / 2);\\r\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\r\\n\\r\\n        uint c2 = c1 / divisor;\\r\\n        return c2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe unsigned integer modulo\\r\\n     * @dev Returns the remainder of dividing two unsigned integers.\\r\\n     *      Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * @param dividend - first operand\\r\\n     * @param divisor - second operand -- cannot be zero\\r\\n     * @return - quotient; throws if overflow or rounding error\\r\\n     */\\r\\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\\r\\n        require(divisor != 0, \\\"ERR_MODULO_BY_ZERO\\\");\\r\\n\\r\\n        return dividend % divisor;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe unsigned integer max\\r\\n     * @dev Returns the greater of the two input values\\r\\n     *\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @return - the maximum of a and b\\r\\n     */\\r\\n    function bmax(uint a, uint b) internal pure returns (uint) {\\r\\n        return a >= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe unsigned integer min\\r\\n     * @dev returns b, if b < a; otherwise returns a\\r\\n     *\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @return - the lesser of the two input values\\r\\n     */\\r\\n    function bmin(uint a, uint b) internal pure returns (uint) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safe unsigned integer average\\r\\n     * @dev Guard against (a+b) overflow by dividing each operand separately\\r\\n     *\\r\\n     * @param a - first operand\\r\\n     * @param b - second operand\\r\\n     * @return - the average of the two values\\r\\n     */\\r\\n    function baverage(uint a, uint b) internal pure returns (uint) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Babylonian square root implementation\\r\\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n     * @param y - operand\\r\\n     * @return z - the square root result\\r\\n     */\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        }\\r\\n        else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/BuniConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @author Buni Labs\\r\\n * @title Put all the constants in one place\\r\\n */\\r\\n\\r\\nlibrary BuniConstants {\\r\\n    // State variables (must be constant in a library)\\r\\n\\r\\n    // B \\\"ONE\\\" - all math is in the \\\"realm\\\" of 10 ** 18;\\r\\n    // where numeric 1 = 10 ** 18\\r\\n    uint public constant BONE = 10**18;\\r\\n    uint public constant MIN_WEIGHT = BONE;\\r\\n    uint public constant MAX_WEIGHT = BONE * 50;\\r\\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\\r\\n    uint public constant MIN_BALANCE = BONE / 10**6;\\r\\n    uint public constant MAX_BALANCE = BONE * 10**12;\\r\\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\\r\\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\\r\\n    uint public constant MIN_FEE = BONE / 10**6;\\r\\n    uint public constant MAX_FEE = BONE / 10;\\r\\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\r\\n    uint public constant EXIT_FEE = 0;\\r\\n    uint public constant MAX_IN_RATIO = BONE / 2;\\r\\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\r\\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\\r\\n    uint public constant MIN_ASSET_LIMIT = 2;\\r\\n    uint public constant MAX_ASSET_LIMIT = 8;\\r\\n    uint public constant MAX_UINT = uint(-1);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n// Interface declarations\\r\\n\\r\\n/* solhint-disable func-order */\\r\\n\\r\\ninterface IERC20 {\\r\\n    // Emitted when the allowance of a spender for an owner is set by a call to approve.\\r\\n    // Value is the new allowance\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\r\\n    // Emitted when value tokens are moved from one account (from) to another (to).\\r\\n    // Note that value may be zero\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    // Returns the amount of tokens in existence\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    // Returns the amount of tokens owned by account\\r\\n    function balanceOf(address account) external view returns (uint);\\r\\n\\r\\n    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\\r\\n    // through transferFrom. This is zero by default\\r\\n    // This value changes when approve or transferFrom are called\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    // Sets amount as the allowance of spender over the caller\u2019s tokens\\r\\n    // Returns a boolean value indicating whether the operation succeeded\\r\\n    // Emits an Approval event.\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n\\r\\n    // Moves amount tokens from the caller\u2019s account to recipient\\r\\n    // Returns a boolean value indicating whether the operation succeeded\\r\\n    // Emits a Transfer event.\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n\\r\\n    // Moves amount tokens from sender to recipient using the allowance mechanism\\r\\n    // Amount is then deducted from the caller\u2019s allowance\\r\\n    // Returns a boolean value indicating whether the operation succeeded\\r\\n    // Emits a Transfer event\\r\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleInGivenPoolOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"rebind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"public_\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BPool", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}