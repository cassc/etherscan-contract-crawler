{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/Chainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {CBORChainlink} from \\\"./vendor/CBORChainlink.sol\\\";\\nimport {BufferChainlink} from \\\"./vendor/BufferChainlink.sol\\\";\\n\\n/**\\n * @title Library for common Chainlink functions\\n * @dev Uses imported CBOR library for encoding to buffer\\n */\\nlibrary Chainlink {\\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\\n\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  struct Request {\\n    bytes32 id;\\n    address callbackAddress;\\n    bytes4 callbackFunctionId;\\n    uint256 nonce;\\n    BufferChainlink.buffer buf;\\n  }\\n\\n  /**\\n   * @notice Initializes a Chainlink request\\n   * @dev Sets the ID, callback address, and callback function signature on the request\\n   * @param self The uninitialized request\\n   * @param jobId The Job Specification ID\\n   * @param callbackAddr The callback address\\n   * @param callbackFunc The callback function signature\\n   * @return The initialized request\\n   */\\n  function initialize(\\n    Request memory self,\\n    bytes32 jobId,\\n    address callbackAddr,\\n    bytes4 callbackFunc\\n  ) internal pure returns (Chainlink.Request memory) {\\n    BufferChainlink.init(self.buf, defaultBufferSize);\\n    self.id = jobId;\\n    self.callbackAddress = callbackAddr;\\n    self.callbackFunctionId = callbackFunc;\\n    return self;\\n  }\\n\\n  /**\\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\\n   * @param self The initialized request\\n   * @param data The CBOR data\\n   */\\n  function setBuffer(Request memory self, bytes memory data) internal pure {\\n    BufferChainlink.init(self.buf, data.length);\\n    BufferChainlink.append(self.buf, data);\\n  }\\n\\n  /**\\n   * @notice Adds a string value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The string value to add\\n   */\\n  function add(\\n    Request memory self,\\n    string memory key,\\n    string memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeString(value);\\n  }\\n\\n  /**\\n   * @notice Adds a bytes value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The bytes value to add\\n   */\\n  function addBytes(\\n    Request memory self,\\n    string memory key,\\n    bytes memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeBytes(value);\\n  }\\n\\n  /**\\n   * @notice Adds a int256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The int256 value to add\\n   */\\n  function addInt(\\n    Request memory self,\\n    string memory key,\\n    int256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds a uint256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The uint256 value to add\\n   */\\n  function addUint(\\n    Request memory self,\\n    string memory key,\\n    uint256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeUInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds an array of strings to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param values The array of string values to add\\n   */\\n  function addStringArray(\\n    Request memory self,\\n    string memory key,\\n    string[] memory values\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.startArray();\\n    for (uint256 i = 0; i < values.length; i++) {\\n      self.buf.encodeString(values[i]);\\n    }\\n    self.buf.endSequence();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/CBORChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.19;\\n\\nimport {BufferChainlink} from \\\"./BufferChainlink.sol\\\";\\n\\nlibrary CBORChainlink {\\n  using BufferChainlink for BufferChainlink.buffer;\\n\\n  uint8 private constant MAJOR_TYPE_INT = 0;\\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\\n  uint8 private constant MAJOR_TYPE_STRING = 3;\\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n  uint8 private constant MAJOR_TYPE_MAP = 5;\\n  uint8 private constant MAJOR_TYPE_TAG = 6;\\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\\n    if(value <= 23) {\\n      buf.appendUint8(uint8((major << 5) | value));\\n    } else if (value <= 0xFF) {\\n      buf.appendUint8(uint8((major << 5) | 24));\\n      buf.appendInt(value, 1);\\n    } else if (value <= 0xFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 25));\\n      buf.appendInt(value, 2);\\n    } else if (value <= 0xFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 26));\\n      buf.appendInt(value, 4);\\n    } else {\\n      buf.appendUint8(uint8((major << 5) | 27));\\n      buf.appendInt(value, 8);\\n    }\\n  }\\n\\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\\n    buf.appendUint8(uint8((major << 5) | 31));\\n  }\\n\\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, value);\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n    }\\n  }\\n\\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\\n    if(value < -0x10000000000000000) {\\n      encodeSignedBigNum(buf, value);\\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, uint(value));\\n    } else if(value >= 0) {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\\n    }\\n  }\\n\\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n    buf.append(value);\\n  }\\n\\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n    encodeBytes(buf, abi.encode(value));\\n  }\\n\\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\\n  }\\n\\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n    buf.append(bytes(value));\\n  }\\n\\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n  }\\n\\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n  }\\n\\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/BufferChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary BufferChainlink {\\n  /**\\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n   *      a capacity. The capacity may be longer than the current value, in\\n   *      which case it can be extended without the need to allocate more memory.\\n   */\\n  struct buffer {\\n    bytes buf;\\n    uint256 capacity;\\n  }\\n\\n  /**\\n   * @dev Initializes a buffer with an initial capacity.\\n   * @param buf The buffer to initialize.\\n   * @param capacity The number of bytes of space to allocate the buffer.\\n   * @return The buffer, for chaining.\\n   */\\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\\n    if (capacity % 32 != 0) {\\n      capacity += 32 - (capacity % 32);\\n    }\\n    // Allocate space for the buffer data\\n    buf.capacity = capacity;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(buf, ptr)\\n      mstore(ptr, 0)\\n      mstore(0x40, add(32, add(ptr, capacity)))\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Initializes a new buffer from an existing bytes object.\\n   *      Changes to the buffer may mutate the original value.\\n   * @param b The bytes object to initialize the buffer with.\\n   * @return A new buffer.\\n   */\\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\\n    buffer memory buf;\\n    buf.buf = b;\\n    buf.capacity = b.length;\\n    return buf;\\n  }\\n\\n  function resize(buffer memory buf, uint256 capacity) private pure {\\n    bytes memory oldbuf = buf.buf;\\n    init(buf, capacity);\\n    append(buf, oldbuf);\\n  }\\n\\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\\n    if (a > b) {\\n      return a;\\n    }\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Sets buffer length to 0.\\n   * @param buf The buffer to truncate.\\n   * @return The original buffer, for chaining..\\n   */\\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n    assembly {\\n      let bufptr := mload(buf)\\n      mstore(bufptr, 0)\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The start offset to write to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    require(len <= data.length);\\n\\n    if (off + len > buf.capacity) {\\n      resize(buf, max(buf.capacity, len + off) * 2);\\n    }\\n\\n    uint256 dest;\\n    uint256 src;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Start address = buffer address + offset + sizeof(buffer length)\\n      dest := add(add(bufptr, 32), off)\\n      // Update buffer length if we're extending it\\n      if gt(add(len, off), buflen) {\\n        mstore(bufptr, add(len, off))\\n      }\\n      src := add(data, 32)\\n    }\\n\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    unchecked {\\n      uint256 mask = (256**(32 - len)) - 1;\\n      assembly {\\n        let srcpart := and(mload(src), not(mask))\\n        let destpart := and(mload(dest), mask)\\n        mstore(dest, or(destpart, srcpart))\\n      }\\n    }\\n\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, len);\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, data.length);\\n  }\\n\\n  /**\\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write the byte at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeUint8(\\n    buffer memory buf,\\n    uint256 off,\\n    uint8 data\\n  ) internal pure returns (buffer memory) {\\n    if (off >= buf.capacity) {\\n      resize(buf, buf.capacity * 2);\\n    }\\n\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Address = buffer address + sizeof(buffer length) + off\\n      let dest := add(add(bufptr, off), 32)\\n      mstore8(dest, data)\\n      // Update buffer length if we extended it\\n      if eq(off, buflen) {\\n        mstore(bufptr, add(buflen, 1))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\\n    return writeUint8(buf, buf.buf.length, data);\\n  }\\n\\n  /**\\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n   *      exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (left-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes32 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    unchecked {\\n      uint256 mask = (256**len) - 1;\\n      // Right-align data\\n      data = data >> (8 * (32 - len));\\n      assembly {\\n        // Memory address of the buffer data\\n        let bufptr := mload(buf)\\n        // Address = buffer address + sizeof(buffer length) + off + len\\n        let dest := add(add(bufptr, off), len)\\n        mstore(dest, or(and(mload(dest), not(mask)), data))\\n        // Update buffer length if we extended it\\n        if gt(add(off, len), mload(bufptr)) {\\n          mstore(bufptr, add(off, len))\\n        }\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeBytes20(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes20 data\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, off, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chhaining.\\n   */\\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, 32);\\n  }\\n\\n  /**\\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (right-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeInt(\\n    buffer memory buf,\\n    uint256 off,\\n    uint256 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint256 mask = (256**len) - 1;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + off + sizeof(buffer length) + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n   * exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer.\\n   */\\n  function appendInt(\\n    buffer memory buf,\\n    uint256 data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return writeInt(buf, buf.buf.length, data, len);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/ChainlinkTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Chainlink.sol\\\";\\nimport \\\"../vendor/CBORChainlink.sol\\\";\\nimport \\\"../vendor/BufferChainlink.sol\\\";\\n\\ncontract ChainlinkTestHelper {\\n  using Chainlink for Chainlink.Request;\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  Chainlink.Request private req;\\n\\n  event RequestData(bytes payload);\\n\\n  function closeEvent() public {\\n    emit RequestData(req.buf.buf);\\n  }\\n\\n  function setBuffer(bytes memory data) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.setBuffer(data);\\n    req = r2;\\n  }\\n\\n  function add(string memory _key, string memory _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.add(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addBytes(string memory _key, bytes memory _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addBytes(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addInt(string memory _key, int256 _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addInt(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addUint(string memory _key, uint256 _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addUint(_key, _value);\\n    req = r2;\\n  }\\n\\n  // Temporarily have method receive bytes32[] memory until experimental\\n  // string[] memory can be invoked from truffle tests.\\n  function addStringArray(string memory _key, string[] memory _values) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addStringArray(_key, _values);\\n    req = r2;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ChainlinkClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Chainlink.sol\\\";\\nimport \\\"./interfaces/ENSInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/ChainlinkRequestInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/PointerInterface.sol\\\";\\nimport {ENSResolver as ENSResolver_Chainlink} from \\\"./vendor/ENSResolver.sol\\\";\\n\\n/**\\n * @title The ChainlinkClient contract\\n * @notice Contract writers can inherit this contract in order to create requests for the\\n * Chainlink network\\n */\\nabstract contract ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\\n  uint256 private constant AMOUNT_OVERRIDE = 0;\\n  address private constant SENDER_OVERRIDE = address(0);\\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\\\"link\\\");\\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\\\"oracle\\\");\\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\\n\\n  ENSInterface private s_ens;\\n  bytes32 private s_ensNode;\\n  LinkTokenInterface private s_link;\\n  OperatorInterface private s_oracle;\\n  uint256 private s_requestCount = 1;\\n  mapping(bytes32 => address) private s_pendingRequests;\\n\\n  event ChainlinkRequested(bytes32 indexed id);\\n  event ChainlinkFulfilled(bytes32 indexed id);\\n  event ChainlinkCancelled(bytes32 indexed id);\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackAddr address to operate the callback on\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildChainlinkRequest(\\n    bytes32 specId,\\n    address callbackAddr,\\n    bytes4 callbackFunctionSignature\\n  ) internal pure returns (Chainlink.Request memory) {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\\n    internal\\n    view\\n    returns (Chainlink.Request memory)\\n  {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, address(this), callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      ChainlinkRequestInterface.oracleRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      address(this),\\n      req.callbackFunctionId,\\n      nonce,\\n      ORACLE_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      OperatorInterface.operatorRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      req.callbackFunctionId,\\n      nonce,\\n      OPERATOR_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Make a request to an oracle\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param nonce used to generate the request ID\\n   * @param payment The amount of LINK to send for the request\\n   * @param encodedRequest data encoded for request type specific format\\n   * @return requestId The request ID\\n   */\\n  function _rawRequest(\\n    address oracleAddress,\\n    uint256 nonce,\\n    uint256 payment,\\n    bytes memory encodedRequest\\n  ) private returns (bytes32 requestId) {\\n    requestId = keccak256(abi.encodePacked(this, nonce));\\n    s_pendingRequests[requestId] = oracleAddress;\\n    emit ChainlinkRequested(requestId);\\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \\\"unable to transferAndCall to oracle\\\");\\n  }\\n\\n  /**\\n   * @notice Allows a request to be cancelled if it has not been fulfilled\\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\\n   * Deletes the request from the `pendingRequests` mapping.\\n   * Emits ChainlinkCancelled event.\\n   * @param requestId The request ID\\n   * @param payment The amount of LINK sent for the request\\n   * @param callbackFunc The callback function specified for the request\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelChainlinkRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) internal {\\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkCancelled(requestId);\\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice the next request count to be used in generating a nonce\\n   * @dev starts at 1 in order to ensure consistent gas cost\\n   * @return returns the next request count to be used in a nonce\\n   */\\n  function getNextRequestCount() internal view returns (uint256) {\\n    return s_requestCount;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle address\\n   * @param oracleAddress The address of the oracle contract\\n   */\\n  function setChainlinkOracle(address oracleAddress) internal {\\n    s_oracle = OperatorInterface(oracleAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the LINK token address\\n   * @param linkAddress The address of the LINK token contract\\n   */\\n  function setChainlinkToken(address linkAddress) internal {\\n    s_link = LinkTokenInterface(linkAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the Chainlink token address for the public\\n   * network as given by the Pointer contract\\n   */\\n  function setPublicChainlinkToken() internal {\\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the LINK token\\n   * @return The address of the LINK token\\n   */\\n  function chainlinkTokenAddress() internal view returns (address) {\\n    return address(s_link);\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the oracle contract\\n   * @return The address of the oracle contract\\n   */\\n  function chainlinkOracleAddress() internal view returns (address) {\\n    return address(s_oracle);\\n  }\\n\\n  /**\\n   * @notice Allows for a request which was created on another contract to be fulfilled\\n   * on this contract\\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\\n   * @param requestId The request ID used for the response\\n   */\\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\\n    s_pendingRequests[requestId] = oracleAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\\n   * @dev Accounts for subnodes having different resolvers\\n   * @param ensAddress The address of the ENS contract\\n   * @param node The ENS node hash\\n   */\\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\\n    s_ens = ENSInterface(ensAddress);\\n    s_ensNode = node;\\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\\n    setChainlinkToken(resolver.addr(linkSubnode));\\n    updateChainlinkOracleWithENS();\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle contract with the address resolved by ENS\\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\\n   */\\n  function updateChainlinkOracleWithENS() internal {\\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\\n    setChainlinkOracle(resolver.addr(oracleSubnode));\\n  }\\n\\n  /**\\n   * @notice Ensures that the fulfillment is valid for this contract\\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\\n   * @param requestId The request ID for fulfillment\\n   */\\n  function validateChainlinkCallback(bytes32 requestId)\\n    internal\\n    recordChainlinkFulfillment(requestId)\\n  // solhint-disable-next-line no-empty-blocks\\n  {\\n\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the oracle of the request.\\n   * Emits ChainlinkFulfilled event.\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\\n    require(msg.sender == s_pendingRequests[requestId], \\\"Source must be the oracle of the request\\\");\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkFulfilled(requestId);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the request is already pending\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier notPendingRequest(bytes32 requestId) {\\n    require(s_pendingRequests[requestId] == address(0), \\\"Request is already pending\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/ENSInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ENSInterface {\\n  // Logged when the owner of a node assigns a new owner to a subnode.\\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n  // Logged when the owner of a node transfers ownership to a new account.\\n  event Transfer(bytes32 indexed node, address owner);\\n\\n  // Logged when the resolver for a node changes.\\n  event NewResolver(bytes32 indexed node, address resolver);\\n\\n  // Logged when the TTL of a node changes\\n  event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external;\\n\\n  function setResolver(bytes32 node, address resolver) external;\\n\\n  function setOwner(bytes32 node, address owner) external;\\n\\n  function setTTL(bytes32 node, uint64 ttl) external;\\n\\n  function owner(bytes32 node) external view returns (address);\\n\\n  function resolver(bytes32 node) external view returns (address);\\n\\n  function ttl(bytes32 node) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/ChainlinkRequestInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OperatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OracleInterface.sol\\\";\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\n\\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  ) external returns (bool);\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\\n\\n  function getAuthorizedSenders() external returns (address[] memory);\\n\\n  function setAuthorizedSenders(address[] calldata senders) external;\\n\\n  function getForwarder() external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/PointerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface PointerInterface {\\n  function getAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/ENSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ENSResolver {\\n  function addr(bytes32 node) public view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  ) external returns (bool);\\n\\n  function isAuthorizedSender(address node) external view returns (bool);\\n\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/ChainlinkClientTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ChainlinkClient.sol\\\";\\n\\ncontract ChainlinkClientTestHelper is ChainlinkClient {\\n  constructor(address _link, address _oracle) {\\n    setChainlinkToken(_link);\\n    setChainlinkOracle(_oracle);\\n  }\\n\\n  event Request(bytes32 id, address callbackAddress, bytes4 callbackfunctionSelector, bytes data);\\n  event LinkAmount(uint256 amount);\\n\\n  function publicNewRequest(\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature\\n  ) public {\\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\\n  }\\n\\n  function publicRequest(\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    sendChainlinkRequest(req, _wei);\\n  }\\n\\n  function publicRequestRunTo(\\n    address _oracle,\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    sendChainlinkRequestTo(_oracle, run, _wei);\\n  }\\n\\n  function publicRequestOracleData(\\n    bytes32 _id,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\\n    sendOperatorRequest(req, _wei);\\n  }\\n\\n  function publicRequestOracleDataFrom(\\n    address _oracle,\\n    bytes32 _id,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\\n    sendOperatorRequestTo(_oracle, run, _wei);\\n  }\\n\\n  function publicCancelRequest(\\n    bytes32 _requestId,\\n    uint256 _payment,\\n    bytes4 _callbackFunctionId,\\n    uint256 _expiration\\n  ) public {\\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\\n  }\\n\\n  function publicChainlinkToken() public view returns (address) {\\n    return chainlinkTokenAddress();\\n  }\\n\\n  function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\\n    fulfillRequest(_requestId, bytes32(0));\\n  }\\n\\n  function fulfillRequest(bytes32 _requestId, bytes32) public {\\n    validateChainlinkCallback(_requestId);\\n  }\\n\\n  function publicLINK(uint256 _amount) public {\\n    emit LinkAmount(LINK_DIVISIBILITY * _amount);\\n  }\\n\\n  function publicOracleAddress() public view returns (address) {\\n    return chainlinkOracleAddress();\\n  }\\n\\n  function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\\n    addChainlinkExternalRequest(_oracle, _requestId);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFV2RevertingExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\n// VRFV2RevertingExample will always revert. Used for testing only, useless in prod.\\ncontract VRFV2RevertingExample is VRFConsumerBaseV2 {\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n  uint64 public s_subId;\\n  uint256 public s_gasAvailable;\\n\\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n  }\\n\\n  function fulfillRandomWords(uint256, uint256[] memory) internal override {\\n    revert();\\n  }\\n\\n  function testCreateSubscriptionAndFund(uint96 amount) external {\\n    if (s_subId == 0) {\\n      s_subId = COORDINATOR.createSubscription();\\n      COORDINATOR.addConsumer(s_subId, address(this));\\n    }\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function topUpSubscription(uint96 amount) external {\\n    require(s_subId != 0, \\\"sub not set\\\");\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function updateSubscription(address[] memory consumers) external {\\n    require(s_subId != 0, \\\"subID not set\\\");\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\\n    }\\n  }\\n\\n  function testRequestRandomness(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minReqConfs,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256) {\\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\\n    return s_requestId;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFSingleConsumerExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Example of a single consumer contract which owns the subscription.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFSingleConsumerExample is VRFConsumerBaseV2 {\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n\\n  struct RequestConfig {\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint16 requestConfirmations;\\n    uint32 numWords;\\n    bytes32 keyHash;\\n  }\\n  RequestConfig public s_requestConfig;\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  address s_owner;\\n\\n  constructor(\\n    address vrfCoordinator,\\n    address link,\\n    uint32 callbackGasLimit,\\n    uint16 requestConfirmations,\\n    uint32 numWords,\\n    bytes32 keyHash\\n  ) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n    s_owner = msg.sender;\\n    s_requestConfig = RequestConfig({\\n      subId: 0, // Unset initially\\n      callbackGasLimit: callbackGasLimit,\\n      requestConfirmations: requestConfirmations,\\n      numWords: numWords,\\n      keyHash: keyHash\\n    });\\n    subscribe();\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    require(requestId == s_requestId, \\\"request ID is incorrect\\\");\\n    s_randomWords = randomWords;\\n  }\\n\\n  // Assumes the subscription is funded sufficiently.\\n  function requestRandomWords() external onlyOwner {\\n    RequestConfig memory rc = s_requestConfig;\\n    // Will revert if subscription is not set and funded.\\n    s_requestId = COORDINATOR.requestRandomWords(\\n      rc.keyHash,\\n      rc.subId,\\n      rc.requestConfirmations,\\n      rc.callbackGasLimit,\\n      rc.numWords\\n    );\\n  }\\n\\n  // Assumes this contract owns link\\n  // This method is analogous to VRFv1, except the amount\\n  // should be selected based on the keyHash (each keyHash functions like a \\\"gas lane\\\"\\n  // with different link costs).\\n  function fundAndRequestRandomWords(uint256 amount) external onlyOwner {\\n    RequestConfig memory rc = s_requestConfig;\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\\n    // Will revert if subscription is not set and funded.\\n    s_requestId = COORDINATOR.requestRandomWords(\\n      rc.keyHash,\\n      rc.subId,\\n      rc.requestConfirmations,\\n      rc.callbackGasLimit,\\n      rc.numWords\\n    );\\n  }\\n\\n  // Assumes this contract owns link\\n  function topUpSubscription(uint256 amount) external onlyOwner {\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\\n  }\\n\\n  function withdraw(uint256 amount, address to) external onlyOwner {\\n    LINKTOKEN.transfer(to, amount);\\n  }\\n\\n  function unsubscribe(address to) external onlyOwner {\\n    // Returns funds to this address\\n    COORDINATOR.cancelSubscription(s_requestConfig.subId, to);\\n    s_requestConfig.subId = 0;\\n  }\\n\\n  // Keep this separate incase the contract want to unsubscribe and then\\n  // resubscribe.\\n  function subscribe() public onlyOwner {\\n    // Create a subscription, current subId\\n    address[] memory consumers = new address[](1);\\n    consumers[0] = address(this);\\n    s_requestConfig.subId = COORDINATOR.createSubscription();\\n    COORDINATOR.addConsumer(s_requestConfig.subId, consumers[0]);\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == s_owner);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFMaliciousConsumerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFMaliciousConsumerV2 is VRFConsumerBaseV2 {\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n  uint64 public s_subId;\\n  uint256 public s_gasAvailable;\\n  bytes32 s_keyHash;\\n\\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n  }\\n\\n  function setKeyHash(bytes32 keyHash) public {\\n    s_keyHash = keyHash;\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    s_gasAvailable = gasleft();\\n    s_randomWords = randomWords;\\n    s_requestId = requestId;\\n    // Should revert\\n    COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 200000, 1);\\n  }\\n\\n  function testCreateSubscriptionAndFund(uint96 amount) external {\\n    if (s_subId == 0) {\\n      s_subId = COORDINATOR.createSubscription();\\n      COORDINATOR.addConsumer(s_subId, address(this));\\n    }\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function updateSubscription(address[] memory consumers) external {\\n    require(s_subId != 0, \\\"subID not set\\\");\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\\n    }\\n  }\\n\\n  function testRequestRandomness() external returns (uint256) {\\n    return COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 500000, 1);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFExternalSubOwnerExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFExternalSubOwnerExample is VRFConsumerBaseV2 {\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  address s_owner;\\n\\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n    s_owner = msg.sender;\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    require(requestId == s_requestId, \\\"request ID is incorrect\\\");\\n    s_randomWords = randomWords;\\n  }\\n\\n  function requestRandomWords(\\n    uint64 subId,\\n    uint32 callbackGasLimit,\\n    uint16 requestConfirmations,\\n    uint32 numWords,\\n    bytes32 keyHash\\n  ) external onlyOwner {\\n    // Will revert if subscription is not funded.\\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, requestConfirmations, callbackGasLimit, numWords);\\n  }\\n\\n  function transferOwnership(address newOwner) external onlyOwner {\\n    s_owner = newOwner;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == s_owner);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFConsumerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFConsumerV2 is VRFConsumerBaseV2 {\\n  uint256[] public s_randomWords;\\n  uint256 public s_requestId;\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  LinkTokenInterface LINKTOKEN;\\n  uint64 public s_subId;\\n  uint256 public s_gasAvailable;\\n\\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n    LINKTOKEN = LinkTokenInterface(link);\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    require(requestId == s_requestId, \\\"request ID is incorrect\\\");\\n\\n    s_gasAvailable = gasleft();\\n    s_randomWords = randomWords;\\n  }\\n\\n  function testCreateSubscriptionAndFund(uint96 amount) external {\\n    if (s_subId == 0) {\\n      s_subId = COORDINATOR.createSubscription();\\n      COORDINATOR.addConsumer(s_subId, address(this));\\n    }\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function topUpSubscription(uint96 amount) external {\\n    require(s_subId != 0, \\\"sub not set\\\");\\n    // Approve the link transfer.\\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\\n  }\\n\\n  function updateSubscription(address[] memory consumers) external {\\n    require(s_subId != 0, \\\"subID not set\\\");\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\\n    }\\n  }\\n\\n  function testRequestRandomness(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minReqConfs,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256) {\\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\\n    return s_requestId;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/mocks/VRFCoordinatorV2Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// A mock for testing code that relies on VRFCoordinatorV2.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../dev/VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFCoordinatorV2Mock is VRFCoordinatorV2Interface {\\n  uint96 public immutable BASE_FEE;\\n  uint96 public immutable GAS_PRICE_LINK;\\n\\n  error InvalidSubscription();\\n  error InsufficientBalance();\\n  error MustBeSubOwner(address owner);\\n\\n  event RandomWordsRequested(\\n    bytes32 indexed keyHash,\\n    uint256 requestId,\\n    uint256 preSeed,\\n    uint64 indexed subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords,\\n    address indexed sender\\n  );\\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\\n  event SubscriptionCreated(uint64 indexed subId, address owner);\\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\\n\\n  uint64 s_currentSubId;\\n  uint256 s_nextRequestId = 1;\\n  uint256 s_nextPreSeed = 100;\\n  struct Subscription {\\n    address owner;\\n    uint96 balance;\\n  }\\n  mapping(uint64 => Subscription) s_subscriptions; /* subId */ /* subscription */\\n\\n  struct Request {\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint32 numWords;\\n  }\\n  mapping(uint256 => Request) s_requests; /* requestId */ /* request */\\n\\n  constructor(uint96 _baseFee, uint96 _gasPriceLink) {\\n    BASE_FEE = _baseFee;\\n    GAS_PRICE_LINK = _gasPriceLink;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomWords fulfills the given request, sending the random words to the supplied\\n   * @notice consumer.\\n   *\\n   * @dev This mock uses a simplified formula for calculating payment amount and gas usage, and does\\n   * @dev not account for all edge cases handled in the real VRF coordinator. When making requests\\n   * @dev against the real coordinator a small amount of additional LINK is required.\\n   *\\n   * @param _requestId the request to fulfill\\n   * @param _consumer the VRF randomness consumer to send the result to\\n   */\\n  function fulfillRandomWords(uint256 _requestId, address _consumer) external {\\n    uint256 startGas = gasleft();\\n    if (s_requests[_requestId].subId == 0) {\\n      revert(\\\"nonexistent request\\\");\\n    }\\n    Request memory req = s_requests[_requestId];\\n\\n    uint256[] memory words = new uint256[](req.numWords);\\n    for (uint256 i = 0; i < req.numWords; i++) {\\n      words[i] = uint256(keccak256(abi.encode(_requestId, i)));\\n    }\\n\\n    VRFConsumerBaseV2 v;\\n    bytes memory callReq = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, _requestId, words);\\n    (bool success, ) = _consumer.call{gas: req.callbackGasLimit}(callReq);\\n\\n    uint96 payment = uint96(BASE_FEE + ((startGas - gasleft()) * GAS_PRICE_LINK));\\n    if (s_subscriptions[req.subId].balance < payment) {\\n      revert InsufficientBalance();\\n    }\\n    s_subscriptions[req.subId].balance -= payment;\\n    delete (s_requests[_requestId]);\\n    emit RandomWordsFulfilled(_requestId, _requestId, payment, success);\\n  }\\n\\n  /**\\n   * @notice fundSubscription allows funding a subscription with an arbitrary amount for testing.\\n   *\\n   * @param _subId the subscription to fund\\n   * @param _amount the amount to fund\\n   */\\n  function fundSubscription(uint64 _subId, uint96 _amount) public {\\n    if (s_subscriptions[_subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    uint96 oldBalance = s_subscriptions[_subId].balance;\\n    s_subscriptions[_subId].balance += _amount;\\n    emit SubscriptionFunded(_subId, oldBalance, oldBalance + _amount);\\n  }\\n\\n  function requestRandomWords(\\n    bytes32 _keyHash,\\n    uint64 _subId,\\n    uint16 _minimumRequestConfirmations,\\n    uint32 _callbackGasLimit,\\n    uint32 _numWords\\n  ) external override returns (uint256) {\\n    if (s_subscriptions[_subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n\\n    uint256 requestId = s_nextRequestId++;\\n    uint256 preSeed = s_nextPreSeed++;\\n\\n    s_requests[requestId] = Request({subId: _subId, callbackGasLimit: _callbackGasLimit, numWords: _numWords});\\n\\n    emit RandomWordsRequested(\\n      _keyHash,\\n      requestId,\\n      preSeed,\\n      _subId,\\n      _minimumRequestConfirmations,\\n      _callbackGasLimit,\\n      _numWords,\\n      msg.sender\\n    );\\n    return requestId;\\n  }\\n\\n  function createSubscription() external override returns (uint64 _subId) {\\n    s_currentSubId++;\\n    s_subscriptions[s_currentSubId] = Subscription({owner: msg.sender, balance: 0});\\n    emit SubscriptionCreated(s_currentSubId, msg.sender);\\n    return s_currentSubId;\\n  }\\n\\n  function getSubscription(uint64 _subId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    )\\n  {\\n    if (s_subscriptions[_subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    return (s_subscriptions[_subId].balance, 0, s_subscriptions[_subId].owner, new address[](0));\\n  }\\n\\n  function cancelSubscription(uint64 _subId, address _to) external override onlySubOwner(_subId) {\\n    emit SubscriptionCanceled(_subId, _to, s_subscriptions[_subId].balance);\\n    delete (s_subscriptions[_subId]);\\n  }\\n\\n  modifier onlySubOwner(uint64 _subId) {\\n    address owner = s_subscriptions[_subId].owner;\\n    if (owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    if (msg.sender != owner) {\\n      revert MustBeSubOwner(owner);\\n    }\\n    _;\\n  }\\n\\n  function getRequestConfig()\\n    external\\n    pure\\n    override\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    )\\n  {\\n    return (3, 2000000, new bytes32[](0));\\n  }\\n\\n  function addConsumer(uint64 _subId, address _consumer) external pure override {\\n    revert(\\\"not implemented\\\");\\n  }\\n\\n  function removeConsumer(uint64 _subId, address _consumer) external pure override {\\n    revert(\\\"not implemented\\\");\\n  }\\n\\n  function requestSubscriptionOwnerTransfer(uint64 _subId, address _newOwner) external pure override {\\n    revert(\\\"not implemented\\\");\\n  }\\n\\n  function acceptSubscriptionOwnerTransfer(uint64 _subId) external pure override {\\n    revert(\\\"not implemented\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/VRFCoordinatorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../interfaces/BlockhashStoreInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/ERC677ReceiverInterface.sol\\\";\\nimport \\\"./VRF.sol\\\";\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"./VRFConsumerBaseV2.sol\\\";\\n\\ncontract VRFCoordinatorV2 is\\n  VRF,\\n  ConfirmedOwner,\\n  TypeAndVersionInterface,\\n  VRFCoordinatorV2Interface,\\n  ERC677ReceiverInterface\\n{\\n  LinkTokenInterface public immutable LINK;\\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\\n  BlockhashStoreInterface public immutable BLOCKHASH_STORE;\\n\\n  // We need to maintain a list of consuming addresses.\\n  // This bound ensures we are able to loop over them as needed.\\n  // Should a user require more consumers, they can use multiple subscriptions.\\n  uint16 public constant MAX_CONSUMERS = 100;\\n  error TooManyConsumers();\\n  error InsufficientBalance();\\n  error InvalidConsumer(uint64 subId, address consumer);\\n  error InvalidSubscription();\\n  error OnlyCallableFromLink();\\n  error InvalidCalldata();\\n  error MustBeSubOwner(address owner);\\n  error PendingRequestExists();\\n  error MustBeRequestedOwner(address proposedOwner);\\n  error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\\n  event FundsRecovered(address to, uint256 amount);\\n  // We use the subscription struct (1 word)\\n  // at fulfillment time.\\n  struct Subscription {\\n    // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)\\n    uint96 balance; // Common link balance used for all consumer requests.\\n    uint64 reqCount; // For fee tiers\\n  }\\n  // We use the config for the mgmt APIs\\n  struct SubscriptionConfig {\\n    address owner; // Owner can fund/withdraw/cancel the sub.\\n    address requestedOwner; // For safely transferring sub ownership.\\n    // Maintains the list of keys in s_consumers.\\n    // We do this for 2 reasons:\\n    // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\\n    // 2. To be able to return the list of all consumers in getSubscription.\\n    // Note that we need the s_consumers map to be able to directly check if a\\n    // consumer is valid without reading all the consumers from storage.\\n    address[] consumers;\\n  }\\n  // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.\\n  mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subId */ /* nonce */\\n    private s_consumers;\\n  mapping(uint64 => SubscriptionConfig) /* subId */ /* subscriptionConfig */\\n    private s_subscriptionConfigs;\\n  mapping(uint64 => Subscription) /* subId */ /* subscription */\\n    private s_subscriptions;\\n  // We make the sub count public so that its possible to\\n  // get all the current subscriptions via getSubscription.\\n  uint64 private s_currentSubId;\\n  // s_totalBalance tracks the total link sent to/from\\n  // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\\n  // A discrepancy with this contract's link balance indicates someone\\n  // sent tokens using transfer and so we may need to use recoverFunds.\\n  uint96 private s_totalBalance;\\n  event SubscriptionCreated(uint64 indexed subId, address owner);\\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\\n  event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\\n  event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\\n  event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\\n  event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\\n\\n  // Set this maximum to 200 to give us a 56 block window to fulfill\\n  // the request before requiring the block hash feeder.\\n  uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\\n  uint32 public constant MAX_NUM_WORDS = 500;\\n  // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\\n  // and some arithmetic operations.\\n  uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\\n  error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\\n  error GasLimitTooBig(uint32 have, uint32 want);\\n  error NumWordsTooBig(uint32 have, uint32 want);\\n  error ProvingKeyAlreadyRegistered(bytes32 keyHash);\\n  error NoSuchProvingKey(bytes32 keyHash);\\n  error InvalidLinkWeiPrice(int256 linkWei);\\n  error InsufficientGasForConsumer(uint256 have, uint256 want);\\n  error NoCorrespondingRequest();\\n  error IncorrectCommitment();\\n  error BlockhashNotInStore(uint256 blockNum);\\n  error PaymentTooLarge();\\n  error Reentrant();\\n  struct RequestCommitment {\\n    uint64 blockNum;\\n    uint64 subId;\\n    uint32 callbackGasLimit;\\n    uint32 numWords;\\n    address sender;\\n  }\\n  mapping(bytes32 => address) /* keyHash */ /* oracle */\\n    private s_provingKeys;\\n  bytes32[] private s_provingKeyHashes;\\n  mapping(address => uint96) /* oracle */ /* LINK balance */\\n    private s_withdrawableTokens;\\n  mapping(uint256 => bytes32) /* requestID */ /* commitment */\\n    private s_requestCommitments;\\n  event ProvingKeyRegistered(bytes32 keyHash, address indexed oracle);\\n  event ProvingKeyDeregistered(bytes32 keyHash, address indexed oracle);\\n  event RandomWordsRequested(\\n    bytes32 indexed keyHash,\\n    uint256 requestId,\\n    uint256 preSeed,\\n    uint64 indexed subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords,\\n    address indexed sender\\n  );\\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\\n\\n  struct Config {\\n    uint16 minimumRequestConfirmations;\\n    uint32 maxGasLimit;\\n    // Re-entrancy protection.\\n    bool reentrancyLock;\\n    // stalenessSeconds is how long before we consider the feed price to be stale\\n    // and fallback to fallbackWeiPerUnitLink.\\n    uint32 stalenessSeconds;\\n    // Gas to cover oracle payment after we calculate the payment.\\n    // We make it configurable in case those operations are repriced.\\n    uint32 gasAfterPaymentCalculation;\\n  }\\n  int256 private s_fallbackWeiPerUnitLink;\\n  Config private s_config;\\n  FeeConfig private s_feeConfig;\\n  struct FeeConfig {\\n    // Flat fee charged per fulfillment in millionths of link\\n    // So fee range is [0, 2^32/10^6].\\n    uint32 fulfillmentFlatFeeLinkPPMTier1;\\n    uint32 fulfillmentFlatFeeLinkPPMTier2;\\n    uint32 fulfillmentFlatFeeLinkPPMTier3;\\n    uint32 fulfillmentFlatFeeLinkPPMTier4;\\n    uint32 fulfillmentFlatFeeLinkPPMTier5;\\n    uint24 reqsForTier2;\\n    uint24 reqsForTier3;\\n    uint24 reqsForTier4;\\n    uint24 reqsForTier5;\\n  }\\n  event ConfigSet(\\n    uint16 minimumRequestConfirmations,\\n    uint32 maxGasLimit,\\n    uint32 stalenessSeconds,\\n    uint32 gasAfterPaymentCalculation,\\n    int256 fallbackWeiPerUnitLink,\\n    FeeConfig feeConfig\\n  );\\n\\n  constructor(\\n    address link,\\n    address blockhashStore,\\n    address linkEthFeed\\n  ) ConfirmedOwner(msg.sender) {\\n    LINK = LinkTokenInterface(link);\\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\\n    BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\\n  }\\n\\n  /**\\n   * @notice Registers a proving key to an oracle.\\n   * @param oracle address of the oracle\\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\\n   */\\n  function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\\n    bytes32 kh = hashOfKey(publicProvingKey);\\n    if (s_provingKeys[kh] != address(0)) {\\n      revert ProvingKeyAlreadyRegistered(kh);\\n    }\\n    s_provingKeys[kh] = oracle;\\n    s_provingKeyHashes.push(kh);\\n    emit ProvingKeyRegistered(kh, oracle);\\n  }\\n\\n  /**\\n   * @notice Deregisters a proving key to an oracle.\\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\\n   */\\n  function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\\n    bytes32 kh = hashOfKey(publicProvingKey);\\n    address oracle = s_provingKeys[kh];\\n    if (oracle == address(0)) {\\n      revert NoSuchProvingKey(kh);\\n    }\\n    delete s_provingKeys[kh];\\n    for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\\n      if (s_provingKeyHashes[i] == kh) {\\n        bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\\n        // Copy last element and overwrite kh to be deleted with it\\n        s_provingKeyHashes[i] = last;\\n        s_provingKeyHashes.pop();\\n      }\\n    }\\n    emit ProvingKeyDeregistered(kh, oracle);\\n  }\\n\\n  /**\\n   * @notice Returns the proving key hash key associated with this public key\\n   * @param publicKey the key to return the hash of\\n   */\\n  function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\\n    return keccak256(abi.encode(publicKey));\\n  }\\n\\n  /**\\n   * @notice Sets the configuration of the vrfv2 coordinator\\n   * @param minimumRequestConfirmations global min for request confirmations\\n   * @param maxGasLimit global max for request gas limit\\n   * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price\\n   * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\\n   * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed\\n   * @param feeConfig fee tier configuration\\n   */\\n  function setConfig(\\n    uint16 minimumRequestConfirmations,\\n    uint32 maxGasLimit,\\n    uint32 stalenessSeconds,\\n    uint32 gasAfterPaymentCalculation,\\n    int256 fallbackWeiPerUnitLink,\\n    FeeConfig memory feeConfig\\n  ) external onlyOwner {\\n    if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\\n      revert InvalidRequestConfirmations(\\n        minimumRequestConfirmations,\\n        minimumRequestConfirmations,\\n        MAX_REQUEST_CONFIRMATIONS\\n      );\\n    }\\n    if (fallbackWeiPerUnitLink <= 0) {\\n      revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\\n    }\\n    s_config = Config({\\n      minimumRequestConfirmations: minimumRequestConfirmations,\\n      maxGasLimit: maxGasLimit,\\n      stalenessSeconds: stalenessSeconds,\\n      gasAfterPaymentCalculation: gasAfterPaymentCalculation,\\n      reentrancyLock: false\\n    });\\n    s_feeConfig = feeConfig;\\n    s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\\n    emit ConfigSet(\\n      minimumRequestConfirmations,\\n      maxGasLimit,\\n      stalenessSeconds,\\n      gasAfterPaymentCalculation,\\n      fallbackWeiPerUnitLink,\\n      s_feeConfig\\n    );\\n  }\\n\\n  function getConfig()\\n    external\\n    view\\n    returns (\\n      uint16 minimumRequestConfirmations,\\n      uint32 maxGasLimit,\\n      uint32 stalenessSeconds,\\n      uint32 gasAfterPaymentCalculation\\n    )\\n  {\\n    return (\\n      s_config.minimumRequestConfirmations,\\n      s_config.maxGasLimit,\\n      s_config.stalenessSeconds,\\n      s_config.gasAfterPaymentCalculation\\n    );\\n  }\\n\\n  function getFeeConfig()\\n    external\\n    view\\n    returns (\\n      uint32 fulfillmentFlatFeeLinkPPMTier1,\\n      uint32 fulfillmentFlatFeeLinkPPMTier2,\\n      uint32 fulfillmentFlatFeeLinkPPMTier3,\\n      uint32 fulfillmentFlatFeeLinkPPMTier4,\\n      uint32 fulfillmentFlatFeeLinkPPMTier5,\\n      uint24 reqsForTier2,\\n      uint24 reqsForTier3,\\n      uint24 reqsForTier4,\\n      uint24 reqsForTier5\\n    )\\n  {\\n    return (\\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier1,\\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier2,\\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier3,\\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier4,\\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier5,\\n      s_feeConfig.reqsForTier2,\\n      s_feeConfig.reqsForTier3,\\n      s_feeConfig.reqsForTier4,\\n      s_feeConfig.reqsForTier5\\n    );\\n  }\\n\\n  function getTotalBalance() external view returns (uint256) {\\n    return s_totalBalance;\\n  }\\n\\n  function getFallbackWeiPerUnitLink() external view returns (int256) {\\n    return s_fallbackWeiPerUnitLink;\\n  }\\n\\n  /**\\n   * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\\n   * @param subId subscription id\\n   * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\\n   */\\n  function ownerCancelSubscription(uint64 subId) external onlyOwner {\\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\\n  }\\n\\n  /**\\n   * @notice Recover link sent with transfer instead of transferAndCall.\\n   * @param to address to send link to\\n   */\\n  function recoverFunds(address to) external onlyOwner {\\n    uint256 externalBalance = LINK.balanceOf(address(this));\\n    uint256 internalBalance = uint256(s_totalBalance);\\n    if (internalBalance > externalBalance) {\\n      revert BalanceInvariantViolated(internalBalance, externalBalance);\\n    }\\n    if (internalBalance < externalBalance) {\\n      uint256 amount = externalBalance - internalBalance;\\n      LINK.transfer(to, amount);\\n      emit FundsRecovered(to, amount);\\n    }\\n    // If the balances are equal, nothing to be done.\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    override\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    )\\n  {\\n    return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 requestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external override nonReentrant returns (uint256) {\\n    // Input validation using the subscription storage.\\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    // Its important to ensure that the consumer is in fact who they say they\\n    // are, otherwise they could use someone else's subscription balance.\\n    // A nonce of 0 indicates consumer is not allocated to the sub.\\n    uint64 currentNonce = s_consumers[msg.sender][subId];\\n    if (currentNonce == 0) {\\n      revert InvalidConsumer(subId, msg.sender);\\n    }\\n    // Input validation using the config storage word.\\n    if (\\n      requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\\n    ) {\\n      revert InvalidRequestConfirmations(\\n        requestConfirmations,\\n        s_config.minimumRequestConfirmations,\\n        MAX_REQUEST_CONFIRMATIONS\\n      );\\n    }\\n    // No lower bound on the requested gas limit. A user could request 0\\n    // and they would simply be billed for the proof verification and wouldn't be\\n    // able to do anything with the random value.\\n    if (callbackGasLimit > s_config.maxGasLimit) {\\n      revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\\n    }\\n    if (numWords > MAX_NUM_WORDS) {\\n      revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\\n    }\\n    // Note we do not check whether the keyHash is valid to save gas.\\n    // The consequence for users is that they can send requests\\n    // for invalid keyHashes which will simply not be fulfilled.\\n    uint64 nonce = currentNonce + 1;\\n    (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\\n\\n    s_requestCommitments[requestId] = keccak256(\\n      abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\\n    );\\n    emit RandomWordsRequested(\\n      keyHash,\\n      requestId,\\n      preSeed,\\n      subId,\\n      requestConfirmations,\\n      callbackGasLimit,\\n      numWords,\\n      msg.sender\\n    );\\n    s_consumers[msg.sender][subId] = nonce;\\n\\n    return requestId;\\n  }\\n\\n  /**\\n   * @notice Get request commitment\\n   * @param requestId id of request\\n   * @dev used to determine if a request is fulfilled or not\\n   */\\n  function getCommitment(uint256 requestId) external view returns (bytes32) {\\n    return s_requestCommitments[requestId];\\n  }\\n\\n  function computeRequestId(\\n    bytes32 keyHash,\\n    address sender,\\n    uint64 subId,\\n    uint64 nonce\\n  ) private pure returns (uint256, uint256) {\\n    uint256 preSeed = uint256(keccak256(abi.encode(keyHash, sender, subId, nonce)));\\n    return (uint256(keccak256(abi.encode(keyHash, preSeed))), preSeed);\\n  }\\n\\n  /**\\n   * @dev calls target address with exactly gasAmount gas and data as calldata\\n   * or reverts if at least gasAmount gas is not available.\\n   */\\n  function callWithExactGas(\\n    uint256 gasAmount,\\n    address target,\\n    bytes memory data\\n  ) private returns (bool success) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      let g := gas()\\n      // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\\n      // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\\n      // as we do not want to provide them with less, however that check itself costs\\n      // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\\n      // to revert if gasAmount >  63//64*gas available.\\n      if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\\n        revert(0, 0)\\n      }\\n      g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\\n      // if g - g//64 <= gasAmount, revert\\n      // (we subtract g//64 because of EIP-150)\\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n        revert(0, 0)\\n      }\\n      // solidity calls check that a contract actually exists at the destination, so we do the same\\n      if iszero(extcodesize(target)) {\\n        revert(0, 0)\\n      }\\n      // call and return whether we succeeded. ignore return data\\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n    }\\n    return success;\\n  }\\n\\n  function getRandomnessFromProof(Proof memory proof, RequestCommitment memory rc)\\n    private\\n    view\\n    returns (\\n      bytes32 keyHash,\\n      uint256 requestId,\\n      uint256 randomness\\n    )\\n  {\\n    keyHash = hashOfKey(proof.pk);\\n    // Only registered proving keys are permitted.\\n    address oracle = s_provingKeys[keyHash];\\n    if (oracle == address(0)) {\\n      revert NoSuchProvingKey(keyHash);\\n    }\\n    requestId = uint256(keccak256(abi.encode(keyHash, proof.seed)));\\n    bytes32 commitment = s_requestCommitments[requestId];\\n    if (commitment == 0) {\\n      revert NoCorrespondingRequest();\\n    }\\n    if (\\n      commitment != keccak256(abi.encode(requestId, rc.blockNum, rc.subId, rc.callbackGasLimit, rc.numWords, rc.sender))\\n    ) {\\n      revert IncorrectCommitment();\\n    }\\n\\n    bytes32 blockHash = blockhash(rc.blockNum);\\n    if (blockHash == bytes32(0)) {\\n      blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum);\\n      if (blockHash == bytes32(0)) {\\n        revert BlockhashNotInStore(rc.blockNum);\\n      }\\n    }\\n\\n    // The seed actually used by the VRF machinery, mixing in the blockhash\\n    uint256 actualSeed = uint256(keccak256(abi.encodePacked(proof.seed, blockHash)));\\n    randomness = VRF.randomValueFromVRFProof(proof, actualSeed); // Reverts on failure\\n  }\\n\\n  /*\\n   * @notice Compute fee based on the request count\\n   * @param reqCount number of requests\\n   * @return feePPM fee in LINK PPM\\n   */\\n  function getFeeTier(uint64 reqCount) public view returns (uint32) {\\n    FeeConfig memory fc = s_feeConfig;\\n    if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\\n      return fc.fulfillmentFlatFeeLinkPPMTier1;\\n    }\\n    if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\\n      return fc.fulfillmentFlatFeeLinkPPMTier2;\\n    }\\n    if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\\n      return fc.fulfillmentFlatFeeLinkPPMTier3;\\n    }\\n    if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\\n      return fc.fulfillmentFlatFeeLinkPPMTier4;\\n    }\\n    return fc.fulfillmentFlatFeeLinkPPMTier5;\\n  }\\n\\n  /*\\n   * @notice Fulfill a randomness request\\n   * @param proof contains the proof and randomness\\n   * @param rc request commitment pre-image, committed to at request time\\n   * @return payment amount billed to the subscription\\n   * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\\n   */\\n  function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external nonReentrant returns (uint96) {\\n    uint256 startGas = gasleft();\\n    (bytes32 keyHash, uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\\n\\n    uint256[] memory randomWords = new uint256[](rc.numWords);\\n    for (uint256 i = 0; i < rc.numWords; i++) {\\n      randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\\n    }\\n\\n    delete s_requestCommitments[requestId];\\n    VRFConsumerBaseV2 v;\\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, requestId, randomWords);\\n    // Call with explicitly the amount of callback gas requested\\n    // Important to not let them exhaust the gas budget and avoid oracle payment.\\n    // Do not allow any non-view/non-pure coordinator functions to be called\\n    // during the consumers callback code via reentrancyLock.\\n    // Note that callWithExactGas will revert if we do not have sufficient gas\\n    // to give the callee their requested amount.\\n    s_config.reentrancyLock = true;\\n    bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\\n    s_config.reentrancyLock = false;\\n\\n    // Increment the req count for fee tier selection.\\n    uint64 reqCount = s_subscriptions[rc.subId].reqCount;\\n    s_subscriptions[rc.subId].reqCount += 1;\\n\\n    // We want to charge users exactly for how much gas they use in their callback.\\n    // The gasAfterPaymentCalculation is meant to cover these additional operations where we\\n    // decrement the subscription balance and increment the oracles withdrawable balance.\\n    // We also add the flat link fee to the payment amount.\\n    // Its specified in millionths of link, if s_config.fulfillmentFlatFeeLinkPPM = 1\\n    // 1 link / 1e6 = 1e18 juels / 1e6 = 1e12 juels.\\n    uint96 payment = calculatePaymentAmount(\\n      startGas,\\n      s_config.gasAfterPaymentCalculation,\\n      getFeeTier(reqCount),\\n      tx.gasprice\\n    );\\n    if (s_subscriptions[rc.subId].balance < payment) {\\n      revert InsufficientBalance();\\n    }\\n    s_subscriptions[rc.subId].balance -= payment;\\n    s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\\n    // Include payment in the event for tracking costs.\\n    emit RandomWordsFulfilled(requestId, randomness, payment, success);\\n    return payment;\\n  }\\n\\n  // Get the amount of gas used for fulfillment\\n  function calculatePaymentAmount(\\n    uint256 startGas,\\n    uint256 gasAfterPaymentCalculation,\\n    uint32 fulfillmentFlatFeeLinkPPM,\\n    uint256 weiPerUnitGas\\n  ) internal view returns (uint96) {\\n    int256 weiPerUnitLink;\\n    weiPerUnitLink = getFeedData();\\n    if (weiPerUnitLink <= 0) {\\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\\n    }\\n    // (1e18 juels/link) (wei/gas * gas) / (wei/link) = juels\\n    uint256 paymentNoFee = (1e18 * weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft())) /\\n      uint256(weiPerUnitLink);\\n    uint256 fee = 1e12 * uint256(fulfillmentFlatFeeLinkPPM);\\n    if (paymentNoFee > (1e27 - fee)) {\\n      revert PaymentTooLarge(); // Payment + fee cannot be more than all of the link in existence.\\n    }\\n    return uint96(paymentNoFee + fee);\\n  }\\n\\n  function getFeedData() private view returns (int256) {\\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\\n    bool staleFallback = stalenessSeconds > 0;\\n    uint256 timestamp;\\n    int256 weiPerUnitLink;\\n    (, weiPerUnitLink, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\\n    // solhint-disable-next-line not-rely-on-time\\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\\n      weiPerUnitLink = s_fallbackWeiPerUnitLink;\\n    }\\n    return weiPerUnitLink;\\n  }\\n\\n  /*\\n   * @notice Oracle withdraw LINK earned through fulfilling requests\\n   * @param recipient where to send the funds\\n   * @param amount amount to withdraw\\n   */\\n  function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\\n    if (s_withdrawableTokens[msg.sender] < amount) {\\n      revert InsufficientBalance();\\n    }\\n    s_withdrawableTokens[msg.sender] -= amount;\\n    s_totalBalance -= amount;\\n    if (!LINK.transfer(recipient, amount)) {\\n      revert InsufficientBalance();\\n    }\\n  }\\n\\n  function onTokenTransfer(\\n    address, /* sender */\\n    uint256 amount,\\n    bytes calldata data\\n  ) external override nonReentrant {\\n    if (msg.sender != address(LINK)) {\\n      revert OnlyCallableFromLink();\\n    }\\n    if (data.length != 32) {\\n      revert InvalidCalldata();\\n    }\\n    uint64 subId = abi.decode(data, (uint64));\\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    // We do not check that the msg.sender is the subscription owner,\\n    // anyone can fund a subscription.\\n    uint256 oldBalance = s_subscriptions[subId].balance;\\n    s_subscriptions[subId].balance += uint96(amount);\\n    s_totalBalance += uint96(amount);\\n    emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\\n  }\\n\\n  function getCurrentSubId() external view returns (uint64) {\\n    return s_currentSubId;\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    )\\n  {\\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    return (\\n      s_subscriptions[subId].balance,\\n      s_subscriptions[subId].reqCount,\\n      s_subscriptionConfigs[subId].owner,\\n      s_subscriptionConfigs[subId].consumers\\n    );\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function createSubscription() external override nonReentrant returns (uint64) {\\n    s_currentSubId++;\\n    uint64 currentSubId = s_currentSubId;\\n    address[] memory consumers = new address[](0);\\n    s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\\n    s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\\n      owner: msg.sender,\\n      requestedOwner: address(0),\\n      consumers: consumers\\n    });\\n\\n    emit SubscriptionCreated(currentSubId, msg.sender);\\n    return currentSubId;\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\\n    external\\n    override\\n    onlySubOwner(subId)\\n    nonReentrant\\n  {\\n    // Proposing to address(0) would never be claimable so don't need to check.\\n    if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\\n      s_subscriptionConfigs[subId].requestedOwner = newOwner;\\n      emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\\n    }\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external override nonReentrant {\\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\\n      revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\\n    }\\n    address oldOwner = s_subscriptionConfigs[subId].owner;\\n    s_subscriptionConfigs[subId].owner = msg.sender;\\n    s_subscriptionConfigs[subId].requestedOwner = address(0);\\n    emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\\n    if (s_consumers[consumer][subId] == 0) {\\n      revert InvalidConsumer(subId, consumer);\\n    }\\n    // Note bounded by MAX_CONSUMERS\\n    address[] memory consumers = s_subscriptionConfigs[subId].consumers;\\n    uint256 lastConsumerIndex = consumers.length - 1;\\n    for (uint256 i = 0; i < consumers.length; i++) {\\n      if (consumers[i] == consumer) {\\n        address last = consumers[lastConsumerIndex];\\n        // Storage write to preserve last element\\n        s_subscriptionConfigs[subId].consumers[i] = last;\\n        // Storage remove last element\\n        s_subscriptionConfigs[subId].consumers.pop();\\n        break;\\n      }\\n    }\\n    delete s_consumers[consumer][subId];\\n    emit SubscriptionConsumerRemoved(subId, consumer);\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\\n    // Already maxed, cannot add any more consumers.\\n    if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\\n      revert TooManyConsumers();\\n    }\\n    if (s_consumers[consumer][subId] != 0) {\\n      // Idempotence - do nothing if already added.\\n      // Ensures uniqueness in s_subscriptions[subId].consumers.\\n      return;\\n    }\\n    // Initialize the nonce to 1, indicating the consumer is allocated.\\n    s_consumers[consumer][subId] = 1;\\n    s_subscriptionConfigs[subId].consumers.push(consumer);\\n\\n    emit SubscriptionConsumerAdded(subId, consumer);\\n  }\\n\\n  /**\\n   * @inheritdoc VRFCoordinatorV2Interface\\n   */\\n  function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) nonReentrant {\\n    if (pendingRequestExists(subId)) {\\n      revert PendingRequestExists();\\n    }\\n    cancelSubscriptionHelper(subId, to);\\n  }\\n\\n  function cancelSubscriptionHelper(uint64 subId, address to) private nonReentrant {\\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\\n    Subscription memory sub = s_subscriptions[subId];\\n    uint96 balance = sub.balance;\\n    // Note bounded by MAX_CONSUMERS;\\n    // If no consumers, does nothing.\\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\\n      delete s_consumers[subConfig.consumers[i]][subId];\\n    }\\n    delete s_subscriptionConfigs[subId];\\n    delete s_subscriptions[subId];\\n    s_totalBalance -= balance;\\n    if (!LINK.transfer(to, uint256(balance))) {\\n      revert InsufficientBalance();\\n    }\\n    emit SubscriptionCanceled(subId, to, balance);\\n  }\\n\\n  /*\\n   * @noticeCheck to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId where to send the funds\\n   * @return exits true if outstanding requests\\n   * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).\\n   * @dev Used to disable subscription canceling while outstanding request are present.\\n   */\\n  function pendingRequestExists(uint64 subId) public view returns (bool) {\\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\\n      for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\\n        (uint256 reqId, ) = computeRequestId(\\n          s_provingKeyHashes[j],\\n          subConfig.consumers[i],\\n          subId,\\n          s_consumers[subConfig.consumers[i]][subId]\\n        );\\n        if (s_requestCommitments[reqId] != 0) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  modifier onlySubOwner(uint64 subId) {\\n    address owner = s_subscriptionConfigs[subId].owner;\\n    if (owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    if (msg.sender != owner) {\\n      revert MustBeSubOwner(owner);\\n    }\\n    _;\\n  }\\n\\n  modifier nonReentrant() {\\n    if (s_config.reentrancyLock) {\\n      revert Reentrant();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"VRFCoordinatorV2 1.0.0\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/BlockhashStoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface BlockhashStoreInterface {\\n  function getBlockhash(uint256 number) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/ERC677ReceiverInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface ERC677ReceiverInterface {\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/VRF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\\n\\n  * @dev Bibliographic references:\\n\\n  * @dev Goldberg, et al., \\\"Verifiable Random Functions (VRFs)\\\", Internet Draft\\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\\n\\n  * @dev Papadopoulos, et al., \\\"Making NSEC5 Practical for DNSSEC\\\", Cryptology\\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\\n  * ****************************************************************************\\n  * @dev USAGE\\n\\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\\n  * ****************************************************************************\\n  * @dev PURPOSE\\n\\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\\n  * @dev Reggie, he gives back a value which is computed completely\\n  * @dev deterministically from the seed and the secret key.\\n\\n  * @dev Reggie provides a proof by which Vera can verify that the output was\\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\\n  * @dev the output is computationally indistinguishable to her from a uniform\\n  * @dev random sample from the output space.\\n\\n  * @dev The purpose of this contract is to perform that verification.\\n  * ****************************************************************************\\n  * @dev DESIGN NOTES\\n\\n  * @dev The VRF algorithm verified here satisfies the full unqiqueness, full\\n  * @dev collision resistance, and full pseudorandomness security properties.\\n  * @dev See \\\"SECURITY PROPERTIES\\\" below, and\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\\n\\n  * @dev An elliptic curve point is generally represented in the solidity code\\n  * @dev as a uint256[2], corresponding to its affine coordinates in\\n  * @dev GF(FIELD_SIZE).\\n\\n  * @dev For the sake of efficiency, this implementation deviates from the spec\\n  * @dev in some minor ways:\\n\\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\\n\\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\\n\\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\\n  * @dev   nonce updated until a valid x-ordinate is found.\\n\\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\\n  * @dev   in the hash message, as recommended in step 5.B of the draft\\n  * @dev   standard. They are unnecessary here because no variation in the\\n  * @dev   cipher suite is allowed.\\n\\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\\n  * @dev   points, not the compressed points as recommended in step 3.\\n\\n  * @dev - In the calculation of the challenge value \\\"c\\\", the \\\"u\\\" value (i.e.\\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\\n  * @dev   generator point, see steps 5 and 7 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\\n  * @dev   keccak hash of the original u. This is because we only verify the\\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\\n  * ****************************************************************************\\n  * @dev   SECURITY PROPERTIES\\n\\n  * @dev Here are the security properties for this VRF:\\n\\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\\n  * @dev   the sense that the proof will pass verifyVRFProof.\\n\\n  * @dev Full collision resistance: It's cryptographically infeasible to find\\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\\n\\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\\n  * @dev   derived from a given seed, the outputs are computationally\\n  * @dev   indistinguishable from randomness.\\n\\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\\n  * @dev for these properties.\\n\\n  * @dev For secp256k1, the key validation described in section\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\\n  * @dev representation of the public key used here (affine x- and y-ordinates\\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\\n  * @dev the point at infinity.\\n  * ****************************************************************************\\n  * @dev OTHER SECURITY CONSIDERATIONS\\n  *\\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\\n  * @dev However, under the Random Oracle Model the probability of choosing a\\n  * @dev point which forces n extra rounds in hashToCurve is 2\u207b\u207f. The base cost\\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\\n  * @dev try, in expectation, about 2\u00b9\u00b2\u2078 seeds, which is infeasible for any\\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\\n\\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\\n  * @dev this means it is infeasible for an adversary to prevent correct\\n  * @dev operation of this contract by choosing an adverse seed.\\n\\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\\n  * @dev hashToCurve.)\\n\\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\\n  * @dev See notes in hashToCurve docstring.\\n*/\\ncontract VRF {\\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\\n  // Number of points in Secp256k1\\n  uint256 private constant GROUP_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n  // Prime characteristic of the galois field over which Secp256k1 is defined\\n  uint256 private constant FIELD_SIZE =\\n    // solium-disable-next-line indentation\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n  uint256 private constant WORD_LENGTH_BYTES = 0x20;\\n\\n  // (base^exponent) % FIELD_SIZE\\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\\n  function bigModExp(uint256 base, uint256 exponent) internal view returns (uint256 exponentiation) {\\n    uint256 callResult;\\n    uint256[6] memory bigModExpContractInputs;\\n    bigModExpContractInputs[0] = WORD_LENGTH_BYTES; // Length of base\\n    bigModExpContractInputs[1] = WORD_LENGTH_BYTES; // Length of exponent\\n    bigModExpContractInputs[2] = WORD_LENGTH_BYTES; // Length of modulus\\n    bigModExpContractInputs[3] = base;\\n    bigModExpContractInputs[4] = exponent;\\n    bigModExpContractInputs[5] = FIELD_SIZE;\\n    uint256[1] memory output;\\n    assembly {\\n      // solhint-disable-line no-inline-assembly\\n      callResult := staticcall(\\n        not(0), // Gas cost: no limit\\n        0x05, // Bigmodexp contract address\\n        bigModExpContractInputs,\\n        0xc0, // Length of input segment: 6*0x20-bytes\\n        output,\\n        0x20 // Length of output segment\\n      )\\n    }\\n    if (callResult == 0) {\\n      revert(\\\"bigModExp failure!\\\");\\n    }\\n    return output[0];\\n  }\\n\\n  // Let q=FIELD_SIZE. q % 4 = 3, \u2234 x\u2261r^2 mod q \u21d2 x^SQRT_POWER\u2261\u00b1r mod q.  See\\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\\n  uint256 private constant SQRT_POWER = (FIELD_SIZE + 1) >> 2;\\n\\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\\n  function squareRoot(uint256 x) internal view returns (uint256) {\\n    return bigModExp(x, SQRT_POWER);\\n  }\\n\\n  // The value of y^2 given that (x,y) is on secp256k1.\\n  function ySquared(uint256 x) internal pure returns (uint256) {\\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\\n    return addmod(xCubed, 7, FIELD_SIZE);\\n  }\\n\\n  // True iff p is on secp256k1\\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\\n    // Section 2.3.6. in https://www.secg.org/sec1-v2.pdf\\n    // requires each ordinate to be in [0, ..., FIELD_SIZE-1]\\n    require(p[0] < FIELD_SIZE, \\\"invalid x-ordinate\\\");\\n    require(p[1] < FIELD_SIZE, \\\"invalid y-ordinate\\\");\\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\\n  }\\n\\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\\n    x_ = uint256(keccak256(b));\\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\\n    // string_to_point in the IETF draft\\n    while (x_ >= FIELD_SIZE) {\\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\\n    }\\n  }\\n\\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\\n  // is always even, due to\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  // step 5.C, which references arbitrary_string_to_point, defined in\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\\n  // returning the point with given x ordinate, and even y ordinate.\\n  function newCandidateSecp256k1Point(bytes memory b) internal view returns (uint256[2] memory p) {\\n    unchecked {\\n      p[0] = fieldHash(b);\\n      p[1] = squareRoot(ySquared(p[0]));\\n      if (p[1] % 2 == 1) {\\n        // Note that 0 <= p[1] < FIELD_SIZE\\n        // so this cannot wrap, we use unchecked to save gas.\\n        p[1] = FIELD_SIZE - p[1];\\n      }\\n    }\\n  }\\n\\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\\n  // vrf.go/hashToCurveHashPrefix\\n  uint256 internal constant HASH_TO_CURVE_HASH_PREFIX = 1;\\n\\n  // Cryptographic hash function onto the curve.\\n  //\\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\\n  // DESIGN NOTES above for slight differences.)\\n  //\\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\\n  // \\\"Construction of Rational Points on Elliptic Curves over Finite Fields\\\"\\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\\n  // and suggested by\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\\n  //\\n  // This would greatly simplify the analysis in \\\"OTHER SECURITY CONSIDERATIONS\\\"\\n  // https://www.pivotaltracker.com/story/show/171120900\\n  function hashToCurve(uint256[2] memory pk, uint256 input) internal view returns (uint256[2] memory rv) {\\n    rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX, pk, input));\\n    while (!isOnCurve(rv)) {\\n      rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\\n    }\\n  }\\n\\n  /** *********************************************************************\\n   * @notice Check that product==scalar*multiplicand\\n   *\\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\\n   *\\n   * @param multiplicand: secp256k1 point\\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\\n   * @param product: secp256k1 expected to be multiplier * multiplicand\\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\\n   */\\n  function ecmulVerify(\\n    uint256[2] memory multiplicand,\\n    uint256 scalar,\\n    uint256[2] memory product\\n  ) internal pure returns (bool verifies) {\\n    require(scalar != 0, \\\"zero scalar\\\"); // Rules out an ecrecover failure case\\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\\n    // (x\u207b\u00b9 mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\\n    // Explicit conversion to address takes bottom 160 bits\\n    address expected = address(uint160(uint256(keccak256(abi.encodePacked(product)))));\\n    return (actual == expected);\\n  }\\n\\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P\u00b9(\ud835\udd3d\u2099)\\n  function projectiveSub(\\n    uint256 x1,\\n    uint256 z1,\\n    uint256 x2,\\n    uint256 z2\\n  ) internal pure returns (uint256 x3, uint256 z3) {\\n    unchecked {\\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\\n      // Note this cannot wrap since x2 is a point in [0, FIELD_SIZE-1]\\n      // we use unchecked to save gas.\\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n    }\\n  }\\n\\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P\u00b9(\ud835\udd3d\u2099)\\n  function projectiveMul(\\n    uint256 x1,\\n    uint256 z1,\\n    uint256 x2,\\n    uint256 z2\\n  ) internal pure returns (uint256 x3, uint256 z3) {\\n    (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n  }\\n\\n  /** **************************************************************************\\n        @notice Computes elliptic-curve sum, in projective co-ordinates\\n\\n        @dev Using projective coordinates avoids costly divisions\\n\\n        @dev To use this with p and q in affine coordinates, call\\n        @dev projectiveECAdd(px, py, qx, qy). This will return\\n        @dev the addition of (px, py, 1) and (qx, qy, 1), in the\\n        @dev secp256k1 group.\\n\\n        @dev This can be used to calculate the z which is the inverse to zInv\\n        @dev in isValidVRFOutput. But consider using a faster\\n        @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\\n\\n        @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\\n             coordinates of secp256k1 points. That is safe in this contract,\\n             because this method is only used by linearCombination, which checks\\n             points are on the curve via ecrecover.\\n        **************************************************************************\\n        @param px The first affine coordinate of the first summand\\n        @param py The second affine coordinate of the first summand\\n        @param qx The first affine coordinate of the second summand\\n        @param qy The second affine coordinate of the second summand\\n\\n        (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\\n        **************************************************************************\\n        Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\\n        on secp256k1, in P\u00b2(\ud835\udd3d\u2099)\\n        @return sx\\n        @return sy\\n        @return sz\\n    */\\n  function projectiveECAdd(\\n    uint256 px,\\n    uint256 py,\\n    uint256 qx,\\n    uint256 qy\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256 sx,\\n      uint256 sy,\\n      uint256 sz\\n    )\\n  {\\n    unchecked {\\n      // See \\\"Group law for E/K : y^2 = x^3 + ax + b\\\", in section 3.1.2, p. 80,\\n      // \\\"Guide to Elliptic Curve Cryptography\\\" by Hankerson, Menezes and Vanstone\\n      // We take the equations there for (sx,sy), and homogenize them to\\n      // projective coordinates. That way, no inverses are required, here, and we\\n      // only need the one inverse in affineECAdd.\\n\\n      // We only need the \\\"point addition\\\" equations from Hankerson et al. Can\\n      // skip the \\\"point doubling\\\" equations because p1 == p2 is cryptographically\\n      // impossible, and required not to be the case in linearCombination.\\n\\n      // Add extra \\\"projective coordinate\\\" to the two points\\n      (uint256 z1, uint256 z2) = (1, 1);\\n\\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\\n      // Cannot wrap since px and py are in [0, FIELD_SIZE-1]\\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\\n\\n      uint256 dx; // Accumulates denominator from sx calculation\\n      // sx=((qy-py)/(qx-px))^2-px-qx\\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\\n\\n      uint256 dy; // Accumulates denominator from sy calculation\\n      // sy=((qy-py)/(qx-px))(px-sx)-py\\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\\n\\n      if (dx != dy) {\\n        // Cross-multiply to put everything over a common denominator\\n        sx = mulmod(sx, dy, FIELD_SIZE);\\n        sy = mulmod(sy, dx, FIELD_SIZE);\\n        sz = mulmod(dx, dy, FIELD_SIZE);\\n      } else {\\n        // Already over a common denominator, use that for z ordinate\\n        sz = dx;\\n      }\\n    }\\n  }\\n\\n  // p1+p2, as affine points on secp256k1.\\n  //\\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\\n  // It is computed off-chain to save gas.\\n  //\\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\\n  // point doubling.\\n  function affineECAdd(\\n    uint256[2] memory p1,\\n    uint256[2] memory p2,\\n    uint256 invZ\\n  ) internal pure returns (uint256[2] memory) {\\n    uint256 x;\\n    uint256 y;\\n    uint256 z;\\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \\\"invZ must be inverse of z\\\");\\n    // Clear the z ordinate of the projective representation by dividing through\\n    // by it, to obtain the affine representation\\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\\n  }\\n\\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\\n  // cryptographically high probability.)\\n  function verifyLinearCombinationWithGenerator(\\n    uint256 c,\\n    uint256[2] memory p,\\n    uint256 s,\\n    address lcWitness\\n  ) internal pure returns (bool) {\\n    // Rule out ecrecover failure modes which return address 0.\\n    unchecked {\\n      require(lcWitness != address(0), \\\"bad witness\\\");\\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\\n      // Note this cannot wrap (X - Y % X), but we use unchecked to save\\n      // gas.\\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n      // The point corresponding to the address returned by\\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\\n      // (p[0]\u207b\u00b9 mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\\n      // See https://crypto.stackexchange.com/a/18106\\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\\n      return computed == lcWitness;\\n    }\\n  }\\n\\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\\n  // requires cp1Witness != sp2Witness (which is fine for this application,\\n  // since it is cryptographically impossible for them to be equal. In the\\n  // (cryptographically impossible) case that a prover accidentally derives\\n  // a proof with equal c*p1 and s*p2, they should retry with a different\\n  // proof nonce.) Assumes that all points are on secp256k1\\n  // (which is checked in verifyVRFProof below.)\\n  function linearCombination(\\n    uint256 c,\\n    uint256[2] memory p1,\\n    uint256[2] memory cp1Witness,\\n    uint256 s,\\n    uint256[2] memory p2,\\n    uint256[2] memory sp2Witness,\\n    uint256 zInv\\n  ) internal pure returns (uint256[2] memory) {\\n    unchecked {\\n      // Note we are relying on the wrap around here\\n      require((cp1Witness[0] % FIELD_SIZE) != (sp2Witness[0] % FIELD_SIZE), \\\"points in sum must be distinct\\\");\\n      require(ecmulVerify(p1, c, cp1Witness), \\\"First mul check failed\\\");\\n      require(ecmulVerify(p2, s, sp2Witness), \\\"Second mul check failed\\\");\\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\\n    }\\n  }\\n\\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\\n  uint256 internal constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\\n\\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  // The draft calls (in step 7, via the definition of string_to_int, in\\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\\n  // first hash without checking that it corresponds to a number less than the\\n  // group order, which will lead to a slight bias in the sample.\\n  //\\n  // TODO(alx): We could save a bit of gas by following the standard here and\\n  // using the compressed representation of the points, if we collated the y\\n  // parities into a single bytes32.\\n  // https://www.pivotaltracker.com/story/show/171120588\\n  function scalarFromCurvePoints(\\n    uint256[2] memory hash,\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    address uWitness,\\n    uint256[2] memory v\\n  ) internal pure returns (uint256 s) {\\n    return uint256(keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX, hash, pk, gamma, v, uWitness)));\\n  }\\n\\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\\n  // and seed. zInv must be the inverse of the third ordinate from\\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\\n  // section 5.3 of the IETF draft.\\n  //\\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\\n  // (which I could make a uint256 without using any extra space.) Would save\\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\\n  function verifyVRFProof(\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    uint256 c,\\n    uint256 s,\\n    uint256 seed,\\n    address uWitness,\\n    uint256[2] memory cGammaWitness,\\n    uint256[2] memory sHashWitness,\\n    uint256 zInv\\n  ) internal view {\\n    unchecked {\\n      require(isOnCurve(pk), \\\"public key is not on curve\\\");\\n      require(isOnCurve(gamma), \\\"gamma is not on curve\\\");\\n      require(isOnCurve(cGammaWitness), \\\"cGammaWitness is not on curve\\\");\\n      require(isOnCurve(sHashWitness), \\\"sHashWitness is not on curve\\\");\\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\\n      // we use the address of u instead of u itself. Also, here we add the\\n      // terms instead of taking the difference, and in the proof consruction in\\n      // vrf.GenerateProof, we correspondingly take the difference instead of\\n      // taking the sum as they do in step 7 of section 5.1.)\\n      require(verifyLinearCombinationWithGenerator(c, pk, s, uWitness), \\\"addr(c*pk+s*g)!=_uWitness\\\");\\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\\n      uint256[2] memory hash = hashToCurve(pk, seed);\\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\\n      uint256[2] memory v = linearCombination(c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\\n      // Steps 7. and 8. of IETF draft section 5.3\\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\\n      require(c == derivedC, \\\"invalid proof\\\");\\n    }\\n  }\\n\\n  // Domain-separation tag for the hash used as the final VRF output.\\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\\n  uint256 internal constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\\n\\n  struct Proof {\\n    uint256[2] pk;\\n    uint256[2] gamma;\\n    uint256 c;\\n    uint256 s;\\n    uint256 seed;\\n    address uWitness;\\n    uint256[2] cGammaWitness;\\n    uint256[2] sHashWitness;\\n    uint256 zInv;\\n  }\\n\\n  /* ***************************************************************************\\n     * @notice Returns proof's output, if proof is valid. Otherwise reverts\\n\\n     * @param proof vrf proof components\\n     * @param seed  seed used to generate the vrf output\\n     *\\n     * Throws if proof is invalid, otherwise:\\n     * @return output i.e., the random output implied by the proof\\n     * ***************************************************************************\\n     */\\n  function randomValueFromVRFProof(Proof memory proof, uint256 seed) internal view returns (uint256 output) {\\n    verifyVRFProof(\\n      proof.pk,\\n      proof.gamma,\\n      proof.c,\\n      proof.s,\\n      seed,\\n      proof.uWitness,\\n      proof.cGammaWitness,\\n      proof.sHashWitness,\\n      proof.zInv\\n    );\\n    output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, proof.gamma)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFCoordinatorV2TestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../dev/VRFCoordinatorV2.sol\\\";\\n\\ncontract VRFCoordinatorV2TestHelper is VRFCoordinatorV2 {\\n  uint96 s_paymentAmount;\\n  uint256 s_gasStart;\\n\\n  constructor(\\n    address link,\\n    address blockhashStore,\\n    address linkEthFeed\\n  )\\n    // solhint-disable-next-line no-empty-blocks\\n    VRFCoordinatorV2(link, blockhashStore, linkEthFeed)\\n  {\\n    /* empty */\\n  }\\n\\n  function calculatePaymentAmountTest(\\n    uint256 gasAfterPaymentCalculation,\\n    uint32 fulfillmentFlatFeeLinkPPM,\\n    uint256 weiPerUnitGas\\n  ) external {\\n    s_paymentAmount = calculatePaymentAmount(\\n      gasleft(),\\n      gasAfterPaymentCalculation,\\n      fulfillmentFlatFeeLinkPPM,\\n      weiPerUnitGas\\n    );\\n  }\\n\\n  function getPaymentAmount() public view returns (uint96) {\\n    return s_paymentAmount;\\n  }\\n\\n  function getGasStart() public view returns (uint256) {\\n    return s_gasStart;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ValidatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"./interfaces/TypeAndVersionInterface.sol\\\";\\n\\ncontract ValidatorProxy is AggregatorValidatorInterface, TypeAndVersionInterface, ConfirmedOwner {\\n  /// @notice Uses a single storage slot to store the current address\\n  struct AggregatorConfiguration {\\n    address target;\\n    bool hasNewProposal;\\n  }\\n\\n  struct ValidatorConfiguration {\\n    AggregatorValidatorInterface target;\\n    bool hasNewProposal;\\n  }\\n\\n  // Configuration for the current aggregator\\n  AggregatorConfiguration private s_currentAggregator;\\n  // Proposed aggregator address\\n  address private s_proposedAggregator;\\n\\n  // Configuration for the current validator\\n  ValidatorConfiguration private s_currentValidator;\\n  // Proposed validator address\\n  AggregatorValidatorInterface private s_proposedValidator;\\n\\n  event AggregatorProposed(address indexed aggregator);\\n  event AggregatorUpgraded(address indexed previous, address indexed current);\\n  event ValidatorProposed(AggregatorValidatorInterface indexed validator);\\n  event ValidatorUpgraded(AggregatorValidatorInterface indexed previous, AggregatorValidatorInterface indexed current);\\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\\n  event ProposedAggregatorValidateCall(\\n    address indexed proposed,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n\\n  /**\\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\\n   * @param aggregator address\\n   * @param validator address\\n   */\\n  constructor(address aggregator, AggregatorValidatorInterface validator) ConfirmedOwner(msg.sender) {\\n    s_currentAggregator = AggregatorConfiguration({target: aggregator, hasNewProposal: false});\\n    s_currentValidator = ValidatorConfiguration({target: validator, hasNewProposal: false});\\n  }\\n\\n  /**\\n   * @notice Validate a transmission\\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\\n   * and the `s_proposedValidator`, if it is set.\\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\\n   * the call was received.\\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\\n   * set as a non-contract address.\\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\\n   * @param previousRoundId uint256\\n   * @param previousAnswer int256\\n   * @param currentRoundId uint256\\n   * @param currentAnswer int256\\n   * @return bool\\n   */\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external override returns (bool) {\\n    address currentAggregator = s_currentAggregator.target;\\n    if (msg.sender != currentAggregator) {\\n      address proposedAggregator = s_proposedAggregator;\\n      require(msg.sender == proposedAggregator, \\\"Not a configured aggregator\\\");\\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\\n      // This is to confirm that `validate` is being called prior to upgrade.\\n      emit ProposedAggregatorValidateCall(\\n        proposedAggregator,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      );\\n      return true;\\n    }\\n\\n    // Send the validate call to the current validator\\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\\n    address currentValidatorAddress = address(currentValidator.target);\\n    require(currentValidatorAddress != address(0), \\\"No validator set\\\");\\n    currentValidatorAddress.call(\\n      abi.encodeWithSelector(\\n        AggregatorValidatorInterface.validate.selector,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      )\\n    );\\n    // If there is a new proposed validator, send the validate call to that validator also\\n    if (currentValidator.hasNewProposal) {\\n      address(s_proposedValidator).call(\\n        abi.encodeWithSelector(\\n          AggregatorValidatorInterface.validate.selector,\\n          previousRoundId,\\n          previousAnswer,\\n          currentRoundId,\\n          currentAnswer\\n        )\\n      );\\n    }\\n    return true;\\n  }\\n\\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an aggregator\\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewAggregator(address proposed) external onlyOwner {\\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedAggregator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\\n    emit AggregatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\\n   * @dev Must have a proposed aggregator. Only owner can call.\\n   */\\n  function upgradeAggregator() external onlyOwner {\\n    // Get configuration in memory\\n    AggregatorConfiguration memory current = s_currentAggregator;\\n    address previous = current.target;\\n    address proposed = s_proposedAggregator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentAggregator = AggregatorConfiguration({target: proposed, hasNewProposal: false});\\n    delete s_proposedAggregator;\\n\\n    emit AggregatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get aggregator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getAggregators()\\n    external\\n    view\\n    returns (\\n      address current,\\n      bool hasProposal,\\n      address proposed\\n    )\\n  {\\n    current = s_currentAggregator.target;\\n    hasProposal = s_currentAggregator.hasNewProposal;\\n    proposed = s_proposedAggregator;\\n  }\\n\\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an validator\\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewValidator(AggregatorValidatorInterface proposed) external onlyOwner {\\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedValidator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\\n    emit ValidatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\\n   * @dev Must have a proposed validator. Only owner can call.\\n   */\\n  function upgradeValidator() external onlyOwner {\\n    // Get configuration in memory\\n    ValidatorConfiguration memory current = s_currentValidator;\\n    AggregatorValidatorInterface previous = current.target;\\n    AggregatorValidatorInterface proposed = s_proposedValidator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentValidator = ValidatorConfiguration({target: proposed, hasNewProposal: false});\\n    delete s_proposedValidator;\\n\\n    emit ValidatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get validator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getValidators()\\n    external\\n    view\\n    returns (\\n      AggregatorValidatorInterface current,\\n      bool hasProposal,\\n      AggregatorValidatorInterface proposed\\n    )\\n  {\\n    current = s_currentValidator.target;\\n    hasProposal = s_currentValidator.hasNewProposal;\\n    proposed = s_proposedValidator;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ValidatorProxy 1.0.0\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorValidatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorValidatorInterface {\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/OptimismValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../SimpleWriteAccessController.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\nimport \\\"./interfaces/ForwarderInterface.sol\\\";\\nimport \\\"./vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title OptimismValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\\n * @notice Allows to raise and lower Flags on the Optimism L2 network through L1 bridge\\n *  - The internal AccessController controls the access of the validate method\\n */\\ncontract OptimismValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\\n  address public constant FLAG_OPTIMISM_SEQ_OFFLINE =\\n    address(bytes20(bytes32(uint256(keccak256(\\\"chainlink.flags.optimism-seq-offline\\\")) - 1)));\\n  // Encode underlying Flags call/s\\n  bytes private constant CALL_RAISE_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.raiseFlag.selector, FLAG_OPTIMISM_SEQ_OFFLINE);\\n  bytes private constant CALL_LOWER_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.lowerFlag.selector, FLAG_OPTIMISM_SEQ_OFFLINE);\\n  uint32 private constant CALL_GAS_LIMIT = 1_200_000;\\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\\n\\n  address public immutable CROSS_DOMAIN_MESSENGER;\\n  address public immutable L2_CROSS_DOMAIN_FORWARDER;\\n  address public immutable L2_FLAGS;\\n\\n  /**\\n   * @param crossDomainMessengerAddr address the xDomain bridge messenger (Optimism bridge L1) contract address\\n   * @param l2CrossDomainForwarderAddr the L2 Forwarder contract address\\n   * @param l2FlagsAddr the L2 Flags contract address\\n   */\\n  constructor(\\n    address crossDomainMessengerAddr,\\n    address l2CrossDomainForwarderAddr,\\n    address l2FlagsAddr\\n  ) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    require(l2CrossDomainForwarderAddr != address(0), \\\"Invalid L2 xDomain Forwarder address\\\");\\n    require(l2FlagsAddr != address(0), \\\"Invalid L2 Flags address\\\");\\n    CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n    L2_CROSS_DOMAIN_FORWARDER = l2CrossDomainForwarderAddr;\\n    L2_FLAGS = l2FlagsAddr;\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - OptimismValidator 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"OptimismValidator 0.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\\n   * @dev A message is sent via the Optimism CrossDomainMessenger L1 contract. The \\\"payment\\\" for L2 execution happens on L1,\\n   *   using the gas attached to this tx (some extra gas is burned by the Optimism bridge to avoid DoS attacks).\\n   *   This method is accessed controlled.\\n   * @param previousAnswer previous aggregator answer\\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\\n   */\\n  function validate(\\n    uint256, /* previousRoundId */\\n    int256 previousAnswer,\\n    uint256, /* currentRoundId */\\n    int256 currentAnswer\\n  ) external override checkAccess returns (bool) {\\n    // Avoids resending to L2 the same tx on every call\\n    if (previousAnswer == currentAnswer) {\\n      return true; // noop\\n    }\\n\\n    // Encode the Forwarder call\\n    bytes4 selector = ForwarderInterface.forward.selector;\\n    address target = L2_FLAGS;\\n    // Choose and encode the underlying Flags call\\n    bytes memory data = currentAnswer == ANSWER_SEQ_OFFLINE ? CALL_RAISE_FLAG : CALL_LOWER_FLAG;\\n    bytes memory message = abi.encodeWithSelector(selector, target, data);\\n    // Make the xDomain call\\n    iOVM_CrossDomainMessenger(CROSS_DOMAIN_MESSENGER).sendMessage(L2_CROSS_DOMAIN_FORWARDER, message, CALL_GAS_LIMIT);\\n    // return success\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AccessControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AccessControllerInterface {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleWriteAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\n\\n/**\\n * @title SimpleWriteAccessController\\n * @notice Gives access to accounts explicitly added to an access list by the\\n * controller's owner.\\n * @dev does not make any special permissions for externally, see\\n * SimpleReadAccessController for that.\\n */\\ncontract SimpleWriteAccessController is AccessControllerInterface, ConfirmedOwner {\\n  bool public checkEnabled;\\n  mapping(address => bool) internal accessList;\\n\\n  event AddedAccess(address user);\\n  event RemovedAccess(address user);\\n  event CheckAccessEnabled();\\n  event CheckAccessDisabled();\\n\\n  constructor() ConfirmedOwner(msg.sender) {\\n    checkEnabled = true;\\n  }\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory) public view virtual override returns (bool) {\\n    return accessList[_user] || !checkEnabled;\\n  }\\n\\n  /**\\n   * @notice Adds an address to the access list\\n   * @param _user The address to add\\n   */\\n  function addAccess(address _user) external onlyOwner {\\n    if (!accessList[_user]) {\\n      accessList[_user] = true;\\n\\n      emit AddedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes an address from the access list\\n   * @param _user The address to remove\\n   */\\n  function removeAccess(address _user) external onlyOwner {\\n    if (accessList[_user]) {\\n      accessList[_user] = false;\\n\\n      emit RemovedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check enforced\\n   */\\n  function enableAccessCheck() external onlyOwner {\\n    if (!checkEnabled) {\\n      checkEnabled = true;\\n\\n      emit CheckAccessEnabled();\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check unenforced\\n   */\\n  function disableAccessCheck() external onlyOwner {\\n    if (checkEnabled) {\\n      checkEnabled = false;\\n\\n      emit CheckAccessDisabled();\\n    }\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access\\n   */\\n  modifier checkAccess() {\\n    require(hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlag(address) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n\\n  function setLoweringAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/ForwarderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ForwarderInterface - forwards a call to a target, under some conditions\\ninterface ForwarderInterface {\\n  /**\\n   * @notice forward calls the `target` with `data`\\n   * @param target contract address to be called\\n   * @param data to send to target contract\\n   */\\n  function forward(address target, bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @title iOVM_CrossDomainMessenger\\n */\\ninterface iOVM_CrossDomainMessenger {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event SentMessage(bytes message);\\n  event RelayedMessage(bytes32 msgHash);\\n  event FailedRelayedMessage(bytes32 msgHash);\\n\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  function xDomainMessageSender() external view returns (address);\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Sends a cross domain message to the target messenger.\\n   * @param _target Target contract address.\\n   * @param _message Message to send to the target.\\n   * @param _gasLimit Gas limit for the provided message.\\n   */\\n  function sendMessage(\\n    address _target,\\n    bytes calldata _message,\\n    uint32 _gasLimit\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/OptimismCrossDomainForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./CrossDomainForwarder.sol\\\";\\nimport \\\"./vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title OptimismCrossDomainForwarder - L1 xDomain account representation\\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\\n *   can be considered to be owned by the `l1Owner`\\n */\\ncontract OptimismCrossDomainForwarder is TypeAndVersionInterface, CrossDomainForwarder {\\n  // OVM_L2CrossDomainMessenger is a precompile usually deployed to 0x4200000000000000000000000000000000000007\\n  address private immutable OVM_CROSS_DOMAIN_MESSENGER;\\n\\n  /**\\n   * @notice creates a new Optimism xDomain Forwarder contract\\n   * @param crossDomainMessengerAddr the xDomain bridge messenger (Optimism bridge L2) contract address\\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\\n   */\\n  constructor(address crossDomainMessengerAddr, address l1OwnerAddr) CrossDomainForwarder(l1OwnerAddr) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    OVM_CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - OptimismCrossDomainForwarder 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"OptimismCrossDomainForwarder 0.1.0\\\";\\n  }\\n\\n  /**\\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address\\n   * @inheritdoc ForwarderInterface\\n   */\\n  function forward(address target, bytes memory data) external override {\\n    // 1. The call MUST come from the L1 Messenger\\n    require(msg.sender == OVM_CROSS_DOMAIN_MESSENGER, \\\"Sender is not the L2 messenger\\\");\\n    // 2. The L1 Messenger's caller MUST be the L1 Owner\\n    require(\\n      iOVM_CrossDomainMessenger(OVM_CROSS_DOMAIN_MESSENGER).xDomainMessageSender() == l1Owner(),\\n      \\\"xDomain sender is not the L1 owner\\\"\\n    );\\n    // 3. Make the external call\\n    (bool success, bytes memory res) = target.call(data);\\n    require(success, string(abi.encode(\\\"xDomain call failed:\\\", res)));\\n  }\\n\\n  /**\\n   * @notice This is always the address of the OVM_L2CrossDomainMessenger contract\\n   * @inheritdoc CrossDomainForwarder\\n   */\\n  function crossDomainMessenger() public view virtual override returns (address) {\\n    return OVM_CROSS_DOMAIN_MESSENGER;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/CrossDomainForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/ForwarderInterface.sol\\\";\\n\\n/**\\n * @title CrossDomainForwarder - L1 xDomain account representation\\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\\n *   can be considered to be owned by the `l1Owner`\\n */\\nabstract contract CrossDomainForwarder is ForwarderInterface, ConfirmedOwner {\\n  address private s_l1Owner;\\n\\n  event L1OwnershipTransferred(address indexed from, address indexed to);\\n\\n  /**\\n   * @notice creates a new xDomain Forwarder contract\\n   * @dev Forwarding can be disabled by setting the L1 owner as `address(0)`.\\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\\n   */\\n  constructor(address l1OwnerAddr) ConfirmedOwner(msg.sender) {\\n    _setL1Owner(l1OwnerAddr);\\n  }\\n\\n  /// @return xDomain messenger address (L2 `msg.sender`)\\n  function crossDomainMessenger() public view virtual returns (address);\\n\\n  /// @return L1 owner address\\n  function l1Owner() public view virtual returns (address) {\\n    return s_l1Owner;\\n  }\\n\\n  /**\\n   * @notice transfer ownership of this account to a new L1 owner\\n   * @dev Forwarding can be disabled by setting the L1 owner as `address(0)`. Accessible only by owner.\\n   * @param to new L1 owner that will be allowed to call the forward fn\\n   */\\n  function transferL1Ownership(address to) external virtual onlyOwner {\\n    _setL1Owner(to);\\n  }\\n\\n  /// @notice internal method that stores the L1 owner\\n  function _setL1Owner(address to) internal {\\n    address from = s_l1Owner;\\n    if (from != to) {\\n      s_l1Owner = to;\\n      emit L1OwnershipTransferred(from, to);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ArbitrumValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../SimpleWriteAccessController.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./interfaces/ForwarderInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\\\";\\nimport \\\"./vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\\\";\\nimport \\\"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title ArbitrumValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\\n * @notice Allows to raise and lower Flags on the Arbitrum L2 network through L1 bridge\\n *  - The internal AccessController controls the access of the validate method\\n *  - Gas configuration is controlled by a configurable external SimpleWriteAccessController\\n *  - Funds on the contract are managed by the owner\\n */\\ncontract ArbitrumValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\\n  enum PaymentStrategy {\\n    L1,\\n    L2\\n  }\\n  // Config for L1 -> L2 Arbitrum retryable ticket message\\n  struct GasConfig {\\n    uint256 maxGas;\\n    uint256 gasPriceBid;\\n    address gasPriceL1FeedAddr;\\n  }\\n\\n  /// @dev Precompiled contract that exists in every Arbitrum chain at address(100). Exposes a variety of system-level functionality.\\n  address constant ARBSYS_ADDR = address(0x0000000000000000000000000000000000000064);\\n\\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\\n  address public constant FLAG_ARBITRUM_SEQ_OFFLINE =\\n    address(bytes20(bytes32(uint256(keccak256(\\\"chainlink.flags.arbitrum-seq-offline\\\")) - 1)));\\n  // Encode underlying Flags call/s\\n  bytes private constant CALL_RAISE_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.raiseFlag.selector, FLAG_ARBITRUM_SEQ_OFFLINE);\\n  bytes private constant CALL_LOWER_FLAG =\\n    abi.encodeWithSelector(FlagsInterface.lowerFlag.selector, FLAG_ARBITRUM_SEQ_OFFLINE);\\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\\n\\n  address public immutable CROSS_DOMAIN_MESSENGER;\\n  address public immutable L2_CROSS_DOMAIN_FORWARDER;\\n  address public immutable L2_FLAGS;\\n  // L2 xDomain alias address of this contract\\n  address public immutable L2_ALIAS = AddressAliasHelper.applyL1ToL2Alias(address(this));\\n\\n  PaymentStrategy private s_paymentStrategy;\\n  GasConfig private s_gasConfig;\\n  AccessControllerInterface private s_configAC;\\n\\n  /**\\n   * @notice emitted when a new payment strategy is set\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  event PaymentStrategySet(PaymentStrategy indexed paymentStrategy);\\n\\n  /**\\n   * @notice emitted when a new gas configuration is set\\n   * @param maxGas gas limit for immediate L2 execution attempt.\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   */\\n  event GasConfigSet(uint256 maxGas, uint256 gasPriceBid, address indexed gasPriceL1FeedAddr);\\n\\n  /**\\n   * @notice emitted when a new gas access-control contract is set\\n   * @param previous the address prior to the current setting\\n   * @param current the address of the new access-control contract\\n   */\\n  event ConfigACSet(address indexed previous, address indexed current);\\n\\n  /**\\n   * @notice emitted when a new ETH withdrawal from L2 was requested\\n   * @param id unique id of the published retryable transaction (keccak256(requestID, uint(0))\\n   * @param amount of funds to withdraw\\n   */\\n  event L2WithdrawalRequested(uint256 indexed id, uint256 amount, address indexed refundAddr);\\n\\n  /**\\n   * @param crossDomainMessengerAddr address the xDomain bridge messenger (Arbitrum Inbox L1) contract address\\n   * @param l2CrossDomainForwarderAddr the L2 Forwarder contract address\\n   * @param l2FlagsAddr the L2 Flags contract address\\n   * @param configACAddr address of the access controller for managing gas price on Arbitrum\\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  constructor(\\n    address crossDomainMessengerAddr,\\n    address l2CrossDomainForwarderAddr,\\n    address l2FlagsAddr,\\n    address configACAddr,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr,\\n    PaymentStrategy paymentStrategy\\n  ) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    require(l2CrossDomainForwarderAddr != address(0), \\\"Invalid L2 xDomain Forwarder address\\\");\\n    require(l2FlagsAddr != address(0), \\\"Invalid Flags contract address\\\");\\n    CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n    L2_CROSS_DOMAIN_FORWARDER = l2CrossDomainForwarderAddr;\\n    L2_FLAGS = l2FlagsAddr;\\n    // Additional L2 payment configuration\\n    _setConfigAC(configACAddr);\\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n    _setPaymentStrategy(paymentStrategy);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - ArbitrumValidator 0.1.0: initial release\\n   * - ArbitrumValidator 0.2.0: critical Arbitrum network update\\n   *   - xDomain `msg.sender` backwards incompatible change (now an alias address)\\n   *   - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address\\n   *   - approximation of `maxSubmissionCost` using a L1 gas price feed\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ArbitrumValidator 0.2.0\\\";\\n  }\\n\\n  /// @return stored PaymentStrategy\\n  function paymentStrategy() external view virtual returns (PaymentStrategy) {\\n    return s_paymentStrategy;\\n  }\\n\\n  /// @return stored GasConfig\\n  function gasConfig() external view virtual returns (GasConfig memory) {\\n    return s_gasConfig;\\n  }\\n\\n  /// @return config AccessControllerInterface contract address\\n  function configAC() external view virtual returns (address) {\\n    return address(s_configAC);\\n  }\\n\\n  /**\\n   * @notice makes this contract payable\\n   * @dev receives funds:\\n   *  - to use them (if configured) to pay for L2 execution on L1\\n   *  - when withdrawing funds from L2 xDomain alias address (pay for L2 execution on L2)\\n   */\\n  receive() external payable {}\\n\\n  /**\\n   * @notice withdraws all funds available in this contract to the msg.sender\\n   * @dev only owner can call this\\n   */\\n  function withdrawFunds() external onlyOwner {\\n    address payable recipient = payable(msg.sender);\\n    uint256 amount = address(this).balance;\\n    Address.sendValue(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice withdraws all funds available in this contract to the address specified\\n   * @dev only owner can call this\\n   * @param recipient address where to send the funds\\n   */\\n  function withdrawFundsTo(address payable recipient) external onlyOwner {\\n    uint256 amount = address(this).balance;\\n    Address.sendValue(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice withdraws funds from L2 xDomain alias address (representing this L1 contract)\\n   * @dev only owner can call this\\n   * @param amount of funds to withdraws\\n   * @param refundAddr address where gas excess on L2 will be sent\\n   *   WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.\\n   * @return id unique id of the published retryable transaction (keccak256(requestID, uint(0))\\n   */\\n  function withdrawFundsFromL2(uint256 amount, address refundAddr) external onlyOwner returns (uint256 id) {\\n    // Build an xDomain message to trigger the ArbSys precompile, which will create a L2 -> L1 tx transferring `amount`\\n    bytes memory message = abi.encodeWithSelector(ArbSys.withdrawEth.selector, address(this));\\n    // Make the xDomain call\\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\\n    uint256 maxGas = 120_000; // static `maxGas` for L2 -> L1 transfer\\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\\n      : 0;\\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\\n    id = IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\\n      ARBSYS_ADDR, // target\\n      amount, // L2 call value (requested)\\n      maxSubmissionCost,\\n      refundAddr, // excessFeeRefundAddress\\n      refundAddr, // callValueRefundAddress\\n      maxGas,\\n      gasPriceBid,\\n      message\\n    );\\n    emit L2WithdrawalRequested(id, amount, refundAddr);\\n  }\\n\\n  /**\\n   * @notice sets config AccessControllerInterface contract\\n   * @dev only owner can call this\\n   * @param accessController new AccessControllerInterface contract address\\n   */\\n  function setConfigAC(address accessController) external onlyOwner {\\n    _setConfigAC(accessController);\\n  }\\n\\n  /**\\n   * @notice sets Arbitrum gas configuration\\n   * @dev access control provided by `configAC`\\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   */\\n  function setGasConfig(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr\\n  ) external onlyOwnerOrConfigAccess {\\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n  }\\n\\n  /**\\n   * @notice sets the payment strategy\\n   * @dev access control provided by `configAC`\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  function setPaymentStrategy(PaymentStrategy paymentStrategy) external onlyOwnerOrConfigAccess {\\n    _setPaymentStrategy(paymentStrategy);\\n  }\\n\\n  /**\\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\\n   * @dev A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this\\n   *   contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by\\n   *   the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.\\n   * @param previousAnswer previous aggregator answer\\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\\n   */\\n  function validate(\\n    uint256, /* previousRoundId */\\n    int256 previousAnswer,\\n    uint256, /* currentRoundId */\\n    int256 currentAnswer\\n  ) external override checkAccess returns (bool) {\\n    // Avoids resending to L2 the same tx on every call\\n    if (previousAnswer == currentAnswer) {\\n      return true;\\n    }\\n\\n    // Excess gas on L2 will be sent to the L2 xDomain alias address of this contract\\n    address refundAddr = L2_ALIAS;\\n    // Encode the Forwarder call\\n    bytes4 selector = ForwarderInterface.forward.selector;\\n    address target = L2_FLAGS;\\n    // Choose and encode the underlying Flags call\\n    bytes memory data = currentAnswer == ANSWER_SEQ_OFFLINE ? CALL_RAISE_FLAG : CALL_LOWER_FLAG;\\n    bytes memory message = abi.encodeWithSelector(selector, target, data);\\n    // Make the xDomain call\\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\\n    uint256 maxGas = s_gasConfig.maxGas;\\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\\n      : 0;\\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\\n    // We also ignore the returned msg number, that can be queried via the `InboxMessageDelivered` event.\\n    IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\\n      L2_CROSS_DOMAIN_FORWARDER, // target\\n      0, // L2 call value\\n      maxSubmissionCost,\\n      refundAddr, // excessFeeRefundAddress\\n      refundAddr, // callValueRefundAddress\\n      maxGas,\\n      gasPriceBid,\\n      message\\n    );\\n    // return success\\n    return true;\\n  }\\n\\n  /// @notice internal method that stores the payment strategy\\n  function _setPaymentStrategy(PaymentStrategy paymentStrategy) internal {\\n    s_paymentStrategy = paymentStrategy;\\n    emit PaymentStrategySet(paymentStrategy);\\n  }\\n\\n  /// @notice internal method that stores the gas configuration\\n  function _setGasConfig(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr\\n  ) internal {\\n    require(maxGas > 0, \\\"Max gas is zero\\\");\\n    require(gasPriceBid > 0, \\\"Gas price bid is zero\\\");\\n    require(gasPriceL1FeedAddr != address(0), \\\"Gas price Aggregator is zero address\\\");\\n    s_gasConfig = GasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n    emit GasConfigSet(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n  }\\n\\n  /// @notice Internal method that stores the configuration access controller\\n  function _setConfigAC(address accessController) internal {\\n    address previousAccessController = address(s_configAC);\\n    if (accessController != previousAccessController) {\\n      s_configAC = AccessControllerInterface(accessController);\\n      emit ConfigACSet(previousAccessController, accessController);\\n    }\\n  }\\n\\n  /**\\n   * @notice Internal method that approximates the `maxSubmissionCost` (using the L1 gas price feed)\\n   * @dev On L2 this info is available via `ArbRetryableTx.getSubmissionPrice`.\\n   * @param calldataSizeInBytes xDomain message size in bytes\\n   */\\n  function _approximateMaxSubmissionCost(uint256 calldataSizeInBytes) internal view returns (uint256) {\\n    (, int256 l1GasPriceInWei, , , ) = AggregatorV3Interface(s_gasConfig.gasPriceL1FeedAddr).latestRoundData();\\n    uint256 l1GasPriceEstimate = uint256(l1GasPriceInWei) * 3; // add 200% buffer (price volatility error margin)\\n    return (l1GasPriceEstimate * calldataSizeInBytes) / 256 + l1GasPriceEstimate;\\n  }\\n\\n  /// @notice Internal helper method that calculates the total cost of the xDomain retryable ticket call\\n  function _maxRetryableTicketCost(\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 gasPriceBid\\n  ) internal pure returns (uint256) {\\n    return maxSubmissionCost + maxGas * gasPriceBid;\\n  }\\n\\n  /// @dev reverts if the caller does not have access to change the configuration\\n  modifier onlyOwnerOrConfigAccess() {\\n    require(\\n      msg.sender == owner() || (address(s_configAC) != address(0) && s_configAC.hasAccess(msg.sender, msg.data)),\\n      \\\"No access\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n  function sendUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendL1FundedUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function sendL1FundedContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicketNoRefundAliasRewrite(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicket(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function depositEth(address destAddr) external payable returns (uint256);\\n\\n  function depositEthRetryable(\\n    address destAddr,\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 maxGasPrice\\n  ) external payable returns (uint256);\\n\\n  function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l1Address L2 address as viewed in msg.sender\\n  /// @return l2Address the address in the L1 that triggered the tx to L2\\n  function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n    unchecked {\\n      l2Address = address(uint160(l1Address) + offset);\\n    }\\n  }\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l2Address L2 address as viewed in msg.sender\\n  /// @return l1Address the address in the L1 that triggered the tx to L2\\n  function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n    unchecked {\\n      l1Address = address(uint160(l2Address) - offset);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\": {\r\n      \"content\": \"// NOTICE: pragma change from original (>=0.4.21 <0.7.0)\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface ArbSys {\\n  /**\\n   * @notice Get internal version number identifying an ArbOS build\\n   * @return version number as int\\n   */\\n  function arbOSVersion() external pure returns (uint256);\\n\\n  function arbChainID() external view returns (uint256);\\n\\n  /**\\n   * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n   * @return block number as int\\n   */\\n  function arbBlockNumber() external view returns (uint256);\\n\\n  /**\\n   * @notice Send given amount of Eth to dest from sender.\\n   * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n   * @param destination recipient address on L1\\n   * @return unique identifier for this L2-to-L1 transaction.\\n   */\\n  function withdrawEth(address destination) external payable returns (uint256);\\n\\n  /**\\n   * @notice Send a transaction to L1\\n   * @param destination recipient address on L1\\n   * @param calldataForL1 (optional) calldata for L1 contract call\\n   * @return a unique identifier for this L2-to-L1 transaction.\\n   */\\n  function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\\n\\n  /**\\n   * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n   * @param account target account\\n   * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n   */\\n  function getTransactionCount(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice get the value of target L2 storage slot\\n   * This function is only callable from address 0 to prevent contracts from being able to call it\\n   * @param account target account\\n   * @param index target index of storage slot\\n   * @return stotage value for the given account at the given index\\n   */\\n  function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice check if current call is coming from l1\\n   * @return true if the caller of this was called directly from L1\\n   */\\n  function isTopLevelCall() external view returns (bool);\\n\\n  event L2ToL1Transaction(\\n    address caller,\\n    address indexed destination,\\n    uint256 indexed uniqueId,\\n    uint256 indexed batchNumber,\\n    uint256 indexInBatch,\\n    uint256 arbBlockNum,\\n    uint256 ethBlockNum,\\n    uint256 timestamp,\\n    uint256 callvalue,\\n    bytes data\\n  );\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\ninterface IBridge {\\n  event MessageDelivered(\\n    uint256 indexed messageIndex,\\n    bytes32 indexed beforeInboxAcc,\\n    address inbox,\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  );\\n\\n  function deliverMessageToInbox(\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  ) external payable returns (uint256);\\n\\n  function executeCall(\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (bool success, bytes memory returnData);\\n\\n  // These are only callable by the admin\\n  function setInbox(address inbox, bool enabled) external;\\n\\n  function setOutbox(address inbox, bool enabled) external;\\n\\n  // View functions\\n\\n  function activeOutbox() external view returns (address);\\n\\n  function allowedInboxes(address inbox) external view returns (bool);\\n\\n  function allowedOutboxes(address outbox) external view returns (bool);\\n\\n  function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n  function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\ninterface IMessageProvider {\\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ArbitrumCrossDomainForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\\\";\\nimport \\\"./CrossDomainForwarder.sol\\\";\\n\\n/**\\n * @title ArbitrumCrossDomainForwarder - L1 xDomain account representation\\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\\n *   can be considered to be owned by the `l1Owner`\\n */\\ncontract ArbitrumCrossDomainForwarder is TypeAndVersionInterface, CrossDomainForwarder {\\n  /**\\n   * @notice creates a new Arbitrum xDomain Forwarder contract\\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\\n   */\\n  constructor(address l1OwnerAddr) CrossDomainForwarder(l1OwnerAddr) {\\n    // noop\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - ArbitrumCrossDomainForwarder 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ArbitrumCrossDomainForwarder 0.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice The L2 xDomain `msg.sender`, generated from L1 sender address\\n   * @inheritdoc CrossDomainForwarder\\n   */\\n  function crossDomainMessenger() public view virtual override returns (address) {\\n    return AddressAliasHelper.applyL1ToL2Alias(l1Owner());\\n  }\\n\\n  /**\\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address\\n   * @inheritdoc ForwarderInterface\\n   */\\n  function forward(address target, bytes memory data) external override {\\n    // 1. The call MUST come from the L2 Messenger (deterministically generated from the L1 xDomain sender address)\\n    require(msg.sender == crossDomainMessenger(), \\\"Sender is not the L2 messenger\\\");\\n    // 2. Make the external call\\n    (bool success, bytes memory res) = target.call(data);\\n    require(success, string(abi.encode(\\\"xDomain call failed:\\\", res)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../SimpleReadAccessController.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\n/* dev dependencies - to be re/moved after audit */\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags.\\n * Raise flag actions are controlled by its own access controller.\\n * Lower flag actions are controlled by its own access controller.\\n * An expected pattern is to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is TypeAndVersionInterface, FlagsInterface, SimpleReadAccessController {\\n  AccessControllerInterface public raisingAccessController;\\n  AccessControllerInterface public loweringAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(address indexed subject);\\n  event FlagLowered(address indexed subject);\\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\\n  event LoweringAccessControllerUpdated(address indexed previous, address indexed current);\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   * @param lacAddress address for the lowering access controller.\\n   */\\n  constructor(address racAddress, address lacAddress) {\\n    setRaisingAccessController(racAddress);\\n    setLoweringAccessController(lacAddress);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller\\n   * - Flags 1.0.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"Flags 1.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(address subject) external view override checkAccess returns (bool) {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(address subject) external override {\\n    require(_allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    _tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(address[] calldata subjects) external override {\\n    require(_allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      _tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for an addresses.\\n   * Access is controlled by loweringAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being lowered\\n   */\\n  function lowerFlag(address subject) external override {\\n    require(_allowedToLowerFlags(), \\\"Not allowed to lower flags\\\");\\n\\n    _tryToLowerFlag(subject);\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * Access is controlled by loweringAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(address[] calldata subjects) external override {\\n    require(_allowedToLowerFlags(), \\\"Not allowed to lower flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      _tryToLowerFlag(subject);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n  function setLoweringAccessController(address lacAddress) public override onlyOwner {\\n    address previous = address(loweringAccessController);\\n\\n    if (previous != lacAddress) {\\n      loweringAccessController = AccessControllerInterface(lacAddress);\\n\\n      emit LoweringAccessControllerUpdated(previous, lacAddress);\\n    }\\n  }\\n\\n  // PRIVATE\\n  function _allowedToRaiseFlags() private view returns (bool) {\\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function _allowedToLowerFlags() private view returns (bool) {\\n    return msg.sender == owner() || loweringAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function _tryToRaiseFlag(address subject) private {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n\\n  function _tryToLowerFlag(address subject) private {\\n    if (flags[subject]) {\\n      flags[subject] = false;\\n      emit FlagLowered(subject);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleWriteAccessController.sol\\\";\\n\\n/**\\n * @title SimpleReadAccessController\\n * @notice Gives access to:\\n * - any externally owned account (note that offchain actors can always read\\n * any contract storage regardless of onchain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev SimpleReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * SimpleWriteAccessController for that.\\n */\\ncontract SimpleReadAccessController is SimpleWriteAccessController {\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {\\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleReadAccessController.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags. The\\n * owner must turn the flags off, other setters cannot. An expected pattern is\\n * to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is FlagsInterface, SimpleReadAccessController {\\n  AccessControllerInterface public raisingAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(address indexed subject);\\n  event FlagLowered(address indexed subject);\\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   */\\n  constructor(address racAddress) {\\n    setRaisingAccessController(racAddress);\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(address subject) external view override checkAccess returns (bool) {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(address subject) external override {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(address[] calldata subjects) external override {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(address[] calldata subjects) external override onlyOwner {\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      if (flags[subject]) {\\n        flags[subject] = false;\\n        emit FlagLowered(subject);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n  // PRIVATE\\n\\n  function allowedToRaiseFlags() private view returns (bool) {\\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function tryToRaiseFlag(address subject) private {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/FlagsTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Flags.sol\\\";\\n\\ncontract FlagsTestHelper {\\n  Flags public flags;\\n\\n  constructor(address flagsContract) {\\n    flags = Flags(flagsContract);\\n  }\\n\\n  function getFlag(address subject) external view returns (bool) {\\n    return flags.getFlag(subject);\\n  }\\n\\n  function getFlags(address[] calldata subjects) external view returns (bool[] memory) {\\n    return flags.getFlags(subjects);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/FeedRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface FeedRegistryInterface {\\n  struct Phase {\\n    uint16 phaseId;\\n    uint80 startingAggregatorRoundId;\\n    uint80 endingAggregatorRoundId;\\n  }\\n\\n  event FeedProposed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed proposedAggregator,\\n    address currentAggregator,\\n    address sender\\n  );\\n  event FeedConfirmed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed latestAggregator,\\n    address previousAggregator,\\n    uint16 nextPhaseId,\\n    address sender\\n  );\\n\\n  // V3 AggregatorV3Interface\\n\\n  function decimals(address base, address quote) external view returns (uint8);\\n\\n  function description(address base, address quote) external view returns (string memory);\\n\\n  function version(address base, address quote) external view returns (uint256);\\n\\n  function latestRoundData(address base, address quote)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function getRoundData(\\n    address base,\\n    address quote,\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // V2 AggregatorInterface\\n\\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\\n\\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\\n\\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\\n\\n  function getAnswer(\\n    address base,\\n    address quote,\\n    uint256 roundId\\n  ) external view returns (int256 answer);\\n\\n  function getTimestamp(\\n    address base,\\n    address quote,\\n    uint256 roundId\\n  ) external view returns (uint256 timestamp);\\n\\n  // Registry getters\\n\\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function getPhaseFeed(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function isFeedEnabled(address aggregator) external view returns (bool);\\n\\n  function getPhase(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (Phase memory phase);\\n\\n  // Round helpers\\n\\n  function getRoundFeed(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function getPhaseRange(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\\n\\n  function getPreviousRoundId(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (uint80 previousRoundId);\\n\\n  function getNextRoundId(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (uint80 nextRoundId);\\n\\n  // Feed management\\n\\n  function proposeFeed(\\n    address base,\\n    address quote,\\n    address aggregator\\n  ) external;\\n\\n  function confirmFeed(\\n    address base,\\n    address quote,\\n    address aggregator\\n  ) external;\\n\\n  // Proposed aggregator\\n\\n  function getProposedFeed(address base, address quote)\\n    external\\n    view\\n    returns (AggregatorV2V3Interface proposedAggregator);\\n\\n  function proposedGetRoundData(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function proposedLatestRoundData(address base, address quote)\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // Phases\\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/mocks/MockAggregatorValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\n\\ncontract MockAggregatorValidator is AggregatorValidatorInterface {\\n  uint8 immutable id;\\n\\n  constructor(uint8 id_) {\\n    id = id_;\\n  }\\n\\n  event ValidateCalled(\\n    uint8 id,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external override returns (bool) {\\n    emit ValidateCalled(id, previousRoundId, previousAnswer, currentRoundId, currentAnswer);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/upkeeps/EthBalanceMonitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"../interfaces/KeeperCompatibleInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\n/**\\n * @title The EthBalanceMonitor contract\\n * @notice A keeper-compatible contract that monitors and funds eth addresses\\n */\\ncontract EthBalanceMonitor is ConfirmedOwner, Pausable, KeeperCompatibleInterface {\\n  // observed limit of 45K + 10k buffer\\n  uint256 private constant MIN_GAS_FOR_TRANSFER = 55_000;\\n\\n  event FundsAdded(uint256 amountAdded, uint256 newBalance, address sender);\\n  event FundsWithdrawn(uint256 amountWithdrawn, address payee);\\n  event TopUpSucceeded(address indexed recipient);\\n  event TopUpFailed(address indexed recipient);\\n  event KeeperRegistryAddressUpdated(address oldAddress, address newAddress);\\n  event MinWaitPeriodUpdated(uint256 oldMinWaitPeriod, uint256 newMinWaitPeriod);\\n\\n  error InvalidWatchList();\\n  error OnlyKeeperRegistry();\\n  error DuplicateAddress(address duplicate);\\n\\n  struct Target {\\n    bool isActive;\\n    uint96 minBalanceWei;\\n    uint96 topUpAmountWei;\\n    uint56 lastTopUpTimestamp; // enough space for 2 trillion years\\n  }\\n\\n  address private s_keeperRegistryAddress;\\n  uint256 private s_minWaitPeriodSeconds;\\n  address[] private s_watchList;\\n  mapping(address => Target) internal s_targets;\\n\\n  /**\\n   * @param keeperRegistryAddress The address of the keeper registry contract\\n   * @param minWaitPeriodSeconds The minimum wait period for addresses between funding\\n   */\\n  constructor(address keeperRegistryAddress, uint256 minWaitPeriodSeconds) ConfirmedOwner(msg.sender) {\\n    setKeeperRegistryAddress(keeperRegistryAddress);\\n    setMinWaitPeriodSeconds(minWaitPeriodSeconds);\\n  }\\n\\n  /**\\n   * @notice Sets the list of addresses to watch and their funding parameters\\n   * @param addresses the list of addresses to watch\\n   * @param minBalancesWei the minimum balances for each address\\n   * @param topUpAmountsWei the amount to top up each address\\n   */\\n  function setWatchList(\\n    address[] calldata addresses,\\n    uint96[] calldata minBalancesWei,\\n    uint96[] calldata topUpAmountsWei\\n  ) external onlyOwner {\\n    if (addresses.length != minBalancesWei.length || addresses.length != topUpAmountsWei.length) {\\n      revert InvalidWatchList();\\n    }\\n    address[] memory oldWatchList = s_watchList;\\n    for (uint256 idx = 0; idx < oldWatchList.length; idx++) {\\n      s_targets[oldWatchList[idx]].isActive = false;\\n    }\\n    for (uint256 idx = 0; idx < addresses.length; idx++) {\\n      if (s_targets[addresses[idx]].isActive) {\\n        revert DuplicateAddress(addresses[idx]);\\n      }\\n      if (addresses[idx] == address(0)) {\\n        revert InvalidWatchList();\\n      }\\n      if (topUpAmountsWei[idx] == 0) {\\n        revert InvalidWatchList();\\n      }\\n      s_targets[addresses[idx]] = Target({\\n        isActive: true,\\n        minBalanceWei: minBalancesWei[idx],\\n        topUpAmountWei: topUpAmountsWei[idx],\\n        lastTopUpTimestamp: 0\\n      });\\n    }\\n    s_watchList = addresses;\\n  }\\n\\n  /**\\n   * @notice Gets a list of addresses that are under funded\\n   * @return list of addresses that are underfunded\\n   */\\n  function getUnderfundedAddresses() public view returns (address[] memory) {\\n    address[] memory watchList = s_watchList;\\n    address[] memory needsFunding = new address[](watchList.length);\\n    uint256 count = 0;\\n    uint256 minWaitPeriod = s_minWaitPeriodSeconds;\\n    uint256 balance = address(this).balance;\\n    Target memory target;\\n    for (uint256 idx = 0; idx < watchList.length; idx++) {\\n      target = s_targets[watchList[idx]];\\n      if (\\n        target.lastTopUpTimestamp + minWaitPeriod <= block.timestamp &&\\n        balance >= target.topUpAmountWei &&\\n        watchList[idx].balance < target.minBalanceWei\\n      ) {\\n        needsFunding[count] = watchList[idx];\\n        count++;\\n        balance -= target.topUpAmountWei;\\n      }\\n    }\\n    if (count != watchList.length) {\\n      assembly {\\n        mstore(needsFunding, count)\\n      }\\n    }\\n    return needsFunding;\\n  }\\n\\n  /**\\n   * @notice Send funds to the addresses provided\\n   * @param needsFunding the list of addresses to fund (addresses must be pre-approved)\\n   */\\n  function topUp(address[] memory needsFunding) public whenNotPaused {\\n    uint256 minWaitPeriodSeconds = s_minWaitPeriodSeconds;\\n    Target memory target;\\n    for (uint256 idx = 0; idx < needsFunding.length; idx++) {\\n      target = s_targets[needsFunding[idx]];\\n      if (\\n        target.isActive &&\\n        target.lastTopUpTimestamp + minWaitPeriodSeconds <= block.timestamp &&\\n        needsFunding[idx].balance < target.minBalanceWei\\n      ) {\\n        bool success = payable(needsFunding[idx]).send(target.topUpAmountWei);\\n        if (success) {\\n          s_targets[needsFunding[idx]].lastTopUpTimestamp = uint56(block.timestamp);\\n          emit TopUpSucceeded(needsFunding[idx]);\\n        } else {\\n          emit TopUpFailed(needsFunding[idx]);\\n        }\\n      }\\n      if (gasleft() < MIN_GAS_FOR_TRANSFER) {\\n        return;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Get list of addresses that are underfunded and return keeper-compatible payload\\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoded list of addresses that need funds\\n   */\\n  function checkUpkeep(bytes calldata)\\n    external\\n    view\\n    override\\n    whenNotPaused\\n    returns (bool upkeepNeeded, bytes memory performData)\\n  {\\n    address[] memory needsFunding = getUnderfundedAddresses();\\n    upkeepNeeded = needsFunding.length > 0;\\n    performData = abi.encode(needsFunding);\\n    return (upkeepNeeded, performData);\\n  }\\n\\n  /**\\n   * @notice Called by keeper to send funds to underfunded addresses\\n   * @param performData The abi encoded list of addresses to fund\\n   */\\n  function performUpkeep(bytes calldata performData) external override onlyKeeperRegistry whenNotPaused {\\n    address[] memory needsFunding = abi.decode(performData, (address[]));\\n    topUp(needsFunding);\\n  }\\n\\n  /**\\n   * @notice Withdraws the contract balance\\n   * @param amount The amount of eth (in wei) to withdraw\\n   * @param payee The address to pay\\n   */\\n  function withdraw(uint256 amount, address payable payee) external onlyOwner {\\n    require(payee != address(0));\\n    emit FundsWithdrawn(amount, payee);\\n    payee.transfer(amount);\\n  }\\n\\n  /**\\n   * @notice Receive funds\\n   */\\n  receive() external payable {\\n    emit FundsAdded(msg.value, address(this).balance, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Sets the keeper registry address\\n   */\\n  function setKeeperRegistryAddress(address keeperRegistryAddress) public onlyOwner {\\n    require(keeperRegistryAddress != address(0));\\n    emit KeeperRegistryAddressUpdated(s_keeperRegistryAddress, keeperRegistryAddress);\\n    s_keeperRegistryAddress = keeperRegistryAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the minimum wait period (in seconds) for addresses between funding\\n   */\\n  function setMinWaitPeriodSeconds(uint256 period) public onlyOwner {\\n    emit MinWaitPeriodUpdated(s_minWaitPeriodSeconds, period);\\n    s_minWaitPeriodSeconds = period;\\n  }\\n\\n  /**\\n   * @notice Gets the keeper registry address\\n   */\\n  function getKeeperRegistryAddress() external view returns (address keeperRegistryAddress) {\\n    return s_keeperRegistryAddress;\\n  }\\n\\n  /**\\n   * @notice Gets the minimum wait period\\n   */\\n  function getMinWaitPeriodSeconds() external view returns (uint256) {\\n    return s_minWaitPeriodSeconds;\\n  }\\n\\n  /**\\n   * @notice Gets the list of addresses being watched\\n   */\\n  function getWatchList() external view returns (address[] memory) {\\n    return s_watchList;\\n  }\\n\\n  /**\\n   * @notice Gets configuration information for an address on the watchlist\\n   */\\n  function getAccountInfo(address targetAddress)\\n    external\\n    view\\n    returns (\\n      bool isActive,\\n      uint96 minBalanceWei,\\n      uint96 topUpAmountWei,\\n      uint56 lastTopUpTimestamp\\n    )\\n  {\\n    Target memory target = s_targets[targetAddress];\\n    return (target.isActive, target.minBalanceWei, target.topUpAmountWei, target.lastTopUpTimestamp);\\n  }\\n\\n  /**\\n   * @notice Pauses the contract, which prevents executing performUpkeep\\n   */\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice Unpauses the contract\\n   */\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  modifier onlyKeeperRegistry() {\\n    if (msg.sender != s_keeperRegistryAddress) {\\n      revert OnlyKeeperRegistry();\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface KeeperCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easilly be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/upkeeps/CronUpkeep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n  The Cron contract is a chainlink keepers-powered cron job runner for smart contracts.\\n  The contract enables developers to trigger actions on various targets using cron\\n  strings to specify the cadence. For example, a user may have 3 tasks that require\\n  regular service in their dapp ecosystem:\\n    1) 0xAB..CD, update(1), \\\"0 0 * * *\\\"     --> runs update(1) on 0xAB..CD daily at midnight\\n    2) 0xAB..CD, update(2), \\\"30 12 * * 0-4\\\" --> runs update(2) on 0xAB..CD weekdays at 12:30\\n    3) 0x12..34, trigger(), \\\"0 * * * *\\\"     --> runs trigger() on 0x12..34 hourly\\n\\n  To use this contract, a user first deploys this contract and registers it on the chainlink\\n  keeper registry. Then the user adds cron jobs by following these steps:\\n    1) Convert a cron string to an encoded cron spec by calling encodeCronString()\\n    2) Take the encoding, target, and handler, and create a job by sending a tx to createCronJob()\\n    3) Cron job is running :)\\n*/\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"../KeeperBase.sol\\\";\\nimport \\\"../interfaces/KeeperCompatibleInterface.sol\\\";\\nimport {Cron as CronInternal, Spec} from \\\"../libraries/internal/Cron.sol\\\";\\nimport {Cron as CronExternal} from \\\"../libraries/external/Cron.sol\\\";\\nimport {getRevertMsg} from \\\"../utils/utils.sol\\\";\\n\\n/**\\n * @title The CronUpkeep contract\\n * @notice A keeper-compatible contract that runs various tasks on cron schedules.\\n * Users must use the encodeCronString() function to encode their cron jobs before\\n * setting them. This keeps all the string manipulation off chain and reduces gas costs.\\n */\\ncontract CronUpkeep is KeeperCompatibleInterface, KeeperBase, ConfirmedOwner, Pausable, Proxy {\\n  event CronJobExecuted(uint256 indexed id, uint256 timestamp);\\n  event CronJobCreated(uint256 indexed id, address target, bytes handler);\\n  event CronJobDeleted(uint256 indexed id);\\n\\n  error CallFailed(uint256 id, string reason);\\n  error CronJobIDNotFound(uint256 id);\\n  error InvalidHandler();\\n  error TickInFuture();\\n  error TickTooOld();\\n  error TickDoesntMatchSpec();\\n\\n  address immutable s_delegate;\\n  uint256 private s_nextCronJobID = 1;\\n  uint256[] private s_activeCronJobIDs;\\n\\n  mapping(uint256 => uint256) private s_lastRuns;\\n  mapping(uint256 => Spec) private s_specs;\\n  mapping(uint256 => address) private s_targets;\\n  mapping(uint256 => bytes) private s_handlers;\\n  mapping(uint256 => bytes32) private s_handlerSignatures;\\n\\n  /**\\n   * @param owner the initial owner of the contract\\n   * @param delegate the contract to delegate checkUpkeep calls to\\n   */\\n  constructor(address owner, address delegate) ConfirmedOwner(owner) {\\n    s_delegate = delegate;\\n  }\\n\\n  /**\\n   * @notice Executes the cron job with id encoded in performData\\n   * @param performData abi encoding of cron job ID and the cron job's next run-at datetime\\n   */\\n  function performUpkeep(bytes calldata performData) external override whenNotPaused {\\n    (uint256 id, uint256 tickTime, address target, bytes memory handler) = abi.decode(\\n      performData,\\n      (uint256, uint256, address, bytes)\\n    );\\n    validate(id, tickTime, target, handler);\\n    s_lastRuns[id] = block.timestamp;\\n    (bool success, bytes memory payload) = target.call(handler);\\n    if (!success) {\\n      revert CallFailed(id, getRevertMsg(payload));\\n    }\\n    emit CronJobExecuted(id, block.timestamp);\\n  }\\n\\n  /**\\n   * @notice Creates a cron job from the given encoded spec\\n   * @param target the destination contract of a cron job\\n   * @param handler the function signature on the target contract to call\\n   * @param encodedCronSpec abi encoding of a cron spec\\n   */\\n  function createCronJobFromEncodedSpec(\\n    address target,\\n    bytes memory handler,\\n    bytes memory encodedCronSpec\\n  ) external {\\n    Spec memory spec = abi.decode(encodedCronSpec, (Spec));\\n    createCronJobFromSpec(target, handler, spec);\\n  }\\n\\n  /**\\n   * @notice Deletes the cron job matching the provided id. Reverts if\\n   * the id is not found.\\n   * @param id the id of the cron job to delete\\n   */\\n  function deleteCronJob(uint256 id) external onlyOwner {\\n    if (s_targets[id] == address(0)) {\\n      revert CronJobIDNotFound(id);\\n    }\\n    uint256 existingID;\\n    uint256 oldLength = s_activeCronJobIDs.length;\\n    uint256 newLength = oldLength - 1;\\n    uint256 idx;\\n    for (idx = 0; idx < newLength; idx++) {\\n      existingID = s_activeCronJobIDs[idx];\\n      if (existingID == id) {\\n        s_activeCronJobIDs[idx] = s_activeCronJobIDs[newLength];\\n        break;\\n      }\\n    }\\n    delete s_lastRuns[id];\\n    delete s_specs[id];\\n    delete s_targets[id];\\n    delete s_handlers[id];\\n    delete s_handlerSignatures[id];\\n    s_activeCronJobIDs.pop();\\n    emit CronJobDeleted(id);\\n  }\\n\\n  /**\\n   * @notice Pauses the contract, which prevents executing performUpkeep\\n   */\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice Unpauses the contract\\n   */\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  /**\\n   * @notice Get the id of an eligible cron job\\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding\\n   * of the id and \\\"next tick\\\" of the elligible cron job\\n   */\\n  function checkUpkeep(bytes calldata) external override whenNotPaused cannotExecute returns (bool, bytes memory) {\\n    _delegate(s_delegate);\\n  }\\n\\n  /**\\n   * @notice gets a list of active cron job IDs\\n   * @return list of active cron job IDs\\n   */\\n  function getActiveCronJobIDs() external view returns (uint256[] memory) {\\n    return s_activeCronJobIDs;\\n  }\\n\\n  /**\\n   * @notice gets a cron job\\n   * @param id the cron job ID\\n   * @return target - the address a cron job forwards the eth tx to\\n             handler - the encoded function sig to execute when forwarding a tx\\n             cronString - the string representing the cron job\\n             nextTick - the timestamp of the next time the cron job will run\\n   */\\n  function getCronJob(uint256 id)\\n    external\\n    view\\n    returns (\\n      address target,\\n      bytes memory handler,\\n      string memory cronString,\\n      uint256 nextTick\\n    )\\n  {\\n    Spec memory spec = s_specs[id];\\n    return (s_targets[id], s_handlers[id], CronExternal.toCronString(spec), CronExternal.nextTick(spec));\\n  }\\n\\n  /**\\n   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to convert and encode\\n   * @return the abi encoding of the Spec struct representing the cron string\\n   */\\n  function cronStringToEncodedSpec(string memory cronString) external pure returns (bytes memory) {\\n    return CronExternal.toEncodedSpec(cronString);\\n  }\\n\\n  /**\\n   * @notice Adds a cron spec to storage and the ID to the list of jobs\\n   * @param target the destination contract of a cron job\\n   * @param handler the function signature on the target contract to call\\n   * @param spec the cron spec to create\\n   */\\n  function createCronJobFromSpec(\\n    address target,\\n    bytes memory handler,\\n    Spec memory spec\\n  ) internal onlyOwner {\\n    uint256 newID = s_nextCronJobID;\\n    s_activeCronJobIDs.push(newID);\\n    s_targets[newID] = target;\\n    s_handlers[newID] = handler;\\n    s_specs[newID] = spec;\\n    s_lastRuns[newID] = block.timestamp;\\n    s_handlerSignatures[newID] = handlerSig(target, handler);\\n    s_nextCronJobID++;\\n    emit CronJobCreated(newID, target, handler);\\n  }\\n\\n  function _implementation() internal view override returns (address) {\\n    return s_delegate;\\n  }\\n\\n  /**\\n   * @notice validates the input to performUpkeep\\n   * @param id the id of the cron job\\n   * @param tickTime the observed tick time\\n   * @param target the contract to forward the tx to\\n   * @param handler the handler of the conract receiving the forwarded tx\\n   */\\n  function validate(\\n    uint256 id,\\n    uint256 tickTime,\\n    address target,\\n    bytes memory handler\\n  ) private {\\n    if (block.timestamp < tickTime) {\\n      revert TickInFuture();\\n    }\\n    if (tickTime <= s_lastRuns[id]) {\\n      revert TickTooOld();\\n    }\\n    if (!CronInternal.matches(s_specs[id], tickTime)) {\\n      revert TickDoesntMatchSpec();\\n    }\\n    if (handlerSig(target, handler) != s_handlerSignatures[id]) {\\n      revert InvalidHandler();\\n    }\\n  }\\n\\n  /**\\n   * @notice returns a unique identifier for target/handler pairs\\n   * @param target the contract to forward the tx to\\n   * @param handler the handler of the conract receiving the forwarded tx\\n   * @return a hash of the inputs\\n   */\\n  function handlerSig(address target, bytes memory handler) private pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(target, handler));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/KeeperBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract KeeperBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    if (tx.origin != address(0)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/libraries/internal/Cron.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/*\\n  The Cron contract serves two primary functions:\\n    * parsing cron-formatted strings like \\\"0 0 * * *\\\" into\\n      structs called \\\"Specs\\\"\\n    * computing the \\\"next tick\\\" of a cron spec\\n\\n  Because manipulating strings is gas-expensive in solidity,\\n  the intended use of this contract is for users to first convert\\n  their cron strings to encoded Spec structs via toEncodedSpec().\\n  Then, the user stores the Spec on chain. Finally, users use the nextTick(),\\n  function to determine the datetime of the next cron job run.\\n\\n  Cron jobs are interpreted acording to this fomat:\\n\\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\\n  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\\n  \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the month (1 - 31)\\n  \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\\n  \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the week (0 - 6) (Monday to Sunday)\\n  \u2502 \u2502 \u2502 \u2502 \u2502\\n  \u2502 \u2502 \u2502 \u2502 \u2502\\n  \u2502 \u2502 \u2502 \u2502 \u2502\\n  * * * * *\\n\\n  Special limitations:\\n    * there is no year field\\n    * no special characters: ? L W #\\n    * lists can have a max length of 26\\n    * no words like JAN / FEB or MON / TUES\\n*/\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"../../vendor/Strings.sol\\\";\\nimport \\\"../../vendor/DateTime.sol\\\";\\n\\n// The fields of a cron spec, by name\\nstring constant MINUTE = \\\"minute\\\";\\nstring constant HOUR = \\\"hour\\\";\\nstring constant DAY = \\\"day\\\";\\nstring constant MONTH = \\\"month\\\";\\nstring constant DAY_OF_WEEK = \\\"day of week\\\";\\n\\nerror UnknownFieldType();\\nerror InvalidSpec(string reason);\\nerror InvalidField(string field, string reason);\\nerror ListTooLarge();\\n\\n// Set of enums representing a cron field type\\nenum FieldType {\\n  WILD,\\n  EXACT,\\n  INTERVAL,\\n  RANGE,\\n  LIST\\n}\\n\\n// A spec represents a cron job by decomposing it into 5 fields\\nstruct Spec {\\n  Field minute;\\n  Field hour;\\n  Field day;\\n  Field month;\\n  Field dayOfWeek;\\n}\\n\\n// A field represents a single element in a cron spec. There are 5 types\\n// of fields (see above). Not all properties of this struct are present at once.\\nstruct Field {\\n  FieldType fieldType;\\n  uint8 singleValue;\\n  uint8 interval;\\n  uint8 rangeStart;\\n  uint8 rangeEnd;\\n  uint8 listLength;\\n  uint8[26] list;\\n}\\n\\n/**\\n * @title The Cron library\\n * @notice A utility contract for encoding/decoding cron strings (ex: 0 0 * * *) into an\\n * abstraction called a Spec. The library also includes a spec function, nextTick(), which\\n * determines the next time a cron job should fire based on the current block timestamp.\\n */\\nlibrary Cron {\\n  using strings for *;\\n\\n  /**\\n   * @notice nextTick calculates the next datetime that a spec \\\"ticks\\\", starting\\n   * from the current block timestamp. This is gas-intensive and therefore should\\n   * only be called off-chain.\\n   * @param spec the spec to evaluate\\n   * @return the next tick\\n   * @dev this is the internal version of the library. There is also an external version.\\n   */\\n  function nextTick(Spec memory spec) internal view returns (uint256) {\\n    uint16 year = DateTime.getYear(block.timestamp);\\n    uint8 month = DateTime.getMonth(block.timestamp);\\n    uint8 day = DateTime.getDay(block.timestamp);\\n    uint8 hour = DateTime.getHour(block.timestamp);\\n    uint8 minute = DateTime.getMinute(block.timestamp);\\n    uint8 dayOfWeek;\\n    for (; true; year++) {\\n      for (; month <= 12; month++) {\\n        if (!matches(spec.month, month)) {\\n          day = 1;\\n          hour = 0;\\n          minute = 0;\\n          continue;\\n        }\\n        uint8 maxDay = DateTime.getDaysInMonth(month, year);\\n        for (; day <= maxDay; day++) {\\n          if (!matches(spec.day, day)) {\\n            hour = 0;\\n            minute = 0;\\n            continue;\\n          }\\n          dayOfWeek = DateTime.getWeekday(DateTime.toTimestamp(year, month, day));\\n          if (!matches(spec.dayOfWeek, dayOfWeek)) {\\n            hour = 0;\\n            minute = 0;\\n            continue;\\n          }\\n          for (; hour < 24; hour++) {\\n            if (!matches(spec.hour, hour)) {\\n              minute = 0;\\n              continue;\\n            }\\n            for (; minute < 60; minute++) {\\n              if (!matches(spec.minute, minute)) {\\n                continue;\\n              }\\n              return DateTime.toTimestamp(year, month, day, hour, minute);\\n            }\\n            minute = 0;\\n          }\\n          hour = 0;\\n        }\\n        day = 1;\\n      }\\n      month = 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice lastTick calculates the previous datetime that a spec \\\"ticks\\\", starting\\n   * from the current block timestamp. This is gas-intensive and therefore should\\n   * only be called off-chain.\\n   * @param spec the spec to evaluate\\n   * @return the next tick\\n   */\\n  function lastTick(Spec memory spec) internal view returns (uint256) {\\n    uint16 year = DateTime.getYear(block.timestamp);\\n    uint8 month = DateTime.getMonth(block.timestamp);\\n    uint8 day = DateTime.getDay(block.timestamp);\\n    uint8 hour = DateTime.getHour(block.timestamp);\\n    uint8 minute = DateTime.getMinute(block.timestamp);\\n    uint8 dayOfWeek;\\n    bool resetDay;\\n    for (; true; year--) {\\n      for (; month > 0; month--) {\\n        if (!matches(spec.month, month)) {\\n          resetDay = true;\\n          hour = 23;\\n          minute = 59;\\n          continue;\\n        }\\n        if (resetDay) {\\n          day = DateTime.getDaysInMonth(month, year);\\n        }\\n        for (; day > 0; day--) {\\n          if (!matches(spec.day, day)) {\\n            hour = 23;\\n            minute = 59;\\n            continue;\\n          }\\n          dayOfWeek = DateTime.getWeekday(DateTime.toTimestamp(year, month, day));\\n          if (!matches(spec.dayOfWeek, dayOfWeek)) {\\n            hour = 23;\\n            minute = 59;\\n            continue;\\n          }\\n          for (; hour >= 0; hour--) {\\n            if (!matches(spec.hour, hour)) {\\n              minute = 59;\\n              if (hour == 0) {\\n                break;\\n              }\\n              continue;\\n            }\\n            for (; minute >= 0; minute--) {\\n              if (!matches(spec.minute, minute)) {\\n                if (minute == 0) {\\n                  break;\\n                }\\n                continue;\\n              }\\n              return DateTime.toTimestamp(year, month, day, hour, minute);\\n            }\\n            minute = 59;\\n            if (hour == 0) {\\n              break;\\n            }\\n          }\\n          hour = 23;\\n        }\\n        resetDay = true;\\n      }\\n      month = 12;\\n    }\\n  }\\n\\n  /**\\n   * @notice matches evaluates whether or not a spec \\\"ticks\\\" at a given timestamp\\n   * @param spec the spec to evaluate\\n   * @param timestamp the timestamp to compare against\\n   * @return true / false if they match\\n   */\\n  function matches(Spec memory spec, uint256 timestamp) internal view returns (bool) {\\n    DateTime._DateTime memory dt = DateTime.parseTimestamp(timestamp);\\n    return\\n      matches(spec.month, dt.month) &&\\n      matches(spec.day, dt.day) &&\\n      matches(spec.hour, dt.hour) &&\\n      matches(spec.minute, dt.minute);\\n  }\\n\\n  /**\\n   * @notice toSpec converts a cron string to a spec struct. This is gas-intensive\\n   * and therefore should only be called off-chain.\\n   * @param cronString the cron string\\n   * @return the spec struct\\n   */\\n  function toSpec(string memory cronString) internal pure returns (Spec memory) {\\n    strings.slice memory space = strings.toSlice(\\\" \\\");\\n    strings.slice memory cronSlice = strings.toSlice(cronString);\\n    if (cronSlice.count(space) != 4) {\\n      revert InvalidSpec(\\\"4 spaces required\\\");\\n    }\\n    strings.slice memory minuteSlice = cronSlice.split(space);\\n    strings.slice memory hourSlice = cronSlice.split(space);\\n    strings.slice memory daySlice = cronSlice.split(space);\\n    strings.slice memory monthSlice = cronSlice.split(space);\\n    // DEV: dayOfWeekSlice = cronSlice\\n    // The cronSlice now contains the last section of the cron job,\\n    // which corresponds to the day of week\\n    if (\\n      minuteSlice.len() == 0 ||\\n      hourSlice.len() == 0 ||\\n      daySlice.len() == 0 ||\\n      monthSlice.len() == 0 ||\\n      cronSlice.len() == 0\\n    ) {\\n      revert InvalidSpec(\\\"some fields missing\\\");\\n    }\\n    return\\n      validate(\\n        Spec({\\n          minute: sliceToField(minuteSlice),\\n          hour: sliceToField(hourSlice),\\n          day: sliceToField(daySlice),\\n          month: sliceToField(monthSlice),\\n          dayOfWeek: sliceToField(cronSlice)\\n        })\\n      );\\n  }\\n\\n  /**\\n   * @notice toEncodedSpec converts a cron string to an abi-encoded spec. This is gas-intensive\\n   * and therefore should only be called off-chain.\\n   * @param cronString the cron string\\n   * @return the abi-encoded spec\\n   */\\n  function toEncodedSpec(string memory cronString) internal pure returns (bytes memory) {\\n    return abi.encode(toSpec(cronString));\\n  }\\n\\n  /**\\n   * @notice toCronString converts a cron spec to a human-readable cron string. This is gas-intensive\\n   * and therefore should only be called off-chain.\\n   * @param spec the cron spec\\n   * @return the corresponding cron string\\n   */\\n  function toCronString(Spec memory spec) internal pure returns (string memory) {\\n    return\\n      string(\\n        bytes.concat(\\n          fieldToBstring(spec.minute),\\n          \\\" \\\",\\n          fieldToBstring(spec.hour),\\n          \\\" \\\",\\n          fieldToBstring(spec.day),\\n          \\\" \\\",\\n          fieldToBstring(spec.month),\\n          \\\" \\\",\\n          fieldToBstring(spec.dayOfWeek)\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice matches evaluates if a values matches a field.\\n   * ex: 3 matches *, 3 matches 0-5, 3 does not match 0,2,4\\n   * @param field the field struct to match against\\n   * @param value the value of a field\\n   * @return true / false if they match\\n   */\\n  function matches(Field memory field, uint8 value) private pure returns (bool) {\\n    if (field.fieldType == FieldType.WILD) {\\n      return true;\\n    } else if (field.fieldType == FieldType.INTERVAL) {\\n      return value % field.interval == 0;\\n    } else if (field.fieldType == FieldType.EXACT) {\\n      return value == field.singleValue;\\n    } else if (field.fieldType == FieldType.RANGE) {\\n      return value >= field.rangeStart && value <= field.rangeEnd;\\n    } else if (field.fieldType == FieldType.LIST) {\\n      for (uint256 idx = 0; idx < field.listLength; idx++) {\\n        if (value == field.list[idx]) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n    revert UnknownFieldType();\\n  }\\n\\n  // VALIDATIONS\\n\\n  /**\\n   * @notice validate validates a spec, reverting if any errors are found\\n   * @param spec the spec to validate\\n   * @return the original spec\\n   */\\n  function validate(Spec memory spec) private pure returns (Spec memory) {\\n    validateField(spec.minute, MINUTE, 5, 0, 59);\\n    validateField(spec.hour, HOUR, 1, 0, 23);\\n    validateField(spec.day, DAY, 1, 1, 31);\\n    validateField(spec.month, MONTH, 1, 1, 12);\\n    validateField(spec.dayOfWeek, DAY_OF_WEEK, 1, 0, 6);\\n    return spec;\\n  }\\n\\n  /**\\n   * @notice validateField validates the value of a field. It reverts if an error is found.\\n   * @param field the field to validate\\n   * @param fieldName the name of the field ex \\\"minute\\\" or \\\"hour\\\"\\n   * @param minInterval the minimum interval of the field (usually 1)\\n   * @param min the minimum value a field can have (usually 1 or 0)\\n   * @param max the maximum value a field can have (ex minute = 59, hour = 23)\\n   */\\n  function validateField(\\n    Field memory field,\\n    string memory fieldName,\\n    uint8 minInterval,\\n    uint8 min,\\n    uint8 max\\n  ) private pure {\\n    if (field.fieldType == FieldType.WILD) {\\n      return;\\n    } else if (field.fieldType == FieldType.EXACT) {\\n      if (field.singleValue < min || field.singleValue > max) {\\n        string memory reason = string(\\n          bytes.concat(\\\"value must be >=,\\\", uintToBString(min), \\\" and <=\\\", uintToBString(max))\\n        );\\n        revert InvalidField(fieldName, reason);\\n      }\\n    } else if (field.fieldType == FieldType.INTERVAL) {\\n      if (field.interval < minInterval || field.interval > max) {\\n        string memory reason = string(\\n          bytes.concat(\\\"inverval must be */(\\\", uintToBString(minInterval), \\\"-\\\", uintToBString(max), \\\")\\\")\\n        );\\n        revert InvalidField(fieldName, reason);\\n      }\\n    } else if (field.fieldType == FieldType.RANGE) {\\n      if (field.rangeEnd > max) {\\n        string memory reason = string(\\n          bytes.concat(\\\"inverval must be within \\\", uintToBString(min), \\\"-\\\", uintToBString(max))\\n        );\\n        revert InvalidField(fieldName, reason);\\n      }\\n    } else if (field.fieldType == FieldType.LIST) {\\n      if (field.listLength < 2) {\\n        revert InvalidField(fieldName, \\\"lists must have at least 2 items\\\");\\n      }\\n      string memory reason = string(\\n        bytes.concat(\\\"items in list must be within \\\", uintToBString(min), \\\"-\\\", uintToBString(max))\\n      );\\n      uint8 listItem;\\n      for (uint256 idx = 0; idx < field.listLength; idx++) {\\n        listItem = field.list[idx];\\n        if (listItem < min || listItem > max) {\\n          revert InvalidField(fieldName, reason);\\n        }\\n      }\\n    } else {\\n      revert UnknownFieldType();\\n    }\\n  }\\n\\n  /**\\n   * @notice sliceToField converts a strings.slice to a field struct\\n   * @param fieldSlice the slice of a string representing the field of a cron job\\n   * @return the field\\n   */\\n  function sliceToField(strings.slice memory fieldSlice) private pure returns (Field memory) {\\n    strings.slice memory star = strings.toSlice(\\\"*\\\");\\n    strings.slice memory dash = strings.toSlice(\\\"-\\\");\\n    strings.slice memory slash = strings.toSlice(\\\"/\\\");\\n    strings.slice memory comma = strings.toSlice(\\\",\\\");\\n    Field memory field;\\n    if (fieldSlice.equals(star)) {\\n      field.fieldType = FieldType.WILD;\\n    } else if (fieldSlice.contains(dash)) {\\n      field.fieldType = FieldType.RANGE;\\n      strings.slice memory start = fieldSlice.split(dash);\\n      field.rangeStart = sliceToUint8(start);\\n      field.rangeEnd = sliceToUint8(fieldSlice);\\n    } else if (fieldSlice.contains(slash)) {\\n      field.fieldType = FieldType.INTERVAL;\\n      fieldSlice.split(slash);\\n      field.interval = sliceToUint8(fieldSlice);\\n    } else if (fieldSlice.contains(comma)) {\\n      field.fieldType = FieldType.LIST;\\n      strings.slice memory token;\\n      while (fieldSlice.len() > 0) {\\n        if (field.listLength > 25) {\\n          revert ListTooLarge();\\n        }\\n        token = fieldSlice.split(comma);\\n        field.list[field.listLength] = sliceToUint8(token);\\n        field.listLength++;\\n      }\\n    } else {\\n      // needs input validation\\n      field.fieldType = FieldType.EXACT;\\n      field.singleValue = sliceToUint8(fieldSlice);\\n    }\\n    return field;\\n  }\\n\\n  /**\\n   * @notice fieldToBstring converts a field to the bytes representation of that field string\\n   * @param field the field to stringify\\n   * @return bytes representing the string, ex: bytes(\\\"*\\\")\\n   */\\n  function fieldToBstring(Field memory field) private pure returns (bytes memory) {\\n    if (field.fieldType == FieldType.WILD) {\\n      return \\\"*\\\";\\n    } else if (field.fieldType == FieldType.EXACT) {\\n      return uintToBString(uint256(field.singleValue));\\n    } else if (field.fieldType == FieldType.RANGE) {\\n      return bytes.concat(uintToBString(field.rangeStart), \\\"-\\\", uintToBString(field.rangeEnd));\\n    } else if (field.fieldType == FieldType.INTERVAL) {\\n      return bytes.concat(\\\"*/\\\", uintToBString(uint256(field.interval)));\\n    } else if (field.fieldType == FieldType.LIST) {\\n      bytes memory result = uintToBString(field.list[0]);\\n      for (uint256 idx = 1; idx < field.listLength; idx++) {\\n        result = bytes.concat(result, \\\",\\\", uintToBString(field.list[idx]));\\n      }\\n      return result;\\n    }\\n    revert UnknownFieldType();\\n  }\\n\\n  /**\\n   * @notice uintToBString converts a uint256 to a bytes representation of that uint as a string\\n   * @param n the number to stringify\\n   * @return bytes representing the string, ex: bytes(\\\"1\\\")\\n   */\\n  function uintToBString(uint256 n) private pure returns (bytes memory) {\\n    if (n == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint256 j = n;\\n    uint256 len;\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n    bytes memory bstr = new bytes(len);\\n    uint256 k = len;\\n    while (n != 0) {\\n      k = k - 1;\\n      uint8 temp = (48 + uint8(n - (n / 10) * 10));\\n      bytes1 b1 = bytes1(temp);\\n      bstr[k] = b1;\\n      n /= 10;\\n    }\\n    return bstr;\\n  }\\n\\n  /**\\n   * @notice sliceToUint8 converts a strings.slice to uint8\\n   * @param slice the string slice to convert to a uint8\\n   * @return the number that the string represents ex: \\\"20\\\" --> 20\\n   */\\n  function sliceToUint8(strings.slice memory slice) private pure returns (uint8) {\\n    bytes memory b = bytes(slice.toString());\\n    uint8 i;\\n    uint8 result = 0;\\n    for (i = 0; i < b.length; i++) {\\n      uint8 c = uint8(b[i]);\\n      if (c >= 48 && c <= 57) {\\n        result = result * 10 + (c - 48);\\n      }\\n    }\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/libraries/external/Cron.sol\": {\r\n      \"content\": \"pragma solidity 0.8.6;\\n\\nimport {Cron as CronInternal, Spec} from \\\"../internal/Cron.sol\\\";\\n\\n/**\\n * @title The Cron library\\n * @notice A utility contract for encoding/decoding cron strings (ex: 0 0 * * *) into an\\n * abstraction called a Spec. The library also includes a spec function, nextTick(), which\\n * determines the next time a cron job should fire based on the current block timestamp.\\n * @dev this is the external version of the library, which relies on the internal library\\n * by the same name.\\n */\\nlibrary Cron {\\n  using CronInternal for Spec;\\n  using CronInternal for string;\\n\\n  /**\\n   * @notice nextTick calculates the next datetime that a spec \\\"ticks\\\", starting\\n   * from the current block timestamp. This is gas-intensive and therefore should\\n   * only be called off-chain.\\n   * @param spec the spec to evaluate\\n   * @return the next tick\\n   */\\n  function nextTick(Spec calldata spec) public view returns (uint256) {\\n    return spec.nextTick();\\n  }\\n\\n  /**\\n   * @notice lastTick calculates the previous datetime that a spec \\\"ticks\\\", starting\\n   * from the current block timestamp. This is gas-intensive and therefore should\\n   * only be called off-chain.\\n   * @param spec the spec to evaluate\\n   * @return the next tick\\n   */\\n  function lastTick(Spec calldata spec) public view returns (uint256) {\\n    return spec.lastTick();\\n  }\\n\\n  /**\\n   * @notice matches evaluates whether or not a spec \\\"ticks\\\" at a given timestamp\\n   * @param spec the spec to evaluate\\n   * @param timestamp the timestamp to compare against\\n   * @return true / false if they match\\n   */\\n  function matches(Spec calldata spec, uint256 timestamp) public view returns (bool) {\\n    return spec.matches(timestamp);\\n  }\\n\\n  /**\\n   * @notice toSpec converts a cron string to a spec struct. This is gas-intensive\\n   * and therefore should only be called off-chain.\\n   * @param cronString the cron string\\n   * @return the spec struct\\n   */\\n  function toSpec(string calldata cronString) public pure returns (Spec memory) {\\n    return cronString.toSpec();\\n  }\\n\\n  /**\\n   * @notice toEncodedSpec converts a cron string to an abi-encoded spec. This is gas-intensive\\n   * and therefore should only be called off-chain.\\n   * @param cronString the cron string\\n   * @return the abi-encoded spec\\n   */\\n  function toEncodedSpec(string calldata cronString) public pure returns (bytes memory) {\\n    return cronString.toEncodedSpec();\\n  }\\n\\n  /**\\n   * @notice toCronString converts a cron spec to a human-readable cron string. This is gas-intensive\\n   * and therefore should only be called off-chain.\\n   * @param spec the cron spec\\n   * @return the corresponding cron string\\n   */\\n  function toCronString(Spec calldata spec) public pure returns (string memory) {\\n    return spec.toCronString();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/utils/utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\n/**\\n * @notice getRevertMsg extracts a revert reason from a failed contract call\\n */\\nfunction getRevertMsg(bytes memory payload) pure returns (string memory) {\\n  if (payload.length < 68) return \\\"transaction reverted silently\\\";\\n  assembly {\\n    payload := add(payload, 0x04)\\n  }\\n  return abi.decode(payload, (string));\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2.0\\n\\n/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\n *      modifying s to only contain the remainder of the string after the '.'.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary strings {\\n  struct slice {\\n    uint256 _len;\\n    uint256 _ptr;\\n  }\\n\\n  function memcpy(\\n    uint256 dest,\\n    uint256 src,\\n    uint256 len\\n  ) private pure {\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    uint256 mask = type(uint256).max;\\n    if (len > 0) {\\n      mask = 256**(32 - len) - 1;\\n    }\\n    assembly {\\n      let srcpart := and(mload(src), not(mask))\\n      let destpart := and(mload(dest), mask)\\n      mstore(dest, or(destpart, srcpart))\\n    }\\n  }\\n\\n  /*\\n   * @dev Returns a slice containing the entire string.\\n   * @param self The string to make a slice from.\\n   * @return A newly allocated slice containing the entire string.\\n   */\\n  function toSlice(string memory self) internal pure returns (slice memory) {\\n    uint256 ptr;\\n    assembly {\\n      ptr := add(self, 0x20)\\n    }\\n    return slice(bytes(self).length, ptr);\\n  }\\n\\n  /*\\n   * @dev Returns the length of a null-terminated bytes32 string.\\n   * @param self The value to find the length of.\\n   * @return The length of the string, from 0 to 32.\\n   */\\n  function len(bytes32 self) internal pure returns (uint256) {\\n    uint256 ret;\\n    if (self == 0) return 0;\\n    if (uint256(self) & type(uint128).max == 0) {\\n      ret += 16;\\n      self = bytes32(uint256(self) / 0x100000000000000000000000000000000);\\n    }\\n    if (uint256(self) & type(uint64).max == 0) {\\n      ret += 8;\\n      self = bytes32(uint256(self) / 0x10000000000000000);\\n    }\\n    if (uint256(self) & type(uint32).max == 0) {\\n      ret += 4;\\n      self = bytes32(uint256(self) / 0x100000000);\\n    }\\n    if (uint256(self) & type(uint16).max == 0) {\\n      ret += 2;\\n      self = bytes32(uint256(self) / 0x10000);\\n    }\\n    if (uint256(self) & type(uint8).max == 0) {\\n      ret += 1;\\n    }\\n    return 32 - ret;\\n  }\\n\\n  /*\\n   * @dev Returns a slice containing the entire bytes32, interpreted as a\\n   *      null-terminated utf-8 string.\\n   * @param self The bytes32 value to convert to a slice.\\n   * @return A new slice containing the value of the input argument up to the\\n   *         first null.\\n   */\\n  function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\\n    // Allocate space for `self` in memory, copy it there, and point ret at it\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(0x40, add(ptr, 0x20))\\n      mstore(ptr, self)\\n      mstore(add(ret, 0x20), ptr)\\n    }\\n    ret._len = len(self);\\n  }\\n\\n  /*\\n   * @dev Returns a new slice containing the same data as the current slice.\\n   * @param self The slice to copy.\\n   * @return A new slice containing the same data as `self`.\\n   */\\n  function copy(slice memory self) internal pure returns (slice memory) {\\n    return slice(self._len, self._ptr);\\n  }\\n\\n  /*\\n   * @dev Copies a slice to a new string.\\n   * @param self The slice to copy.\\n   * @return A newly allocated string containing the slice's text.\\n   */\\n  function toString(slice memory self) internal pure returns (string memory) {\\n    string memory ret = new string(self._len);\\n    uint256 retptr;\\n    assembly {\\n      retptr := add(ret, 32)\\n    }\\n\\n    memcpy(retptr, self._ptr, self._len);\\n    return ret;\\n  }\\n\\n  /*\\n   * @dev Returns the length in runes of the slice. Note that this operation\\n   *      takes time proportional to the length of the slice; avoid using it\\n   *      in loops, and call `slice.empty()` if you only need to know whether\\n   *      the slice is empty or not.\\n   * @param self The slice to operate on.\\n   * @return The length of the slice in runes.\\n   */\\n  function len(slice memory self) internal pure returns (uint256 l) {\\n    // Starting at ptr-31 means the LSB will be the byte we care about\\n    uint256 ptr = self._ptr - 31;\\n    uint256 end = ptr + self._len;\\n    for (l = 0; ptr < end; l++) {\\n      uint8 b;\\n      assembly {\\n        b := and(mload(ptr), 0xFF)\\n      }\\n      if (b < 0x80) {\\n        ptr += 1;\\n      } else if (b < 0xE0) {\\n        ptr += 2;\\n      } else if (b < 0xF0) {\\n        ptr += 3;\\n      } else if (b < 0xF8) {\\n        ptr += 4;\\n      } else if (b < 0xFC) {\\n        ptr += 5;\\n      } else {\\n        ptr += 6;\\n      }\\n    }\\n  }\\n\\n  /*\\n   * @dev Returns true if the slice is empty (has a length of 0).\\n   * @param self The slice to operate on.\\n   * @return True if the slice is empty, False otherwise.\\n   */\\n  function empty(slice memory self) internal pure returns (bool) {\\n    return self._len == 0;\\n  }\\n\\n  /*\\n   * @dev Returns a positive number if `other` comes lexicographically after\\n   *      `self`, a negative number if it comes before, or zero if the\\n   *      contents of the two slices are equal. Comparison is done per-rune,\\n   *      on unicode codepoints.\\n   * @param self The first slice to compare.\\n   * @param other The second slice to compare.\\n   * @return The result of the comparison.\\n   */\\n  function compare(slice memory self, slice memory other)\\n    internal\\n    pure\\n    returns (int256)\\n  {\\n    uint256 shortest = self._len;\\n    if (other._len < self._len) shortest = other._len;\\n\\n    uint256 selfptr = self._ptr;\\n    uint256 otherptr = other._ptr;\\n    for (uint256 idx = 0; idx < shortest; idx += 32) {\\n      uint256 a;\\n      uint256 b;\\n      assembly {\\n        a := mload(selfptr)\\n        b := mload(otherptr)\\n      }\\n      if (a != b) {\\n        // Mask out irrelevant bytes and check again\\n        uint256 mask = type(uint256).max; // 0xffff...\\n        if (shortest < 32) {\\n          mask = ~(2**(8 * (32 - shortest + idx)) - 1);\\n        }\\n        unchecked {\\n          uint256 diff = (a & mask) - (b & mask);\\n          if (diff != 0) return int256(diff);\\n        }\\n      }\\n      selfptr += 32;\\n      otherptr += 32;\\n    }\\n    return int256(self._len) - int256(other._len);\\n  }\\n\\n  /*\\n   * @dev Returns true if the two slices contain the same text.\\n   * @param self The first slice to compare.\\n   * @param self The second slice to compare.\\n   * @return True if the slices are equal, false otherwise.\\n   */\\n  function equals(slice memory self, slice memory other)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return compare(self, other) == 0;\\n  }\\n\\n  /*\\n   * @dev Extracts the first rune in the slice into `rune`, advancing the\\n   *      slice to point to the next rune and returning `self`.\\n   * @param self The slice to operate on.\\n   * @param rune The slice that will contain the first rune.\\n   * @return `rune`.\\n   */\\n  function nextRune(slice memory self, slice memory rune)\\n    internal\\n    pure\\n    returns (slice memory)\\n  {\\n    rune._ptr = self._ptr;\\n\\n    if (self._len == 0) {\\n      rune._len = 0;\\n      return rune;\\n    }\\n\\n    uint256 l;\\n    uint256 b;\\n    // Load the first byte of the rune into the LSBs of b\\n    assembly {\\n      b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)\\n    }\\n    if (b < 0x80) {\\n      l = 1;\\n    } else if (b < 0xE0) {\\n      l = 2;\\n    } else if (b < 0xF0) {\\n      l = 3;\\n    } else {\\n      l = 4;\\n    }\\n\\n    // Check for truncated codepoints\\n    if (l > self._len) {\\n      rune._len = self._len;\\n      self._ptr += self._len;\\n      self._len = 0;\\n      return rune;\\n    }\\n\\n    self._ptr += l;\\n    self._len -= l;\\n    rune._len = l;\\n    return rune;\\n  }\\n\\n  /*\\n   * @dev Returns the first rune in the slice, advancing the slice to point\\n   *      to the next rune.\\n   * @param self The slice to operate on.\\n   * @return A slice containing only the first rune from `self`.\\n   */\\n  function nextRune(slice memory self)\\n    internal\\n    pure\\n    returns (slice memory ret)\\n  {\\n    nextRune(self, ret);\\n  }\\n\\n  /*\\n   * @dev Returns the number of the first codepoint in the slice.\\n   * @param self The slice to operate on.\\n   * @return The number of the first codepoint in the slice.\\n   */\\n  function ord(slice memory self) internal pure returns (uint256 ret) {\\n    if (self._len == 0) {\\n      return 0;\\n    }\\n\\n    uint256 word;\\n    uint256 length;\\n    uint256 divisor = 2**248;\\n\\n    // Load the rune into the MSBs of b\\n    assembly {\\n      word := mload(mload(add(self, 32)))\\n    }\\n    uint256 b = word / divisor;\\n    if (b < 0x80) {\\n      ret = b;\\n      length = 1;\\n    } else if (b < 0xE0) {\\n      ret = b & 0x1F;\\n      length = 2;\\n    } else if (b < 0xF0) {\\n      ret = b & 0x0F;\\n      length = 3;\\n    } else {\\n      ret = b & 0x07;\\n      length = 4;\\n    }\\n\\n    // Check for truncated codepoints\\n    if (length > self._len) {\\n      return 0;\\n    }\\n\\n    for (uint256 i = 1; i < length; i++) {\\n      divisor = divisor / 256;\\n      b = (word / divisor) & 0xFF;\\n      if (b & 0xC0 != 0x80) {\\n        // Invalid UTF-8 sequence\\n        return 0;\\n      }\\n      ret = (ret * 64) | (b & 0x3F);\\n    }\\n\\n    return ret;\\n  }\\n\\n  /*\\n   * @dev Returns the keccak-256 hash of the slice.\\n   * @param self The slice to hash.\\n   * @return The hash of the slice.\\n   */\\n  function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n    assembly {\\n      ret := keccak256(mload(add(self, 32)), mload(self))\\n    }\\n  }\\n\\n  /*\\n   * @dev Returns true if `self` starts with `needle`.\\n   * @param self The slice to operate on.\\n   * @param needle The slice to search for.\\n   * @return True if the slice starts with the provided text, false otherwise.\\n   */\\n  function startsWith(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    if (self._len < needle._len) {\\n      return false;\\n    }\\n\\n    if (self._ptr == needle._ptr) {\\n      return true;\\n    }\\n\\n    bool equal;\\n    assembly {\\n      let length := mload(needle)\\n      let selfptr := mload(add(self, 0x20))\\n      let needleptr := mload(add(needle, 0x20))\\n      equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n    }\\n    return equal;\\n  }\\n\\n  /*\\n   * @dev If `self` starts with `needle`, `needle` is removed from the\\n   *      beginning of `self`. Otherwise, `self` is unmodified.\\n   * @param self The slice to operate on.\\n   * @param needle The slice to search for.\\n   * @return `self`\\n   */\\n  function beyond(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (slice memory)\\n  {\\n    if (self._len < needle._len) {\\n      return self;\\n    }\\n\\n    bool equal = true;\\n    if (self._ptr != needle._ptr) {\\n      assembly {\\n        let length := mload(needle)\\n        let selfptr := mload(add(self, 0x20))\\n        let needleptr := mload(add(needle, 0x20))\\n        equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n      }\\n    }\\n\\n    if (equal) {\\n      self._len -= needle._len;\\n      self._ptr += needle._len;\\n    }\\n\\n    return self;\\n  }\\n\\n  /*\\n   * @dev Returns true if the slice ends with `needle`.\\n   * @param self The slice to operate on.\\n   * @param needle The slice to search for.\\n   * @return True if the slice starts with the provided text, false otherwise.\\n   */\\n  function endsWith(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    if (self._len < needle._len) {\\n      return false;\\n    }\\n\\n    uint256 selfptr = self._ptr + self._len - needle._len;\\n\\n    if (selfptr == needle._ptr) {\\n      return true;\\n    }\\n\\n    bool equal;\\n    assembly {\\n      let length := mload(needle)\\n      let needleptr := mload(add(needle, 0x20))\\n      equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n    }\\n\\n    return equal;\\n  }\\n\\n  /*\\n   * @dev If `self` ends with `needle`, `needle` is removed from the\\n   *      end of `self`. Otherwise, `self` is unmodified.\\n   * @param self The slice to operate on.\\n   * @param needle The slice to search for.\\n   * @return `self`\\n   */\\n  function until(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (slice memory)\\n  {\\n    if (self._len < needle._len) {\\n      return self;\\n    }\\n\\n    uint256 selfptr = self._ptr + self._len - needle._len;\\n    bool equal = true;\\n    if (selfptr != needle._ptr) {\\n      assembly {\\n        let length := mload(needle)\\n        let needleptr := mload(add(needle, 0x20))\\n        equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n      }\\n    }\\n\\n    if (equal) {\\n      self._len -= needle._len;\\n    }\\n\\n    return self;\\n  }\\n\\n  // Returns the memory address of the first byte of the first occurrence of\\n  // `needle` in `self`, or the first byte after `self` if not found.\\n  function findPtr(\\n    uint256 selflen,\\n    uint256 selfptr,\\n    uint256 needlelen,\\n    uint256 needleptr\\n  ) private pure returns (uint256) {\\n    uint256 ptr = selfptr;\\n    uint256 idx;\\n\\n    if (needlelen <= selflen) {\\n      if (needlelen <= 32) {\\n        bytes32 mask;\\n        if (needlelen > 0) {\\n          mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\\n        }\\n\\n        bytes32 needledata;\\n        assembly {\\n          needledata := and(mload(needleptr), mask)\\n        }\\n\\n        uint256 end = selfptr + selflen - needlelen;\\n        bytes32 ptrdata;\\n        assembly {\\n          ptrdata := and(mload(ptr), mask)\\n        }\\n\\n        while (ptrdata != needledata) {\\n          if (ptr >= end) return selfptr + selflen;\\n          ptr++;\\n          assembly {\\n            ptrdata := and(mload(ptr), mask)\\n          }\\n        }\\n        return ptr;\\n      } else {\\n        // For long needles, use hashing\\n        bytes32 hash;\\n        assembly {\\n          hash := keccak256(needleptr, needlelen)\\n        }\\n\\n        for (idx = 0; idx <= selflen - needlelen; idx++) {\\n          bytes32 testHash;\\n          assembly {\\n            testHash := keccak256(ptr, needlelen)\\n          }\\n          if (hash == testHash) return ptr;\\n          ptr += 1;\\n        }\\n      }\\n    }\\n    return selfptr + selflen;\\n  }\\n\\n  // Returns the memory address of the first byte after the last occurrence of\\n  // `needle` in `self`, or the address of `self` if not found.\\n  function rfindPtr(\\n    uint256 selflen,\\n    uint256 selfptr,\\n    uint256 needlelen,\\n    uint256 needleptr\\n  ) private pure returns (uint256) {\\n    uint256 ptr;\\n\\n    if (needlelen <= selflen) {\\n      if (needlelen <= 32) {\\n        bytes32 mask;\\n        if (needlelen > 0) {\\n          mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\\n        }\\n\\n        bytes32 needledata;\\n        assembly {\\n          needledata := and(mload(needleptr), mask)\\n        }\\n\\n        ptr = selfptr + selflen - needlelen;\\n        bytes32 ptrdata;\\n        assembly {\\n          ptrdata := and(mload(ptr), mask)\\n        }\\n\\n        while (ptrdata != needledata) {\\n          if (ptr <= selfptr) return selfptr;\\n          ptr--;\\n          assembly {\\n            ptrdata := and(mload(ptr), mask)\\n          }\\n        }\\n        return ptr + needlelen;\\n      } else {\\n        // For long needles, use hashing\\n        bytes32 hash;\\n        assembly {\\n          hash := keccak256(needleptr, needlelen)\\n        }\\n        ptr = selfptr + (selflen - needlelen);\\n        while (ptr >= selfptr) {\\n          bytes32 testHash;\\n          assembly {\\n            testHash := keccak256(ptr, needlelen)\\n          }\\n          if (hash == testHash) return ptr + needlelen;\\n          ptr -= 1;\\n        }\\n      }\\n    }\\n    return selfptr;\\n  }\\n\\n  /*\\n   * @dev Modifies `self` to contain everything from the first occurrence of\\n   *      `needle` to the end of the slice. `self` is set to the empty slice\\n   *      if `needle` is not found.\\n   * @param self The slice to search and modify.\\n   * @param needle The text to search for.\\n   * @return `self`.\\n   */\\n  function find(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (slice memory)\\n  {\\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n    self._len -= ptr - self._ptr;\\n    self._ptr = ptr;\\n    return self;\\n  }\\n\\n  /*\\n   * @dev Modifies `self` to contain the part of the string from the start of\\n   *      `self` to the end of the first occurrence of `needle`. If `needle`\\n   *      is not found, `self` is set to the empty slice.\\n   * @param self The slice to search and modify.\\n   * @param needle The text to search for.\\n   * @return `self`.\\n   */\\n  function rfind(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (slice memory)\\n  {\\n    uint256 ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n    self._len = ptr - self._ptr;\\n    return self;\\n  }\\n\\n  /*\\n   * @dev Splits the slice, setting `self` to everything after the first\\n   *      occurrence of `needle`, and `token` to everything before it. If\\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n   *      and `token` is set to the entirety of `self`.\\n   * @param self The slice to split.\\n   * @param needle The text to search for in `self`.\\n   * @param token An output parameter to which the first token is written.\\n   * @return `token`.\\n   */\\n  function split(\\n    slice memory self,\\n    slice memory needle,\\n    slice memory token\\n  ) internal pure returns (slice memory) {\\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n    token._ptr = self._ptr;\\n    token._len = ptr - self._ptr;\\n    if (ptr == self._ptr + self._len) {\\n      // Not found\\n      self._len = 0;\\n    } else {\\n      self._len -= token._len + needle._len;\\n      self._ptr = ptr + needle._len;\\n    }\\n    return token;\\n  }\\n\\n  /*\\n   * @dev Splits the slice, setting `self` to everything after the first\\n   *      occurrence of `needle`, and returning everything before it. If\\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n   *      and the entirety of `self` is returned.\\n   * @param self The slice to split.\\n   * @param needle The text to search for in `self`.\\n   * @return The part of `self` up to the first occurrence of `delim`.\\n   */\\n  function split(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (slice memory token)\\n  {\\n    split(self, needle, token);\\n  }\\n\\n  /*\\n   * @dev Splits the slice, setting `self` to everything before the last\\n   *      occurrence of `needle`, and `token` to everything after it. If\\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n   *      and `token` is set to the entirety of `self`.\\n   * @param self The slice to split.\\n   * @param needle The text to search for in `self`.\\n   * @param token An output parameter to which the first token is written.\\n   * @return `token`.\\n   */\\n  function rsplit(\\n    slice memory self,\\n    slice memory needle,\\n    slice memory token\\n  ) internal pure returns (slice memory) {\\n    uint256 ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n    token._ptr = ptr;\\n    token._len = self._len - (ptr - self._ptr);\\n    if (ptr == self._ptr) {\\n      // Not found\\n      self._len = 0;\\n    } else {\\n      self._len -= token._len + needle._len;\\n    }\\n    return token;\\n  }\\n\\n  /*\\n   * @dev Splits the slice, setting `self` to everything before the last\\n   *      occurrence of `needle`, and returning everything after it. If\\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n   *      and the entirety of `self` is returned.\\n   * @param self The slice to split.\\n   * @param needle The text to search for in `self`.\\n   * @return The part of `self` after the last occurrence of `delim`.\\n   */\\n  function rsplit(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (slice memory token)\\n  {\\n    rsplit(self, needle, token);\\n  }\\n\\n  /*\\n   * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n   * @param self The slice to search.\\n   * @param needle The text to search for in `self`.\\n   * @return The number of occurrences of `needle` found in `self`.\\n   */\\n  function count(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (uint256 cnt)\\n  {\\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) +\\n      needle._len;\\n    while (ptr <= self._ptr + self._len) {\\n      cnt++;\\n      ptr =\\n        findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) +\\n        needle._len;\\n    }\\n  }\\n\\n  /*\\n   * @dev Returns True if `self` contains `needle`.\\n   * @param self The slice to search.\\n   * @param needle The text to search for in `self`.\\n   * @return True if `needle` is found in `self`, false otherwise.\\n   */\\n  function contains(slice memory self, slice memory needle)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return\\n      rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n  }\\n\\n  /*\\n   * @dev Returns a newly allocated string containing the concatenation of\\n   *      `self` and `other`.\\n   * @param self The first slice to concatenate.\\n   * @param other The second slice to concatenate.\\n   * @return The concatenation of the two strings.\\n   */\\n  function concat(slice memory self, slice memory other)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    string memory ret = new string(self._len + other._len);\\n    uint256 retptr;\\n    assembly {\\n      retptr := add(ret, 32)\\n    }\\n    memcpy(retptr, self._ptr, self._len);\\n    memcpy(retptr + self._len, other._ptr, other._len);\\n    return ret;\\n  }\\n\\n  /*\\n   * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n   *      newly allocated string.\\n   * @param self The delimiter to use.\\n   * @param parts A list of slices to join.\\n   * @return A newly allocated string containing all the slices in `parts`,\\n   *         joined with `self`.\\n   */\\n  function join(slice memory self, slice[] memory parts)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    if (parts.length == 0) return \\\"\\\";\\n\\n    uint256 length = self._len * (parts.length - 1);\\n    for (uint256 i = 0; i < parts.length; i++) length += parts[i]._len;\\n\\n    string memory ret = new string(length);\\n    uint256 retptr;\\n    assembly {\\n      retptr := add(ret, 32)\\n    }\\n\\n    for (uint256 i = 0; i < parts.length; i++) {\\n      memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n      retptr += parts[i]._len;\\n      if (i < parts.length - 1) {\\n        memcpy(retptr, self._ptr, self._len);\\n        retptr += self._len;\\n      }\\n    }\\n\\n    return ret;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// sourced from https://github.com/pipermerriam/ethereum-datetime\\n\\npragma solidity ^0.8.0;\\n\\nlibrary DateTime {\\n  /*\\n   *  Date and Time utilities for ethereum contracts\\n   *\\n   */\\n  struct _DateTime {\\n    uint16 year;\\n    uint8 month;\\n    uint8 day;\\n    uint8 hour;\\n    uint8 minute;\\n    uint8 second;\\n    uint8 weekday;\\n  }\\n\\n  uint256 constant DAY_IN_SECONDS = 86400;\\n  uint256 constant YEAR_IN_SECONDS = 31536000;\\n  uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n  uint256 constant HOUR_IN_SECONDS = 3600;\\n  uint256 constant MINUTE_IN_SECONDS = 60;\\n\\n  uint16 constant ORIGIN_YEAR = 1970;\\n\\n  function isLeapYear(uint16 year) internal pure returns (bool) {\\n    if (year % 4 != 0) {\\n      return false;\\n    }\\n    if (year % 100 != 0) {\\n      return true;\\n    }\\n    if (year % 400 != 0) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  function leapYearsBefore(uint256 year) internal pure returns (uint256) {\\n    year -= 1;\\n    return year / 4 - year / 100 + year / 400;\\n  }\\n\\n  function getDaysInMonth(uint8 month, uint16 year)\\n    internal\\n    pure\\n    returns (uint8)\\n  {\\n    if (\\n      month == 1 ||\\n      month == 3 ||\\n      month == 5 ||\\n      month == 7 ||\\n      month == 8 ||\\n      month == 10 ||\\n      month == 12\\n    ) {\\n      return 31;\\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n      return 30;\\n    } else if (isLeapYear(year)) {\\n      return 29;\\n    } else {\\n      return 28;\\n    }\\n  }\\n\\n  function parseTimestamp(uint256 timestamp)\\n    internal\\n    pure\\n    returns (_DateTime memory dt)\\n  {\\n    uint256 secondsAccountedFor = 0;\\n    uint256 buf;\\n    uint8 i;\\n\\n    // Year\\n    dt.year = getYear(timestamp);\\n    buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\n\\n    // Month\\n    uint256 secondsInMonth;\\n    for (i = 1; i <= 12; i++) {\\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\n      if (secondsInMonth + secondsAccountedFor > timestamp) {\\n        dt.month = i;\\n        break;\\n      }\\n      secondsAccountedFor += secondsInMonth;\\n    }\\n\\n    // Day\\n    for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\\n      if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\n        dt.day = i;\\n        break;\\n      }\\n      secondsAccountedFor += DAY_IN_SECONDS;\\n    }\\n\\n    // Hour\\n    dt.hour = getHour(timestamp);\\n\\n    // Minute\\n    dt.minute = getMinute(timestamp);\\n\\n    // Second\\n    dt.second = getSecond(timestamp);\\n\\n    // Day of week.\\n    dt.weekday = getWeekday(timestamp);\\n  }\\n\\n  function getYear(uint256 timestamp) internal pure returns (uint16) {\\n    uint256 secondsAccountedFor = 0;\\n    uint16 year;\\n    uint256 numLeapYears;\\n\\n    // Year\\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n    secondsAccountedFor +=\\n      YEAR_IN_SECONDS *\\n      (year - ORIGIN_YEAR - numLeapYears);\\n\\n    while (secondsAccountedFor > timestamp) {\\n      if (isLeapYear(uint16(year - 1))) {\\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        secondsAccountedFor -= YEAR_IN_SECONDS;\\n      }\\n      year -= 1;\\n    }\\n    return year;\\n  }\\n\\n  function getMonth(uint256 timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).month;\\n  }\\n\\n  function getDay(uint256 timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).day;\\n  }\\n\\n  function getHour(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60 / 60) % 24);\\n  }\\n\\n  function getMinute(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60) % 60);\\n  }\\n\\n  function getSecond(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8(timestamp % 60);\\n  }\\n\\n  function getWeekday(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day\\n  ) internal pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, 0, 0, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour\\n  ) internal pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, hour, 0, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour,\\n    uint8 minute\\n  ) internal pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, hour, minute, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour,\\n    uint8 minute,\\n    uint8 second\\n  ) internal pure returns (uint256 timestamp) {\\n    uint16 i;\\n\\n    // Year\\n    for (i = ORIGIN_YEAR; i < year; i++) {\\n      if (isLeapYear(i)) {\\n        timestamp += LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        timestamp += YEAR_IN_SECONDS;\\n      }\\n    }\\n\\n    // Month\\n    uint8[12] memory monthDayCounts;\\n    monthDayCounts[0] = 31;\\n    if (isLeapYear(year)) {\\n      monthDayCounts[1] = 29;\\n    } else {\\n      monthDayCounts[1] = 28;\\n    }\\n    monthDayCounts[2] = 31;\\n    monthDayCounts[3] = 30;\\n    monthDayCounts[4] = 31;\\n    monthDayCounts[5] = 30;\\n    monthDayCounts[6] = 31;\\n    monthDayCounts[7] = 31;\\n    monthDayCounts[8] = 30;\\n    monthDayCounts[9] = 31;\\n    monthDayCounts[10] = 30;\\n    monthDayCounts[11] = 31;\\n\\n    for (i = 1; i < month; i++) {\\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\n    }\\n\\n    // Day\\n    timestamp += DAY_IN_SECONDS * (day - 1);\\n\\n    // Hour\\n    timestamp += HOUR_IN_SECONDS * (hour);\\n\\n    // Minute\\n    timestamp += MINUTE_IN_SECONDS * (minute);\\n\\n    // Second\\n    timestamp += second;\\n\\n    return timestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/CronUpkeepTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"../upkeeps/CronUpkeep.sol\\\";\\nimport {Cron, Spec} from \\\"../libraries/internal/Cron.sol\\\";\\n\\n/**\\n * @title The CronUpkeepTestHelper contract\\n * @notice This contract exposes core functionality of the CronUpkeep contract.\\n * It is only intended for use in tests.\\n */\\ncontract CronUpkeepTestHelper is CronUpkeep {\\n  using Cron for Spec;\\n  using Cron for string;\\n\\n  constructor(address owner, address delegate) CronUpkeep(owner, delegate) {}\\n\\n  /**\\n   * @notice createCronJobFromString is a helper function for creating cron jobs\\n   * directly from strings. This is gas-intensive and shouldn't be done outside\\n   * of testing environments.\\n   */\\n  function createCronJobFromString(\\n    address target,\\n    bytes memory handler,\\n    string memory cronString\\n  ) external {\\n    Spec memory spec = cronString.toSpec();\\n    createCronJobFromSpec(target, handler, spec);\\n  }\\n\\n  /**\\n   * @notice txCheckUpkeep is a helper function for sending real txs to the\\n   * checkUpkeep function. This allows us to do gas analysis on it.\\n   */\\n  function txCheckUpkeep(bytes calldata checkData) external {\\n    address(this).call(abi.encodeWithSelector(bytes4(keccak256(\\\"checkUpkeep(bytes)\\\")), checkData));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/CronTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport {Cron as CronInternal, Spec} from \\\"../libraries/internal/Cron.sol\\\";\\nimport {Cron as CronExternal} from \\\"../libraries/external/Cron.sol\\\";\\n\\n/**\\n * @title The CronInternalTestHelper contract\\n * @notice This contract exposes core functionality of the internal/Cron library.\\n * It is only intended for use in tests.\\n */\\ncontract CronInternalTestHelper {\\n  /**\\n   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to convert and encode\\n   * @return the abi encoding of the Spec struct representing the cron string\\n   */\\n  function encodeCronString(string memory cronString) external pure returns (bytes memory) {\\n    return CronInternal.toEncodedSpec(cronString);\\n  }\\n\\n  /**\\n   * @notice encodedSpecToString is a helper function for turning an\\n   * encoded spec back into a string. There is limited or no use for this outside\\n   * of tests.\\n   */\\n  function encodedSpecToString(bytes memory encodedSpec) public pure returns (string memory) {\\n    Spec memory spec = abi.decode(encodedSpec, (Spec));\\n    return CronInternal.toCronString(spec);\\n  }\\n\\n  /**\\n   * @notice encodedSpecToString is a helper function for turning a string\\n   * into a spec struct.\\n   */\\n  function cronStringtoEncodedSpec(string memory cronString) public pure returns (Spec memory) {\\n    return CronInternal.toSpec(cronString);\\n  }\\n\\n  /**\\n   * @notice calculateNextTick calculates the next time a cron job should \\\"tick\\\".\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to consider\\n   * @return the timestamp in UTC of the next \\\"tick\\\"\\n   */\\n  function calculateNextTick(string memory cronString) external view returns (uint256) {\\n    return CronInternal.nextTick(CronInternal.toSpec(cronString));\\n  }\\n\\n  /**\\n   * @notice calculateLastTick calculates the last time a cron job \\\"ticked\\\".\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to consider\\n   * @return the timestamp in UTC of the last \\\"tick\\\"\\n   */\\n  function calculateLastTick(string memory cronString) external view returns (uint256) {\\n    return CronInternal.lastTick(CronInternal.toSpec(cronString));\\n  }\\n}\\n\\n/**\\n * @title The CronExternalTestHelper contract\\n * @notice This contract exposes core functionality of the external/Cron library.\\n * It is only intended for use in tests.\\n */\\ncontract CronExternalTestHelper {\\n  /**\\n   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to convert and encode\\n   * @return the abi encoding of the Spec struct representing the cron string\\n   */\\n  function encodeCronString(string memory cronString) external pure returns (bytes memory) {\\n    return CronExternal.toEncodedSpec(cronString);\\n  }\\n\\n  /**\\n   * @notice encodedSpecToString is a helper function for turning an\\n   * encoded spec back into a string. There is limited or no use for this outside\\n   * of tests.\\n   */\\n  function encodedSpecToString(bytes memory encodedSpec) public pure returns (string memory) {\\n    Spec memory spec = abi.decode(encodedSpec, (Spec));\\n    return CronExternal.toCronString(spec);\\n  }\\n\\n  /**\\n   * @notice encodedSpecToString is a helper function for turning a string\\n   * into a spec struct.\\n   */\\n  function cronStringtoEncodedSpec(string memory cronString) public pure returns (Spec memory) {\\n    return CronExternal.toSpec(cronString);\\n  }\\n\\n  /**\\n   * @notice calculateNextTick calculates the next time a cron job should \\\"tick\\\".\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to consider\\n   * @return the timestamp in UTC of the next \\\"tick\\\"\\n   */\\n  function calculateNextTick(string memory cronString) external view returns (uint256) {\\n    return CronExternal.nextTick(CronExternal.toSpec(cronString));\\n  }\\n\\n  /**\\n   * @notice calculateLastTick calculates the last time a cron job \\\"ticked\\\".\\n   * This should only be called off-chain, as it is gas expensive!\\n   * @param cronString the cron string to consider\\n   * @return the timestamp in UTC of the last \\\"tick\\\"\\n   */\\n  function calculateLastTick(string memory cronString) external view returns (uint256) {\\n    return CronExternal.lastTick(CronExternal.toSpec(cronString));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/upkeeps/CronUpkeepDelegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport {Cron, Spec} from \\\"../libraries/internal/Cron.sol\\\";\\n\\n/**\\n * @title The CronUpkeepDelegate contract\\n * @notice This contract serves as a delegate for all instances of CronUpkeep. Those contracts\\n * delegate their checkUpkeep calls onto this contract. Utilizing this pattern reduces the size\\n * of the CronUpkeep contracts.\\n */\\ncontract CronUpkeepDelegate {\\n  using Cron for Spec;\\n\\n  address private s_owner; // from ConfirmedOwner\\n  address private s_delegate;\\n  uint256 private s_nextCronJobID;\\n  uint256[] private s_activeCronJobIDs;\\n  mapping(uint256 => uint256) private s_lastRuns;\\n  mapping(uint256 => Spec) private s_specs;\\n  mapping(uint256 => address) private s_targets;\\n  mapping(uint256 => bytes) private s_handlers;\\n\\n  /**\\n   * @notice Get the id of an eligible cron job\\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding\\n   * of the id and \\\"next tick\\\" of the elligible cron job\\n   */\\n  function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\\n    // DEV: start at a random spot in the list so that checks are\\n    // spread evenly among cron jobs\\n    uint256 numCrons = s_activeCronJobIDs.length;\\n    uint256 startIdx = block.number % numCrons;\\n    bool result;\\n    bytes memory payload;\\n    (result, payload) = checkInRange(startIdx, numCrons);\\n    if (result) {\\n      return (result, payload);\\n    }\\n    (result, payload) = checkInRange(0, startIdx);\\n    if (result) {\\n      return (result, payload);\\n    }\\n    return (false, bytes(\\\"\\\"));\\n  }\\n\\n  /**\\n   * @notice checks the cron jobs in a given range\\n   * @param start the starting id to check (inclusive)\\n   * @param end the ending id to check (exclusive)\\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding\\n   * of the id and \\\"next tick\\\" of the elligible cron job\\n   */\\n  function checkInRange(uint256 start, uint256 end) private view returns (bool, bytes memory) {\\n    uint256 id;\\n    uint256 lastTick;\\n    for (uint256 idx = start; idx < end; idx++) {\\n      id = s_activeCronJobIDs[idx];\\n      lastTick = s_specs[id].lastTick();\\n      if (lastTick > s_lastRuns[id]) {\\n        return (true, abi.encode(id, lastTick, s_targets[id], s_handlers[id]));\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/factories/CronUpkeepFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"../upkeeps/CronUpkeep.sol\\\";\\nimport \\\"../upkeeps/CronUpkeepDelegate.sol\\\";\\n\\n/**\\n * @title The CronUpkeepFactory contract\\n * @notice This contract serves as a delegate for all instances of CronUpkeep. Those contracts\\n * delegate their checkUpkeep calls onto this contract. Utilizing this pattern reduces the size\\n * of the CronUpkeep contracts.\\n */\\ncontract CronUpkeepFactory {\\n  event NewCronUpkeepCreated(address upkeep, address owner);\\n\\n  address private immutable s_cronDelegate;\\n\\n  constructor() {\\n    s_cronDelegate = address(new CronUpkeepDelegate());\\n  }\\n\\n  /**\\n   * @notice Creates a new CronUpkeep contract, with msg.sender as the owner\\n   */\\n  function newCronUpkeep() public {\\n    emit NewCronUpkeepCreated(address(new CronUpkeep(msg.sender, s_cronDelegate)), msg.sender);\\n  }\\n\\n  /**\\n   * @notice Gets the address of the delegate contract\\n   * @return the address of the delegate contract\\n   */\\n  function cronDelegateAddress() public view returns (address) {\\n    return s_cronDelegate;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/KeeperCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./KeeperBase.sol\\\";\\nimport \\\"./interfaces/KeeperCompatibleInterface.sol\\\";\\n\\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\\n\"\r\n    },\r\n    \"src/v0.8/tests/KeeperCompatibleTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../KeeperCompatible.sol\\\";\\n\\ncontract KeeperCompatibleTestHelper is KeeperCompatible {\\n  function checkUpkeep(bytes calldata) external override returns (bool, bytes memory) {}\\n\\n  function performUpkeep(bytes calldata) external override {}\\n\\n  function testCannotExecute() public view cannotExecute {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/EthBalanceMonitorExposed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"../upkeeps/EthBalanceMonitor.sol\\\";\\n\\ncontract EthBalanceMonitorExposed is EthBalanceMonitor {\\n  constructor(address keeperRegistryAddress, uint256 minWaitPeriod)\\n    EthBalanceMonitor(keeperRegistryAddress, minWaitPeriod)\\n  {}\\n\\n  function setLastTopUpXXXTestOnly(address target, uint56 lastTopUpTimestamp) external {\\n    s_targets[target].lastTopUpTimestamp = lastTopUpTimestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../dev/VRF.sol\\\";\\n\\n/** ***********************************************************************\\n    @notice Testing harness for VRF.sol, exposing its internal methods. Not to\\n    @notice be used for production.\\n*/\\ncontract VRFTestHelper is VRF {\\n  function bigModExp_(uint256 base, uint256 exponent) public view returns (uint256) {\\n    return super.bigModExp(base, exponent);\\n  }\\n\\n  function squareRoot_(uint256 x) public view returns (uint256) {\\n    return super.squareRoot(x);\\n  }\\n\\n  function ySquared_(uint256 x) public pure returns (uint256) {\\n    return super.ySquared(x);\\n  }\\n\\n  function fieldHash_(bytes memory b) public pure returns (uint256) {\\n    return super.fieldHash(b);\\n  }\\n\\n  function hashToCurve_(uint256[2] memory pk, uint256 x) public view returns (uint256[2] memory) {\\n    return super.hashToCurve(pk, x);\\n  }\\n\\n  function ecmulVerify_(\\n    uint256[2] memory x,\\n    uint256 scalar,\\n    uint256[2] memory q\\n  ) public pure returns (bool) {\\n    return super.ecmulVerify(x, scalar, q);\\n  }\\n\\n  function projectiveECAdd_(\\n    uint256 px,\\n    uint256 py,\\n    uint256 qx,\\n    uint256 qy\\n  )\\n    public\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return super.projectiveECAdd(px, py, qx, qy);\\n  }\\n\\n  function affineECAdd_(\\n    uint256[2] memory p1,\\n    uint256[2] memory p2,\\n    uint256 invZ\\n  ) public pure returns (uint256[2] memory) {\\n    return super.affineECAdd(p1, p2, invZ);\\n  }\\n\\n  function verifyLinearCombinationWithGenerator_(\\n    uint256 c,\\n    uint256[2] memory p,\\n    uint256 s,\\n    address lcWitness\\n  ) public pure returns (bool) {\\n    return super.verifyLinearCombinationWithGenerator(c, p, s, lcWitness);\\n  }\\n\\n  function linearCombination_(\\n    uint256 c,\\n    uint256[2] memory p1,\\n    uint256[2] memory cp1Witness,\\n    uint256 s,\\n    uint256[2] memory p2,\\n    uint256[2] memory sp2Witness,\\n    uint256 zInv\\n  ) public pure returns (uint256[2] memory) {\\n    return super.linearCombination(c, p1, cp1Witness, s, p2, sp2Witness, zInv);\\n  }\\n\\n  function scalarFromCurvePoints_(\\n    uint256[2] memory hash,\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    address uWitness,\\n    uint256[2] memory v\\n  ) public pure returns (uint256) {\\n    return super.scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\\n  }\\n\\n  function isOnCurve_(uint256[2] memory p) public pure returns (bool) {\\n    return super.isOnCurve(p);\\n  }\\n\\n  function verifyVRFProof_(\\n    uint256[2] memory pk,\\n    uint256[2] memory gamma,\\n    uint256 c,\\n    uint256 s,\\n    uint256 seed,\\n    address uWitness,\\n    uint256[2] memory cGammaWitness,\\n    uint256[2] memory sHashWitness,\\n    uint256 zInv\\n  ) public view {\\n    super.verifyVRFProof(pk, gamma, c, s, seed, uWitness, cGammaWitness, sHashWitness, zInv);\\n  }\\n\\n  function randomValueFromVRFProof_(Proof memory proof, uint256 seed) public view returns (uint256 output) {\\n    return super.randomValueFromVRFProof(proof, seed);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFOwnerlessConsumerExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// An example VRF V1 consumer contract that can be triggered using a transferAndCall from the link\\n// contract.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../VRFConsumerBase.sol\\\";\\nimport \\\"../interfaces/ERC677ReceiverInterface.sol\\\";\\n\\ncontract VRFOwnerlessConsumerExample is VRFConsumerBase, ERC677ReceiverInterface {\\n  uint256 public s_randomnessOutput;\\n  bytes32 public s_requestId;\\n\\n  error OnlyCallableFromLink();\\n\\n  constructor(address _vrfCoordinator, address _link) VRFConsumerBase(_vrfCoordinator, _link) {\\n    /* empty */\\n  }\\n\\n  function fulfillRandomness(bytes32 requestId, uint256 _randomness) internal override {\\n    require(requestId == s_requestId, \\\"request ID is incorrect\\\");\\n    s_randomnessOutput = _randomness;\\n  }\\n\\n  /**\\n   * @dev Creates a new randomness request. This function can only be used by calling\\n   * transferAndCall on the LinkToken contract.\\n   * @param _amount The amount of LINK transferred to pay for this request.\\n   * @param _data The data passed to transferAndCall on LinkToken. Must be an abi-encoded key hash.\\n   */\\n  function onTokenTransfer(\\n    address, /* sender */\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external override {\\n    if (msg.sender != address(LINK)) {\\n      revert OnlyCallableFromLink();\\n    }\\n\\n    bytes32 keyHash = abi.decode(_data, (bytes32));\\n    s_requestId = requestRandomness(keyHash, _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../VRFConsumerBase.sol\\\";\\n\\ncontract VRFConsumer is VRFConsumerBase {\\n  uint256 public randomnessOutput;\\n  bytes32 public requestId;\\n\\n  constructor(address vrfCoordinator, address link)\\n    // solhint-disable-next-line no-empty-blocks\\n    VRFConsumerBase(vrfCoordinator, link)\\n  {\\n    /* empty */\\n  }\\n\\n  function fulfillRandomness(\\n    bytes32, /* requestId */\\n    uint256 randomness\\n  ) internal override {\\n    randomnessOutput = randomness;\\n    requestId = requestId;\\n  }\\n\\n  function testRequestRandomness(bytes32 keyHash, uint256 fee) external returns (bytes32) {\\n    return requestRandomness(keyHash, fee);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/VRFRequestIDBaseTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../VRFRequestIDBase.sol\\\";\\n\\ncontract VRFRequestIDBaseTestHelper is VRFRequestIDBase {\\n  function makeVRFInputSeed_(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) public pure returns (uint256) {\\n    return makeVRFInputSeed(_keyHash, _userSeed, _requester, _nonce);\\n  }\\n\\n  function makeRequestId_(bytes32 _keyHash, uint256 _vRFInputSeed) public pure returns (bytes32) {\\n    return makeRequestId(_keyHash, _vRFInputSeed);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/mocks/VRFCoordinatorMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"../VRFConsumerBase.sol\\\";\\n\\ncontract VRFCoordinatorMock {\\n  LinkTokenInterface public LINK;\\n\\n  event RandomnessRequest(address indexed sender, bytes32 indexed keyHash, uint256 indexed seed);\\n\\n  constructor(address linkAddress) public {\\n    LINK = LinkTokenInterface(linkAddress);\\n  }\\n\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 fee,\\n    bytes memory _data\\n  ) public onlyLINK {\\n    (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\\n    emit RandomnessRequest(sender, keyHash, seed);\\n  }\\n\\n  function callBackWithRandomness(\\n    bytes32 requestId,\\n    uint256 randomness,\\n    address consumerContract\\n  ) public {\\n    VRFConsumerBase v;\\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomness.selector, requestId, randomness);\\n    uint256 b = 206000;\\n    require(gasleft() >= b, \\\"not enough gas for consumer\\\");\\n    (bool success, ) = consumerContract.call(resp);\\n  }\\n\\n  modifier onlyLINK() {\\n    require(msg.sender == address(LINK), \\\"Must use LINK token\\\");\\n    _;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"blockhashStore\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkEthFeed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"internalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"externalBalance\",\"type\":\"uint256\"}],\"name\":\"BalanceInvariantViolated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"BlockhashNotInStore\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"have\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"want\",\"type\":\"uint32\"}],\"name\":\"GasLimitTooBig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectCommitment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"InsufficientGasForConsumer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCalldata\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"InvalidConsumer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"linkWei\",\"type\":\"int256\"}],\"name\":\"InvalidLinkWeiPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"have\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"min\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"max\",\"type\":\"uint16\"}],\"name\":\"InvalidRequestConfirmations\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSubscription\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"MustBeRequestedOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"MustBeSubOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoCorrespondingRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"NoSuchProvingKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"have\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"want\",\"type\":\"uint32\"}],\"name\":\"NumWordsTooBig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableFromLink\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingRequestExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"ProvingKeyAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyConsumers\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"stalenessSeconds\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"gasAfterPaymentCalculation\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"fallbackWeiPerUnitLink\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier5\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier2\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier3\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier4\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier5\",\"type\":\"uint24\"}],\"indexed\":false,\"internalType\":\"struct VRFCoordinatorV2.FeeConfig\",\"name\":\"feeConfig\",\"type\":\"tuple\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"ProvingKeyDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"ProvingKeyRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"RandomWordsFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"preSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RandomWordsRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SubscriptionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"SubscriptionConsumerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"SubscriptionConsumerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SubscriptionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"SubscriptionFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SubscriptionOwnerTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SubscriptionOwnerTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BLOCKHASH_STORE\",\"outputs\":[{\"internalType\":\"contract BlockhashStoreInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK_ETH_FEED\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CONSUMERS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_NUM_WORDS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REQUEST_CONFIRMATIONS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"acceptSubscriptionOwnerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"addConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"cancelSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createSubscription\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"publicProvingKey\",\"type\":\"uint256[2]\"}],\"name\":\"deregisterProvingKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"pk\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"gamma\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uWitness\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"cGammaWitness\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"sHashWitness\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"zInv\",\"type\":\"uint256\"}],\"internalType\":\"struct VRF.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"internalType\":\"struct VRFCoordinatorV2.RequestCommitment\",\"name\":\"rc\",\"type\":\"tuple\"}],\"name\":\"fulfillRandomWords\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getCommitment\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"maxGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"stalenessSeconds\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gasAfterPaymentCalculation\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSubId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackWeiPerUnitLink\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeConfig\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier5\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier2\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier3\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier4\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier5\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"reqCount\",\"type\":\"uint64\"}],\"name\":\"getFeeTier\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequestConfig\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"getSubscription\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"reqCount\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"consumers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"publicKey\",\"type\":\"uint256[2]\"}],\"name\":\"hashOfKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"oracleWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"ownerCancelSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"pendingRequestExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"publicProvingKey\",\"type\":\"uint256[2]\"}],\"name\":\"registerProvingKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"removeConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"requestRandomWords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"requestSubscriptionOwnerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"minimumRequestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"maxGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"stalenessSeconds\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gasAfterPaymentCalculation\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"fallbackWeiPerUnitLink\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fulfillmentFlatFeeLinkPPMTier5\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier2\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier3\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier4\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"reqsForTier5\",\"type\":\"uint24\"}],\"internalType\":\"struct VRFCoordinatorV2.FeeConfig\",\"name\":\"feeConfig\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "VRFCoordinatorV2", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000404460c6a5ede2d891e8297795264fde62adbb75000000000000000000000000fa390a2e7c3c3bc2f97fe63f11ef21bac455f121000000000000000000000000b38722f6a608646a538e882ee9972d15c86fc597", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}