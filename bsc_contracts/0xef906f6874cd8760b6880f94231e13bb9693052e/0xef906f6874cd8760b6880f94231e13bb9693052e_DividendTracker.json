{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ScroogeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(\\r\\n        address account\\r\\n    ) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual returns (bool) {\\r\\n        _allowances[owner][spender] = amount;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint256 addedValue\\r\\n    ) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint256 subtractedValue\\r\\n    ) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(\\r\\n            currentAllowance >= subtractedValue,\\r\\n            \\\"ERC20: decreased allowance below zero\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(\\r\\n            fromBalance >= amount,\\r\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(\\r\\n                currentAllowance >= amount,\\r\\n                \\\"ERC20: insufficient allowance\\\"\\r\\n            );\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler's built in overflow checks.\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function tryAdd(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    ) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function trySub(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    ) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMul(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    ) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryDiv(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    ) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMod(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    ) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathUint {\\r\\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n        int256 b = int256(a);\\r\\n        require(b >= 0);\\r\\n        return b;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface DividendPayingTokenInterface {\\r\\n    function dividendOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    event DividendsDistributed(address indexed from, uint256 weiAmount);\\r\\n\\r\\n    event DividendWithdrawn(address indexed to, uint256 weiAmount);\\r\\n}\\r\\n\\r\\ninterface DividendPayingTokenOptionalInterface {\\r\\n    function withdrawableDividendOf(\\r\\n        address _owner\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function withdrawnDividendOf(\\r\\n        address _owner\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function accumulativeDividendOf(\\r\\n        address _owner\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract DividendPayingToken is\\r\\n    ERC20,\\r\\n    DividendPayingTokenInterface,\\r\\n    DividendPayingTokenOptionalInterface\\r\\n{\\r\\n    using SafeMathUint for uint256;\\r\\n    using SafeMathInt for int256;\\r\\n\\r\\n    uint256 internal constant magnitude = 2 ** 128;\\r\\n\\r\\n    uint256 internal magnifiedDividendPerShare;\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 9;\\r\\n    }\\r\\n\\r\\n    mapping(address => int256) internal magnifiedDividendCorrections;\\r\\n    mapping(address => uint256) internal withdrawnDividends;\\r\\n\\r\\n    uint256 public totalDividendsDistributed;\\r\\n\\r\\n    address public rewardToken;\\r\\n\\r\\n    constructor(\\r\\n        address _rewardToken,\\r\\n        string memory _name,\\r\\n        string memory _symbol\\r\\n    ) ERC20(_name, _symbol) {\\r\\n        rewardToken = _rewardToken;\\r\\n    }\\r\\n\\r\\n    function distributeDividends(uint256 amount) public {\\r\\n        require(totalSupply() > 0);\\r\\n\\r\\n        uint256 balBefore = IERC20(rewardToken).balanceOf(address(this));\\r\\n        IERC20(rewardToken).transferFrom(msg.sender, address(this), amount);\\r\\n        uint256 received = IERC20(rewardToken).balanceOf(address(this)) -\\r\\n            balBefore;\\r\\n\\r\\n        if (received > 0) {\\r\\n            magnifiedDividendPerShare =\\r\\n                magnifiedDividendPerShare +\\r\\n                ((received * magnitude) / totalSupply());\\r\\n\\r\\n            emit DividendsDistributed(msg.sender, received);\\r\\n\\r\\n            totalDividendsDistributed = totalDividendsDistributed + received;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _withdrawDividend(address account) internal returns (uint256) {\\r\\n        uint256 withdrawableDividend = withdrawableDividendOf(account);\\r\\n\\r\\n        if (withdrawableDividend > 0) {\\r\\n            withdrawnDividends[account] =\\r\\n                withdrawnDividends[account] +\\r\\n                withdrawableDividend;\\r\\n\\r\\n            try\\r\\n                IERC20(rewardToken).transfer(account, withdrawableDividend)\\r\\n            returns (bool) {\\r\\n                emit DividendWithdrawn(account, withdrawableDividend);\\r\\n\\r\\n                return withdrawableDividend;\\r\\n            } catch {\\r\\n                withdrawnDividends[account] =\\r\\n                    withdrawnDividends[account] -\\r\\n                    withdrawableDividend;\\r\\n\\r\\n                return 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function dividendOf(\\r\\n        address account\\r\\n    ) public view override returns (uint256) {\\r\\n        return withdrawableDividendOf(account);\\r\\n    }\\r\\n\\r\\n    function withdrawableDividendOf(\\r\\n        address account\\r\\n    ) public view override returns (uint256) {\\r\\n        return accumulativeDividendOf(account) - withdrawnDividends[account];\\r\\n    }\\r\\n\\r\\n    function withdrawnDividendOf(\\r\\n        address account\\r\\n    ) public view override returns (uint256) {\\r\\n        return withdrawnDividends[account];\\r\\n    }\\r\\n\\r\\n    function accumulativeDividendOf(\\r\\n        address account\\r\\n    ) public view override returns (uint256) {\\r\\n        return\\r\\n            ((magnifiedDividendPerShare * balanceOf(account)).toInt256Safe() +\\r\\n                magnifiedDividendCorrections[account]).toUint256Safe() /\\r\\n            magnitude;\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 value) internal override {\\r\\n        super._mint(account, value);\\r\\n\\r\\n        magnifiedDividendCorrections[account] =\\r\\n            magnifiedDividendCorrections[account] -\\r\\n            (magnifiedDividendPerShare * value).toInt256Safe();\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 value) internal override {\\r\\n        super._burn(account, value);\\r\\n\\r\\n        magnifiedDividendCorrections[account] =\\r\\n            magnifiedDividendCorrections[account] +\\r\\n            (magnifiedDividendPerShare * value).toInt256Safe();\\r\\n    }\\r\\n\\r\\n    function _setBalance(address account, uint256 newBalance) internal {\\r\\n        uint256 currentBalance = balanceOf(account);\\r\\n\\r\\n        if (newBalance > currentBalance)\\r\\n            _mint(account, newBalance - currentBalance);\\r\\n        else if (newBalance < currentBalance)\\r\\n            _burn(account, currentBalance - newBalance);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary IterableMapping {\\r\\n    // Iterable mapping from address to uint;\\r\\n    struct Map {\\r\\n        address[] keys;\\r\\n        mapping(address => uint) values;\\r\\n        mapping(address => uint) indexOf;\\r\\n        mapping(address => bool) inserted;\\r\\n    }\\r\\n\\r\\n    function get(Map storage map, address key) public view returns (uint) {\\r\\n        return map.values[key];\\r\\n    }\\r\\n\\r\\n    function getIndexOfKey(\\r\\n        Map storage map,\\r\\n        address key\\r\\n    ) public view returns (int) {\\r\\n        if (!map.inserted[key]) {\\r\\n            return -1;\\r\\n        }\\r\\n        return int(map.indexOf[key]);\\r\\n    }\\r\\n\\r\\n    function getKeyAtIndex(\\r\\n        Map storage map,\\r\\n        uint index\\r\\n    ) public view returns (address) {\\r\\n        return map.keys[index];\\r\\n    }\\r\\n\\r\\n    function size(Map storage map) public view returns (uint) {\\r\\n        return map.keys.length;\\r\\n    }\\r\\n\\r\\n    function set(Map storage map, address key, uint val) public {\\r\\n        if (map.inserted[key]) {\\r\\n            map.values[key] = val;\\r\\n        } else {\\r\\n            map.inserted[key] = true;\\r\\n            map.values[key] = val;\\r\\n            map.indexOf[key] = map.keys.length;\\r\\n            map.keys.push(key);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remove(Map storage map, address key) public {\\r\\n        if (!map.inserted[key]) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        delete map.inserted[key];\\r\\n        delete map.values[key];\\r\\n\\r\\n        uint index = map.indexOf[key];\\r\\n        uint lastIndex = map.keys.length - 1;\\r\\n        address lastKey = map.keys[lastIndex];\\r\\n\\r\\n        map.indexOf[lastKey] = index;\\r\\n        delete map.indexOf[key];\\r\\n\\r\\n        map.keys[index] = lastKey;\\r\\n        map.keys.pop();\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DividendTracker is Ownable, DividendPayingToken {\\r\\n    using IterableMapping for IterableMapping.Map;\\r\\n\\r\\n    IterableMapping.Map private tokenHoldersMap;\\r\\n    uint256 public lastProcessedIndex;\\r\\n\\r\\n    mapping(address => bool) public isExcludedFromDividends;\\r\\n    mapping(address => uint256) public lastClaimTimes;\\r\\n\\r\\n    uint256 public claimWait;\\r\\n    uint256 public minimumTokenBalanceForDividends;\\r\\n\\r\\n    event ExcludeFromDividends(address indexed account, bool isExcluded);\\r\\n    event ClaimWaitUpdated(uint256 claimWait);\\r\\n    event ProcessedDividendTracker(uint256 iterations, uint256 claims);\\r\\n\\r\\n    constructor(\\r\\n        uint256 _claimWait,\\r\\n        uint256 _minimumTokenBalance,\\r\\n        address _rewardToken\\r\\n    ) DividendPayingToken(_rewardToken, \\\"DividendTracker\\\", \\\"DividendTracker\\\") {\\r\\n        claimWaitSetup(_claimWait);\\r\\n        minimumTokenBalanceForDividends = _minimumTokenBalance;\\r\\n    }\\r\\n\\r\\n    function excludeFromDividends(\\r\\n        address account,\\r\\n        uint256 balance,\\r\\n        bool isExcluded\\r\\n    ) external onlyOwner {\\r\\n        if (isExcluded) {\\r\\n            require(\\r\\n                !isExcludedFromDividends[account],\\r\\n                \\\"DividendTracker: This address is already excluded from dividends\\\"\\r\\n            );\\r\\n            isExcludedFromDividends[account] = true;\\r\\n\\r\\n            _setBalance(account, 0);\\r\\n            tokenHoldersMap.remove(account);\\r\\n        } else {\\r\\n            require(\\r\\n                isExcludedFromDividends[account],\\r\\n                \\\"DividendTracker: This address is already included in dividends\\\"\\r\\n            );\\r\\n            isExcludedFromDividends[account] = false;\\r\\n\\r\\n            setBalance(account, balance);\\r\\n        }\\r\\n\\r\\n        emit ExcludeFromDividends(account, isExcluded);\\r\\n    }\\r\\n\\r\\n    function claimWaitSetup(uint256 newClaimWait) public onlyOwner {\\r\\n        require(\\r\\n            newClaimWait >= 60 && newClaimWait <= 7 days,\\r\\n            \\\"DividendTracker: Claim wait time must be between 1 minute and 7 days\\\"\\r\\n        );\\r\\n\\r\\n        claimWait = newClaimWait;\\r\\n\\r\\n        emit ClaimWaitUpdated(newClaimWait);\\r\\n    }\\r\\n\\r\\n    function getNumberOfTokenHolders() external view returns (uint256) {\\r\\n        return tokenHoldersMap.keys.length;\\r\\n    }\\r\\n\\r\\n    function getAccountData(\\r\\n        address _account\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            address account,\\r\\n            int256 index,\\r\\n            int256 iterationsUntilProcessed,\\r\\n            uint256 withdrawableDividends,\\r\\n            uint256 totalDividends,\\r\\n            uint256 lastClaimTime,\\r\\n            uint256 nextClaimTime,\\r\\n            uint256 secondsUntilAutoClaimAvailable\\r\\n        )\\r\\n    {\\r\\n        account = _account;\\r\\n        index = tokenHoldersMap.getIndexOfKey(account);\\r\\n        iterationsUntilProcessed = -1;\\r\\n\\r\\n        if (index >= 0) {\\r\\n            if (uint256(index) > lastProcessedIndex) {\\r\\n                iterationsUntilProcessed = index - int256(lastProcessedIndex);\\r\\n            } else {\\r\\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >\\r\\n                    lastProcessedIndex\\r\\n                    ? tokenHoldersMap.keys.length - lastProcessedIndex\\r\\n                    : 0;\\r\\n                iterationsUntilProcessed =\\r\\n                    index +\\r\\n                    int256(processesUntilEndOfArray);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        withdrawableDividends = withdrawableDividendOf(account);\\r\\n        totalDividends = accumulativeDividendOf(account);\\r\\n        lastClaimTime = lastClaimTimes[account];\\r\\n        nextClaimTime = lastClaimTime > 0 ? lastClaimTime + claimWait : 0;\\r\\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp\\r\\n            ? nextClaimTime - block.timestamp\\r\\n            : 0;\\r\\n    }\\r\\n\\r\\n    function getAccountDataAtIndex(\\r\\n        uint256 index\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            address,\\r\\n            int256,\\r\\n            int256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        if (index >= tokenHoldersMap.size())\\r\\n            return (address(0), -1, -1, 0, 0, 0, 0, 0);\\r\\n\\r\\n        address account = tokenHoldersMap.getKeyAtIndex(index);\\r\\n\\r\\n        return getAccountData(account);\\r\\n    }\\r\\n\\r\\n    function claim(address account) public onlyOwner returns (bool) {\\r\\n        uint256 amount = _withdrawDividend(account);\\r\\n\\r\\n        if (amount > 0) {\\r\\n            lastClaimTimes[account] = block.timestamp;\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\r\\n        if (block.timestamp < lastClaimTime) return false;\\r\\n\\r\\n        return block.timestamp - lastClaimTime >= claimWait;\\r\\n    }\\r\\n\\r\\n    function setBalance(address account, uint256 newBalance) public onlyOwner {\\r\\n        if (!isExcludedFromDividends[account]) {\\r\\n            if (newBalance >= minimumTokenBalanceForDividends) {\\r\\n                _setBalance(account, newBalance);\\r\\n                tokenHoldersMap.set(account, newBalance);\\r\\n            } else {\\r\\n                _setBalance(account, 0);\\r\\n                tokenHoldersMap.remove(account);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function process(\\r\\n        uint256 gas\\r\\n    ) external onlyOwner returns (uint256 iterations, uint256 claims) {\\r\\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\\r\\n\\r\\n        if (numberOfTokenHolders == 0) return (0, 0);\\r\\n\\r\\n        uint256 _lastProcessedIndex = lastProcessedIndex;\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n\\r\\n        iterations = 0;\\r\\n        claims = 0;\\r\\n\\r\\n        while (gasUsed < gas && iterations < numberOfTokenHolders) {\\r\\n            _lastProcessedIndex++;\\r\\n\\r\\n            if (_lastProcessedIndex >= tokenHoldersMap.keys.length)\\r\\n                _lastProcessedIndex = 0;\\r\\n\\r\\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\\r\\n\\r\\n            if (_canAutoClaim(lastClaimTimes[account])) {\\r\\n                if (claim(account)) {\\r\\n                    claims++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            iterations++;\\r\\n\\r\\n            uint256 newGasLeft = gasleft();\\r\\n\\r\\n            if (gasLeft > newGasLeft)\\r\\n                gasUsed = gasUsed + (gasLeft - newGasLeft);\\r\\n\\r\\n            gasLeft = newGasLeft;\\r\\n        }\\r\\n\\r\\n        lastProcessedIndex = _lastProcessedIndex;\\r\\n\\r\\n        emit ProcessedDividendTracker(iterations, claims);\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract DividendTrackerFunctions is Ownable {\\r\\n    DividendTracker public dividendTracker;\\r\\n\\r\\n    uint256 public gasForProcessing;\\r\\n\\r\\n    address public rewardToken;\\r\\n\\r\\n    event DeployedDividendTracker(\\r\\n        address indexed dividendTracker,\\r\\n        address indexed rewardToken\\r\\n    );\\r\\n    event GasForProcessingUpdated(uint256 gasForProcessing);\\r\\n\\r\\n    function _deployDividendTracker(\\r\\n        uint256 claimWait,\\r\\n        uint256 minimumTokenBalance,\\r\\n        address _rewardToken\\r\\n    ) internal {\\r\\n        dividendTracker = new DividendTracker(\\r\\n            claimWait,\\r\\n            minimumTokenBalance,\\r\\n            _rewardToken\\r\\n        );\\r\\n\\r\\n        rewardToken = _rewardToken;\\r\\n\\r\\n        emit DeployedDividendTracker(address(dividendTracker), _rewardToken);\\r\\n    }\\r\\n\\r\\n    function gasForProcessingSetup(uint256 _gasForProcessing) public onlyOwner {\\r\\n        require(\\r\\n            _gasForProcessing >= 200_000 && _gasForProcessing <= 1_000_000,\\r\\n            \\\"ERC20: gasForProcessing must be between 200k and 1M units\\\"\\r\\n        );\\r\\n\\r\\n        gasForProcessing = _gasForProcessing;\\r\\n\\r\\n        emit GasForProcessingUpdated(_gasForProcessing);\\r\\n    }\\r\\n\\r\\n    function claimWaitSetup(uint256 claimWait) external onlyOwner {\\r\\n        dividendTracker.claimWaitSetup(claimWait);\\r\\n    }\\r\\n\\r\\n    function excludeFromDividends(\\r\\n        address account,\\r\\n        bool isExcluded\\r\\n    ) public virtual;\\r\\n\\r\\n    function isExcludedFromDividends(\\r\\n        address account\\r\\n    ) public view returns (bool) {\\r\\n        return dividendTracker.isExcludedFromDividends(account);\\r\\n    }\\r\\n\\r\\n    function claim() external returns (bool) {\\r\\n        return dividendTracker.claim(msg.sender);\\r\\n    }\\r\\n\\r\\n    function getClaimWait() external view returns (uint256) {\\r\\n        return dividendTracker.claimWait();\\r\\n    }\\r\\n\\r\\n    function getTotalDividendsDistributed() external view returns (uint256) {\\r\\n        return dividendTracker.totalDividendsDistributed();\\r\\n    }\\r\\n\\r\\n    function withdrawableDividendOf(\\r\\n        address account\\r\\n    ) public view returns (uint256) {\\r\\n        return dividendTracker.withdrawableDividendOf(account);\\r\\n    }\\r\\n\\r\\n    function dividendTokenBalanceOf(\\r\\n        address account\\r\\n    ) public view returns (uint256) {\\r\\n        return dividendTracker.balanceOf(account);\\r\\n    }\\r\\n\\r\\n    function dividendTokenTotalSupply() public view returns (uint256) {\\r\\n        return dividendTracker.totalSupply();\\r\\n    }\\r\\n\\r\\n    function getAccountDividendsInfo(\\r\\n        address account\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address,\\r\\n            int256,\\r\\n            int256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return dividendTracker.getAccountData(account);\\r\\n    }\\r\\n\\r\\n    function getAccountDividendsInfoAtIndex(\\r\\n        uint256 index\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address,\\r\\n            int256,\\r\\n            int256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return dividendTracker.getAccountDataAtIndex(index);\\r\\n    }\\r\\n\\r\\n    function getLastProcessedIndex() external view returns (uint256) {\\r\\n        return dividendTracker.lastProcessedIndex();\\r\\n    }\\r\\n\\r\\n    function getNumberOfDividendTokenHolders() public view returns (uint256) {\\r\\n        return dividendTracker.getNumberOfTokenHolders();\\r\\n    }\\r\\n\\r\\n    function process(\\r\\n        uint256 gas\\r\\n    ) external returns (uint256 iterations, uint256 claims) {\\r\\n        return dividendTracker.process(gas);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapFactory {\\r\\n    event PairCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        address pair,\\r\\n        uint\\r\\n    );\\r\\n\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract ScroogeToken is ERC20, Ownable, DividendTrackerFunctions {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 public swapThreshold;\\r\\n    uint256 public _totalSupply = 1_000_000_000 * (10 ** decimals());\\r\\n    uint256 public _maxTxAmount;\\r\\n    uint256 public _walletMax;\\r\\n\\r\\n    address private _marketingAddress;\\r\\n    address private _deployer;\\r\\n    address public immutable DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address public immutable ZERO = 0x0000000000000000000000000000000000000000;\\r\\n\\r\\n    // Buy Tax: 5%\\r\\n    uint256 _buyLiquidityFee = 20;\\r\\n    uint256 _buyMarketingFees = 20;\\r\\n    uint256 _buyRewardFee = 10;\\r\\n    uint256 public totalBuyFee;\\r\\n\\r\\n    // Sell Tax: 10%\\r\\n    uint256 _sellLiquidityFee = 30;\\r\\n    uint256 _sellMarketingFees = 20;\\r\\n    uint256 _sellBurnFees = 10;\\r\\n    uint256 _sellRewardFee = 40;\\r\\n    uint256 public totalSellFee;\\r\\n\\r\\n    uint256 feeDenominator = 1000;\\r\\n\\r\\n    mapping(address => bool) public isExcludedFromFees;\\r\\n    mapping(address => bool) public isExcludedFromMaxWalletSize;\\r\\n    mapping(address => bool) public isExcludedFromMaxTxAmount;\\r\\n\\r\\n    bool _swapping;\\r\\n    bool private _swapEnabled;\\r\\n    bool private _tradingActive;\\r\\n\\r\\n    modifier swapping() {\\r\\n        _swapping = true;\\r\\n        _;\\r\\n        _swapping = false;\\r\\n    }\\r\\n\\r\\n    IPancakeSwapRouter public pancakeRouter;\\r\\n    address public pairAddress;\\r\\n\\r\\n    mapping(address => bool) public isCoreAddress;\\r\\n    mapping(address => bool) public isMarketPair;\\r\\n    mapping(address => bool) public isBlacklisted;\\r\\n    uint256 private _launchedAt;\\r\\n    uint256 private _snipingTime = 120 seconds;\\r\\n\\r\\n    constructor(\\r\\n        address marketingWallet,\\r\\n        address busdRewardToken\\r\\n    ) ERC20(\\\"SCROOGE\\\", \\\"$CROOGE\\\") {\\r\\n\\r\\n        swapThreshold = 2_000_000 * (10 ** decimals()); //0.2% \\r\\n        _maxTxAmount = 20_000_000 * (10 ** decimals()); //2.0% \\r\\n        _walletMax = 20_000_000 * (10 ** decimals());   //2.0% \\r\\n\\r\\n        _marketingAddress = marketingWallet;\\r\\n        _deployer = msg.sender;\\r\\n\\r\\n        totalBuyFee = _buyLiquidityFee.add(_buyRewardFee).add(\\r\\n            _buyMarketingFees\\r\\n        );\\r\\n\\r\\n        totalSellFee = _sellLiquidityFee\\r\\n            .add(_sellRewardFee)\\r\\n            .add(_sellMarketingFees)\\r\\n            .add(_sellBurnFees);\\r\\n\\r\\n        dividendTracker = new DividendTracker(\\r\\n            36_000,\\r\\n            100 * (10 ** decimals()),\\r\\n            busdRewardToken\\r\\n        );\\r\\n\\r\\n        rewardToken = busdRewardToken;\\r\\n        gasForProcessing = 300000;\\r\\n\\r\\n        isCoreAddress[msg.sender] = true;\\r\\n        isCoreAddress[address(this)] = true;\\r\\n\\r\\n        excludeFromDividends(address(this), true);\\r\\n        excludeFromDividends(DEAD, true);\\r\\n        excludeFromDividends(ZERO, true);\\r\\n\\r\\n        excludeFromFees(DEAD, true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(msg.sender, true);\\r\\n\\r\\n        excludeFromMaxTxAmount(DEAD, true);\\r\\n        excludeFromMaxTxAmount(ZERO, true);\\r\\n        excludeFromMaxTxAmount(msg.sender, true);\\r\\n        excludeFromMaxTxAmount(address(this), true);\\r\\n\\r\\n        excludeFromMaxWalletSize(msg.sender, true);\\r\\n        excludeFromMaxWalletSize(address(this), true);\\r\\n        excludeFromMaxWalletSize(DEAD, true);\\r\\n        excludeFromMaxWalletSize(ZERO, true);\\r\\n\\r\\n        // _mint is an internal function in ERC20.sol that is only called here and CANNOT be called ever again\\r\\n        _mint(msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    modifier simpleGuard() {\\r\\n        require(msg.sender == _deployer, \\\"Error: Guarded!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function decimals() public pure override returns (uint8) {\\r\\n        return 9;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        _tradingActive = true;\\r\\n        _swapEnabled = true;\\r\\n        _launchedAt = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function swapTokens(uint256 tokenAmount, address[] memory path) private {\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n\\r\\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _sendDividends(uint256 tokenAmount) private {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(this);\\r\\n        path[1] = pancakeRouter.WETH();\\r\\n        path[2] = rewardToken; // Convert to BUSD\\r\\n\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n\\r\\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of BUSD\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 dividends = IERC20(rewardToken).balanceOf(address(this));\\r\\n\\r\\n        if (dividends > 0) {\\r\\n            bool success = IERC20(rewardToken).approve(\\r\\n                address(dividendTracker),\\r\\n                dividends\\r\\n            );\\r\\n\\r\\n            if (success) {\\r\\n                dividendTracker.distributeDividends(dividends);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal override {\\r\\n        super._burn(account, amount);\\r\\n        dividendTracker.setBalance(account, balanceOf(account));\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal override {\\r\\n        super._mint(account, amount);\\r\\n        dividendTracker.setBalance(account, balanceOf(account));\\r\\n    }\\r\\n\\r\\n    function swapBack(uint256 contractBalance) internal swapping {\\r\\n        uint256 totalShares = totalBuyFee.add(totalSellFee); // 15%\\r\\n\\r\\n        if (totalShares == 0) return;\\r\\n\\r\\n        uint256 _rewardShare = _buyRewardFee.add(_sellRewardFee);\\r\\n        uint256 _liquidityShare = _buyLiquidityFee.add(_sellLiquidityFee);\\r\\n\\r\\n        // only half liquidity share needs to be tokens\\r\\n        uint256 tokensForLP = contractBalance\\r\\n            .mul(_liquidityShare)\\r\\n            .div(totalShares)\\r\\n            .div(2);\\r\\n\\r\\n        uint256 tokensForBurn = contractBalance.mul(_sellBurnFees).div(\\r\\n            totalShares\\r\\n        );\\r\\n\\r\\n        uint256 tokensForReward = contractBalance.mul(_rewardShare).div(\\r\\n            totalShares\\r\\n        );\\r\\n\\r\\n        // rest of LP and all other tokens can be sold for BNB\\r\\n        uint256 tokensForSwap = contractBalance\\r\\n            .sub(tokensForLP)\\r\\n            .sub(tokensForBurn)\\r\\n            .sub(tokensForReward);\\r\\n\\r\\n        uint256 initialBalance = address(this).balance;\\r\\n\\r\\n        // generate the uniswap pair path of token -> bnb\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = pancakeRouter.WETH(); // BNB\\r\\n\\r\\n        swapTokens(tokensForSwap, path);\\r\\n\\r\\n        uint256 amountReceived = address(this).balance.sub(initialBalance);\\r\\n\\r\\n        uint256 totalExchangedShare = _liquidityShare.add(_buyMarketingFees).add(_sellMarketingFees);\\r\\n\\r\\n        // halved because we didn't swap half the tokens reserved for liquidity\\r\\n        // so when we calculate the share of total based on full % for this we need to cut half\\r\\n        uint256 amountETHLiquidity = amountReceived\\r\\n            .mul(_liquidityShare)\\r\\n            .div(totalExchangedShare)\\r\\n            .div(2);\\r\\n\\r\\n        // The total tokens traded is equal to LP tokens + MRKT tokens\\r\\n        // Therefor, we can simply deduct the LP ETH from the total to arrive at the MRKT amount\\r\\n        // Burn happens in pure tokens and reward tokens get cashed in through dif method/route\\r\\n        uint256 amountBNBMarketing = amountReceived.sub(amountETHLiquidity);\\r\\n\\r\\n        if (amountETHLiquidity > 0 && tokensForLP > 0) {\\r\\n            addLiquidity(tokensForLP, amountETHLiquidity);\\r\\n        }\\r\\n\\r\\n        if (tokensForReward > 0) {\\r\\n            _sendDividends(tokensForReward);\\r\\n        }\\r\\n\\r\\n        if (amountBNBMarketing > 0) {\\r\\n            (bool os, ) = payable(_marketingAddress).call{\\r\\n                value: amountBNBMarketing\\r\\n            }(\\\"\\\");\\r\\n            require(os, \\\"Marketing Fund Failure!\\\");\\r\\n        }\\r\\n\\r\\n        if (tokensForBurn > 0) {\\r\\n            _burn(address(this), tokensForBurn);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(!isBlacklisted[from], \\\"ERC20: Bot detected\\\");\\r\\n        require(!isBlacklisted[msg.sender], \\\"ERC20: Bot detected\\\");\\r\\n\\r\\n        if (_swapping) {\\r\\n            // if swapping, dont take fees\\r\\n            return super._transfer(from, to, amount);\\r\\n        }\\r\\n\\r\\n        if (!isCoreAddress[from] && !isCoreAddress[to]) {\\r\\n            require(_tradingActive, \\\"ERC20: trading not enable yet\\\");\\r\\n            if (\\r\\n                block.timestamp < _launchedAt + _snipingTime &&\\r\\n                from != address(pancakeRouter) \\r\\n            ) {\\r\\n                if (pairAddress == from) {\\r\\n                    isBlacklisted[to] = true;\\r\\n                } else if (pairAddress == to) {\\r\\n                    isBlacklisted[from] = true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n        bool overMinimumTokenBalance = contractTokenBalance >= swapThreshold;\\r\\n\\r\\n        if (\\r\\n            overMinimumTokenBalance &&\\r\\n            !_swapping &&\\r\\n            !isMarketPair[from] &&\\r\\n            _swapEnabled\\r\\n        ) {\\r\\n            swapBack(contractTokenBalance);\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            !isExcludedFromMaxTxAmount[from] && !isExcludedFromMaxTxAmount[to]\\r\\n        ) {\\r\\n            require(\\r\\n                amount <= _maxTxAmount,\\r\\n                \\\"Transfer amount exceeds the maxTransactionAmount.\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (!isExcludedFromMaxWalletSize[to]) {\\r\\n            require(\\r\\n                amount + balanceOf(to) <= _walletMax,\\r\\n                \\\"Max wallet size exceeded\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 finalAmount = shouldNotTakeFee(from, to)\\r\\n            ? amount\\r\\n            : takeFee(from, to, amount);\\r\\n\\r\\n        super._transfer(from, to, finalAmount);\\r\\n\\r\\n        dividendTracker.setBalance(from, balanceOf(from));\\r\\n        dividendTracker.setBalance(to, balanceOf(to));\\r\\n\\r\\n        if (!_swapping)\\r\\n            try dividendTracker.process(gasForProcessing) {} catch {}\\r\\n    }\\r\\n\\r\\n    function shouldNotTakeFee(\\r\\n        address sender,\\r\\n        address recipient\\r\\n    ) internal view returns (bool) {\\r\\n        if (isExcludedFromFees[sender] || isExcludedFromFees[recipient]) {\\r\\n            return true;\\r\\n        } else if (isMarketPair[sender] || isMarketPair[recipient]) {\\r\\n            return false;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setupPair(address pancakeSwapRouter) external onlyOwner {\\r\\n        // Router & Pair\\r\\n        pancakeRouter = IPancakeSwapRouter(pancakeSwapRouter); // Pancakeswap\\r\\n        pairAddress = IPancakeSwapFactory(pancakeRouter.factory()).createPair(\\r\\n            address(this),\\r\\n            pancakeRouter.WETH()\\r\\n        );\\r\\n\\r\\n        isCoreAddress[pancakeSwapRouter] = true;\\r\\n        excludeFromMaxWalletSize(pairAddress, true);\\r\\n        excludeFromMaxWalletSize(pancakeSwapRouter, true);\\r\\n        excludeFromDividends(pairAddress, true);\\r\\n        excludeFromDividends(pancakeSwapRouter, true);\\r\\n        excludeFromFees(pancakeSwapRouter, true);\\r\\n        excludeFromMaxTxAmount(pancakeSwapRouter, true);\\r\\n        \\r\\n        isMarketPair[pairAddress] = true;\\r\\n\\r\\n        setAllowance(address(this), pancakeSwapRouter, ~uint256(0));\\r\\n        setAllowance(address(this), pairAddress, ~uint256(0));\\r\\n    }\\r\\n\\r\\n    function takeFee(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (uint256) {\\r\\n        uint feeAmount;\\r\\n\\r\\n        unchecked {\\r\\n            if (isMarketPair[sender]) {\\r\\n                //buy\\r\\n                feeAmount = amount.mul(totalBuyFee).div(feeDenominator);\\r\\n            } else if (isMarketPair[recipient]) {\\r\\n                //sell\\r\\n                feeAmount = amount.mul(totalSellFee).div(feeDenominator);\\r\\n            }\\r\\n\\r\\n            if (feeAmount > 0) {\\r\\n                super._transfer(sender, address(this), feeAmount);\\r\\n            }\\r\\n\\r\\n            return amount.sub(feeAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        pancakeRouter.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            DEAD, // Auto-burn liquidity\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function excludeFromDividends(\\r\\n        address account,\\r\\n        bool isExcluded\\r\\n    ) public override simpleGuard {\\r\\n        dividendTracker.excludeFromDividends(\\r\\n            account,\\r\\n            balanceOf(account),\\r\\n            isExcluded\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(\\r\\n        address account,\\r\\n        bool isExcluded\\r\\n    ) public simpleGuard {\\r\\n        isExcludedFromFees[account] = isExcluded;\\r\\n    }\\r\\n\\r\\n    function excludeFromMaxWalletSize(\\r\\n        address account,\\r\\n        bool isExcluded\\r\\n    ) public simpleGuard {\\r\\n        isExcludedFromMaxWalletSize[account] = isExcluded;\\r\\n    }\\r\\n\\r\\n    function excludeFromMaxTxAmount(\\r\\n        address account,\\r\\n        bool isExcluded\\r\\n    ) public simpleGuard {\\r\\n        isExcludedFromMaxTxAmount[account] = isExcluded;\\r\\n    }\\r\\n\\r\\n    function setMaxWalletLimit(uint256 newLimit) external simpleGuard {\\r\\n        require(\\r\\n            newLimit >= ((totalSupply() * 5) / 1000) / 1e9,\\r\\n            \\\"Cannot set Max Wallet Amount lower than 0.5%\\\"\\r\\n        );\\r\\n\\r\\n        _walletMax = newLimit;\\r\\n    }\\r\\n\\r\\n    function setTxLimit(uint256 newLimit) external simpleGuard {\\r\\n        require(\\r\\n            newLimit >= ((totalSupply() * 5) / 1000) / 1e9,\\r\\n            \\\"Cannot set Max Transaction Limit lower than 0.5%\\\"\\r\\n        );\\r\\n\\r\\n        _maxTxAmount = newLimit;\\r\\n    }\\r\\n\\r\\n    function rescueStuckDividends() external simpleGuard {\\r\\n        IERC20(rewardToken).transfer(\\r\\n            _marketingAddress,\\r\\n            IERC20(rewardToken).balanceOf(address(this))\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function rescueStuckBNB(uint256 amount) external simpleGuard {\\r\\n        payable(_marketingAddress).transfer(amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/ScroogeToken.sol\": {\r\n        \"IterableMapping\": \"0x8dbec2953434d6b02026150e26561d7a4b340bef\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"ClaimWaitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"DividendWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"DividendsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accumulativeDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newClaimWait\",\"type\":\"uint256\"}],\"name\":\"claimWaitSetup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"index\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"iterationsUntilProcessed\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsUntilAutoClaimAvailable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountDataAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokenBalanceForDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"process\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"setBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawnDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DividendTracker", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000008ca0000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}