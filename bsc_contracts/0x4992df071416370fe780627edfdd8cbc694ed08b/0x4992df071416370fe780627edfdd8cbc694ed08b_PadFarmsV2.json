{"SourceCode": "pragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n}\r\n\r\ninterface TOKEN {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface MINTER {\r\n    function mint() external returns (uint256);\r\n}\r\n\r\ncontract PadFarmsV2 {\r\n    using SafeMath for uint256;\r\n\r\n   modifier hasDripped {\r\n        if (farmPool > 0 && sharesSupply > 0) {\r\n          uint256 secondsPassed = SafeMath.sub(block.timestamp, lastDripTime);\r\n          uint256 rewards = secondsPassed.mul(farmPool).div(dailyRate);\r\n\r\n          if (rewards > farmPool) {\r\n            rewards = farmPool;\r\n          }\r\n\r\n          profitPerShare = SafeMath.add(profitPerShare, (rewards * magnitude) / sharesSupply);\r\n          farmPool = farmPool.sub(rewards);\r\n          lastDripTime = block.timestamp;\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier padMinted {\r\n        mintPad();\r\n        _;\r\n    }\r\n    \r\n    modifier onlyFarmers {\r\n        require(myShares() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier hasRewards {\r\n        require(myRewards() > 0);\r\n        _;\r\n    }\r\n\r\n    event onNewStake(\r\n        address indexed farmerAddress,\r\n        uint256 stakedTokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onRemoveStake(\r\n        address indexed farmerAddress,\r\n        uint256 tokensRemoved,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onHarvest(\r\n        address indexed farmerAddress,\r\n        uint256 padWithdrawn\r\n    );\r\n    \r\n     event onTokenMint(\r\n        uint256 mintedPad,\r\n        uint256 timestamp\r\n    );\r\n\r\n\r\n    uint256 constant private magnitude = 2 ** 64;\r\n    uint32 constant private dailyRate = 864000; //10% a day\r\n    uint8 constant private vaultFee = 1;\r\n\r\n    mapping(address => uint256) private sharesBalanceLedger;\r\n    mapping(address => int256) private payoutsTo;\r\n    \r\n    mapping(address => uint256) public farmedPad;\r\n\r\n    uint256 public farmPool = 0;\r\n    uint256 public lastDripTime = block.timestamp;\r\n    uint256 public mintedPad = 0;\r\n    \r\n    uint256 public totalVaultFundReceived = 0;\r\n    uint256 public totalVaultFundCollected = 0;\r\n\r\n    uint256 private sharesSupply = 0;\r\n    uint256 private profitPerShare = 0;\r\n\r\n    address public vaultAddress;\r\n    \r\n    MINTER minterContract;\r\n    TOKEN pad;\r\n    TOKEN acceptedToken;\r\n\r\n    constructor(address _minter, address _vaultAddress, address _pad, address _acceptedToken) {\r\n        minterContract = MINTER(_minter);\r\n        pad = TOKEN(_pad);\r\n        acceptedToken = TOKEN(_acceptedToken);\r\n        vaultAddress = _vaultAddress;\r\n    }\r\n\r\n\r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    function checkAndTransfer(uint256 _amount, TOKEN _token) private {\r\n        require(_token.transferFrom(msg.sender, address(this), _amount) == true, \"transfer must succeed\");\r\n    }\r\n    \r\n    function mintPad() public {\r\n        uint256 _mintedAmount = minterContract.mint();\r\n        mintedPad += _mintedAmount;\r\n        farmPool = farmPool.add(_mintedAmount);\r\n        emit onTokenMint(_mintedAmount, block.timestamp);\r\n    }\r\n\r\n    function payVault() public {\r\n        uint256 _tokensToPay = tokensToPay();\r\n        require(_tokensToPay > 0);\r\n        acceptedToken.transfer(vaultAddress, _tokensToPay);\r\n        totalVaultFundReceived = totalVaultFundReceived.add(_tokensToPay);\r\n    }\r\n\r\n    function harvest() hasDripped hasRewards public {\r\n        address _farmerAddress = msg.sender;\r\n        uint256 _rewards = myRewards();\r\n        payoutsTo[_farmerAddress] += (int256) (_rewards.mul(magnitude));\r\n        pad.transfer(_farmerAddress, _rewards);\r\n        farmedPad[_farmerAddress] += _rewards;\r\n        emit onHarvest(_farmerAddress, _rewards);\r\n    }\r\n\r\n    function deposit(uint256 _amount) padMinted hasDripped public returns (uint256) {\r\n        checkAndTransfer(_amount, acceptedToken);\r\n        return addShares(msg.sender, _amount);\r\n    }\r\n\r\n    function _addShares(address _customerAddress, uint256 _incomingTokens) private returns(uint256) {\r\n        uint256 _amountOfTokens = _incomingTokens;\r\n\r\n        require(_amountOfTokens > 0 && _amountOfTokens.add(sharesSupply) > sharesSupply);\r\n\r\n        sharesSupply = sharesSupply.add(_amountOfTokens);\r\n        sharesBalanceLedger[_customerAddress] = sharesBalanceLedger[_customerAddress].add(_amountOfTokens);\r\n\r\n        int256 _updatedPayouts = (int256) (profitPerShare.mul(_amountOfTokens));\r\n        payoutsTo[_customerAddress] += _updatedPayouts;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n    \r\n    function addShares(address _farmerAddress, uint256 _incomingTokens) private returns (uint256) {\r\n        require(_incomingTokens > 0);\r\n\r\n        uint256 _vaultFee = _incomingTokens.mul(vaultFee).div(100);\r\n\r\n        uint256 _taxedTokens = _incomingTokens.sub(_vaultFee);\r\n\r\n        uint256 _amountOfTokens = _addShares(_farmerAddress, _taxedTokens);\r\n\r\n        totalVaultFundCollected = totalVaultFundCollected.add(_vaultFee);\r\n\r\n        emit onNewStake(_farmerAddress, _amountOfTokens, block.timestamp);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n    \r\n     function remove(uint256 _amountOfShares) padMinted hasDripped onlyFarmers public {\r\n        address _farmerAddress = msg.sender;\r\n        require(_amountOfShares > 0 && _amountOfShares <= sharesBalanceLedger[_farmerAddress]);\r\n        \r\n        uint256 _vaultFee = _amountOfShares.mul(vaultFee).div(100);\r\n        \r\n        uint256 _taxedTokens = _amountOfShares.sub(_vaultFee);\r\n\r\n        sharesSupply = sharesSupply.sub(_amountOfShares);\r\n        sharesBalanceLedger[_farmerAddress] = sharesBalanceLedger[_farmerAddress].sub(_amountOfShares);\r\n\r\n        int256 _updatedPayouts = (int256) (profitPerShare.mul(_amountOfShares));\r\n        payoutsTo[_farmerAddress] -= _updatedPayouts;\r\n        \r\n        totalVaultFundCollected = totalVaultFundCollected.add(_vaultFee);\r\n        \r\n        acceptedToken.transfer(_farmerAddress, _taxedTokens);\r\n        \r\n        emit onRemoveStake(_farmerAddress, _taxedTokens, block.timestamp);\r\n    }\r\n    \r\n    function totalTokenBalance() public view returns (uint256) {\r\n        return acceptedToken.balanceOf(address(this));\r\n    }\r\n\r\n    function totalSupply() public view returns(uint256) {\r\n        return sharesSupply;\r\n    }\r\n\r\n    function myShares() public view returns (uint256) {\r\n        address _farmerAddress = msg.sender;\r\n        return sharesOf(_farmerAddress);\r\n    }\r\n\r\n    function myEstimateRewards() public view returns (uint256) {\r\n        address _farmerAddress = msg.sender;\r\n        return estimateRewardsOf(_farmerAddress) ;\r\n    }\r\n\r\n    function estimateRewardsOf(address _farmerAddress) public view returns (uint256) {\r\n        uint256 _profitPerShare = profitPerShare;\r\n\r\n        if (farmPool > 0) {\r\n          uint256 secondsPassed = SafeMath.sub(block.timestamp, lastDripTime);\r\n          \r\n          uint256 dividends = secondsPassed.mul(farmPool).div(dailyRate);\r\n\r\n          if (dividends > farmPool) {\r\n            dividends = farmPool;\r\n          }\r\n\r\n          _profitPerShare = SafeMath.add(_profitPerShare, (dividends * magnitude) / sharesSupply);\r\n        }\r\n\r\n        return (uint256) ((int256) (_profitPerShare * sharesBalanceLedger[_farmerAddress]) - payoutsTo[_farmerAddress]) / magnitude;\r\n    }\r\n\r\n    function myRewards() public view returns (uint256) {\r\n        address _farmerAddress = msg.sender;\r\n        return rewardsOf(_farmerAddress) ;\r\n    }\r\n\r\n    function rewardsOf(address _farmerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare * sharesBalanceLedger[_farmerAddress]) - payoutsTo[_farmerAddress]) / magnitude;\r\n    }\r\n\r\n    function sharesOf(address _farmerAddress) public view returns (uint256) {\r\n        return sharesBalanceLedger[_farmerAddress];\r\n    }\r\n    \r\n    function tokensToPay() public view returns(uint256) {\r\n        return totalVaultFundCollected.sub(totalVaultFundReceived);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pad\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acceptedToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"farmerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"padWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onHarvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"farmerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onNewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"farmerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensRemoved\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onRemoveStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedPad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenMint\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_farmerAddress\",\"type\":\"address\"}],\"name\":\"estimateRewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"farmedPad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDripTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPad\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedPad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myEstimateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfShares\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_farmerAddress\",\"type\":\"address\"}],\"name\":\"rewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_farmerAddress\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensToPay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVaultFundCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVaultFundReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PadFarmsV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002833e29063c94e3efc33fb8963db1ea42b904c440000000000000000000000006beee53efa847ec426707693c83836e359e92609000000000000000000000000c0888d80ee0abf84563168b3182650c0addeb6d50000000000000000000000004bddda73f0a83ccada25107830e29de594e8f7c2", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://da1ae69db06bc23b661c9a321aaa5790f65dfcc4b0c964ba656baea30598f45d"}