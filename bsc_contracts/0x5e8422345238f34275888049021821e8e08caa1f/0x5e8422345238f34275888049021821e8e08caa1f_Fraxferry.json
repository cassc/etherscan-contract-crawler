{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n// Sources flattened with hardhat v2.17.3 https://hardhat.org\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol@v4.9.3\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol@v4.9.3\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\n\r\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.3\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// File @uniswap/v3-periphery/contracts/libraries/TransferHelper.sol@v1.4.3\r\n\r\n// Original license: SPDX_License_Identifier: GPL-2.0-or-later\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.9.3\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxferry/Fraxferry.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ============================ Fraxferry =============================\r\n// ====================================================================\r\n// Ferry that can be used to ship tokens between chains\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Dennis: https://github.com/denett\r\n\r\n/*\r\n** Modus operandi:\r\n** - User sends tokens to the contract. This transaction is stored in the contract.\r\n** - Captain queries the source chain for transactions to ship.\r\n** - Captain sends batch (start, end, hash) to start the trip,\r\n** - Crewmembers check the batch and can dispute it if it is invalid.\r\n** - Non disputed batches can be executed by the first officer by providing the transactions as calldata. \r\n** - Hash of the transactions must be equal to the hash in the batch. User receives their tokens on the other chain.\r\n** - In case there was a fraudulent transaction (a hacker for example), the owner can cancel a single transaction, such that it will not be executed.\r\n** - The owner can manually manage the tokens in the contract and must make sure it has enough funds.\r\n**\r\n** What must happen for a false batch to be executed:\r\n** - Captain is tricked into proposing a batch with a false hash\r\n** - All crewmembers bots are offline/censured/compromised and no one disputes the proposal\r\n**\r\n** Other risks:\r\n** - Reorgs on the source chain. Avoided, by only returning the transactions on the source chain that are at least one hour old.\r\n** - Rollbacks of optimistic rollups. Avoided by running a node.\r\n** - Operators do not have enough time to pause the chain after a fake proposal. Avoided by requiring a minimal amount of time between sending the proposal and executing it.\r\n*/\r\n\r\n\r\n\r\n\r\ncontract Fraxferry {\r\n   IERC20 immutable public token;\r\n   IERC20 immutable public targetToken;\r\n   uint immutable public chainid;\r\n   uint immutable public targetChain;   \r\n   \r\n   address public owner;\r\n   address public nominatedOwner;\r\n   address public captain;\r\n   address public firstOfficer;\r\n   mapping(address => bool) public crewmembers;\r\n   mapping(address => bool) public fee_exempt_addrs;\r\n\r\n   bool public paused;\r\n   \r\n   uint public MIN_WAIT_PERIOD_ADD=3600; // Minimal 1 hour waiting\r\n   uint public MIN_WAIT_PERIOD_EXECUTE=79200; // Minimal 22 hour waiting\r\n   uint public FEE_RATE=10;      // 0.1% fee\r\n   uint public FEE_MIN=5*1e18;   // 5 token min fee\r\n   uint public FEE_MAX=100*1e18; // 100 token max fee\r\n   \r\n   uint constant MAX_FEE_RATE=100; // Max fee rate is 1%\r\n   uint constant MAX_FEE_MIN=100e18; // Max minimum fee is 100 tokens\r\n   uint constant MAX_FEE_MAX=1000e18; // Max fee is 1000 tokens\r\n   \r\n   uint constant public REDUCED_DECIMALS=1e10;\r\n   \r\n   Transaction[] public transactions;\r\n   mapping(uint => bool) public cancelled;\r\n   uint public executeIndex;\r\n   Batch[] public batches;\r\n   \r\n   struct Transaction {\r\n      address user;\r\n      uint64 amount;\r\n      uint32 timestamp;\r\n   }\r\n   \r\n   struct Batch {\r\n      uint64 start;\r\n      uint64 end;\r\n      uint64 departureTime;\r\n      uint64 status;\r\n      bytes32 hash;\r\n   }\r\n   \r\n   struct BatchData {\r\n      uint startTransactionNo;\r\n      Transaction[] transactions;\r\n   }\r\n\r\n   constructor(address _token, uint _chainid, address _targetToken, uint _targetChain) {\r\n      //require (block.chainid==_chainid,\"Wrong chain\");\r\n      chainid=_chainid;\r\n      token = IERC20(_token);\r\n      targetToken = IERC20(_targetToken);\r\n      owner = msg.sender;\r\n      targetChain = _targetChain;\r\n   }\r\n   \r\n   \r\n   // ############## Events ##############\r\n   \r\n   event Embark(address indexed sender, uint index, uint amount, uint amountAfterFee, uint timestamp);\r\n   event Disembark(uint start, uint end, bytes32 hash); \r\n   event Depart(uint batchNo,uint start,uint end,bytes32 hash); \r\n   event RemoveBatch(uint batchNo);\r\n   event DisputeBatch(uint batchNo, bytes32 hash);\r\n   event Cancelled(uint index, bool cancel);\r\n   event Pause(bool paused);\r\n   event OwnerNominated(address indexed newOwner);\r\n   event OwnerChanged(address indexed previousOwner,address indexed newOwner);\r\n   event SetCaptain(address indexed previousCaptain, address indexed newCaptain);   \r\n   event SetFirstOfficer(address indexed previousFirstOfficer, address indexed newFirstOfficer);\r\n   event SetCrewmember(address indexed crewmember,bool set); \r\n   event SetFee(uint previousFeeRate, uint feeRate,uint previousFeeMin, uint feeMin,uint previousFeeMax, uint feeMax);\r\n   event SetMinWaitPeriods(uint previousMinWaitAdd,uint previousMinWaitExecute,uint minWaitAdd,uint minWaitExecute); \r\n   event FeeExemptToggled(address addr,bool is_fee_exempt); \r\n   \r\n\r\n   // ############## Modifiers ##############\r\n   \r\n   modifier isOwner() {\r\n      require (msg.sender==owner,\"Not owner\");\r\n      _;\r\n   }\r\n   \r\n   modifier isCaptain() {\r\n      require (msg.sender==captain,\"Not captain\");\r\n      _;\r\n   }\r\n   \r\n   modifier isFirstOfficer() {\r\n      require (msg.sender==firstOfficer,\"Not first officer\");\r\n      _;\r\n   }   \r\n    \r\n   modifier isCrewmember() {\r\n      require (crewmembers[msg.sender] || msg.sender==owner || msg.sender==captain || msg.sender==firstOfficer,\"Not crewmember\");\r\n      _;\r\n   }\r\n   \r\n   modifier notPaused() {\r\n      require (!paused,\"Paused\");\r\n      _;\r\n   } \r\n   \r\n   // ############## Ferry actions ##############\r\n   \r\n   function embarkWithRecipient(uint amount, address recipient) public notPaused {\r\n      amount = (amount/REDUCED_DECIMALS)*REDUCED_DECIMALS; // Round amount to fit in data structure\r\n      uint fee;\r\n      if(fee_exempt_addrs[msg.sender]) fee = 0;\r\n      else {\r\n         fee = Math.min(Math.max(FEE_MIN,amount*FEE_RATE/10000),FEE_MAX);\r\n      }\r\n      require (amount>fee,\"Amount too low\");\r\n      require (amount/REDUCED_DECIMALS<=type(uint64).max,\"Amount too high\");\r\n      TransferHelper.safeTransferFrom(address(token),msg.sender,address(this),amount); \r\n      uint64 amountAfterFee = uint64((amount-fee)/REDUCED_DECIMALS);\r\n      emit Embark(recipient,transactions.length,amount,amountAfterFee*REDUCED_DECIMALS,block.timestamp);\r\n      transactions.push(Transaction(recipient,amountAfterFee,uint32(block.timestamp)));   \r\n   }\r\n   \r\n   function embark(uint amount) public {\r\n      embarkWithRecipient(amount, msg.sender) ;\r\n   }\r\n\r\n   function embarkWithSignature(\r\n      uint256 _amount,\r\n      address recipient,\r\n      uint256 deadline,\r\n      bool approveMax,\r\n      uint8 v,\r\n      bytes32 r,\r\n      bytes32 s\r\n   ) public {\r\n      uint amount = approveMax ? type(uint256).max : _amount;\r\n      IERC20Permit(address(token)).permit(msg.sender, address(this), amount, deadline, v, r, s);\r\n      embarkWithRecipient(amount,recipient);\r\n   }   \r\n   \r\n   function depart(uint start, uint end, bytes32 hash) external notPaused isCaptain {\r\n      require ((batches.length==0 && start==0) || (batches.length>0 && start==batches[batches.length-1].end+1),\"Wrong start\");\r\n      require (end>=start && end<type(uint64).max,\"Wrong end\");\r\n      batches.push(Batch(uint64(start),uint64(end),uint64(block.timestamp),0,hash));\r\n      emit Depart(batches.length-1,start,end,hash);\r\n   }\r\n   \r\n   function disembark(BatchData calldata batchData) external notPaused isFirstOfficer {\r\n      Batch memory batch = batches[executeIndex++];\r\n      require (batch.status==0,\"Batch disputed\");\r\n      require (batch.start==batchData.startTransactionNo,\"Wrong start\");\r\n      require (batch.start+batchData.transactions.length-1==batch.end,\"Wrong size\");\r\n      require (block.timestamp-batch.departureTime>=MIN_WAIT_PERIOD_EXECUTE,\"Too soon\");\r\n      \r\n      bytes32 hash = keccak256(abi.encodePacked(targetChain, targetToken, chainid, token, batch.start));\r\n      for (uint i=0;i<batchData.transactions.length;++i) {\r\n         if (!cancelled[batch.start+i]) {\r\n            TransferHelper.safeTransfer(address(token),batchData.transactions[i].user,batchData.transactions[i].amount*REDUCED_DECIMALS);\r\n         }\r\n         hash = keccak256(abi.encodePacked(hash, batchData.transactions[i].user,batchData.transactions[i].amount));\r\n      }\r\n      require (batch.hash==hash,\"Wrong hash\");\r\n      emit Disembark(batch.start,batch.end,hash);\r\n   }\r\n   \r\n   function removeBatches(uint batchNo) external isOwner {\r\n      require (executeIndex<=batchNo,\"Batch already executed\");\r\n      while (batches.length>batchNo) batches.pop();\r\n      emit RemoveBatch(batchNo);\r\n   }\r\n   \r\n   function disputeBatch(uint batchNo, bytes32 hash) external isCrewmember {\r\n      require (batches[batchNo].hash==hash,\"Wrong hash\");\r\n      require (executeIndex<=batchNo,\"Batch already executed\");\r\n      require (batches[batchNo].status==0,\"Batch already disputed\");\r\n      batches[batchNo].status=1; // Set status on disputed\r\n      _pause(true);\r\n      emit DisputeBatch(batchNo,hash);\r\n   }\r\n   \r\n   function pause() external isCrewmember {\r\n      _pause(true);\r\n   }\r\n   \r\n   function unPause() external isOwner {\r\n      _pause(false);\r\n   }   \r\n   \r\n   function _pause(bool _paused) internal {\r\n      paused=_paused;\r\n      emit Pause(_paused);\r\n   } \r\n   \r\n   function _jettison(uint index, bool cancel) internal {\r\n      require (executeIndex==0 || index>batches[executeIndex-1].end,\"Transaction already executed\");\r\n      cancelled[index]=cancel;\r\n      emit Cancelled(index,cancel);\r\n   }\r\n   \r\n   function jettison(uint index, bool cancel) external isOwner {\r\n      _jettison(index,cancel);\r\n   }\r\n   \r\n   function jettisonGroup(uint[] calldata indexes, bool cancel) external isOwner {\r\n      for (uint i=0;i<indexes.length;++i) {\r\n         _jettison(indexes[i],cancel);\r\n      }\r\n   }   \r\n   \r\n   // ############## Parameters management ##############\r\n   \r\n   function setFee(uint _FEE_RATE, uint _FEE_MIN, uint _FEE_MAX) external isOwner {\r\n      require(_FEE_RATE<MAX_FEE_RATE);\r\n      require(_FEE_MIN<MAX_FEE_MIN);\r\n      require(_FEE_MAX<MAX_FEE_MAX);\r\n      emit SetFee(FEE_RATE,_FEE_RATE,FEE_MIN,_FEE_MIN,FEE_MAX,_FEE_MAX);\r\n      FEE_RATE=_FEE_RATE;\r\n      FEE_MIN=_FEE_MIN;\r\n      FEE_MAX=_FEE_MAX;\r\n   }\r\n   \r\n   function setMinWaitPeriods(uint _MIN_WAIT_PERIOD_ADD, uint _MIN_WAIT_PERIOD_EXECUTE) external isOwner {\r\n      require(_MIN_WAIT_PERIOD_ADD>=3600 && _MIN_WAIT_PERIOD_EXECUTE>=3600,\"Period too short\");\r\n      emit SetMinWaitPeriods(MIN_WAIT_PERIOD_ADD, MIN_WAIT_PERIOD_EXECUTE,_MIN_WAIT_PERIOD_ADD, _MIN_WAIT_PERIOD_EXECUTE);\r\n      MIN_WAIT_PERIOD_ADD=_MIN_WAIT_PERIOD_ADD;\r\n      MIN_WAIT_PERIOD_EXECUTE=_MIN_WAIT_PERIOD_EXECUTE;\r\n   }\r\n   \r\n   // ############## Roles management ##############\r\n   \r\n   function nominateNewOwner(address newOwner) external isOwner {\r\n      nominatedOwner = newOwner;\r\n      emit OwnerNominated(newOwner);\r\n   }   \r\n   \r\n   function acceptOwnership() external {\r\n      require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n      emit OwnerChanged(owner, nominatedOwner);\r\n      owner = nominatedOwner;\r\n      nominatedOwner = address(0);\r\n   }\r\n   \r\n   function setCaptain(address newCaptain) external isOwner {\r\n      emit SetCaptain(captain,newCaptain);\r\n      captain=newCaptain;\r\n   }\r\n   \r\n   function setFirstOfficer(address newFirstOfficer) external isOwner {\r\n      emit SetFirstOfficer(firstOfficer,newFirstOfficer);\r\n      firstOfficer=newFirstOfficer;\r\n   }    \r\n   \r\n   function setCrewmember(address crewmember, bool set) external isOwner {\r\n      crewmembers[crewmember]=set;\r\n      emit SetCrewmember(crewmember,set);\r\n   }   \r\n\r\n   function toggleFeeExemptAddr(address addr) external isOwner {\r\n      fee_exempt_addrs[addr] = !fee_exempt_addrs[addr];\r\n      emit FeeExemptToggled(addr,fee_exempt_addrs[addr]);\r\n   }   \r\n  \r\n   \r\n   // ############## Token management ##############   \r\n   \r\n   function sendTokens(address receiver, uint amount) external isOwner {\r\n      require (receiver!=address(0),\"Zero address not allowed\");\r\n      TransferHelper.safeTransfer(address(token),receiver,amount);\r\n   }   \r\n   \r\n   // Generic proxy\r\n   function execute(address _to, uint256 _value, bytes calldata _data) external isOwner returns (bool, bytes memory) {\r\n      require(_data.length==0 || _to.code.length>0,\"Can not call a function on a EOA\");\r\n      (bool success, bytes memory result) = _to.call{value:_value}(_data);\r\n      return (success, result);\r\n   }   \r\n   \r\n   // ############## Views ##############\r\n   function getNextBatch(uint _start, uint max) public view returns (uint start, uint end, bytes32 hash) {\r\n      uint cutoffTime = block.timestamp-MIN_WAIT_PERIOD_ADD;\r\n      if (_start<transactions.length && transactions[_start].timestamp<cutoffTime) {\r\n         start=_start;\r\n         end=start+max-1;\r\n         if (end>=transactions.length) end=transactions.length-1;\r\n         while(transactions[end].timestamp>=cutoffTime) end--;\r\n         hash = getTransactionsHash(start,end);\r\n      }\r\n   }\r\n   \r\n   function getBatchData(uint start, uint end) public view returns (BatchData memory data) {\r\n      data.startTransactionNo = start;\r\n      data.transactions = new Transaction[](end-start+1);\r\n      for (uint i=start;i<=end;++i) {\r\n         data.transactions[i-start]=transactions[i];\r\n      }\r\n   }\r\n   \r\n   function getBatchAmount(uint start, uint end) public view returns (uint totalAmount) {\r\n      for (uint i=start;i<=end;++i) {\r\n         totalAmount+=transactions[i].amount;\r\n      }\r\n      totalAmount*=REDUCED_DECIMALS;\r\n   }\r\n   \r\n   function getTransactionsHash(uint start, uint end) public view returns (bytes32) {\r\n      bytes32 result = keccak256(abi.encodePacked(chainid, token, targetChain, targetToken, uint64(start)));\r\n      for (uint i=start;i<=end;++i) {\r\n         result = keccak256(abi.encodePacked(result, transactions[i].user,transactions[i].amount));\r\n      }\r\n      return result;\r\n   }   \r\n   \r\n   function noTransactions() public view returns (uint) {\r\n      return transactions.length;\r\n   }\r\n   \r\n   function noBatches() public view returns (uint) {\r\n      return batches.length;\r\n   }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_targetChain\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Depart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Disembark\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"DisputeBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAfterFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Embark\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"is_fee_exempt\",\"type\":\"bool\"}],\"name\":\"FeeExemptToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"}],\"name\":\"RemoveBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousCaptain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCaptain\",\"type\":\"address\"}],\"name\":\"SetCaptain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"crewmember\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"SetCrewmember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousFeeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousFeeMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousFeeMax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeMax\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFirstOfficer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFirstOfficer\",\"type\":\"address\"}],\"name\":\"SetFirstOfficer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMinWaitAdd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMinWaitExecute\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWaitAdd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWaitExecute\",\"type\":\"uint256\"}],\"name\":\"SetMinWaitPeriods\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WAIT_PERIOD_ADD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WAIT_PERIOD_EXECUTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REDUCED_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batches\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"departureTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"status\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"captain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"crewmembers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"depart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTransactionNo\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Fraxferry.Transaction[]\",\"name\":\"transactions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fraxferry.BatchData\",\"name\":\"batchData\",\"type\":\"tuple\"}],\"name\":\"disembark\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"disputeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"embark\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"embarkWithRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"embarkWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fee_exempt_addrs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstOfficer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getBatchAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getBatchData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTransactionNo\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Fraxferry.Transaction[]\",\"name\":\"transactions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fraxferry.BatchData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"getNextBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getTransactionsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"}],\"name\":\"jettison\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"}],\"name\":\"jettisonGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noBatches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"}],\"name\":\"removeBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCaptain\",\"type\":\"address\"}],\"name\":\"setCaptain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crewmember\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"setCrewmember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_FEE_RATE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_FEE_MIN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_FEE_MAX\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFirstOfficer\",\"type\":\"address\"}],\"name\":\"setFirstOfficer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_MIN_WAIT_PERIOD_ADD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MIN_WAIT_PERIOD_EXECUTE\",\"type\":\"uint256\"}],\"name\":\"setMinWaitPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"toggleFeeExemptAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Fraxferry", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000a63f56985f9c7f3bc9ffc5685535649e0c1a55f30000000000000000000000000000000000000000000000000000000000000038000000000000000000000000a663b02cf0a4b149d2ad41910cb81e23e1c41c320000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://295475025cbe3a698c2aca619caedc853e1dd3d95957b5d820e26cd249b364a4"}