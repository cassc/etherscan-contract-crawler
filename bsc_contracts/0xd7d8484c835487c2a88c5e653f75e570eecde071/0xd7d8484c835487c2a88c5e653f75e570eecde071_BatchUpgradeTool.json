{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tranchessV1/upgrade/BatchUpgradeTool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../fund/PrimaryMarket.sol\\\";\\nimport \\\"../exchange/ExchangeV3.sol\\\";\\nimport \\\"./UpgradeTool.sol\\\";\\n\\ncontract BatchUpgradeTool {\\n    using SafeMath for uint256;\\n\\n    /// @dev `encodedData` consists of two types of data:\\n    ///      - unsettled epochs\\n    ///      - bid orders\\n    //       Unsettled epochs are encoded as follows:\\n    //       Bit  255       | 0 (constant)\\n    //       Bit [224, 228) | exchangeIndex\\n    //       Bit 192        | 0 (maker), 1(taker)\\n    //       Bit [0, 64)    | epoch\\n    //       Bid orders are encoded as follows:\\n    //       Bit  255       | 1 (constant)\\n    //       Bit [224, 228) | exchangeIndex\\n    //       Bit [76, 80)   | version\\n    //       Bit [72, 76)   | tranche\\n    //       Bit [64, 72)   | pdLevel\\n    //       Bit [0, 64)    | index\\n    /// @return tokenAmounts An array of (upgradeTools.length * 3) values, containing the amount\\n    ///         of three tokens upgraded for each Fund\\n    /// @return underlyingAmounts An array of (oldPrimaryMarkets.length + oldWrappedPrimaryMarkets.length)\\n    ///         values, containing the amount of underlying tokens claimed from each primary market\\n    /// @return totalQuoteAmount Total amount of quote tokens returned to the account.\\n    /// @return totalRewards Total amount of CHESS claimed by the account.\\n    function batchProtocolUpgrade(\\n        address[] calldata oldPrimaryMarkets,\\n        address[] calldata oldWrappedPrimaryMarkets,\\n        address[] calldata upgradeTools,\\n        uint256[] calldata encodedData,\\n        address account\\n    )\\n        external\\n        returns (\\n            uint256[] memory tokenAmounts,\\n            uint256[] memory underlyingAmounts,\\n            uint256 totalQuoteAmount,\\n            uint256 totalRewards\\n        )\\n    {\\n        underlyingAmounts = new uint256[](\\n            oldPrimaryMarkets.length + oldWrappedPrimaryMarkets.length\\n        );\\n        for (uint256 i = 0; i < oldPrimaryMarkets.length; i++) {\\n            (, underlyingAmounts[i]) = IPrimaryMarket(oldPrimaryMarkets[i]).claim(account);\\n        }\\n        for (uint256 i = 0; i < oldWrappedPrimaryMarkets.length; i++) {\\n            (, underlyingAmounts[i + oldPrimaryMarkets.length]) = IPrimaryMarketV2(\\n                oldWrappedPrimaryMarkets[i]\\n            )\\n                .claimAndUnwrap(account);\\n        }\\n\\n        for (uint256 i = 0; i < encodedData.length; i++) {\\n            uint256 encodedDatum = encodedData[i];\\n            uint256 exchangeIndex = (encodedDatum >> 224) & 0xF;\\n            ExchangeV3 exchange =\\n                ExchangeV3(address(UpgradeTool(upgradeTools[exchangeIndex]).oldExchange()));\\n            uint256 quoteAmount;\\n            if ((encodedDatum >> 255) == 0) {\\n                // unsettled epochs\\n                uint256 epoch = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                (, , , quoteAmount) = ((encodedDatum >> 192) & 0x1 == 0)\\n                    ? exchange.settleMaker(account, epoch)\\n                    : exchange.settleTaker(account, epoch);\\n            } else {\\n                // bid orders\\n                uint256 version = (encodedDatum >> 76) & 0xF;\\n                uint256 tranche = (encodedDatum >> 72) & 0xF;\\n                uint256 pdLevel = (encodedDatum >> 64) & 0xFF;\\n                uint256 index = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                quoteAmount = exchange.cancelBid(version, tranche, pdLevel, index);\\n            }\\n            totalQuoteAmount = totalQuoteAmount.add(quoteAmount);\\n        }\\n\\n        tokenAmounts = new uint256[](upgradeTools.length * 3);\\n        for (uint256 i = 0; i < upgradeTools.length; i++) {\\n            UpgradeTool tool = UpgradeTool(upgradeTools[i]);\\n            if (address(tool) == address(0)) {\\n                continue;\\n            }\\n            uint256 claimedRewards;\\n            (\\n                tokenAmounts[i * 3],\\n                tokenAmounts[i * 3 + 1],\\n                tokenAmounts[i * 3 + 2],\\n                claimedRewards\\n            ) = tool.protocolUpgrade(account);\\n            totalRewards = totalRewards.add(claimedRewards);\\n        }\\n    }\\n\\n    /// @notice Same as `batchProtocolUpgrade` but returns minimal parameters that should be used\\n    ///         to call `batchProtocolUpgrade`.\\n    function batchProtocolUpgradeParameters(\\n        address[] memory oldPrimaryMarkets,\\n        address[] memory oldWrappedPrimaryMarkets,\\n        address[] memory upgradeTools,\\n        uint256[] memory encodedData,\\n        address account\\n    )\\n        external\\n        returns (\\n            address[] memory,\\n            address[] memory,\\n            address[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        bool[] memory requiredTools = new bool[](upgradeTools.length);\\n        _filterPrimaryMarkets(1, oldPrimaryMarkets, upgradeTools, requiredTools, account);\\n        _filterPrimaryMarkets(2, oldWrappedPrimaryMarkets, upgradeTools, requiredTools, account);\\n        _filterEncodedData(encodedData, upgradeTools, requiredTools, account);\\n        _filterUpgradeTools(upgradeTools, requiredTools, account);\\n        return (oldPrimaryMarkets, oldWrappedPrimaryMarkets, upgradeTools, encodedData);\\n    }\\n\\n    function _filterPrimaryMarkets(\\n        uint256 fundVersion,\\n        address[] memory primaryMarkets,\\n        address[] memory upgradeTools,\\n        bool[] memory requiredTools,\\n        address account\\n    ) private {\\n        for (uint256 i = 0; i < primaryMarkets.length; i++) {\\n            (uint256 shares, uint256 underlying) =\\n                fundVersion == 1\\n                    ? IPrimaryMarket(primaryMarkets[i]).claim(account)\\n                    : IPrimaryMarketV2(primaryMarkets[i]).claimAndUnwrap(account);\\n            if (shares | underlying == 0) {\\n                primaryMarkets[i] = address(0);\\n            } else if (shares != 0) {\\n                address tokenUnderlying = PrimaryMarket(primaryMarkets[i]).fund().tokenUnderlying();\\n                for (uint256 j = 0; j < upgradeTools.length; j++) {\\n                    if (\\n                        address(UpgradeTool(upgradeTools[j]).tokenUnderlying()) == tokenUnderlying\\n                    ) {\\n                        requiredTools[j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        _packAddressArray(primaryMarkets);\\n    }\\n\\n    function _filterEncodedData(\\n        uint256[] memory encodedData,\\n        address[] memory upgradeTools,\\n        bool[] memory requiredTools,\\n        address account\\n    ) private {\\n        for (uint256 i = 0; i < encodedData.length; i++) {\\n            uint256 encodedDatum = encodedData[i];\\n            uint256 exchangeIndex = (encodedDatum >> 224) & 0xF;\\n            ExchangeV3 exchange =\\n                ExchangeV3(address(UpgradeTool(upgradeTools[exchangeIndex]).oldExchange()));\\n            if ((encodedDatum >> 255) == 0) {\\n                // unsettled epochs\\n                uint256 epoch = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                (uint256 amountM, uint256 amountA, uint256 amountB, uint256 quoteAmount) =\\n                    ((encodedDatum >> 192) & 0x1 == 0)\\n                        ? exchange.settleMaker(account, epoch)\\n                        : exchange.settleTaker(account, epoch);\\n                if (amountM | amountA | amountB | quoteAmount == 0) {\\n                    encodedData[i] = 0;\\n                } else {\\n                    requiredTools[exchangeIndex] = true;\\n                }\\n            } else {\\n                // bid orders\\n                uint256 version = (encodedDatum >> 76) & 0xF;\\n                uint256 tranche = (encodedDatum >> 72) & 0xF;\\n                uint256 pdLevel = (encodedDatum >> 64) & 0xFF;\\n                uint256 index = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                (address maker, , ) = exchange.getBidOrder(version, tranche, pdLevel, index);\\n                if (maker != account) {\\n                    encodedData[i] = 0;\\n                } else {\\n                    exchange.cancelBid(version, tranche, pdLevel, index);\\n                    requiredTools[exchangeIndex] = true;\\n                }\\n            }\\n        }\\n        _packUintArray(encodedData);\\n    }\\n\\n    function _filterUpgradeTools(\\n        address[] memory upgradeTools,\\n        bool[] memory requiredTools,\\n        address account\\n    ) private {\\n        for (uint256 i = 0; i < upgradeTools.length; i++) {\\n            UpgradeTool tool = UpgradeTool(upgradeTools[i]);\\n            (uint256 r1, uint256 r2, uint256 r3, uint256 r4) = tool.protocolUpgrade(account);\\n            if (r1 | r2 | r3 | r4 == 0 && !requiredTools[i]) {\\n                upgradeTools[i] = address(0);\\n            }\\n        }\\n        // Do not pack upgradeTools because encodedData has references to it\\n    }\\n\\n    function _packAddressArray(address[] memory array) private pure {\\n        uint256 newLength = 0;\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] != address(0)) {\\n                array[newLength] = array[i];\\n                newLength += 1;\\n            }\\n        }\\n        assembly {\\n            mstore(array, newLength)\\n        }\\n    }\\n\\n    function _packUintArray(uint256[] memory array) private pure {\\n        uint256 newLength = 0;\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] != 0) {\\n                array[newLength] = array[i];\\n                newLength += 1;\\n            }\\n        }\\n        assembly {\\n            mstore(array, newLength)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IPrimaryMarketV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./IPrimaryMarket.sol\\\";\\n\\ninterface IPrimaryMarketV2 is IPrimaryMarket {\\n    function claimAndUnwrap(address account)\\n        external\\n        returns (uint256 createdShares, uint256 redeemedUnderlying);\\n\\n    function updateDelayedRedemptionDay() external;\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/PrimaryMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarket.sol\\\";\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\n\\ncontract PrimaryMarket is IPrimaryMarket, ReentrancyGuard, ITrancheIndex, Ownable {\\n    event Created(address indexed account, uint256 underlying);\\n    event Redeemed(address indexed account, uint256 shares);\\n    event Split(address indexed account, uint256 inM, uint256 outA, uint256 outB);\\n    event Merged(address indexed account, uint256 outM, uint256 inA, uint256 inB);\\n    event Claimed(address indexed account, uint256 createdShares, uint256 redeemedUnderlying);\\n    event Settled(\\n        uint256 indexed day,\\n        uint256 sharesToMint,\\n        uint256 sharesToBurn,\\n        uint256 creationUnderlying,\\n        uint256 redemptionUnderlying,\\n        uint256 fee\\n    );\\n\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Creation and redemption of a single account.\\n    /// @param day Day of the last creation or redemption request.\\n    /// @param creatingUnderlying Underlying that will be used for creation at the end of this day.\\n    /// @param redeemingShares Shares that will be redeemed at the end of this day.\\n    /// @param createdShares Shares already created in previous days.\\n    /// @param redeemedUnderlying Underlying already redeemed in previous days.\\n    /// @param version Rebalance version before the end of this trading day.\\n    struct CreationRedemption {\\n        uint256 day;\\n        uint256 creatingUnderlying;\\n        uint256 redeemingShares;\\n        uint256 createdShares;\\n        uint256 redeemedUnderlying;\\n        uint256 version;\\n    }\\n\\n    uint256 private constant MAX_REDEMPTION_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_SPLIT_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_MERGE_FEE_RATE = 0.01e18;\\n\\n    uint256 public immutable guardedLaunchStart;\\n    uint256 public guardedLaunchTotalCap;\\n    uint256 public guardedLaunchIndividualCap;\\n    mapping(address => uint256) public guardedLaunchCreations;\\n\\n    IFund public fund;\\n\\n    uint256 public redemptionFeeRate;\\n    uint256 public splitFeeRate;\\n    uint256 public mergeFeeRate;\\n    uint256 public minCreationUnderlying;\\n\\n    mapping(address => CreationRedemption) private _creationRedemptions;\\n\\n    uint256 public currentDay;\\n    uint256 public currentCreatingUnderlying;\\n    uint256 public currentRedeemingShares;\\n    uint256 public currentFeeInShares;\\n\\n    mapping(uint256 => uint256) private _historicalCreationRate;\\n    mapping(uint256 => uint256) private _historicalRedemptionRate;\\n\\n    constructor(\\n        address fund_,\\n        uint256 guardedLaunchStart_,\\n        uint256 redemptionFeeRate_,\\n        uint256 splitFeeRate_,\\n        uint256 mergeFeeRate_,\\n        uint256 minCreationUnderlying_\\n    ) public Ownable() {\\n        require(redemptionFeeRate_ <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        require(splitFeeRate_ <= MAX_SPLIT_FEE_RATE, \\\"Exceed max split fee rate\\\");\\n        require(mergeFeeRate_ <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        fund = IFund(fund_);\\n        guardedLaunchStart = guardedLaunchStart_;\\n        redemptionFeeRate = redemptionFeeRate_;\\n        splitFeeRate = splitFeeRate_;\\n        mergeFeeRate = mergeFeeRate_;\\n        minCreationUnderlying = minCreationUnderlying_;\\n        currentDay = fund.currentDay();\\n    }\\n\\n    function creationRedemptionOf(address account)\\n        external\\n        view\\n        returns (CreationRedemption memory)\\n    {\\n        return _currentCreationRedemption(account);\\n    }\\n\\n    function create(uint256 underlying) external nonReentrant onlyActive {\\n        require(underlying >= minCreationUnderlying, \\\"Min amount\\\");\\n        IERC20(fund.tokenUnderlying()).safeTransferFrom(msg.sender, address(this), underlying);\\n\\n        CreationRedemption memory cr = _currentCreationRedemption(msg.sender);\\n        cr.creatingUnderlying = cr.creatingUnderlying.add(underlying);\\n        _updateCreationRedemption(msg.sender, cr);\\n\\n        currentCreatingUnderlying = currentCreatingUnderlying.add(underlying);\\n\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            guardedLaunchCreations[msg.sender] = guardedLaunchCreations[msg.sender].add(underlying);\\n            require(\\n                IERC20(fund.tokenUnderlying()).balanceOf(address(fund)).add(\\n                    currentCreatingUnderlying\\n                ) <= guardedLaunchTotalCap,\\n                \\\"Guarded launch: exceed total cap\\\"\\n            );\\n            require(\\n                guardedLaunchCreations[msg.sender] <= guardedLaunchIndividualCap,\\n                \\\"Guarded launch: exceed individual cap\\\"\\n            );\\n        }\\n\\n        emit Created(msg.sender, underlying);\\n    }\\n\\n    function redeem(uint256 shares) external onlyActive {\\n        require(shares != 0, \\\"Zero shares\\\");\\n        // Use burn and mint to simulate a transfer, so that we don't need a special transferFrom()\\n        fund.burn(TRANCHE_M, msg.sender, shares);\\n        fund.mint(TRANCHE_M, address(this), shares);\\n\\n        CreationRedemption memory cr = _currentCreationRedemption(msg.sender);\\n        cr.redeemingShares = cr.redeemingShares.add(shares);\\n        _updateCreationRedemption(msg.sender, cr);\\n\\n        currentRedeemingShares = currentRedeemingShares.add(shares);\\n        emit Redeemed(msg.sender, shares);\\n    }\\n\\n    function claim(address account)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 createdShares, uint256 redeemedUnderlying)\\n    {\\n        CreationRedemption memory cr = _currentCreationRedemption(account);\\n        createdShares = cr.createdShares;\\n        redeemedUnderlying = cr.redeemedUnderlying;\\n\\n        if (createdShares > 0) {\\n            IERC20(fund.tokenM()).safeTransfer(account, createdShares);\\n            cr.createdShares = 0;\\n        }\\n        if (redeemedUnderlying > 0) {\\n            IERC20(fund.tokenUnderlying()).safeTransfer(account, redeemedUnderlying);\\n            cr.redeemedUnderlying = 0;\\n        }\\n        _updateCreationRedemption(account, cr);\\n\\n        emit Claimed(account, createdShares, redeemedUnderlying);\\n    }\\n\\n    function split(uint256 inM) external onlyActive {\\n        require(\\n            block.timestamp >= guardedLaunchStart + 2 weeks,\\n            \\\"Guarded launch: split not ready yet\\\"\\n        );\\n        (uint256 weightA, uint256 weightB) = fund.trancheWeights();\\n        // Charge splitting fee and round it to a multiple of (weightA + weightB)\\n        uint256 unit = inM.sub(inM.multiplyDecimal(splitFeeRate)) / (weightA + weightB);\\n        require(unit > 0, \\\"Too little to split\\\");\\n        uint256 inMAfterFee = unit * (weightA + weightB);\\n        uint256 outA = unit * weightA;\\n        uint256 outB = inMAfterFee - outA;\\n        uint256 feeM = inM - inMAfterFee;\\n\\n        fund.burn(TRANCHE_M, msg.sender, inM);\\n        fund.mint(TRANCHE_A, msg.sender, outA);\\n        fund.mint(TRANCHE_B, msg.sender, outB);\\n        fund.mint(TRANCHE_M, address(this), feeM);\\n\\n        currentFeeInShares = currentFeeInShares.add(feeM);\\n        emit Split(msg.sender, inM, outA, outB);\\n    }\\n\\n    function merge(uint256 inA) external onlyActive {\\n        (uint256 weightA, uint256 weightB) = fund.trancheWeights();\\n        // Round to tranche weights\\n        uint256 unit = inA / weightA;\\n        require(unit > 0, \\\"Too little to merge\\\");\\n        // Keep unmergable Token A unchanged.\\n        inA = unit * weightA;\\n        uint256 inB = unit.mul(weightB);\\n        uint256 outMBeforeFee = inA.add(inB);\\n        uint256 feeM = outMBeforeFee.multiplyDecimal(mergeFeeRate);\\n        uint256 outM = outMBeforeFee.sub(feeM);\\n\\n        fund.burn(TRANCHE_A, msg.sender, inA);\\n        fund.burn(TRANCHE_B, msg.sender, inB);\\n        fund.mint(TRANCHE_M, msg.sender, outM);\\n        fund.mint(TRANCHE_M, address(this), feeM);\\n\\n        currentFeeInShares = currentFeeInShares.add(feeM);\\n        emit Merged(msg.sender, outM, inA, inB);\\n    }\\n\\n    /// @notice Settle ongoing creations and redemptions and also split and merge fees.\\n    ///\\n    ///         Creations and redemptions are settled according to the current shares and\\n    ///         underlying assets in the fund. Split and merge fee charged as Token M are also\\n    ///         redeemed at the same rate (without redemption fee).\\n    ///\\n    ///         This function does not mint or burn shares, nor transfer underlying assets.\\n    ///         It returns the following changes that should be done by the fund:\\n    ///\\n    ///         1. Mint or burn net shares (creations v.s. redemptions + split/merge fee).\\n    ///         2. Transfer underlying to or from this contract (creations v.s. redemptions).\\n    ///         3. Transfer fee in underlying assets to the governance address.\\n    ///\\n    ///         This function can only be called from the Fund contract. It should be called\\n    ///         after protocol fee is collected and before rebalance is triggered for the same\\n    ///         trading day.\\n    /// @param day The trading day to settle\\n    /// @param fundTotalShares Total shares of the fund (as if all Token A and B are merged)\\n    /// @param fundUnderlying Underlying assets in the fund\\n    /// @param underlyingPrice Price of the underlying assets at the end of the trading day\\n    /// @param previousNav NAV of Token M of the previous trading day\\n    /// @return sharesToMint Amount of Token M to mint for creations\\n    /// @return sharesToBurn Amount of Token M to burn for redemptions and split/merge fee\\n    /// @return creationUnderlying Underlying assets received for creations (including creation fee)\\n    /// @return redemptionUnderlying Underlying assets to be redeemed (excluding redemption fee)\\n    /// @return fee Total fee in underlying assets for the fund to transfer to the governance address,\\n    ///         inlucding creation fee, redemption fee and split/merge fee\\n    function settle(\\n        uint256 day,\\n        uint256 fundTotalShares,\\n        uint256 fundUnderlying,\\n        uint256 underlyingPrice,\\n        uint256 previousNav\\n    )\\n        external\\n        override\\n        nonReentrant\\n        onlyFund\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        )\\n    {\\n        require(day >= currentDay, \\\"Already settled\\\");\\n\\n        // Creation\\n        creationUnderlying = currentCreatingUnderlying;\\n        if (creationUnderlying > 0) {\\n            if (fundUnderlying > 0) {\\n                sharesToMint = creationUnderlying.mul(fundTotalShares).div(fundUnderlying);\\n            } else {\\n                // NAV is rounded down. Computing creations using NAV results in rounded up shares,\\n                // which is unfair to existing share holders. We only do that when there are\\n                // no shares before.\\n                require(\\n                    fundTotalShares == 0,\\n                    \\\"Cannot create shares for fund with shares but no underlying\\\"\\n                );\\n                require(previousNav > 0, \\\"Cannot create shares at zero NAV\\\");\\n                sharesToMint = creationUnderlying\\n                    .mul(underlyingPrice)\\n                    .mul(fund.underlyingDecimalMultiplier())\\n                    .div(previousNav);\\n            }\\n            _historicalCreationRate[day] = sharesToMint.divideDecimal(creationUnderlying);\\n        }\\n\\n        // Redemption\\n        sharesToBurn = currentRedeemingShares;\\n        if (sharesToBurn > 0) {\\n            uint256 underlying = sharesToBurn.mul(fundUnderlying).div(fundTotalShares);\\n            uint256 redemptionFee = underlying.multiplyDecimal(redemptionFeeRate);\\n            redemptionUnderlying = underlying.sub(redemptionFee);\\n            _historicalRedemptionRate[day] = redemptionUnderlying.divideDecimal(sharesToBurn);\\n            fee = redemptionFee;\\n        }\\n\\n        // Redeem split and merge fee\\n        uint256 feeInShares = currentFeeInShares;\\n        if (feeInShares > 0) {\\n            sharesToBurn = sharesToBurn.add(feeInShares);\\n            fee = fee.add(feeInShares.mul(fundUnderlying).div(fundTotalShares));\\n        }\\n\\n        // Approve the fund to take underlying if creation is more than redemption.\\n        // Instead of directly transfering underlying to the fund, this implementation\\n        // makes testing much easier.\\n        if (creationUnderlying > redemptionUnderlying) {\\n            IERC20(fund.tokenUnderlying()).safeApprove(\\n                address(fund),\\n                creationUnderlying - redemptionUnderlying\\n            );\\n        }\\n\\n        // This loop should never execute, because this function is called by Fund\\n        // for every day. We fill the gap just in case that something goes wrong in Fund.\\n        for (uint256 t = currentDay; t < day; t += 1 days) {\\n            _historicalCreationRate[t] = _historicalCreationRate[day];\\n            _historicalRedemptionRate[t] = _historicalRedemptionRate[day];\\n        }\\n\\n        currentDay = day + 1 days;\\n        currentCreatingUnderlying = 0;\\n        currentRedeemingShares = 0;\\n        currentFeeInShares = 0;\\n        emit Settled(\\n            day,\\n            sharesToMint,\\n            sharesToBurn,\\n            creationUnderlying,\\n            redemptionUnderlying,\\n            fee\\n        );\\n    }\\n\\n    function updateGuardedLaunchCap(uint256 newTotalCap, uint256 newIndividualCap)\\n        external\\n        onlyOwner\\n    {\\n        guardedLaunchTotalCap = newTotalCap;\\n        guardedLaunchIndividualCap = newIndividualCap;\\n    }\\n\\n    function updateRedemptionFeeRate(uint256 newRedemptionFeeRate) external onlyOwner {\\n        require(newRedemptionFeeRate <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        redemptionFeeRate = newRedemptionFeeRate;\\n    }\\n\\n    function updateSplitFeeRate(uint256 newSplitFeeRate) external onlyOwner {\\n        require(newSplitFeeRate <= MAX_SPLIT_FEE_RATE, \\\"Exceed max split fee rate\\\");\\n        splitFeeRate = newSplitFeeRate;\\n    }\\n\\n    function updateMergeFeeRate(uint256 newMergeFeeRate) external onlyOwner {\\n        require(newMergeFeeRate <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        mergeFeeRate = newMergeFeeRate;\\n    }\\n\\n    function updateMinCreationUnderlying(uint256 newMinCreationUnderlying) external onlyOwner {\\n        minCreationUnderlying = newMinCreationUnderlying;\\n    }\\n\\n    function _currentCreationRedemption(address account)\\n        private\\n        view\\n        returns (CreationRedemption memory cr)\\n    {\\n        cr = _creationRedemptions[account];\\n        uint256 oldDay = cr.day;\\n        if (oldDay < currentDay) {\\n            if (cr.creatingUnderlying > 0) {\\n                cr.createdShares = cr.createdShares.add(\\n                    cr.creatingUnderlying.multiplyDecimal(_historicalCreationRate[oldDay])\\n                );\\n                cr.creatingUnderlying = 0;\\n            }\\n            uint256 rebalanceSize = fund.getRebalanceSize();\\n            if (cr.version < rebalanceSize) {\\n                if (cr.createdShares > 0) {\\n                    (cr.createdShares, , ) = fund.batchRebalance(\\n                        cr.createdShares,\\n                        0,\\n                        0,\\n                        cr.version,\\n                        rebalanceSize\\n                    );\\n                }\\n                cr.version = rebalanceSize;\\n            }\\n            if (cr.redeemingShares > 0) {\\n                cr.redeemedUnderlying = cr.redeemedUnderlying.add(\\n                    cr.redeemingShares.multiplyDecimal(_historicalRedemptionRate[oldDay])\\n                );\\n                cr.redeemingShares = 0;\\n            }\\n            cr.day = currentDay;\\n        }\\n    }\\n\\n    function _updateCreationRedemption(address account, CreationRedemption memory cr) private {\\n        CreationRedemption storage old = _creationRedemptions[account];\\n        if (old.day != cr.day) {\\n            old.day = cr.day;\\n        }\\n        if (old.creatingUnderlying != cr.creatingUnderlying) {\\n            old.creatingUnderlying = cr.creatingUnderlying;\\n        }\\n        if (old.redeemingShares != cr.redeemingShares) {\\n            old.redeemingShares = cr.redeemingShares;\\n        }\\n        if (old.createdShares != cr.createdShares) {\\n            old.createdShares = cr.createdShares;\\n        }\\n        if (old.redeemedUnderlying != cr.redeemedUnderlying) {\\n            old.redeemedUnderlying = cr.redeemedUnderlying;\\n        }\\n        if (old.version != cr.version) {\\n            old.version = cr.version;\\n        }\\n    }\\n\\n    modifier onlyActive() {\\n        require(fund.isPrimaryMarketActive(address(this), block.timestamp), \\\"Only when active\\\");\\n        _;\\n    }\\n\\n    modifier onlyFund() {\\n        require(msg.sender == address(fund), \\\"Only fund\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/ExchangeV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/ProxyUtility.sol\\\";\\n\\nimport {Order, OrderQueue, LibOrderQueue} from \\\"./LibOrderQueue.sol\\\";\\nimport {\\n    UnsettledBuyTrade,\\n    UnsettledSellTrade,\\n    UnsettledTrade,\\n    LibUnsettledBuyTrade,\\n    LibUnsettledSellTrade\\n} from \\\"./LibUnsettledTrade.sol\\\";\\n\\nimport \\\"./ExchangeRoles.sol\\\";\\nimport \\\"./StakingV3.sol\\\";\\n\\n/// @title Tranchess's Exchange Contract\\n/// @notice A decentralized exchange to match premium-discount orders and clear trades\\n/// @author Tranchess\\ncontract ExchangeV3 is ExchangeRoles, StakingV3, ProxyUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using SafeDecimalMath for uint256;\\n    using LibOrderQueue for OrderQueue;\\n    using SafeERC20 for IERC20;\\n    using LibUnsettledBuyTrade for UnsettledBuyTrade;\\n    using LibUnsettledSellTrade for UnsettledSellTrade;\\n\\n    /// @notice A maker bid order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to buy\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event BidOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker ask order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event AskOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker bid order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Original amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled, rounding precision to 18 for\\n    ///                 quote assets with precision other than 18 decimal places\\n    event BidOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice A maker ask order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Original amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled\\n    event AskOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice Matching result of a taker bid order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param quoteAmount Matched amount of quote asset, rounding precision to 18 for quote assets\\n    ///                    with precision other than 18 decimal places\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedBaseAmount Matched base asset amount of the last matched maker order\\n    event BuyTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedBaseAmount\\n    );\\n\\n    /// @notice Matching result of a taker ask order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param baseAmount Matched amount of base asset\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedQuoteAmount Matched quote asset amount of the last matched maker order,\\n    ///                               rounding precision to 18 for quote assets with precision\\n    ///                               other than 18 decimal places\\n    event SellTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedQuoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of maker orders.\\n    /// @param account Account placing the related maker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event MakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of taker orders.\\n    /// @param account Account placing the related taker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event TakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    uint256 private constant EPOCH = 30 minutes; // An exchange epoch is 30 minutes long\\n\\n    /// @dev Maker reserves 105% of Token M they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_M = 1.05e18;\\n\\n    /// @dev Maker reserves 100.1% of Token A they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_A = 1.001e18;\\n\\n    /// @dev Maker reserves 110% of Token B they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_B = 1.1e18;\\n\\n    /// @dev Premium-discount level ranges from -10% to 10% with 0.25% as step size\\n    uint256 private constant PD_TICK = 0.0025e18;\\n\\n    uint256 private constant MIN_PD = 0.9e18;\\n    uint256 private constant MAX_PD = 1.1e18;\\n    uint256 private constant PD_START = MIN_PD - PD_TICK;\\n    uint256 private constant PD_LEVEL_COUNT = (MAX_PD - MIN_PD) / PD_TICK + 1;\\n\\n    /// @notice Minumum quote amount of maker bid orders with 18 decimal places\\n    uint256 public immutable minBidAmount;\\n\\n    /// @notice Minumum base amount of maker ask orders\\n    uint256 public immutable minAskAmount;\\n\\n    /// @notice Minumum base or quote amount of maker orders during guarded launch\\n    uint256 public immutable guardedLaunchMinOrderAmount;\\n\\n    /// @dev A multipler that normalizes a quote asset balance to 18 decimal places.\\n    uint256 private immutable _quoteDecimalMultiplier;\\n\\n    /// @notice Mapping of rebalance version => tranche => an array of order queues\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public bids;\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public asks;\\n\\n    /// @notice Mapping of rebalance version => best bid premium-discount level of the three tranches.\\n    ///         Zero indicates that there is no bid order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestBids;\\n\\n    /// @notice Mapping of rebalance version => best ask premium-discount level of the three tranches.\\n    ///         Zero or `PD_LEVEL_COUNT + 1` indicates that there is no ask order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestAsks;\\n\\n    /// @notice Mapping of account => tranche => epoch => unsettled trade\\n    mapping(address => mapping(uint256 => mapping(uint256 => UnsettledTrade)))\\n        public unsettledTrades;\\n\\n    /// @dev Mapping of epoch => rebalance version\\n    mapping(uint256 => uint256) private _epochVersions;\\n\\n    /// @dev The `makerRequirement_` param is removed to workaround a stack-too-deep error.\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 quoteDecimals_,\\n        address votingEscrow_,\\n        uint256 minBidAmount_,\\n        uint256 minAskAmount_,\\n        uint256 guardedLaunchStart_,\\n        uint256 guardedLaunchMinOrderAmount_,\\n        address upgradeTool_\\n    )\\n        public\\n        ExchangeRoles(votingEscrow_, 0)\\n        StakingV3(\\n            fund_,\\n            chessSchedule_,\\n            chessController_,\\n            quoteAssetAddress_,\\n            guardedLaunchStart_,\\n            votingEscrow_,\\n            upgradeTool_\\n        )\\n    {\\n        minBidAmount = minBidAmount_;\\n        minAskAmount = minAskAmount_;\\n        guardedLaunchMinOrderAmount = guardedLaunchMinOrderAmount_;\\n        require(quoteDecimals_ <= 18, \\\"Quote asset decimals larger than 18\\\");\\n        _quoteDecimalMultiplier = 10**(18 - quoteDecimals_);\\n    }\\n\\n    /// @dev Initialize the contract. The contract is designed to be used with OpenZeppelin's\\n    ///      `TransparentUpgradeableProxy`. This function should be called by the proxy's\\n    ///      constructor (via the `_data` argument).\\n    function initialize() external {\\n        _initializeStaking();\\n        _initializeV2(msg.sender);\\n    }\\n\\n    /// @dev Initialize the part added in V2. If this contract is upgraded from the previous\\n    ///      version, call `upgradeToAndCall` of the proxy and put a call to this function\\n    ///      in the `data` argument.\\n    function initializeV2(address pauser_) external onlyProxyAdmin {\\n        _initializeV2(pauser_);\\n    }\\n\\n    function _initializeV2(address pauser_) private {\\n        _initializeStakingV2(pauser_);\\n    }\\n\\n    /// @notice Return end timestamp of the epoch containing a given timestamp.\\n    /// @param timestamp Timestamp within a given epoch\\n    /// @return The closest ending timestamp\\n    function endOfEpoch(uint256 timestamp) public pure returns (uint256) {\\n        return (timestamp / EPOCH) * EPOCH + EPOCH;\\n    }\\n\\n    function getMakerReserveRatio(uint256 tranche) public pure returns (uint256) {\\n        if (tranche == TRANCHE_M) {\\n            return MAKER_RESERVE_RATIO_M;\\n        } else if (tranche == TRANCHE_A) {\\n            return MAKER_RESERVE_RATIO_A;\\n        } else {\\n            return MAKER_RESERVE_RATIO_B;\\n        }\\n    }\\n\\n    function getBidOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = bids[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    function getAskOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = asks[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    /// @notice Get all tranches' net asset values of a given time\\n    /// @param timestamp Timestamp of the net asset value\\n    /// @return estimatedNavM Token M's net asset value\\n    /// @return estimatedNavA Token A's net asset value\\n    /// @return estimatedNavB Token B's net asset value\\n    function estimateNavs(uint256 timestamp)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 price = fund.twapOracle().getTwap(timestamp);\\n        require(price != 0, \\\"Price is not available\\\");\\n        return fund.extrapolateNav(timestamp, price);\\n    }\\n\\n    /// @notice Place a bid order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Quote asset amount with 18 decimal places\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeBid(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version\\n    ) external onlyMaker whenNotPaused beforeProtocolUpgrade {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(quoteAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(quoteAmount >= minBidAmount, \\\"Quote amount too low\\\");\\n        }\\n        uint256 bestAsk = bestAsks[version][tranche];\\n        require(\\n            pdLevel > 0 && pdLevel < (bestAsk == 0 ? PD_LEVEL_COUNT + 1 : bestAsk),\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n\\n        uint256 index = bids[version][tranche][pdLevel].append(msg.sender, quoteAmount, version);\\n        if (bestBids[version][tranche] < pdLevel) {\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        _transferQuoteFrom(msg.sender, quoteAmount);\\n\\n        emit BidOrderPlaced(msg.sender, tranche, pdLevel, quoteAmount, version, index);\\n    }\\n\\n    /// @notice Place an ask order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Base asset amount\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeAsk(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version\\n    ) external onlyMaker whenNotPaused beforeProtocolUpgrade {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(baseAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(baseAmount >= minAskAmount, \\\"Base amount too low\\\");\\n        }\\n        require(\\n            pdLevel > bestBids[version][tranche] && pdLevel <= PD_LEVEL_COUNT,\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n\\n        _lock(tranche, msg.sender, baseAmount);\\n        uint256 index = asks[version][tranche][pdLevel].append(msg.sender, baseAmount, version);\\n        uint256 oldBestAsk = bestAsks[version][tranche];\\n        if (oldBestAsk > pdLevel || oldBestAsk == 0) {\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        emit AskOrderPlaced(msg.sender, tranche, pdLevel, baseAmount, version, index);\\n    }\\n\\n    /// @notice Cancel a bid order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelBid(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external whenNotPaused returns (uint256 fillable) {\\n        OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        address maker = order.maker;\\n        // Bid orders can be canceled by anyone after the upgrade\\n        if (block.timestamp < upgradeTimestamp) {\\n            require(maker == msg.sender, \\\"Maker address mismatched\\\");\\n        } else {\\n            require(maker != address(0), \\\"Maker address mismatched\\\");\\n        }\\n\\n        fillable = order.fillable;\\n        emit BidOrderCanceled(maker, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestBid\\n        if (bestBids[version][tranche] == pdLevel) {\\n            uint256 newBestBid = pdLevel;\\n            while (newBestBid > 0 && bids[version][tranche][newBestBid].isEmpty()) {\\n                newBestBid--;\\n            }\\n            bestBids[version][tranche] = newBestBid;\\n        }\\n\\n        _transferQuote(maker, fillable);\\n    }\\n\\n    /// @notice Cancel an ask order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelAsk(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external whenNotPaused beforeProtocolUpgrade {\\n        OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        require(order.maker == msg.sender, \\\"Maker address mismatched\\\");\\n\\n        uint256 fillable = order.fillable;\\n        emit AskOrderCanceled(msg.sender, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestAsk\\n        if (bestAsks[version][tranche] == pdLevel) {\\n            uint256 newBestAsk = pdLevel;\\n            while (newBestAsk <= PD_LEVEL_COUNT && asks[version][tranche][newBestAsk].isEmpty()) {\\n                newBestAsk++;\\n            }\\n            bestAsks[version][tranche] = newBestAsk;\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            _rebalanceAndUnlock(msg.sender, fillable, 0, 0, version);\\n        } else if (tranche == TRANCHE_A) {\\n            _rebalanceAndUnlock(msg.sender, 0, fillable, 0, version);\\n        } else {\\n            _rebalanceAndUnlock(msg.sender, 0, 0, fillable, version);\\n        }\\n    }\\n\\n    /// @notice Buy Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyM(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_M, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyA(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_A, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyB(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_B, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Sell Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token M willing to trade\\n    function sellM(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_M, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token A willing to trade\\n    function sellA(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_A, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token B willing to trade\\n    function sellB(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_B, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for makers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleMaker(address account, uint256 epoch)\\n        external\\n        whenNotPaused\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleMaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleMaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleMaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit MakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for takers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleTaker(address account, uint256 epoch)\\n        external\\n        whenNotPaused\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleTaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleTaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleTaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit TakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @dev Buy share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param quoteAmount Amount of quote assets willing to trade with 18 decimal places\\n    function _buy(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 maxPDLevel,\\n        uint256 estimatedNav,\\n        uint256 quoteAmount\\n    ) internal onlyActive whenNotPaused beforeProtocolUpgrade {\\n        require(maxPDLevel > 0 && maxPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledBuyTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledBuyTrade memory currentTrade;\\n        uint256 orderIndex = 0;\\n        uint256 pdLevel = bestAsks[version][tranche];\\n        if (pdLevel == 0) {\\n            // Zero best ask indicates that no ask order is ever placed.\\n            // We set pdLevel beyond the largest valid level, forcing the following loop\\n            // to exit immediately.\\n            pdLevel = PD_LEVEL_COUNT + 1;\\n        }\\n        for (; pdLevel <= maxPDLevel; pdLevel++) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Scope to avoid \\\"stack too deep\\\"\\n                {\\n                    // Calculate the current trade assuming that the taker would be completely filled.\\n                    uint256 makerReserveRatio = getMakerReserveRatio(tranche);\\n                    currentTrade.frozenQuote = quoteAmount.sub(totalTrade.frozenQuote);\\n                    currentTrade.reservedBase = currentTrade.frozenQuote.mul(makerReserveRatio).div(\\n                        price\\n                    );\\n\\n                    if (currentTrade.reservedBase < order.fillable) {\\n                        // Taker is completely filled.\\n                        currentTrade.effectiveQuote = currentTrade.frozenQuote.divideDecimal(\\n                            pdLevel.mul(PD_TICK).add(PD_START)\\n                        );\\n                    } else {\\n                        // Maker is completely filled. Recalculate the current trade.\\n                        currentTrade.frozenQuote = order.fillable.mul(price).div(makerReserveRatio);\\n                        currentTrade.effectiveQuote = order.fillable.mul(estimatedNav).div(\\n                            makerReserveRatio\\n                        );\\n                        currentTrade.reservedBase = order.fillable;\\n                    }\\n                }\\n                totalTrade.frozenQuote = totalTrade.frozenQuote.add(currentTrade.frozenQuote);\\n                totalTrade.effectiveQuote = totalTrade.effectiveQuote.add(\\n                    currentTrade.effectiveQuote\\n                );\\n                totalTrade.reservedBase = totalTrade.reservedBase.add(currentTrade.reservedBase);\\n                unsettledTrades[order.maker][tranche][epoch].makerSell.add(currentTrade);\\n\\n                // There is no need to rebalance for maker; the fact that the order could\\n                // be filled here indicates that the maker is in the latest version\\n                _tradeLocked(tranche, order.maker, currentTrade.reservedBase);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedBase);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestAsks[version][tranche] != pdLevel) {\\n                    bestAsks[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit BuyTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenQuote,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedBase\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and below the specified\\n            // premium-discount level `maxPDLevel`.\\n            // Find the new best ask beyond that level.\\n            for (; pdLevel <= PD_LEVEL_COUNT; pdLevel++) {\\n                if (!asks[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenQuote > 0,\\n            \\\"Nothing can be bought at the given premium-discount level\\\"\\n        );\\n        unsettledTrades[msg.sender][tranche][epoch].takerBuy.add(totalTrade);\\n        _transferQuoteFrom(msg.sender, totalTrade.frozenQuote);\\n    }\\n\\n    /// @dev Sell share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param baseAmount Amount of base assets willing to trade\\n    function _sell(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 minPDLevel,\\n        uint256 estimatedNav,\\n        uint256 baseAmount\\n    ) internal onlyActive whenNotPaused beforeProtocolUpgrade {\\n        require(minPDLevel > 0 && minPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledSellTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledSellTrade memory currentTrade;\\n        uint256 orderIndex;\\n        uint256 pdLevel = bestBids[version][tranche];\\n        for (; pdLevel >= minPDLevel; pdLevel--) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Scope to avoid \\\"stack too deep\\\"\\n                {\\n                    // Calculate the current trade assuming that the taker would be completely filled.\\n                    uint256 makerReserveRatio = getMakerReserveRatio(tranche);\\n                    currentTrade.frozenBase = baseAmount.sub(totalTrade.frozenBase);\\n                    currentTrade.reservedQuote = currentTrade\\n                        .frozenBase\\n                        .multiplyDecimal(makerReserveRatio)\\n                        .multiplyDecimal(price);\\n\\n                    if (currentTrade.reservedQuote < order.fillable) {\\n                        // Taker is completely filled\\n                        currentTrade.effectiveBase = currentTrade.frozenBase.multiplyDecimal(\\n                            pdLevel.mul(PD_TICK).add(PD_START)\\n                        );\\n                    } else {\\n                        // Maker is completely filled. Recalculate the current trade.\\n                        currentTrade.frozenBase = order.fillable.divideDecimal(price).divideDecimal(\\n                            makerReserveRatio\\n                        );\\n                        currentTrade.effectiveBase = order\\n                            .fillable\\n                            .divideDecimal(estimatedNav)\\n                            .divideDecimal(makerReserveRatio);\\n                        currentTrade.reservedQuote = order.fillable;\\n                    }\\n                }\\n                totalTrade.frozenBase = totalTrade.frozenBase.add(currentTrade.frozenBase);\\n                totalTrade.effectiveBase = totalTrade.effectiveBase.add(currentTrade.effectiveBase);\\n                totalTrade.reservedQuote = totalTrade.reservedQuote.add(currentTrade.reservedQuote);\\n                unsettledTrades[order.maker][tranche][epoch].makerBuy.add(currentTrade);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedQuote);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestBids[version][tranche] != pdLevel) {\\n                    bestBids[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit SellTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenBase,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedQuote\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and above the specified\\n            // premium-discount level `minPDLevel`.\\n            // Find the new best bid beyond that level.\\n            for (; pdLevel > 0; pdLevel--) {\\n                if (!bids[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenBase > 0,\\n            \\\"Nothing can be sold at the given premium-discount level\\\"\\n        );\\n        _tradeAvailable(tranche, msg.sender, totalTrade.frozenBase);\\n        unsettledTrades[msg.sender][tranche][epoch].takerSell.add(totalTrade);\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for takers\\n    /// @param account Taker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleTaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledBuyTrade memory takerBuy = unsettledTrade.takerBuy;\\n        if (takerBuy.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(takerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = takerBuy.frozenQuote.sub(executionQuote);\\n            delete unsettledTrade.takerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledSellTrade memory takerSell = unsettledTrade.takerSell;\\n        if (takerSell.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(takerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(takerSell.frozenBase.sub(executionBase));\\n            delete unsettledTrade.takerSell;\\n        }\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for makers\\n    /// @param account Maker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleMaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledSellTrade memory makerBuy = unsettledTrade.makerBuy;\\n        if (makerBuy.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(makerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = makerBuy.reservedQuote.sub(executionQuote);\\n            delete unsettledTrade.makerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledBuyTrade memory makerSell = unsettledTrade.makerSell;\\n        if (makerSell.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(makerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(makerSell.reservedBase.sub(executionBase));\\n            delete unsettledTrade.makerSell;\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled buy trade with a given NAV\\n    /// @param buyTrade Buy trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _buyTradeResult(UnsettledBuyTrade memory buyTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedBase = buyTrade.reservedBase;\\n        uint256 reservedQuote = reservedBase.multiplyDecimal(nav);\\n        uint256 effectiveQuote = buyTrade.effectiveQuote;\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved base is enough to execute the trade.\\n            // nav is always positive here\\n            return (buyTrade.frozenQuote, effectiveQuote.divideDecimal(nav));\\n        } else {\\n            // Reserved base is not enough. The trade is partially executed\\n            // and a fraction of frozenQuote is returned to the taker.\\n            return (buyTrade.frozenQuote.mul(reservedQuote).div(effectiveQuote), reservedBase);\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled sell trade with a given NAV\\n    /// @param sellTrade Sell trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _sellTradeResult(UnsettledSellTrade memory sellTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedQuote = sellTrade.reservedQuote;\\n        uint256 effectiveQuote = sellTrade.effectiveBase.multiplyDecimal(nav);\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved quote is enough to execute the trade.\\n            return (effectiveQuote, sellTrade.frozenBase);\\n        } else {\\n            // Reserved quote is not enough. The trade is partially executed\\n            // and a fraction of frozenBase is returned to the taker.\\n            return (reservedQuote, sellTrade.frozenBase.mul(reservedQuote).div(effectiveQuote));\\n        }\\n    }\\n\\n    /// @dev Transfer quote asset to an account. Transfered amount is rounded down.\\n    /// @param account Recipient address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuote(address account, uint256 amount) private {\\n        uint256 amountToTransfer = amount / _quoteDecimalMultiplier;\\n        if (amountToTransfer == 0) {\\n            return;\\n        }\\n        IERC20(quoteAssetAddress).safeTransfer(account, amountToTransfer);\\n    }\\n\\n    /// @dev Transfer quote asset from an account. Transfered amount is rounded up.\\n    /// @param account Sender address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuoteFrom(address account, uint256 amount) private {\\n        uint256 amountToTransfer =\\n            amount.add(_quoteDecimalMultiplier - 1) / _quoteDecimalMultiplier;\\n        IERC20(quoteAssetAddress).safeTransferFrom(account, address(this), amountToTransfer);\\n    }\\n\\n    modifier onlyActive() {\\n        require(fund.isExchangeActive(block.timestamp), \\\"Exchange is inactive\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/upgrade/UpgradeTool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../interfaces/IFundV2.sol\\\";\\nimport \\\"../../fund/FundV3.sol\\\";\\nimport \\\"../../fund/ShareStaking.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\nimport \\\"../../interfaces/IAprOracle.sol\\\";\\nimport \\\"../../interfaces/IBallot.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\n\\ninterface IOldExchange {\\n    function protocolUpgrade(address account)\\n        external\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 claimedRewards\\n        );\\n}\\n\\ninterface IDailyProtocolFeeRate {\\n    function dailyProtocolFeeRate() external view returns (uint256);\\n}\\n\\n/// @notice This is the core contract for the upgrade to Tranchess V2. It replaces the following\\n///         contracts of the Tranchess protocol during the upgrade process:\\n///\\n///         * TwapOracle of the old Fund\\n///         * PrimaryMarket of the old Fund\\n///         * PrimaryMarket of the new Fund\\n/// @dev The upgrade procedure consists of the following stages:\\n///\\n///      *STAGE_START*. The owner of the old Fund changes both primary market and TWAP oracle\\n///      to this contract. As a primary market, it records the old tranche tokens' total supplies\\n///      and asks the old Fund to transfer all underlying tokens but one unit to this contract when\\n///      the old Fund settles. As a TWAP oracle, it returns a special value to ensure the total value\\n///      of the old Fund does not change after almost all underlying tokens are transferred out,\\n///      so that no rebalance is triggered.\\n///\\n///      * Change Fund's primary market to this contract\\ncontract UpgradeTool is\\n    ITwapOracle,\\n    IAprOracle,\\n    IBallot,\\n    IPrimaryMarketV2,\\n    ITrancheIndex,\\n    CoreUtility,\\n    Ownable\\n{\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Upgraded(\\n        address account,\\n        uint256 oldM,\\n        uint256 oldA,\\n        uint256 oldB,\\n        uint256 newM,\\n        uint256 newA,\\n        uint256 newB,\\n        uint256 claimedRewards\\n    );\\n\\n    uint256 private constant STAGE_START = 0;\\n    uint256 private constant STAGE_SETTLED = 1;\\n    uint256 private constant STAGE_UPGRADED = 2;\\n\\n    IFund public immutable oldFund;\\n    ITwapOracle public immutable originTwapOracle;\\n    IERC20 public immutable tokenUnderlying;\\n    IERC20 public immutable oldTokenM;\\n    IERC20 public immutable oldTokenA;\\n    IERC20 public immutable oldTokenB;\\n    uint256 public immutable oldFundVersion;\\n\\n    IOldExchange public immutable oldExchange;\\n\\n    FundV3 public immutable newFund;\\n    ShareStaking public immutable newStaking;\\n\\n    uint256 public immutable upgradeTimestamp;\\n\\n    uint256 public stage;\\n\\n    /// @notice Total amount of underlying tokens managed by the old Fund right before this upgrade.\\n    uint256 public upgradeUnderlying;\\n\\n    /// @notice Initial split ratio of the new Fund.\\n    uint256 public initialSplitRatio;\\n\\n    constructor(\\n        address oldFund_,\\n        uint256 oldFundVersion_,\\n        address oldExchange_,\\n        address newFund_,\\n        address newStaking_,\\n        uint256 upgradeTimestamp_\\n    ) public {\\n        oldFund = IFund(oldFund_);\\n        originTwapOracle = ITwapOracle(IFund(oldFund_).twapOracle());\\n        tokenUnderlying = IERC20(IFund(oldFund_).tokenUnderlying());\\n        oldTokenM = IERC20(IFund(oldFund_).tokenM());\\n        oldTokenA = IERC20(IFund(oldFund_).tokenA());\\n        oldTokenB = IERC20(IFund(oldFund_).tokenB());\\n        oldFundVersion = oldFundVersion_;\\n\\n        oldExchange = IOldExchange(oldExchange_);\\n\\n        newFund = FundV3(newFund_);\\n        require(IFund(oldFund_).tokenUnderlying() == IFund(newFund_).tokenUnderlying());\\n        newStaking = ShareStaking(newStaking_);\\n        require(address(ShareStaking(newStaking_).fund()) == newFund_);\\n\\n        require(upgradeTimestamp_ + 1 weeks == _endOfWeek(upgradeTimestamp_));\\n        upgradeTimestamp = upgradeTimestamp_;\\n    }\\n\\n    modifier onlyStage(uint256 expectedStage) {\\n        require(stage == expectedStage, \\\"Incorrect stage\\\");\\n        _;\\n    }\\n\\n    /// @dev This is used by 3rd-party tools to calculate TVL in the SETTLED stage.\\n    function currentCreatingUnderlying() external view returns (uint256) {\\n        return\\n            stage <= STAGE_SETTLED ? upgradeUnderlying : tokenUnderlying.balanceOf(address(this));\\n    }\\n\\n    /// @notice As a special TWAP oracle of the old Fund, it returns the same value as the original\\n    ///         oracle before the protocol upgrade. After the upgrade, it constantly returns the\\n    ///         total value of the Fund at the time of the upgrade, which keeps NAV of the Fund\\n    ///         constant forever.\\n    function getTwap(uint256 timestamp) external view override returns (uint256) {\\n        if (timestamp < upgradeTimestamp) {\\n            return originTwapOracle.getTwap(timestamp);\\n        } else {\\n            uint256 underlying = upgradeUnderlying;\\n            if (underlying == 0) {\\n                // We are in stage STAGE_START and all underlying tokens are still in the old Fund.\\n                underlying = oldFundVersion == 2\\n                    ? IFundV2(address(oldFund)).getTotalUnderlying()\\n                    : tokenUnderlying.balanceOf(address(oldFund));\\n                uint256 protocolFee =\\n                    underlying.multiplyDecimal(\\n                        IDailyProtocolFeeRate(address(oldFund)).dailyProtocolFeeRate()\\n                    );\\n                underlying = underlying.sub(protocolFee);\\n            }\\n            return originTwapOracle.getTwap(upgradeTimestamp).mul(underlying);\\n        }\\n    }\\n\\n    /// @notice As a special APR oracle of the old Fund, it always returns zero to keep\\n    ///         Tranche A's NAV unchanged.\\n    function capture() external override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @notice As a special interest rate ballot of the old Fund, it always returns zero to keep\\n    ///         Tranche A's NAV unchanged.\\n    function count(uint256) external view override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @dev For IBallot.\\n    function syncWithVotingEscrow(address account) external override {}\\n\\n    /// @dev For IPrimaryMarketV2.\\n    function claim(address) external override returns (uint256, uint256) {\\n        revert(\\\"Not allowed\\\");\\n    }\\n\\n    /// @dev For IPrimaryMarketV2.\\n    function claimAndUnwrap(address) external override returns (uint256, uint256) {\\n        revert(\\\"Not allowed\\\");\\n    }\\n\\n    /// @dev For IPrimaryMarketV2.\\n    function updateDelayedRedemptionDay() external override {}\\n\\n    /// @dev For IPrimaryMarketV3.\\n    function canBeRemovedFromFund() external view returns (bool) {\\n        return stage == STAGE_UPGRADED;\\n    }\\n\\n    /// @dev For IPrimaryMarketV3.\\n    function settle(uint256) external {}\\n\\n    function settle(\\n        uint256 day,\\n        uint256, // fundTotalShares\\n        uint256 fundUnderlying,\\n        uint256, // underlyingPrice\\n        uint256 // previousNav\\n    )\\n        external\\n        override\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        )\\n    {\\n        require(oldFund.twapOracle() == this, \\\"Not TWAP oracle of the old fund\\\");\\n        require(msg.sender == address(oldFund), \\\"Only old fund\\\");\\n        if (day < upgradeTimestamp) {\\n            return (0, 0, 0, 0, 0);\\n        }\\n        if (stage == STAGE_START) {\\n            upgradeUnderlying = fundUnderlying;\\n            stage = STAGE_SETTLED;\\n        }\\n\\n        // Fetch all but 1 unit of underlying tokens from the Fund. This guarantees that there's\\n        // only 1 unit of underlying token left in the old Fund at each settlement after the upgrade,\\n        // so that the NAVs remain the same and no rebalance will be triggered. In case that someone\\n        // transfers underlying tokens directly to the old Fund, these tokens will be transferred to\\n        // and forever locked in this contract.\\n        redemptionUnderlying = fundUnderlying.sub(1);\\n    }\\n\\n    /// @notice Transfer all underlying tokens to the new Fund and mint all new tranche tokens.\\n    ///         When this function is called, this contract should be the primary market of the\\n    ///         new Fund and the new Fund should be empty.\\n    function createNewTokens() external onlyOwner onlyStage(STAGE_SETTLED) {\\n        (, uint256 navA, uint256 navB) = oldFund.historicalNavs(upgradeTimestamp);\\n        uint256 splitRatio =\\n            originTwapOracle.getTwap(upgradeTimestamp).divideDecimal(navA.add(navB));\\n        initialSplitRatio = splitRatio;\\n        uint256 hotBalance = tokenUnderlying.balanceOf(address(this));\\n        newFund.initialize(splitRatio, navA, navB, upgradeUnderlying.sub(hotBalance));\\n        newFund.transferOwnership(owner());\\n\\n        tokenUnderlying.safeTransfer(address(newFund), hotBalance);\\n        newFund.primaryMarketMint(\\n            TRANCHE_M,\\n            address(this),\\n            oldFund.shareTotalSupply(TRANCHE_M).divideDecimal(splitRatio.mul(2)),\\n            0\\n        );\\n        newFund.primaryMarketMint(TRANCHE_A, address(this), oldFund.shareTotalSupply(TRANCHE_A), 0);\\n        newFund.primaryMarketMint(TRANCHE_B, address(this), oldFund.shareTotalSupply(TRANCHE_B), 0);\\n        stage = STAGE_UPGRADED;\\n    }\\n\\n    /// @notice Transfer all underlying tokens back to the old Fund in case of emergency rollback.\\n    function rollback() external onlyOwner onlyStage(STAGE_SETTLED) {\\n        tokenUnderlying.safeTransfer(address(oldFund), tokenUnderlying.balanceOf(address(this)));\\n    }\\n\\n    /// @notice Transfer the new fund's ownership back to admin in case that `createNewTokens()`\\n    ///         fails unexpectedly.\\n    function transferNewFundOwnership() external onlyOwner {\\n        newFund.transferOwnership(owner());\\n    }\\n\\n    function protocolUpgrade(address account)\\n        external\\n        onlyStage(STAGE_UPGRADED)\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 claimedRewards\\n        )\\n    {\\n        if (Address.isContract(account)) {\\n            // It is unsafe to upgrade for a smart contract. Such operation is only allowed by\\n            // the contract itself or the owner.\\n            require(\\n                msg.sender == account || msg.sender == owner(),\\n                \\\"Smart contracts can only be upgraded by itself or admin\\\"\\n            );\\n        }\\n\\n        // Burn unstaked old tokens\\n        (uint256 oldBalanceM, uint256 oldBalanceA, uint256 oldBalanceB) =\\n            oldFund.allShareBalanceOf(account);\\n        if (oldBalanceM > 0) {\\n            oldFund.burn(TRANCHE_M, account, oldBalanceM);\\n        }\\n        if (oldBalanceA > 0) {\\n            oldFund.burn(TRANCHE_A, account, oldBalanceA);\\n        }\\n        if (oldBalanceB > 0) {\\n            oldFund.burn(TRANCHE_B, account, oldBalanceB);\\n        }\\n\\n        // Burn staked old tokens\\n        {\\n            uint256 stakedM;\\n            uint256 stakedA;\\n            uint256 stakedB;\\n            (stakedM, stakedA, stakedB, claimedRewards) = oldExchange.protocolUpgrade(account);\\n            if (stakedM > 0) {\\n                oldFund.burn(TRANCHE_M, address(oldExchange), stakedM);\\n                oldBalanceM = oldBalanceM.add(stakedM);\\n            }\\n            if (stakedA > 0) {\\n                oldFund.burn(TRANCHE_A, address(oldExchange), stakedA);\\n                oldBalanceA = oldBalanceA.add(stakedA);\\n            }\\n            if (stakedB > 0) {\\n                oldFund.burn(TRANCHE_B, address(oldExchange), stakedB);\\n                oldBalanceB = oldBalanceB.add(stakedB);\\n            }\\n        }\\n\\n        // Mint all collected old tokens so that their total supplies do not change\\n        if (oldBalanceM > 0) {\\n            oldFund.mint(TRANCHE_M, address(this), oldBalanceM);\\n        }\\n        if (oldBalanceA > 0) {\\n            oldFund.mint(TRANCHE_A, address(this), oldBalanceA);\\n        }\\n        if (oldBalanceB > 0) {\\n            oldFund.mint(TRANCHE_B, address(this), oldBalanceB);\\n        }\\n\\n        uint256 newVersion = newFund.getRebalanceSize();\\n        amountM = oldBalanceM.divideDecimal(initialSplitRatio.mul(2));\\n        amountA = oldBalanceA;\\n        amountB = oldBalanceB;\\n        if (newVersion > 0) {\\n            (amountM, amountA, amountB) = newFund.batchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                0,\\n                newVersion\\n            );\\n        }\\n\\n        newFund.trancheTransfer(TRANCHE_M, address(newStaking), amountM, newVersion);\\n        newStaking.deposit(TRANCHE_M, amountM, account, newVersion);\\n        newFund.trancheTransfer(TRANCHE_A, address(newStaking), amountA, newVersion);\\n        newStaking.deposit(TRANCHE_A, amountA, account, newVersion);\\n        newFund.trancheTransfer(TRANCHE_B, address(newStaking), amountB, newVersion);\\n        newStaking.deposit(TRANCHE_B, amountB, account, newVersion);\\n\\n        emit Upgraded(\\n            account,\\n            oldBalanceM,\\n            oldBalanceA,\\n            oldBalanceB,\\n            amountM,\\n            amountA,\\n            amountB,\\n            claimedRewards\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IPrimaryMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IPrimaryMarket {\\n    function claim(address account)\\n        external\\n        returns (uint256 createdShares, uint256 redeemedUnderlying);\\n\\n    function settle(\\n        uint256 day,\\n        uint256 fundTotalShares,\\n        uint256 fundUnderlying,\\n        uint256 underlyingPrice,\\n        uint256 previousNav\\n    )\\n        external\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeDecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary SafeDecimalMath {\\n    using SafeMath for uint256;\\n\\n    /* Number of decimal places in the representations. */\\n    uint256 private constant decimals = 18;\\n    uint256 private constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint256 private constant UNIT = 10**uint256(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint256 private constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\\n    uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\\n        10**uint256(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y).div(UNIT);\\n    }\\n\\n    function multiplyDecimalPrecise(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y).div(PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    function divideDecimalPrecise(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(PRECISE_UNIT).div(y);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\\n        uint256 quotientTimesTen = i.mul(10).div(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen = quotientTimesTen.add(10);\\n        }\\n\\n        return quotientTimesTen.div(10);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, and the max value of\\n     * uint256 on overflow.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        return c / a != b ? type(uint256).max : c;\\n    }\\n\\n    function saturatingMultiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return saturatingMul(x, y).div(UNIT);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IFund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\n\\ninterface IFund {\\n    /// @notice A linear transformation matrix that represents a rebalance.\\n    ///\\n    ///         ```\\n    ///             [ ratioM          0        0 ]\\n    ///         R = [ ratioA2M  ratioAB        0 ]\\n    ///             [ ratioB2M        0  ratioAB ]\\n    ///         ```\\n    ///\\n    ///         Amounts of the three tranches `m`, `a` and `b` can be rebalanced by multiplying the matrix:\\n    ///\\n    ///         ```\\n    ///         [ m', a', b' ] = [ m, a, b ] * R\\n    ///         ```\\n    struct Rebalance {\\n        uint256 ratioM;\\n        uint256 ratioA2M;\\n        uint256 ratioB2M;\\n        uint256 ratioAB;\\n        uint256 timestamp;\\n    }\\n\\n    function trancheWeights() external pure returns (uint256 weightA, uint256 weightB);\\n\\n    function tokenUnderlying() external view returns (address);\\n\\n    function tokenM() external view returns (address);\\n\\n    function tokenA() external view returns (address);\\n\\n    function tokenB() external view returns (address);\\n\\n    function underlyingDecimalMultiplier() external view returns (uint256);\\n\\n    function twapOracle() external view returns (ITwapOracle);\\n\\n    function feeCollector() external view returns (address);\\n\\n    function endOfDay(uint256 timestamp) external pure returns (uint256);\\n\\n    function shareTotalSupply(uint256 tranche) external view returns (uint256);\\n\\n    function shareBalanceOf(uint256 tranche, address account) external view returns (uint256);\\n\\n    function allShareBalanceOf(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function shareBalanceVersion(address account) external view returns (uint256);\\n\\n    function shareAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function shareAllowanceVersion(address owner, address spender) external view returns (uint256);\\n\\n    function getRebalanceSize() external view returns (uint256);\\n\\n    function getRebalance(uint256 index) external view returns (Rebalance memory);\\n\\n    function getRebalanceTimestamp(uint256 index) external view returns (uint256);\\n\\n    function currentDay() external view returns (uint256);\\n\\n    function fundActivityStartTime() external view returns (uint256);\\n\\n    function exchangeActivityStartTime() external view returns (uint256);\\n\\n    function isFundActive(uint256 timestamp) external view returns (bool);\\n\\n    function isPrimaryMarketActive(address primaryMarket, uint256 timestamp)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isExchangeActive(uint256 timestamp) external view returns (bool);\\n\\n    function getTotalShares() external view returns (uint256);\\n\\n    function historicalTotalShares(uint256 timestamp) external view returns (uint256);\\n\\n    function historicalNavs(uint256 timestamp)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function extrapolateNav(uint256 timestamp, uint256 price)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function calculateNavB(uint256 navM, uint256 navA) external pure returns (uint256);\\n\\n    function doRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        );\\n\\n    function batchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        );\\n\\n    function refreshBalance(address account, uint256 targetVersion) external;\\n\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external;\\n\\n    function mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function transferFrom(\\n        uint256 tranche,\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (uint256 newAllowance);\\n\\n    function increaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function decreaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    event RebalanceTriggered(\\n        uint256 indexed index,\\n        uint256 indexed day,\\n        uint256 ratioM,\\n        uint256 ratioA2M,\\n        uint256 ratioB2M,\\n        uint256 ratioAB\\n    );\\n    event Settled(uint256 indexed day, uint256 navM, uint256 navA, uint256 navB);\\n    event InterestRateUpdated(uint256 baseInterestRate, uint256 floatingInterestRate);\\n    event Transfer(\\n        uint256 indexed tranche,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n    event Approval(\\n        uint256 indexed tranche,\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n    event BalancesRebalanced(\\n        address indexed account,\\n        uint256 version,\\n        uint256 balanceM,\\n        uint256 balanceA,\\n        uint256 balanceB\\n    );\\n    event AllowancesRebalanced(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 version,\\n        uint256 allowanceM,\\n        uint256 allowanceA,\\n        uint256 allowanceB\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/ITrancheIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice Amounts of Token M, A and B are sometimes stored in a `uint256[3]` array. This contract\\n///         defines index of each tranche in this array.\\n///\\n///         Solidity does not allow constants to be defined in interfaces. So this contract follows\\n///         the naming convention of interfaces but is implemented as an `abstract contract`.\\nabstract contract ITrancheIndex {\\n    uint256 internal constant TRANCHE_M = 0;\\n    uint256 internal constant TRANCHE_A = 1;\\n    uint256 internal constant TRANCHE_B = 2;\\n\\n    uint256 internal constant TRANCHE_COUNT = 3;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface ITwapOracle {\\n    enum UpdateType {PRIMARY, SECONDARY, OWNER, CHAINLINK, UNISWAP_V2}\\n\\n    function getTwap(uint256 timestamp) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ProxyUtility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nabstract contract ProxyUtility {\\n    /// @dev Storage slot with the admin of the contract.\\n    bytes32 private constant _ADMIN_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n\\n    /// @dev Revert if the proxy admin is not the caller\\n    modifier onlyProxyAdmin() {\\n        bytes32 slot = _ADMIN_SLOT;\\n        address proxyAdmin;\\n        assembly {\\n            proxyAdmin := sload(slot)\\n        }\\n        require(msg.sender == proxyAdmin, \\\"Only proxy admin\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/LibOrderQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice A maker order\\n/// @param prev Index of the previous order at the same premium-discount level,\\n///             or zero if this is the first one\\n/// @param next Index of the next order at the same premium-discount level,\\n///             or zero if this is the last one\\n/// @param maker Account placing this order\\n/// @param amount Original amount of the order, which is amount of quote asset with 18 decimal places\\n///               for a bid order, or amount of base asset for an ask order\\n/// @param version Rebalance version when the order is placed\\n/// @param fillable Currently fillable amount\\nstruct Order {\\n    uint256 prev;\\n    uint256 next;\\n    address maker;\\n    uint256 amount;\\n    uint256 version;\\n    uint256 fillable;\\n}\\n\\n/// @notice A queue of orders with the same premium-discount level.\\n///\\n///         An order queue assigns a unique index to each order and stores the orders in a doubly\\n///         linked list. Orders can be removed from the queue by cancellation, expiration or trade.\\n/// @param list Mapping of order index => order\\n/// @param head Index of the first order in the queue, or zero if the queue is empty\\n/// @param tail Index of the last order in the queue, or zero if the queue is empty\\n/// @param counter The total number of orders that have been added to the queue, no matter whether\\n///                they are still active or not\\nstruct OrderQueue {\\n    mapping(uint256 => Order) list;\\n    uint256 head;\\n    uint256 tail;\\n    uint256 counter;\\n}\\n\\n/// @title Tranchess's Exchange Order Queue Contract\\n/// @notice Order queue struct and implementation using doubly linked list\\n/// @author Tranchess\\nlibrary LibOrderQueue {\\n    function isEmpty(OrderQueue storage queue) internal view returns (bool) {\\n        return queue.head == 0;\\n    }\\n\\n    /// @notice Append a new order to the queue\\n    /// @param queue Order queue\\n    /// @param maker Maker address\\n    /// @param amount Amount to place in the order with 18 decimal places\\n    /// @param version Current rebalance version\\n    /// @return Index of the order in the order queue\\n    function append(\\n        OrderQueue storage queue,\\n        address maker,\\n        uint256 amount,\\n        uint256 version\\n    ) internal returns (uint256) {\\n        uint256 index = queue.counter + 1;\\n        queue.counter = index;\\n        uint256 tail = queue.tail;\\n        queue.list[index] = Order({\\n            prev: tail,\\n            next: 0,\\n            maker: maker,\\n            amount: amount,\\n            version: version,\\n            fillable: amount\\n        });\\n        if (tail == 0) {\\n            // The queue was empty.\\n            queue.head = index;\\n        } else {\\n            // The queue was not empty.\\n            queue.list[tail].next = index;\\n        }\\n        queue.tail = index;\\n        return index;\\n    }\\n\\n    /// @dev Cancel an order from the queue.\\n    /// @param queue Order queue\\n    /// @param index Index of the order to be canceled\\n    function cancel(OrderQueue storage queue, uint256 index) internal {\\n        uint256 oldHead = queue.head;\\n        if (index >= oldHead && oldHead > 0) {\\n            // The order is still active.\\n            Order storage order = queue.list[index];\\n            uint256 prev = order.prev;\\n            uint256 next = order.next;\\n            if (prev == 0) {\\n                // This is the first but not the only order.\\n                queue.head = next;\\n            } else {\\n                queue.list[prev].next = next;\\n            }\\n            if (next == 0) {\\n                // This is the last but not the only order.\\n                queue.tail = prev;\\n            } else {\\n                queue.list[next].prev = prev;\\n            }\\n        }\\n        delete queue.list[index];\\n    }\\n\\n    /// @dev Remove an order that is completely filled in matching. Links of the previous\\n    ///      and next order are not updated here. Caller must call `updateHead` after finishing\\n    ///      the matching on this queue.\\n    /// @param queue Order queue\\n    /// @param index Index of the order to be removed\\n    /// @return nextIndex Index of the next order, or zero if the removed order is the last one\\n    function fill(OrderQueue storage queue, uint256 index) internal returns (uint256 nextIndex) {\\n        nextIndex = queue.list[index].next;\\n        delete queue.list[index];\\n    }\\n\\n    /// @dev Update head and tail of the queue. This function should be called after matching\\n    ///      a taker order with this order queue and all orders before the new head are either\\n    ///      completely filled or expired.\\n    /// @param queue Order queue\\n    /// @param newHead Index of the first order that is still active now,\\n    ///                or zero if the queue is empty\\n    function updateHead(OrderQueue storage queue, uint256 newHead) internal {\\n        queue.head = newHead;\\n        if (newHead == 0) {\\n            queue.tail = 0;\\n        } else {\\n            queue.list[newHead].prev = 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/LibUnsettledTrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/// @notice Unsettled trade of a taker buy order or a maker sell order\\n/// @param frozenQuote Amount of quote assets from the taker\\n/// @param effectiveQuote Effective amount of quote assets at zero premium-discount\\n/// @param reservedBase Reserved amount of base assets from the maker\\nstruct UnsettledBuyTrade {\\n    uint256 frozenQuote;\\n    uint256 effectiveQuote;\\n    uint256 reservedBase;\\n}\\n\\n/// @notice Unsettled trade of a taker sell order or a maker buy order\\n/// @param frozenBase Amount of base assets from the taker\\n/// @param effectiveBase Effective amount of base assets at zero premium-discount\\n/// @param reservedQuote Reserved amount of quote assets from the maker\\nstruct UnsettledSellTrade {\\n    uint256 frozenBase;\\n    uint256 effectiveBase;\\n    uint256 reservedQuote;\\n}\\n\\n/// @notice Unsettled trades of an account in a single epoch\\n/// @param takerBuy Trade by taker buy orders\\n/// @param takerSell Trade by taker sell orders\\n/// @param makerBuy Trade by maker buy orders\\n/// @param makerSell Trade by maker sell orders\\nstruct UnsettledTrade {\\n    UnsettledBuyTrade takerBuy;\\n    UnsettledSellTrade takerSell;\\n    UnsettledSellTrade makerBuy;\\n    UnsettledBuyTrade makerSell;\\n}\\n\\nlibrary LibUnsettledBuyTrade {\\n    using SafeMath for uint256;\\n\\n    /// @dev Accumulate buy trades\\n    /// @param self Trade to update\\n    /// @param other New trade to be added to storage\\n    function add(UnsettledBuyTrade storage self, UnsettledBuyTrade memory other) internal {\\n        self.frozenQuote = self.frozenQuote.add(other.frozenQuote);\\n        self.effectiveQuote = self.effectiveQuote.add(other.effectiveQuote);\\n        self.reservedBase = self.reservedBase.add(other.reservedBase);\\n    }\\n}\\n\\nlibrary LibUnsettledSellTrade {\\n    using SafeMath for uint256;\\n\\n    /// @dev Accumulate sell trades\\n    /// @param self Trade to update\\n    /// @param other New trade to be added to storage\\n    function add(UnsettledSellTrade storage self, UnsettledSellTrade memory other) internal {\\n        self.frozenBase = self.frozenBase.add(other.frozenBase);\\n        self.effectiveBase = self.effectiveBase.add(other.effectiveBase);\\n        self.reservedQuote = self.reservedQuote.add(other.reservedQuote);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/ExchangeRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\n\\n/// @title Tranchess's Exchange Role Contract\\n/// @notice Exchange role management\\n/// @author Tranchess\\nabstract contract ExchangeRoles {\\n    event MakerApplied(address indexed account, uint256 expiration);\\n\\n    /// @notice Voting Escrow.\\n    IVotingEscrow public immutable votingEscrow;\\n\\n    /// @notice Minimum vote-locked governance token balance required to place maker orders.\\n    uint256 public immutable makerRequirement;\\n\\n    /// @dev Mapping of account => maker expiration timestamp\\n    mapping(address => uint256) internal _makerExpiration;\\n\\n    constructor(address votingEscrow_, uint256 makerRequirement_) public {\\n        votingEscrow = IVotingEscrow(votingEscrow_);\\n        makerRequirement = makerRequirement_;\\n    }\\n\\n    // ------------------------------ MAKER ------------------------------------\\n    /// @notice Functions with this modifer can only be invoked by makers\\n    modifier onlyMaker() {\\n        require(isMaker(msg.sender), \\\"Only maker\\\");\\n        _;\\n    }\\n\\n    /// @notice Returns maker expiration timestamp of an account.\\n    ///         When `makerRequirement` is zero, this function always returns\\n    ///         an extremely large timestamp (2500-01-01 00:00:00 UTC).\\n    function makerExpiration(address account) external view returns (uint256) {\\n        return makerRequirement > 0 ? _makerExpiration[account] : 16725225600;\\n    }\\n\\n    /// @notice Verify if the account is an active maker or not\\n    /// @param account Account address to verify\\n    /// @return True if the account is an active maker; else returns false\\n    function isMaker(address account) public view returns (bool) {\\n        return makerRequirement == 0 || _makerExpiration[account] > block.timestamp;\\n    }\\n\\n    /// @notice Apply for maker membership\\n    function applyForMaker() external {\\n        require(makerRequirement > 0, \\\"No need to apply for maker\\\");\\n        // The membership will be valid until the current vote-locked governance\\n        // token balance drop below the requirement.\\n        uint256 expiration = votingEscrow.getTimestampDropBelow(msg.sender, makerRequirement);\\n        _makerExpiration[msg.sender] = expiration;\\n        emit MakerApplied(msg.sender, expiration);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/StakingV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../utils/ManagedPausable.sol\\\";\\n\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\n\\n/// @notice Chess locking snapshot used in calculating working balance of an account.\\n/// @param veProportion The account's veCHESS divided by the total veCHESS supply.\\n/// @param veLocked Locked CHESS and unlock time, which is synchronized from VotingEscrow.\\nstruct VESnapshot {\\n    uint256 veProportion;\\n    IVotingEscrow.LockedBalance veLocked;\\n}\\n\\ninterface IUpgradeTool {\\n    function upgradeTimestamp() external view returns (uint256);\\n}\\n\\nabstract contract StakingV3 is ITrancheIndex, CoreUtility, ManagedPausable {\\n    /// @dev Reserved storage slots for future sibling contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposited(uint256 tranche, address account, uint256 amount);\\n    event Withdrawn(uint256 tranche, address account, uint256 amount);\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    uint256 private constant REWARD_WEIGHT_A = 4;\\n    uint256 private constant REWARD_WEIGHT_B = 2;\\n    uint256 private constant REWARD_WEIGHT_M = 3;\\n    uint256 private constant MAX_BOOSTING_FACTOR = 3e18;\\n    uint256 private constant MAX_BOOSTING_FACTOR_MINUS_ONE = MAX_BOOSTING_FACTOR - 1e18;\\n\\n    /// @dev Maximum fraction of veCHESS that can be used to boost Token M.\\n    uint256 private constant MAX_BOOSTING_POWER_M = 0.5e18;\\n\\n    IFund public immutable fund;\\n    IERC20 private immutable tokenM;\\n    IERC20 private immutable tokenA;\\n    IERC20 private immutable tokenB;\\n\\n    /// @notice The Chess release schedule contract.\\n    IChessSchedule public immutable chessSchedule;\\n\\n    uint256 public immutable guardedLaunchStart;\\n\\n    address public immutable upgradeTool;\\n\\n    uint256 public immutable upgradeTimestamp;\\n\\n    uint256 private _rate;\\n\\n    /// @notice The controller contract.\\n    IChessController public immutable chessController;\\n\\n    /// @notice Quote asset for the exchange. Each exchange only handles one quote asset\\n    address public immutable quoteAssetAddress;\\n\\n    /// @dev Total amount of user shares, i.e. sum of all entries in `_availableBalances` and\\n    ///      `_lockedBalances`. Note that these values can be smaller than the amount of\\n    ///      share tokens held by this contract, because shares locked in unsettled trades\\n    ///      are not included in total supplies or any user's balance.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Rebalance version of `_totalSupplies`.\\n    uint256 private _totalSupplyVersion;\\n\\n    /// @dev Amount of shares that can be withdrawn or traded by each user.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _availableBalances;\\n\\n    /// @dev Amount of shares that are locked in ask orders.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _lockedBalances;\\n\\n    /// @dev Rebalance version mapping for `_availableBalances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev 1e27 * \u222b(rate(t) / totalWeight(t) dt) from the latest rebalance till checkpoint.\\n    uint256 private _invTotalWeightIntegral;\\n\\n    /// @dev Final `_invTotalWeightIntegral` before each rebalance.\\n    ///      These values are accessed in a loop in `_userCheckpoint()` with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_historicalIntegralSize` and should be explicitly checked when necessary.\\n    uint256[65535] private _historicalIntegrals;\\n\\n    /// @dev Actual length of the `_historicalIntegrals` array, which always equals to the number of\\n    ///      historical rebalances after `checkpoint()` is called.\\n    uint256 private _historicalIntegralSize;\\n\\n    /// @dev Timestamp when checkpoint() is called.\\n    uint256 private _checkpointTimestamp;\\n\\n    /// @dev Snapshot of `_invTotalWeightIntegral` per user.\\n    mapping(address => uint256) private _userIntegrals;\\n\\n    /// @dev Mapping of account => claimable rewards.\\n    mapping(address => uint256) private _claimableRewards;\\n\\n    IVotingEscrow private immutable _votingEscrow;\\n    uint256 private _workingSupply;\\n    mapping(address => uint256) private _workingBalances;\\n    mapping(address => VESnapshot) private _veSnapshots;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 guardedLaunchStart_,\\n        address votingEscrow_,\\n        address upgradeTool_\\n    ) public {\\n        fund = IFund(fund_);\\n        tokenM = IERC20(IFund(fund_).tokenM());\\n        tokenA = IERC20(IFund(fund_).tokenA());\\n        tokenB = IERC20(IFund(fund_).tokenB());\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        quoteAssetAddress = quoteAssetAddress_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        _votingEscrow = IVotingEscrow(votingEscrow_);\\n        upgradeTool = upgradeTool_;\\n        upgradeTimestamp = IUpgradeTool(upgradeTool_).upgradeTimestamp();\\n    }\\n\\n    function _initializeStaking() internal {\\n        require(_checkpointTimestamp == 0);\\n        _checkpointTimestamp = block.timestamp;\\n        _rate = IChessSchedule(chessSchedule).getRate(block.timestamp);\\n    }\\n\\n    function _initializeStakingV2(address pauser_) internal {\\n        _initializeManagedPausable(pauser_);\\n        // The contract was just upgraded from an old version without boosting\\n        _workingSupply = weightedBalance(\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B]\\n        );\\n    }\\n\\n    /// @notice Return weight of given balance with respect to rewards.\\n    /// @param amountM Amount of Token M\\n    /// @param amountA Amount of Token A\\n    /// @param amountB Amount of Token B\\n    /// @return Rewarding weight of the balance\\n    function weightedBalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) public pure returns (uint256) {\\n        return\\n            amountM.mul(REWARD_WEIGHT_M).add(amountA.mul(REWARD_WEIGHT_A)).add(\\n                amountB.mul(REWARD_WEIGHT_B)\\n            ) / REWARD_WEIGHT_M;\\n    }\\n\\n    function totalSupply(uint256 tranche) external view returns (uint256) {\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (totalSupplyM, totalSupplyA, totalSupplyB) = _fundBatchRebalance(\\n                totalSupplyM,\\n                totalSupplyA,\\n                totalSupplyB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return totalSupplyM;\\n        } else if (tranche == TRANCHE_A) {\\n            return totalSupplyA;\\n        } else {\\n            return totalSupplyB;\\n        }\\n    }\\n\\n    function availableBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _availableBalances[account][TRANCHE_M];\\n        uint256 amountA = _availableBalances[account][TRANCHE_A];\\n        uint256 amountB = _availableBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function lockedBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _lockedBalances[account][TRANCHE_M];\\n        uint256 amountA = _lockedBalances[account][TRANCHE_A];\\n        uint256 amountB = _lockedBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function balanceVersion(address account) external view returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function workingSupply() external view returns (uint256) {\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (uint256 totalSupplyM, uint256 totalSupplyA, uint256 totalSupplyB) =\\n                _fundBatchRebalance(\\n                    _totalSupplies[TRANCHE_M],\\n                    _totalSupplies[TRANCHE_A],\\n                    _totalSupplies[TRANCHE_B],\\n                    version,\\n                    rebalanceSize\\n                );\\n            return weightedBalance(totalSupplyM, totalSupplyA, totalSupplyB);\\n        } else {\\n            return _workingSupply;\\n        }\\n    }\\n\\n    function workingBalanceOf(address account) external view returns (uint256) {\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        uint256 workingBalance = _workingBalances[account]; // gas saver\\n        if (version < rebalanceSize || workingBalance == 0) {\\n            uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n            uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n            uint256 amountM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n            uint256 amountA = available[TRANCHE_A].add(locked[TRANCHE_A]);\\n            uint256 amountB = available[TRANCHE_B].add(locked[TRANCHE_B]);\\n            if (version < rebalanceSize) {\\n                (amountM, amountA, amountB) = _fundBatchRebalance(\\n                    amountM,\\n                    amountA,\\n                    amountB,\\n                    version,\\n                    rebalanceSize\\n                );\\n            }\\n            return weightedBalance(amountM, amountA, amountB);\\n        } else {\\n            return workingBalance;\\n        }\\n    }\\n\\n    function veSnapshotOf(address account) external view returns (VESnapshot memory) {\\n        return _veSnapshots[account];\\n    }\\n\\n    function _fundRebalanceSize() internal view returns (uint256) {\\n        return fund.getRebalanceSize();\\n    }\\n\\n    function _fundDoRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.doRebalance(amountM, amountA, amountB, index);\\n    }\\n\\n    function _fundBatchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.batchRebalance(amountM, amountA, amountB, fromIndex, toIndex);\\n    }\\n\\n    /// @dev Deposit to get rewards\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function deposit(uint256 tranche, uint256 amount) public whenNotPaused beforeProtocolUpgrade {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].add(\\n            amount\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _updateWorkingBalance(msg.sender);\\n\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransferFrom(msg.sender, address(this), amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransferFrom(msg.sender, address(this), amount);\\n        } else {\\n            tokenB.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n\\n        emit Deposited(tranche, msg.sender, amount);\\n    }\\n\\n    /// @dev Claim settled Token M from the primary market and deposit to get rewards\\n    /// @param primaryMarket The primary market to claim shares from\\n    function claimAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarketV2(primaryMarket).claim(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    function claimAndUnwrapAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarketV2(primaryMarket).claimAndUnwrap(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    /// @dev Withdraw\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function withdraw(uint256 tranche, uint256 amount) external whenNotPaused {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to withdraw\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(msg.sender);\\n\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransfer(msg.sender, amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransfer(msg.sender, amount);\\n        } else {\\n            tokenB.safeTransfer(msg.sender, amount);\\n        }\\n\\n        emit Withdrawn(tranche, msg.sender, amount);\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (targetVersion == 0) {\\n            targetVersion = rebalanceSize;\\n        } else {\\n            require(targetVersion <= rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, targetVersion);\\n    }\\n\\n    /// @notice Return claimable rewards of an account till now.\\n    ///\\n    ///         This function should be call as a \\\"view\\\" function off-chain to get\\n    ///         the return value, e.g. using `contract.claimableRewards.call(account)` in web3\\n    ///         or `contract.callStatic.claimableRewards(account)` in ethers.js.\\n    /// @param account Address of an account\\n    /// @return Amount of claimable rewards\\n    function claimableRewards(address account) external returns (uint256) {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        return _claimableRewards[account];\\n    }\\n\\n    /// @notice Claim the rewards for an account.\\n    /// @param account Account to claim its rewards\\n    function claimRewards(address account) external whenNotPaused {\\n        require(\\n            block.timestamp >= guardedLaunchStart + 15 days,\\n            \\\"Cannot claim during guarded launch\\\"\\n        );\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _claim(account);\\n    }\\n\\n    /// @notice Synchronize an account's locked Chess with `VotingEscrow`\\n    ///         and update its working balance.\\n    /// @param account Address of the synchronized account\\n    function syncWithVotingEscrow(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n\\n        VESnapshot storage veSnapshot = _veSnapshots[account];\\n        IVotingEscrow.LockedBalance memory newLocked = _votingEscrow.getLockedBalance(account);\\n        if (\\n            newLocked.amount != veSnapshot.veLocked.amount ||\\n            newLocked.unlockTime != veSnapshot.veLocked.unlockTime ||\\n            newLocked.unlockTime < block.timestamp\\n        ) {\\n            veSnapshot.veLocked.amount = newLocked.amount;\\n            veSnapshot.veLocked.unlockTime = newLocked.unlockTime;\\n            veSnapshot.veProportion = _votingEscrow.balanceOf(account).divideDecimal(\\n                _votingEscrow.totalSupply()\\n            );\\n        }\\n\\n        _updateWorkingBalance(account);\\n    }\\n\\n    modifier beforeProtocolUpgrade() {\\n        require(block.timestamp < upgradeTimestamp, \\\"Closed after upgrade\\\");\\n        _;\\n    }\\n\\n    /// @notice Upgrade to Tranchess V2. This can only be called from the upgrade tool.\\n    function protocolUpgrade(address account)\\n        external\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 claimedRewards\\n        )\\n    {\\n        require(msg.sender == upgradeTool, \\\"Only upgrade tool\\\");\\n        require(block.timestamp >= upgradeTimestamp, \\\"Not ready for upgrade\\\");\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        // These amounts of tokens will be burnt by the upgrade tool.\\n        amountM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n        amountA = available[TRANCHE_A].add(locked[TRANCHE_A]);\\n        amountB = available[TRANCHE_B].add(locked[TRANCHE_B]);\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = 0;\\n            locked[TRANCHE_M] = 0;\\n            _totalSupplies[TRANCHE_M] = _totalSupplies[TRANCHE_M].sub(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = 0;\\n            locked[TRANCHE_A] = 0;\\n            _totalSupplies[TRANCHE_A] = _totalSupplies[TRANCHE_A].sub(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = 0;\\n            locked[TRANCHE_B] = 0;\\n            _totalSupplies[TRANCHE_B] = _totalSupplies[TRANCHE_B].sub(amountB);\\n        }\\n        _updateWorkingBalance(account);\\n\\n        claimedRewards = _claim(account);\\n    }\\n\\n    /// @dev Transfer shares from the sender to the contract internally\\n    /// @param tranche Tranche of the share\\n    /// @param sender Sender address\\n    /// @param amount The amount to transfer\\n    function _tradeAvailable(\\n        uint256 tranche,\\n        address sender,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(sender, rebalanceSize);\\n        _availableBalances[sender][tranche] = _availableBalances[sender][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(sender);\\n    }\\n\\n    function _rebalanceAndClearTrade(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    )\\n        internal\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            _totalSupplies[TRANCHE_M] = _totalSupplies[TRANCHE_M].add(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            _totalSupplies[TRANCHE_A] = _totalSupplies[TRANCHE_A].add(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            _totalSupplies[TRANCHE_B] = _totalSupplies[TRANCHE_B].add(amountB);\\n        }\\n        _updateWorkingBalance(account);\\n\\n        return (amountM, amountA, amountB);\\n    }\\n\\n    function _lock(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _availableBalances[account][tranche] = _availableBalances[account][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to lock\\\"\\n        );\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].add(amount);\\n    }\\n\\n    function _rebalanceAndUnlock(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            locked[TRANCHE_M] = locked[TRANCHE_M].sub(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            locked[TRANCHE_A] = locked[TRANCHE_A].sub(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            locked[TRANCHE_B] = locked[TRANCHE_B].sub(amountB);\\n        }\\n    }\\n\\n    function _tradeLocked(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(account);\\n    }\\n\\n    /// @dev Transfer claimable rewards to an account. Rewards since the last user checkpoint\\n    ///      is not included. This function should always be called after `_userCheckpoint()`,\\n    ///      in order for the user to get all rewards till now.\\n    /// @param account Address of the account\\n    function _claim(address account) internal returns (uint256 claimableReward) {\\n        claimableReward = _claimableRewards[account];\\n        _claimableRewards[account] = 0;\\n        chessSchedule.mint(account, claimableReward);\\n    }\\n\\n    /// @dev Transform total supplies to the latest rebalance version and make a global reward checkpoint.\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _checkpoint(uint256 rebalanceSize) private {\\n        uint256 timestamp = _checkpointTimestamp;\\n        if (timestamp >= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 integral = _invTotalWeightIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 weeklyPercentage =\\n            chessController.getFundRelativeWeight(address(fund), endWeek - 1 weeks);\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceTimestamp;\\n        if (version < rebalanceSize) {\\n            rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n        } else {\\n            rebalanceTimestamp = type(uint256).max;\\n        }\\n        uint256 rate = _rate;\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 weight = _workingSupply;\\n        uint256 timestamp_ = timestamp; // avoid stack too deep\\n\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp_ < block.timestamp; i++) {\\n            uint256 endTimestamp = rebalanceTimestamp.min(endWeek).min(block.timestamp);\\n\\n            if (weight > 0) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp_))\\n                        .multiplyDecimal(weeklyPercentage)\\n                        .divideDecimalPrecise(weight)\\n                );\\n            }\\n\\n            if (endTimestamp == rebalanceTimestamp) {\\n                uint256 oldSize = _historicalIntegralSize;\\n                _historicalIntegrals[oldSize] = integral;\\n                _historicalIntegralSize = oldSize + 1;\\n\\n                integral = 0;\\n                (totalSupplyM, totalSupplyA, totalSupplyB) = _fundDoRebalance(\\n                    totalSupplyM,\\n                    totalSupplyA,\\n                    totalSupplyB,\\n                    version\\n                );\\n\\n                version++;\\n                // Reset total weight boosting after the first rebalance\\n                weight = weightedBalance(totalSupplyM, totalSupplyA, totalSupplyB);\\n\\n                if (version < rebalanceSize) {\\n                    rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n                } else {\\n                    rebalanceTimestamp = type(uint256).max;\\n                }\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek);\\n                weeklyPercentage = chessController.getFundRelativeWeight(address(fund), endWeek);\\n                endWeek += 1 weeks;\\n            }\\n\\n            timestamp_ = endTimestamp;\\n        }\\n\\n        _checkpointTimestamp = block.timestamp;\\n        _invTotalWeightIntegral = integral;\\n        if (_rate != rate) {\\n            _rate = rate;\\n        }\\n        if (_totalSupplyVersion != rebalanceSize) {\\n            _totalSupplies[TRANCHE_M] = totalSupplyM;\\n            _totalSupplies[TRANCHE_A] = totalSupplyA;\\n            _totalSupplies[TRANCHE_B] = totalSupplyB;\\n            _totalSupplyVersion = rebalanceSize;\\n            // Reset total working weight before any boosting if rebalance ever triggered\\n            _workingSupply = weight;\\n        }\\n    }\\n\\n    /// @dev Transform a user's balance to a given rebalance version and update this user's rewards.\\n    ///\\n    ///      In most cases, the target version is the latest version and this function cumulates\\n    ///      rewards till now. When this function is called from `refreshBalance()`,\\n    ///      `targetVersion` can be an older version, in which case rewards are cumulated till\\n    ///      the end of that version (i.e. timestamp of the transaction triggering the rebalance\\n    ///      with index `targetVersion`).\\n    ///\\n    ///      This function should always be called after `_checkpoint()` is called, so that\\n    ///      the global reward checkpoint is guarenteed up to date.\\n    /// @param account Account to update\\n    /// @param targetVersion The target rebalance version\\n    function _userCheckpoint(address account, uint256 targetVersion) private {\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion > targetVersion) {\\n            return;\\n        }\\n        uint256 userIntegral = _userIntegrals[account];\\n        uint256 integral;\\n        // This scope is to avoid the \\\"stack too deep\\\" error.\\n        {\\n            // We assume that this function is always called immediately after `_checkpoint()`,\\n            // which guarantees that `_historicalIntegralSize` equals to the number of historical\\n            // rebalances.\\n            uint256 rebalanceSize = _historicalIntegralSize;\\n            integral = targetVersion == rebalanceSize\\n                ? _invTotalWeightIntegral\\n                : _historicalIntegrals[targetVersion];\\n        }\\n        if (userIntegral == integral && oldVersion == targetVersion) {\\n            // Return immediately when the user's rewards have already been updated to\\n            // the target version.\\n            return;\\n        }\\n\\n        uint256 rewards = _claimableRewards[account];\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        uint256 weight = _workingBalances[account];\\n        if (weight == 0) {\\n            // Loading available and locked is repeated to avoid \\\"stake too deep\\\" error.\\n            weight = weightedBalance(\\n                available[TRANCHE_M].add(locked[TRANCHE_M]),\\n                available[TRANCHE_A].add(locked[TRANCHE_A]),\\n                available[TRANCHE_B].add(locked[TRANCHE_B])\\n            );\\n            if (weight > 0) {\\n                // The contract was just upgraded from an old version without boosting\\n                _workingBalances[account] = weight;\\n            }\\n        }\\n        uint256 availableM = available[TRANCHE_M];\\n        uint256 availableA = available[TRANCHE_A];\\n        uint256 availableB = available[TRANCHE_B];\\n        uint256 lockedM = locked[TRANCHE_M];\\n        uint256 lockedA = locked[TRANCHE_A];\\n        uint256 lockedB = locked[TRANCHE_B];\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            rewards = rewards.add(\\n                weight.multiplyDecimalPrecise(_historicalIntegrals[i].sub(userIntegral))\\n            );\\n            if (availableM != 0 || availableA != 0 || availableB != 0) {\\n                (availableM, availableA, availableB) = _fundDoRebalance(\\n                    availableM,\\n                    availableA,\\n                    availableB,\\n                    i\\n                );\\n            }\\n            if (lockedM != 0 || lockedA != 0 || lockedB != 0) {\\n                (lockedM, lockedA, lockedB) = _fundDoRebalance(lockedM, lockedA, lockedB, i);\\n            }\\n            userIntegral = 0;\\n\\n            // Reset per-user weight boosting after the first rebalance\\n            weight = weightedBalance(\\n                availableM.add(lockedM),\\n                availableA.add(lockedA),\\n                availableB.add(lockedB)\\n            );\\n        }\\n        rewards = rewards.add(weight.multiplyDecimalPrecise(integral.sub(userIntegral)));\\n        address account_ = account; // Fix the \\\"stack too deep\\\" error\\n        _claimableRewards[account_] = rewards;\\n        _userIntegrals[account_] = integral;\\n\\n        if (oldVersion < targetVersion) {\\n            if (available[TRANCHE_M] != availableM) {\\n                available[TRANCHE_M] = availableM;\\n            }\\n            if (available[TRANCHE_A] != availableA) {\\n                available[TRANCHE_A] = availableA;\\n            }\\n            if (available[TRANCHE_B] != availableB) {\\n                available[TRANCHE_B] = availableB;\\n            }\\n            if (locked[TRANCHE_M] != lockedM) {\\n                locked[TRANCHE_M] = lockedM;\\n            }\\n            if (locked[TRANCHE_A] != lockedA) {\\n                locked[TRANCHE_A] = lockedA;\\n            }\\n            if (locked[TRANCHE_B] != lockedB) {\\n                locked[TRANCHE_B] = lockedB;\\n            }\\n            _balanceVersions[account_] = targetVersion;\\n            _workingBalances[account_] = weight;\\n        }\\n    }\\n\\n    /// @dev Calculate working balance, which depends on the amount of staked tokens and veCHESS.\\n    ///      Before this function is called, both `_checkpoint()` and `_userCheckpoint(account)`\\n    ///      should be called to update `_workingSupply` and `_workingBalances[account]` to\\n    ///      the latest rebalance version.\\n    /// @param account User address\\n    function _updateWorkingBalance(address account) private {\\n        uint256 weightedSupply =\\n            weightedBalance(\\n                _totalSupplies[TRANCHE_M],\\n                _totalSupplies[TRANCHE_A],\\n                _totalSupplies[TRANCHE_B]\\n            );\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        // Assume weightedBalance(x, 0, 0) always equal to x\\n        uint256 weightedM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n        uint256 weightedAB =\\n            weightedBalance(\\n                0,\\n                available[TRANCHE_A].add(locked[TRANCHE_A]),\\n                available[TRANCHE_B].add(locked[TRANCHE_B])\\n            );\\n\\n        uint256 newWorkingBalance = weightedAB.add(weightedM);\\n        uint256 veProportion = _veSnapshots[account].veProportion;\\n        if (veProportion > 0 && _veSnapshots[account].veLocked.unlockTime > block.timestamp) {\\n            uint256 boostingPower = weightedSupply.multiplyDecimal(veProportion);\\n            if (boostingPower <= weightedAB) {\\n                newWorkingBalance = newWorkingBalance.add(\\n                    boostingPower.multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                );\\n            } else {\\n                uint256 boostingPowerM =\\n                    (boostingPower - weightedAB)\\n                        .min(boostingPower.multiplyDecimal(MAX_BOOSTING_POWER_M))\\n                        .min(weightedM);\\n                newWorkingBalance = newWorkingBalance.add(\\n                    weightedAB.add(boostingPowerM).multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                );\\n            }\\n        }\\n\\n        _workingSupply = _workingSupply.sub(_workingBalances[account]).add(newWorkingBalance);\\n        _workingBalances[account] = newWorkingBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IVotingEscrow {\\n    struct LockedBalance {\\n        uint256 amount;\\n        uint256 unlockTime;\\n    }\\n\\n    function token() external view returns (address);\\n\\n    function maxTime() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTimestampDropBelow(address account, uint256 threshold)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getLockedBalance(address account) external view returns (LockedBalance memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/CoreUtility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nabstract contract CoreUtility {\\n    using SafeMath for uint256;\\n\\n    /// @dev UTC time of a day when the fund settles.\\n    uint256 internal constant SETTLEMENT_TIME = 14 hours;\\n\\n    /// @dev Return end timestamp of the trading week containing a given timestamp.\\n    ///\\n    ///      A trading week starts at UTC time `SETTLEMENT_TIME` on a Thursday (inclusive)\\n    ///      and ends at the same time of the next Thursday (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading week.\\n    function _endOfWeek(uint256 timestamp) internal pure returns (uint256) {\\n        return ((timestamp.add(1 weeks) - SETTLEMENT_TIME) / 1 weeks) * 1 weeks + SETTLEMENT_TIME;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ManagedPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract of an emergency stop mechanism that can be triggered by an authorized account.\\n *\\n * This module is modified based on Pausable in OpenZeppelin v3.3.0, adding public functions to\\n * pause, unpause and manage the pauser role. It is also designed to be used by upgradable\\n * contracts, like PausableUpgradable but with compact storage slots and no dependencies.\\n */\\nabstract contract ManagedPausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    event PauserRoleTransferred(address indexed previousPauser, address indexed newPauser);\\n\\n    uint256 private constant FALSE = 0;\\n    uint256 private constant TRUE = 1;\\n\\n    uint256 private _initialized;\\n\\n    uint256 private _paused;\\n\\n    address private _pauser;\\n\\n    function _initializeManagedPausable(address pauser_) internal {\\n        require(_initialized == FALSE);\\n        _initialized = TRUE;\\n        _paused = FALSE;\\n        _pauser = pauser_;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused != FALSE;\\n    }\\n\\n    function pauser() public view returns (address) {\\n        return _pauser;\\n    }\\n\\n    function renouncePauserRole() external onlyPauser {\\n        emit PauserRoleTransferred(_pauser, address(0));\\n        _pauser = address(0);\\n    }\\n\\n    function transferPauserRole(address newPauser) external onlyPauser {\\n        require(newPauser != address(0));\\n        emit PauserRoleTransferred(_pauser, newPauser);\\n        _pauser = newPauser;\\n    }\\n\\n    modifier onlyPauser() {\\n        require(_pauser == msg.sender, \\\"Pausable: only pauser\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(_paused == FALSE, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused != FALSE, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function pause() external onlyPauser whenNotPaused {\\n        _paused = TRUE;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function unpause() external onlyPauser whenPaused {\\n        _paused = FALSE;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IChessController {\\n    function getFundRelativeWeight(address account, uint256 timestamp) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChessSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IChessSchedule {\\n    function getRate(uint256 timestamp) external view returns (uint256);\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function addMinter(address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IFundV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IFund.sol\\\";\\n\\ninterface IFundV2 is IFund {\\n    function historicalUnderlying(uint256 timestamp) external view returns (uint256);\\n\\n    function getTotalUnderlying() external view returns (uint256);\\n\\n    function getStrategyUnderlying() external view returns (uint256);\\n\\n    function getTotalDebt() external view returns (uint256);\\n\\n    function transferToStrategy(uint256 amount) external;\\n\\n    function transferFromStrategy(uint256 amount) external;\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external;\\n\\n    function reportLoss(uint256 loss) external;\\n}\\n\"\r\n    },\r\n    \"contracts/fund/FundV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV3.sol\\\";\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IShareV2.sol\\\";\\nimport \\\"../interfaces/ITwapOracleV2.sol\\\";\\nimport \\\"../interfaces/IAprOracle.sol\\\";\\nimport \\\"../interfaces/IBallot.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\nimport \\\"./FundRolesV2.sol\\\";\\n\\ncontract FundV3 is IFundV3, Ownable, ReentrancyGuard, FundRolesV2, CoreUtility {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event ProfitReported(uint256 profit, uint256 performanceFee);\\n    event LossReported(uint256 loss);\\n    event DailyProtocolFeeRateUpdated(uint256 newDailyProtocolFeeRate);\\n    event TwapOracleUpdated(address newTwapOracle);\\n    event AprOracleUpdated(address newAprOracle);\\n    event BallotUpdated(address newBallot);\\n    event FeeCollectorUpdated(address newFeeCollector);\\n    event ActivityDelayTimeUpdated(uint256 delayTime);\\n    event SplitRatioUpdated(uint256 newSplitRatio);\\n    event FeeDebtPaid(uint256 amount);\\n    event TotalDebtUpdated(uint256 newTotalDebt);\\n\\n    uint256 private constant UNIT = 1e18;\\n    uint256 private constant MAX_INTEREST_RATE = 0.2e18; // 20% daily\\n    uint256 private constant MAX_DAILY_PROTOCOL_FEE_RATE = 0.05e18; // 5% daily rate\\n\\n    /// @notice Upper bound of `NAV_R / NAV_B` to trigger a rebalance.\\n    uint256 public immutable upperRebalanceThreshold;\\n\\n    /// @notice Lower bound of `NAV_R / NAV_B` to trigger a rebalance.\\n    uint256 public immutable lowerRebalanceThreshold;\\n\\n    /// @notice Address of the underlying token.\\n    address public immutable override tokenUnderlying;\\n\\n    /// @notice A multipler that normalizes an underlying balance to 18 decimal places.\\n    uint256 public immutable override underlyingDecimalMultiplier;\\n\\n    /// @notice Daily protocol fee rate.\\n    uint256 public dailyProtocolFeeRate;\\n\\n    /// @notice TwapOracle address for the underlying asset.\\n    ITwapOracleV2 public override twapOracle;\\n\\n    /// @notice AprOracle address.\\n    IAprOracle public aprOracle;\\n\\n    /// @notice Address of the interest rate ballot.\\n    IBallot public ballot;\\n\\n    /// @notice Fee Collector address.\\n    address public override feeCollector;\\n\\n    /// @notice End timestamp of the current trading day.\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    uint256 public override currentDay;\\n\\n    /// @notice The amount of BISHOP received by splitting one QUEEN.\\n    ///         This ratio changes on every rebalance.\\n    uint256 public override splitRatio;\\n\\n    /// @dev Mapping of rebalance version => splitRatio.\\n    mapping(uint256 => uint256) private _historicalSplitRatio;\\n\\n    /// @notice Start timestamp of the current primary market activity window.\\n    uint256 public override fundActivityStartTime;\\n\\n    uint256 public activityDelayTimeAfterRebalance;\\n\\n    /// @dev Historical rebalances. Rebalances are often accessed in loops with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_rebalanceSize` and should be explicitly checked when necessary.\\n    Rebalance[65535] private _rebalances;\\n\\n    /// @dev Historical rebalance count.\\n    uint256 private _rebalanceSize;\\n\\n    /// @dev Total share supply of the three tranches. They are always rebalanced to the latest\\n    ///      version.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Mapping of account => share balance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_balanceVersions`.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _balances;\\n\\n    /// @dev Rebalance version mapping for `_balances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev Mapping of owner => spender => share allowance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_allowanceVersions`.\\n    mapping(address => mapping(address => uint256[TRANCHE_COUNT])) private _allowances;\\n\\n    /// @dev Rebalance version mapping for `_allowances`.\\n    mapping(address => mapping(address => uint256)) private _allowanceVersions;\\n\\n    /// @dev Mapping of trading day => NAV of BISHOP.\\n    mapping(uint256 => uint256) private _historicalNavB;\\n\\n    /// @dev Mapping of trading day => NAV of ROOK.\\n    mapping(uint256 => uint256) private _historicalNavR;\\n\\n    /// @notice Mapping of trading day => equivalent BISHOP supply.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the total supply of BISHOP,\\n    ///         as if all QUEEN are split.\\n    mapping(uint256 => uint256) public override historicalEquivalentTotalB;\\n\\n    /// @notice Mapping of trading day => underlying assets in the fund.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the underlying assets in\\n    ///         the fund after settlement of that trading day.\\n    mapping(uint256 => uint256) public override historicalUnderlying;\\n\\n    /// @notice Mapping of trading week => interest rate of BISHOP.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the interest rate captured\\n    ///         after settlement of that day, which will be effective in the following trading day.\\n    mapping(uint256 => uint256) public historicalInterestRate;\\n\\n    /// @notice Amount of fee not transfered to the fee collector yet.\\n    uint256 public feeDebt;\\n\\n    /// @notice Amount of redemption underlying that the fund owes the primary market\\n    uint256 public redemptionDebt;\\n\\n    /// @dev Sum of the fee debt and redemption debts of all primary markets.\\n    uint256 private _totalDebt;\\n\\n    uint256 private _strategyUnderlying;\\n\\n    struct ConstructorParameters {\\n        address tokenUnderlying;\\n        uint256 underlyingDecimals;\\n        address tokenQ;\\n        address tokenB;\\n        address tokenR;\\n        address primaryMarket;\\n        address strategy;\\n        uint256 dailyProtocolFeeRate;\\n        uint256 upperRebalanceThreshold;\\n        uint256 lowerRebalanceThreshold;\\n        address twapOracle;\\n        address aprOracle;\\n        address ballot;\\n        address feeCollector;\\n    }\\n\\n    constructor(ConstructorParameters memory params)\\n        public\\n        Ownable()\\n        FundRolesV2(\\n            params.tokenQ,\\n            params.tokenB,\\n            params.tokenR,\\n            params.primaryMarket,\\n            params.strategy\\n        )\\n    {\\n        tokenUnderlying = params.tokenUnderlying;\\n        require(params.underlyingDecimals <= 18, \\\"Underlying decimals larger than 18\\\");\\n        underlyingDecimalMultiplier = 10**(18 - params.underlyingDecimals);\\n        _updateDailyProtocolFeeRate(params.dailyProtocolFeeRate);\\n        upperRebalanceThreshold = params.upperRebalanceThreshold;\\n        lowerRebalanceThreshold = params.lowerRebalanceThreshold;\\n        _updateTwapOracle(params.twapOracle);\\n        _updateAprOracle(params.aprOracle);\\n        _updateBallot(params.ballot);\\n        _updateFeeCollector(params.feeCollector);\\n        _updateActivityDelayTime(30 minutes);\\n    }\\n\\n    function initialize(\\n        uint256 newSplitRatio,\\n        uint256 lastNavB,\\n        uint256 lastNavR,\\n        uint256 strategyUnderlying\\n    ) external onlyOwner {\\n        require(splitRatio == 0 && currentDay == 0, \\\"Already initialized\\\");\\n        require(\\n            newSplitRatio != 0 && lastNavB >= UNIT && !_shouldTriggerRebalance(lastNavB, lastNavR),\\n            \\\"Invalid parameters\\\"\\n        );\\n        currentDay = endOfDay(block.timestamp);\\n        splitRatio = newSplitRatio;\\n        _historicalSplitRatio[0] = newSplitRatio;\\n        emit SplitRatioUpdated(newSplitRatio);\\n        uint256 lastDay = currentDay - 1 days;\\n        uint256 lastDayPrice = twapOracle.getTwap(lastDay);\\n        require(lastDayPrice != 0, \\\"Price not available\\\"); // required to do the first creation\\n        _historicalNavB[lastDay] = lastNavB;\\n        _historicalNavR[lastDay] = lastNavR;\\n        _strategyUnderlying = strategyUnderlying;\\n        uint256 lastInterestRate = _updateInterestRate(lastDay);\\n        historicalInterestRate[lastDay] = lastInterestRate;\\n        emit Settled(lastDay, lastNavB, lastNavR, lastInterestRate);\\n        fundActivityStartTime = lastDay;\\n    }\\n\\n    /// @notice UTC time of a day when the fund settles.\\n    function settlementTime() external pure returns (uint256) {\\n        return SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading day containing a given timestamp.\\n    ///\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading day.\\n    function endOfDay(uint256 timestamp) public pure override returns (uint256) {\\n        return ((timestamp.add(1 days) - SETTLEMENT_TIME) / 1 days) * 1 days + SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading week containing a given timestamp.\\n    ///\\n    ///         A trading week starts at UTC time `SETTLEMENT_TIME` on a Thursday (inclusive)\\n    ///         and ends at the same time of the next Thursday (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading week.\\n    function endOfWeek(uint256 timestamp) external pure returns (uint256) {\\n        return _endOfWeek(timestamp);\\n    }\\n\\n    function tokenQ() external view override returns (address) {\\n        return _tokenQ;\\n    }\\n\\n    function tokenB() external view override returns (address) {\\n        return _tokenB;\\n    }\\n\\n    function tokenR() external view override returns (address) {\\n        return _tokenR;\\n    }\\n\\n    function tokenShare(uint256 tranche) external view override returns (address) {\\n        return _getShare(tranche);\\n    }\\n\\n    function primaryMarket() external view override returns (address) {\\n        return _primaryMarket;\\n    }\\n\\n    function primaryMarketUpdateProposal() external view override returns (address, uint256) {\\n        return (_proposedPrimaryMarket, _proposedPrimaryMarketTimestamp);\\n    }\\n\\n    function strategy() external view override returns (address) {\\n        return _strategy;\\n    }\\n\\n    function strategyUpdateProposal() external view override returns (address, uint256) {\\n        return (_proposedStrategy, _proposedStrategyTimestamp);\\n    }\\n\\n    /// @notice Return the status of the fund contract.\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the fund contract is active\\n    function isFundActive(uint256 timestamp) public view override returns (bool) {\\n        return timestamp >= fundActivityStartTime;\\n    }\\n\\n    function getTotalUnderlying() public view override returns (uint256) {\\n        uint256 hot = IERC20(tokenUnderlying).balanceOf(address(this));\\n        return hot.add(_strategyUnderlying).sub(_totalDebt);\\n    }\\n\\n    function getStrategyUnderlying() external view override returns (uint256) {\\n        return _strategyUnderlying;\\n    }\\n\\n    function getTotalDebt() external view override returns (uint256) {\\n        return _totalDebt;\\n    }\\n\\n    /// @notice Equivalent BISHOP supply, as if all QUEEN are split.\\n    function getEquivalentTotalB() public view override returns (uint256) {\\n        return _totalSupplies[TRANCHE_Q].multiplyDecimal(splitRatio).add(_totalSupplies[TRANCHE_B]);\\n    }\\n\\n    /// @notice Equivalent QUEEN supply, as if all BISHOP and ROOK are merged.\\n    function getEquivalentTotalQ() external view override returns (uint256) {\\n        return _totalSupplies[TRANCHE_B].divideDecimal(splitRatio).add(_totalSupplies[TRANCHE_Q]);\\n    }\\n\\n    /// @notice Return the rebalance matrix at a given index. A zero struct is returned\\n    ///         if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return A rebalance matrix\\n    function getRebalance(uint256 index) external view override returns (Rebalance memory) {\\n        return _rebalances[index];\\n    }\\n\\n    /// @notice Return timestamp of the transaction triggering the rebalance at a given index.\\n    ///         Zero is returned if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return Timestamp of the rebalance\\n    function getRebalanceTimestamp(uint256 index) external view override returns (uint256) {\\n        return _rebalances[index].timestamp;\\n    }\\n\\n    /// @notice Return the number of historical rebalances.\\n    function getRebalanceSize() external view override returns (uint256) {\\n        return _rebalanceSize;\\n    }\\n\\n    /// @notice Return split ratio at a given version.\\n    ///         Zero is returned if `version` is invalid.\\n    /// @param version Rebalance version\\n    /// @return Split ratio of the version\\n    function historicalSplitRatio(uint256 version) external view override returns (uint256) {\\n        return _historicalSplitRatio[version];\\n    }\\n\\n    /// @notice Return NAV of BISHOP and ROOK of the given trading day.\\n    /// @param day End timestamp of a trading day\\n    /// @return navB NAV of BISHOP\\n    /// @return navR NAV of ROOK\\n    function historicalNavs(uint256 day)\\n        external\\n        view\\n        override\\n        returns (uint256 navB, uint256 navR)\\n    {\\n        return (_historicalNavB[day], _historicalNavR[day]);\\n    }\\n\\n    /// @notice Estimate the current NAV of all tranches, considering underlying price change,\\n    ///         accrued protocol fee and accrued interest since the previous settlement.\\n    ///\\n    ///         The extrapolation uses simple interest instead of daily compound interest in\\n    ///         calculating protocol fee and BISHOP's interest. There may be significant error\\n    ///         in the returned values when `timestamp` is far beyond the last settlement.\\n    /// @param price Price of the underlying asset (18 decimal places)\\n    /// @return navSum Sum of the estimated NAV of BISHOP and ROOK\\n    /// @return navB Estimated NAV of BISHOP\\n    /// @return navROrZero Estimated NAV of ROOK, or zero if the NAV is negative\\n    function extrapolateNav(uint256 price)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 navSum,\\n            uint256 navB,\\n            uint256 navROrZero\\n        )\\n    {\\n        uint256 settledDay = currentDay - 1 days;\\n        uint256 underlying = getTotalUnderlying();\\n        uint256 protocolFee =\\n            underlying.multiplyDecimal(dailyProtocolFeeRate).mul(block.timestamp - settledDay).div(\\n                1 days\\n            );\\n        underlying = underlying.sub(protocolFee);\\n        return\\n            _extrapolateNav(block.timestamp, settledDay, price, getEquivalentTotalB(), underlying);\\n    }\\n\\n    function _extrapolateNav(\\n        uint256 timestamp,\\n        uint256 settledDay,\\n        uint256 price,\\n        uint256 equivalentTotalB,\\n        uint256 underlying\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 navSum,\\n            uint256 navB,\\n            uint256 navROrZero\\n        )\\n    {\\n        navB = _historicalNavB[settledDay];\\n        if (equivalentTotalB > 0) {\\n            navSum = price.mul(underlying.mul(underlyingDecimalMultiplier)).div(equivalentTotalB);\\n            navB = navB.multiplyDecimal(\\n                historicalInterestRate[settledDay].mul(timestamp - settledDay).div(1 days).add(UNIT)\\n            );\\n            navROrZero = navSum >= navB ? navSum - navB : 0;\\n        } else {\\n            // If the fund is empty, use NAV in the last day\\n            navROrZero = _historicalNavR[settledDay];\\n            navSum = navB + navROrZero;\\n        }\\n    }\\n\\n    /// @notice Transform share amounts according to the rebalance at a given index.\\n    ///         This function performs no bounds checking on the given index. A non-existent\\n    ///         rebalance transforms anything to a zero vector.\\n    /// @param amountQ Amount of QUEEN before the rebalance\\n    /// @param amountB Amount of BISHOP before the rebalance\\n    /// @param amountR Amount of ROOK before the rebalance\\n    /// @param index Rebalance index\\n    /// @return newAmountQ Amount of QUEEN after the rebalance\\n    /// @return newAmountB Amount of BISHOP after the rebalance\\n    /// @return newAmountR Amount of ROOK after the rebalance\\n    function doRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 index\\n    )\\n        public\\n        view\\n        override\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n        newAmountQ = amountQ.add(amountB.multiplyDecimal(rebalance.ratioB2Q)).add(\\n            amountR.multiplyDecimal(rebalance.ratioR2Q)\\n        );\\n        uint256 ratioBR = rebalance.ratioBR; // Gas saver\\n        newAmountB = amountB.multiplyDecimal(ratioBR);\\n        newAmountR = amountR.multiplyDecimal(ratioBR);\\n    }\\n\\n    /// @notice Transform share amounts according to rebalances in a given index range,\\n    ///         This function performs no bounds checking on the given indices. The original amounts\\n    ///         are returned if `fromIndex` is no less than `toIndex`. A zero vector is returned\\n    ///         if `toIndex` is greater than the number of existing rebalances.\\n    /// @param amountQ Amount of QUEEN before the rebalance\\n    /// @param amountB Amount of BISHOP before the rebalance\\n    /// @param amountR Amount of ROOK before the rebalance\\n    /// @param fromIndex Starting of the rebalance index range, inclusive\\n    /// @param toIndex End of the rebalance index range, exclusive\\n    /// @return newAmountQ Amount of QUEEN after the rebalance\\n    /// @return newAmountB Amount of BISHOP after the rebalance\\n    /// @return newAmountR Amount of ROOK after the rebalance\\n    function batchRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        )\\n    {\\n        for (uint256 i = fromIndex; i < toIndex; i++) {\\n            (amountQ, amountB, amountR) = doRebalance(amountQ, amountB, amountR, i);\\n        }\\n        newAmountQ = amountQ;\\n        newAmountB = amountB;\\n        newAmountR = amountR;\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshBalance(account, targetVersion);\\n    }\\n\\n    /// @notice Transform allowance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshAllowance(owner, spender, targetVersion);\\n    }\\n\\n    function trancheBalanceOf(uint256 tranche, address account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 amountQ = _balances[account][TRANCHE_Q];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n        uint256 amountR = _balances[account][TRANCHE_R];\\n\\n        if (tranche == TRANCHE_Q) {\\n            if (amountQ == 0 && amountB == 0 && amountR == 0) return 0;\\n        } else if (tranche == TRANCHE_B) {\\n            if (amountB == 0) return 0;\\n        } else {\\n            if (amountR == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountQ, amountB, amountR) = doRebalance(amountQ, amountB, amountR, i);\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return amountQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return amountB;\\n        } else {\\n            return amountR;\\n        }\\n    }\\n\\n    /// @notice Return all three share balances transformed to the latest rebalance version.\\n    /// @param account Owner of the shares\\n    function trancheAllBalanceOf(address account)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 amountQ = _balances[account][TRANCHE_Q];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n        uint256 amountR = _balances[account][TRANCHE_R];\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountQ, amountB, amountR) = doRebalance(amountQ, amountB, amountR, i);\\n        }\\n\\n        return (amountQ, amountB, amountR);\\n    }\\n\\n    function trancheBalanceVersion(address account) external view override returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function trancheAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view override returns (uint256) {\\n        uint256 allowanceQ = _allowances[owner][spender][TRANCHE_Q];\\n        uint256 allowanceB = _allowances[owner][spender][TRANCHE_B];\\n        uint256 allowanceR = _allowances[owner][spender][TRANCHE_R];\\n\\n        if (tranche == TRANCHE_Q) {\\n            if (allowanceQ == 0) return 0;\\n        } else if (tranche == TRANCHE_B) {\\n            if (allowanceB == 0) return 0;\\n        } else {\\n            if (allowanceR == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _allowanceVersions[owner][spender]; i < size; i++) {\\n            (allowanceQ, allowanceB, allowanceR) = _rebalanceAllowance(\\n                allowanceQ,\\n                allowanceB,\\n                allowanceR,\\n                i\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return allowanceQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return allowanceB;\\n        } else {\\n            return allowanceR;\\n        }\\n    }\\n\\n    function trancheAllowanceVersion(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowanceVersions[owner][spender];\\n    }\\n\\n    function trancheTransfer(\\n        uint256 tranche,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyCurrentVersion(version) {\\n        _refreshBalance(msg.sender, version);\\n        _refreshBalance(recipient, version);\\n        _transfer(tranche, msg.sender, recipient, amount);\\n    }\\n\\n    function trancheTransferFrom(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyCurrentVersion(version) {\\n        _refreshAllowance(sender, msg.sender, version);\\n        uint256 newAllowance =\\n            _allowances[sender][msg.sender][tranche].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            );\\n        _approve(tranche, sender, msg.sender, newAllowance);\\n        _refreshBalance(sender, version);\\n        _refreshBalance(recipient, version);\\n        _transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function trancheApprove(\\n        uint256 tranche,\\n        address spender,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyCurrentVersion(version) {\\n        _refreshAllowance(msg.sender, spender, version);\\n        _approve(tranche, msg.sender, spender, amount);\\n    }\\n\\n    function trancheTotalSupply(uint256 tranche) external view override returns (uint256) {\\n        return _totalSupplies[tranche];\\n    }\\n\\n    function primaryMarketMint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyPrimaryMarket onlyCurrentVersion(version) {\\n        _refreshBalance(account, version);\\n        _mint(tranche, account, amount);\\n    }\\n\\n    function primaryMarketBurn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyPrimaryMarket onlyCurrentVersion(version) {\\n        _refreshBalance(account, version);\\n        _burn(tranche, account, amount);\\n    }\\n\\n    function shareTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override {\\n        uint256 tranche = _getTranche(msg.sender);\\n        if (tranche != TRANCHE_Q) {\\n            require(isFundActive(block.timestamp), \\\"Transfer is inactive\\\");\\n        }\\n        _refreshBalance(sender, _rebalanceSize);\\n        _refreshBalance(recipient, _rebalanceSize);\\n        _transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function shareTransferFrom(\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (uint256 newAllowance) {\\n        uint256 tranche = _getTranche(msg.sender);\\n        shareTransfer(sender, recipient, amount);\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function shareApprove(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external override {\\n        uint256 tranche = _getTranche(msg.sender);\\n        _refreshAllowance(owner, spender, _rebalanceSize);\\n        _approve(tranche, owner, spender, amount);\\n    }\\n\\n    function shareIncreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external override returns (uint256 newAllowance) {\\n        uint256 tranche = _getTranche(msg.sender);\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].add(addedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function shareDecreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external override returns (uint256 newAllowance) {\\n        uint256 tranche = _getTranche(msg.sender);\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(subtractedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function _transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        _balances[sender][tranche] = _balances[sender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient][tranche] = _balances[recipient][tranche].add(amount);\\n        IShareV2(_getShare(tranche)).fundEmitTransfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _balances[account][tranche] = _balances[account][tranche].add(amount);\\n        IShareV2(_getShare(tranche)).fundEmitTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n        _balances[account][tranche] = _balances[account][tranche].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        IShareV2(_getShare(tranche)).fundEmitTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender][tranche] = amount;\\n        IShareV2(_getShare(tranche)).fundEmitApproval(owner, spender, amount);\\n    }\\n\\n    /// @notice Settle the current trading day. Settlement includes the following changes\\n    ///         to the fund.\\n    ///\\n    ///         1. Charge protocol fee of the day.\\n    ///         2. Settle all pending creations and redemptions from the primary market.\\n    ///         3. Calculate NAV of the day and trigger rebalance if necessary.\\n    ///         4. Capture new interest rate for BISHOP.\\n    function settle() external nonReentrant {\\n        uint256 day = currentDay;\\n        require(day != 0, \\\"Not initialized\\\");\\n        require(block.timestamp >= day, \\\"The current trading day does not end yet\\\");\\n        uint256 price = twapOracle.getTwap(day);\\n        require(price != 0, \\\"Underlying price for settlement is not ready yet\\\");\\n\\n        _collectFee();\\n\\n        IPrimaryMarketV3(_primaryMarket).settle(day);\\n\\n        _payFeeDebt();\\n\\n        // Calculate NAV\\n        uint256 equivalentTotalB = getEquivalentTotalB();\\n        uint256 underlying = getTotalUnderlying();\\n        (uint256 navSum, uint256 navB, uint256 navR) =\\n            _extrapolateNav(day, day - 1 days, price, equivalentTotalB, underlying);\\n\\n        if (_shouldTriggerRebalance(navB, navR)) {\\n            uint256 newSplitRatio = splitRatio.multiplyDecimal(navSum) / 2;\\n            _triggerRebalance(day, navSum, navB, navR, newSplitRatio);\\n            navB = UNIT;\\n            navR = UNIT;\\n            equivalentTotalB = getEquivalentTotalB();\\n            fundActivityStartTime = day + activityDelayTimeAfterRebalance;\\n        } else {\\n            fundActivityStartTime = day;\\n        }\\n\\n        uint256 interestRate = _updateInterestRate(day);\\n        historicalInterestRate[day] = interestRate;\\n\\n        historicalEquivalentTotalB[day] = equivalentTotalB;\\n        historicalUnderlying[day] = underlying;\\n        _historicalNavB[day] = navB;\\n        _historicalNavR[day] = navR;\\n        currentDay = day + 1 days;\\n\\n        emit Settled(day, navB, navR, interestRate);\\n    }\\n\\n    function transferToStrategy(uint256 amount) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.add(amount);\\n        IERC20(tokenUnderlying).safeTransfer(_strategy, amount);\\n    }\\n\\n    function transferFromStrategy(uint256 amount) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.sub(amount);\\n        IERC20(tokenUnderlying).safeTransferFrom(_strategy, address(this), amount);\\n        _payFeeDebt();\\n    }\\n\\n    function primaryMarketTransferUnderlying(\\n        address recipient,\\n        uint256 amount,\\n        uint256 fee\\n    ) external override onlyPrimaryMarket {\\n        IERC20(tokenUnderlying).safeTransfer(recipient, amount);\\n        feeDebt = feeDebt.add(fee);\\n        _updateTotalDebt(_totalDebt.add(fee));\\n    }\\n\\n    function primaryMarketAddDebt(uint256 amount, uint256 fee) external override onlyPrimaryMarket {\\n        redemptionDebt = redemptionDebt.add(amount);\\n        feeDebt = feeDebt.add(fee);\\n        _updateTotalDebt(_totalDebt.add(amount).add(fee));\\n    }\\n\\n    function primaryMarketPayDebt(uint256 amount) external override onlyPrimaryMarket {\\n        redemptionDebt = redemptionDebt.sub(amount);\\n        _updateTotalDebt(_totalDebt.sub(amount));\\n        IERC20(tokenUnderlying).safeTransfer(msg.sender, amount);\\n    }\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external override onlyStrategy {\\n        require(profit >= performanceFee, \\\"Performance fee cannot exceed profit\\\");\\n        _strategyUnderlying = _strategyUnderlying.add(profit);\\n        feeDebt = feeDebt.add(performanceFee);\\n        _updateTotalDebt(_totalDebt.add(performanceFee));\\n        emit ProfitReported(profit, performanceFee);\\n    }\\n\\n    function reportLoss(uint256 loss) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.sub(loss);\\n        emit LossReported(loss);\\n    }\\n\\n    function proposePrimaryMarketUpdate(address newPrimaryMarket) external onlyOwner {\\n        _proposePrimaryMarketUpdate(newPrimaryMarket);\\n    }\\n\\n    function applyPrimaryMarketUpdate(address newPrimaryMarket) external onlyOwner {\\n        require(\\n            IPrimaryMarketV3(_primaryMarket).canBeRemovedFromFund(),\\n            \\\"Cannot update primary market\\\"\\n        );\\n        _applyPrimaryMarketUpdate(newPrimaryMarket);\\n    }\\n\\n    function proposeStrategyUpdate(address newStrategy) external onlyOwner {\\n        _proposeStrategyUpdate(newStrategy);\\n    }\\n\\n    function applyStrategyUpdate(address newStrategy) external onlyOwner {\\n        require(_totalDebt == 0, \\\"Cannot update strategy with debt\\\");\\n        _applyStrategyUpdate(newStrategy);\\n    }\\n\\n    function _updateDailyProtocolFeeRate(uint256 newDailyProtocolFeeRate) private {\\n        require(\\n            newDailyProtocolFeeRate <= MAX_DAILY_PROTOCOL_FEE_RATE,\\n            \\\"Exceed max protocol fee rate\\\"\\n        );\\n        dailyProtocolFeeRate = newDailyProtocolFeeRate;\\n        emit DailyProtocolFeeRateUpdated(newDailyProtocolFeeRate);\\n    }\\n\\n    function updateDailyProtocolFeeRate(uint256 newDailyProtocolFeeRate) external onlyOwner {\\n        _updateDailyProtocolFeeRate(newDailyProtocolFeeRate);\\n    }\\n\\n    function _updateTwapOracle(address newTwapOracle) private {\\n        twapOracle = ITwapOracleV2(newTwapOracle);\\n        emit TwapOracleUpdated(newTwapOracle);\\n    }\\n\\n    function updateTwapOracle(address newTwapOracle) external onlyOwner {\\n        _updateTwapOracle(newTwapOracle);\\n    }\\n\\n    function _updateAprOracle(address newAprOracle) private {\\n        aprOracle = IAprOracle(newAprOracle);\\n        emit AprOracleUpdated(newAprOracle);\\n    }\\n\\n    function updateAprOracle(address newAprOracle) external onlyOwner {\\n        _updateAprOracle(newAprOracle);\\n    }\\n\\n    function _updateBallot(address newBallot) private {\\n        ballot = IBallot(newBallot);\\n        emit BallotUpdated(newBallot);\\n    }\\n\\n    function updateBallot(address newBallot) external onlyOwner {\\n        _updateBallot(newBallot);\\n    }\\n\\n    function _updateFeeCollector(address newFeeCollector) private {\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorUpdated(newFeeCollector);\\n    }\\n\\n    function updateFeeCollector(address newFeeCollector) external onlyOwner {\\n        _updateFeeCollector(newFeeCollector);\\n    }\\n\\n    function _updateActivityDelayTime(uint256 delayTime) private {\\n        require(\\n            delayTime >= 30 minutes && delayTime <= 12 hours,\\n            \\\"Exceed allowed delay time range\\\"\\n        );\\n        activityDelayTimeAfterRebalance = delayTime;\\n        emit ActivityDelayTimeUpdated(delayTime);\\n    }\\n\\n    function updateActivityDelayTime(uint256 delayTime) external onlyOwner {\\n        _updateActivityDelayTime(delayTime);\\n    }\\n\\n    /// @dev Transfer protocol fee of the current trading day to the fee collector.\\n    ///      This function should be called before creation and redemption on the same day\\n    ///      are settled.\\n    function _collectFee() private {\\n        uint256 currentUnderlying = getTotalUnderlying();\\n        uint256 fee = currentUnderlying.multiplyDecimal(dailyProtocolFeeRate);\\n        if (fee > 0) {\\n            feeDebt = feeDebt.add(fee);\\n            _updateTotalDebt(_totalDebt.add(fee));\\n        }\\n    }\\n\\n    function _payFeeDebt() private {\\n        uint256 total = _totalDebt;\\n        if (total == 0) {\\n            return;\\n        }\\n        uint256 hot = IERC20(tokenUnderlying).balanceOf(address(this));\\n        if (hot == 0) {\\n            return;\\n        }\\n        uint256 fee = feeDebt;\\n        if (fee > 0) {\\n            uint256 amount = hot.min(fee);\\n            feeDebt = fee - amount;\\n            _updateTotalDebt(total - amount);\\n            // Call `feeCollector.checkpoint()` without errors.\\n            // This is a intended behavior because `feeCollector` may not have `checkpoint()`.\\n            (bool success, ) = feeCollector.call(abi.encodeWithSignature(\\\"checkpoint()\\\"));\\n            if (!success) {\\n                // ignore\\n            }\\n            IERC20(tokenUnderlying).safeTransfer(feeCollector, amount);\\n            emit FeeDebtPaid(amount);\\n        }\\n    }\\n\\n    /// @dev Check whether a new rebalance should be triggered. Rebalance is triggered if\\n    ///      ROOK's NAV over BISHOP's NAV is greater than the upper threshold or\\n    ///      less than the lower threshold.\\n    /// @param navB BISHOP's NAV before the rebalance\\n    /// @param navROrZero ROOK's NAV before the rebalance or zero if the NAV is negative\\n    /// @return Whether a new rebalance should be triggered\\n    function _shouldTriggerRebalance(uint256 navB, uint256 navROrZero) private view returns (bool) {\\n        uint256 rOverB = navROrZero.divideDecimal(navB);\\n        return rOverB < lowerRebalanceThreshold || rOverB > upperRebalanceThreshold;\\n    }\\n\\n    /// @dev Create a new rebalance that resets NAV of all tranches to 1. Total supplies are\\n    ///      rebalanced immediately.\\n    /// @param day Trading day that triggers this rebalance\\n    /// @param navSum Sum of BISHOP and ROOK's NAV\\n    /// @param navB BISHOP's NAV before this rebalance\\n    /// @param navROrZero ROOK's NAV before this rebalance or zero if the NAV is negative\\n    /// @param newSplitRatio The new split ratio after this rebalance\\n    function _triggerRebalance(\\n        uint256 day,\\n        uint256 navSum,\\n        uint256 navB,\\n        uint256 navROrZero,\\n        uint256 newSplitRatio\\n    ) private {\\n        Rebalance memory rebalance = _calculateRebalance(navSum, navB, navROrZero, newSplitRatio);\\n        uint256 oldSize = _rebalanceSize;\\n        splitRatio = newSplitRatio;\\n        _historicalSplitRatio[oldSize + 1] = newSplitRatio;\\n        emit SplitRatioUpdated(newSplitRatio);\\n        _rebalances[oldSize] = rebalance;\\n        _rebalanceSize = oldSize + 1;\\n        emit RebalanceTriggered(\\n            oldSize,\\n            day,\\n            navSum,\\n            navB,\\n            navROrZero,\\n            rebalance.ratioB2Q,\\n            rebalance.ratioR2Q,\\n            rebalance.ratioBR\\n        );\\n\\n        (\\n            _totalSupplies[TRANCHE_Q],\\n            _totalSupplies[TRANCHE_B],\\n            _totalSupplies[TRANCHE_R]\\n        ) = doRebalance(\\n            _totalSupplies[TRANCHE_Q],\\n            _totalSupplies[TRANCHE_B],\\n            _totalSupplies[TRANCHE_R],\\n            oldSize\\n        );\\n        _refreshBalance(address(this), oldSize + 1);\\n    }\\n\\n    /// @dev Create a new rebalance matrix that resets given NAVs to (1, 1).\\n    ///\\n    ///      Note that ROOK's NAV can be negative before the rebalance when the underlying price\\n    ///      drops dramatically in a single trading day, in which case zero should be passed to\\n    ///      this function instead of the negative NAV.\\n    /// @param navSum Sum of BISHOP and ROOK's NAV\\n    /// @param navB BISHOP's NAV before the rebalance\\n    /// @param navROrZero ROOK's NAV before the rebalance or zero if the NAV is negative\\n    /// @param newSplitRatio The new split ratio after this rebalance\\n    /// @return The rebalance matrix\\n    function _calculateRebalance(\\n        uint256 navSum,\\n        uint256 navB,\\n        uint256 navROrZero,\\n        uint256 newSplitRatio\\n    ) private view returns (Rebalance memory) {\\n        uint256 ratioBR;\\n        uint256 ratioB2Q;\\n        uint256 ratioR2Q;\\n        if (navROrZero <= navB) {\\n            // Lower rebalance\\n            ratioBR = navROrZero;\\n            ratioB2Q = (navSum / 2 - navROrZero).divideDecimal(newSplitRatio);\\n            ratioR2Q = 0;\\n        } else {\\n            // Upper rebalance\\n            ratioBR = UNIT;\\n            ratioB2Q = (navB - UNIT).divideDecimal(newSplitRatio) / 2;\\n            ratioR2Q = (navROrZero - UNIT).divideDecimal(newSplitRatio) / 2;\\n        }\\n        return\\n            Rebalance({\\n                ratioB2Q: ratioB2Q,\\n                ratioR2Q: ratioR2Q,\\n                ratioBR: ratioBR,\\n                timestamp: block.timestamp\\n            });\\n    }\\n\\n    function _updateInterestRate(uint256 week) private returns (uint256) {\\n        uint256 baseInterestRate = MAX_INTEREST_RATE.min(aprOracle.capture());\\n        uint256 floatingInterestRate = ballot.count(week).div(365);\\n        uint256 rate = baseInterestRate.add(floatingInterestRate);\\n\\n        emit InterestRateUpdated(baseInterestRate, floatingInterestRate);\\n\\n        return rate;\\n    }\\n\\n    function _updateTotalDebt(uint256 newTotalDebt) private {\\n        _totalDebt = newTotalDebt;\\n        emit TotalDebtUpdated(newTotalDebt);\\n    }\\n\\n    /// @dev Transform share balance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshBalance(address account, uint256 targetVersion) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage balanceTuple = _balances[account];\\n        uint256 balanceQ = balanceTuple[TRANCHE_Q];\\n        uint256 balanceB = balanceTuple[TRANCHE_B];\\n        uint256 balanceR = balanceTuple[TRANCHE_R];\\n        _balanceVersions[account] = targetVersion;\\n\\n        if (balanceQ == 0 && balanceB == 0 && balanceR == 0) {\\n            // Fast path for an empty account\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (balanceQ, balanceB, balanceR) = doRebalance(balanceQ, balanceB, balanceR, i);\\n        }\\n        balanceTuple[TRANCHE_Q] = balanceQ;\\n        balanceTuple[TRANCHE_B] = balanceB;\\n        balanceTuple[TRANCHE_R] = balanceR;\\n\\n        emit BalancesRebalanced(account, targetVersion, balanceQ, balanceB, balanceR);\\n    }\\n\\n    /// @dev Transform allowance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _allowanceVersions[owner][spender];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage allowanceTuple = _allowances[owner][spender];\\n        uint256 allowanceQ = allowanceTuple[TRANCHE_Q];\\n        uint256 allowanceB = allowanceTuple[TRANCHE_B];\\n        uint256 allowanceR = allowanceTuple[TRANCHE_R];\\n        _allowanceVersions[owner][spender] = targetVersion;\\n\\n        if (allowanceQ == 0 && allowanceB == 0 && allowanceR == 0) {\\n            // Fast path for an empty allowance\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (allowanceQ, allowanceB, allowanceR) = _rebalanceAllowance(\\n                allowanceQ,\\n                allowanceB,\\n                allowanceR,\\n                i\\n            );\\n        }\\n        allowanceTuple[TRANCHE_Q] = allowanceQ;\\n        allowanceTuple[TRANCHE_B] = allowanceB;\\n        allowanceTuple[TRANCHE_R] = allowanceR;\\n\\n        emit AllowancesRebalanced(\\n            owner,\\n            spender,\\n            targetVersion,\\n            allowanceQ,\\n            allowanceB,\\n            allowanceR\\n        );\\n    }\\n\\n    function _rebalanceAllowance(\\n        uint256 allowanceQ,\\n        uint256 allowanceB,\\n        uint256 allowanceR,\\n        uint256 index\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 newAllowanceQ,\\n            uint256 newAllowanceB,\\n            uint256 newAllowanceR\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n\\n        /// @dev using saturating arithmetic to avoid unconscious overflow revert\\n        newAllowanceQ = allowanceQ;\\n        newAllowanceB = allowanceB.saturatingMultiplyDecimal(rebalance.ratioBR);\\n        newAllowanceR = allowanceR.saturatingMultiplyDecimal(rebalance.ratioBR);\\n    }\\n\\n    modifier onlyCurrentVersion(uint256 version) {\\n        require(_rebalanceSize == version, \\\"Only current version\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/fund/ShareStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\ncontract ShareStaking is ITrancheIndexV2, CoreUtility {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposited(uint256 tranche, address account, uint256 amount);\\n    event Withdrawn(uint256 tranche, address account, uint256 amount);\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    uint256 private constant REWARD_WEIGHT_B = 2;\\n    uint256 private constant REWARD_WEIGHT_R = 1;\\n    uint256 private constant REWARD_WEIGHT_Q = 3;\\n    uint256 private constant MAX_BOOSTING_FACTOR = 3e18;\\n    uint256 private constant MAX_BOOSTING_FACTOR_MINUS_ONE = MAX_BOOSTING_FACTOR - 1e18;\\n\\n    IFundV3 public immutable fund;\\n\\n    /// @notice The Chess release schedule contract.\\n    IChessSchedule public immutable chessSchedule;\\n\\n    /// @notice The controller contract.\\n    IChessController public immutable chessController;\\n\\n    IVotingEscrow private immutable _votingEscrow;\\n\\n    /// @notice Timestamp when rewards start.\\n    uint256 public immutable rewardStartTimestamp;\\n\\n    /// @dev Per-fund CHESS emission rate. The product of CHESS emission rate\\n    ///      and weekly percentage of the fund\\n    uint256 private _rate;\\n\\n    /// @dev Total amount of user shares, i.e. sum of all entries in `_balances`.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Rebalance version of `_totalSupplies`.\\n    uint256 private _totalSupplyVersion;\\n\\n    /// @dev Amount of shares staked by each user.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _balances;\\n\\n    /// @dev Rebalance version mapping for `_balances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev Mapping of rebalance version => split ratio.\\n    mapping(uint256 => uint256) private _historicalSplitRatio;\\n\\n    /// @dev 1e27 * \u222b(rate(t) / totalWeight(t) dt) from the latest rebalance till checkpoint.\\n    uint256 private _invTotalWeightIntegral;\\n\\n    /// @dev Final `_invTotalWeightIntegral` before each rebalance.\\n    ///      These values are accessed in a loop in `_userCheckpoint()` with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_historicalIntegralSize` and should be explicitly checked when necessary.\\n    uint256[65535] private _historicalIntegrals;\\n\\n    /// @dev Actual length of the `_historicalIntegrals` array, which always equals to the number of\\n    ///      historical rebalances after `checkpoint()` is called.\\n    uint256 private _historicalIntegralSize;\\n\\n    /// @dev Timestamp when checkpoint() is called.\\n    uint256 private _checkpointTimestamp;\\n\\n    /// @dev Snapshot of `_invTotalWeightIntegral` per user.\\n    mapping(address => uint256) private _userIntegrals;\\n\\n    /// @dev Mapping of account => claimable rewards.\\n    mapping(address => uint256) private _claimableRewards;\\n\\n    uint256 private _workingSupply;\\n    mapping(address => uint256) private _workingBalances;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address votingEscrow_,\\n        uint256 rewardStartTimestamp_\\n    ) public {\\n        fund = IFundV3(fund_);\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        _votingEscrow = IVotingEscrow(votingEscrow_);\\n        rewardStartTimestamp = rewardStartTimestamp_;\\n        _checkpointTimestamp = block.timestamp;\\n    }\\n\\n    function getRate() external view returns (uint256) {\\n        return _rate / 1e18;\\n    }\\n\\n    /// @notice Return weight of given balance with respect to rewards.\\n    /// @param amountQ Amount of QUEEN\\n    /// @param amountB Amount of BISHOP\\n    /// @param amountR Amount of ROOK\\n    /// @param splitRatio Split ratio\\n    /// @return Rewarding weight of the balance\\n    function weightedBalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 splitRatio\\n    ) public pure returns (uint256) {\\n        return\\n            amountQ\\n                .mul(REWARD_WEIGHT_Q)\\n                .multiplyDecimal(splitRatio)\\n                .add(amountB.mul(REWARD_WEIGHT_B))\\n                .add(amountR.mul(REWARD_WEIGHT_R))\\n                .div(REWARD_WEIGHT_Q);\\n    }\\n\\n    function totalSupply(uint256 tranche) external view returns (uint256) {\\n        uint256 totalSupplyQ = _totalSupplies[TRANCHE_Q];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 totalSupplyR = _totalSupplies[TRANCHE_R];\\n\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (totalSupplyQ, totalSupplyB, totalSupplyR) = _fundBatchRebalance(\\n                totalSupplyQ,\\n                totalSupplyB,\\n                totalSupplyR,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return totalSupplyQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return totalSupplyB;\\n        } else {\\n            return totalSupplyR;\\n        }\\n    }\\n\\n    function trancheBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountQ = _balances[account][TRANCHE_Q];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n        uint256 amountR = _balances[account][TRANCHE_R];\\n\\n        if (tranche == TRANCHE_Q) {\\n            if (amountQ == 0 && amountB == 0 && amountR == 0) return 0;\\n        } else if (tranche == TRANCHE_B) {\\n            if (amountB == 0) return 0;\\n        } else {\\n            if (amountR == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountQ, amountB, amountR) = _fundBatchRebalance(\\n                amountQ,\\n                amountB,\\n                amountR,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return amountQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return amountB;\\n        } else {\\n            return amountR;\\n        }\\n    }\\n\\n    function balanceVersion(address account) external view returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function workingSupply() external view returns (uint256) {\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (uint256 totalSupplyQ, uint256 totalSupplyB, uint256 totalSupplyR) =\\n                _fundBatchRebalance(\\n                    _totalSupplies[TRANCHE_Q],\\n                    _totalSupplies[TRANCHE_B],\\n                    _totalSupplies[TRANCHE_R],\\n                    version,\\n                    rebalanceSize\\n                );\\n            return weightedBalance(totalSupplyQ, totalSupplyB, totalSupplyR, fund.splitRatio());\\n        } else {\\n            return _workingSupply;\\n        }\\n    }\\n\\n    function workingBalanceOf(address account) external view returns (uint256) {\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        uint256 workingBalance = _workingBalances[account]; // gas saver\\n        if (version < rebalanceSize || workingBalance == 0) {\\n            uint256[TRANCHE_COUNT] storage balance = _balances[account];\\n            uint256 amountQ = balance[TRANCHE_Q];\\n            uint256 amountB = balance[TRANCHE_B];\\n            uint256 amountR = balance[TRANCHE_R];\\n            if (version < rebalanceSize) {\\n                (amountQ, amountB, amountR) = _fundBatchRebalance(\\n                    amountQ,\\n                    amountB,\\n                    amountR,\\n                    version,\\n                    rebalanceSize\\n                );\\n            }\\n            return weightedBalance(amountQ, amountB, amountR, fund.splitRatio());\\n        } else {\\n            return workingBalance;\\n        }\\n    }\\n\\n    function _fundRebalanceSize() internal view returns (uint256) {\\n        return fund.getRebalanceSize();\\n    }\\n\\n    function _fundDoRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 index\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.doRebalance(amountQ, amountB, amountR, index);\\n    }\\n\\n    function _fundBatchRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.batchRebalance(amountQ, amountB, amountR, fromIndex, toIndex);\\n    }\\n\\n    /// @dev Stake share tokens. A user could send QUEEN before deposit().\\n    ///      The contract first measures how much tranche share it has received,\\n    ///      then transfer the rest from the user\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    /// @param recipient Address that receives deposit\\n    /// @param version The current rebalance version\\n    function deposit(\\n        uint256 tranche,\\n        uint256 amount,\\n        address recipient,\\n        uint256 version\\n    ) external {\\n        _checkpoint(version);\\n        _userCheckpoint(recipient, version);\\n        _balances[recipient][tranche] = _balances[recipient][tranche].add(amount);\\n        uint256 oldTotalSupply = _totalSupplies[tranche];\\n        _totalSupplies[tranche] = oldTotalSupply.add(amount);\\n        _updateWorkingBalance(recipient, version);\\n        uint256 spareAmount = fund.trancheBalanceOf(tranche, address(this)).sub(oldTotalSupply);\\n        if (spareAmount < amount) {\\n            // Retain the rest of share token (version is checked by the fund)\\n            fund.trancheTransferFrom(\\n                tranche,\\n                msg.sender,\\n                address(this),\\n                amount - spareAmount,\\n                version\\n            );\\n        } else {\\n            require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        }\\n        emit Deposited(tranche, recipient, amount);\\n    }\\n\\n    /// @notice Unstake tranche tokens.\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to withdraw\\n    /// @param version The current rebalance version\\n    function withdraw(\\n        uint256 tranche,\\n        uint256 amount,\\n        uint256 version\\n    ) external {\\n        _checkpoint(version);\\n        _userCheckpoint(msg.sender, version);\\n        _balances[msg.sender][tranche] = _balances[msg.sender][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to withdraw\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(msg.sender, version);\\n        // version is checked by the fund\\n        fund.trancheTransfer(tranche, msg.sender, amount, version);\\n        emit Withdrawn(tranche, msg.sender, amount);\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (targetVersion == 0) {\\n            targetVersion = rebalanceSize;\\n        } else {\\n            require(targetVersion <= rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, targetVersion);\\n    }\\n\\n    /// @notice Return claimable rewards of an account till now.\\n    ///\\n    ///         This function should be call as a \\\"view\\\" function off-chain to get\\n    ///         the return value, e.g. using `contract.claimableRewards.call(account)` in web3\\n    ///         or `contract.callStatic.claimableRewards(account)` in ethers.js.\\n    /// @param account Address of an account\\n    /// @return Amount of claimable rewards\\n    function claimableRewards(address account) external returns (uint256) {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        return _claimableRewards[account];\\n    }\\n\\n    /// @notice Claim the rewards for an account.\\n    /// @param account Account to claim its rewards\\n    function claimRewards(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        uint256 amount = _claimableRewards[account];\\n        _claimableRewards[account] = 0;\\n        chessSchedule.mint(account, amount);\\n        _updateWorkingBalance(account, rebalanceSize);\\n    }\\n\\n    /// @notice Synchronize an account's locked Chess with `VotingEscrow`\\n    ///         and update its working balance.\\n    /// @param account Address of the synchronized account\\n    function syncWithVotingEscrow(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _updateWorkingBalance(account, rebalanceSize);\\n    }\\n\\n    /// @dev Transform total supplies to the latest rebalance version and make a global reward checkpoint.\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _checkpoint(uint256 rebalanceSize) private {\\n        uint256 timestamp = _checkpointTimestamp;\\n        if (timestamp >= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 integral = _invTotalWeightIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceTimestamp;\\n        if (version < rebalanceSize) {\\n            rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n        } else {\\n            rebalanceTimestamp = type(uint256).max;\\n        }\\n        uint256 rate = _rate;\\n        uint256 totalSupplyQ = _totalSupplies[TRANCHE_Q];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 totalSupplyR = _totalSupplies[TRANCHE_R];\\n        uint256 weight = _workingSupply;\\n        uint256 timestamp_ = timestamp; // avoid stack too deep\\n\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp_ < block.timestamp; i++) {\\n            uint256 endTimestamp = rebalanceTimestamp.min(endWeek).min(block.timestamp);\\n\\n            if (weight > 0 && endTimestamp > rewardStartTimestamp) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp_.max(rewardStartTimestamp)))\\n                        .decimalToPreciseDecimal()\\n                        .div(weight)\\n                );\\n            }\\n\\n            if (endTimestamp == rebalanceTimestamp) {\\n                uint256 oldSize = _historicalIntegralSize;\\n                _historicalIntegrals[oldSize] = integral;\\n                _historicalIntegralSize = oldSize + 1;\\n\\n                integral = 0;\\n                (totalSupplyQ, totalSupplyB, totalSupplyR) = _fundDoRebalance(\\n                    totalSupplyQ,\\n                    totalSupplyB,\\n                    totalSupplyR,\\n                    version\\n                );\\n\\n                version++;\\n                {\\n                    // Reset total weight boosting after the first rebalance\\n                    uint256 splitRatio = fund.historicalSplitRatio(version);\\n                    weight = weightedBalance(totalSupplyQ, totalSupplyB, totalSupplyR, splitRatio);\\n                    _historicalSplitRatio[version] = splitRatio;\\n                }\\n\\n                if (version < rebalanceSize) {\\n                    rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n                } else {\\n                    rebalanceTimestamp = type(uint256).max;\\n                }\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek).mul(\\n                    chessController.getFundRelativeWeight(address(this), endWeek)\\n                );\\n                if (endWeek < rewardStartTimestamp && endWeek + 1 weeks > rewardStartTimestamp) {\\n                    // Rewards start in the middle of the next week. We adjust the rate to\\n                    // compensate for the period between `endWeek` and `rewardStartTimestamp`.\\n                    rate = rate.mul(1 weeks).div(endWeek + 1 weeks - rewardStartTimestamp);\\n                }\\n                endWeek += 1 weeks;\\n            }\\n\\n            timestamp_ = endTimestamp;\\n        }\\n\\n        _checkpointTimestamp = block.timestamp;\\n        _invTotalWeightIntegral = integral;\\n        _rate = rate;\\n        if (_totalSupplyVersion != rebalanceSize) {\\n            _totalSupplies[TRANCHE_Q] = totalSupplyQ;\\n            _totalSupplies[TRANCHE_B] = totalSupplyB;\\n            _totalSupplies[TRANCHE_R] = totalSupplyR;\\n            _totalSupplyVersion = rebalanceSize;\\n            // Reset total working weight before any boosting if rebalance ever triggered\\n            _workingSupply = weight;\\n        }\\n    }\\n\\n    /// @dev Transform a user's balance to a given rebalance version and update this user's rewards.\\n    ///\\n    ///      In most cases, the target version is the latest version and this function cumulates\\n    ///      rewards till now. When this function is called from `refreshBalance()`,\\n    ///      `targetVersion` can be an older version, in which case rewards are cumulated till\\n    ///      the end of that version (i.e. timestamp of the transaction triggering the rebalance\\n    ///      with index `targetVersion`).\\n    ///\\n    ///      This function should always be called after `_checkpoint()` is called, so that\\n    ///      the global reward checkpoint is guarenteed up to date.\\n    /// @param account Account to update\\n    /// @param targetVersion The target rebalance version\\n    function _userCheckpoint(address account, uint256 targetVersion) private {\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion > targetVersion) {\\n            return;\\n        }\\n        uint256 userIntegral = _userIntegrals[account];\\n        uint256 integral;\\n        // This scope is to avoid the \\\"stack too deep\\\" error.\\n        {\\n            // We assume that this function is always called immediately after `_checkpoint()`,\\n            // which guarantees that `_historicalIntegralSize` equals to the number of historical\\n            // rebalances.\\n            uint256 rebalanceSize = _historicalIntegralSize;\\n            integral = targetVersion == rebalanceSize\\n                ? _invTotalWeightIntegral\\n                : _historicalIntegrals[targetVersion];\\n        }\\n        if (userIntegral == integral && oldVersion == targetVersion) {\\n            // Return immediately when the user's rewards have already been updated to\\n            // the target version.\\n            return;\\n        }\\n\\n        uint256 rewards = _claimableRewards[account];\\n        uint256[TRANCHE_COUNT] storage balance = _balances[account];\\n        uint256 weight = _workingBalances[account];\\n        uint256 balanceQ = balance[TRANCHE_Q];\\n        uint256 balanceB = balance[TRANCHE_B];\\n        uint256 balanceR = balance[TRANCHE_R];\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            rewards = rewards.add(\\n                weight.multiplyDecimalPrecise(_historicalIntegrals[i].sub(userIntegral))\\n            );\\n            if (balanceQ != 0 || balanceB != 0 || balanceR != 0) {\\n                (balanceQ, balanceB, balanceR) = _fundDoRebalance(balanceQ, balanceB, balanceR, i);\\n            }\\n            userIntegral = 0;\\n\\n            // Reset per-user weight boosting after the first rebalance\\n            weight = weightedBalance(balanceQ, balanceB, balanceR, _historicalSplitRatio[i + 1]);\\n        }\\n        rewards = rewards.add(weight.multiplyDecimalPrecise(integral.sub(userIntegral)));\\n        address account_ = account; // Fix the \\\"stack too deep\\\" error\\n        _claimableRewards[account_] = rewards;\\n        _userIntegrals[account_] = integral;\\n\\n        if (oldVersion < targetVersion) {\\n            balance[TRANCHE_Q] = balanceQ;\\n            balance[TRANCHE_B] = balanceB;\\n            balance[TRANCHE_R] = balanceR;\\n            _balanceVersions[account_] = targetVersion;\\n            _workingBalances[account_] = weight;\\n        }\\n    }\\n\\n    /// @dev Calculate working balance, which depends on the amount of staked tokens and veCHESS.\\n    ///      Before this function is called, both `_checkpoint()` and `_userCheckpoint(account)`\\n    ///      should be called to update `_workingSupply` and `_workingBalances[account]` to\\n    ///      the latest rebalance version.\\n    /// @param account User address\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _updateWorkingBalance(address account, uint256 rebalanceSize) private {\\n        uint256 splitRatio = _historicalSplitRatio[rebalanceSize];\\n        if (splitRatio == 0) {\\n            // Read it from the fund in case that it's not initialized yet, e.g. when we reach here\\n            // for the first time and `rebalanceSize` is zero.\\n            splitRatio = fund.historicalSplitRatio(rebalanceSize);\\n            _historicalSplitRatio[rebalanceSize] = splitRatio;\\n        }\\n        uint256 weightedSupply =\\n            weightedBalance(\\n                _totalSupplies[TRANCHE_Q],\\n                _totalSupplies[TRANCHE_B],\\n                _totalSupplies[TRANCHE_R],\\n                splitRatio\\n            );\\n        uint256[TRANCHE_COUNT] storage balance = _balances[account];\\n        uint256 newWorkingBalance =\\n            weightedBalance(balance[TRANCHE_Q], balance[TRANCHE_B], balance[TRANCHE_R], splitRatio);\\n        uint256 veBalance = _votingEscrow.balanceOf(account);\\n        if (veBalance > 0) {\\n            uint256 veTotalSupply = _votingEscrow.totalSupply();\\n            uint256 maxWorkingBalance = newWorkingBalance.multiplyDecimal(MAX_BOOSTING_FACTOR);\\n            uint256 boostedWorkingBalance =\\n                newWorkingBalance.add(\\n                    weightedSupply\\n                        .mul(veBalance)\\n                        .multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                        .div(veTotalSupply)\\n                );\\n            newWorkingBalance = maxWorkingBalance.min(boostedWorkingBalance);\\n        }\\n\\n        _workingSupply = _workingSupply.sub(_workingBalances[account]).add(newWorkingBalance);\\n        _workingBalances[account] = newWorkingBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAprOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IAprOracle {\\n    function capture() external returns (uint256 dailyRate);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBallot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IBallot {\\n    struct Voter {\\n        uint256 amount;\\n        uint256 unlockTime;\\n        uint256 weight;\\n    }\\n\\n    function count(uint256 timestamp) external view returns (uint256);\\n\\n    function syncWithVotingEscrow(address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrimaryMarketV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./IFundV3.sol\\\";\\n\\ninterface IPrimaryMarketV3 {\\n    function fund() external view returns (IFundV3);\\n\\n    function getCreation(uint256 underlying) external view returns (uint256 outQ);\\n\\n    function getCreationForQ(uint256 minOutQ) external view returns (uint256 underlying);\\n\\n    function getRedemption(uint256 inQ) external view returns (uint256 underlying, uint256 fee);\\n\\n    function getRedemptionForUnderlying(uint256 minUnderlying) external view returns (uint256 inQ);\\n\\n    function getSplit(uint256 inQ) external view returns (uint256 outB);\\n\\n    function getSplitForB(uint256 minOutB) external view returns (uint256 inQ);\\n\\n    function getMerge(uint256 inB) external view returns (uint256 outQ, uint256 feeQ);\\n\\n    function getMergeForQ(uint256 minOutQ) external view returns (uint256 inB);\\n\\n    function canBeRemovedFromFund() external view returns (bool);\\n\\n    function create(\\n        address recipient,\\n        uint256 minOutQ,\\n        uint256 version\\n    ) external returns (uint256 outQ);\\n\\n    function redeem(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external returns (uint256 underlying);\\n\\n    function redeemAndUnwrap(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external returns (uint256 underlying);\\n\\n    function queueRedemption(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external returns (uint256 underlying, uint256 index);\\n\\n    function claimRedemptions(address account, uint256[] calldata indices)\\n        external\\n        returns (uint256 underlying);\\n\\n    function claimRedemptionsAndUnwrap(address account, uint256[] calldata indices)\\n        external\\n        returns (uint256 underlying);\\n\\n    function split(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 version\\n    ) external returns (uint256 outB);\\n\\n    function merge(\\n        address recipient,\\n        uint256 inB,\\n        uint256 version\\n    ) external returns (uint256 outQ);\\n\\n    function settle(uint256 day) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFundV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITwapOracleV2.sol\\\";\\n\\ninterface IFundV3 {\\n    /// @notice A linear transformation matrix that represents a rebalance.\\n    ///\\n    ///         ```\\n    ///             [        1        0        0 ]\\n    ///         R = [ ratioB2Q  ratioBR        0 ]\\n    ///             [ ratioR2Q        0  ratioBR ]\\n    ///         ```\\n    ///\\n    ///         Amounts of the three tranches `q`, `b` and `r` can be rebalanced by multiplying the matrix:\\n    ///\\n    ///         ```\\n    ///         [ q', b', r' ] = [ q, b, r ] * R\\n    ///         ```\\n    struct Rebalance {\\n        uint256 ratioB2Q;\\n        uint256 ratioR2Q;\\n        uint256 ratioBR;\\n        uint256 timestamp;\\n    }\\n\\n    function tokenUnderlying() external view returns (address);\\n\\n    function tokenQ() external view returns (address);\\n\\n    function tokenB() external view returns (address);\\n\\n    function tokenR() external view returns (address);\\n\\n    function tokenShare(uint256 tranche) external view returns (address);\\n\\n    function primaryMarket() external view returns (address);\\n\\n    function primaryMarketUpdateProposal() external view returns (address, uint256);\\n\\n    function strategy() external view returns (address);\\n\\n    function strategyUpdateProposal() external view returns (address, uint256);\\n\\n    function underlyingDecimalMultiplier() external view returns (uint256);\\n\\n    function twapOracle() external view returns (ITwapOracleV2);\\n\\n    function feeCollector() external view returns (address);\\n\\n    function endOfDay(uint256 timestamp) external pure returns (uint256);\\n\\n    function trancheTotalSupply(uint256 tranche) external view returns (uint256);\\n\\n    function trancheBalanceOf(uint256 tranche, address account) external view returns (uint256);\\n\\n    function trancheAllBalanceOf(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function trancheBalanceVersion(address account) external view returns (uint256);\\n\\n    function trancheAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function trancheAllowanceVersion(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function trancheTransfer(\\n        uint256 tranche,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function trancheTransferFrom(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function trancheApprove(\\n        uint256 tranche,\\n        address spender,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function getRebalanceSize() external view returns (uint256);\\n\\n    function getRebalance(uint256 index) external view returns (Rebalance memory);\\n\\n    function getRebalanceTimestamp(uint256 index) external view returns (uint256);\\n\\n    function currentDay() external view returns (uint256);\\n\\n    function splitRatio() external view returns (uint256);\\n\\n    function historicalSplitRatio(uint256 version) external view returns (uint256);\\n\\n    function fundActivityStartTime() external view returns (uint256);\\n\\n    function isFundActive(uint256 timestamp) external view returns (bool);\\n\\n    function getEquivalentTotalB() external view returns (uint256);\\n\\n    function getEquivalentTotalQ() external view returns (uint256);\\n\\n    function historicalEquivalentTotalB(uint256 timestamp) external view returns (uint256);\\n\\n    function historicalNavs(uint256 timestamp) external view returns (uint256 navB, uint256 navR);\\n\\n    function extrapolateNav(uint256 price)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function doRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        );\\n\\n    function batchRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        );\\n\\n    function refreshBalance(address account, uint256 targetVersion) external;\\n\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external;\\n\\n    function primaryMarketMint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function primaryMarketBurn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function shareTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function shareTransferFrom(\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (uint256 newAllowance);\\n\\n    function shareIncreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function shareDecreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function shareApprove(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    function historicalUnderlying(uint256 timestamp) external view returns (uint256);\\n\\n    function getTotalUnderlying() external view returns (uint256);\\n\\n    function getStrategyUnderlying() external view returns (uint256);\\n\\n    function getTotalDebt() external view returns (uint256);\\n\\n    function transferToStrategy(uint256 amount) external;\\n\\n    function transferFromStrategy(uint256 amount) external;\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external;\\n\\n    function reportLoss(uint256 loss) external;\\n\\n    function primaryMarketTransferUnderlying(\\n        address recipient,\\n        uint256 amount,\\n        uint256 fee\\n    ) external;\\n\\n    function primaryMarketAddDebt(uint256 amount, uint256 fee) external;\\n\\n    function primaryMarketPayDebt(uint256 amount) external;\\n\\n    event RebalanceTriggered(\\n        uint256 indexed index,\\n        uint256 indexed day,\\n        uint256 navSum,\\n        uint256 navB,\\n        uint256 navROrZero,\\n        uint256 ratioB2Q,\\n        uint256 ratioR2Q,\\n        uint256 ratioBR\\n    );\\n    event Settled(uint256 indexed day, uint256 navB, uint256 navR, uint256 interestRate);\\n    event InterestRateUpdated(uint256 baseInterestRate, uint256 floatingInterestRate);\\n    event BalancesRebalanced(\\n        address indexed account,\\n        uint256 version,\\n        uint256 balanceQ,\\n        uint256 balanceB,\\n        uint256 balanceR\\n    );\\n    event AllowancesRebalanced(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 version,\\n        uint256 allowanceQ,\\n        uint256 allowanceB,\\n        uint256 allowanceR\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShareV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IShareV2 is IERC20 {\\n    function fundEmitTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function fundEmitApproval(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracleV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./ITwapOracle.sol\\\";\\n\\ninterface ITwapOracleV2 is ITwapOracle {\\n    function getLatest() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/fund/FundRolesV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\n\\nabstract contract FundRolesV2 is ITrancheIndexV2 {\\n    event PrimaryMarketUpdateProposed(\\n        address indexed newPrimaryMarket,\\n        uint256 minTimestamp,\\n        uint256 maxTimestamp\\n    );\\n    event PrimaryMarketUpdated(\\n        address indexed previousPrimaryMarket,\\n        address indexed newPrimaryMarket\\n    );\\n    event StrategyUpdateProposed(\\n        address indexed newStrategy,\\n        uint256 minTimestamp,\\n        uint256 maxTimestamp\\n    );\\n    event StrategyUpdated(address indexed previousStrategy, address indexed newStrategy);\\n\\n    uint256 private constant ROLE_UPDATE_MIN_DELAY = 3 days;\\n    uint256 private constant ROLE_UPDATE_MAX_DELAY = 15 days;\\n\\n    address internal immutable _tokenQ;\\n    address internal immutable _tokenB;\\n    address internal immutable _tokenR;\\n\\n    address internal _primaryMarket;\\n    address internal _proposedPrimaryMarket;\\n    uint256 internal _proposedPrimaryMarketTimestamp;\\n\\n    address internal _strategy;\\n    address internal _proposedStrategy;\\n    uint256 internal _proposedStrategyTimestamp;\\n\\n    constructor(\\n        address tokenQ_,\\n        address tokenB_,\\n        address tokenR_,\\n        address primaryMarket_,\\n        address strategy_\\n    ) public {\\n        _tokenQ = tokenQ_;\\n        _tokenB = tokenB_;\\n        _tokenR = tokenR_;\\n        _primaryMarket = primaryMarket_;\\n        _strategy = strategy_;\\n        emit PrimaryMarketUpdated(address(0), primaryMarket_);\\n        emit StrategyUpdated(address(0), strategy_);\\n    }\\n\\n    function _getTranche(address share) internal view returns (uint256) {\\n        if (share == _tokenQ) {\\n            return TRANCHE_Q;\\n        } else if (share == _tokenB) {\\n            return TRANCHE_B;\\n        } else if (share == _tokenR) {\\n            return TRANCHE_R;\\n        } else {\\n            revert(\\\"Only share\\\");\\n        }\\n    }\\n\\n    function _getShare(uint256 tranche) internal view returns (address) {\\n        if (tranche == TRANCHE_Q) {\\n            return _tokenQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return _tokenB;\\n        } else if (tranche == TRANCHE_R) {\\n            return _tokenR;\\n        } else {\\n            revert(\\\"Invalid tranche\\\");\\n        }\\n    }\\n\\n    modifier onlyPrimaryMarket() {\\n        require(msg.sender == _primaryMarket, \\\"Only primary market\\\");\\n        _;\\n    }\\n\\n    function _proposePrimaryMarketUpdate(address newPrimaryMarket) internal {\\n        require(newPrimaryMarket != _primaryMarket);\\n        _proposedPrimaryMarket = newPrimaryMarket;\\n        _proposedPrimaryMarketTimestamp = block.timestamp;\\n        emit PrimaryMarketUpdateProposed(\\n            newPrimaryMarket,\\n            block.timestamp + ROLE_UPDATE_MIN_DELAY,\\n            block.timestamp + ROLE_UPDATE_MAX_DELAY\\n        );\\n    }\\n\\n    function _applyPrimaryMarketUpdate(address newPrimaryMarket) internal {\\n        require(_proposedPrimaryMarket == newPrimaryMarket, \\\"Proposed address mismatch\\\");\\n        require(\\n            block.timestamp >= _proposedPrimaryMarketTimestamp + ROLE_UPDATE_MIN_DELAY &&\\n                block.timestamp < _proposedPrimaryMarketTimestamp + ROLE_UPDATE_MAX_DELAY,\\n            \\\"Not ready to update\\\"\\n        );\\n        emit PrimaryMarketUpdated(_primaryMarket, newPrimaryMarket);\\n        _primaryMarket = newPrimaryMarket;\\n        _proposedPrimaryMarket = address(0);\\n        _proposedPrimaryMarketTimestamp = 0;\\n    }\\n\\n    modifier onlyStrategy() {\\n        require(msg.sender == _strategy, \\\"Only strategy\\\");\\n        _;\\n    }\\n\\n    function _proposeStrategyUpdate(address newStrategy) internal {\\n        require(newStrategy != _strategy);\\n        _proposedStrategy = newStrategy;\\n        _proposedStrategyTimestamp = block.timestamp;\\n        emit StrategyUpdateProposed(\\n            newStrategy,\\n            block.timestamp + ROLE_UPDATE_MIN_DELAY,\\n            block.timestamp + ROLE_UPDATE_MAX_DELAY\\n        );\\n    }\\n\\n    function _applyStrategyUpdate(address newStrategy) internal {\\n        require(_proposedStrategy == newStrategy, \\\"Proposed address mismatch\\\");\\n        require(\\n            block.timestamp >= _proposedStrategyTimestamp + ROLE_UPDATE_MIN_DELAY &&\\n                block.timestamp < _proposedStrategyTimestamp + ROLE_UPDATE_MAX_DELAY,\\n            \\\"Not ready to update\\\"\\n        );\\n        emit StrategyUpdated(_strategy, newStrategy);\\n        _strategy = newStrategy;\\n        _proposedStrategy = address(0);\\n        _proposedStrategyTimestamp = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITrancheIndexV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice Amounts of QUEEN, BISHOP and ROOK are sometimes stored in a `uint256[3]` array.\\n///         This contract defines index of each tranche in this array.\\n///\\n///         Solidity does not allow constants to be defined in interfaces. So this contract follows\\n///         the naming convention of interfaces but is implemented as an `abstract contract`.\\nabstract contract ITrancheIndexV2 {\\n    uint256 internal constant TRANCHE_Q = 0;\\n    uint256 internal constant TRANCHE_B = 1;\\n    uint256 internal constant TRANCHE_R = 2;\\n\\n    uint256 internal constant TRANCHE_COUNT = 3;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"oldPrimaryMarkets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"oldWrappedPrimaryMarkets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"upgradeTools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"encodedData\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"batchProtocolUpgrade\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"underlyingAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalQuoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"oldPrimaryMarkets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"oldWrappedPrimaryMarkets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"upgradeTools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"encodedData\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"batchProtocolUpgradeParameters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BatchUpgradeTool", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}