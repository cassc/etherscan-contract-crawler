{"SourceCode": "pragma solidity 0.5.9;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Transfer to null address is not allowed\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n}\r\n\r\n\r\ncontract Beneficiary is Ownable {\r\n\r\n    address payable public beneficiary;\r\n\r\n    constructor() public  {\r\n        beneficiary = msg.sender;\r\n    }\r\n\r\n    function setBeneficiary(address payable _beneficiary) public onlyOwner {\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    function withdrawal(uint256 value) public onlyOwner {\r\n        if (value > address(this).balance) {\r\n            revert(\"Insufficient balance\");\r\n        }\r\n\r\n        beneficiaryPayout(value);\r\n    }\r\n\r\n    function withdrawalAll() public onlyOwner {\r\n        beneficiaryPayout(address(this).balance);\r\n    }\r\n\r\n    function beneficiaryPayout(uint256 value) internal {\r\n        beneficiary.transfer(value);\r\n        emit BeneficiaryPayout(value);\r\n    }\r\n\r\n    event BeneficiaryPayout(uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract Manageable is Beneficiary {\r\n\r\n    uint256 DECIMALS = 10e8;\r\n\r\n    bool maintenance = false;\r\n\r\n    mapping(address => bool) public managers;\r\n\r\n    modifier onlyManager() {\r\n\r\n        require(managers[msg.sender] || msg.sender == address(this), \"Only managers allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier notOnMaintenance() {\r\n        require(!maintenance);\r\n        _;\r\n    }\r\n\r\n    bool saleOpen = false;\r\n\r\n    modifier onlyOnSale() {\r\n        require(saleOpen);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        managers[msg.sender] = true;\r\n    }\r\n\r\n    function setMaintenanceStatus(bool _status) public onlyManager {\r\n        maintenance = _status;\r\n        emit Maintenance(_status);\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwner {\r\n        managers[_manager] = true;\r\n    }\r\n\r\n    function deleteManager(address _manager) public onlyOwner {\r\n        delete managers[_manager];\r\n    }\r\n\r\n    function _addressToPayable(address _address) internal pure returns (address payable) {\r\n        return address(uint160(_address));\r\n    }\r\n\r\n    event Maintenance(bool status);\r\n\r\n    event FailedPayout(address to, uint256 value);\r\n\r\n}\r\n\r\npragma solidity 0.5.9;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function name() external view returns (string memory _name);\r\n\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n\r\n    function baseTokenURI() external view returns (string memory);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ncontract LockableToken is Manageable {\r\n    mapping(uint256 => bool) public locks;\r\n\r\n    modifier onlyNotLocked(uint256 _tokenId) {\r\n        require(!locks[_tokenId]);\r\n        _;\r\n    }\r\n\r\n    function isLocked(uint256 _tokenId) public view returns (bool) {\r\n        return locks[_tokenId];\r\n    }\r\n\r\n    function lockToken(uint256 _tokenId) public onlyManager {\r\n        locks[_tokenId] = true;\r\n    }\r\n\r\n    function unlockToken(uint256 _tokenId) public onlyManager {\r\n        locks[_tokenId] = false;\r\n    }\r\n\r\n    function _lockToken(uint256 _tokenId) internal {\r\n        locks[_tokenId] = true;\r\n    }\r\n\r\n    function _unlockToken(uint256 _tokenId) internal {\r\n        locks[_tokenId] = false;\r\n    }\r\n\r\n}\r\n\r\nlibrary Strings {\r\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function bytes32ToString(bytes32 x) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    function bytesToUInt(bytes32 b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint256(uint8(b[i]))*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n}\r\n\r\ncontract ERC721 is Manageable, LockableToken, IERC721, IERC165 {\r\n    using Strings for string;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(uint256 => address) public approved;\r\n    mapping(address => mapping(address => bool)) private operators;\r\n    mapping(uint256 => address) private tokenOwner;\r\n\r\n    uint256 public totalSupply = 0;\r\n\r\n    string private _tokenURI = \"\";\r\n\r\n    string private tokenName = '';\r\n    string private tokenSymbol = '';\r\n\r\n    modifier onlyTokenOwner(uint256 _tokenId) {\r\n        require(msg.sender == tokenOwner[_tokenId]);\r\n        _;\r\n    }\r\n\r\n    function setName(string memory _name) public onlyManager {\r\n        tokenName = _name;\r\n    }\r\n\r\n    function setSymbol(string memory _symbol) public onlyManager {\r\n        tokenSymbol = _symbol;\r\n    }\r\n\r\n    function name() external view returns (string memory _name) {\r\n        return tokenName;\r\n    }\r\n\r\n    function symbol() external view returns (string memory _symbol) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return interfaceID == 0x5b5e139f || interfaceID == 0x80ac58cd;\r\n    }\r\n\r\n    function setBaseTokenURI(string memory _newTokenURI) public onlyManager {\r\n        _tokenURI = _newTokenURI;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        return tokenOwner[_tokenId];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public onlyNotLocked(_tokenId) {\r\n        require(_to != address(0));\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) public onlyNotLocked(_tokenId) {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_approved != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        approved[_tokenId] = _approved;\r\n\r\n        emit Approval(owner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public {\r\n        require(_operator != msg.sender);\r\n\r\n        operators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operators[_owner][_operator];\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return approved[_tokenId];\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function transfer(address _from, address _to, uint256 _tokenId) public onlyTokenOwner(_tokenId) onlyNotLocked(_tokenId) {\r\n        require(_to != address(0));\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n\r\n        delete approved[_tokenId];\r\n\r\n        if (_from != address(0)) {\r\n            balances[_from]--;\r\n        } else {\r\n            totalSupply++;\r\n        }\r\n\r\n        if (_to != address(0)) {\r\n            balances[_to]++;\r\n        }\r\n\r\n        tokenOwner[_tokenId] = _to;\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _mint(uint256 _tokenId, address _owner) internal {\r\n        _transfer(address(0), _owner, _tokenId);\r\n    }\r\n\r\n    function _burn(uint256 _tokenId) internal {\r\n        _transfer(ownerOf(_tokenId), address(0), _tokenId);\r\n    }\r\n\r\n\r\n    function baseTokenURI() public view returns (string memory) {\r\n        return _tokenURI;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n        return Strings.strConcat(\r\n            baseTokenURI(),\r\n            Strings.uint2str(_tokenId)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        require(_to != address(0));\r\n\r\n        IERC721Receiver receiver = IERC721Receiver(_to);\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n\r\n        require(receiver.onERC721Received(msg.sender, _from, _tokenId, data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")));\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        require(_to != address(0));\r\n\r\n        IERC721Receiver receiver = IERC721Receiver(_to);\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n\r\n        require(receiver.onERC721Received(msg.sender, _from, _tokenId, \"\") == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")));\r\n    }\r\n\r\n    function burn(uint256 _tokenId) public onlyManager {\r\n        _burn(_tokenId);\r\n    }\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n}\r\n\r\n\r\ncontract Land is Manageable, ERC721 {\r\n\r\n    struct Token {\r\n        int64 x;\r\n        int64 y;\r\n        uint8 building;\r\n        uint8 level;\r\n        uint8 buildingType;\r\n    }\r\n\r\n    mapping(int => mapping(int => uint16)) public map;\r\n    mapping(int => mapping(int => uint)) public buyPrice;\r\n    mapping(int => mapping(int => uint256)) public mapReverse;\r\n\r\n    Token[] public tokens;\r\n\r\n    constructor() public {\r\n        setSymbol(\"MCPL\");\r\n        setName(\"MCP Land\");\r\n        setBaseTokenURI(\"https://mcp3d.com/bnb/api/land/\");\r\n        tokens.push(Token(0, 0, 0, 0, 0));\r\n    }\r\n\r\n    function mint(address _owner, int64 _x, int64 _y) public onlyManager returns (uint256 _tokenId) {\r\n        tokens.push(Token(_x, _y, 0, 0, 0));\r\n        mapReverse[_x][_y] = tokens.length - 1;\r\n        _mint(mapReverse[_x][_y], _owner);\r\n        return tokens.length - 1;\r\n    }\r\n\r\n    function batchBuyPrice(\r\n        int64[] memory _x,\r\n        int64[] memory _y,\r\n        uint[] memory _buyPrice\r\n    ) public onlyManager {\r\n        for(uint i = 0; i < _x.length; i++) {\r\n            buyPrice[_x[i]][_y[i]] = _buyPrice[i];\r\n        }\r\n    }\r\n\r\n    function batchMint(\r\n        address[] memory _owner,\r\n        int64[] memory _x,\r\n        int64[] memory _y,\r\n        uint8[] memory _building,\r\n        uint8[] memory _buildingType,\r\n        uint8[] memory _level,\r\n        uint16[] memory _regionId,\r\n        uint[] memory _buyPrices\r\n    ) public onlyManager {\r\n        for(uint i = 0; i < _owner.length; i++) {\r\n            if(mapReverse[_x[i]][_y[i]] > 0) {\r\n                continue;\r\n            }\r\n            tokens.push(Token(_x[i], _y[i], _building[i], _level[i], _buildingType[i]));\r\n            mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n            map[_x[i]][_y[i]] = _regionId[i];\r\n            buyPrice[_x[i]][_y[i]] = _buyPrices[i];\r\n            _mint(mapReverse[_x[i]][_y[i]], _owner[i]);\r\n        }\r\n    }\r\n\r\n    function batchMintHugeBuildings(\r\n        address[] memory _owner,\r\n        int64[] memory _x,\r\n        int64[] memory _y,\r\n        uint8[] memory _building,\r\n        uint8[] memory _buildingType,\r\n        uint8[] memory _type,\r\n        uint16[] memory _regionId\r\n    ) public onlyManager {\r\n        for(uint i = 0; i < _owner.length; i++) {\r\n            if(mapReverse[_x[i]][_y[i]] > 0) {\r\n                continue;\r\n            }\r\n\r\n            if(_type[i] == 1) {\r\n                tokens.push(Token(_x[i], _y[i], _building[i], 6, _buildingType[i]));\r\n\r\n                mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n                map[_x[i]][_y[i]] = _regionId[i];\r\n\r\n                mapReverse[_x[i] - 1][_y[i]] = tokens.length - 1;\r\n                map[_x[i] - 1][_y[i]] = _regionId[i];\r\n\r\n            } else if(_type[i] == 2) {\r\n                tokens.push(Token(_x[i], _y[i], _building[i], 6, _buildingType[i]));\r\n\r\n                mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n                map[_x[i]][_y[i]] = _regionId[i];\r\n\r\n                mapReverse[_x[i]][_y[i] - 1] = tokens.length - 1;\r\n                map[_x[i]][_y[i] - 1] = _regionId[i];\r\n\r\n            } else if(_type[i] == 3) {\r\n                tokens.push(Token(_x[i], _y[i], _building[i], 7, _buildingType[i]));\r\n\r\n                mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n                map[_x[i]][_y[i]] = _regionId[i];\r\n\r\n\r\n                mapReverse[_x[i]][_y[i] - 1] = tokens.length - 1;\r\n                map[_x[i]][_y[i] - 1] = _regionId[i];\r\n\r\n                mapReverse[_x[i] - 1][_y[i]] = tokens.length - 1;\r\n                map[_x[i] - 1][_y[i]] = _regionId[i];\r\n\r\n                mapReverse[_x[i] - 1][_y[i] - 1] = tokens.length - 1;\r\n                map[_x[i] - 1][_y[i] - 1] = _regionId[i];\r\n\r\n            }\r\n            _mint(tokens.length - 1, _owner[i]);\r\n        }\r\n    }\r\n\r\n    function burn(uint _tokenId) public onlyManager {\r\n        _burn(_tokenId);\r\n        delete mapReverse[tokens[_tokenId].x][tokens[_tokenId].y];\r\n        delete tokens[_tokenId];\r\n    }\r\n\r\n    function ownerOfXY(int _x, int _y) public view returns (address) {\r\n        return ownerOf(mapReverse[_x][_y]);\r\n    }\r\n\r\n    function setRegion(int64 _x, int64 _y, uint16 _region) public onlyManager {\r\n        map[_x][_y] = _region;\r\n    }\r\n\r\n    function setCell(int64 _x, int64 _y, uint8 _building, uint8 _level, uint8 _typeId) public onlyManager returns (uint)  {\r\n        require(mapReverse[_x][_y] > 0);\r\n\r\n        Token storage _token = tokens[mapReverse[_x][_y]];\r\n\r\n        _token.building = _building;\r\n        _token.level = _level;\r\n        _token.buildingType = _typeId;\r\n\r\n        return mapReverse[_x][_y];\r\n    }\r\n\r\n    function setToken(uint _tokenId, uint8 _building, uint8 _level, uint8 _typeId) public onlyManager {\r\n        Token storage _token = tokens[_tokenId];\r\n\r\n        _token.building = _building;\r\n        _token.level = _level;\r\n        _token.buildingType = _typeId;\r\n    }\r\n\r\n    function setToken(int64 _x, int64 _y, uint _tokenId) public onlyManager {\r\n        tokens[_tokenId] = Token(_x, _y, 0, 0, 0);\r\n        mapReverse[_x][_y] = _tokenId;\r\n    }\r\n\r\n    function setBuyPrice(int64 _x, int64 _y, uint _buyPrice) public onlyManager {\r\n        buyPrice[_x][_y] = _buyPrice;\r\n    }\r\n\r\n    function getCell(int64 _x, int64 _y) public view\r\n    returns (\r\n        uint8 buildingId,\r\n        uint8 buildingLevel,\r\n        uint8 buildingTypeId,\r\n        uint16 regionId,\r\n        uint tokenId\r\n    ) {\r\n        uint _tokenId = mapReverse[_x][_y];\r\n        uint16 _regionId = map[_x][_y];\r\n        return (tokens[_tokenId].building, tokens[_tokenId].level, tokens[_tokenId].buildingType, _regionId, _tokenId) ;\r\n    }\r\n\r\n    function getCellByToken(uint256 _tokenId) public view\r\n    returns (\r\n        uint8 buildingId,\r\n        uint8 buildingLevel,\r\n        uint8 buildingTypeId,\r\n        uint16 regionId,\r\n        uint tokenId\r\n    ) {\r\n        return getCell(tokens[_tokenId].x, tokens[_tokenId].y);\r\n    }\r\n\r\n    function getRegionId(int64 _x, int64 _y) public view returns (uint16 regionId) {\r\n        return map[_x][_y];\r\n    }\r\n\r\n    function getRegionId(uint _tokenId) public view returns (uint16 regionId) {\r\n        return map[tokens[_tokenId].x][tokens[_tokenId].y];\r\n    }\r\n\r\n    function getTokens(int64 _x, int64 _y, int _radius) public view returns (uint256[] memory tokenIds, uint256[] memory buyPrices, address payable[] memory owners) {\r\n        tokenIds = new uint256[]((uint(_radius) * 2 + 1) ** 2 - 1);\r\n        buyPrices = new uint256[]((uint(_radius) * 2 + 1) ** 2 - 1);\r\n        owners = new address payable[]((uint(_radius) * 2 + 1) ** 2 - 1);\r\n        uint i = 0;\r\n        for (int xi = _x - _radius; xi <= _x + _radius; xi++) {\r\n            for (int yi = _y - _radius; yi <= _y + _radius; yi++) {\r\n                if (_x == xi && _y == yi) {\r\n                    continue;\r\n                }\r\n\r\n                if (buyPrice[xi][yi] > 0) {\r\n                    tokenIds[i] = mapReverse[xi][yi];\r\n                    buyPrices[i] = buyPrice[xi][yi];\r\n                    owners[i] = _addressToPayable(ownerOfXY(xi, yi));\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyLand(int64 _x, int64 _y, uint256 _buyPrice, address _owner) public onlyManager {\r\n        require(map[_x][_y] > 0);\r\n        mint(_owner, _x, _y);\r\n        buyPrice[_x][_y] = _buyPrice;\r\n    }\r\n\r\n    function mergeCells(int64[] memory _x, int64[] memory _y, address _owner) public onlyManager returns (uint _baseTokenId) {\r\n        int64[2] memory _max = [_x[0], _y[0]];\r\n\r\n        for(uint i = 0; i < _x.length; i++) {\r\n            require(ownerOfXY(_x[i], _y[i]) == _owner);\r\n            require(tokens[mapReverse[_x[i]][_y[i]]].building == tokens[mapReverse[_x[0]][_y[0]]].building);\r\n            require(tokens[mapReverse[_x[i]][_y[i]]].level == tokens[mapReverse[_x[0]][_y[0]]].level);\r\n            if(_x[i] > _max[0]) {\r\n                _max[0] = _x[i];\r\n            }\r\n\r\n            if(_y[i] > _max[1]) {\r\n                _max[1] = _y[i];\r\n            }\r\n        }\r\n\r\n        _baseTokenId = mapReverse[_max[0]][_max[1]];\r\n\r\n        for(uint i = 0; i < _x.length; i++) {\r\n            if(_baseTokenId != mapReverse[_x[i]][_y[i]]) {\r\n                if(ownerOf(mapReverse[_x[i]][_y[i]]) != address(0)) {\r\n                    _burn(mapReverse[_x[i]][_y[i]]);\r\n                }\r\n                mapReverse[_x[i]][_y[i]] = _baseTokenId;\r\n            }\r\n        }\r\n    }\r\n\r\n    function unmergeToken(uint _tokenId) public onlyManager {\r\n        int64 _x = tokens[_tokenId].x;\r\n        int64 _y = tokens[_tokenId].y;\r\n        address _owner = ownerOf(_tokenId);\r\n\r\n        while(true) {\r\n            if(mapReverse[_x][_y] != _tokenId) {\r\n                _x = tokens[_tokenId].x;\r\n                _y--;\r\n            }\r\n\r\n            if(mapReverse[_x][_y] != _tokenId) {\r\n                break;\r\n            }\r\n\r\n            if(_x != tokens[_tokenId].x || _y != tokens[_tokenId].y) {\r\n                mint(_owner, _x, _y);\r\n            }\r\n\r\n            _x--;\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"}],\"name\":\"getCell\",\"outputs\":[{\"name\":\"buildingId\",\"type\":\"uint8\"},{\"name\":\"buildingLevel\",\"type\":\"uint8\"},{\"name\":\"buildingTypeId\",\"type\":\"uint8\"},{\"name\":\"regionId\",\"type\":\"uint16\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_building\",\"type\":\"uint8\"},{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_typeId\",\"type\":\"uint8\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"}],\"name\":\"setBuyPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64[]\"},{\"name\":\"_y\",\"type\":\"int64[]\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"mergeCells\",\"outputs\":[{\"name\":\"_baseTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address[]\"},{\"name\":\"_x\",\"type\":\"int64[]\"},{\"name\":\"_y\",\"type\":\"int64[]\"},{\"name\":\"_building\",\"type\":\"uint8[]\"},{\"name\":\"_buildingType\",\"type\":\"uint8[]\"},{\"name\":\"_type\",\"type\":\"uint8[]\"},{\"name\":\"_regionId\",\"type\":\"uint16[]\"}],\"name\":\"batchMintHugeBuildings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unmergeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenURI\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"name\":\"map\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"},{\"name\":\"_region\",\"type\":\"uint16\"}],\"name\":\"setRegion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"x\",\"type\":\"int64\"},{\"name\":\"y\",\"type\":\"int64\"},{\"name\":\"building\",\"type\":\"uint8\"},{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"buildingType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64[]\"},{\"name\":\"_y\",\"type\":\"int64[]\"},{\"name\":\"_buyPrice\",\"type\":\"uint256[]\"}],\"name\":\"batchBuyPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"lockToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"int256\"},{\"name\":\"_y\",\"type\":\"int256\"}],\"name\":\"ownerOfXY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getRegionId\",\"outputs\":[{\"name\":\"regionId\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"deleteManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCellByToken\",\"outputs\":[{\"name\":\"buildingId\",\"type\":\"uint8\"},{\"name\":\"buildingLevel\",\"type\":\"uint8\"},{\"name\":\"buildingTypeId\",\"type\":\"uint8\"},{\"name\":\"regionId\",\"type\":\"uint16\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"},{\"name\":\"_radius\",\"type\":\"int256\"}],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"buyPrices\",\"type\":\"uint256[]\"},{\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address[]\"},{\"name\":\"_x\",\"type\":\"int64[]\"},{\"name\":\"_y\",\"type\":\"int64[]\"},{\"name\":\"_building\",\"type\":\"uint8[]\"},{\"name\":\"_buildingType\",\"type\":\"uint8[]\"},{\"name\":\"_level\",\"type\":\"uint8[]\"},{\"name\":\"_regionId\",\"type\":\"uint16[]\"},{\"name\":\"_buyPrices\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"},{\"name\":\"_building\",\"type\":\"uint8\"},{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_typeId\",\"type\":\"uint8\"}],\"name\":\"setCell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unlockToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"}],\"name\":\"getRegionId\",\"outputs\":[{\"name\":\"regionId\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"int64\"},{\"name\":\"_y\",\"type\":\"int64\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"buyLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawalAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"name\":\"mapReverse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setMaintenanceStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Maintenance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BeneficiaryPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "Land", "CompilerVersion": "v0.5.9+commit.c68bc34e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://44b889e915692e3db688b3b50596e191db810a95c0b6b2a3c8e79cfa101050ce"}