{"SourceCode": "// File: contracts/IERC20.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool); // Include the `approve` function\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    event Mint(address indexed to, uint256 value);\r\n}\r\n// File: contracts/UserDataContract.sol\r\n\r\n\r\npragma solidity 0.8.0;\r\ncontract UserDataContract {\r\n    address public owner;\r\n\r\n    struct User {\r\n        string name;\r\n        string email;\r\n        string mobile;\r\n        address sponsorAddress;\r\n        address userAddress;\r\n        address[] referrals;\r\n        uint256 joiningDate;\r\n        bool active;\r\n        bool withdrawEnable;\r\n    }\r\n\r\n    struct Package {\r\n        string name;\r\n        uint256 minimumAmount;\r\n        uint256 maxAmount;\r\n        uint256 roiDaily;\r\n        uint256 initialLock;\r\n        uint256 openingPercentage;\r\n    }\r\n\r\n   struct StakingDetail {\r\n        uint256 packageId;\r\n        uint256 investedAmountUSD;\r\n        uint256 investedAmount;\r\n        uint256 stakingStartDate;\r\n        uint256 initialLock;\r\n        uint256 remainingToken;\r\n        uint256 monthCount;\r\n        uint256 roiDaily;\r\n    }\r\n\r\n    mapping(address => StakingDetail[]) public stakingDetails;\r\n    mapping(address => User) public users;\r\n    mapping(uint256 => Package) public packages;\r\n    address[] public userAddresses;\r\n    uint256 private nextPackageId = 5;\r\n    address public allowedContract;\r\n    mapping(address => uint256) public amountWithdrawn;\r\n    mapping(address => uint256) public extraBonus;\r\n    mapping(address => uint256) public totalInvestments;\r\n    uint256 public directCommisionPercentage =50000;\r\n    uint256 public totalLevels  =12;\r\n    uint256 public percentage_decimals =10000;\r\n    uint256[12] public levelPercentage = [150000,100000,50000,30000,20000,10000,10000,10000,10000,10000,20000,30000];\r\n    uint256[12] public directReferralsRequirement = [1,2,5,10,15,20,20,20,20,20,20,20];\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        packages[1] = Package(\r\n            \"PACKAGE-1\",\r\n            50*10**18,\r\n            499*10**18,\r\n            2666,\r\n            100 * 1 days,\r\n            20\r\n        );\r\n        packages[2] = Package(\r\n            \"PACKAGE-2\",\r\n            500*10**18,\r\n            999*10**18,\r\n            3333,\r\n            100 * 1 days,\r\n            20\r\n        );\r\n        packages[3] = Package(\r\n            \"PACKAGE-3\",\r\n            1000*10**18,\r\n            4999*10**18,\r\n            3666,\r\n            100 * 1 days,\r\n            20\r\n        );\r\n        packages[4] = Package(\r\n            \"PACKAGE-4\",\r\n            5000*10**18,\r\n            10*10**36,\r\n            4000,\r\n            100 * 1 days,\r\n            20\r\n        );\r\n        registerUser(msg.sender,\"admin\",\"admin@admin.com\",\"0000000000\",address(0));\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the owner can perform this operation\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedContract() {\r\n        require(msg.sender == allowedContract || msg.sender ==owner , \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    function registerUser(\r\n        address user_address,\r\n        string memory name,\r\n        string memory email,\r\n        string memory mobile,\r\n        address sponsorAddress\r\n    ) public onlyAllowedContract returns (bool)  {\r\n        require(\r\n            users[user_address].userAddress == address(0),\r\n            \"User already registered\"\r\n        );\r\n        address[] memory emptyArray = new address[](0);\r\n        users[user_address] = User(\r\n            name,\r\n            email,\r\n            mobile,\r\n            sponsorAddress,\r\n            user_address,\r\n            emptyArray,\r\n            block.timestamp,\r\n            false,\r\n            true\r\n        );\r\n        userAddresses.push(user_address);\r\n        users[sponsorAddress].referrals.push(user_address);\r\n        return true;\r\n    }\r\n\r\n    function purchasePackage(\r\n        uint256 _packageId,\r\n        address _userAddress,\r\n        uint256 _investedAmountUSD,\r\n        uint256 _investedAmount\r\n    ) public onlyAllowedContract returns (bool) {\r\n        require(\r\n            users[_userAddress].userAddress != address(0),\r\n            \"User is not registered\"\r\n        );\r\n        uint256 initialLockdays= packages[_packageId].initialLock;\r\n        uint256 roiDaily= packages[_packageId].roiDaily;\r\n        StakingDetail memory detail = StakingDetail(\r\n            _packageId,\r\n            _investedAmountUSD,\r\n            _investedAmount,\r\n            block.timestamp,\r\n            initialLockdays,\r\n            _investedAmount,\r\n            0,\r\n            roiDaily\r\n        );\r\n        totalInvestments[_userAddress] += _investedAmount;\r\n        stakingDetails[_userAddress].push(detail);\r\n        users[_userAddress].active = true;\r\n        return true;\r\n    }\r\n\r\n    function AddPackageToOldUser(\r\n        address _userAddress,\r\n        uint256 _packageId,\r\n        uint256 _investedAmountUSD,\r\n        uint256 _investedAmount,\r\n        uint256 _stakingStartDate,\r\n        uint256 _monthCount\r\n    ) public onlyAllowedContract returns (bool) {\r\n        require(\r\n            users[_userAddress].userAddress != address(0),\r\n            \"User is not registered\"\r\n        );\r\n        uint256 _roiDaily= packages[_packageId].roiDaily;\r\n        StakingDetail memory detail = StakingDetail(\r\n            _packageId,\r\n            _investedAmountUSD,\r\n            _investedAmount,\r\n            _stakingStartDate,\r\n            packages[_packageId].initialLock,\r\n            _investedAmount,\r\n            _monthCount,\r\n            _roiDaily\r\n        );\r\n        totalInvestments[_userAddress] += _investedAmount;\r\n        stakingDetails[_userAddress].push(detail);\r\n        users[_userAddress].active = true;\r\n        return true;\r\n    }\r\n\r\n    function getUserInfo(address _userAddress)\r\n        public\r\n        view\r\n        returns (\r\n            string memory name,\r\n            string memory email,\r\n            string memory mobile,\r\n            address sponsorAddress,\r\n            address userAddress,\r\n            address[] memory referrals,\r\n            uint256 joiningDate,\r\n            bool active\r\n        )\r\n    {\r\n        User memory user = users[_userAddress];\r\n        return (\r\n            user.name,\r\n            user.email,\r\n            user.mobile,\r\n            user.sponsorAddress,\r\n            user.userAddress,\r\n            user.referrals,\r\n            user.joiningDate,\r\n            user.active\r\n        );\r\n    }\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    // Add a new package\r\n    function addPackage(\r\n        string memory name,\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount,\r\n        uint256 _roiDaily,\r\n        uint256 _initialLockDays,\r\n        uint256 _openingPercentage\r\n    ) public onlyOwner {\r\n        require(_minAmount > 0, \"Minimum amount must be greater than 0\");\r\n        require(\r\n            _maxAmount > _minAmount,\r\n            \"Maximum amount must be greater than minimum amount\"\r\n        );\r\n        packages[nextPackageId] = Package(\r\n            name,\r\n            _minAmount,\r\n            _maxAmount,\r\n            _roiDaily,\r\n            _initialLockDays,\r\n            _openingPercentage\r\n        );\r\n        nextPackageId++;\r\n    }\r\n\r\n    // Delete a package by packageId\r\n    function deletePackage(uint256 packageId) public onlyOwner {\r\n        require(\r\n            packageId > 0 && packageId < nextPackageId,\r\n            \"Invalid package ID\"\r\n        );\r\n        delete packages[packageId];\r\n    }\r\n\r\n    // Update an existing package\r\n    function updatePackage(\r\n        uint256 packageId,\r\n        string memory name,\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount,\r\n        uint256 _roiDaily,\r\n        uint256 _initialLockDays,\r\n        uint256 _openingPercentage\r\n    ) public onlyOwner {\r\n        require(\r\n            packageId > 0 && packageId < nextPackageId,\r\n            \"Invalid package ID\"\r\n        );\r\n        require(_minAmount > 0, \"Minimum amount must be greater than 0\");\r\n        require(\r\n            _maxAmount > _minAmount,\r\n            \"Maximum amount must be greater than minimum amount\"\r\n        );\r\n        packages[packageId] = Package(\r\n            name,\r\n            _minAmount,\r\n            _maxAmount,\r\n            _roiDaily,\r\n            _initialLockDays,\r\n            _openingPercentage\r\n        );\r\n    }\r\n\r\n    // Get package details by packageId\r\n    function getPackage(uint256 packageId)\r\n        public\r\n        view\r\n        returns (\r\n            string memory name,\r\n            uint256 maxAmount,\r\n            uint256 minimumAmount,\r\n            uint256 roiDaily,\r\n            uint256 initialLock,\r\n            uint256 openingPercentage\r\n        )\r\n    {\r\n        require(\r\n            packageId > 0 && packageId < nextPackageId,\r\n            \"Invalid package ID\"\r\n        );\r\n        Package memory package = packages[packageId];\r\n        return (\r\n            package.name,\r\n            package.maxAmount,\r\n            package.minimumAmount,\r\n            package.roiDaily,\r\n            package.initialLock,\r\n            package.openingPercentage\r\n        );\r\n    }\r\n\r\n    function getPackageRequirement(uint256 packageId)\r\n        public\r\n        view\r\n        returns (uint256 maxAmount, uint256 minimumAmount)\r\n    {\r\n        require(\r\n            packageId > 0 && packageId < nextPackageId,\r\n            \"Invalid package ID\"\r\n        );\r\n        Package memory package = packages[packageId];\r\n        return (package.maxAmount, package.minimumAmount);\r\n    }\r\n\r\n    // Get all packages\r\n    function getAllPackages() public view returns (Package[] memory) {\r\n        Package[] memory allPackages = new Package[](nextPackageId - 1);\r\n        for (uint256 i = 1; i < nextPackageId; i++) {\r\n            allPackages[i - 1] = packages[i];\r\n        }\r\n        return allPackages;\r\n    }\r\n\r\n    // Get all users with details\r\n    function getAllUsersWithDetails() public view returns (User[] memory) {\r\n        User[] memory allUsers = new User[](userAddresses.length);\r\n        for (uint256 i = 0; i < userAddresses.length; i++) {\r\n            allUsers[i] = users[userAddresses[i]];\r\n        }\r\n        return allUsers;\r\n    }\r\n\r\n\r\n    function updateUserDetails(\r\n        string  memory name,\r\n        string  memory email,\r\n        string  memory mobile,\r\n        address userAddress,\r\n        address _sponsorAddress,\r\n        bool active\r\n        ) external onlyOwner returns (bool){\r\n        users[userAddress].name = name;\r\n        users[userAddress].email = email;\r\n        users[userAddress].mobile = mobile;\r\n        users[userAddress].active = active;\r\n        users[userAddress].sponsorAddress = _sponsorAddress;\r\n        return true;\r\n    }\r\n\r\n    // Get all users with details\r\n    function getAllStakings(address _account)\r\n        external\r\n        view\r\n        returns (  \r\n         StakingDetail[] memory)\r\n    {\r\n        StakingDetail[] memory details = stakingDetails[_account];\r\n        return (details);\r\n    }\r\n\r\n    function updateAllowedContractAddress(address _allowedContract) external onlyOwner returns (bool){\r\n        allowedContract = _allowedContract;\r\n        return true;\r\n    }\r\n\r\n    function updateWithdrawnBalance(address _account, uint256 amount_)\r\n        external\r\n        onlyAllowedContract\r\n        returns (bool)\r\n    {\r\n        amountWithdrawn[_account] += amount_;\r\n        return true;\r\n    }\r\n\r\n    function getUserActive(address user_) external view returns (bool) {\r\n       return users[user_].active;\r\n    }\r\n\r\n    function getAmountWithdrawn(address user_) external view returns (uint256) {\r\n       return amountWithdrawn[user_];\r\n    }\r\n\r\n    function addExtraBonus(address user_,uint256 amount_) external onlyOwner returns (uint256) {\r\n       return extraBonus[user_] += amount_;\r\n    }\r\n\r\n    function getTotalLevels() external view returns (uint256) {\r\n       return totalLevels;\r\n    }\r\n\r\n    function getReferrals(address user_) external view returns (address[] memory) {\r\n       return users[user_].referrals;\r\n    }\r\n\r\n      function getDirectReferralRequirement(uint256 level_) external view returns (uint256) {\r\n       return directReferralsRequirement[level_];\r\n    }\r\n\r\n    function updateDirectReferralsRequirement(uint256[] memory newValues) external onlyOwner {\r\n        require(newValues.length == 12, \"Invalid array length\");\r\n        for (uint256 i = 0; i < 12; i++) {\r\n            directReferralsRequirement[i] = newValues[i];\r\n        }\r\n    }\r\n\r\n    function updateLevelPercentage(uint256[] memory newValues) external {\r\n        require(newValues.length == 12, \"Invalid array length\");\r\n        for (uint256 i = 0; i < 12; i++) {\r\n            levelPercentage[i] = newValues[i];\r\n        }\r\n    }\r\n\r\n\r\n    function getlevelPercentage(uint256 level_) external view returns (uint256) {\r\n       return levelPercentage[level_];\r\n    }\r\n\r\n    function getStakingDetails(address user_) external view returns (StakingDetail[] memory) {\r\n       return stakingDetails[user_];\r\n    }\r\n\r\n     function getDirectCommisionPercentage() external view returns (uint256) {\r\n       return directCommisionPercentage;\r\n    }\r\n\r\n    function getPackageDetail(uint256 _packageId) external view returns (Package memory) {\r\n       return packages[_packageId];\r\n    }\r\n\r\n    function getExtraBonus(address _user) external view returns (uint256) {\r\n       return extraBonus[_user];\r\n    }\r\n\r\n    function getOpeningPercentage(uint256 _packageId) external view returns (uint256) {\r\n       return packages[_packageId].openingPercentage;\r\n    }\r\n\r\n    function updateWithdrawalStatusForUser(address _user,bool _value) external onlyOwner{\r\n        require(users[_user].withdrawEnable = _value, \"Update Failed\");\r\n    }\r\n\r\n\r\n    function getWithdrawalStatusForUser(address _user) external  view returns(bool){\r\n        return users[_user].withdrawEnable;\r\n    }\r\n\r\n     function updateMonthCount(uint256 packageId, address _user, uint256 receivableToken, uint256 remainedMonth) external onlyAllowedContract returns (bool success ) {\r\n        StakingDetail[] storage stakings =  stakingDetails[_user];\r\n        for(uint256 i=0;i<stakings.length;i++){\r\n            if(stakings[i].packageId == packageId){\r\n                uint256 remainedToken = stakings[i].remainingToken;\r\n                stakings[i].monthCount += remainedMonth;   \r\n                remainedToken -= receivableToken;\r\n                stakings[i].remainingToken = remainedToken;\r\n                return true;\r\n            }\r\n        }\r\n     }\r\n\r\n}\r\n// File: contracts/UserService.sol\r\n\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\ncontract UserService {\r\n    UserDataContract public userDataContract;\r\n    IERC20 public usdtToken;\r\n    address public OSTTokenAddress;\r\n    uint256 public minimumWithdrawableLimit=1666*10**18;\r\n    address public owner;\r\n    uint256 public tokenPerUSD = 166666;\r\n    uint256 public percentageDecimals =10000;\r\n    uint8 constant MAX_LEVEL = 12;\r\n    bool public usdtWithdrawEnable= true;\r\n    bool public ostWithdrawEnable= true;\r\n    mapping(address => bool) public disableWithdraw;\r\n\r\n    struct PackageDetailResponse{\r\n        UserDataContract.Package package;\r\n        UserDataContract.StakingDetail stakingDetail;\r\n        uint256 earning;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the owner can perform this operation\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _usdtToken, address _userDbContractAddress,address _OSTToken) {\r\n        owner = msg.sender;\r\n        usdtToken = IERC20(_usdtToken);\r\n        OSTTokenAddress = _OSTToken;\r\n        userDataContract = UserDataContract(_userDbContractAddress);\r\n    }\r\n\r\n    function registerNewUser(\r\n        address userAddress_,\r\n        string memory name_,\r\n        string memory email_,\r\n        string memory mobile_,\r\n        address sponsorAddress_\r\n    ) external returns (bool) {\r\n        userDataContract.registerUser(\r\n            userAddress_,\r\n            name_,\r\n            email_,\r\n            mobile_,\r\n            sponsorAddress_\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function purchasePackage(\r\n        address _subscriberAddress,\r\n        uint256 _feeUsdt,\r\n        uint256 _packageId\r\n    ) external returns (bool) {\r\n        require(\r\n            usdtToken.balanceOf(_subscriberAddress) >= _feeUsdt,\r\n            \"Insufficient Balance\"\r\n        );\r\n        (uint256 maxAmount, uint256 minimumAmount) = userDataContract\r\n            .getPackageRequirement(_packageId);\r\n        require(\r\n            _feeUsdt >= minimumAmount,\r\n            \"Minimum Deposit amount not met\"\r\n        );\r\n        require(\r\n            _feeUsdt <= maxAmount,\r\n            \"Input Amount below Max Amount or select higher package\"\r\n        );\r\n        usdtToken.transferFrom(\r\n            _subscriberAddress,\r\n            address(this),\r\n            _feeUsdt\r\n        );\r\n        uint256 totalOstPurchased = (tokenPerUSD * _feeUsdt) / 10000;\r\n        userDataContract.purchasePackage(\r\n            _packageId,\r\n            _subscriberAddress,\r\n            _feeUsdt,\r\n            totalOstPurchased\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function sumOfAllEarnings(address user_) public view returns (uint256 total_earnings) {\r\n        uint256 totalEarnings=0;\r\n        if(userDataContract.getUserActive(user_) == true){\r\n            totalEarnings = getProfitPerSecond(user_) + calculateNLevelCommision(user_) + getDirectReferralCommision(user_) + userDataContract.getExtraBonus(user_);\r\n        }\r\n        return totalEarnings;\r\n    }\r\n    \r\n    function withdrawProfitAsOST(uint256 amount_) external returns (bool) {\r\n        require(ostWithdrawEnable,\"USDT Withdraw Disabled\");\r\n        require(userDataContract.getUserActive(msg.sender) == true, \"User is not active\");\r\n        require(disableWithdraw[msg.sender]==true,\"Withdraw Is Disabled for this user\");\r\n        require(amount_ >= minimumWithdrawableLimit, \"ERC20: Minimum Withdrawable Limit not met\");\r\n        uint256 withdrawableBalance = sumOfAllEarnings(msg.sender) - userDataContract.getAmountWithdrawn(msg.sender);\r\n        require(amount_ <= withdrawableBalance, \"ERC20: Insufficient Balance\");\r\n\r\n        IERC20(OSTTokenAddress).approve(address(this), amount_);\r\n        IERC20(OSTTokenAddress).transferFrom(address(this), msg.sender, amount_);\r\n        userDataContract.updateWithdrawnBalance(msg.sender, amount_);\r\n        return true;\r\n    }\r\n\r\n    function withdrawProfitAsUSDT(uint256 amount_) external returns (bool) {\r\n        require(usdtWithdrawEnable,\"USDT Withdraw Disabled\");\r\n        require(userDataContract.getUserActive(msg.sender) == true, \"User is not active\");\r\n        require(disableWithdraw[msg.sender]==true,\"Withdraw Is Disabled for this user\");\r\n        require(amount_ >= minimumWithdrawableLimit, \"ERC20: Minimum Withdrawable Limit not met\");\r\n        uint256 withdrawableBalance = sumOfAllEarnings(msg.sender) - userDataContract.getAmountWithdrawn(msg.sender);\r\n        require(amount_ <= withdrawableBalance, \"ERC20: Insufficient Balance\");\r\n        uint256 amountUSDT = (percentageDecimals * amount_) / tokenPerUSD;\r\n        require(usdtToken.approve(address(this), amountUSDT), \"Approval failed\");\r\n        require(usdtToken.transferFrom(address(this), msg.sender, amountUSDT), \"Token transfer failed.\");\r\n        userDataContract.updateWithdrawnBalance(msg.sender, amount_);\r\n        return true;\r\n    }\r\n\r\n    function withdrawTokenFromContract(address tokenAddress,uint256 _amount) public onlyOwner {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(_amount <= balance, \"Insufficient Balance.\");\r\n        require(token.transfer(owner, _amount), \"Token transfer failed.\");\r\n    }\r\n\r\n    function withdrawNativeCurrency(uint256 _amount) external onlyOwner {\r\n        payable(owner).transfer(_amount);\r\n    }\r\n\r\n    function updateMinimumWithdrawableLimit(uint256 _minimumWithdrawableLimit) external onlyOwner{\r\n        minimumWithdrawableLimit = _minimumWithdrawableLimit;\r\n    }\r\n\r\n    function updateTokenPriceUSD(uint256 _price_fourDecimals) external onlyOwner{\r\n        tokenPerUSD = _price_fourDecimals;\r\n    }\r\n\r\n    function updateRegistrationService(address _userRegistrationContractAddress) external onlyOwner returns (bool) {\r\n        userDataContract = UserDataContract(_userRegistrationContractAddress);\r\n        return true;\r\n    }\r\n\r\n    function updateOSTTokenAddress(address _newAddress) external onlyOwner returns (bool) {\r\n        OSTTokenAddress = _newAddress;\r\n        return true;\r\n    }\r\n \r\n\r\n    function getEarningsStatistics(address user_) external view returns (uint256[] memory) {\r\n        uint256[] memory profits = new uint256[](5);\r\n        if(userDataContract.getUserActive(user_) == true){\r\n            profits[0] = getProfitPerSecond(user_);\r\n            profits[1] = calculateNLevelCommision(user_);\r\n            profits[2] = getDirectReferralCommision(user_);\r\n            profits[3] = userDataContract.getExtraBonus(user_);\r\n            profits[4] = userDataContract.getAmountWithdrawn(user_);\r\n        }\r\n        return profits;\r\n    }\r\n\r\n\r\n    //Realtime Profit From All Stake and Amount Withdrawn\r\n    function getProfitPerSecond(address user_)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {   \r\n        uint256 totalProfitPerSecond = 0;\r\n        if(userDataContract.getUserActive(user_) == true){\r\n            UserDataContract.StakingDetail[] memory details = userDataContract.getStakingDetails(user_);\r\n            for (uint256 i = 0; i < details.length; i++) {\r\n                UserDataContract.StakingDetail memory detail = details[i];\r\n                uint256 secondPassed = (block.timestamp - detail.stakingStartDate);\r\n                uint256 perSecondRoi = (detail.roiDaily * detail.investedAmount) / (percentageDecimals * 100 * 86400);\r\n                totalProfitPerSecond += (perSecondRoi * secondPassed);\r\n            }\r\n        }\r\n        return (totalProfitPerSecond);\r\n    }\r\n\r\n    //calculate direct referral commission\r\n    function getDirectReferralCommision(address user_)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {  \r\n        if(userDataContract.getUserActive(user_) == true){\r\n        address[] memory referrals =  userDataContract.getReferrals(user_);\r\n        uint256 directSum =0;\r\n        for(uint256 i=0;i<referrals.length;i++){\r\n          UserDataContract.StakingDetail[] memory detail = userDataContract.getStakingDetails(referrals[i]);\r\n          for(uint256 j=0; j<detail.length; j++){\r\n            directSum += detail[j].investedAmount;\r\n          }\r\n        }\r\n        return (userDataContract.getDirectCommisionPercentage() * directSum)/(percentageDecimals * 100);\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    function getAllStakingWithIncome(address _user) public view returns (PackageDetailResponse[] memory){\r\n        UserDataContract.StakingDetail[] memory details = userDataContract.getStakingDetails(_user);\r\n        PackageDetailResponse[] memory allPackages = new PackageDetailResponse[](details.length);\r\n        for (uint256 i = 0; i < details.length; i++) {\r\n                UserDataContract.StakingDetail memory detail = details[i];\r\n                UserDataContract.Package memory package = userDataContract.getPackageDetail(detail.packageId);\r\n                uint256 secondPassed = (block.timestamp - detail.stakingStartDate);\r\n                uint256 perSecondRoi = (detail.roiDaily * detail.investedAmount) / (percentageDecimals * 100 * 86400);\r\n                if(userDataContract.getUserActive(_user) == true){\r\n                    allPackages[i] = PackageDetailResponse(package,detail,(perSecondRoi * secondPassed));\r\n                }else{\r\n                    allPackages[i] = PackageDetailResponse(package,detail,0);\r\n                }\r\n        }\r\n        return allPackages;\r\n    } \r\n\r\n    //lock for 100 days, 10% each month withdraw limit\r\n    function withdrawCapital(uint256 packageId, address user_) external returns (bool){\r\n        require(userDataContract.getUserActive(user_) == true, \"User is not active\");\r\n        require(user_ != address(0), \"Target address can not be zero address\");\r\n        UserDataContract.StakingDetail[] memory stakings =  userDataContract.getStakingDetails(user_);\r\n        bool success = false;\r\n        for(uint256 i=0;i<stakings.length;i++){\r\n            if(stakings[i].packageId == packageId){\r\n                require(stakings[i].remainingToken != 0, \"All tokens are withdrawn\");\r\n                uint256 OpeningPercentage = userDataContract.getOpeningPercentage(packageId);\r\n                require(\r\n                    block.timestamp > stakings[i].stakingStartDate + (stakings[i].initialLock * 1 days),\r\n                    \"UnLocking period is not opened\"\r\n                );\r\n                uint256 timePassed = block.timestamp -\r\n                    (stakings[i].stakingStartDate + (stakings[i].initialLock * 1 days));\r\n\r\n                uint256 monthNumber = (uint256(timePassed) + (uint256(30 days) - 1)) /\r\n                    uint256(30 days);\r\n                 uint256 installment = uint256(100) / OpeningPercentage;\r\n                if(monthNumber>installment) monthNumber= installment;\r\n\r\n                uint256 remainedMonth = monthNumber - stakings[i].monthCount;\r\n\r\n                if (remainedMonth > installment) remainedMonth = installment;\r\n                require(remainedMonth > 0, \"Releasable token till now is released\");\r\n                uint256 receivableToken = (stakings[i].investedAmount * (remainedMonth * OpeningPercentage)) / 100;\r\n\r\n                updateUser(packageId, user_, receivableToken,remainedMonth);\r\n                success =true;\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function updateUser(uint256 packageId, address _user, uint256 receivableToken, uint256 remainedMonth) internal{\r\n        userDataContract.updateMonthCount(packageId,_user,receivableToken,remainedMonth) ;\r\n    }\r\n\r\n    function calculateNLevelRewards(\r\n        address[] memory referrals,\r\n        uint8 _level, \r\n        uint256 totalBonus \r\n    ) internal view returns (uint256) {\r\n        if (referrals.length == 0 || _level > 12) {\r\n            return totalBonus;\r\n        }\r\n\r\n        if (referrals.length >= userDataContract.getDirectReferralRequirement(_level)) {\r\n            for (uint256 i = 0; i < referrals.length; i++) {\r\n                uint256 profit = getProfitPerSecond(referrals[i]);\r\n                uint256 commission = (userDataContract.getlevelPercentage(_level) * profit) /(percentageDecimals * 100);\r\n                totalBonus += commission;\r\n                address[] memory newReferrals = userDataContract.getReferrals(referrals[i]);\r\n                totalBonus = calculateNLevelRewards(newReferrals, _level + 1, totalBonus);\r\n            }\r\n        }\r\n        return totalBonus;\r\n    }\r\n\r\n    function calculateNLevelCommision(address _user) public view returns (uint256) {\r\n        if(userDataContract.getUserActive(_user) == true){\r\n            address[] memory newreferrals = userDataContract.getReferrals(_user);\r\n            uint256 result = calculateNLevelRewards(newreferrals, 0, 0);\r\n            return result;\r\n        }else{\r\n        return 0;  \r\n        }\r\n    }\r\n\r\n    function updateUsdtWithdrawEnable(bool value) external onlyOwner{\r\n        usdtWithdrawEnable = value;\r\n    }\r\n\r\n    function updateOSTWithdrawEnable(bool value) external onlyOwner{\r\n        ostWithdrawEnable = value;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getContractBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function updateWithdrawStatusOfAUser(address user,bool status) external onlyOwner{\r\n        disableWithdraw[user]=status;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userDbContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_OSTToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OSTTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"calculateNLevelCommision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"disableWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllStakingWithIncome\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiDaily\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openingPercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct UserDataContract.Package\",\"name\":\"package\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investedAmountUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingStartDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiDaily\",\"type\":\"uint256\"}],\"internalType\":\"struct UserDataContract.StakingDetail\",\"name\":\"stakingDetail\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"earning\",\"type\":\"uint256\"}],\"internalType\":\"struct UserService.PackageDetailResponse[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getDirectReferralCommision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getEarningsStatistics\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getProfitPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumWithdrawableLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ostWithdrawEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_subscriberAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_packageId\",\"type\":\"uint256\"}],\"name\":\"purchasePackage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"email_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"mobile_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"sponsorAddress_\",\"type\":\"address\"}],\"name\":\"registerNewUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"sumOfAllEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_earnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumWithdrawableLimit\",\"type\":\"uint256\"}],\"name\":\"updateMinimumWithdrawableLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateOSTTokenAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"updateOSTWithdrawEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userRegistrationContractAddress\",\"type\":\"address\"}],\"name\":\"updateRegistrationService\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price_fourDecimals\",\"type\":\"uint256\"}],\"name\":\"updateTokenPriceUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"updateUsdtWithdrawEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updateWithdrawStatusOfAUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtWithdrawEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userDataContract\",\"outputs\":[{\"internalType\":\"contract UserDataContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"withdrawCapital\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawNativeCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawProfitAsOST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawProfitAsUSDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UserService", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000005f85ec161a8daf65534e2a5ad52a779492e36d4d000000000000000000000000aa5ce9958b77b0751a2b9f8fefb32ed43e02c57e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://252fa3e9190fc954f2adeb2ab732ee4b5ac163b57b65f58cac6043aaaf2a6d8a"}