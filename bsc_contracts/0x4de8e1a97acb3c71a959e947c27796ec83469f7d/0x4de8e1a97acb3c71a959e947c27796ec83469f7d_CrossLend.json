{"SourceCode": "// File: @openzeppelin/contracts/token/ERC777/IERC777.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See {IERC1820Registry} and\r\n * {ERC1820Implementer}.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See {operatorSend} and {operatorBurn}.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor}.\r\n     *\r\n     * Emits an {AuthorizedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Revoke an account's operator status for the caller.\r\n     *\r\n     * See {isOperatorFor} and {defaultOperators}.\r\n     *\r\n     * Emits a {RevokedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if {authorizeOperator} was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/IERC1820Registry.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: crosslend/data.sol\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\nenum FinancialType{CRFI, CFil}\r\n\r\nstruct FinancialPackage {\r\n  FinancialType Type;\r\n  \r\n  uint256 Days;\r\n  uint256 CFilInterestRate;\r\n  uint256 CRFIInterestRateDyn;\r\n  uint256 ID;\r\n\r\n  uint256 Weight;\r\n  uint256 ParamCRFI;\r\n  uint256 ParamCFil;\r\n  uint256 Total;\r\n}\r\n\r\nstruct LoanCFilPackage {\r\n  uint256 APY;\r\n  uint256 PledgeRate;\r\n  uint256 PaymentDue;\r\n  uint256 PaymentDue99;\r\n\r\n  uint256 UpdateTime;\r\n  uint256 Param;\r\n}\r\n\r\nstruct ViewSystemInfo{\r\n  FinancialPackage[] Packages;\r\n  uint256 AffRate;\r\n  uint256 AffRequire;\r\n  uint256 EnableAffCFil;\r\n  \r\n  LoanCFilPackage LoanCFil;\r\n\r\n  ChainManager ChainM;\r\n\r\n  // invest\r\n  uint256 NewInvestID;\r\n  mapping(uint256 => InvestInfo) Invests;\r\n  mapping(address => uint256) InvestAddrID;\r\n        \r\n  // setting power\r\n  address SuperAdmin;\r\n  mapping(address => bool) Admins;\r\n\r\n  // statistic\r\n  uint256 nowInvestCRFI;\r\n  uint256 nowInvestCFil; \r\n  uint256 cfilInterestPool;\r\n  uint256 crfiInterestPool;\r\n\r\n  uint256 cfilLendingTotal;\r\n  uint256 crfiRewardTotal;\r\n  uint256 avaiCFilAmount;\r\n  \r\n  uint256 totalWeightCFil;\r\n  uint256 totalWeightCRFI;\r\n  uint256 crfiMinerPerDayCFil;\r\n  uint256 crfiMinerPerDayCRFI;\r\n  \r\n  uint256 ParamUpdateTime;\r\n}\r\n\r\nstruct SystemInfoView {\r\n  uint256 AffRate;\r\n  uint256 AffRequire;\r\n  uint256 EnableAffCFil;\r\n  \r\n  // invest\r\n  uint256 NewInvestID;\r\n\r\n  // statistic\r\n  uint256 nowInvestCRFI;\r\n  uint256 nowInvestCFil; \r\n  uint256 cfilInterestPool;\r\n  uint256 crfiInterestPool;\r\n\r\n  uint256 cfilLendingTotal;\r\n  uint256 crfiRewardTotal;\r\n  uint256 avaiCFilAmount;\r\n  \r\n  uint256 totalWeightCFil;\r\n  uint256 totalWeightCRFI;\r\n  uint256 crfiMinerPerDayCFil;\r\n  uint256 crfiMinerPerDayCRFI;\r\n  \r\n  uint256 ParamUpdateTime;\r\n}\r\n\r\nstruct SystemInfo {\r\n\r\n  FinancialPackage[] Packages;\r\n  uint256 AffRate;\r\n  uint256 AffRequire;\r\n  uint256 EnableAffCFil;\r\n  \r\n  LoanCFilPackage LoanCFil;\r\n\r\n  ChainManager ChainM;\r\n\r\n  // invest\r\n  uint256 NewInvestID;\r\n  mapping(uint256 => InvestInfo) Invests;\r\n  mapping(address => uint256) InvestAddrID;\r\n        \r\n  // setting power\r\n  address SuperAdmin;\r\n  mapping(address => bool) Admins;\r\n\r\n  // statistic\r\n  uint256 nowInvestCRFI;\r\n  uint256 nowInvestCFil; \r\n  uint256 cfilInterestPool;\r\n  uint256 crfiInterestPool;\r\n\r\n  uint256 cfilLendingTotal;\r\n  uint256 crfiRewardTotal;\r\n  uint256 avaiCFilAmount;\r\n  \r\n  uint256 totalWeightCFil;\r\n  uint256 totalWeightCRFI;\r\n  uint256 crfiMinerPerDayCFil;\r\n  uint256 crfiMinerPerDayCRFI;\r\n  \r\n  uint256 ParamUpdateTime;\r\n\r\n  mapping(string => string) kvMap;\r\n}\r\n\r\nstruct InterestDetail{\r\n  uint256 crfiInterest;\r\n  uint256 cfilInterest;\r\n}\r\n\r\nstruct LoanInvest{\r\n  uint256 Lending;\r\n  uint256 Pledge;\r\n  uint256 Param;\r\n  uint256 NowInterest;\r\n}\r\n\r\nstruct InvestInfoView {\r\n  address Addr;\r\n  uint256 ID;\r\n\r\n  uint256 affID;\r\n\r\n  // statistic for financial\r\n  uint256 totalAffTimes;\r\n  uint256 totalAffPackageTimes;\r\n  \r\n  uint256 totalAffCRFI;\r\n  uint256 totalAffCFil;\r\n  \r\n  uint256 nowInvestFinCRFI;\r\n  uint256 nowInvestFinCFil;\r\n}\r\n\r\nstruct InvestInfo {\r\n  mapping(uint256 => ChainQueue) InvestRecords;\r\n\r\n  address Addr;\r\n  uint256 ID;\r\n\r\n  uint256 affID;\r\n\r\n  LoanInvest LoanCFil;\r\n\r\n  // statistic for financial\r\n  uint256 totalAffTimes;\r\n  uint256 totalAffPackageTimes;\r\n  \r\n  uint256 totalAffCRFI;\r\n  uint256 totalAffCFil;\r\n  \r\n  uint256 nowInvestFinCRFI;\r\n  uint256 nowInvestFinCFil;\r\n}\r\n\r\n\r\n//////////////////// queue\r\n\r\nstruct QueueData {\r\n  uint256 RecordID;\r\n  \r\n  FinancialType Type;\r\n  uint256 PackageID;\r\n  uint256 Days;\r\n  uint256 EndTime;\r\n  uint256 AffID;\r\n  uint256 Amount;\r\n\r\n  uint256 ParamCRFI;\r\n  uint256 ParamCFil;\r\n}\r\n\r\nstruct ChainItem {\r\n  uint256 Next;\r\n  uint256 Prev;\r\n  uint256 My;\r\n  \r\n  QueueData Data;\r\n}\r\n\r\nstruct ChainQueue{\r\n  uint256 First;\r\n  uint256 End;\r\n\r\n  uint256 Size;\r\n}\r\n\r\n\r\nstruct ChainManager{\r\n  ChainItem[] rawQueue;\r\n\r\n  ChainQueue avaiQueue;\r\n}\r\n\r\nlibrary ChainQueueLib{\r\n\r\n  //////////////////// item\r\n  function GetNullItem(ChainManager storage chainM)\r\n    internal\r\n    view\r\n    returns(ChainItem storage item){\r\n    return chainM.rawQueue[0];\r\n  }\r\n\r\n  function HasNext(ChainManager storage chainM,\r\n                   ChainItem storage item)\r\n    internal\r\n    view\r\n    returns(bool has){\r\n\r\n    if(item.Next == 0){\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function Next(ChainManager storage chainM,\r\n                ChainItem storage item)\r\n    internal\r\n    view\r\n    returns(ChainItem storage nextItem){\r\n\r\n    uint256 nextIdx = item.Next;\r\n    require(nextIdx > 0, \"no next item\");\r\n\r\n    return chainM.rawQueue[uint256(nextIdx)];\r\n  }\r\n\r\n  //////////////////// chain\r\n  function GetFirstItem(ChainManager storage chainM,\r\n                        ChainQueue storage chain)\r\n    internal\r\n    view\r\n    returns(ChainItem storage item){\r\n\r\n    require(chain.Size > 0, \"chain is empty\");\r\n\r\n    return chainM.rawQueue[chain.First];\r\n  }\r\n\r\n  function GetEndItem(ChainManager storage chainM,\r\n                      ChainQueue storage chain)\r\n    internal\r\n    view\r\n    returns(ChainItem storage item){\r\n\r\n    require(chain.Size > 0, \"chain is empty\");\r\n\r\n    return chainM.rawQueue[chain.End];\r\n  }\r\n\r\n  // need ensure the item is in chain\r\n  function DeleteItem(ChainManager storage chainM,\r\n                      ChainQueue storage chain,\r\n                      ChainItem storage item)\r\n    internal{\r\n\r\n    if(chain.First == item.My){\r\n      PopPutFirst(chainM, chain);\r\n      return;\r\n    } else if (chain.End == item.My){\r\n      PopPutEnd(chainM, chain);\r\n      return;\r\n    }\r\n\r\n    ChainItem storage next = chainM.rawQueue[item.Next];\r\n    ChainItem storage prev = chainM.rawQueue[item.Prev];\r\n\r\n    next.Prev = item.Prev;\r\n    prev.Next = item.Next;\r\n\r\n    item.Prev = 0;\r\n    item.Next = 0;\r\n\r\n    chain.Size--;\r\n\r\n    PutItem(chainM, item);\r\n  }\r\n\r\n  function PopPutFirst(ChainManager storage chainM,\r\n                       ChainQueue storage chain)\r\n    internal{\r\n\r\n    ChainItem storage item = PopFirstItem(chainM, chain);\r\n    PutItem(chainM, item);\r\n  }\r\n\r\n  function PopPutEnd(ChainManager storage chainM,\r\n                     ChainQueue storage chain)\r\n    internal{\r\n\r\n    ChainItem storage item = PopEndItem(chainM, chain);\r\n    PutItem(chainM, item);\r\n  }\r\n\r\n  function PopEndItem(ChainManager storage chainM,\r\n                        ChainQueue storage chain)\r\n    internal\r\n    returns(ChainItem storage item){\r\n    \r\n    require(chain.Size >0, \"chain is empty\");\r\n    \r\n    uint256 itemIdx = chain.End;\r\n    chain.End = chainM.rawQueue[itemIdx].Prev;\r\n    if(chain.End > 0){\r\n      chainM.rawQueue[chain.End].Next = 0;\r\n    } else {\r\n      chain.First = 0;\r\n    }\r\n    chain.Size--;\r\n    item = chainM.rawQueue[itemIdx];\r\n    item.Prev = 0;\r\n    return item;\r\n  }\r\n\r\n  function PopFirstItem(ChainManager storage chainM,\r\n                        ChainQueue storage chain)\r\n    internal\r\n    returns(ChainItem storage item){\r\n\r\n    require(chain.Size > 0, \"chain is empty\");\r\n\r\n    uint256 itemIdx = chain.First;\r\n    chain.First = chainM.rawQueue[itemIdx].Next;\r\n    if(chain.First > 0){\r\n      chainM.rawQueue[chain.First].Prev = 0;\r\n    } else {\r\n      chain.End = 0;\r\n    }\r\n    chain.Size--;\r\n\r\n    item = chainM.rawQueue[itemIdx];\r\n    item.Next = 0;\r\n\r\n    return item;\r\n  }\r\n\r\n  function PushEndItem(ChainManager storage chainM,\r\n                       ChainQueue storage chain,\r\n                       ChainItem storage item)\r\n    internal{\r\n\r\n    item.Prev = chain.End;\r\n    item.Next = 0;\r\n\r\n    if(chain.Size == 0){\r\n      chain.First = item.My;\r\n      chain.End = item.My;\r\n    } else {\r\n      chainM.rawQueue[chain.End].Next = item.My;\r\n      chain.End = item.My;\r\n    }\r\n    chain.Size++;\r\n  }\r\n\r\n  //////////////////// chain manager\r\n  function InitChainManager(ChainManager storage chainM)\r\n    internal{\r\n    if(chainM.rawQueue.length == 0){\r\n      chainM.rawQueue.push();\r\n    }\r\n  }\r\n  \r\n  function GetAvaiItem(ChainManager storage chainM)\r\n    internal\r\n    returns(ChainItem storage item){\r\n    \r\n    if(chainM.avaiQueue.Size == 0){\r\n      if(chainM.rawQueue.length == 0){\r\n        chainM.rawQueue.push();\r\n      }\r\n      \r\n      uint256 itemIdx = chainM.rawQueue.length;\r\n      chainM.rawQueue.push();\r\n\r\n      item = chainM.rawQueue[itemIdx];\r\n      item.Next = 0;\r\n      item.Prev = 0;\r\n      item.My = itemIdx;\r\n      \r\n      return item;\r\n    }\r\n\r\n    return PopFirstItem(chainM, chainM.avaiQueue);\r\n  }\r\n\r\n  function PutItem(ChainManager storage chainM,\r\n                   ChainItem storage item)\r\n    internal{\r\n    \r\n    PushEndItem(chainM, chainM.avaiQueue, item);\r\n  }\r\n}\r\n\r\n// File: crosslend/main.sol\r\n\r\npragma solidity >=0.7.0 <0.8.0;\r\npragma abicoder v2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CrossLend is IERC777Recipient, ReentrancyGuard{\r\n  //////////////////// for using\r\n  using ChainQueueLib for ChainManager;\r\n  using SafeMath for uint256;\r\n\r\n  //////////////////// constant\r\n  IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n  bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\r\n\r\n  uint256 constant Decimal = 1e18;\r\n\r\n  uint256 public OneDayTime;\r\n\r\n  //////////////////// var\r\n  SystemInfo internal SInfo;\r\n  \r\n  IERC777 public CRFI;\r\n  IERC777 public CFil;\r\n  IERC777 public SFil;\r\n\r\n  //////////////////// modifier\r\n  modifier IsAdmin() {\r\n    require(msg.sender == SInfo.SuperAdmin || SInfo.Admins[msg.sender], \"only admin\");\r\n    _;\r\n  }\r\n\r\n  modifier IsSuperAdmin() {\r\n    require(SInfo.SuperAdmin == msg.sender, \"only super admin\");\r\n    _;\r\n  }\r\n\r\n  //////////////////// event\r\n  event AffEvent(address indexed receiver, address indexed sender, uint256 indexed affTimes, uint256 crfiInterest, uint256 cfilInterest, uint256 packageID, uint256 timestamp);\r\n\r\n  event AffBought(address indexed affer, address indexed sender, uint256 indexed affPackageTimes, uint256 amount, uint256 packageID, uint256 timestamp);\r\n  \r\n  event loanCFilEvent(address indexed addr, uint256 cfilAmount, uint256 sfilAmount);\r\n\r\n  //////////////////// constructor\r\n  constructor(address crfiAddr, address cfilAddr, address sfilAddr) {\r\n    CRFI = IERC777(crfiAddr);\r\n    CFil = IERC777(cfilAddr);\r\n    SFil = IERC777(sfilAddr);\r\n    OneDayTime = 60 * 60 * 24;\r\n\r\n    SInfo.SuperAdmin = msg.sender;\r\n\r\n    SInfo.AffRate = Decimal / 10;\r\n    SInfo.EnableAffCFil = 1;\r\n\r\n    SInfo.ChainM.InitChainManager();\r\n    \r\n    ////////// add package\r\n\r\n    SInfo.crfiMinerPerDayCFil = 1917808 * Decimal / 100;\r\n    SInfo.crfiMinerPerDayCRFI = 821918 * Decimal / 100;\r\n\r\n    SInfo.ParamUpdateTime = block.timestamp;\r\n    \r\n    // loan CFil\r\n    ChangeLoanRate(201 * Decimal / 1000,\r\n                   56 * Decimal / 100,\r\n                   2300 * Decimal);\r\n    SInfo.LoanCFil.UpdateTime = block.timestamp;\r\n\r\n    // add crfi\r\n    AddPackage(FinancialType.CRFI,\r\n               0,\r\n               (20 * Decimal) / 1000,\r\n               Decimal);\r\n    \r\n    AddPackage(FinancialType.CRFI,\r\n               90,\r\n               (32 * Decimal) / 1000,\r\n               (15 * Decimal) / 10);\r\n\r\n    AddPackage(FinancialType.CRFI,\r\n               180,\r\n               (34 * Decimal) / 1000,\r\n               2 * Decimal);\r\n\r\n    AddPackage(FinancialType.CRFI,\r\n               365,\r\n               (36 * Decimal) / 1000,\r\n               (25 * Decimal) / 10);\r\n                   \r\n    AddPackage(FinancialType.CRFI,\r\n               540,\r\n               (40 * Decimal) / 1000,\r\n               3 * Decimal);\r\n    \r\n    // add cfil\r\n    AddPackage(FinancialType.CFil,\r\n               0,\r\n               (20 * Decimal) / 1000,\r\n               Decimal);\r\n    \r\n    AddPackage(FinancialType.CFil,\r\n               90,\r\n               (33 * Decimal) / 1000,\r\n               (15 * Decimal) / 10);\r\n\r\n    AddPackage(FinancialType.CFil,\r\n               180, \r\n               (35 * Decimal) / 1000,\r\n               2 * Decimal);\r\n\r\n    AddPackage(FinancialType.CFil,\r\n               365,\r\n               (37 * Decimal) / 1000,\r\n               (25 * Decimal) / 10);\r\n                   \r\n    AddPackage(FinancialType.CFil,\r\n               540,\r\n               (41 * Decimal) / 1000,\r\n               3 * Decimal);\r\n    \r\n    // register interfaces\r\n    _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\r\n  }\r\n  \r\n  //////////////////// super admin func\r\n  function AddAdmin(address admin)\r\n    public\r\n    IsSuperAdmin(){\r\n    require(!SInfo.Admins[admin], \"already add this admin\");\r\n    SInfo.Admins[admin] = true;\r\n  }\r\n\r\n  function DelAdmin(address admin)\r\n    public\r\n    IsSuperAdmin(){\r\n    require(SInfo.Admins[admin], \"this addr is not admin\");\r\n    SInfo.Admins[admin] = false;\r\n  }\r\n\r\n  function ChangeSuperAdmin(address suAdmin)\r\n    public\r\n    IsSuperAdmin(){\r\n    require(suAdmin != address(0x0), \"empty new super admin\");\r\n\r\n    if(suAdmin == SInfo.SuperAdmin){\r\n      return;\r\n    }\r\n    \r\n    SInfo.SuperAdmin = suAdmin;\r\n  }\r\n\r\n  //////////////////// admin func\r\n  function SetMap(string memory key,\r\n                  string memory value)\r\n    public\r\n    IsAdmin(){\r\n\r\n    SInfo.kvMap[key] = value;\r\n  }\r\n  \r\n  function ChangePackageRate(uint256 packageID,\r\n                             uint256 cfilInterestRate,\r\n                             uint256 weight)\r\n    public\r\n    IsAdmin(){\r\n    \r\n    require(packageID < SInfo.Packages.length, \"packageID error\");\r\n\r\n    updateAllParam();\r\n    \r\n    FinancialPackage storage package = SInfo.Packages[packageID];\r\n    package.CFilInterestRate = cfilInterestRate;\r\n\r\n    uint256 nowTotal = package.Total.mul(package.Weight) / Decimal;\r\n    if(package.Type == FinancialType.CRFI){\r\n      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.sub(nowTotal);\r\n    } else {\r\n      SInfo.totalWeightCFil = SInfo.totalWeightCFil.sub(nowTotal);\r\n    }\r\n\r\n    package.Weight = weight;\r\n\r\n    nowTotal = package.Total.mul(package.Weight) / Decimal;\r\n    if(package.Type == FinancialType.CRFI){\r\n      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.add(nowTotal);\r\n    } else {\r\n      SInfo.totalWeightCFil = SInfo.totalWeightCFil.add(nowTotal);\r\n    }\r\n  }\r\n\r\n  function AddPackage(FinancialType _type,\r\n                      uint256 dayTimes,\r\n                      uint256 cfilInterestRate,\r\n                      uint256 weight)\r\n    public\r\n    IsAdmin(){\r\n\r\n    updateAllParam();\r\n    \r\n    uint256 idx = SInfo.Packages.length;\r\n    SInfo.Packages.push();\r\n    FinancialPackage storage package = SInfo.Packages[idx];\r\n\r\n    package.Type = _type;\r\n    package.Days = dayTimes;\r\n    package.Weight = weight;\r\n    package.CFilInterestRate = cfilInterestRate;\r\n    package.ID = idx;\r\n  }\r\n\r\n  function ChangeCRFIMinerPerDay(uint256 crfi, uint256 cfil)\r\n    public\r\n    IsAdmin(){\r\n\r\n    updateAllParam();\r\n\r\n    SInfo.crfiMinerPerDayCFil = cfil;\r\n    SInfo.crfiMinerPerDayCRFI = crfi;\r\n  }\r\n\r\n  function ChangeLoanRate(uint256 apy, uint256 pledgeRate, uint256 paymentDue)\r\n    public\r\n    IsAdmin(){\r\n\r\n    require(pledgeRate > 0, \"pledge rate can't = 0\");\r\n\r\n    SInfo.LoanCFil.APY = apy;\r\n    SInfo.LoanCFil.PledgeRate = pledgeRate;\r\n    SInfo.LoanCFil.PaymentDue = paymentDue;\r\n    SInfo.LoanCFil.PaymentDue99 = paymentDue.mul(99) / 100;\r\n  }\r\n\r\n  function ChangeAffCFil(bool enable)\r\n    public\r\n    IsAdmin(){\r\n    if(enable && SInfo.EnableAffCFil == 0){\r\n      SInfo.EnableAffCFil = 1;\r\n    } else if(!enable && SInfo.EnableAffCFil > 0){\r\n      SInfo.EnableAffCFil = 0;\r\n    }\r\n  }\r\n\r\n  function ChangeAffRate(uint256 rate)\r\n    public\r\n    IsAdmin(){\r\n    \r\n    SInfo.AffRate = rate;\r\n  }\r\n\r\n  function ChangeAffRequire(uint256 amount)\r\n    public\r\n    IsAdmin(){\r\n    SInfo.AffRequire = amount;\r\n  }\r\n\r\n  function WithdrawCRFIInterestPool(uint256 amount)\r\n    public\r\n    IsAdmin(){\r\n    SInfo.crfiInterestPool = SInfo.crfiInterestPool.sub(amount);\r\n    CRFI.send(msg.sender, amount, \"\");\r\n  }\r\n\r\n  function WithdrawCFilInterestPool(uint256 amount)\r\n    public\r\n    IsAdmin(){\r\n    SInfo.cfilInterestPool = SInfo.cfilInterestPool.sub(amount);\r\n    CFil.send(msg.sender, amount, \"\");\r\n  }\r\n  \r\n  //////////////////// public\r\n  function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData)\r\n    public\r\n    override\r\n    nonReentrant(){\r\n\r\n    ////////// check\r\n    require(userData.length > 0, \"no user data\");\r\n    \r\n    // mode = 0, normal bought financial package\r\n    // mode = 2, charge cfil interest pool\r\n    // mode = 3, charge crfi interest pool\r\n    // mode = 4, loan cfil\r\n    // mode = 5, repay cfil by loan\r\n    (uint256 mode, uint256 param, address addr) = abi.decode(userData, (uint256,uint256, address));\r\n    require(from != address(0x0), \"from is zero\");\r\n\r\n    if(mode == 5){\r\n      _repayLoanCFil(from, amount);\r\n    }else if(mode == 4){\r\n      _loanCFil(from, amount);\r\n    }else if(mode == 3){\r\n      require(amount > 0, \"no amount\");\r\n      require(msg.sender == address(CRFI), \"only charge crfi\");\r\n      SInfo.crfiInterestPool = SInfo.crfiInterestPool.add(amount);\r\n      return;\r\n    }else if(mode == 2){\r\n      require(amount > 0, \"no amount\");\r\n      require(msg.sender == address(CFil), \"only charge cfil\");\r\n      SInfo.cfilInterestPool = SInfo.cfilInterestPool.add(amount);\r\n      \r\n      return;\r\n    } else if (mode == 0){\r\n      _buyFinancialPackage(from, param, addr, amount);\r\n    } else {\r\n      revert(\"mode error\");\r\n    }\r\n  }\r\n  \r\n  function Withdraw(uint256 packageID, bool only, uint256 maxNum)\r\n    public\r\n    nonReentrant(){\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[getUID(msg.sender)];\r\n    \r\n    uint256 cfil;\r\n    uint256 cfilInterest;\r\n    uint256 crfi;\r\n    uint256 crfiInterest;\r\n\r\n    (crfi, crfiInterest, cfil, cfilInterest) = _withdrawFinancial(uInfo, packageID, only, maxNum);\r\n\r\n    if(crfi > 0){\r\n      uInfo.nowInvestFinCRFI = uInfo.nowInvestFinCRFI.sub(crfi);\r\n    }\r\n    if(cfil > 0){\r\n      uInfo.nowInvestFinCFil = uInfo.nowInvestFinCFil.sub(cfil);\r\n    }\r\n\r\n    withdrawCoin(uInfo.Addr, crfi, crfiInterest, cfil, cfilInterest);\r\n  }\r\n\r\n  //////////////////// view func\r\n\r\n  function GetMap(string memory key)\r\n    public\r\n    view\r\n    returns(string memory value){\r\n\r\n    return SInfo.kvMap[key];\r\n  }\r\n\r\n  function GetFinancialPackage()\r\n    public\r\n    view\r\n    returns(FinancialPackage[] memory packages){\r\n\r\n    packages = new FinancialPackage[](SInfo.Packages.length);\r\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\r\n      packages[packageID] = SInfo.Packages[packageID];\r\n      packages[packageID].CRFIInterestRateDyn = getFinancialCRFIRate(SInfo.Packages[packageID]);\r\n    }\r\n    \r\n    return packages;\r\n  }\r\n\r\n  function GetInvesterFinRecords(address addr)\r\n    public\r\n    view\r\n    returns(QueueData[] memory records){\r\n\r\n    uint256 uid = SInfo.InvestAddrID[addr];\r\n    if(uid == 0){\r\n      return records;\r\n    }\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[uid];\r\n\r\n    uint256 recordSize = 0;\r\n\r\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\r\n      ChainQueue storage chain = uInfo.InvestRecords[packageID];\r\n      recordSize = recordSize.add(chain.Size);\r\n    }\r\n\r\n    records = new QueueData[](recordSize);\r\n    uint256 id = 0;\r\n    \r\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\r\n      ChainQueue storage chain = uInfo.InvestRecords[packageID];\r\n      if(chain.Size == 0){\r\n        continue;\r\n      }\r\n\r\n      ChainItem storage item = SInfo.ChainM.GetFirstItem(chain);\r\n      for(;;){\r\n        records[id] = item.Data;\r\n        id++;\r\n\r\n        if(!SInfo.ChainM.HasNext(item)){\r\n          break;\r\n        }\r\n\r\n        item = SInfo.ChainM.Next(item);\r\n      }\r\n    }\r\n    \r\n    return records;\r\n  }\r\n\r\n\r\n  function GetSystemInfo()\r\n    public\r\n    view\r\n    returns(SystemInfoView memory sInfoView){\r\n\r\n    sInfoView.AffRate = SInfo.AffRate;\r\n    sInfoView.AffRequire = SInfo.AffRequire;\r\n    sInfoView.EnableAffCFil = SInfo.EnableAffCFil;\r\n    sInfoView.NewInvestID = SInfo.NewInvestID;\r\n    sInfoView.nowInvestCRFI = SInfo.nowInvestCRFI;\r\n    sInfoView.nowInvestCFil = SInfo.nowInvestCFil;\r\n    sInfoView.cfilInterestPool = SInfo.cfilInterestPool;\r\n    sInfoView.crfiInterestPool = SInfo.crfiInterestPool;\r\n\r\n    sInfoView.cfilLendingTotal = SInfo.cfilLendingTotal;\r\n    sInfoView.crfiRewardTotal = SInfo.crfiRewardTotal;\r\n    sInfoView.avaiCFilAmount = SInfo.avaiCFilAmount;\r\n  \r\n    sInfoView.totalWeightCFil = SInfo.totalWeightCFil;\r\n    sInfoView.totalWeightCRFI = SInfo.totalWeightCRFI;\r\n    sInfoView.crfiMinerPerDayCFil = SInfo.crfiMinerPerDayCFil;\r\n    sInfoView.crfiMinerPerDayCRFI = SInfo.crfiMinerPerDayCRFI;\r\n  \r\n    sInfoView.ParamUpdateTime = SInfo.ParamUpdateTime;\r\n\r\n    return sInfoView;\r\n  }\r\n\r\n  function GetPackages()\r\n    public\r\n    view\r\n    returns(FinancialPackage[] memory financialPackages,\r\n            LoanCFilPackage memory loanCFil){\r\n\r\n    return (GetFinancialPackage(),\r\n            SInfo.LoanCFil);\r\n  }\r\n\r\n\r\n  function GetInvestRecords(address addr)\r\n    public\r\n    view\r\n    returns(QueueData[] memory records,\r\n            LoanInvest memory loanInvest,\r\n            InterestDetail[] memory interestDetail){\r\n\r\n    uint256 uid = SInfo.InvestAddrID[addr];\r\n    if(uid == 0){\r\n      return (records, loanInvest, interestDetail);\r\n    }\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[uid];\r\n\r\n    records = GetInvesterFinRecords(addr);\r\n    interestDetail = new InterestDetail[](records.length+1);\r\n\r\n    uint256 id = 0;\r\n    for(; id < records.length; id++){\r\n      (interestDetail[id].crfiInterest, interestDetail[id].cfilInterest) = _calcInvestFinancial(records[id].PackageID, records[id].Amount, records[id].ParamCRFI, records[id].ParamCFil);\r\n    }\r\n\r\n    interestDetail[id].cfilInterest = calcInvestLoanStatus(uInfo);\r\n    interestDetail[id].cfilInterest = interestDetail[id].cfilInterest.add(uInfo.LoanCFil.NowInterest);\r\n\r\n    return(records,\r\n           uInfo.LoanCFil,\r\n           interestDetail);\r\n  }\r\n\r\n  function GetInvestInfo(uint256 uid, address addr)\r\n    public\r\n    view\r\n    returns(bool admin,\r\n            InvestInfoView memory uInfoView){\r\n    if(uid == 0){\r\n      uid = SInfo.InvestAddrID[addr];\r\n    }\r\n\r\n    if(uid == 0){\r\n      if(addr != address(0x0)){\r\n        admin = (SInfo.SuperAdmin == addr) || (SInfo.Admins[addr]);\r\n      }\r\n      return (admin,\r\n              uInfoView);\r\n    }\r\n    \r\n    InvestInfo storage uInfo = SInfo.Invests[uid];\r\n\r\n    admin = (SInfo.SuperAdmin == uInfo.Addr) || (SInfo.Admins[uInfo.Addr]);\r\n\r\n    uInfoView.Addr = uInfo.Addr;\r\n    uInfoView.ID = uInfo.ID;\r\n    uInfoView.affID = uInfo.affID;\r\n    uInfoView.totalAffTimes = uInfo.totalAffTimes;\r\n    uInfoView.totalAffPackageTimes = uInfo.totalAffPackageTimes;\r\n    uInfoView.totalAffCRFI = uInfo.totalAffCRFI;\r\n    uInfoView.totalAffCFil = uInfo.totalAffCFil;\r\n    uInfoView.nowInvestFinCRFI = uInfo.nowInvestFinCRFI;\r\n    uInfoView.nowInvestFinCFil = uInfo.nowInvestFinCFil;\r\n\r\n    return (admin,\r\n            uInfoView);\r\n  }\r\n\r\n  function calcSFilToCFil(uint256 sfil)\r\n    public\r\n    view\r\n    returns(uint256 cfil){\r\n    cfil = sfil.mul(SInfo.LoanCFil.PledgeRate) / Decimal;\r\n    return cfil;\r\n  }\r\n\r\n  function calcCFilToSFil(uint256 cfil)\r\n    public\r\n    view\r\n    returns(uint256 sfil){\r\n\r\n    sfil = cfil.mul(Decimal) / SInfo.LoanCFil.PledgeRate;\r\n    return sfil;\r\n  }\r\n  \r\n  //////////////////// for debug\r\n\r\n  function getChainMDetail()\r\n    public\r\n    view\r\n    returns(ChainManager memory chaimM){\r\n\r\n    return SInfo.ChainM;\r\n  }\r\n\r\n  function getInvestChainDetail(uint256 id)\r\n    public\r\n    view\r\n    returns(ChainQueue[] memory chains){\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[id];\r\n\r\n    chains = new ChainQueue[](SInfo.Packages.length);\r\n\r\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\r\n      chains[packageID] = uInfo.InvestRecords[packageID];\r\n    }\r\n\r\n    return chains;\r\n  }\r\n  \r\n  //////////////////// internal func\r\n  function _repayLoanCFil(address from,\r\n                          uint256 cfilAmount)\r\n    internal{\r\n    require(cfilAmount > 0, \"no cfil amount\");\r\n    require(msg.sender == address(CFil), \"not cfil coin type\");\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];\r\n    updateInvesterLoanCFil(uInfo);\r\n\r\n    // deal interest\r\n    uint256 repayInterest = cfilAmount;\r\n    if(uInfo.LoanCFil.NowInterest < cfilAmount){\r\n      repayInterest = uInfo.LoanCFil.NowInterest;\r\n    }\r\n\r\n    uInfo.LoanCFil.NowInterest = uInfo.LoanCFil.NowInterest.sub(repayInterest);\r\n    SInfo.cfilInterestPool = SInfo.cfilInterestPool.add(repayInterest);\r\n    cfilAmount = cfilAmount.sub(repayInterest);\r\n\r\n    // deal lending\r\n    if(cfilAmount == 0){\r\n      return;\r\n    }\r\n\r\n    uint256 repayLending = cfilAmount;\r\n    if(uInfo.LoanCFil.Lending < cfilAmount){\r\n      repayLending = uInfo.LoanCFil.Lending;\r\n    }\r\n\r\n    uint256 pledge = repayLending.mul(uInfo.LoanCFil.Pledge) / uInfo.LoanCFil.Lending;\r\n    uInfo.LoanCFil.Lending = uInfo.LoanCFil.Lending.sub(repayLending);\r\n    uInfo.LoanCFil.Pledge = uInfo.LoanCFil.Pledge.sub(pledge);\r\n    SInfo.cfilLendingTotal = SInfo.cfilLendingTotal.sub(repayLending);\r\n    SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.add(repayLending);\r\n    cfilAmount = cfilAmount.sub(repayLending);\r\n\r\n    if(pledge > 0){\r\n      SFil.send(from, pledge, \"\");\r\n    }\r\n    \r\n    if(cfilAmount > 0){\r\n      CFil.send(from, cfilAmount, \"\");\r\n    }\r\n  }\r\n  \r\n  function _loanCFil(address from,\r\n                     uint256 sfilAmount)\r\n    internal{\r\n\r\n    require(sfilAmount > 0, \"no sfil amount\");\r\n    require(msg.sender == address(SFil), \"not sfil coin type\");\r\n\r\n    uint256 cfilAmount = calcSFilToCFil(sfilAmount);\r\n    require(cfilAmount <= SInfo.avaiCFilAmount, \"not enough cfil to loan\");\r\n    require(cfilAmount >= SInfo.LoanCFil.PaymentDue99, \"cfil amount is too small\");\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];\r\n    updateInvesterLoanCFil(uInfo);\r\n    \r\n    if(uInfo.LoanCFil.Param < SInfo.LoanCFil.Param){\r\n      uInfo.LoanCFil.Param = SInfo.LoanCFil.Param;\r\n    }\r\n    uInfo.LoanCFil.Lending = uInfo.LoanCFil.Lending.add(cfilAmount);\r\n    uInfo.LoanCFil.Pledge = uInfo.LoanCFil.Pledge.add(sfilAmount);\r\n\r\n    SInfo.cfilLendingTotal = SInfo.cfilLendingTotal.add(cfilAmount);\r\n    SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.sub(cfilAmount);\r\n\r\n    CFil.send(from, cfilAmount, \"\");\r\n    emit loanCFilEvent(from, cfilAmount, sfilAmount);\r\n  }\r\n  \r\n  function _buyFinancialPackage(address from,\r\n                                uint256 packageID,\r\n                                address affAddr,\r\n                                uint256 amount)\r\n    internal{\r\n    // check\r\n    require(amount > 0, \"no amount\");\r\n    require(packageID < SInfo.Packages.length, \"invalid packageID\");\r\n    FinancialPackage storage package = SInfo.Packages[packageID];\r\n    if(package.Type == FinancialType.CRFI){\r\n      require(msg.sender == address(CRFI), \"not CRFI coin type\");\r\n    }else if(package.Type == FinancialType.CFil){\r\n      require(msg.sender == address(CFil), \"not CFil coin type\");\r\n    } else {\r\n      revert(\"not avai package type\");\r\n    }\r\n\r\n    updateAllParam();\r\n    \r\n    // exec\r\n    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];    \r\n\r\n    uint256 affID = uInfo.affID;\r\n\r\n    if(affID == 0 && affAddr != from && affAddr != address(0x0)){\r\n      uInfo.affID = getUID(affAddr);\r\n      affID = uInfo.affID;\r\n    }\r\n\r\n    if(package.Days == 0){\r\n      affID = 0;\r\n    }\r\n\r\n    if(affID != 0){\r\n      InvestInfo storage affInfo = SInfo.Invests[affID];\r\n      affInfo.totalAffPackageTimes++;      \r\n      emit AffBought(affAddr, from, affInfo.totalAffPackageTimes, amount, packageID, block.timestamp); \r\n    }\r\n\r\n    ChainQueue storage recordQ = uInfo.InvestRecords[package.ID];\r\n\r\n    ChainItem storage item = SInfo.ChainM.GetAvaiItem();\r\n\r\n    item.Data.Type = package.Type;\r\n    item.Data.PackageID = package.ID;\r\n    item.Data.Days = package.Days;\r\n    item.Data.EndTime = block.timestamp.add(package.Days.mul(OneDayTime));\r\n    item.Data.AffID = affID;\r\n    item.Data.Amount = amount;\r\n    item.Data.ParamCRFI = package.ParamCRFI;\r\n    item.Data.ParamCFil = package.ParamCFil;\r\n\r\n    SInfo.ChainM.PushEndItem(recordQ, item);\r\n\r\n    ////////// for statistic\r\n    package.Total = package.Total.add(amount);\r\n    if(package.Type == FinancialType.CRFI){\r\n      uInfo.nowInvestFinCRFI = uInfo.nowInvestFinCRFI.add(amount);\r\n      SInfo.nowInvestCRFI = SInfo.nowInvestCRFI.add(amount);\r\n      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.add(amount.mul(package.Weight) / Decimal);\r\n    } else if(package.Type == FinancialType.CFil){\r\n      uInfo.nowInvestFinCFil = uInfo.nowInvestFinCFil.add(amount);\r\n      SInfo.nowInvestCFil = SInfo.nowInvestCFil.add(amount);\r\n      SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.add(amount);\r\n      SInfo.totalWeightCFil = SInfo.totalWeightCFil.add(amount.mul(package.Weight) / Decimal);\r\n    }\r\n  }\r\n\r\n  function _withdrawFinancial(InvestInfo storage uInfo, uint256 onlyPackageID, bool only, uint256 maxNum)\r\n    internal\r\n    returns(uint256 crfi,\r\n            uint256 crfiInterest,\r\n            uint256 cfil,\r\n            uint256 cfilInterest){\r\n\r\n    updateAllParam();\r\n\r\n    if(!only){\r\n      onlyPackageID = 0;\r\n    }\r\n\r\n    if(maxNum == 0){\r\n      maxNum -= 1;\r\n    }\r\n    \r\n    (uint256 packageID, ChainItem storage item, bool has) = getFirstValidItem(uInfo, onlyPackageID);\r\n    \r\n    while(has && maxNum > 0 && (!only || packageID == onlyPackageID)){\r\n      maxNum--;\r\n      QueueData storage data = item.Data;\r\n      FinancialPackage storage package = SInfo.Packages[data.PackageID];\r\n\r\n      (uint256 _crfiInterest, uint256 _cfilInterest) = calcInvestFinancial(data);\r\n      crfiInterest = crfiInterest.add(_crfiInterest);\r\n      cfilInterest = cfilInterest.add(_cfilInterest);\r\n\r\n      addAffCRFI(uInfo, data, _crfiInterest, _cfilInterest);\r\n\r\n      if((block.timestamp > data.EndTime && data.Days > 0) || (data.Days ==0 && only)){\r\n        package.Total = package.Total.sub(data.Amount);\r\n        if(data.Type == FinancialType.CFil){\r\n          cfil = cfil.add(data.Amount);\r\n          SInfo.totalWeightCFil = SInfo.totalWeightCFil.sub(data.Amount.mul(package.Weight) / Decimal);\r\n        } else {\r\n          crfi = crfi.add(data.Amount);\r\n          SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.sub(data.Amount.mul(package.Weight) / Decimal);\r\n        }\r\n        SInfo.ChainM.PopPutFirst(uInfo.InvestRecords[packageID]);\r\n        (packageID, item, has) = getFirstValidItem(uInfo, packageID);\r\n      } else {\r\n        data.ParamCRFI = package.ParamCRFI;\r\n        data.ParamCFil = package.ParamCFil;\r\n        (packageID, item, has) = getNextItem(uInfo, packageID, item);\r\n      }\r\n    }\r\n\r\n    return (crfi, crfiInterest, cfil, cfilInterest);\r\n  }\r\n        \r\n  function getUID(address addr) internal returns(uint256 uID){\r\n    uID = SInfo.InvestAddrID[addr];\r\n    if(uID != 0){\r\n      return uID;\r\n    }\r\n    \r\n    SInfo.NewInvestID++;\r\n    uID = SInfo.NewInvestID;\r\n\r\n    InvestInfo storage uInfo = SInfo.Invests[uID];\r\n    uInfo.Addr = addr;\r\n    uInfo.ID = uID;\r\n        \r\n    SInfo.InvestAddrID[addr] = uID;\r\n    return uID;\r\n  }\r\n\r\n  function calcSystemLoanStatus()\r\n    internal\r\n    view\r\n    returns(uint256 param){\r\n\r\n    if(block.timestamp == SInfo.LoanCFil.UpdateTime){\r\n      return SInfo.LoanCFil.Param;\r\n    }\r\n\r\n    uint256 diffSec = block.timestamp.sub(SInfo.LoanCFil.UpdateTime);\r\n\r\n    param = SInfo.LoanCFil.Param.add(calcInterest(Decimal, SInfo.LoanCFil.APY, diffSec));\r\n\r\n    return param;\r\n  }\r\n\r\n  function calcInvestLoanStatus(InvestInfo storage uInfo)\r\n    internal\r\n    view\r\n    returns(uint256 cfilInterest){\r\n\r\n    if(uInfo.LoanCFil.Lending == 0){\r\n      return 0;\r\n    }\r\n    \r\n    uint256 param = calcSystemLoanStatus();\r\n    if(uInfo.LoanCFil.Param >= param){\r\n      return 0;\r\n    }\r\n    \r\n    cfilInterest = uInfo.LoanCFil.Lending.mul(param.sub(uInfo.LoanCFil.Param)) / Decimal;\r\n    \r\n    return cfilInterest;\r\n  }\r\n\r\n  function updateSystemLoanStatus()\r\n    internal{\r\n    uint256 param;\r\n    param = calcSystemLoanStatus();\r\n    if(param <= SInfo.LoanCFil.Param){\r\n      return;\r\n    }\r\n\r\n    SInfo.LoanCFil.Param = param;\r\n    SInfo.LoanCFil.UpdateTime = block.timestamp;\r\n  }\r\n\r\n  function updateInvesterLoanCFil(InvestInfo storage uInfo)\r\n    internal{\r\n    updateSystemLoanStatus();\r\n    uint256 cfilInterest = calcInvestLoanStatus(uInfo);\r\n    if(cfilInterest == 0){\r\n      return;\r\n    }\r\n\r\n    uInfo.LoanCFil.Param = SInfo.LoanCFil.Param;\r\n    uInfo.LoanCFil.NowInterest = uInfo.LoanCFil.NowInterest.add(cfilInterest);\r\n  }\r\n\r\n  function calcInterest(uint256 amount, uint256 rate, uint256 sec)\r\n    internal\r\n    view\r\n    returns(uint256){\r\n    \r\n    return amount.mul(rate).mul(sec) / 365 / OneDayTime / Decimal;    \r\n  }\r\n\r\n  function getFirstValidItem(InvestInfo storage uInfo, uint256 packageID)\r\n    internal\r\n    view\r\n    returns(uint256 newPackageID, ChainItem storage item, bool has){\r\n    \r\n    while(packageID < SInfo.Packages.length){\r\n      ChainQueue storage chain = uInfo.InvestRecords[packageID];\r\n      if(chain.Size == 0){\r\n        packageID++;\r\n        continue;\r\n      }\r\n      item = SInfo.ChainM.GetFirstItem(chain);\r\n      return (packageID, item, true);\r\n    }\r\n\r\n    return (0, SInfo.ChainM.GetNullItem(), false);\r\n  }\r\n\r\n  function getNextItem(InvestInfo storage uInfo,\r\n                       uint256 packageID,\r\n                       ChainItem storage item)\r\n    internal\r\n    view\r\n    returns(uint256, ChainItem storage, bool){\r\n\r\n    if(packageID >= SInfo.Packages.length){\r\n      return (0, item, false);\r\n    }\r\n\r\n    if(SInfo.ChainM.HasNext(item)){\r\n      return (packageID, SInfo.ChainM.Next(item), true);\r\n    }\r\n\r\n    return getFirstValidItem(uInfo, packageID+1);\r\n  }\r\n\r\n  function addAffCRFI(InvestInfo storage uInfo, QueueData storage data, uint256 crfiInterest, uint256 cfilInterest)\r\n    internal{\r\n    if(data.Days == 0){\r\n      return;\r\n    }\r\n    \r\n    uint256 affID = data.AffID;\r\n    if(affID == 0){\r\n      return;\r\n    }\r\n    InvestInfo storage affInfo = SInfo.Invests[affID];\r\n    if(affInfo.nowInvestFinCFil < SInfo.AffRequire){\r\n      return;\r\n    }\r\n    \r\n    uint256 affCRFI = crfiInterest.mul(SInfo.AffRate) / Decimal;\r\n    uint256 affCFil;\r\n\r\n    bool emitFlag;\r\n    if(affCRFI != 0){\r\n      emitFlag = true;\r\n      affInfo.totalAffCRFI = affInfo.totalAffCRFI.add(affCRFI);\r\n    }\r\n\r\n    if(SInfo.EnableAffCFil > 0){\r\n      affCFil = cfilInterest.mul(SInfo.AffRate) / Decimal;\r\n      if(affCFil != 0){\r\n        emitFlag = true;\r\n        affInfo.totalAffCFil = affInfo.totalAffCFil.add(affCFil);\r\n      }\r\n    }\r\n\r\n    if(!emitFlag){\r\n      return;\r\n    }\r\n    \r\n    affInfo.totalAffTimes++;\r\n    emit AffEvent(affInfo.Addr, uInfo.Addr, affInfo.totalAffTimes, affCRFI, affCFil, data.PackageID, block.timestamp);\r\n\r\n    withdrawCoin(affInfo.Addr, 0, affCRFI, 0, affCFil);\r\n\r\n  }\r\n\r\n  function withdrawCoin(address addr,\r\n                        uint256 crfi,\r\n                        uint256 crfiInterest,\r\n                        uint256 cfil,\r\n                        uint256 cfilInterest)\r\n    internal{\r\n    \r\n    require(cfil <= SInfo.nowInvestCFil, \"cfil invest now error\");\r\n    require(cfil <= SInfo.avaiCFilAmount, \"not enough cfil to withdraw\");    \r\n    require(crfi <= SInfo.nowInvestCRFI, \"crfi invest now error\");\r\n    \r\n    if(cfil > 0){\r\n      SInfo.nowInvestCFil = SInfo.nowInvestCFil.sub(cfil);\r\n      SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.sub(cfil);\r\n    }\r\n\r\n    if(crfi > 0){\r\n      SInfo.nowInvestCRFI = SInfo.nowInvestCRFI.sub(crfi);\r\n    }\r\n    \r\n    if(cfilInterest > 0){\r\n      require(SInfo.cfilInterestPool >= cfilInterest, \"cfil interest pool is not enough\");\r\n      SInfo.cfilInterestPool = SInfo.cfilInterestPool.sub(cfilInterest);\r\n      cfil = cfil.add(cfilInterest);\r\n    }\r\n\r\n    if(crfiInterest > 0){\r\n      require(SInfo.crfiInterestPool >= crfiInterest, \"crfi interest pool is not enough\");\r\n      SInfo.crfiInterestPool = SInfo.crfiInterestPool.sub(crfiInterest);\r\n      crfi = crfi.add(crfiInterest);\r\n      SInfo.crfiRewardTotal = SInfo.crfiRewardTotal.add(crfiInterest);\r\n    }\r\n\r\n    if(cfil > 0){\r\n      CFil.send(addr, cfil, \"\");\r\n    }\r\n\r\n    if(crfi > 0){\r\n      CRFI.send(addr, crfi, \"\");\r\n    }\r\n  }\r\n\r\n  //////////////////// for update param\r\n  \r\n  function getFinancialCRFIRate(FinancialPackage storage package)\r\n    internal\r\n    view\r\n    returns(uint256 rate){\r\n    if(package.Total == 0){\r\n      return 0;\r\n    }\r\n    \r\n    uint256 x = package.Total.mul(package.Weight);\r\n    if(package.Type == FinancialType.CRFI){\r\n      if(SInfo.totalWeightCRFI == 0){\r\n        return 0;\r\n      }\r\n      rate = x.mul(SInfo.crfiMinerPerDayCRFI) / SInfo.totalWeightCRFI;\r\n    } else {\r\n      if(SInfo.totalWeightCFil == 0){\r\n        return 0;\r\n      }\r\n      rate = x.mul(SInfo.crfiMinerPerDayCFil) / SInfo.totalWeightCFil;\r\n    }\r\n\r\n    rate = rate.mul(365) / package.Total ;\r\n    \r\n    return rate;\r\n  }\r\n\r\n  function calcFinancialParam(FinancialPackage storage package)\r\n    internal\r\n    view\r\n    returns(uint256 paramCRFI,\r\n            uint256 paramCFil){\r\n\r\n    uint256 diffSec = block.timestamp.sub(SInfo.ParamUpdateTime);\r\n    if(diffSec == 0){\r\n      return (package.ParamCRFI, package.ParamCFil);\r\n    }\r\n\r\n    paramCFil = package.ParamCFil.add(calcInterest(Decimal, package.CFilInterestRate, diffSec));\r\n    paramCRFI = package.ParamCRFI.add(calcInterest(Decimal,\r\n                                                   getFinancialCRFIRate(package),\r\n                                                   diffSec));\r\n    return (paramCRFI, paramCFil);\r\n  }\r\n\r\n  function updateFinancialParam(FinancialPackage storage package)\r\n    internal{\r\n\r\n    (package.ParamCRFI, package.ParamCFil) = calcFinancialParam(package);\r\n  }\r\n\r\n  function updateAllParam()\r\n    internal{\r\n    if(block.timestamp == SInfo.ParamUpdateTime){\r\n      return;\r\n    }\r\n\r\n    for(uint256 i = 0; i < SInfo.Packages.length; i++){\r\n      updateFinancialParam(SInfo.Packages[i]);\r\n    }\r\n\r\n    SInfo.ParamUpdateTime = block.timestamp;\r\n  }\r\n\r\n  function _calcInvestFinancial(uint256 packageID, uint256 amount, uint256 paramCRFI, uint256 paramCFil)\r\n    internal\r\n    view\r\n    returns(uint256 crfiInterest, uint256 cfilInterest){\r\n    \r\n    FinancialPackage storage package = SInfo.Packages[packageID];\r\n\r\n    (uint256 packageParamCRFI, uint256 packageParamCFil) = calcFinancialParam(package);\r\n    crfiInterest = amount.mul(packageParamCRFI.sub(paramCRFI)) / Decimal;\r\n    cfilInterest = amount.mul(packageParamCFil.sub(paramCFil)) / Decimal;\r\n\r\n    return(crfiInterest, cfilInterest);\r\n  }\r\n\r\n  function calcInvestFinancial(QueueData storage data)\r\n    internal\r\n    view\r\n    returns(uint256 crfiInterest, uint256 cfilInterest){\r\n    return _calcInvestFinancial(data.PackageID, data.Amount, data.ParamCRFI, data.ParamCFil);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crfiAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cfilAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sfilAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"affPackageTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AffBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"affTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"crfiInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cfilInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AffEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cfilAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sfilAmount\",\"type\":\"uint256\"}],\"name\":\"loanCFilEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FinancialType\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dayTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cfilInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"AddPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CFil\",\"outputs\":[{\"internalType\":\"contract IERC777\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CRFI\",\"outputs\":[{\"internalType\":\"contract IERC777\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"ChangeAffCFil\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"ChangeAffRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChangeAffRequire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"crfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cfil\",\"type\":\"uint256\"}],\"name\":\"ChangeCRFIMinerPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pledgeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentDue\",\"type\":\"uint256\"}],\"name\":\"ChangeLoanRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cfilInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"ChangePackageRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"suAdmin\",\"type\":\"address\"}],\"name\":\"ChangeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DelAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetFinancialPackage\",\"outputs\":[{\"components\":[{\"internalType\":\"enum FinancialType\",\"name\":\"Type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"Days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CFilInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CRFIInterestRateDyn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Total\",\"type\":\"uint256\"}],\"internalType\":\"struct FinancialPackage[]\",\"name\":\"packages\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GetInvestInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"admin\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"Addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAffTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAffPackageTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAffCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAffCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowInvestFinCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowInvestFinCFil\",\"type\":\"uint256\"}],\"internalType\":\"struct InvestInfoView\",\"name\":\"uInfoView\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GetInvestRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"RecordID\",\"type\":\"uint256\"},{\"internalType\":\"enum FinancialType\",\"name\":\"Type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"PackageID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AffID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCFil\",\"type\":\"uint256\"}],\"internalType\":\"struct QueueData[]\",\"name\":\"records\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Lending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Pledge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Param\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NowInterest\",\"type\":\"uint256\"}],\"internalType\":\"struct LoanInvest\",\"name\":\"loanInvest\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"crfiInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cfilInterest\",\"type\":\"uint256\"}],\"internalType\":\"struct InterestDetail[]\",\"name\":\"interestDetail\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GetInvesterFinRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"RecordID\",\"type\":\"uint256\"},{\"internalType\":\"enum FinancialType\",\"name\":\"Type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"PackageID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AffID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCFil\",\"type\":\"uint256\"}],\"internalType\":\"struct QueueData[]\",\"name\":\"records\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"GetMap\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetPackages\",\"outputs\":[{\"components\":[{\"internalType\":\"enum FinancialType\",\"name\":\"Type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"Days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CFilInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CRFIInterestRateDyn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Total\",\"type\":\"uint256\"}],\"internalType\":\"struct FinancialPackage[]\",\"name\":\"financialPackages\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PledgeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PaymentDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PaymentDue99\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"UpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Param\",\"type\":\"uint256\"}],\"internalType\":\"struct LoanCFilPackage\",\"name\":\"loanCFil\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetSystemInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"AffRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AffRequire\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EnableAffCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NewInvestID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowInvestCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowInvestCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cfilInterestPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crfiInterestPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cfilLendingTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crfiRewardTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avaiCFilAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeightCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeightCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crfiMinerPerDayCFil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crfiMinerPerDayCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamUpdateTime\",\"type\":\"uint256\"}],\"internalType\":\"struct SystemInfoView\",\"name\":\"sInfoView\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OneDayTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SFil\",\"outputs\":[{\"internalType\":\"contract IERC777\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"SetMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"only\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxNum\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawCFilInterestPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawCRFIInterestPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cfil\",\"type\":\"uint256\"}],\"name\":\"calcCFilToSFil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sfil\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sfil\",\"type\":\"uint256\"}],\"name\":\"calcSFilToCFil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cfil\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainMDetail\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Next\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Prev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"My\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"RecordID\",\"type\":\"uint256\"},{\"internalType\":\"enum FinancialType\",\"name\":\"Type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"PackageID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AffID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ParamCFil\",\"type\":\"uint256\"}],\"internalType\":\"struct QueueData\",\"name\":\"Data\",\"type\":\"tuple\"}],\"internalType\":\"struct ChainItem[]\",\"name\":\"rawQueue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"First\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"End\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Size\",\"type\":\"uint256\"}],\"internalType\":\"struct ChainQueue\",\"name\":\"avaiQueue\",\"type\":\"tuple\"}],\"internalType\":\"struct ChainManager\",\"name\":\"chaimM\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getInvestChainDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"First\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"End\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Size\",\"type\":\"uint256\"}],\"internalType\":\"struct ChainQueue[]\",\"name\":\"chains\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CrossLend", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ae20bc46300bab5d85612c6bc6ea87ea0f1860350000000000000000000000004eab1d37213b08c224e4c9c28efba23dc493dfd200000000000000000000000086ef562a68e1eb7e3cec2de9b7a752a231bf3cff", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e41164bdf8c9a4db6120b097c47392ab0b27dfdcd74414380c0b5555653ad6a9"}