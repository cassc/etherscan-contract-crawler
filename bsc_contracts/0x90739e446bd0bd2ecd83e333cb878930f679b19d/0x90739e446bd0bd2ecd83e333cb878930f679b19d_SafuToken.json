{"SourceCode": "/* *******************************************************************************************************************************************************************************\n*\n* Powered By t.me/BlazeXDeployerBot - This Contract is safe has no hidden malfunctions - Create your own Contract via telegram with blazex.org \n*\n* Disclaimer: The @BlazeXDeployerBot tool assists users in contract deployment. Tokens or contracts initiated through this bot are solely under the user's responsibility and are  * not linked to, endorsed by, or associated with the BlazeX Team. Users are urged to approach with caution and comprehend the outcomes of their deployments. The contract has been * reviewed and audited.\n* TG BOT: t.me/BlazeXdeployerBot\n*********************************************************************************************************************************************************************************\n*/\n\n\n  /*\n * \n  *\n  *\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  *\n  * Description: Welcome to Dragon Infinity - where you can enjoy games and earn profits from NFTs.\n  * Website: https://dragoninfinity.app\n  * Twitter: https://x.com/dragoninfinity_?s=21&t=mxdT1yCJrBlKn4enFjrrWA\n  * Telegram: https://t.me/dragonInfinity_Channel\n  *\n  *\u2014\u2014\u2014\u2014\u2014\n  */\n  \n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n  \n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n   \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal returns(bool){\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        return success;\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUNCX {\n    function lockLPToken(address _lpToken, uint256 _amount, uint256 _unlock_date, address _referral, bool _fee_in_eth, address _withdrawer, uint16 _countryCode) external payable;\n\n    function gFees() external view returns(uint256);\n}\n\ninterface ITeamLocker {\n    function lockToken(address _tokenAddress, address _withdrawalAddress, uint256 _amount, uint256 _unlockTime, bool _mintNFT, address referrer) external payable;\n\n    function getFeesInETH(address _tokenAddress) external view returns(uint256);\n}\n\ncontract SafuToken is Context, IERC20 {\n    using Address for address;\n    using Address for address payable;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcludedFromFees;\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n\n    string private _name=\"Dragon Infinity Token\";\n    string private _symbol=\"DRIN\";\n    uint8  private _decimals=18;\n   \n    uint256 private constant MAX = type(uint256).max;\n    uint256 private _tTotal = 1000000000000000000000000000;\n    uint256 private _tTotalSupply = 1000000000000000000000000000;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    uint private ReflectionFeeonBuy;\n    uint private ReflectionFeeonSell;\n\n    uint private liquidityFeeonBuy;\n    uint private liquidityFeeonSell;\n\n    uint public marketingFeeonBuy=20;\n    uint public marketingFeeonSell=20;\n\n    uint private burnFeeOnBuy;\n    uint private burnFeeOnSell;\n\n    bool public tradingEnabled = true;\n\n    uint private _ReflectionFee;\n    uint private _liquidityFee;\n    uint private _marketingFee;\n\n    uint256 private totalBuyFees;\n    uint256 private totalSellFees;\n\n    address public marketingWallet=0x718BE3FC41bc63F62172b971EBa830F0A803a3A3;\n\n    uint256 public maxTransactionAmountBuy=40000000000000000000000000;\n    uint256 public maxTransactionAmountSell=40000000000000000000000000;\n\n    \n    uint256 public maxWalletAmount=40000000000000000000000000;\n\n    bool public walletToWalletTransferWithoutFee;\n\n    address private deployer;\n    \n    address private DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    IUniswapV2Router02 public  uniswapV2Router;\n    address public  uniswapV2Pair;\n\n    bool private inSwapAndLiquify;\n    bool public swapEnabled;\n    uint256 public swapTokensAtAmount=50000000000000000000000;\n\n    address public owner = address(0);\n\n    address public referralWallet;\n    uint256 public serviceFee;\n    uint256 public referralCommission;\n\n    address public lpPair;\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event MarketingWalletChanged(address marketingWallet);\n    event SwapEnabledUpdated(bool enabled);\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);\n    event SwapAndSendMarketing(uint256 tokensSwapped, uint256 bnbSend);\n    event SwapTokensAtAmountUpdated(uint256 amount);\n    event BuyFeesChanged(uint256 ReflectionFee, uint256 liquidityFee, uint256 marketingFee);\n    event SellFeesChanged(uint256 ReflectionFee, uint256 liquidityFee, uint256 marketingFee);\n    event WalletToWalletTransferWithoutFeeEnabled(bool enabled);\n    \n    constructor() \n        payable\n    {        \n        address router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    require(msg.value >= 0.3 ether, \"Insufficient value for fee receiver\");\n    \n    \n    serviceFee = 0.29999999999999999 ether;\n    payable(0x72460072CCC5DB06559dd6e970dFD2Cb06ee7876).transfer(serviceFee);\n    \n    \n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);\n        \n        uniswapV2Router = _uniswapV2Router;        \n\n        _approve(address(this), address(uniswapV2Router), MAX);\n        _approve(msg.sender, address(uniswapV2Router), MAX);\n\n        totalBuyFees = ReflectionFeeonBuy + liquidityFeeonBuy + marketingFeeonBuy + burnFeeOnBuy;\n        totalSellFees = ReflectionFeeonSell + liquidityFeeonSell + marketingFeeonSell + burnFeeOnSell;\n        \n        \n        swapTokensAtAmount = _tTotal / 5000;\n\n        maxTransactionLimitEnabled  = true;\n\n        _isExcludedFromMaxTxLimit[msg.sender] = true;\n        _isExcludedFromMaxTxLimit[address(0)] = true;\n        _isExcludedFromMaxTxLimit[address(this)] = true;\n        _isExcludedFromMaxTxLimit[marketingWallet] = true;\n        _isExcludedFromMaxTxLimit[DEAD] = true;\n\n        maxWalletLimitEnabled = true;\n\n        _isExcludedFromMaxWalletLimit[msg.sender] = true;\n        _isExcludedFromMaxWalletLimit[address(this)] = true;\n        _isExcludedFromMaxWalletLimit[address(0xdead)] = true;\n        _isExcludedFromMaxWalletLimit[marketingWallet] = true;\n            \n        walletToWalletTransferWithoutFee = true;\n        \n        _isExcludedFromFees[msg.sender] = true;\n        _isExcludedFromFees[address(0xdead)] = true;\n        _isExcludedFromFees[address(this)] = true;\n\n        _isExcluded[address(this)] = true;\n        _isExcluded[address(0xdead)] = true;\n        \n        _rOwned[address(this)] = _rTotal;\n        _tOwned[address(this)] = _tTotal;\n        deployer = address(msg.sender);\n\n        emit Transfer(address(0), address(this), _tTotal);\n\n    }\n\t\n\tfunction createLPPairIfRequired() private {\n        IUniswapV2Factory factory = IUniswapV2Factory(uniswapV2Router.factory());\n        address pair = factory.getPair(address(this), uniswapV2Router.WETH());\n\t\tif(pair == address(0)) {\n\t\t\tuniswapV2Pair = factory.createPair(address(this), uniswapV2Router.WETH());\n\t\t\tlpPair = uniswapV2Pair;\n\t\t\t_isExcluded[address(uniswapV2Pair)] = true;\n\t\t}\n        else {\n            if(uniswapV2Pair != pair){\n                uniswapV2Pair = pair;\n                lpPair = uniswapV2Pair;\n                _isExcluded[address(uniswapV2Pair)] = true;\n            }\n        }\n\t}\n\t\n\n\n    function addLiquidityToZero() public payable returns(bool) {\n        require(address(msg.sender) == deployer, \"Only deployer can call this function\");\n\t\tcreateLPPairIfRequired();\n        uniswapV2Router.addLiquidityETH{value: msg.value}(address(this), balanceOf(address(this)), 0, 0, address(0xdead), block.timestamp + 50);\n        swapEnabled = true;\n        return true;\n    }\n\n    function lockOnUNCX(address _uncxAddress, uint256 _lockToTime, address referralAddress) public payable returns(bool) {\n        require(address(msg.sender) == deployer, \"Only deployer can call this function\");\n\t\tcreateLPPairIfRequired();\n        _isExcluded[_uncxAddress] = true;\n        _isExcludedFromMaxWalletLimit[_uncxAddress] = true;\n        _isExcludedFromFees[_uncxAddress] = true;\n        IUNCX locker = IUNCX(_uncxAddress);\n\n        uint256 fee = locker.gFees();\n        uniswapV2Router.addLiquidityETH{value: msg.value - fee }(address(this), balanceOf(address(this)), 0, 0, address(this), block.timestamp + 300);\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\n        pair.approve(_uncxAddress, pair.balanceOf(address(this)));\n        bytes memory data;\n        if(block.chainid == 5){\n            data = abi.encodeWithSelector(bytes4(keccak256(\"lockLPToken(address,uint256,uint256,address,bool,address,uint16)\")), uniswapV2Pair, pair.balanceOf(address(this)), block.timestamp + _lockToTime, referralAddress, true, deployer, uint16(1));\n        }\n        else {\n            data = abi.encodeWithSelector(bytes4(keccak256(\"lockLPToken(address,uint256,uint256,address,bool,address)\")), uniswapV2Pair, pair.balanceOf(address(this)), block.timestamp + _lockToTime, referralAddress, true, deployer);\n        }\n        (bool success, ) = payable(_uncxAddress).call{value: fee}(data);\n        require(success, \"Add Liquidity to UNCX failed\");\n        swapEnabled = true;\n        return true;\n    }\n\n    function lockOnTeam(address _teamAddress, uint256 _lockToTime, address referralAddress) public payable returns(bool) {\n        require(address(msg.sender) == deployer, \"Only deployer can call this function\");\n\t\tcreateLPPairIfRequired();\n        _isExcluded[_teamAddress] = true;\n        _isExcludedFromMaxWalletLimit[_teamAddress] = true;\n        _isExcludedFromFees[_teamAddress] = true;\n        ITeamLocker locker = ITeamLocker(_teamAddress);\n        uint256 fee = locker.getFeesInETH(uniswapV2Pair);\n        uniswapV2Router.addLiquidityETH{value: msg.value - fee}(address(this), balanceOf(address(this)), 0, 0, address(this), block.timestamp + 300);\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\n        pair.approve(_teamAddress, MAX);\n        locker.lockToken{value: fee}(uniswapV2Pair, deployer, pair.balanceOf(address(this)), block.timestamp + _lockToTime, false, referralAddress);\n        swapEnabled = true;\n        return true;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address _owner, address spender) public view override returns (uint256) {\n        return _allowances[_owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalReflectionDistributed() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rTotal = _rTotal - rAmount;\n        _tFeeTotal = _tFeeTotal + tAmount;\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount / currentRate;\n    }\n\n\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal - rFee;\n        _tFeeTotal = _tFeeTotal + tFee;\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tMarketing, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity, tMarketing);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\n        uint256 tFee = calculateReflectionFee(tAmount);\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\n        uint256 tMarketing = calculateMarketingFee(tAmount);\n        uint256 tTransferAmount = tAmount - tFee - tLiquidity - tMarketing;\n        return (tTransferAmount, tFee, tLiquidity, tMarketing);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount * currentRate;\n        uint256 rFee = tFee * currentRate;\n        uint256 rLiquidity = tLiquidity * currentRate;\n        uint256 rMarketing = tMarketing * currentRate;\n        uint256 rTransferAmount = rAmount - rFee - rLiquidity - rMarketing;\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply - _rOwned[_excluded[i]];\n            tSupply = tSupply - _tOwned[_excluded[i]];\n        }\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n    \n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 liquidityAmount;\n        if(liquidityFeeonBuy > 0 || liquidityFeeonSell > 0 || burnFeeOnBuy > 0 || burnFeeOnSell > 0){\n            liquidityAmount = tLiquidity * (liquidityFeeonBuy + liquidityFeeonSell) / (liquidityFeeonBuy + liquidityFeeonSell + burnFeeOnBuy + burnFeeOnSell);\n        }\n        uint256 burnAmount = tLiquidity - liquidityAmount;\n\n        if(liquidityAmount > 0){\n            uint256 currentRate =  _getRate();\n            uint256 rLiquidity = liquidityAmount * currentRate;\n            _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;\n            if(_isExcluded[address(this)])\n                _tOwned[address(this)] = _tOwned[address(this)] + liquidityAmount;\n        }\n\n        if(burnAmount > 0){\n            uint256 currentRate =  _getRate();\n            uint256 rBurn = burnAmount * currentRate;\n            _rOwned[address(0xdead)] = _rOwned[address(0xdead)] + rBurn;\n            if(_isExcluded[address(0xdead)])\n                _tOwned[address(0xdead)] = _tOwned[address(0xdead)] + burnAmount;\n\n            _tTotalSupply -= burnAmount;\n        }\n    }\n\n    function _takeMarketing(uint256 tMarketing) private {\n        if (tMarketing > 0) {\n            uint256 currentRate =  _getRate();\n            uint256 rMarketing = tMarketing * currentRate;\n            _rOwned[address(this)] = _rOwned[address(this)] + rMarketing;\n            if(_isExcluded[address(this)])\n                _tOwned[address(this)] = _tOwned[address(this)] + tMarketing;\n        }\n    }\n    \n    function calculateReflectionFee(uint256 _amount) private view returns (uint256) {\n        return _amount * _ReflectionFee / 1000;\n    }\n\n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n        return _amount * _liquidityFee / 1000;\n    }\n    \n    function calculateMarketingFee(uint256 _amount) private view returns (uint256) {\n        return _amount * _marketingFee / 1000;\n    }\n    \n    function removeAllFee() private {\n        if(_ReflectionFee == 0 && _liquidityFee == 0 && _marketingFee == 0) return;\n        \n        _ReflectionFee = 0;\n        _marketingFee = 0;\n        _liquidityFee = 0;\n    }\n    \n    function setBuyFee() private{\n        if(_ReflectionFee == ReflectionFeeonBuy && _liquidityFee == (liquidityFeeonBuy + burnFeeOnBuy) && _marketingFee == marketingFeeonBuy ) return;\n\n        _ReflectionFee = ReflectionFeeonBuy;\n        _marketingFee = marketingFeeonBuy;\n        _liquidityFee = liquidityFeeonBuy + burnFeeOnBuy;\n    }\n\n    function setSellFee() private{\n        if(_ReflectionFee == ReflectionFeeonSell && _liquidityFee == (liquidityFeeonSell + burnFeeOnSell) && _marketingFee == marketingFeeonSell ) return;\n\n        _ReflectionFee = ReflectionFeeonSell;\n        _marketingFee = marketingFeeonSell;\n        _liquidityFee = liquidityFeeonSell + burnFeeOnSell;\n    }\n    \n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    function _approve(address _owner, address spender, uint256 amount) private {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n    \n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (maxTransactionLimitEnabled) \n        {\n            if ((from == uniswapV2Pair || to == uniswapV2Pair) &&\n                _isExcludedFromMaxTxLimit[from] == false && \n                _isExcludedFromMaxTxLimit[to]   == false) \n            {\n                if (from == uniswapV2Pair) {\n                    require(\n                        amount <= maxTransactionAmountBuy,  \n                        \"AntiWhale: Transfer amount exceeds the maxTransactionAmount\"\n                    );\n                } else {\n                    require(\n                        amount <= maxTransactionAmountSell, \n                        \"AntiWhale: Transfer amount exceeds the maxTransactionAmount\"\n                    );\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));        \n        bool overMinTokenBalance = contractTokenBalance >= swapTokensAtAmount;\n        if (\n            overMinTokenBalance &&\n            !inSwapAndLiquify &&\n            to == uniswapV2Pair &&\n            swapEnabled\n        ) {\n            inSwapAndLiquify = true;\n            \n            uint256 marketingShare = marketingFeeonBuy + marketingFeeonSell;\n            uint256 liquidityShare = liquidityFeeonBuy + liquidityFeeonSell;\n\n            uint256 totalShare = marketingShare + liquidityShare;\n\n            if(totalShare > 0) {\n                if(liquidityShare > 0) {\n                    uint256 liquidityTokens = (contractTokenBalance * liquidityShare) / totalShare;\n                    swapAndLiquify(liquidityTokens);\n                }\n                \n                if(marketingShare > 0) {\n                    uint256 marketingTokens = (contractTokenBalance * marketingShare) / totalShare;\n                    swapAndSendMarketing(marketingTokens);\n                } \n            }\n\n            inSwapAndLiquify = false;\n        }\n        \n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from,to,amount);\n\n        if (maxWalletLimitEnabled) \n        {\n            if (!_isExcludedFromMaxWalletLimit[from] && \n                !_isExcludedFromMaxWalletLimit[to] &&\n                to != uniswapV2Pair\n            ) {\n                uint256 balance  = balanceOf(to);\n                require(\n                    balance + amount <= maxWalletAmount, \n                    \"MaxWallet: Recipient exceeds the maxWalletAmount\"\n                );\n            }\n        }\n    }\n\n    function swapAndLiquify(uint256 tokens) private {\n        uint256 half = tokens / 2;\n        uint256 otherHalf = tokens - half;\n\n        uint256 initialBalance = address(this).balance;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            half,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp);\n        \n        uint256 newBalance = address(this).balance - initialBalance;\n\n        uniswapV2Router.addLiquidityETH{value: newBalance}(\n            address(this),\n            otherHalf,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            DEAD,\n            block.timestamp\n        );\n\n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }\n\n    function swapAndSendMarketing(uint256 tokenAmount) private {\n        uint256 initialBalance = address(this).balance;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp);\n\n        uint256 newBalance = address(this).balance - initialBalance;\n\n        payable(marketingWallet).sendValue(newBalance);\n\n        emit SwapAndSendMarketing(tokenAmount, newBalance);\n    }\n\n    function _tokenTransfer(address sender, address recipient, uint256 amount) private {\n         if (_isExcludedFromFees[sender] || \n            _isExcludedFromFees[recipient] \n            ) {\n            removeAllFee();\n        }else if(recipient == uniswapV2Pair){\n            setSellFee();\n        }else if(sender == uniswapV2Pair){\n            setBuyFee();\n        }else if(walletToWalletTransferWithoutFee){\n            removeAllFee();\n        }else{\n            setSellFee();\n        }\n\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);           \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender] - tAmount;\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount; \n        _takeMarketing(tMarketing);  \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender] - tAmount;\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);        \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    mapping(address => bool) private _isExcludedFromMaxTxLimit;\n    bool    public  maxTransactionLimitEnabled;\n\n    event ExcludedFromMaxTransactionLimit(address indexed account, bool isExcluded);\n    event MaxTransactionLimitStateChanged(bool maxTransactionLimit);\n    event MaxTransactionLimitAmountChanged(uint256 maxTransactionAmountBuy, uint256 maxTransactionAmountSell);\n\n\n    function isExcludedFromMaxTransaction(address account) public view returns(bool) {\n        return _isExcludedFromMaxTxLimit[account];\n    }\n\n    mapping(address => bool) private _isExcludedFromMaxWalletLimit;\n    bool public maxWalletLimitEnabled;\n\n    event ExcludedFromMaxWalletLimit(address indexed account, bool isExcluded);\n    event MaxWalletLimitStateChanged(bool maxWalletLimit);\n    event MaxWalletLimitAmountChanged(uint256 maxWalletAmount);\n\n\n    function isExcludedFromMaxWalletLimit(address account) public view returns(bool) {\n        return _isExcludedFromMaxWalletLimit[account];\n    }\n\n    function contractTypeBlazex() external pure returns(uint){\n        return 3;\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReflectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"}],\"name\":\"BuyFeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromMaxTransactionLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromMaxWalletLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketingWallet\",\"type\":\"address\"}],\"name\":\"MarketingWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransactionAmountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransactionAmountSell\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionLimitAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"maxTransactionLimit\",\"type\":\"bool\"}],\"name\":\"MaxTransactionLimitStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWalletAmount\",\"type\":\"uint256\"}],\"name\":\"MaxWalletLimitAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"maxWalletLimit\",\"type\":\"bool\"}],\"name\":\"MaxWalletLimitStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReflectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"}],\"name\":\"SellFeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbSend\",\"type\":\"uint256\"}],\"name\":\"SwapAndSendMarketing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapTokensAtAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"WalletToWalletTransferWithoutFeeEnabled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addLiquidityToZero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractTypeBlazex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxWalletLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teamAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockToTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"lockOnTeam\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uncxAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockToTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"lockOnUNCX\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeonBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeonSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmountBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmountSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReflectionDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletToWalletTransferWithoutFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SafuToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}