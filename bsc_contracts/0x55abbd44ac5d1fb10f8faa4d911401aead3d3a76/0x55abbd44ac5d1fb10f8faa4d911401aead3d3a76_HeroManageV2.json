{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HeroManage_v2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./lib/openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"./lib/openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./lib/openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./Common.sol\\\";\\nimport \\\"./Configable.sol\\\";\\nimport \\\"./lib/Signature.sol\\\";\\n\\ncontract HeroManageV2 is IHeroManage, ReentrancyGuard, Configable {\\n\\n    using SafeCast for uint;\\n\\n    address public SIGNER;\\n    IHero721V2 public hero721;\\n    IERC20 public burger20;\\n\\n    address public nftlease;\\n\\n    uint private rand_seed;\\n    uint public summon_price = 1 ether;\\n\\n    uint32 public cd = 43200;\\n\\n    uint32 public mutation_rate1 = 20;\\n    uint32 public mutation_rate2 = 10;\\n\\n    uint16 constant max_creation = 10000;\\n    uint32 public descendants_token_count = max_creation;\\n\\n    event OpenBox(address owner, uint32 token_id);\\n    event Summon(address owner, uint price);\\n\\n    constructor(address _hero721, address _burger20, address _signer)\\n    {\\n        owner = msg.sender;\\n        hero721 = IHero721V2(_hero721);\\n        burger20 = IERC20(_burger20);\\n        SIGNER = _signer;\\n        rand_seed = 0;\\n    }\\n\\n    function calcSummonBurger(uint32 _token_id1, uint32 _token_id2) external view returns (uint)\\n    {\\n        HeroMetaDataV2 memory meta1 = hero721.getMeta(_token_id1);\\n        HeroMetaDataV2 memory meta2 = hero721.getMeta(_token_id2);\\n\\n        return calcSummonBurgerInner(meta1) + calcSummonBurgerInner(meta2);\\n    }\\n\\n    function openBox(uint32 _token_id, address _account, uint _seed, uint _expiry_time, bytes memory _signatures) external nonReentrant\\n    {\\n        require(verify(_account, _seed, _expiry_time, _signatures), \\\"this sign is not valid\\\");\\n        require(_expiry_time > block.timestamp, \\\"_seed expired\\\");\\n        require(_account == msg.sender, \\\"only the account signatures can open\\\");\\n        _openBox(_token_id, _seed);\\n    }\\n\\n    function batchOpenBox(uint32[] memory _token_ids) external onlyAdmin nonReentrant {\\n        for (uint i = 0; i < _token_ids.length; i++) {\\n            _openBox(_token_ids[i], block.timestamp);\\n        }\\n    }\\n\\n    function summon(uint32 _token_id1, uint32 _token_id2, address _account, uint _seed, uint _expiry_time, bytes memory _signatures) external nonReentrant\\n    {\\n        require(_token_id1 != _token_id2, \\\"same token_id\\\");\\n\\n        require(hero721.ownerOf(_token_id1) == msg.sender, \\\"only the owner can summon\\\");\\n        require(hero721.ownerOf(_token_id2) == msg.sender, \\\"only the owner can summon\\\");\\n        require(verify(_account, _seed, _expiry_time, _signatures), \\\"this sign is not valid\\\");\\n        require(_expiry_time > block.timestamp, \\\"_seed expired\\\");\\n        require(_account == msg.sender, \\\"only the account signatures can summon\\\");\\n\\n        HeroMetaDataV2 memory meta1 = hero721.getMeta(_token_id1);\\n        HeroMetaDataV2 memory meta2 = hero721.getMeta(_token_id2);\\n\\n        makeNew(msg.sender, _token_id1, meta1, _token_id2, meta2, _seed);\\n    }\\n\\n    function summonLease(address _account, uint32 _token_id1, uint32 _token_id2, uint _seed, uint _expiry_time, bytes memory _signatures) external nonReentrant\\n    {\\n        require(msg.sender == nftlease);\\n        require(_token_id1 != _token_id2, \\\"same token_id\\\");\\n        require(hero721.ownerOf(_token_id1) == _account, \\\"only the owner can summon\\\");\\n        require(verify(_account, _seed, _expiry_time, _signatures), \\\"this sign is not valid\\\");\\n        require(_expiry_time > block.timestamp, \\\"_seed expired\\\");\\n        \\n        HeroMetaDataV2 memory meta1 = hero721.getMeta(_token_id1);\\n        HeroMetaDataV2 memory meta2 = hero721.getMeta(_token_id2);\\n\\n        makeNew(_account, _token_id1, meta1, _token_id2, meta2, _seed);\\n    }\\n\\n    //*****************************************************************************\\n    //* inner\\n    //*****************************************************************************\\n    function randMod(uint _seed) internal returns(uint) {\\n        uint base = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, rand_seed, _seed)));  \\n        unchecked {\\n            rand_seed += base;\\n        }     \\n        return base;\\n    }\\n\\n    function max(uint _a, uint _b) internal pure returns(uint) {\\n        if (_a > _b) {\\n            return _a;\\n        }\\n\\n        return _b;\\n    }\\n\\n    function min(uint _a, uint _b) internal pure returns(uint) {\\n        if (_a < _b) {\\n            return _a;\\n        }\\n\\n        return _b;\\n    }\\n\\n    function calcRemainSummonCnt(HeroMetaDataV2 memory _meta) internal pure returns (uint32)\\n    {\\n        if (_meta.gen == 0) {\\n            return 100;\\n        }\\n\\n        return (_meta.maxsummon_cnt - _meta.summon_cnt);\\n    }\\n\\n    function calcSummonBurgerInner(HeroMetaDataV2 memory _meta) internal view returns (uint)\\n    {\\n        uint summon_cnt = min(_meta.summon_cnt, 13);\\n\\n        uint burger = (uint(_meta.gen) * 10 + 6 + summon_cnt * 2) * summon_price;\\n        return burger;\\n    }\\n\\n    function mixDNA(HeroMetaDataV2 memory _meta1, HeroMetaDataV2 memory _meta2, uint _seed) internal returns (uint8, uint8, uint8, uint8)\\n    {\\n        uint8[4] memory newdna;\\n        uint8[4] memory dna1;\\n        uint8[4] memory dna2;\\n\\n        dna1[0] = _meta1.d;\\n        dna1[1] = _meta1.r1;\\n        dna1[2] = _meta1.r2;\\n        dna1[3] = _meta1.r3;\\n\\n        dna2[0] = _meta2.d;\\n        dna2[1] = _meta2.r1;\\n        dna2[2] = _meta2.r2;\\n        dna2[3] = _meta2.r3;\\n\\n        uint rand = randMod(_seed);      \\n        uint rate;\\n        \\n        //dna1\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 25) {\\n            uint8 tmp = dna1[3];\\n            dna1[3] = dna1[2];\\n            dna1[2] = tmp;\\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 25) {\\n            uint8 tmp = dna1[2];\\n            dna1[2] = dna1[1];\\n            dna1[1] = tmp;\\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 25) {\\n            uint8 tmp = dna1[1];\\n            dna1[1] = dna1[0];\\n            dna1[0] = tmp;\\n        }\\n\\n        //dna2\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 25) {\\n            uint8 tmp = dna2[3];\\n            dna2[3] = dna2[2];\\n            dna2[2] = tmp;\\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 25) {\\n            uint8 tmp = dna2[2];\\n            dna2[2] = dna2[1];\\n            dna2[1] = tmp;\\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 25) {\\n            uint8 tmp = dna2[1];\\n            dna2[1] = dna2[0];\\n            dna2[0] = tmp;\\n        }\\n\\n        //make new dna\\n        uint32 p1_rate1 = (100 - mutation_rate1) / 2 + mutation_rate1;\\n        uint32 p1_rate2 = (100 - mutation_rate2) / 2 + mutation_rate2;\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if ((dna1[0] == 1 && dna2[0] == 2) || (dna1[0] == 2 && dna2[0] == 1)) {\\n            if (rate < mutation_rate1) {\\n                newdna[0] = 9;\\n            } else if (rate < p1_rate1) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else if ((dna1[0] == 3 && dna2[0] == 4) || (dna1[0] == 4 && dna2[0] == 3)) {\\n            if (rate < mutation_rate1) {\\n                newdna[0] = 10;\\n            } else if (rate < p1_rate1) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else if ((dna1[0] == 5 && dna2[0] == 6) || (dna1[0] == 6 && dna2[0] == 5)) {\\n            if (rate < mutation_rate1) {\\n                newdna[0] = 11;\\n            } else if (rate < p1_rate1) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else if ((dna1[0] == 7 && dna2[0] == 8) || (dna1[0] == 8 && dna2[0] == 7)) {\\n            if (rate < mutation_rate1) {\\n                newdna[0] = 12;\\n            } else if (rate < p1_rate1) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else if ((dna1[0] == 9 && dna2[0] == 10) || (dna1[0] == 10 && dna2[0] == 9)) {\\n            if (rate < mutation_rate1) {\\n                newdna[0] = 13;\\n            } else if (rate < p1_rate1) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else if ((dna1[0] == 11 && dna2[0] == 12) || (dna1[0] == 12 && dna2[0] == 11)) {\\n            if (rate < mutation_rate1) {\\n                newdna[0] = 14;\\n            } else if (rate < p1_rate1) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else if ((dna1[0] == 13 && dna2[0] == 14) || (dna1[0] == 14 && dna2[0] == 13)) {\\n            if (rate < mutation_rate2) {\\n                newdna[0] = 15;\\n            } else if (rate < p1_rate2) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            }\\n        } else {\\n            if (rate < 50) {\\n                newdna[0] = dna1[0];\\n            } else {\\n                newdna[0] = dna2[0];\\n            } \\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 50) {\\n            newdna[1] = dna1[1];\\n        } else {\\n            newdna[1] = dna2[1];\\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 50) {\\n            newdna[2] = dna1[2];\\n        } else {\\n            newdna[2] = dna2[2];\\n        }\\n\\n        rate = rand % 100;\\n        rand = rand / 100;\\n        if (rate < 50) {\\n            newdna[3] = dna1[3];\\n        } else {\\n            newdna[3] = dna2[3];\\n        }\\n\\n        return (newdna[0], newdna[1], newdna[2], newdna[3]);\\n    }\\n\\n    function makeNew(address _to, uint32 _token_id1, HeroMetaDataV2 memory _meta1, uint32 _token_id2, HeroMetaDataV2 memory _meta2, uint _seed) internal\\n    {\\n        uint64 curtime = block.timestamp.toUint64();\\n        require(_meta1.opened, \\\"token1 not open\\\");\\n        require(_meta2.opened, \\\"token2 not open\\\");\\n        require(_meta1.summon_cd < curtime, \\\"token1 cd\\\");\\n        require(_meta2.summon_cd < curtime, \\\"token2 cd\\\");\\n\\n        require(_meta1.p1 != _token_id2, \\\"token1 p1 == token_id2\\\");\\n        require(_meta1.p2 != _token_id2, \\\"token1 p2 == token_id2\\\");\\n        require(_meta2.p1 != _token_id1, \\\"token2 p1 == token_id1\\\");\\n        require(_meta2.p2 != _token_id1, \\\"token2 p2 == token_id1\\\");\\n\\n        //calc summon num\\n        uint32 remainsummon1 = calcRemainSummonCnt(_meta1);\\n        uint32 remainsummon2 = calcRemainSummonCnt(_meta2);\\n\\n        require(remainsummon1 > 0, \\\"token1 cnt\\\");\\n        require(remainsummon2 > 0, \\\"token2 cnt\\\");\\n\\n        //calc burger\\n        uint sum_burger = calcSummonBurgerInner(_meta1) + calcSummonBurgerInner(_meta2);\\n        if (sum_burger > 0) {\\n            burger20.transferFrom(_to, address(this), sum_burger);\\n            emit Summon(_to, sum_burger);\\n        }\\n\\n        //do summon logic\\n        HeroMetaDataV2 memory newmeta;\\n        //opened\\n        newmeta.opened = true;\\n        //gen\\n        newmeta.gen = uint8(max(_meta1.gen, _meta2.gen) + 1);\\n        //summon dna\\n        (newmeta.d, newmeta.r1, newmeta.r2, newmeta.r3) = mixDNA(_meta1, _meta2, _seed);\\n        //summon_cd\\n        newmeta.summon_cd = (uint(curtime) + 6 * uint(cd)).toUint64();\\n        //summon_cnt\\n        newmeta.summon_cnt = 0;\\n        //maxsummon_cnt\\n        if (newmeta.gen >= 11) {\\n            newmeta.maxsummon_cnt = 0;\\n        } else {\\n            uint maxsummon_cnt1 = 11 - newmeta.gen;\\n            uint maxsummon_cnt2;\\n            if (newmeta.d <= 8) {\\n                maxsummon_cnt2 = 10;\\n            } else if (newmeta.d <= 12) {\\n                maxsummon_cnt2 = 5;\\n            } else if (newmeta.d <= 14) {\\n                maxsummon_cnt2 = 3;\\n            } else {\\n                maxsummon_cnt2 = 1;\\n            }\\n\\n            uint min1 = min(maxsummon_cnt1, maxsummon_cnt2);\\n            uint min2 = min(remainsummon1, remainsummon2) - 1;\\n\\n            newmeta.maxsummon_cnt = uint8(min(min1, min2));\\n        }\\n        //p1\\n        newmeta.p1 = _token_id1;\\n        //p2\\n        newmeta.p2 = _token_id2;\\n\\n        newmeta.morale = randMorale(newmeta.d, _seed);\\n\\n        HeroMetaDataExt[] memory _exts;\\n        \\n        uint new_token_id = ++descendants_token_count;\\n        require(new_token_id < type(uint32).max, 'new_token_id overflow');\\n        hero721.mint(2, _to, new_token_id, newmeta, _exts);\\n\\n\\n        //change token1\\n        if (_meta1.summon_cnt < 100) {\\n            _meta1.summon_cnt += 1;            \\n        }\\n\\n        uint summon_cnt1 = min(_meta1.summon_cnt, 13);\\n\\n        _meta1.summon_cd = (uint(curtime) + (uint(_meta1.gen) + summon_cnt1) * uint(cd) + uint(cd)).toUint64();\\n        hero721.setMeta(_token_id1, _meta1, _exts);\\n\\n        //change token2\\n        if (_meta2.summon_cnt < 100) {\\n            _meta2.summon_cnt += 1;            \\n        }\\n\\n        uint summon_cnt2 = min(_meta2.summon_cnt, 13);\\n\\n        _meta2.summon_cd = (uint(curtime) + (uint(_meta2.gen) + summon_cnt2) * uint(cd) + uint(cd)).toUint64();\\n        hero721.setMeta(_token_id2, _meta2, _exts);\\n    }\\n\\n    function _openBox(uint32 _token_id, uint _seed) internal\\n    {\\n        require(hero721.ownerOf(_token_id) == msg.sender, \\\"only the owner can open box\\\");\\n\\n        HeroMetaDataV2 memory meta = hero721.getMeta(_token_id);\\n        require(!meta.opened, \\\"box opened\\\");\\n\\n        meta.opened = true;\\n        meta.gen = 0;\\n\\n        uint cdtime = block.timestamp + 2 * uint(cd);\\n        meta.summon_cd = cdtime.toUint64();\\n\\n        meta.summon_cnt = 0;\\n        meta.maxsummon_cnt = 0;\\n\\n        uint rand = randMod(_seed);\\n        uint8 rate;\\n\\n        rate = uint8(rand % 8);\\n        rand = rand / 8;\\n        meta.d = uint8(rate + 1);\\n\\n        rate = uint8(rand % 8);\\n        rand = rand / 8;\\n        meta.r1 = uint8(rate + 1);\\n\\n        rate = uint8(rand % 8);\\n        rand = rand / 8;\\n        meta.r2 = uint8(rate + 1);\\n\\n        rate = uint8(rand % 8);\\n        rand = rand / 8;\\n        meta.r3 = uint8(rate + 1);\\n\\n        meta.p1 = 0;\\n        meta.p2 = 0;\\n\\n        meta.morale = randMorale(meta.d, _seed);\\n\\n        HeroMetaDataExt[] memory _exts;\\n\\n        hero721.setMeta(_token_id, meta, _exts);\\n        emit OpenBox(msg.sender, _token_id);\\n    }\\n\\n    function randMorale(uint8 d, uint _seed) internal returns (uint8) {\\n        \\n        uint rand = randMod(_seed);\\n        uint8 rate = uint8(rand % 41);\\n\\n        if (d >= 1 && d <= 8) {\\n            return 30 + rate;\\n        } else if (d >= 9 && d <= 12) {\\n            return 35 + rate;\\n        } else if (d >= 13 && d <= 14) {\\n            return 40 + rate;\\n        } else if (d == 15) {\\n            return 45 + rate;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function verify(address _account, uint _seed, uint _expiry_time, bytes memory _signatures) public view returns (bool) {\\n\\n        bytes32 message = keccak256(abi.encodePacked(_account, _seed, _expiry_time));\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", message));\\n        address[] memory sign_list = Signature.recoverAddresses(hash, _signatures);\\n        return sign_list[0] == SIGNER;\\n    }\\n\\n    //*****************************************************************************\\n    //* manage\\n    //*****************************************************************************\\n    function withdraw(address _to) external onlyAdmin\\n    {\\n        if (address(this).balance > 0) {\\n            payable(_to).transfer(address(this).balance);\\n        }\\n    }\\n\\n    function withdrawBurger(address _to) external onlyAdmin\\n    {\\n        uint balance = burger20.balanceOf(address(this));\\n        if (balance > 0) {\\n            burger20.transfer(_to, balance);\\n        }\\n    }\\n\\n    function balanceOfBurger() external view returns (uint)\\n    {\\n        return burger20.balanceOf(address(this));\\n    }\\n\\n    function setSummonPrice(uint _price) external onlyAdmin\\n    {\\n        require(_price > 0, \\\"summon price should > 0\\\");\\n\\n        summon_price = _price;\\n    }\\n\\n    function setSummonCD(uint32 _cd) external onlyAdmin\\n    {\\n        require(_cd > 0, \\\"summon cd should > 0\\\");\\n\\n        cd = _cd;\\n    }\\n\\n    function setMutationRate(uint32 _mutation_rate1, uint32 _mutation_rate2) external onlyAdmin\\n    {\\n        require(_mutation_rate1 <= 100, \\\"_mutation_rate1 should <= 100\\\");\\n        require(_mutation_rate2 <= 100, \\\"_mutation_rate2 should <= 100\\\");\\n\\n        require(_mutation_rate1 % 2 == 0, \\\"_mutation_rate1 must be an even number\\\");\\n        require(_mutation_rate2 % 2 == 0, \\\"_mutation_rate2 must be an even number\\\");\\n\\n        mutation_rate1 = _mutation_rate1;\\n        mutation_rate2 = _mutation_rate2;\\n    }\\n\\n    function setHero721(address _hero721) external onlyDev\\n    {\\n        require(_hero721 != address(0), \\\"address should not 0\\\");\\n        hero721 = IHero721V2(_hero721);\\n    }\\n\\n    function setBurger20(address _burger20) external onlyDev\\n    {\\n        require(_burger20 != address(0), \\\"address should not 0\\\");\\n        burger20 = IERC20(_burger20);\\n    }\\n\\n    function setNFTLease(address _nftlease) external onlyDev\\n    {\\n        require(_nftlease != address(0), \\\"address should not 0\\\");\\n        nftlease = _nftlease;\\n    }\\n\\n    function setSigner(address _signer) external onlyAdmin\\n    {\\n        SIGNER = _signer;\\n    }\\n\\n    function setDescendantsTokenCount(uint32 _token_count) external onlyDev\\n    {\\n        require(_token_count > max_creation, \\\"must be greater than max creation\\\");\\n        descendants_token_count = _token_count;\\n    }\\n\\n    function kill() external onlyOwner\\n    {\\n        uint balance = burger20.balanceOf(address(this));\\n        if (balance > 0) {\\n            burger20.transfer(owner, balance);\\n        }\\n        selfdestruct(payable(owner));\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./lib/openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"./lib/openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"./lib/openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n\\n//Hero data structure\\nstruct HeroMetaData {\\n    bool opened;        //box or hero\\n    uint8 gen;          //generation\\n\\n    uint64 summon_cd;       //next summon time\\n    uint8 summon_cnt;       //current summon count\\n    uint8 maxsummon_cnt;    //max summon count\\n    uint8 d;      //Dominant gene\\n    uint8 r1;     //Recessive gene 1\\n    uint8 r2;     //Recessive gene 2\\n    uint8 r3;     //Recessive gene 3\\n    uint32 p1;    //parent 1\\n    uint32 p2;    //parent 2\\n}\\n\\n//Hero data structure\\nstruct HeroMetaDataV2 {\\n    bool opened;        //box or hero\\n    uint8 gen;          //generation\\n\\n    uint64 summon_cd;       //next summon time\\n    uint8 summon_cnt;       //current summon count\\n    uint8 maxsummon_cnt;    //max summon count\\n    uint8 d;      //Dominant gene\\n    uint8 r1;     //Recessive gene 1\\n    uint8 r2;     //Recessive gene 2\\n    uint8 r3;     //Recessive gene 3\\n    uint32 p1;    //parent 1\\n    uint32 p2;    //parent 2\\n    uint8 morale;      //morale\\n}\\n\\nstruct HeroMetaDataExt {\\n    uint256 key;\\n    uint256 val;\\n}\\n\\n\\ninterface IHero721 is IERC721, IERC721Enumerable {\\n    function getMeta(uint32 token_id) external view returns (HeroMetaData memory);\\n    function setMeta(uint32 token_id, HeroMetaData calldata meta) external;\\n    function burn(uint32 token_id) external;\\n    function exists(uint32 token_id) external view returns (bool);\\n    function createCreationTo(address to, HeroMetaData calldata meta) external;\\n    function createDescendantsTo(address to, HeroMetaData calldata meta) external;\\n    function calcCreationLimit() external view returns (uint16);\\n}\\n\\ninterface IHero721V2 is IERC721, IERC721Enumerable {\\n    function getMeta(uint256 token_id) external view returns (HeroMetaDataV2 memory);\\n    function getMeta2(uint256 _token_id) external view returns (HeroMetaDataV2 memory meta, HeroMetaDataExt[] memory exts);\\n    function getMetas2(uint256[] memory _token_ids) external view returns (uint256[] memory token_ids, HeroMetaDataV2[] memory metas, HeroMetaDataExt[][] memory exts);\\n    function setMeta(uint256 _token_id, HeroMetaDataV2 calldata _meta, HeroMetaDataExt[] calldata _exts) external;\\n    function burn(uint256 token_id) external;\\n    function mint(uint8 _mint_type, address _to, uint256 _token_id, HeroMetaDataV2 calldata _meta, HeroMetaDataExt[] calldata _exts) external;\\n    function exists(uint256 token_id) external view returns (bool);\\n    function getExtKeys() external view returns (uint256[] memory);\\n    function existExtKey(uint256 _key) external view returns (bool);\\n\\n}\\n\\ninterface IClothing721 {\\n    function manageMintTo(address to, uint32 clothes_id) external;\\n}\\n\\ninterface IHeroManage {\\n    function summonLease(address _account, uint32 _token_id1, uint32 _token_id2, uint _seed, uint _expiry_time, bytes memory _signatures) external;\\n}\\n\\n\"\r\n    },\r\n    \"contracts/Configable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IConfig {\\n    function dev() external view returns (address);\\n    function admin() external view returns (address);\\n}\\n\\ncontract Configable {\\n    address public config;\\n    address public owner;\\n\\n    event ConfigChanged(address indexed _user, address indexed _old, address indexed _new);\\n    event OwnerChanged(address indexed _user, address indexed _old, address indexed _new);\\n \\n    function setupConfig(address _config) external onlyOwner {\\n        emit ConfigChanged(msg.sender, config, _config);\\n        config = _config;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'OWNER FORBIDDEN');\\n        _;\\n    }\\n\\n    function admin() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).admin();\\n        }\\n        return owner;\\n    }\\n\\n    function dev() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).dev();\\n        }\\n        return owner;\\n    }\\n\\n    function changeOwner(address _user) external onlyOwner {\\n        require(owner != _user, 'Owner: NO CHANGE');\\n        emit OwnerChanged(msg.sender, owner, _user);\\n        owner = _user;\\n    }\\n    \\n    modifier onlyDev() {\\n        require(msg.sender == dev() || msg.sender == owner, 'dev FORBIDDEN');\\n        _;\\n    }\\n    \\n    modifier onlyAdmin() {\\n        require(msg.sender == admin() || msg.sender == owner, 'admin FORBIDDEN');\\n        _;\\n    }\\n  \\n    modifier onlyManager() {\\n        require(msg.sender == dev() || msg.sender == admin() || msg.sender == owner, 'manager FORBIDDEN');\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/Signature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nlibrary Signature {\\n    function recoverAddresses(bytes32 _hash, bytes memory _signatures) internal pure returns (address[] memory addresses) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint count = _countSignatures(_signatures);\\n        addresses = new address[](count);\\n        for (uint i = 0; i < count; i++) {\\n            (v, r, s) = _parseSignature(_signatures, i);\\n            addresses[i] = ecrecover(_hash, v, r, s);\\n        }\\n    }\\n    \\n    function _parseSignature(bytes memory _signatures, uint _pos) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        uint offset = _pos * 65;\\n        assembly {\\n            r := mload(add(_signatures, add(32, offset)))\\n            s := mload(add(_signatures, add(64, offset)))\\n            v := and(mload(add(_signatures, add(65, offset))), 0xff)\\n        }\\n\\n        if (v < 27) v += 27;\\n\\n        require(v == 27 || v == 28);\\n    }\\n    \\n    function _countSignatures(bytes memory _signatures) internal pure returns (uint) {\\n        return _signatures.length % 65 == 0 ? _signatures.length / 65 : 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hero721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burger20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"token_id\",\"type\":\"uint32\"}],\"name\":\"OpenBox\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Summon\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SIGNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfBurger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_token_ids\",\"type\":\"uint32[]\"}],\"name\":\"batchOpenBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burger20\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_token_id1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_token_id2\",\"type\":\"uint32\"}],\"name\":\"calcSummonBurger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cd\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descendants_token_count\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hero721\",\"outputs\":[{\"internalType\":\"contract IHero721V2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mutation_rate1\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mutation_rate2\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftlease\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_token_id\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry_time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"openBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burger20\",\"type\":\"address\"}],\"name\":\"setBurger20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_token_count\",\"type\":\"uint32\"}],\"name\":\"setDescendantsTokenCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hero721\",\"type\":\"address\"}],\"name\":\"setHero721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_mutation_rate1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_mutation_rate2\",\"type\":\"uint32\"}],\"name\":\"setMutationRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftlease\",\"type\":\"address\"}],\"name\":\"setNFTLease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_cd\",\"type\":\"uint32\"}],\"name\":\"setSummonCD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setSummonPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_token_id1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_token_id2\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry_time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"summon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_token_id1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_token_id2\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry_time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"summonLease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"summon_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry_time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawBurger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HeroManageV2", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000057cb9c450c64efb071a44173d815edeba9344632000000000000000000000000ae9269f27437f0fcbc232d39ec814844a51d6b8f0000000000000000000000005720cc167fec35a89ef016ba8aa4eb26ef1d46a6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}