{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n//https://learnblockchain.cn/article/3152\r\n//https://github.com/liyue201/stock-contract/blob/main/stock.sol\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\ninterface PB {\r\n    function changeBanlance(address token, address userAddress,uint amountIn) external;\r\n}\r\ninterface IERC20 {\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n//\u6536\u76ca\u5408\u7ea6\uff08\u9886\u53d6\u5408\u7ea6\u6765\u90e8\u7f72\uff09\r\ncontract AIncome  {\r\n    using SafeMath for uint;\r\n    mapping(uint8 => address) public _owners;\r\n    mapping(address => bool) public whitelist;\r\n    /**\r\n     * \u53ea\u6709\u7ba1\u7406\u5458\u53ef\u4ee5\u64cd\u4f5c\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owners[0] , \"nodata\");\r\n        _;\r\n    }\r\n    modifier onlyWhitelisted() {\r\n        require(whitelist[msg.sender],\"no white\");\r\n        _;\r\n    }\r\n    constructor(address sender,address father) public {\r\n        _owners[0] = sender;\r\n        //\u9886\u53d6\u5408\u7ea6\u548c\u7ba1\u7406\u90fd\u662f\u6536\u76ca\u5408\u7ea6\u7684\u767d\u540d\u5355\r\n        whitelist[father] = true;\r\n    }\r\n    function toOwner(address to) public onlyOwner{\r\n        _owners[0] = to;\r\n    }\r\n\r\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\r\n        if (!whitelist[addr]) {\r\n            whitelist[addr] = true;\r\n            success = true;\r\n        }\r\n    }\r\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n        if (whitelist[addr]) {\r\n            whitelist[addr] = false;\r\n            success = true;\r\n        }\r\n    }\r\n    function changeBanlance(address token, address userAddress,uint amountIn) onlyWhitelisted external virtual{\r\n        if (token == address(0)) {\r\n            payable(userAddress).transfer(amountIn);\r\n        }else {\r\n            IERC20(token).transfer(userAddress, amountIn);\r\n        }\r\n    }\r\n}\r\ncontract AGive{\r\n    using SafeMath for uint256;\r\n    mapping(uint8 => address) public _owners;\r\n    mapping(address => bool) public whitelist;\r\n    mapping(address => uint) public user_sum_balance;//\u7528\u6237\u4ece\u4ec0\u4e48\u67d0\u4e2a\u6536\u76ca\u91d1\u989d\u8d28\u62bc\u8fdb\u6765\u7684\r\n    mapping(address => uint) public user_have_profit;//\u7528\u6237\u8fd8\u6709\u591a\u5c11\u6536\u76ca\u6ca1\u6709\u9886\u53d6\r\n\r\n    address public _b;//\u8d28\u62bc\u5408\u7ea6\r\n    address public _income;//\u6536\u76ca\u5408\u7ea6\r\n    address public _time_token;//\u4e3b\u5408\u7ea6\r\n    uint256 public token_balance;\r\n    constructor()  {\r\n        _owners[0] = msg.sender;\r\n        //\u90e8\u7f72\u6536\u76ca\u5408\u7ea6\r\n        AIncome cincome = new AIncome(msg.sender,address(this));\r\n        _income = address(cincome);\r\n    }\r\n    /**\r\n     * \u53ea\u6709\u7ba1\u7406\u5458\u53ef\u4ee5\u64cd\u4f5c\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owners[0] , \"nodata\");\r\n        _;\r\n    }\r\n    modifier onlyWhitelisted() {\r\n        require(whitelist[msg.sender],\"no white\");\r\n        _;\r\n    }\r\n    function toOwner(address to) public onlyOwner{\r\n        _owners[0] = to;\r\n    }\r\n    function set(address b,address time_token)public onlyOwner{\r\n        _b = b;\r\n        _time_token =time_token;\r\n        //\u9700\u8981\u7ed9\u4e3b\u5e01\u8bbe\u7f6e\u767d\u540d\u5355\r\n        whitelist[time_token] = true;\r\n        whitelist[_b] = true;\r\n    }\r\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\r\n        if (!whitelist[addr]) {\r\n            whitelist[addr] = true;\r\n            success = true;\r\n        }\r\n    }\r\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n        if (whitelist[addr]) {\r\n            whitelist[addr] = false;\r\n            success = true;\r\n        }\r\n    }\r\n    function profit(uint amount) onlyWhitelisted public{\r\n        //\u8bb0\u5f55\u7d2f\u8ba1\u6536\u76ca\r\n        token_balance = token_balance.add(amount);\r\n    }\r\n    //\u7ba1\u7406\u5458\u6709\u6743\u9650\u4fee\u6539\u6536\u76ca\u7684\u6570\u91cf\r\n    function sumprofit(uint amount) onlyOwner public{\r\n        if(token_balance>0 && token_balance>=amount){\r\n            token_balance = token_balance.sub(amount);\r\n        }\r\n    }\r\n    //\u5904\u7406\u7528\u6237\u8d28\u62bc\u8fdb\u6765\u7684\u6570\u636e\uff08\u8d28\u62bc\u5408\u7ea6\u4f1a\u8c03\u7528\uff09\r\n    function updateUserSumB(address addr) onlyWhitelisted public{\r\n        uint per = getPairInfoPer(addr);\r\n        uint res = token_balance.sub(user_sum_balance[addr]);\r\n        res = res.mul(per).div(10000);\r\n        user_sum_balance[addr] = token_balance;\r\n    }\r\n    //\u7528\u6237\u9886\u53d6\u6536\u76ca\r\n    function takeProfit(uint amount) public{\r\n        uint allpertoken = getProfitToken(msg.sender);\r\n        require(allpertoken>=amount,\"no balance\");\r\n        uint per = getPairInfoPer(msg.sender);\r\n        uint res = token_balance.sub(user_sum_balance[msg.sender]);\r\n        res = res.mul(per).div(10000);\r\n        user_have_profit[msg.sender] = user_have_profit[msg.sender].add(res);\r\n        user_have_profit[msg.sender] = user_have_profit[msg.sender].sub(amount);\r\n        user_sum_balance[msg.sender] = token_balance;\r\n        if(_income!=address(0) && _time_token!=address(0)){\r\n            //\u8c03\u7528\u6536\u76ca\u8f6c\u8d26\r\n            PB(_income).changeBanlance(_time_token,address(msg.sender),amount);\r\n        }\r\n    }\r\n    //\u83b7\u53d6\u7528\u6237\u6709\u591a\u5c11\u6536\u76ca\r\n    function getProfitToken(address userAddress) public view returns(uint256) {\r\n        uint pertoken =user_have_profit[userAddress];\r\n        uint per = getPairInfoPer(userAddress);\r\n        if(token_balance>0 && per>0 && token_balance>user_sum_balance[userAddress]){\r\n            uint res = token_balance.sub(user_sum_balance[userAddress]);\r\n            res = res.mul(per).div(10000);\r\n            pertoken = pertoken.add(res);\r\n        }\r\n        return pertoken;\r\n    }\r\n    //\u83b7\u53d6\u7528\u6237\u7684\u5360\u6bd4\r\n    function getPairInfoPer(address userAddress) public view  returns (uint _poolShare) {\r\n        uint lpBalance;\r\n        uint lpTotalSupply;\r\n        uint _poolShare;\r\n        if(_b!=address(0)){\r\n            lpBalance  =IERC20(_b).balanceOf(userAddress);\r\n            lpTotalSupply  = IERC20(_b).totalSupply();\r\n        }\r\n        if(lpBalance>0 && lpBalance<=lpTotalSupply){\r\n            _poolShare = lpBalance.mul(10000).div(lpTotalSupply);\r\n        }\r\n        return _poolShare;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_b\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_income\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"_owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_time_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getPairInfoPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getProfitToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"profit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"b\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"time_token\",\"type\":\"address\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sumprofit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"toOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"updateUserSumB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_have_profit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_sum_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AGive", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://394b4f70e5c50235b06de3e3e17d035db8bb6b7074df546361ec3e9d99e43ccf"}