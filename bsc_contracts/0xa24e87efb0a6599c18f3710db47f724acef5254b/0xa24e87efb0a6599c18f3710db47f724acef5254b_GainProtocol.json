{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"GainPriceFeed.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IGainProtocol.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract GainPriceFeed {\\n    using SafeMath for uint256;\\n\\n    AggregatorV3Interface public immutable priceFeed;\\n    IGainProtocol internal immutable token;\\n\\n    constructor(IGainProtocol _token, AggregatorV3Interface _priceFeed) public {\\n        token = _token;\\n        priceFeed = _priceFeed;\\n    }\\n\\n    /**\\n     * @dev returns value of _usd in gains.\\n     */\\n    function gainsForUSD(uint256 _usd)\\n        external\\n        view\\n        returns (bool success, uint256 value)\\n    {\\n        (uint256 gainReserve, uint256 bnbReserve) = this.getReserves();\\n        if (gainReserve == 0 || bnbReserve == 0) {\\n            return (false, 0);\\n        }\\n        (bool internalSuccess, int256 usdToBNB) = this.usdBNBPrice();\\n        if (usdToBNB == 0) {\\n            return (false, 0);\\n        }\\n        success = internalSuccess;\\n        /*\\n            10**8 - decimals\\n            USDs * (1/(USD price for bnb/10**8)) * (GAIN/BNB)\\n            USDs * GAIN * 10**8 /USD price / BNB\\n        */\\n        value = _usd\\n        .mul(gainReserve)\\n        .mul(uint256(10)**(priceFeed.decimals() + 18)) // to remove decimals from usd price, and from BNB\\n            .div(uint256(usdToBNB))\\n            .div(bnbReserve);\\n    }\\n\\n    /**\\n     * @dev Get LP reserves for GAIN/BNB\\n     * returns (gainReserve, BNBReserve)\\n     */\\n    function getReserves() external view returns (uint256, uint256) {\\n        IUniswapV2Pair pair = token.uniswapV2Pair();\\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\\n        return\\n            pair.token0() == address(token)\\n                ? (reserve0, reserve1)\\n                : (reserve1, reserve0);\\n    }\\n\\n    /**\\n     * @dev get BNB price in USD. if latestRoundData throws, returns (false, 0)\\n     */\\n    function usdBNBPrice() public view returns (bool success, int256 value) {\\n        try priceFeed.latestRoundData() returns (\\n            uint80, /*roundId*/\\n            int256 answer,\\n            uint256, /*startedAt*/\\n            uint256, /*updatedAt*/\\n            uint80 /*answeredInRound*/\\n        ) {\\n            value = answer;\\n            success = true;\\n        } catch {\\n            success = false;\\n            value = 0;\\n        }\\n    }\\n\\n    function usdBNBDecimals() external view returns (uint256) {\\n        return priceFeed.decimals();\\n    }\\n\\n    function usdToBNB(uint256 usd) external view returns (uint256 bnb) {\\n        (bool priceSuccess, int256 usdToBNBRate) = usdBNBPrice();\\n        require(priceSuccess, \\\"Internal pricing error\\\");\\n\\n        bnb = usd.mul(1 ether).mul(uint256(10)**priceFeed.decimals()).div(\\n            uint256(usdToBNBRate)\\n        );\\n    }\\n}\\n\"},\"GainProtocol.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IGainSweepstakes.sol\\\";\\nimport \\\"./IGainProtocol.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\nimport \\\"./GainPriceFeed.sol\\\";\\n\\n/**\\n * Mechanisms:\\n *   1. Taxes - Taxes are taken from seller and buyers, not from transaction. for example, if A transfers 100 GP to B,\\n *       A balance will be reduced by 103.5, and\\n *      B account will receive 96.5 GP. (excluding static reward of course)\\n *   2. Dynamic/Automatic liquidity - Auto LP is a mechanism to tax a certain amount of tax (2% for GP), and when it\\n *      adds up to a certain amount sell half of it for BNB, and take both half and add to liquidity. GP fixed this\\n *      mechanism, which was applied in previous protocols in two ways:\\n *      1. GP always checks for available BNB in contract account, and adds them to liquidity as well, and by doing\\n *         so, fix an issue which caused a LOT of BNB to be accumulated in the contract balance.\\n *      2. GP moves the LP tokens to the contract account, which locks them forever\\n *         Also, GP introduce dynamic liquidity. which can be used when there is too much liquidity in the LP.\\n *         this is determined by setting bounds for liquidity (start, end) for total tokens.\\n *         too much liquidity (should) mean a lot of accounts are selling their GAINs (or we are adding liquidity\\n *         where it\\u0027s no longer needed)\\n *         so remove liquidity (which will give us BNBs and GAINs), then buy GAINs with the BNBs.\\n *         This gives us a side effect of raising GAIN price (which balances out the sells for auto LP)\\n *         and we use the resulting GAINs to reward all users (reflection).\\n *         So basically - what we do here is use the tax we collected (which was put into the liquidity)\\n *         when no longer needed to help our holders.\\n *         This can be viewed as some kind of insurance - we collect a fee when everything is great\\n *         but when dark days come, we use that money to help out holders to keep their profits\\n *   3. Whale protection - In other contracts, we\\u0027ve all seen the following situation: the price rises\\n *      (or even worse - crashes), then some big holder decides to dump all their funds, almost at once,\\n *      which crashes the price..\\n *      We think that with great power, comes great responsibly [uncle ben], and to help incentivize whales to act responsibly\\n *      we\\u0027ve added a tax (maximum 25%) which is taken from anybody doing too much transfers per day (determined as)\\n *      a percent from LP. if someone sells more then 2% of the LP per day, he will be taxed. taxes rate are exponential\\n *      relative to total amount transferred relative to LP.\\n *   4. Hodl rewards - GP gives back to loyal holders, 0.25% of seller tax is given to accounts that haven\\u0027t sell\\n *      anything yet. As long as the account hodl, he will get this reward (and as it\\u0027s expected that less\\n *      accounts will hodl, the 0.25% reward will be shared by less accounts).\\n *   5. Associate account (connect) - Taxes are what makes GP tick, but there is a side effect: they can prevent trade.\\n *      This is often the case for user who purchased the token from PCS, and want to move it to some exchange, but are\\n *      reluctant to do so due to fees. To help trade happen, each user can define ONE and only ONE associate account which all\\n *      transfers to will be excluded from tax. Please note that associate transfers will not be rewarded with\\n *      hodl reward, and also won\\u0027t cancel hodl eligibility from sender.\\n *   6. Charity - GP takes 0.25% from each sell to give to charity, this is limited by dailyCharityLimitUSD $ per day.\\n *   7. Sweepstake - GP conducts a sweepstake each day to give to holders with 7 different criteria.\\n *       Please review GainSweepstakes.sol\\n *   8. Static rewards - Each sell is taxed with 3% fee, which is delivered to all existing holders.\\n *   9. Team tax - Every buy transaction is taxed 0.1% which will be taken for the team to keep them motivated and\\n *      fully focused on the project. this is taken ONLY from buys, and not sells to make sure the team goals are\\n *      aligned with the community.\\n */\\n\\ncontract GainProtocol is IGainProtocol, Context, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    struct Owner {\\n        uint64 lockedStartTime; // Timestamp - when was funds locking started\\n        uint64 lockedEndTime; // Timestamp - when will funds locking ends\\n        uint64 dailyTransferLastUpdatedDay; // Timestamp - when was daily transfer count last updated\\n        bool excludedFromHodlReward; // Is eligible for hodl reward\\n        uint96 dailyTransfers; // amount of token transferred today - up to TOKEN_TOTAL (which is limited to 70bit)\\n        uint96 hodlTokens; // hodl tokens reward - up to TOKEN_TOTAL (which is limited to 70bit)\\n        uint256 balance;\\n        uint256 lockedBalance; // Funds locked (used after winning sweepstake - in reflection units)\\n    }\\n\\n    struct Fees {\\n        // Used to avoid stack too deep\\n        uint256 liquidity;\\n        uint256 sweepstake;\\n        uint256 charity;\\n        uint256 reward;\\n        uint256 hodl;\\n        uint256 team;\\n        uint256 whaleProtection;\\n    }\\n\\n    struct FeesPercentage {\\n        // Used to avoid stack too deep\\n        uint256 liquidity;\\n        uint256 sweepstake;\\n        uint256 charity;\\n        uint256 reward;\\n        uint256 hodl;\\n        uint256 team;\\n        uint256 whaleProtection;\\n    }\\n\\n    // Constants\\n    string private constant NAME = \\\"GainProtocol\\\";\\n    string private constant SYMBOL = \\\"GAIN\\\";\\n    // Returns the number of decimals the token uses\\n    // e.g. 9, means to divide the token amount by 1000000000 to get its user representation.\\n    uint8 private constant DECIMALS = 9;\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private constant TOKEN_TOTAL = 1 * 10**12 * 10**9; // 1T (1,000,000,000,000)\\n    uint256 private constant PERCENT_DIVIDER_FACTOR = 10**4;\\n    uint256 private constant EXPONENT_PERCENT_DIVIDER = 10**2;\\n    uint256 private constant MAX_WHALE_FEE = 2500; // 25%\\n    uint256 private constant MAX_SWEEPSTAKE_REFUND = 10**17; // 0.1 BNB\\n\\n    // Mappings\\n\\n    // mapping of amounts allowed to be transferred by spender from owner account.\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowances;\\n    // Exclude the ENTIRE transaction from fee, for example: if A is excluded, if he sends\\n    // funds, to someone, no fee will be charged.\\n    mapping(address =\\u003e bool) public isExcludedFromFee;\\n    mapping(address =\\u003e address) private associateRequest;\\n    mapping(address =\\u003e address) public associateOf;\\n    mapping(address =\\u003e bool) public isAssociateBlackList;\\n    mapping(address =\\u003e bool) public isExcludedFromBuyFee;\\n    mapping(address =\\u003e bool) public isExcludedFromSellFee;\\n    mapping(address =\\u003e bool) public isExcludedFromWhaleProtectionFee;\\n\\n    mapping(address =\\u003e Owner) private owners; // Owner map\\n    mapping(address =\\u003e uint256) private tokenOwned; // Only for wallets excluded from reward\\n    mapping(address =\\u003e bool) public isExcludedFromReward;\\n    address[] private excludedFromReward;\\n\\n    // Flags\\n    bool private inSwapAndLiquify;\\n    bool private inSweepstake;\\n\\n    // Values\\n    uint256 private hodlTotalSupply;\\n    uint256 private rHodlersRewardPool;\\n    uint256 private rAvailableSweepstake; // In reflection\\n    uint256 private rAvailableLiquidity; // In reflection\\n    uint256 private rAvailableCharity; // In reflection\\n    uint256 private rDailyCharity; // In reflection\\n    uint256 private collectedSweepstakeTotal; // in tokens\\n    uint256 private collectedLiquidityTotal; // in tokens\\n    uint256 private collectedTeamFeeTotal; // in tokens\\n    uint256 private soldLiquidityTotal; // in tokens\\n    uint256 private collectedWhaleTotal; // in tokens\\n    uint256 private collectedRewardTotal; // in tokens\\n    uint256 private collectedHodlRewardTotal; // in tokens\\n    uint256 private collectedCharityTotal; // in tokens\\n    bool private tradeStarted;\\n    uint256 public charityLimit;\\n    uint256 private lastDailyUpdate;\\n    uint256 private rewardTotal = (MAX - (MAX % TOKEN_TOTAL));\\n    uint256 private cachedRate = rewardTotal / TOKEN_TOTAL;\\n\\n    IGainSweepstakes public sweepstake;\\n    IGainProtocolTransferListener public governance =\\n        IGainProtocolTransferListener(0);\\n    GainPriceFeed public priceFeed;\\n    IUniswapV2Router02 public immutable override uniswapV2Router;\\n    IUniswapV2Pair public immutable override uniswapV2Pair;\\n\\n    // Parameters\\n\\n    uint256 public maxTxAmount = 5000 * 10**6 * 10**9; // 0.5% from total\\n    uint256 private numTokensSellToAddToLiquidity = 500 * 10**6 * 10**9; // 0.05% from total\\n    // Will be changed manually once there is enough liquidity, as we need a bigger K at start, regardless of percent\\n    uint256 private liquidityTargetPercentStart = 2500; // 25%\\n    uint256 private liquidityTargetPercentEnd = 3000; // 30%\\n    uint256 public dailyCharityLimitUSD = 10000;\\n\\n    uint256 private sweepstakeTaxPercentage = 150; // 1.5%\\n    uint256 private liquidityTaxPercentage = 190; // 1.9%\\n    uint256 private rewardTaxPercentage = 300; // 3%\\n    uint256 private charityTaxPercentage = 25; // 0.25%\\n    uint256 private hodlTaxPercentage = 25; // 0.25%\\n    uint256 private teamTaxPercentage = 10; // 0.1%\\n\\n    uint256 public sweepstakeLockTime = 7 * 24 * 60 * 60; // 30 days\\n\\n    uint256 public whaleProtectionPercentFromLP = 200; // 2%\\n    bool private swapAndLiquifyEnabled = true;\\n    bool private dynamicSwapAndLiquifyEnabled = false;\\n    bool private whaleProtectionEnabled = true;\\n    bool private taxesEnabled = true;\\n    bool private associatesEnabled = true;\\n    address public teamWallet;\\n\\n    // Events\\n    event GiveBack(address from, uint256 amount);\\n    event GiveBackHodl(address from, uint256 amount);\\n    event TokensLocked(address owner, uint256 amount, uint256 duration);\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event WhaleProtectionUpdated(bool enabled);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 bnbReceived,\\n        uint256 bnbIntoLiquidity,\\n        uint256 tokensIntoLiquidity\\n    );\\n    event RemoveFromLiquidityAndReward(\\n        uint256 tokenRemovedFromLiquidity,\\n        uint256 bnbRemovedFromLiquidity,\\n        uint256 tokenRewarded\\n    );\\n    event SellerFeesCollected(\\n        uint256 reward,\\n        uint256 hodl,\\n        uint256 charity,\\n        uint256 whaleProtection\\n    );\\n\\n    event NoFeesTransfer(address from, address to, uint256 tokenAmount);\\n\\n    event BuyerFeesCollected(\\n        uint256 liquidity,\\n        uint256 sweepstake,\\n        uint256 team\\n    );\\n    event WhaleProtectionFeeCollected(uint256 amount);\\n\\n    // Modifiers\\n    modifier lockTheSwap() {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    modifier inSweepstakeLock() {\\n        inSweepstake = true;\\n        _;\\n        inSweepstake = false;\\n    }\\n\\n    // section: externals\\n\\n    function getTaxes()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            sweepstakeTaxPercentage,\\n            liquidityTaxPercentage,\\n            rewardTaxPercentage,\\n            charityTaxPercentage,\\n            hodlTaxPercentage,\\n            teamTaxPercentage\\n        );\\n    }\\n\\n    /**\\n     * @dev Get total sweepstake token distributed so far\\n     */\\n    function collectedSweepstake() external view override returns (uint256) {\\n        return collectedSweepstakeTotal.add(availableSweepstake());\\n    }\\n\\n    /**\\n     * @dev Get all time liquidity collected\\n     */\\n    function collectedLiquidity() external view override returns (uint256) {\\n        return collectedLiquidityTotal.add(availableLiquidity());\\n    }\\n\\n    /**\\n     * @dev Get all time collected charity\\n     */\\n    function collectedCharity() external view override returns (uint256) {\\n        return collectedCharityTotal.add(availableCharity());\\n    }\\n\\n    /**\\n     * @dev Get all time collected team fee\\n     */\\n    function collectedTeamFee() external view override returns (uint256) {\\n        return collectedTeamFeeTotal;\\n    }\\n\\n    /**\\n     * @dev Get all time collected whale fee\\n     */\\n    function collectedWhaleFee() external view override returns (uint256) {\\n        return collectedWhaleTotal;\\n    }\\n\\n    /**\\n     * @dev Get all time collected hodl reward\\n     */\\n    function collectedHodlReward() external view override returns (uint256) {\\n        return collectedHodlRewardTotal;\\n    }\\n\\n    /**\\n     * @dev Get all time collected reward (without whale fee)\\n     */\\n\\n    function collectedReward() external view override returns (uint256) {\\n        return collectedRewardTotal.sub(collectedWhaleTotal);\\n    }\\n\\n    /**\\n     * @dev Get sold liquidity\\n     */\\n    function soldLiquidity() external view override returns (uint256) {\\n        return soldLiquidityTotal;\\n    }\\n\\n    /**\\n     * @dev Get next sweepstake jackpot\\n     */\\n    function availableSweepstake() public view override returns (uint256) {\\n        return tokenFromReflection(rAvailableSweepstake);\\n    }\\n\\n    /**\\n     * @dev Get charity available\\n     */\\n    function availableCharity() public view override returns (uint256) {\\n        return tokenFromReflection(rAvailableCharity);\\n    }\\n\\n    /**\\n     * @dev Get available liquidity (to be added to LP)\\n     */\\n    function availableLiquidity() public view override returns (uint256) {\\n        return tokenFromReflection(rAvailableLiquidity);\\n    }\\n\\n    /**\\n     * @dev allows a user to give funds to reward all other users\\n     *      This is better then burning :)\\n     */\\n    function giveBack(uint256 _tAmount) external override {\\n        address sender = _msgSender();\\n        uint256 rAmount = _tAmount.mul(cachedRate);\\n        // Try to liquidate hodl tokens if needed.\\n        _removeTokensFromHodlForBalanceIfNeeded(sender, _tAmount);\\n\\n        owners[sender].balance = owners[sender].balance.sub(\\n            rAmount,\\n            \\\"You don\\u0027t have enough funds\\\"\\n        );\\n        if (isExcludedFromReward[sender]) {\\n            tokenOwned[sender] = tokenOwned[sender].sub(_tAmount);\\n        }\\n        _reflectReward(_tAmount, rAmount);\\n        emit GiveBack(sender, _tAmount);\\n    }\\n\\n    /**\\n     * @dev allows a user to give funds to reward all other users (hodl version)\\n     *      This is better then burning :)\\n     */\\n    function giveBackHodl(uint256 _tAmount) external override {\\n        address sender = _msgSender();\\n        uint256 rAmount = _tAmount.mul(cachedRate);\\n\\n        // Try to liquidate hodl tokens if needed.\\n        _removeTokensFromHodlForBalanceIfNeeded(sender, _tAmount);\\n\\n        owners[sender].balance = owners[sender].balance.sub(\\n            rAmount,\\n            \\\"You don\\u0027t have enough funds\\\"\\n        );\\n        if (isExcludedFromReward[sender]) {\\n            tokenOwned[sender] = tokenOwned[sender].sub(_tAmount);\\n        }\\n        _reflectHodlFee(_tAmount, rAmount);\\n        emit GiveBackHodl(sender, _tAmount);\\n    }\\n\\n    /**\\n     * @dev Set an associate for this wallet. this cannot be changed later\\n     *   _associate: wallet address\\n     */\\n    function setAssociate(address _associate) external override {\\n        _setAssociate(_msgSender(), _associate);\\n    }\\n\\n    function _setAssociate(address _sender, address _associate) private {\\n        if (associateRequest[_associate] != _sender) {\\n            associateRequest[_sender] = _associate;\\n            return;\\n        }\\n        require(\\n            associateOf[_sender] == address(0) \\u0026\\u0026\\n                associateOf[_associate] == address(0),\\n            \\\"Cannot change associate\\\"\\n        );\\n\\n        require(\\n            !isAssociateBlackList[_associate] \\u0026\\u0026 !isAssociateBlackList[_sender],\\n            \\\"This address is blacklisted\\\"\\n        );\\n\\n        associateOf[_sender] = _associate;\\n        associateOf[_associate] = _sender;\\n    }\\n\\n    /**\\n     * @dev run sweepstake. using inSweepstakeLock to avoid swapAndLiquify in sweepstake as it\\u0027s pretty heavy as is\\n     */\\n    function startDraw() external override inSweepstakeLock {\\n        uint256 startGas = gasleft();\\n        sweepstake.startDraw(tokenFromReflection(rAvailableSweepstake));\\n        uint256 gasSpent = startGas.sub(gasleft());\\n        // Try to transfer back the cost of running this function, fails quietly..\\n        uint256 bnbRefund = _min(\\n            _min(MAX_SWEEPSTAKE_REFUND, gasSpent.mul(tx.gasprice)),\\n            address(this).balance\\n        );\\n        _msgSender().transfer(bnbRefund);\\n    }\\n\\n    /**\\n     * @dev get total transfers done today of an account\\n     */\\n\\n    function dailyTransfersOf(address _account)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 dayIndex = block.timestamp.div(1 days);\\n\\n        if (owners[_account].dailyTransferLastUpdatedDay != dayIndex) {\\n            return 0;\\n        }\\n        return owners[_account].dailyTransfers;\\n    }\\n\\n    /**\\n     * @dev Enable sending BNB to contract. can be helpful in the future for balancing liquidity.\\n     * Also needed to get BNB from uniswapV2Router when swapping\\n     */\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Returns hodl tokens, and total hodl tokens. divided one by the other to get hodl reward percent\\n     * @return hodlTokens _account holding\\n     * @return hodlTokenSupply total hodl supply\\n     */\\n    function hodlTokensOf(address _account)\\n        external\\n        view\\n        override\\n        returns (uint256 hodlTokens, uint256 hodlTokenSupply)\\n    {\\n        hodlTokens = owners[_account].hodlTokens;\\n        hodlTokenSupply = hodlTotalSupply;\\n    }\\n\\n    /**\\n     * @dev Transfer _tAmount tokens for _to, which will be locked for _lockPeriodSeconds seconds\\n     */\\n\\n    function lockedTransfer(\\n        address _to,\\n        uint256 _tAmount,\\n        uint256 _lockPeriodSeconds\\n    ) external override {\\n        _lockedTransfer(_msgSender(), _to, _tAmount, _lockPeriodSeconds);\\n    }\\n\\n    /**\\n     * @dev Allows to lock _tAmount for _lockPeriodSeconds seconds. relative part will be released on an\\n     *      hourly basis\\n     */\\n    function lockTokens(uint256 _tAmount, uint256 _lockPeriodSeconds)\\n        external\\n        override\\n    {\\n        _lockReflection(\\n            _msgSender(),\\n            reflectionFromToken(_tAmount),\\n            _lockPeriodSeconds\\n        );\\n    }\\n\\n    /**\\n     * @dev Get when the locked tokens will be released\\n     */\\n    function lockedBalanceReleaseDate(address _account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 lockEndTime = owners[_account].lockedEndTime;\\n        return lockEndTime \\u003e block.timestamp ? lockEndTime : block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Get how much tokens are locked for the user\\n     */\\n    function lockedBalanceOf(address _account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return tokenFromReflection(_getLockedReflectionOf(_account));\\n    }\\n\\n    /**\\n     * @dev Calculate fee for a transaction - public function\\n     */\\n    function calculateFees(\\n        address _sender,\\n        address _recipient,\\n        uint256 _tAmount\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 liquidityFee,\\n            uint256 sweepstakeFee,\\n            uint256 teamFee,\\n            uint256 charityFee,\\n            uint256 rewardFee,\\n            uint256 hodlFee,\\n            uint256 whaleProtectionFee\\n        )\\n    {\\n        Fees memory fees = _calculateFees(_sender, _recipient, _tAmount);\\n        liquidityFee = fees.liquidity;\\n        sweepstakeFee = fees.sweepstake;\\n        teamFee = fees.team;\\n        charityFee = fees.charity;\\n        rewardFee = fees.reward;\\n        hodlFee = fees.hodl;\\n        whaleProtectionFee = fees.whaleProtection;\\n    }\\n\\n    // section: externals - onlyOwner\\n\\n    /**\\n     * Sets the team wallet to transfer team motivation funds\\n     */\\n    function setTeamWallet(address _account) external onlyOwner {\\n        teamWallet = _account;\\n    }\\n\\n    /**\\n     * @dev Set the number of tokens to liquify at once\\n     *      We will probably lower this value in the future\\n     *      to avoid too much price drop when swapping\\n     */\\n    function setNumTokensSellToAddToLiquidity(uint256 _value)\\n        external\\n        onlyOwner\\n    {\\n        numTokensSellToAddToLiquidity = _value;\\n    }\\n\\n    /**\\n     * @dev Set Maximum tx amount\\n     */\\n    function setMaxTxAmount(uint256 _value) external onlyOwner {\\n        maxTxAmount = _value;\\n    }\\n\\n    /**\\n     * @dev When a user wins a sweepstake, the win funds are locked for a few days.\\n     * _value: the number of days to lock sweepstake winnings\\n     */\\n    function setSweepstakeLockTime(uint256 _value) external onlyOwner {\\n        sweepstakeLockTime = _value;\\n    }\\n\\n    /**\\n     * @dev if dynamic liquidity is enabled, sets limits. see explanations above\\n     * _values: range [start, end]\\n     */\\n    function setLiquidityTarget(uint256 _start, uint256 _end)\\n        external\\n        onlyOwner\\n    {\\n        liquidityTargetPercentStart = _start;\\n        liquidityTargetPercentEnd = _end;\\n    }\\n\\n    /**\\n     * @dev Override the associate for a wallet.\\n     * In case there will be a future Gain Protocol wallet, we will use this to allow transfers to the new wallet.\\n     * Note: This is LESS strong then excludeFromFee.\\n     * can only be called by owner\\n     * _from: The wallet to change the associate for.\\n     * _associate: The new associate wallet.\\n     */\\n    function overrideAssociate(address _from, address _associate)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        associateOf[_from] = _associate;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Limits the maximum daily charity collected (in USD)\\n     * _value: amount in USD\\n     */\\n\\n    function setCharityLimitUSD(uint256 _value) external onlyOwner {\\n        dailyCharityLimitUSD = _value;\\n        (, uint256 value) = priceFeed.gainsForUSD(_value);\\n        charityLimit = value;\\n    }\\n\\n    /**\\n     * @dev changes the taxes being collected. cannot add up to more then 10%\\n     */\\n\\n    function setTaxPercentage(\\n        uint16 _sweepstake,\\n        uint16 _liquidity,\\n        uint16 _reward,\\n        uint16 _charity,\\n        uint16 _hodl,\\n        uint16 _team\\n    ) external onlyOwner {\\n        require(_sweepstake + _liquidity + _team \\u003c= 350, \\\"Max 3.5% tax\\\");\\n        require(_reward + _charity + _hodl \\u003c= 350, \\\"Max 3.5% tax\\\");\\n        sweepstakeTaxPercentage = _sweepstake;\\n        liquidityTaxPercentage = _liquidity;\\n        rewardTaxPercentage = _reward;\\n        charityTaxPercentage = _charity;\\n        hodlTaxPercentage = _hodl;\\n        teamTaxPercentage = _team;\\n    }\\n\\n    /**\\n     * @dev set when to take whale protection fee. this is the percent from the total GAINs in the LP.\\n     * value is compared for a user daily sells (see whale protection mechanism)\\n     * _value - Percent from LP\\n     */\\n    function setWhaleProtectionPercentFromLP(uint256 _value)\\n        external\\n        onlyOwner\\n    {\\n        whaleProtectionPercentFromLP = _value;\\n    }\\n\\n    /**\\n     * @dev enables dynamic swap and liquify (see dynamic liquidity above)\\n     */\\n    function setDynamicSwapAndLiquifyEnabled(bool _value) external onlyOwner {\\n        dynamicSwapAndLiquifyEnabled = _value;\\n    }\\n\\n    /**\\n     * @dev set price feed contract address\\n     * _priceFeed contract address\\n     */\\n    function setPriceFeed(GainPriceFeed _priceFeed) external onlyOwner {\\n        priceFeed = _priceFeed;\\n    }\\n\\n    /**\\n     * @dev Exclude account from fee. exclude every transaction this account is a part of from ALL fees\\n     */\\n    function excludeFromFee(address _account, bool _isExcluded)\\n        external\\n        onlyOwner\\n    {\\n        isExcludedFromFee[_account] = _isExcluded;\\n    }\\n\\n    /**\\n     * @dev Exclude account from buy fee. seller fee will be taken (unless it\\u0027s also excluded)\\n     */\\n    function excludeFromBuyFee(address _account, bool _isExcluded)\\n        external\\n        onlyOwner\\n    {\\n        isExcludedFromBuyFee[_account] = _isExcluded;\\n    }\\n\\n    /**\\n     * @dev Add account to associate blacklist so it cannot be added as associate (for example: PancakeSwap)\\n     */\\n    function blackListFromAssociate(address _account, bool _isBlackListed)\\n        external\\n        onlyOwner\\n    {\\n        isAssociateBlackList[_account] = _isBlackListed;\\n    }\\n\\n    /**\\n     * @dev Exclude account from whale protection. will be used for\\n     *      address(this) and possibly for exchanges if needed in the future\\n     */\\n    function excludeFromWhaleProtection(address _account, bool _isExclude)\\n        external\\n        onlyOwner\\n    {\\n        isExcludedFromWhaleProtectionFee[_account] = _isExclude;\\n    }\\n\\n    /**\\n     * @dev Exclude account from sell fee. buyer fee will be taken (unless it\\u0027s also excluded)\\n     */\\n    function excludeFromSellFee(address _account, bool _isExclude)\\n        external\\n        onlyOwner\\n    {\\n        isExcludedFromSellFee[_account] = _isExclude;\\n    }\\n\\n    /**\\n     * @dev Used in case we will change the sweepstake mechanism (unlikely)\\n     */\\n    function setSweepstakeAddress(IGainSweepstakes _newSweepstake)\\n        external\\n        onlyOwner\\n    {\\n        sweepstake = _newSweepstake;\\n    }\\n\\n    /**\\n     * @dev Used when we have our governance contract ready\\n     */\\n    function setGovernanceAddress(IGainProtocolTransferListener _governance)\\n        external\\n        onlyOwner\\n    {\\n        governance = _governance;\\n    }\\n\\n    /**\\n     * @dev Disable/enable taxes (will be used in ICO)\\n     */\\n    function setTaxesEnabled(bool _enabled) external onlyOwner {\\n        taxesEnabled = _enabled;\\n    }\\n\\n    /**\\n     * @dev Disable/enable associates\\n     */\\n    function setAssociatesEnabled(bool _enabled) external onlyOwner {\\n        associatesEnabled = _enabled;\\n    }\\n\\n    /**\\n     * @dev Enable/disable Auto LP. can only be called by owner\\n     *      _enabled: new state\\n     */\\n\\n    function setSwapAndLiquifyEnabled(bool _enabled) external onlyOwner {\\n        swapAndLiquifyEnabled = _enabled;\\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\\n    }\\n\\n    /**\\n     * @dev will be used after ICO\\n     */\\n    function startTrade() external onlyOwner {\\n        tradeStarted = true;\\n    }\\n\\n    /**\\n     * @dev Enable/disable whale protection. can only be called by owner\\n     *      _enabled: new state\\n     */\\n\\n    function setWhaleProtectionEnabled(bool _enabled) external onlyOwner {\\n        whaleProtectionEnabled = _enabled;\\n        emit WhaleProtectionUpdated(_enabled);\\n    }\\n\\n    /**\\n     * @dev exclude an account from getting a reward and hodl\\n     */\\n    function excludeFromReward(address _account, bool _isExcluded)\\n        external\\n        onlyOwner\\n    {\\n        if (_isExcluded) {\\n            _excludeFromReward(_account);\\n        } else {\\n            _includeInReward(_account);\\n        }\\n    }\\n\\n    /**\\n     * @dev exclude an account from getting a reward and hodl\\n     */\\n    function _excludeFromReward(address _account) private {\\n        require(_account != address(this), \\\"Cannot exclude\\\");\\n        require(!isExcludedFromReward[_account], \\\"Already excluded\\\");\\n        _removeTokensFromHodl(_account);\\n        if (owners[_account].balance \\u003e 0) {\\n            tokenOwned[_account] = tokenFromReflection(\\n                owners[_account].balance\\n            );\\n        }\\n        isExcludedFromReward[_account] = true;\\n        excludedFromReward.push(_account);\\n    }\\n\\n    /**\\n     * @dev reverts previous function\\n     */\\n    function _includeInReward(address _account) private {\\n        require(isExcludedFromReward[_account], \\\"Already included\\\");\\n        for (uint256 i = 0; i \\u003c excludedFromReward.length; i++) {\\n            if (excludedFromReward[i] == _account) {\\n                // As in time, balance lost sync with tokenOwned, calculate new balance\\n                uint256 newBalance = reflectionFromToken(tokenOwned[_account]);\\n                // Adjust reward total to fit the new balance\\n                rewardTotal = rewardTotal.sub(owners[_account].balance).add(\\n                    newBalance\\n                );\\n                owners[_account].balance = newBalance;\\n\\n                excludedFromReward[i] = excludedFromReward[\\n                    excludedFromReward.length - 1\\n                ];\\n                tokenOwned[_account] = 0;\\n                isExcludedFromReward[_account] = false;\\n                excludedFromReward.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw charity to some address\\n     */\\n    function withdrawCharity(address _to) external onlyOwner lockTheSwap {\\n        uint256 charityInTokens = tokenFromReflection(rAvailableCharity);\\n        rAvailableCharity = 0;\\n        _transfer(address(this), _to, charityInTokens);\\n        collectedCharityTotal = collectedCharityTotal.add(charityInTokens);\\n    }\\n\\n    // section: public\\n\\n    /**\\n     * @dev Returns the state (on/off) of the following features: swapAndLiquify, dynamicSwapAndLiquify, whaleProtection, taxes, associates.\\n     * @return swapAndLiquify\\n     * @return dynamicSwapAndLiquify\\n     * @return whaleProtection\\n     * @return taxes\\n     * @return associates\\n     */\\n    function featuresState()\\n        external\\n        view\\n        returns (\\n            bool swapAndLiquify,\\n            bool dynamicSwapAndLiquify,\\n            bool whaleProtection,\\n            bool taxes,\\n            bool associates\\n        )\\n    {\\n        swapAndLiquify = swapAndLiquifyEnabled;\\n        dynamicSwapAndLiquify = dynamicSwapAndLiquifyEnabled;\\n        whaleProtection = whaleProtectionEnabled;\\n        taxes = taxesEnabled;\\n        associates = associatesEnabled;\\n    }\\n\\n    /**\\n     * @dev Return current liquidity control parameters value\\n     * @return numTokensSell How much tokens to accumulate before swap and liquify\\n     * @return liquidityTargetStart Dynamic liquidity start range (percent)\\n     * @return liquidityTargetEnd  Dynamic liquidity end range (percent)\\n     */\\n    function liquidityParams()\\n        external\\n        view\\n        returns (\\n            uint256 numTokensSell,\\n            uint256 liquidityTargetStart,\\n            uint256 liquidityTargetEnd\\n        )\\n    {\\n        numTokensSell = numTokensSellToAddToLiquidity;\\n        liquidityTargetStart = liquidityTargetPercentStart;\\n        liquidityTargetEnd = liquidityTargetPercentEnd;\\n    }\\n\\n    /**\\n     * @dev convert reflection units to tokens\\n     */\\n    function tokenFromReflection(uint256 _rAmount)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        // solhint-disable-next-line reason-string\\n        require(_rAmount \\u003c= rewardTotal, \\\"\\u003e total reflections\\\");\\n        return _rAmount.div(cachedRate);\\n    }\\n\\n    /**\\n     * @dev convert token units to reflection\\n     */\\n    function reflectionFromToken(uint256 _tAmount)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        require(_tAmount \\u003c= TOKEN_TOTAL, \\\"\\u003e total tokens\\\");\\n        return _tAmount.mul(cachedRate);\\n    }\\n\\n    // section: special externals\\n\\n    /**\\n     * @dev transfer sweepstake funds to winners. can only be called by sweepstake contract\\n     */\\n    function transferSweepstake(address _winner, uint256 _tAmount)\\n        external\\n        override\\n    {\\n        require(_msgSender() == address(sweepstake), \\\"Invalid sender\\\");\\n        uint256 rAmount = reflectionFromToken(_tAmount);\\n        rAvailableSweepstake = rAvailableSweepstake.sub(rAmount);\\n        collectedSweepstakeTotal = collectedSweepstakeTotal.add(_tAmount);\\n        // This must be called last, as it will change cachedRate\\n        _lockedTransfer(address(this), _winner, _tAmount, sweepstakeLockTime);\\n    }\\n\\n    // section: IERC20\\n\\n    constructor(address _routerAddrs, IGainSweepstakes _sweepstake) public {\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_routerAddrs);\\n        // Create a uniswap pair for this new token\\n\\n        address pairAddress = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n        uniswapV2Pair = IUniswapV2Pair(pairAddress);\\n\\n        // set the rest of the contract variables\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        sweepstake = _sweepstake;\\n        sweepstake.setParentERC(this);\\n        sweepstake.initialTransfer(_msgSender(), TOKEN_TOTAL);\\n\\n        owners[_msgSender()].balance = rewardTotal;\\n        owners[_msgSender()].excludedFromHodlReward = true;\\n        owners[address(0xDEAD)].excludedFromHodlReward = true;\\n        owners[address(this)].excludedFromHodlReward = true;\\n        isExcludedFromBuyFee[address(this)] = true;\\n        isExcludedFromSellFee[address(this)] = true;\\n\\n        emit Transfer(address(0), _msgSender(), TOKEN_TOTAL);\\n    }\\n\\n    /**\\n     * @dev Token name\\n     */\\n\\n    function name() external pure returns (string memory) {\\n        return NAME;\\n    }\\n\\n    /**\\n     * @dev Token symbol\\n     */\\n\\n    function symbol() external pure returns (string memory) {\\n        return SYMBOL;\\n    }\\n\\n    /**\\n     * @dev Token decimal point\\n     */\\n\\n    function decimals() external pure returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    /**\\n     * @dev Token total supply (doesn\\u0027t change)\\n     */\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return TOKEN_TOTAL;\\n    }\\n\\n    /**\\n     * @dev Get how much _spender can spend from _owners wallet\\n     * _owner: owners address\\n     * _spender: spender address\\n     */\\n\\n    function allowance(address _owner, address _spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowances[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Approve _spender to spend _amount from callers wallet. this overrides previous allowance\\n     * _spender: spender address\\n     * _amount: token quantity\\n     */\\n\\n    function approve(address _spender, uint256 _amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the balance of a wallet, in tokens.\\n     * @param _account: wallet address\\n     */\\n\\n    function balanceOf(address _account)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        // If reflection is disabled - take token count\\n        if (isExcludedFromReward[_account]) {\\n            return tokenOwned[_account];\\n        }\\n        // Converted here to prevent overflow\\n        uint256 hodlRewardTokens = rHodlersRewardPool.div(cachedRate);\\n        uint256 hodlTokens = owners[_account].hodlTokens;\\n        uint256 hodlReward = hodlTotalSupply \\u003e 0\\n            ? hodlRewardTokens.mul(hodlTokens).div(hodlTotalSupply)\\n            : 0;\\n\\n        return owners[_account].balance.div(cachedRate).add(hodlReward);\\n    }\\n\\n    /**\\n     * @dev Transfer _amount tokens to _recipient\\n     */\\n    function transfer(address _recipient, uint256 _amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), _recipient, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev transfer from _sender to _recipient, _amount tokens. will only work if approve was called before\\n     */\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) external override returns (bool) {\\n        _transfer(_sender, _recipient, _amount);\\n        _approve(\\n            _sender,\\n            _msgSender(),\\n            allowances[_sender][_msgSender()].sub(\\n                _amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    // section: internal functions\\n\\n    /**\\n     * @dev internal method for approve\\n     */\\n    function _approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _amount\\n    ) private {\\n        require(_owner != address(0), \\\"ERC20: approve from zero address\\\");\\n        require(_spender != address(0), \\\"ERC20: approve to zero address\\\");\\n\\n        allowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /**\\n     * @dev get current rate (ratio between reflection and tokens)\\n     */\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply.div(tSupply);\\n    }\\n\\n    /**\\n     * @dev Returns total reward and total tokens (excluding tokens and reward held by excluded from reward users)\\n     */\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = rewardTotal;\\n        uint256 tSupply = TOKEN_TOTAL;\\n        for (uint256 i = 0; i \\u003c excludedFromReward.length; i++) {\\n            if (\\n                owners[excludedFromReward[i]].balance \\u003e rSupply ||\\n                tokenOwned[excludedFromReward[i]] \\u003e tSupply\\n            ) return (rewardTotal, TOKEN_TOTAL);\\n            rSupply = rSupply.sub(owners[excludedFromReward[i]].balance);\\n            tSupply = tSupply.sub(tokenOwned[excludedFromReward[i]]);\\n        }\\n        if (rSupply \\u003c rewardTotal.div(TOKEN_TOTAL)) {\\n            return (rewardTotal, TOKEN_TOTAL);\\n        }\\n        return (rSupply, tSupply);\\n    }\\n\\n    /**\\n     * @dev internal transfer function\\n     * @return The amount of *reflection* added to the receiver (returning reflection as token\\n     *         is less viable as reward changes in the function)\\n     */\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) private returns (uint256) {\\n        // THIS IS A WORKAROUND!! see _swapBNBForTokens\\n        if (_to == address(1) \\u0026\\u0026 inSwapAndLiquify) {\\n            _to = address(this);\\n        }\\n        // This is like calling setAssociate, but can be used when you can\\u0027t call the contract function (like when using an exchange)\\n        if (associateRequest[_to] == _from \\u0026\\u0026 _amount == 777771234) {\\n            _setAssociate(_from, _to);\\n            emit Transfer(_from, _to, 0);\\n            return 0;\\n        }\\n        require(_from != address(0), \\\"ERC20: transfer from zero addrs\\\");\\n        require(_to != address(0), \\\"ERC20: transfer to zero address\\\");\\n        require(_amount \\u003e 0, \\\"Transfer amount must be \\u003e 0\\\");\\n        // Instead of adding ANOTHER list of people allowed to trade, we just use isExcludedFromFee (which can only be added by owner)\\n        require(tradeStarted || isExcludedFromFee[_from], \\\"Trade not started\\\");\\n\\n        // Needed for ICO\\n        if (_from != owner() \\u0026\\u0026 _to != owner()) {\\n            require(_amount \\u003c= maxTxAmount, \\\"Transfer amount exceeds maxTx\\\");\\n        }\\n\\n        if (\\n            _from != address(uniswapV2Pair) \\u0026\\u0026\\n            !inSweepstake \\u0026\\u0026\\n            !inSwapAndLiquify\\n        ) {\\n            _handleLiquify();\\n        }\\n\\n        // Update data that needs to be updated on a daily basis\\n        _updateDailyData();\\n\\n        //transfer amount\\n        return _tokenTransfer(_from, _to, _amount);\\n    }\\n\\n    /**\\n     * @dev Update charity limit from USD value\\n     */\\n    function _updateDailyData() private {\\n        uint256 dayIndex = block.timestamp.div(1 days);\\n        if (dayIndex != lastDailyUpdate) {\\n            // Ignoring success, because with an error, value = 0, and that\\u0027s OK for us..\\n            // Note: Until there will be a working LP, the value here will be 0..\\n            (, uint256 value) = priceFeed.gainsForUSD(dailyCharityLimitUSD);\\n            charityLimit = value;\\n            rDailyCharity = 0;\\n            lastDailyUpdate = dayIndex;\\n        }\\n    }\\n\\n    /**\\n     * @dev all liquify related handling,\\n     *      will liquify or un-liquify (for dynamic liquidity) if needed\\n     */\\n    function _handleLiquify() private {\\n        // Get tokens ready for liquify\\n        uint256 tokensWaitingForLiquidity = rAvailableLiquidity.div(cachedRate);\\n\\n        // liquify if needed\\n        bool overMinTokenBalance = tokensWaitingForLiquidity \\u003e=\\n            numTokensSellToAddToLiquidity;\\n        if (overMinTokenBalance \\u0026\\u0026 swapAndLiquifyEnabled) {\\n            // add liquidity\\n            _swapAndLiquify(numTokensSellToAddToLiquidity);\\n        }\\n\\n        // Dynamic liquidity\\n        uint256 neededMaxLiquidity = _percent(\\n            TOKEN_TOTAL,\\n            liquidityTargetPercentEnd\\n        );\\n        if (\\n            dynamicSwapAndLiquifyEnabled \\u0026\\u0026\\n            _getLiquidity() \\u003e= neededMaxLiquidity\\n        ) {\\n            _removeFromLiquidityAndReward(numTokensSellToAddToLiquidity);\\n        }\\n    }\\n\\n    /**\\n     * @dev Get LP reserves for GAIN/BNB\\n     * returns (gainReserve, BNBReserve)\\n     */\\n    function _getReserves() private view returns (uint256, uint256) {\\n        (uint112 reserve0, uint112 reserve1, ) = uniswapV2Pair.getReserves();\\n        return\\n            uniswapV2Pair.token0() == address(this)\\n                ? (reserve0, reserve1)\\n                : (reserve1, reserve0);\\n    }\\n\\n    /**\\n     * @dev swap GAINS for BNB, and add the resulting tokens to liquidity\\n     * if there are hanging BNBs - use them also\\n     */\\n    function _swapAndLiquify(uint256 tokensToLiquify) private lockTheSwap {\\n        (uint256 gainReserve, uint256 bnbReserve) = _getReserves();\\n        if (gainReserve == 0 || bnbReserve == 0) {\\n            // No LP yet, this will fail..\\n            return;\\n        }\\n        // Try to keep the balance above MAX_SWEEPSTAKE_REFUND\\n        uint256 balanceBefore = address(this).balance;\\n        (, uint256 balance) = balanceBefore.trySub(\\n            MAX_SWEEPSTAKE_REFUND.mul(5)\\n        );\\n        // We will also add this to liquidity, don\\u0027t need BNB seating around..\\n        uint256 balanceInGains = balance.mul(gainReserve).div(bnbReserve);\\n        uint256 toConvert = tokensToLiquify \\u003e balanceInGains\\n            ? tokensToLiquify.sub(balanceInGains).div(2)\\n            : 0;\\n        uint256 otherHalf = tokensToLiquify.sub(toConvert);\\n\\n        // swap tokens for BNB\\n        if (toConvert \\u003e 0) {\\n            _swapTokensForBNB(toConvert);\\n        }\\n        uint256 receivedBNBs = address(this).balance.sub(balanceBefore);\\n\\n        // add liquidity to uniswap\\n        // There should never be any BNB left in the contract\\n        uint256 balanceBeforeLiquify = address(this).balance;\\n        (uint256 amountTokenAdded, ) = _addLiquidity(\\n            otherHalf,\\n            address(this).balance\\n        );\\n        collectedLiquidityTotal = collectedLiquidityTotal\\n            .add(amountTokenAdded)\\n            .add(toConvert);\\n\\n        rAvailableLiquidity = rAvailableLiquidity.sub(\\n            amountTokenAdded.add(toConvert).mul(cachedRate)\\n        );\\n\\n        emit SwapAndLiquify(\\n            toConvert,\\n            receivedBNBs,\\n            balanceBeforeLiquify.sub(address(this).balance),\\n            otherHalf\\n        );\\n    }\\n\\n    /**\\n     * @dev There is too much liquidity (as defined by liquidityTargetPercentEnd)\\n     * this (should) mean a lot of accounts are selling their GAINs.\\n     * so remove liquidity (which will give us BNBs and GAINs), then buy GAINs with the BNBs.\\n     * This gives us a side effect of raising GAIN price (which balances out the sells)\\n     * and we use the resulting GAINs to reward all users (reflection).\\n     * So basically - what we do here is use the tax we collected (which was put into the liquidity)\\n     * when no longer needed to help our holders.\\n     * This can be viewed as some kind of insurance - we collect a fee when everything is great\\n     * but when dark days come, we use that money to help out holders to keep their profits\\n     */\\n    function _removeFromLiquidityAndReward(uint256 _tokensToRemoveFromLiquidity)\\n        private\\n        lockTheSwap\\n    {\\n        (uint256 amountToken, uint256 amountBNB) = _removeLiquidity(\\n            _tokensToRemoveFromLiquidity.div(2)\\n        );\\n        if (amountToken == 0 || amountBNB == 0) {\\n            // Cannot remove liquidity\\n            return;\\n        }\\n        uint256 swappedTokens = _swapBNBForTokens(amountBNB);\\n        uint256 newRate = _getRate();\\n        uint256 totalTokens = swappedTokens.add(amountToken);\\n        owners[address(this)].balance = owners[address(this)].balance.sub(\\n            totalTokens.mul(newRate)\\n        );\\n        _reflectReward(totalTokens, totalTokens.mul(newRate));\\n        soldLiquidityTotal = soldLiquidityTotal.add(totalTokens);\\n        emit RemoveFromLiquidityAndReward(amountToken, amountBNB, totalTokens);\\n    }\\n\\n    /**\\n     * @dev send GAINs and get BNB\\n     */\\n    function _swapTokensForBNB(uint256 _tokenAmount) private {\\n        // generate the uniswap pair path of token -\\u003e weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), _tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            _tokenAmount,\\n            0, // accept any amount of BNB\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev send BNBs and get GAIN\\n     */\\n    function _swapBNBForTokens(uint256 _bnbAmount) private returns (uint256) {\\n        // generate the uniswap pair path of token -\\u003e weth\\n        address[] memory path = new address[](2);\\n        path[0] = uniswapV2Router.WETH();\\n        path[1] = address(this);\\n\\n        // make the swap\\n        uint256 balanceBefore = balanceOf(address(this));\\n\\n        // We put address(1) here because uniswap will fail\\n        // if we send to address(this) (UniswapV2: INVALID_TO).\\n        // due to that, we are forced to work around this, send to\\n        // address(1), and in _transfer, change address(1) to address(this)\\n        // This is a bit ugly, but i see no good alternative..\\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n            value: _bnbAmount\\n        }(0, path, address(1), block.timestamp);\\n        return balanceOf(address(this)).sub(balanceBefore);\\n    }\\n\\n    /**\\n     * @dev send BNBs and GAIN to LP\\n     */\\n    function _addLiquidity(uint256 _tokenAmount, uint256 _bnbAmount)\\n        private\\n        returns (uint256 amountToken, uint256 amountETH)\\n    {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(uniswapV2Router), _tokenAmount);\\n\\n        // add the liquidity\\n        (amountToken, amountETH, ) = uniswapV2Router.addLiquidityETH{\\n            value: _bnbAmount\\n        }(\\n            address(this),\\n            _tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Remove liquidity of gainAmount gains + BNB of the same value (total in gains: 2 * gainAmount)\\n     */\\n\\n    function _removeLiquidity(uint256 _gainAmount)\\n        private\\n        returns (uint256, uint256)\\n    {\\n        // Not using getLiquidity as we need updated balances, not reserves\\n        uint256 liquidity = balanceOf(address(uniswapV2Pair));\\n        uint256 liquidityNeeded = _gainAmount\\n            .mul(uniswapV2Pair.totalSupply())\\n            .div(liquidity);\\n\\n        // Just in case we are not the owner of all the liquidity\\n        liquidityNeeded = _min(\\n            uniswapV2Pair.balanceOf(address(this)),\\n            liquidityNeeded\\n        );\\n        if (liquidityNeeded == 0) {\\n            // No available liquidity\\n            return (0, 0);\\n        }\\n        uniswapV2Pair.approve(address(uniswapV2Router), liquidityNeeded);\\n        return\\n            uniswapV2Router.removeLiquidityETH(\\n                address(this),\\n                liquidityNeeded,\\n                0,\\n                0,\\n                address(this),\\n                block.timestamp\\n            );\\n    }\\n\\n    /**\\n     * @dev compare _amount to total liquidity (in GAINs), and return percentage\\n     */\\n    function _compareToLP(uint256 _amount) private view returns (uint256) {\\n        return _amount.mul(PERCENT_DIVIDER_FACTOR).div(_getLiquidity());\\n    }\\n\\n    /**\\n     * @dev Get liquidity (at GAINs side)\\n     */\\n    function _getLiquidity() private view returns (uint256) {\\n        (uint256 gainReserve, ) = priceFeed.getReserves();\\n        return gainReserve;\\n    }\\n\\n    /**\\n     * @dev Transfer _tAmount tokens from _from to _to, and lock them for _lockPeriodSeconds.\\n     * Relative amount will be released on an hourly basis\\n     */\\n    function _lockedTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _tAmount,\\n        uint256 _lockPeriodSeconds\\n    ) private {\\n        uint256 rTransferred = _transfer(_from, _to, _tAmount);\\n        // Add newly won reflection to locked balance\\n        /* NOTICE: there is a logical issue here:\\n            If we win 10000 tokens, and in 15 days another 10 token\\n            we now have 5010 tokens locked for 30 days, instead of 10 for 30 days and 5000 for 15 days\\n            we are OK with that..\\n        */\\n        _lockReflection(_to, rTransferred, _lockPeriodSeconds);\\n    }\\n\\n    /**\\n     * @dev lock _rAmount reflection for _account for _lockPeriodSeconds.\\n     *      Relative amount will be released on an hourly basis\\n     */\\n    function _lockReflection(\\n        address _account,\\n        uint256 _rAmount,\\n        uint256 _lockPeriodSeconds\\n    ) private {\\n        uint256 newLockTime = block.timestamp.add(_lockPeriodSeconds);\\n        // Prevent a situation where someone reduces his current lock\\n        // By locking some more tokens, for 1 seconds\\n\\n        newLockTime = _max(owners[_account].lockedEndTime, newLockTime);\\n        require(_lockPeriodSeconds \\u003e 0, \\\"Too short lock\\\");\\n        require(_rAmount \\u003e 0, \\\"Invalid parameter\\\");\\n        owners[_account].lockedBalance = _rAmount.add(\\n            _getLockedReflectionOf(_account) // in case he already has a locked amount\\n        );\\n        owners[_account].lockedStartTime = uint64(block.timestamp);\\n        owners[_account].lockedEndTime = uint64(newLockTime);\\n        emit TokensLocked(\\n            _account,\\n            tokenFromReflection(_rAmount),\\n            _lockPeriodSeconds\\n        );\\n    }\\n\\n    /**\\n     * @dev Get how much reflection is locked for the user\\n     */\\n    function _getLockedReflectionOf(address _account)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        uint256 lockEndTime = owners[_account].lockedEndTime;\\n        if (lockEndTime \\u003c= block.timestamp || lockEndTime == 0) {\\n            return 0;\\n        }\\n        uint256 timeSlotLeft = lockEndTime.sub(block.timestamp).div(1 hours);\\n        uint256 totalTimeSlots = lockEndTime\\n            .sub(owners[_account].lockedStartTime)\\n            .div(1 hours);\\n        // Doing here div before mul on purpose, because otherwise if someone has 0.1% of all tokens\\n        // (which happens in ICO), there will be an error. the reason is because 0.1% * (24 * 30) \\u003e 100% which is UINT_MAX.\\n        // Anyway, as totalTime is not that big, the inaccuracy doesn\\u0027t do that much of an effect\\n        // Also, this doesn\\u0027t effect user funds, only locked amount, so less critical\\n        return\\n            owners[_account].lockedBalance.div(totalTimeSlots).mul(\\n                timeSlotLeft\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculate fee for a transaction\\n     */\\n    function _calculateFees(\\n        address _sender,\\n        address _recipient,\\n        uint256 _tAmount\\n    ) private view returns (Fees memory) {\\n        {\\n            // Avoid stack too deep\\n            bool excludedFromFee = isExcludedFromFee[_sender] ||\\n                isExcludedFromFee[_recipient] ||\\n                (associateOf[_sender] == _recipient \\u0026\\u0026\\n                    !isAssociateBlackList[_recipient] \\u0026\\u0026\\n                    associatesEnabled);\\n            // Don\\u0027t take tax if taxes are disabled, or from swapAndLiquify\\n            if (!taxesEnabled || inSwapAndLiquify || excludedFromFee) {\\n                return\\n                    Fees({\\n                        liquidity: 0,\\n                        sweepstake: 0,\\n                        charity: 0,\\n                        team: 0,\\n                        hodl: 0,\\n                        reward: 0,\\n                        whaleProtection: 0\\n                    });\\n            }\\n        }\\n\\n        FeesPercentage memory feesP = FeesPercentage({\\n            liquidity: liquidityTaxPercentage,\\n            sweepstake: sweepstakeTaxPercentage,\\n            team: teamTaxPercentage,\\n            charity: charityTaxPercentage,\\n            hodl: hodlTaxPercentage,\\n            reward: rewardTaxPercentage,\\n            whaleProtection: 0\\n        });\\n        if (teamWallet == address(0)) {\\n            feesP.liquidity = feesP.liquidity.add(feesP.team);\\n            feesP.team = 0;\\n        }\\n\\n        if (isExcludedFromBuyFee[_recipient]) {\\n            // Remove only buy fee (for example: selling from PancakeSwap)\\n            feesP.sweepstake = 0;\\n            feesP.liquidity = 0;\\n            feesP.team = 0;\\n        } else if (\\n            dynamicSwapAndLiquifyEnabled \\u0026\\u0026\\n            _getLiquidity() \\u003e _percent(TOKEN_TOTAL, liquidityTargetPercentStart)\\n        ) {\\n            // No need to increase liquidity\\n            feesP.sweepstake = feesP.liquidity.add(feesP.sweepstake);\\n            feesP.liquidity = 0;\\n        }\\n\\n        if (isExcludedFromSellFee[_sender]) {\\n            // Remove only sell fee (for example: buying from PancakeSwap)\\n            feesP.charity = 0;\\n            feesP.hodl = 0;\\n            feesP.reward = 0;\\n        } else if (\\n            _getLiquidity() \\u003e 0 \\u0026\\u0026\\n            whaleProtectionEnabled \\u0026\\u0026\\n            !isExcludedFromWhaleProtectionFee[_sender]\\n        ) {\\n            uint256 percentRelativeToLP = _compareToLP(\\n                dailyTransfersOf(_sender).add(_tAmount)\\n            );\\n            if (percentRelativeToLP \\u003e whaleProtectionPercentFromLP) {\\n                uint256 diff = percentRelativeToLP.sub(\\n                    whaleProtectionPercentFromLP\\n                );\\n                // EXPONENT_PERCENT_DIVIDER moves one of the diff, from percentages, to multiplier\\n                // as 1% * 1% is actually 0.1% [and for that case, we should have divided by 10**4] (and not 1% which is what we are looking for).\\n                // So we do 1% * 1 or another example: 2% * 2 (and not  2% * 2%)\\n                // There is still a problem with anything below 1%, so for that range, we don\\u0027t **2\\n                feesP.whaleProtection = _min(\\n                    _max(diff.mul(diff).div(EXPONENT_PERCENT_DIVIDER), diff),\\n                    MAX_WHALE_FEE\\n                );\\n            }\\n        }\\n        uint256 charityFee = _percent(_tAmount, feesP.charity);\\n        uint256 hodlFee = _percent(_tAmount, feesP.hodl);\\n        uint256 tDailyCharity = rDailyCharity.div(cachedRate);\\n        if (tDailyCharity.add(charityFee) \\u003e charityLimit) {\\n            // Get the needed amount to get to the charity limit. if the limit is smaller\\n            // then daily charity (can happen if there was a manual update)\\n            // make sure there is no underflow (and take all fee to hodl)\\n            (, uint256 diff) = charityLimit.trySub(tDailyCharity);\\n            hodlFee = hodlFee.add(charityFee.sub(diff));\\n            charityFee = diff;\\n        }\\n        return\\n            Fees({\\n                liquidity: _percent(_tAmount, feesP.liquidity),\\n                sweepstake: _percent(_tAmount, feesP.sweepstake),\\n                team: _percent(_tAmount, feesP.team),\\n                charity: charityFee,\\n                reward: _percent(_tAmount, feesP.reward),\\n                hodl: hodlFee,\\n                whaleProtection: _percent(_tAmount, feesP.whaleProtection)\\n            });\\n    }\\n\\n    /**\\n     * @dev this method is responsible for taking all fees\\n     * @return The amount of *reflection* added to the receiver (returning reflection as token\\n     *         is less viable as reward changes in the function)\\n     */\\n    function _tokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _tAmount\\n    ) private returns (uint256) {\\n        // Reset daily transfer if day changes\\n        {\\n            // Avoid Stack too deep\\n\\n            uint256 dayIndex = block.timestamp.div(1 days);\\n            if (owners[_from].dailyTransferLastUpdatedDay != dayIndex) {\\n                owners[_from].dailyTransferLastUpdatedDay = uint64(dayIndex);\\n                owners[_from].dailyTransfers = 0;\\n            }\\n        }\\n\\n        Fees memory fees = _calculateFees(_from, _to, _tAmount);\\n        if (fees.whaleProtection \\u003e 0) {\\n            emit WhaleProtectionFeeCollected(fees.whaleProtection);\\n        }\\n        uint256 tSellerSold = _tAmount.add(_totalSellerFees(fees));\\n        uint256 tTransferAmount = _tAmount.sub(_totalBuyerFees(fees));\\n        uint256 rTransferAmount = tTransferAmount.mul(cachedRate);\\n\\n        owners[_from].dailyTransfers = uint96(\\n            uint256(owners[_from].dailyTransfers).add(_tAmount)\\n        );\\n\\n        _onTransfer(\\n            _from,\\n            _to,\\n            _tAmount,\\n            fees,\\n            tTransferAmount,\\n            balanceOf(_from)\\n        );\\n\\n        bool balanceAddedAsHodl = _reflectHodlTokens(\\n            _from,\\n            _to,\\n            tSellerSold,\\n            tTransferAmount\\n        );\\n        owners[_from].balance = owners[_from].balance.sub(\\n            tSellerSold.mul(cachedRate),\\n            \\\"Not enough funds when taking seller fee\\\"\\n        );\\n        if (isExcludedFromReward[_from]) {\\n            tokenOwned[_from] = tokenOwned[_from].sub(tSellerSold);\\n        }\\n        // solhint-disable-next-line reason-string\\n        require(\\n            balanceOf(_from) \\u003e= _getLockedReflectionOf(_from).div(cachedRate),\\n            \\\"Some funds are locked\\\"\\n        );\\n        if (!balanceAddedAsHodl) {\\n            if (isExcludedFromReward[_to]) {\\n                tokenOwned[_to] = tokenOwned[_to].add(tTransferAmount);\\n            }\\n            owners[_to].balance = owners[_to].balance.add(rTransferAmount);\\n        }\\n\\n        _reflectLiquidity(fees.liquidity.mul(cachedRate));\\n        _reflectSweepstakeFee(fees.sweepstake.mul(cachedRate));\\n        _reflectHodlFee(fees.hodl, fees.hodl.mul(cachedRate));\\n        _reflectTeamFee(fees.team, fees.team.mul(cachedRate));\\n        _reflectCharityFee(fees.charity.mul(cachedRate));\\n\\n        collectedWhaleTotal = collectedWhaleTotal.add(fees.whaleProtection);\\n        _reflectReward(\\n            fees.reward.add(fees.whaleProtection),\\n            fees.reward.add(fees.whaleProtection).mul(cachedRate)\\n        );\\n\\n        if (\\n            fees.reward != 0 ||\\n            fees.charity != 0 ||\\n            fees.whaleProtection != 0 ||\\n            fees.hodl != 0\\n        ) {\\n            emit SellerFeesCollected(\\n                fees.reward,\\n                fees.hodl,\\n                fees.charity,\\n                fees.whaleProtection\\n            );\\n        } else if (\\n            fees.liquidity == 0 \\u0026\\u0026 fees.sweepstake == 0 \\u0026\\u0026 fees.team == 0\\n        ) {\\n            emit NoFeesTransfer(_from, _to, tTransferAmount);\\n        }\\n\\n        if (fees.liquidity != 0 || fees.sweepstake != 0 || fees.team != 0) {\\n            emit BuyerFeesCollected(fees.liquidity, fees.sweepstake, fees.team);\\n        }\\n\\n        emit Transfer(_from, _to, tTransferAmount);\\n        return rTransferAmount;\\n    }\\n\\n    /**\\n     * @dev Reflect hodl tokens for a transaction being made.\\n     *      will remove _from from being able to receive hodl reward (if not connect)\\n     * @return true if _to balance was added as hodl tokens, false otherwise\\n     */\\n    function _reflectHodlTokens(\\n        address _from,\\n        address _to,\\n        uint256 _tSoldAmount,\\n        uint256 _tTransferAmount\\n    ) private returns (bool) {\\n        if (\\n            associateOf[_from] == _to \\u0026\\u0026\\n            !isAssociateBlackList[_to] \\u0026\\u0026\\n            associatesEnabled \\u0026\\u0026\\n            !owners[_to].excludedFromHodlReward\\n        ) {\\n            // If an associate account - not all balance should be removed\\n            _removeTokensFromHodlForBalanceIfNeeded(_from, _tSoldAmount);\\n            return false;\\n        }\\n        // Remove all hodl tokens\\n        _removeTokensFromHodl(_from);\\n        owners[_from].excludedFromHodlReward = true;\\n\\n        // If percipient is entitled to hodl reward, and the transfer is not an associate transfer\\n        // (associate is excluded to prevent abuse), and percipient is not excluded from reward\\n        if (!owners[_to].excludedFromHodlReward \\u0026\\u0026 !isExcludedFromReward[_to]) {\\n            uint256 tHodlersRewardPool = rHodlersRewardPool.div(cachedRate);\\n\\n            uint256 newTokens = _tTransferAmount;\\n            if (hodlTotalSupply != 0) {\\n                newTokens = _tTransferAmount.mul(hodlTotalSupply).div(\\n                    tHodlersRewardPool\\n                );\\n            }\\n            hodlTotalSupply = hodlTotalSupply.add(newTokens);\\n\\n            owners[_to].hodlTokens = uint96(\\n                uint256(owners[_to].hodlTokens).add(newTokens)\\n            );\\n\\n            rHodlersRewardPool = rHodlersRewardPool.add(\\n                _tTransferAmount.mul(cachedRate)\\n            );\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Remove hodl tokens so that balance will reach _wantedBalance\\n     */\\n    function _removeTokensFromHodlForBalanceIfNeeded(\\n        address _account,\\n        uint256 _wantedBalance\\n    ) private {\\n        uint256 tBalance = owners[_account].balance.div(cachedRate);\\n        if (_wantedBalance \\u003c= tBalance) {\\n            return;\\n        }\\n        uint256 tokensDiff = _wantedBalance.sub(tBalance);\\n        // will throw (subtract overflow) if not enough tokens\\n        _removeTokensFromHodl(_account, tokensDiff);\\n    }\\n\\n    /**\\n     * @dev Removes all hodl tokens of _account (and add them to his balance),\\n     * @notice Will NOT mark him as un-eligible.\\n     */\\n    function _removeTokensFromHodl(address _account) private {\\n        _removeTokensFromHodl(_account, 0);\\n    }\\n\\n    /**\\n     * @dev Removes _tTokensToRemove hodl tokens from _account (and add them to his balance),\\n     * if _tTokensToRemove == 0, will remove all tokens.\\n     * @notice Will NOT mark him as excluded.\\n     */\\n    function _removeTokensFromHodl(\\n        address _account,\\n        uint256 _amountInGains // Send 0 for everything\\n    ) private {\\n        uint256 hodlTokens = owners[_account].hodlTokens;\\n        // Liquidate hodl reward to balance\\n        if (hodlTokens == 0) {\\n            return;\\n        }\\n        uint256 hodlTokensToRemove;\\n        uint256 liquidateAmount;\\n        uint256 tHodlersRewardPool = rHodlersRewardPool.div(cachedRate);\\n        if (_amountInGains \\u003e 0) {\\n            liquidateAmount = _amountInGains;\\n            hodlTokensToRemove = _amountInGains.mul(hodlTotalSupply).div(\\n                tHodlersRewardPool\\n            );\\n        } else {\\n            hodlTokensToRemove = hodlTokens;\\n            liquidateAmount = hodlTokensToRemove.mul(tHodlersRewardPool).div(\\n                hodlTotalSupply\\n            );\\n        }\\n\\n        uint256 rLiquidateAmount = liquidateAmount.mul(cachedRate);\\n        // Update sender balance to include hodl reward\\n        owners[_account].balance = owners[_account].balance.add(\\n            rLiquidateAmount\\n        );\\n        hodlTotalSupply = hodlTotalSupply.sub(hodlTokensToRemove);\\n        owners[_account].hodlTokens = uint96(\\n            hodlTokens.sub(hodlTokensToRemove, \\\"Not enough funds\\\")\\n        );\\n        // Remove taken reward\\n\\n        rHodlersRewardPool = rHodlersRewardPool.sub(rLiquidateAmount);\\n    }\\n\\n    /**\\n     * @dev Call sweepstake onTransfer\\n     */\\n    function _onTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _tAmount,\\n        Fees memory _fees,\\n        uint256 _tTransferAmount,\\n        uint256 _sellerBalance\\n    ) private {\\n        if (address(sweepstake) != address(0)) {\\n            sweepstake.onTransfer(\\n                _from,\\n                _to,\\n                _tAmount,\\n                _fees.liquidity,\\n                _fees.sweepstake,\\n                _fees.team,\\n                _fees.charity,\\n                _fees.reward,\\n                _fees.hodl,\\n                _fees.whaleProtection,\\n                _tTransferAmount,\\n                _sellerBalance\\n            );\\n        }\\n\\n        if (address(governance) != address(0)) {\\n            governance.onTransfer(\\n                _from,\\n                _to,\\n                _tAmount,\\n                _fees.liquidity,\\n                _fees.sweepstake,\\n                _fees.team,\\n                _fees.charity,\\n                _fees.reward,\\n                _fees.hodl,\\n                _fees.whaleProtection,\\n                _tTransferAmount,\\n                _sellerBalance\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev log and take team fee\\n     */\\n    function _reflectTeamFee(uint256 _tAmount, uint256 _rAmount) private {\\n        if (isExcludedFromReward[teamWallet]) {\\n            tokenOwned[teamWallet] = tokenOwned[teamWallet].add(_tAmount);\\n        }\\n        owners[teamWallet].balance = owners[teamWallet].balance.add(_rAmount);\\n        collectedTeamFeeTotal = collectedTeamFeeTotal.add(_tAmount);\\n    }\\n\\n    /**\\n     * @dev log and take sweepstake fee\\n     */\\n    function _reflectSweepstakeFee(uint256 _rAmount) private {\\n        rAvailableSweepstake = rAvailableSweepstake.add(_rAmount);\\n        owners[address(this)].balance = owners[address(this)].balance.add(\\n            _rAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev log and take hodl fee\\n     */\\n    function _reflectHodlFee(uint256 _tAmount, uint256 _rAmount) private {\\n        // There is an edge case here - if there are no hodl eligible holders,\\n        // The whole amount will be given to the first new account - but this\\n        // is so unlikely (and outcome isn\\u0027t a crash) that we don\\u0027t\\n        // see the need to address this\\n        rHodlersRewardPool = rHodlersRewardPool.add(_rAmount);\\n        collectedHodlRewardTotal = collectedHodlRewardTotal.add(_tAmount);\\n    }\\n\\n    /**\\n     * @dev log and take liquidity fee\\n     */\\n    function _reflectLiquidity(uint256 _rAmount) private {\\n        rAvailableLiquidity = rAvailableLiquidity.add(_rAmount);\\n        owners[address(this)].balance = owners[address(this)].balance.add(\\n            _rAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev log and take charity fee\\n     */\\n    function _reflectCharityFee(uint256 _rAmount) private {\\n        rDailyCharity = rDailyCharity.add(_rAmount);\\n        rAvailableCharity = rAvailableCharity.add(_rAmount);\\n        owners[address(this)].balance = owners[address(this)].balance.add(\\n            _rAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev log and take reward fee\\n     */\\n    function _reflectReward(uint256 _tAmount, uint256 _rAmount) private {\\n        rewardTotal = rewardTotal.sub(_rAmount);\\n        collectedRewardTotal = collectedRewardTotal.add(_tAmount);\\n        cachedRate = _getRate();\\n    }\\n\\n    // Utilities\\n    function _min(uint256 _a, uint256 _b) private pure returns (uint256) {\\n        return _a \\u003c _b ? _a : _b;\\n    }\\n\\n    function _max(uint256 _a, uint256 _b) private pure returns (uint256) {\\n        return _a \\u003e _b ? _a : _b;\\n    }\\n\\n    function _percent(uint256 _amount, uint256 _percentToTake)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return _amount.mul(_percentToTake).div(PERCENT_DIVIDER_FACTOR);\\n    }\\n\\n    function _totalBuyerFees(Fees memory _fees) private pure returns (uint256) {\\n        return _fees.sweepstake.add(_fees.liquidity).add(_fees.team);\\n    }\\n\\n    function _totalSellerFees(Fees memory _fees)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            _fees.reward.add(_fees.charity).add(_fees.whaleProtection).add(\\n                _fees.hodl\\n            );\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IGainProtocol.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\n\\ninterface IGainProtocol is IERC20 {\\n    function startDraw() external;\\n\\n    function setAssociate(address _associate) external;\\n\\n    function dailyTransfersOf(address _account) external view returns (uint256);\\n\\n    function tokenFromReflection(uint256 _rAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reflectionFromToken(uint256 _tAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function collectedSweepstake() external view returns (uint256);\\n\\n    function collectedLiquidity() external view returns (uint256);\\n\\n    function collectedCharity() external view returns (uint256);\\n\\n    function collectedWhaleFee() external view returns (uint256);\\n\\n    function collectedReward() external view returns (uint256);\\n\\n    function collectedTeamFee() external view returns (uint256);\\n\\n    function collectedHodlReward() external view returns (uint256);\\n\\n    function soldLiquidity() external view returns (uint256);\\n\\n    function availableSweepstake() external view returns (uint256);\\n\\n    function availableCharity() external view returns (uint256);\\n\\n    function availableLiquidity() external view returns (uint256);\\n\\n    function transferSweepstake(address _winner, uint256 _tAmount) external;\\n\\n    function calculateFees(\\n        address _sender,\\n        address _recipient,\\n        uint256 _tAmount\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liquidityFee,\\n            uint256 sweepstakeFee,\\n            uint256 teamFee,\\n            uint256 charityFee,\\n            uint256 rewardFee,\\n            uint256 hodlFee,\\n            uint256 whaleProtectionFee\\n        );\\n\\n    function lockedBalanceReleaseDate(address _account)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function lockedBalanceOf(address _account) external view returns (uint256);\\n\\n    function hodlTokensOf(address _account)\\n        external\\n        view\\n        returns (uint256 hodlTokens, uint256 hodlTokenSupply);\\n\\n    function giveBack(uint256 _tAmount) external;\\n\\n    function giveBackHodl(uint256 _tAmount) external;\\n\\n    function lockedTransfer(\\n        address _to,\\n        uint256 _tAmount,\\n        uint256 _lockPeriodSeconds\\n    ) external;\\n\\n    function lockTokens(uint256 _tAmount, uint256 _lockPeriodSeconds) external;\\n\\n    function uniswapV2Pair() external view returns (IUniswapV2Pair);\\n\\n    function uniswapV2Router() external view returns (IUniswapV2Router02);\\n}\\n\"},\"IGainProtocolTransferListener.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\ninterface IGainProtocolTransferListener {\\n    function onTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _tAmount,\\n        uint256 _liquidityFee,\\n        uint256 _sweepstakeFee,\\n        uint256 _teamFee,\\n        uint256 _charityFee,\\n        uint256 _rewardFee,\\n        uint256 _hodlFee,\\n        uint256 _whaleProtection,\\n        uint256 _tTransferAmount,\\n        uint256 _sellerBalance\\n    ) external;\\n}\\n\"},\"IGainSweepstakes.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IGainProtocol.sol\\\";\\nimport \\\"./IGainProtocolTransferListener.sol\\\";\\n\\ninterface IGainSweepstakes is IGainProtocolTransferListener {\\n    enum SweepstakeTypes {\\n        EqualChance,\\n        ByHoldingSize,\\n        Minigame,\\n        DailyBuyers,\\n        BigHolders,\\n        Seniority,\\n        NewHolders\\n    }\\n\\n    struct SweepstakeWinInfo {\\n        address winner;\\n        uint256 amount;\\n        SweepstakeTypes sweepstakeType;\\n    }\\n\\n    struct SweepstakeResult {\\n        uint256 performedAt;\\n        uint256 sweepstakeID;\\n        uint256 totalJackpot;\\n        uint256 minigameRandom;\\n        SweepstakeWinInfo[] winners;\\n    }\\n\\n    function sweepstakeCount() external view returns (uint256);\\n\\n    function setParentERC(IGainProtocol _parentToken) external;\\n\\n    function sweepstakeResult(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint256 performedAt,\\n            uint256 sweepstakeID,\\n            uint256 totalJackpot,\\n            uint256 minigameRandom,\\n            address[] memory winners,\\n            uint256[] memory amounts,\\n            SweepstakeTypes[] memory types\\n        );\\n\\n    function initialTransfer(\\n        address _to,\\n        uint256 /*_tAmount*/\\n    ) external;\\n\\n    function startDraw(uint256 tSweepstakeAmount) external;\\n}\\n\"},\"IUniswapV2Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"},\"IUniswapV2Router01.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./IUniswapV2Router01.sol\\u0027;\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddrs\",\"type\":\"address\"},{\"internalType\":\"contract IGainSweepstakes\",\"name\":\"_sweepstake\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sweepstake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"team\",\"type\":\"uint256\"}],\"name\":\"BuyerFeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GiveBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GiveBackHodl\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"NoFeesTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRemovedFromLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbRemovedFromLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRewarded\",\"type\":\"uint256\"}],\"name\":\"RemoveFromLiquidityAndReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hodl\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"charity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"whaleProtection\",\"type\":\"uint256\"}],\"name\":\"SellerFeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbIntoLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"TokensLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WhaleProtectionFeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"WhaleProtectionUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"associateOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableCharity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableSweepstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBlackListed\",\"type\":\"bool\"}],\"name\":\"blackListFromAssociate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"}],\"name\":\"calculateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sweepstakeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"charityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hodlFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"whaleProtectionFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedCharity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedHodlReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedSweepstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedTeamFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedWhaleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyCharityLimitUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"dailyTransfersOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeFromBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExclude\",\"type\":\"bool\"}],\"name\":\"excludeFromSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExclude\",\"type\":\"bool\"}],\"name\":\"excludeFromWhaleProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"featuresState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"swapAndLiquify\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"dynamicSwapAndLiquify\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"whaleProtection\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"taxes\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"associates\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"}],\"name\":\"giveBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"}],\"name\":\"giveBackHodl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IGainProtocolTransferListener\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"hodlTokensOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hodlTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hodlTokenSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAssociateBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromBuyFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromSellFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromWhaleProtectionFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokensSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTargetStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTargetEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockPeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"lockedBalanceReleaseDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockPeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"lockedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_associate\",\"type\":\"address\"}],\"name\":\"overrideAssociate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract GainPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_associate\",\"type\":\"address\"}],\"name\":\"setAssociate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setAssociatesEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setCharityLimitUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setDynamicSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGainProtocolTransferListener\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernanceAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setLiquidityTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setNumTokensSellToAddToLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GainPriceFeed\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGainSweepstakes\",\"name\":\"_newSweepstake\",\"type\":\"address\"}],\"name\":\"setSweepstakeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setSweepstakeLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_sweepstake\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_liquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_reward\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_charity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_hodl\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_team\",\"type\":\"uint16\"}],\"name\":\"setTaxPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setTaxesEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setWhaleProtectionEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setWhaleProtectionPercentFromLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepstake\",\"outputs\":[{\"internalType\":\"contract IGainSweepstakes\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepstakeLockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tAmount\",\"type\":\"uint256\"}],\"name\":\"transferSweepstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleProtectionPercentFromLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawCharity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GainProtocol", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000002cf13601129aaa1f2c2dd528baff72754ce97522", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c9c634c09f9b317f6722c115b47836c9fa6108e392967a468f5b0dfd2433dee2"}