{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/CheezburgerBun.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// This token was deployed using the CheezburgerFactory.\\n// You can check the tokenomics, website and social from the public read functions.\\npragma solidity ^0.8.21;\\n\\nimport \\\"solady/src/tokens/ERC20.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./CheezburgerDynamicTokenomics.sol\\\";\\nimport \\\"./interfaces/ICheezburgerFactory.sol\\\";\\n\\ncontract CheezburgerBun is CheezburgerDynamicTokenomics, ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    error TransferToZeroAddress(address from, address to);\\n    error TransferToToken(address to);\\n    error TransferMaxTokensPerWallet();\\n    error OnlyOneBuyPerBlockAllowed();\\n    error CannotReceiveEtherDirectly();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    string private _name;\\n    string private _symbol;\\n    string private _website;\\n    string private _social;\\n    IUniswapV2Pair private _pair;\\n    address public constant owner = address(0);\\n    mapping(address => uint256) private _holderLastBuyTimestamp;\\n    ICheezburgerFactory public immutable factory =\\n        ICheezburgerFactory(msg.sender);\\n    uint8 internal isSwapping = 1;\\n\\n    constructor(\\n        TokenCustomization memory _customization,\\n        DynamicSettings memory _fees,\\n        DynamicSettings memory _wallet\\n    ) CheezburgerDynamicTokenomics(_fees, _wallet) {\\n        _name = _customization.name;\\n        _symbol = _customization.symbol;\\n        _website = _customization.website;\\n        _social = _customization.social;\\n        _mint(address(factory), _customization.supply * (10 ** decimals()));\\n    }\\n\\n    /// @dev Prevents direct Ether transfers to contract\\n    receive() external payable {\\n        revert CannotReceiveEtherDirectly();\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function website() public view returns (string memory) {\\n        return _website;\\n    }\\n\\n    function social() public view returns (string memory) {\\n        return _social;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (to == address(this)) {\\n            revert TransferToToken(to);\\n        }\\n\\n        // Cache pair internally if available\\n        if (address(_pair) == address(0)) {\\n            if (address(factory).code.length > 0) {\\n                _pair = factory.selfPair();\\n            }\\n        }\\n\\n        bool isBuying = from == address(_pair);\\n\\n        /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n        /*                        LIQUIDITY SWAP                      */\\n        /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n        if (\\n            !isBuying &&\\n            isSwapping == 1 &&\\n            balanceOf(address(factory)) > 0 &&\\n            _pair.totalSupply() > 0\\n        ) {\\n            doLiquiditySwap();\\n        }\\n    }\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._afterTokenTransfer(from, to, amount);\\n\\n        // Must use burn() to burn tokens\\n        if (to == address(0) && balanceOf(address(0)) > 0) {\\n            revert TransferToZeroAddress(from, to);\\n        }\\n\\n        // Don't look after self transfers\\n        if (from == to) {\\n            return;\\n        }\\n\\n        // Ignore Factory-related txs\\n        if (to == address(factory) || from == address(factory)) {\\n            return;\\n        }\\n\\n        bool isBuying = from == address(_pair);\\n        bool isSelling = to == address(_pair);\\n        DynamicTokenomicsStruct memory tokenomics = _getTokenomics(\\n            totalSupply()\\n        );\\n\\n        /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n        /*                          TXS LIMITS                        */\\n        /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n        if (isBuying) {\\n            bool buyFeeStillDecreasing = tokenomics.earlyAccessPremium !=\\n                tokenomics.sellFee;\\n            if (buyFeeStillDecreasing) {\\n                if (_holderLastBuyTimestamp[tx.origin] == block.number) {\\n                    revert OnlyOneBuyPerBlockAllowed();\\n                }\\n                _holderLastBuyTimestamp[tx.origin] = block.number;\\n            }\\n        }\\n\\n        /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n        /*                            FEES                            */\\n        /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n        uint256 feeAmount = 0;\\n        if (isBuying || isSelling) {\\n            unchecked {\\n                if (isBuying && tokenomics.earlyAccessPremium > 0) {\\n                    feeAmount = amount * tokenomics.earlyAccessPremium;\\n                } else if (isSelling && tokenomics.sellFee > 0) {\\n                    feeAmount = amount * tokenomics.sellFee;\\n                }\\n                if (feeAmount > 0) {\\n                    super._transfer(to, address(factory), feeAmount / 10000);\\n                    emit AppliedTokenomics(tokenomics);\\n                }\\n            }\\n        }\\n\\n        /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n        /*                        WALLET LIMITS                       */\\n        /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n        if (!isSelling) {\\n            unchecked {\\n                bool walletExceedLimits = balanceOf(to) >\\n                    tokenomics.maxTokensPerWallet;\\n                if (walletExceedLimits) {\\n                    revert TransferMaxTokensPerWallet();\\n                }\\n            }\\n        }\\n    }\\n\\n    function doLiquiditySwap() private lockSwap {\\n        factory.afterTokenTransfer(msg.sender, balanceOf(address(factory)));\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// Burns tokens from the caller.\\n    ///\\n    /// @dev Burns `amount` tokens from the caller.\\n    ///\\n    /// See {ERC20-_burn}.\\n    function burn(uint256 amount) external {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /// Burns tokens from an account's allowance.\\n    ///\\n    /// @dev Burns `amount` tokens from `account`, deducting from the caller's\\n    /// allowance.\\n    ///\\n    /// See {ERC20-_burn} and {ERC20-allowance}.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - the caller must have allowance for ``accounts``'s tokens of at least\\n    /// `amount`.\\n    function burnFrom(address account, uint256 amount) external {\\n        _spendAllowance(account, msg.sender, amount);\\n        _burn(account, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Get current dynamic tokenomics\\n    /// @return DynamicTokenomics struct with current values\\n    /// @notice Values will change dynamically based on configured durations and percentages\\n    function getTokenomics()\\n        external\\n        view\\n        returns (DynamicTokenomicsStruct memory)\\n    {\\n        return _getTokenomics(totalSupply());\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    modifier lockSwap() {\\n        isSwapping = 2;\\n        _;\\n        isSwapping = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CheezburgerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nlibrary CheezburgerConstants {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // The maximum amount of tokens that can be held on the pair is limited to the max uint112 value\\n    // uint112 ranges from 0 to 340,282,366,920,938,463,463,374,607,431,768,211,455\\n    uint256 private constant MAX_TOTAL_SUPPLY = type(uint112).max;\\n    // Dividing by 10**18 shifts the decimal place 18 spots to represent the value with 18 decimals\\n    // This allows the total supply to be represented as a common token amount in the external interface\\n    uint256 private constant MAX_TOKEN_SUPPLY = MAX_TOTAL_SUPPLY / (10 ** 18);\\n    // Calculate safety margin as 1% below max\\n    // SAFE_TOKEN_SUPPLY will be the enforced limit, providing a buffer\\n    // below the mathematical max to account for potential overflows\\n    uint256 internal constant SAFE_TOKEN_SUPPLY =\\n        MAX_TOKEN_SUPPLY - (MAX_TOKEN_SUPPLY / 100);\\n    uint8 internal constant MAX_LP_FEE = 4;\\n    uint256 internal constant FEE_DURATION_MIN = 1 hours;\\n    uint256 internal constant FEE_DURATION_CAP = 1 days;\\n    uint256 internal constant WALLET_DURATION_MIN = 1 days;\\n    uint256 internal constant WALLET_DURATION_CAP = 4 weeks;\\n    uint256 internal constant WALLET_MIN_PERCENT_END = 200;\\n    uint256 internal constant WALLET_MAX_PERCENT_END = 4900;\\n    uint256 internal constant MIN_NAME_LENGTH = 1;\\n    uint256 internal constant MAX_NAME_LENGTH = 128;\\n    uint256 internal constant MIN_SYMBOL_LENGTH = 1;\\n    uint256 internal constant MAX_SYMBOL_LENGTH = 128;\\n    uint256 internal constant MAX_URL_LENGTH = 256;\\n    uint256 internal constant FEE_START_MIN = 100;\\n    uint256 internal constant FEE_START_MAX = 4000;\\n    uint256 internal constant FEE_END_MAX = 500;\\n    uint8 internal constant THRESHOLD_MIN = 1;\\n    uint8 internal constant THRESHOLD_MAX = 5;\\n    uint256 internal constant FEE_ADDRESSES_MAX = 5;\\n    uint256 internal constant FEE_ADDRESSES_MIN = 1;\\n}\\n\"\r\n    },\r\n    \"contracts/CheezburgerDynamicTokenomics.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport \\\"./CheezburgerStructs.sol\\\";\\n\\nabstract contract CheezburgerDynamicTokenomics is CheezburgerStructs {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    event AppliedTokenomics(DynamicTokenomicsStruct tokenomics);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    uint256 public immutable launchStart = block.timestamp;\\n    uint256 public immutable EARLY_ACCESS_PREMIUM_DURATION;\\n    uint16 public immutable EARLY_ACCESS_PREMIUM_START;\\n    uint16 public immutable EARLY_ACCESS_PREMIUM_END;\\n    uint16 public immutable SELL_FEE_END;\\n    uint256 public immutable MAX_WALLET_DURATION;\\n    uint16 public immutable MAX_WALLET_PERCENT_START;\\n    uint16 public immutable MAX_WALLET_PERCENT_END;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCT                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    struct DynamicTokenomicsStruct {\\n        uint16 earlyAccessPremium;\\n        uint16 sellFee;\\n        uint16 maxWalletPercentage;\\n        uint256 maxTokensPerWallet;\\n    }\\n\\n    constructor(DynamicSettings memory _fee, DynamicSettings memory _wallet) {\\n        EARLY_ACCESS_PREMIUM_DURATION = _fee.duration;\\n        EARLY_ACCESS_PREMIUM_START = _fee.percentStart;\\n        EARLY_ACCESS_PREMIUM_END = _fee.percentEnd;\\n        SELL_FEE_END = _fee.percentEnd;\\n        MAX_WALLET_DURATION = _wallet.duration;\\n        MAX_WALLET_PERCENT_START = _wallet.percentStart;\\n        MAX_WALLET_PERCENT_END = _wallet.percentEnd;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Computes current tokenomics values\\n    /// @return DynamicTokenomics struct with current values\\n    /// @notice Values will change dynamically based on configured durations and percentages\\n    function _getTokenomics(\\n        uint256 _totalSupply\\n    ) internal view returns (DynamicTokenomicsStruct memory) {\\n        uint256 _elapsed = block.timestamp - launchStart;\\n        uint16 _maxWalletPercentage = _currentMaxWalletPercentage(_elapsed);\\n        return\\n            DynamicTokenomicsStruct({\\n                earlyAccessPremium: _currentBuyFeePercent(_elapsed),\\n                sellFee: SELL_FEE_END,\\n                maxWalletPercentage: _maxWalletPercentage,\\n                maxTokensPerWallet: _calculateMaxTokensPerWalletPrecisely(\\n                    _totalSupply,\\n                    _maxWalletPercentage\\n                )\\n            });\\n    }\\n\\n    /// @dev Calculates max tokens per wallet more precisely than standard calculation\\n    /// @param _totalSupply Current total token supply\\n    /// @param _maxWalletPercentage Max wallet percentage in basis points (out of 10k)\\n    /// @return maxTokensPerWallet Precisely calculated max tokens per wallet\\n    /// @custom:optimizations Uses unchecked math for better gas efficiency\\n    function _calculateMaxTokensPerWalletPrecisely(\\n        uint256 _totalSupply,\\n        uint256 _maxWalletPercentage\\n    ) private pure returns (uint256) {\\n        unchecked {\\n            // Convert the percentage to a fraction and perform the multiplication last to maintain precision\\n            return (_totalSupply * _maxWalletPercentage + 9999) / 10000;\\n        }\\n    }\\n\\n    /// @dev Gets current buy fee percentage based on elapsed time\\n    /// @return Current buy fee percentage\\n    function _currentBuyFeePercent(\\n        uint256 elapsed\\n    ) internal view returns (uint16) {\\n        return\\n            computeFeePercentage(\\n                elapsed,\\n                EARLY_ACCESS_PREMIUM_DURATION,\\n                EARLY_ACCESS_PREMIUM_START,\\n                EARLY_ACCESS_PREMIUM_END\\n            );\\n    }\\n\\n    /// @dev Gets current max wallet percentage based on elapsed time\\n    /// @return Current max wallet percentage\\n    function _currentMaxWalletPercentage(\\n        uint256 elapsed\\n    ) internal view returns (uint16) {\\n        return\\n            computeMaxWalletPercentage(\\n                elapsed,\\n                MAX_WALLET_DURATION,\\n                MAX_WALLET_PERCENT_START,\\n                MAX_WALLET_PERCENT_END\\n            );\\n    }\\n\\n    /// Computes fee percentage based on elapsed time, using an inverted quadratic curve.\\n    /// The fee percentage starts from a high value and decreases to a low value as time progresses.\\n    /// This creates a curve that starts fast and then slows down as the elapsed time approaches the total duration.\\n    ///\\n    /// @param elapsed The number of seconds that have passed since the launch.\\n    /// @param duration The total duration in seconds for the decrease.\\n    /// @param startPercent The starting fee percentage at the launch. Expressed in basis points where 1000 means 10%.\\n    /// @param endPercent The target fee percentage at the end of the duration. Expressed in basis points where 1000 means 10%.\\n    /// @return The current fee percentage, expressed in basis points where 1000 means 10%.\\n    function computeFeePercentage(\\n        uint256 elapsed,\\n        uint256 duration,\\n        uint16 startPercent,\\n        uint16 endPercent\\n    ) private pure returns (uint16) {\\n        if (elapsed >= duration) {\\n            return endPercent;\\n        }\\n\\n        uint16 feePercent;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let scale := 0x0de0b6b3a7640000 // 10^18 in hexadecimal\\n            // Calculate the position on the curve, x, as a ratio of elapsed time to total duration\\n            let x := div(mul(elapsed, scale), duration)\\n            // Subtract squared x from scale to get the inverted position on the curve\\n            let xx := sub(scale, div(mul(x, x), scale))\\n            // Calculate delta as a proportion of startPercent scaled by the position on the curve\\n            let delta := div(mul(startPercent, xx), scale)\\n            // Ensure feePercent doesn't fall below endPercent\\n            feePercent := endPercent\\n            if gt(delta, endPercent) {\\n                feePercent := delta\\n            }\\n        }\\n        return feePercent;\\n    }\\n\\n    /// Computes the maximum wallet percentage based on the elapsed time using a quadratic function.\\n    /// This function uses the progression of time to determine the maximum wallet percentage allowed,\\n    /// starting from the `startPercent` and progressively moving towards the `endPercent` in a quadratic manner.\\n    /// This creates a curve that starts slow and then accelerates as the elapsed time approaches the total duration.\\n    ///\\n    /// @param elapsed The number of seconds that have passed since the launch.\\n    /// @param duration The total duration in seconds for the quadratic progression.\\n    /// @param startPercent The starting wallet percentage at the launch. Expressed in basis points where 1000 means 10%.\\n    /// @param endPercent The target wallet percentage at the end of the duration. Expressed in basis points where 1000 means 10%.\\n    /// @return The current maximum wallet percentage, expressed in basis points where 1000 means 10%.\\n    function computeMaxWalletPercentage(\\n        uint256 elapsed,\\n        uint256 duration,\\n        uint16 startPercent,\\n        uint16 endPercent\\n    ) private pure returns (uint16) {\\n        // If elapsed time is greater than duration, return endPercent directly\\n        if (elapsed >= duration) {\\n            return endPercent;\\n        }\\n\\n        uint16 walletPercent;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Scale factor equivalent to 1 ether in Solidity to handle the fractional values\\n            let scale := 0x0de0b6b3a7640000 // 10^18 in hexadecimal\\n            // Calculate the position on the curve, x, as a ratio of elapsed time to total duration\\n            let x := div(mul(elapsed, scale), duration)\\n            // Square x to get the position on the curve\\n            let xx := div(mul(x, x), scale)\\n            // Calculate the range of percentages and scale by the position on the curve\\n            let range := sub(endPercent, startPercent)\\n            let delta := div(mul(range, xx), scale)\\n            // Add the starting percentage to get the final percentage\\n            walletPercent := add(startPercent, delta)\\n        }\\n        return walletPercent;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CheezburgerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n//\\n//           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//         \u2588\u2588                    \u2588\u2588\\n//       \u2588\u2588    \u2588\u2588          \u2588\u2588      \u2588\u2588\\n//     \u2588\u2588      \u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588      \u2588\u2588\\n//     \u2588\u2588            \u2588\u2588\u2588\u2588            \u2588\u2588\\n//     \u2588\u2588                            \u2588\u2588\\n//   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\\n//     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\\n//     \u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\\n//     \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588  \u2588\u2588\\n//     \u2588\u2588                            \u2588\u2588\\n//       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//\\n// The CheezburgerFactory are a set of immutable and non-upgradeable smart contracts that enables\\n// easy deployment of new tokens with automated liquidity provisioning against either native ETH\\n// or ERC20 token specified with any Uniswap V2 compatible routers.\\n//\\n// By supporting both ETH and ERC20 tokens as liquidity, the Factory provides flexibility for\\n// projects to launch with the assets they have available. Automating the entire process\\n// dramatically lowers the barrier to creating a new token with smart tokenomics, built-in\\n// liquidity management and DEX listing in a completely trustless and decentralized way.\\n//\\n// Read more on Cheezburger: https://chz.lol\\n//\\npragma solidity ^0.8.21;\\n\\nimport \\\"solady/src/tokens/ERC20.sol\\\";\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"solady/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./CheezburgerBun.sol\\\";\\nimport \\\"./CheezburgerSanitizer.sol\\\";\\n\\ncontract CheezburgerFactory is ReentrancyGuard, Ownable, CheezburgerSanitizer {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    error InsufficientLiquidityWei(uint256 amount);\\n    error ExistingTokenAsRightSide(address token);\\n    error InvalidRouter(address router);\\n    error CannotReceiveEtherDirectly();\\n    error PairNotEmpty();\\n    error FactoryNotOpened();\\n    error InvalidLiquidityPoolFee(uint8 newFee);\\n    error CannotSetZeroAsRightSide();\\n    error InvalidPair(\\n        address tokenA,\\n        address tokenB,\\n        address leftSide,\\n        address rightSide\\n    );\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCT                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Settings and contracts for a token pair and its liquidity pool.\\n    struct Token {\\n        /// @dev The Uniswap factory contract\\n        IUniswapV2Factory factory;\\n        /// @dev The Uniswap router contract\\n        IUniswapV2Router02 router;\\n        /// @dev The Uniswap pair contract\\n        IUniswapV2Pair pair;\\n        /// @dev The token creator\\n        address creator;\\n        /// @dev The left side of the pair\\n        CheezburgerBun leftSide;\\n        /// @dev The right side ERC20 token of the pair\\n        ERC20 rightSide;\\n        /// @dev Liquidity settings\\n        LiquiditySettings liquidity;\\n        /// @dev Dynamic fee settings\\n        DynamicSettings fee;\\n        /// @dev Dynamic wallet settings\\n        DynamicSettings wallet;\\n        /// @dev Referral settings\\n        ReferralSettings referral;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    event TokenDeployed(Token token);\\n    event CommissionsTaken(uint256 factoryFee, uint256 referralFee);\\n    event SwapAndLiquify(\\n        address tokenLeft,\\n        address tokenRight,\\n        uint256 half,\\n        uint256 initialBalance,\\n        uint256 newRightBalance\\n    );\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    bool public factoryOpen = false;\\n    uint8 public factoryLiquidityFee = 4;\\n    uint256 public totalTokens = 0;\\n    mapping(address => Token) public burgerRegistry;\\n\\n    constructor() {\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a new token and adds liquidity with native coin\\n    /// @param _customization Token details (TokenCustomization)\\n    /// @param _router Uniswap router address\\n    /// @param _rightSide Address of token to provide liquidity with\\n    /// @param _liquidity Liquidity provision settings\\n    /// @param _fee Early Access Premium / Sell rate settings\\n    /// @param _wallet Max wallet holding settings\\n    /// @param _referral Referral settings\\n    /// @return The address of the deployed token contract\\n    function deployWithNative(\\n        TokenCustomization memory _customization,\\n        address _router,\\n        // If someone wants to specify a custom WETH() that is not returned by the router\\n        address _rightSide,\\n        LiquiditySettings memory _liquidity,\\n        DynamicSettings memory _fee,\\n        DynamicSettings memory _wallet,\\n        ReferralSettings memory _referral\\n    ) external payable nonReentrant returns (address) {\\n        Token memory token = deploy(\\n            _customization,\\n            _router,\\n            _liquidity,\\n            _fee,\\n            _wallet,\\n            _referral,\\n            _rightSide\\n        );\\n\\n        // Check at least 10,000 wei are provided for liquidity\\n        if (msg.value <= 10000 wei) {\\n            revert InsufficientLiquidityWei(msg.value);\\n        }\\n\\n        // Add liquidity\\n        addLiquidityETH(\\n            token,\\n            SafeTransferLib.balanceOf(address(token.leftSide), address(this)),\\n            msg.value,\\n            token.creator\\n        );\\n\\n        return address(token.leftSide);\\n    }\\n\\n    /// @dev Deploys a new token and adds liquidity using a token as right side\\n    /// @param _customization Token details (TokenCustomization)\\n    /// @param _router Uniswap router address\\n    /// @param _rightSide Address of token to provide liquidity with\\n    /// @param _rightSideAmount Amount of that token for liquidity\\n    /// @param _liquidity Liquidity provision settings\\n    /// @param _fee Early Access Premium / Sell fee rate settings\\n    /// @param _wallet Max wallet holding settings\\n    /// @param _referral Referral settings\\n    /// @return The address of the deployed token contract\\n    function deployWithToken(\\n        TokenCustomization memory _customization,\\n        address _router,\\n        address _rightSide,\\n        uint256 _rightSideAmount,\\n        LiquiditySettings memory _liquidity,\\n        DynamicSettings memory _fee,\\n        DynamicSettings memory _wallet,\\n        ReferralSettings memory _referral\\n    ) external nonReentrant returns (address) {\\n        Token memory token = deploy(\\n            _customization,\\n            _router,\\n            _liquidity,\\n            _fee,\\n            _wallet,\\n            _referral,\\n            _rightSide\\n        );\\n\\n        // Transfer tokens for liquidity add\\n        SafeTransferLib.safeTransferFrom(\\n            address(token.rightSide),\\n            token.creator,\\n            address(this),\\n            _rightSideAmount\\n        );\\n\\n        // Add liquidity\\n        addLiquidityToken(\\n            token,\\n            SafeTransferLib.balanceOf(address(token.leftSide), address(this)),\\n            _rightSideAmount,\\n            token.creator\\n        );\\n\\n        return address(token.leftSide);\\n    }\\n\\n    /// Checks for & executes automated liquidity swap if threshold met.\\n    ///\\n    /// @param _sender The address that initiated the token transfer\\n    ///\\n    /// @return True if check passed\\n    ///\\n    /// Verifies transfer didn't come from the router. Gets threshold\\n    /// and checks if left token balance exceeds it. If so, swaps tokens/adds\\n    /// liquidity, then distributes LP tokens to fee addresses as percentages\\n    /// configured in token settings.\\n    ///\\n    /// This dynamic threshold approach aims to reduce swap size and price\\n    /// impact as the pool and price grow over time. Automates ongoing\\n    /// liquidity additions from transaction volume.\\n    function afterTokenTransfer(\\n        address _sender,\\n        uint256 _leftSideBalance\\n    ) external returns (bool) {\\n        Token memory token = burgerRegistry[msg.sender];\\n        ensurePairValid(token);\\n        uint256 threshold = _getLiquidityThreshold(token);\\n\\n        if (_leftSideBalance >= threshold) {\\n            (\\n                uint256 addedLP,\\n                uint256 factoryFeeLP,\\n                uint256 referralFeeLP\\n            ) = swapAndLiquify(token, threshold);\\n            uint256 feeAddressesLength = token.liquidity.feeAddresses.length;\\n\\n            // Send a portion of the fee to the Factory owner\\n            if (factoryFeeLP > 0) {\\n                SafeTransferLib.safeTransfer(\\n                    address(token.pair),\\n                    owner(),\\n                    factoryFeeLP\\n                );\\n            }\\n\\n            if (referralFeeLP > 0) {\\n                SafeTransferLib.safeTransfer(\\n                    address(token.pair),\\n                    token.referral.feeReceiver,\\n                    referralFeeLP\\n                );\\n            }\\n\\n            // Send LP to designated LP wallets\\n            unchecked {\\n                uint8 i;\\n                while (i < feeAddressesLength) {\\n                    if (i == feeAddressesLength - 1) {\\n                        SafeTransferLib.safeTransferAll(\\n                            address(token.pair),\\n                            token.liquidity.feeAddresses[i]\\n                        );\\n                    } else {\\n                        uint256 feeAmount = (addedLP *\\n                            token.liquidity.feePercentages[i]) / 100;\\n                        SafeTransferLib.safeTransfer(\\n                            address(token.pair),\\n                            token.liquidity.feeAddresses[i],\\n                            feeAmount\\n                        );\\n                    }\\n                    ++i;\\n                }\\n            }\\n\\n            // Send any rightSide dust to the last address\\n            uint256 rightSideBalance = SafeTransferLib.balanceOf(\\n                address(token.rightSide),\\n                address(this)\\n            );\\n            if (rightSideBalance > 0) {\\n                SafeTransferLib.safeTransfer(\\n                    address(token.rightSide),\\n                    token.liquidity.feeAddresses[feeAddressesLength - 1],\\n                    rightSideBalance\\n                );\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Allows owner to update the liquidity fee percentage\\n    /// @param _factoryLiquidityFee New fee percentage, must be 0-4%\\n    function setLiquidityPoolFee(\\n        uint8 _factoryLiquidityFee\\n    ) external onlyOwner {\\n        // Validate that the new fee is in range\\n        if (_factoryLiquidityFee > CheezburgerConstants.MAX_LP_FEE) {\\n            revert InvalidLiquidityPoolFee(_factoryLiquidityFee);\\n        }\\n\\n        // Update deploy fee\\n        factoryLiquidityFee = _factoryLiquidityFee;\\n    }\\n\\n    /// @dev Function to open the factory\\n    function openFactory() external onlyOwner {\\n        factoryOpen = true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the token to get his pair address\\n    /// @return _pair The address of the pair\\n    function selfPair() external view returns (IUniswapV2Pair) {\\n        Token memory token = burgerRegistry[msg.sender];\\n        return token.pair;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// Limitations:\\n    ///\\n    /// EAP duration: 1 to 24 hours\\n    /// EAP start: 1% to 40%\\n    /// EAP end: 0% to 5%\\n    ///\\n    /// Wallet duration: 1 day to 4 weeks\\n    /// Wallet start: >= 1%\\n    /// Wallet end: 2% to 49%\\n    ///\\n    /// @param _customization Token details (TokenCustomization)\\n    /// @param _router Uniswap router address\\n    /// @param _liquidity Liquidity settings\\n    /// @param _fee Fees (Early Access Premium / Sell) settings\\n    /// @param _wallet Max wallet settings\\n    /// @param _referral Referral settings\\n    /// @param _rightSide Address of token to provide liquidity with\\n    /// @return Token instance\\n    function deploy(\\n        TokenCustomization memory _customization,\\n        address _router,\\n        LiquiditySettings memory _liquidity,\\n        DynamicSettings memory _fee,\\n        DynamicSettings memory _wallet,\\n        ReferralSettings memory _referral,\\n        address _rightSide\\n    ) private returns (Token memory) {\\n        validateTokenSettings(_router, _customization);\\n        validateWalletSettings(_wallet);\\n        validateFeeSettings(_fee);\\n        validateLiquiditySettings(_liquidity, address(this));\\n        validateReferralSettings(_referral, address(this));\\n\\n        Token memory token;\\n        token.creator = msg.sender;\\n\\n        // Ensure factory is either opened or the owner is the caller\\n        if (!factoryOpen && token.creator != owner()) {\\n            revert FactoryNotOpened();\\n        }\\n\\n        // Setup router and factory\\n        (IUniswapV2Router02 router, IUniswapV2Factory factory) = getRouter(\\n            _router\\n        );\\n        if (address(factory) == address(0) || address(router) == address(0)) {\\n            revert InvalidRouter(_router);\\n        }\\n        token.factory = factory;\\n        token.router = router;\\n\\n        // Right side token (WETH, USDC...)\\n        token.rightSide = ERC20(_rightSide);\\n        if (address(token.rightSide) == address(0)) {\\n            token.rightSide = ERC20(token.router.WETH());\\n            if (address(token.rightSide) == address(0)) {\\n                revert CannotSetZeroAsRightSide();\\n            }\\n        }\\n        if (burgerRegistry[address(token.rightSide)].creator != address(0)) {\\n            revert ExistingTokenAsRightSide(address(token.rightSide));\\n        }\\n\\n        // Create token\\n        token.leftSide = new CheezburgerBun{\\n            salt: _getSalt(_router, _rightSide)\\n        }(_customization, _fee, _wallet);\\n\\n        // Create pair\\n        token.pair = IUniswapV2Pair(\\n            token.factory.createPair(\\n                address(token.leftSide),\\n                address(token.rightSide)\\n            )\\n        );\\n        ensurePairValid(token);\\n        if (token.pair.totalSupply() > 0) {\\n            revert PairNotEmpty();\\n        }\\n\\n        // Save settings\\n        token.liquidity = _liquidity;\\n        token.fee = _fee;\\n        token.wallet = _wallet;\\n        token.referral = _referral;\\n\\n        // Add token to registry\\n        ++totalTokens;\\n        burgerRegistry[address(token.leftSide)] = token;\\n\\n        emit TokenDeployed(token);\\n        return token;\\n    }\\n\\n    /// Generates a salt value for deploying clones.\\n    ///\\n    /// The salt is derived from:\\n    /// - Total number of tokens deployed\\n    /// - Provided router address\\n    /// - Provided right token address\\n    /// - Previous block random number\\n    /// - Current block number\\n    /// - Current block timestamp\\n    ///\\n    /// @param _router The Uniswap router address\\n    /// @param _rightSide The address of the right side token\\n    /// @return The generated salt value\\n    function _getSalt(\\n        address _router,\\n        address _rightSide\\n    ) private view returns (bytes32) {\\n        bytes memory data = abi.encodePacked(\\n            bytes32(uint256(totalTokens)),\\n            bytes32(abi.encodePacked(_router)),\\n            bytes32(abi.encodePacked(_rightSide)),\\n            bytes32(block.prevrandao),\\n            bytes32(block.number),\\n            bytes32(block.timestamp)\\n        );\\n        return keccak256(data);\\n    }\\n\\n    /// Fetches the router and factory contracts for a router address.\\n    ///\\n    /// @param _router The address of the router contract\\n    ///\\n    /// @return router The router contract\\n    /// @return factory The factory contract\\n    ///\\n    /// This first checks if the provided router address is a valid contract.\\n    /// If so, it will attempt to call the `factory()` method on the router\\n    /// to retrieve the factory address.\\n    ///\\n    /// If the router address is invalid or the factory() call fails,\\n    /// zero addresses will be returned for both the router and factory.\\n    ///\\n    /// This provides a safe way to fetch the expected router and factory\\n    /// instances for a given address with proper validation.\\n    function getRouter(\\n        address _router\\n    ) private view returns (IUniswapV2Router02, IUniswapV2Factory) {\\n        if (_router.code.length > 0) {\\n            IUniswapV2Router02 router = IUniswapV2Router02(_router);\\n            try router.factory() returns (address factory) {\\n                if (factory != address(0)) {\\n                    return (router, IUniswapV2Factory(factory));\\n                }\\n            } catch {}\\n        }\\n        return (IUniswapV2Router02(address(0)), IUniswapV2Factory(address(0)));\\n    }\\n\\n    /// Calculates the target threshold for dynamic liquidity fees.\\n    ///\\n    /// @param token The token settings struct\\n    ///\\n    /// @return The calculated fee threshold amount\\n    ///\\n    /// Checks the total tokens currently in the liquidity pool pair.\\n    /// It then calculates a threshold amount as a percentage (set\\n    /// by `feeThresholdPercent`) of those tokens.\\n    ///\\n    /// This dynamic threshold is used to determine if sell\\n    /// transactions must pay liquidity provider fees. By tying it\\n    /// to total pool size, the threshold scales automatically to\\n    /// always be a set % as more liquidity is provided over time.\\n    ///\\n    /// This approach aims to smoothly collect trading fees for LP's\\n    /// in a way that adjusts to pool size, reducing pricing impact.\\n    function _getLiquidityThreshold(\\n        Token memory token\\n    ) private view returns (uint256) {\\n        uint256 tokensInLiquidity = SafeTransferLib.balanceOf(\\n            address(token.leftSide),\\n            address(token.pair)\\n        );\\n        unchecked {\\n            return\\n                (tokensInLiquidity * token.liquidity.feeThresholdPercent) / 100;\\n        }\\n    }\\n\\n    /// Adds liquidity to the Uniswap ETH pool for a token.\\n    ///\\n    /// @param token The token settings struct\\n    /// @param _leftAmount The amount of left token to add\\n    /// @param _etherAmount The amount of ETH to deposit\\n    ///\\n    /// Approves the token spending and adds liquidity\\n    /// to Uniswap, calling `addLiquidityETH()` on the router.\\n    ///\\n    /// This abstracts away adding liquidity with ETH to simplify\\n    /// integrating token deployments on Uniswap.\\n    function addLiquidityETH(\\n        Token memory token,\\n        uint256 _leftAmount,\\n        uint256 _etherAmount,\\n        address _receiver\\n    ) private {\\n        SafeTransferLib.safeApprove(\\n            address(token.leftSide),\\n            address(token.router),\\n            _leftAmount\\n        );\\n        token.router.addLiquidityETH{value: _etherAmount}(\\n            address(token.leftSide),\\n            _leftAmount,\\n            0,\\n            0,\\n            _receiver,\\n            block.timestamp\\n        );\\n    }\\n\\n    /// Adds liquidity for a token pair on Uniswap.\\n    ///\\n    /// @param token The token settings struct\\n    /// @param _leftAmount The amount of left token to add\\n    /// @param _rightAmount The amount of right token to add\\n    ///\\n    /// Adds liquidity to the Uniswap pool for the token pair\\n    /// defined in the `token` struct. The function adds\\n    /// `_leftAmount` of the left token and `_rightAmount`\\n    /// of the right token to the pool, creating a liquidity\\n    /// position for this token pair on Uniswap.\\n    function addLiquidityToken(\\n        Token memory token,\\n        uint256 _leftAmount,\\n        uint256 _rightAmount,\\n        address _receiver\\n    ) private {\\n        SafeTransferLib.safeApprove(\\n            address(token.leftSide),\\n            address(token.router),\\n            _leftAmount\\n        );\\n        SafeTransferLib.safeApproveWithRetry(\\n            address(token.rightSide),\\n            address(token.router),\\n            _rightAmount\\n        );\\n        token.router.addLiquidity(\\n            address(token.leftSide),\\n            address(token.rightSide),\\n            _leftAmount,\\n            _rightAmount,\\n            0,\\n            0,\\n            _receiver,\\n            block.timestamp\\n        );\\n    }\\n\\n    /// Swaps tokens and adds liquidity to Uniswap in one transaction.\\n    ///\\n    /// @param token The token settings struct\\n    /// @param _amounts The amounts of tokens to swap\\n    ///\\n    /// @return The balance of the new LP tokens received\\n    ///\\n    /// Swaps the specified token amounts according to the pair\\n    /// defined in the `token` struct. It then takes the output\\n    /// of the swap and adds it as liquidity to the Uniswap pool,\\n    /// returning the amount of LP tokens received for the newly\\n    /// provided liquidity. This allows swapping and adding\\n    /// liquidity to be done atomically in a single transaction.\\n    function swapAndLiquify(\\n        Token memory token,\\n        uint256 _amounts\\n    ) private returns (uint256, uint256, uint256) {\\n        unchecked {\\n            uint256 half = _amounts / 2;\\n            uint256 initialRightBalance = SafeTransferLib.balanceOf(\\n                address(token.rightSide),\\n                address(this)\\n            );\\n            swapLeftForRightSide(token, half);\\n            uint256 newRightBalance = SafeTransferLib.balanceOf(\\n                address(token.rightSide),\\n                address(this)\\n            ) - initialRightBalance;\\n            addLiquidityToken(token, half, newRightBalance, address(this));\\n\\n            uint256 addedLP = SafeTransferLib.balanceOf(\\n                address(token.pair),\\n                address(this)\\n            );\\n\\n            uint256 factoryFeeLP = factoryLiquidityFee > 0\\n                ? (addedLP * factoryLiquidityFee) / 100\\n                : 0;\\n            uint256 referralFeeLP = 0;\\n            if (\\n                token.referral.feeReceiver != address(0) &&\\n                token.referral.feePercentage > 0\\n            ) {\\n                referralFeeLP = (addedLP * token.referral.feePercentage) / 100;\\n            }\\n\\n            emit SwapAndLiquify(\\n                address(token.leftSide),\\n                address(token.rightSide),\\n                half,\\n                initialRightBalance,\\n                newRightBalance\\n            );\\n            emit CommissionsTaken(factoryFeeLP, referralFeeLP);\\n\\n            return (\\n                addedLP - factoryFeeLP - referralFeeLP,\\n                factoryFeeLP,\\n                referralFeeLP\\n            );\\n        }\\n    }\\n\\n    /// Swaps left token for right token.\\n    ///\\n    /// @param token The token settings struct\\n    /// @param _amount The amount of left token to swap\\n    ///\\n    /// Swaps the specified amount of the left token for the\\n    /// right token according to the settings in the token struct.\\n    function swapLeftForRightSide(Token memory token, uint256 _amount) private {\\n        SafeTransferLib.safeApprove(\\n            address(token.leftSide),\\n            address(token.router),\\n            _amount\\n        );\\n        address[] memory path = new address[](2);\\n        path[0] = address(token.leftSide);\\n        path[1] = address(token.rightSide);\\n        token.router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            _amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /// Validates that the Uniswap pair is properly set up.\\n    ///\\n    /// @param token The token settings struct\\n    ///\\n    /// Checks that:\\n    /// - The pair token0 != token1 (no same tokens)\\n    /// - One of the pair tokens matches the left token\\n    /// - One of the pair tokens matches the right token\\n    ///\\n    /// If any validation fails, reverts with an error.\\n    ///\\n    /// This ensures the Uniswap pair is properly set up according\\n    /// to the provided token contract settings.\\n    function ensurePairValid(Token memory token) internal view {\\n        address tokenA = token.pair.token0();\\n        address tokenB = token.pair.token1();\\n        address leftSide = address(token.leftSide);\\n        address rightSide = address(token.rightSide);\\n\\n        if (tokenA == tokenB || leftSide == rightSide) {\\n            revert InvalidPair(tokenA, tokenB, leftSide, rightSide);\\n        }\\n\\n        if (\\n            (tokenA != leftSide && tokenA != rightSide) ||\\n            (tokenB != leftSide && tokenB != rightSide)\\n        ) {\\n            revert InvalidPair(tokenA, tokenB, leftSide, rightSide);\\n        }\\n    }\\n\\n    /// @dev Prevents direct Ether transfers to contract\\n    receive() external payable {\\n        revert CannotReceiveEtherDirectly();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CheezburgerSanitizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport \\\"./CheezburgerStructs.sol\\\";\\nimport \\\"./CheezburgerConstants.sol\\\";\\n\\nabstract contract CheezburgerSanitizer is CheezburgerStructs {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    error RouterUndefined();\\n    error NameTooShort(uint256 length, uint256 minLength);\\n    error NameTooLong(uint256 length, uint256 maxLength);\\n    error SymbolTooShort(uint256 length, uint256 minLength);\\n    error SymbolTooLong(uint256 length, uint256 maxLength);\\n    error WebsiteUrlTooLong(uint256 length, uint256 maxLength);\\n    error SocialUrlTooLong(uint256 length, uint256 maxLength);\\n    error SupplyTooLow(uint256 supply);\\n    error SupplyTooLarge(uint256 supply);\\n    error InvalidThreshold(uint256 threshold);\\n    error FeeDurationTooShort(uint256 duration);\\n    error FeeDurationTooLong(uint256 duration);\\n    error FeeStartTooLow(uint256 start);\\n    error FeeStartTooHigh(uint256 start, uint256 max);\\n    error FeeEndTooHigh(uint256 end, uint256 max);\\n    error FeeEndExceedsStart(uint256 end, uint256 start);\\n    error MaxWalletStartTooLow(uint256 start);\\n    error MaxWalletEndTooLow(uint256 end, uint256 min);\\n    error MaxWalletEndTooHigh(uint256 end, uint256 max);\\n    error MaxWalletDurationTooShort(uint256 duration);\\n    error MaxWalletDurationTooLong(uint256 duration, uint256 maxDuration);\\n    error TooManyFeeAddresses(uint256 numAddresses);\\n    error TooFewFeeAddresses(uint256 numAddresses);\\n    error OverflowFeePercentages(uint8 totalFeePercent);\\n    error InvalidFeePercentagesLength(\\n        uint256 percentagesLength,\\n        uint256 addressesLength\\n    );\\n    error FactoryCannotReceiveFees();\\n    error ReferralCannotBeFactory();\\n    error ReferralFeeExceeded();\\n    error ReferralFeeCannotBeZero();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function validateTokenSettings(\\n        address _router,\\n        TokenCustomization memory _customization\\n    ) internal pure {\\n        if (_router == address(0)) {\\n            revert RouterUndefined();\\n        }\\n\\n        if (\\n            bytes(_customization.name).length <\\n            CheezburgerConstants.MIN_NAME_LENGTH\\n        ) {\\n            revert NameTooShort(\\n                bytes(_customization.name).length,\\n                CheezburgerConstants.MIN_NAME_LENGTH\\n            );\\n        }\\n\\n        if (\\n            bytes(_customization.name).length >\\n            CheezburgerConstants.MAX_NAME_LENGTH\\n        ) {\\n            revert NameTooLong(\\n                bytes(_customization.name).length,\\n                CheezburgerConstants.MAX_NAME_LENGTH\\n            );\\n        }\\n\\n        if (\\n            bytes(_customization.symbol).length <\\n            CheezburgerConstants.MIN_SYMBOL_LENGTH\\n        ) {\\n            revert SymbolTooShort(\\n                bytes(_customization.symbol).length,\\n                CheezburgerConstants.MIN_SYMBOL_LENGTH\\n            );\\n        }\\n\\n        if (\\n            bytes(_customization.symbol).length >\\n            CheezburgerConstants.MAX_SYMBOL_LENGTH\\n        ) {\\n            revert SymbolTooLong(\\n                bytes(_customization.symbol).length,\\n                CheezburgerConstants.MAX_SYMBOL_LENGTH\\n            );\\n        }\\n\\n        if (\\n            bytes(_customization.website).length >\\n            CheezburgerConstants.MAX_URL_LENGTH\\n        ) {\\n            revert WebsiteUrlTooLong(\\n                bytes(_customization.website).length,\\n                CheezburgerConstants.MAX_URL_LENGTH\\n            );\\n        }\\n\\n        if (\\n            bytes(_customization.social).length >\\n            CheezburgerConstants.MAX_URL_LENGTH\\n        ) {\\n            revert SocialUrlTooLong(\\n                bytes(_customization.social).length,\\n                CheezburgerConstants.MAX_URL_LENGTH\\n            );\\n        }\\n\\n        if (_customization.supply < 1) {\\n            revert SupplyTooLow(_customization.supply);\\n        }\\n\\n        if (_customization.supply > CheezburgerConstants.SAFE_TOKEN_SUPPLY) {\\n            revert SupplyTooLarge(_customization.supply);\\n        }\\n    }\\n\\n    function validateWalletSettings(\\n        DynamicSettings memory _wallet\\n    ) internal pure {\\n        if (_wallet.percentStart < 100) {\\n            revert MaxWalletStartTooLow(_wallet.percentStart);\\n        }\\n\\n        if (_wallet.percentEnd < CheezburgerConstants.WALLET_MIN_PERCENT_END) {\\n            revert MaxWalletEndTooLow(\\n                _wallet.percentEnd,\\n                CheezburgerConstants.WALLET_MIN_PERCENT_END\\n            );\\n        }\\n\\n        if (_wallet.percentEnd > CheezburgerConstants.WALLET_MAX_PERCENT_END) {\\n            revert MaxWalletEndTooHigh(\\n                _wallet.percentEnd,\\n                CheezburgerConstants.WALLET_MAX_PERCENT_END\\n            );\\n        }\\n\\n        if (_wallet.duration < CheezburgerConstants.WALLET_DURATION_MIN) {\\n            revert MaxWalletDurationTooShort(_wallet.duration);\\n        }\\n\\n        if (_wallet.duration > CheezburgerConstants.WALLET_DURATION_CAP) {\\n            revert MaxWalletDurationTooLong(\\n                _wallet.duration,\\n                CheezburgerConstants.WALLET_DURATION_CAP\\n            );\\n        }\\n    }\\n\\n    function validateReferralSettings(\\n        ReferralSettings memory _referral,\\n        address _factory\\n    ) internal pure {\\n        if (_referral.feeReceiver != address(0)) {\\n            if (_referral.feeReceiver == _factory) {\\n                revert ReferralCannotBeFactory();\\n            }\\n            if (_referral.feePercentage <= 0) {\\n                revert ReferralFeeCannotBeZero();\\n            }\\n            if (_referral.feePercentage > CheezburgerConstants.MAX_LP_FEE) {\\n                revert ReferralFeeExceeded();\\n            }\\n        }\\n    }\\n\\n    function validateFeeSettings(DynamicSettings memory _fee) internal pure {\\n        if (_fee.duration < CheezburgerConstants.FEE_DURATION_MIN) {\\n            revert FeeDurationTooShort(_fee.duration);\\n        }\\n\\n        if (_fee.duration > CheezburgerConstants.FEE_DURATION_CAP) {\\n            revert FeeDurationTooLong(_fee.duration);\\n        }\\n\\n        if (_fee.percentStart < CheezburgerConstants.FEE_START_MIN) {\\n            revert FeeStartTooLow(_fee.percentStart);\\n        }\\n\\n        if (_fee.percentStart > CheezburgerConstants.FEE_START_MAX) {\\n            revert FeeStartTooHigh(\\n                _fee.percentStart,\\n                CheezburgerConstants.FEE_START_MAX\\n            );\\n        }\\n\\n        if (_fee.percentEnd > CheezburgerConstants.FEE_END_MAX) {\\n            revert FeeEndTooHigh(\\n                _fee.percentEnd,\\n                CheezburgerConstants.FEE_END_MAX\\n            );\\n        }\\n\\n        if (_fee.percentEnd > _fee.percentStart) {\\n            revert FeeEndExceedsStart(_fee.percentEnd, _fee.percentStart);\\n        }\\n    }\\n\\n    function validateLiquiditySettings(\\n        LiquiditySettings memory _fees,\\n        address _factory\\n    ) internal pure {\\n        if (\\n            _fees.feeThresholdPercent < CheezburgerConstants.THRESHOLD_MIN ||\\n            _fees.feeThresholdPercent > CheezburgerConstants.THRESHOLD_MAX\\n        ) {\\n            revert InvalidThreshold(_fees.feeThresholdPercent);\\n        }\\n\\n        if (\\n            _fees.feeAddresses.length > CheezburgerConstants.FEE_ADDRESSES_MAX\\n        ) {\\n            revert TooManyFeeAddresses(_fees.feeAddresses.length);\\n        }\\n\\n        if (\\n            _fees.feeAddresses.length < CheezburgerConstants.FEE_ADDRESSES_MIN\\n        ) {\\n            revert TooFewFeeAddresses(_fees.feeAddresses.length);\\n        }\\n\\n        // Prevent any of the feeAddresses to be the factory\\n        for (uint i = 0; i < _fees.feeAddresses.length; i++) {\\n            if (_fees.feeAddresses[i] == _factory) {\\n                revert FactoryCannotReceiveFees();\\n            }\\n        }\\n\\n        if (_fees.feePercentages.length != _fees.feeAddresses.length - 1) {\\n            // If we only have 1 address then we accept [] as feePercentages since 100% goes there\\n            revert InvalidFeePercentagesLength(\\n                _fees.feePercentages.length,\\n                _fees.feeAddresses.length\\n            );\\n        }\\n\\n        if (_fees.feePercentages.length > 1) {\\n            uint8 totalFeePercent;\\n            for (uint8 i = 0; i < _fees.feePercentages.length; i++) {\\n                totalFeePercent += _fees.feePercentages[i];\\n            }\\n            if (totalFeePercent > 99) {\\n                revert OverflowFeePercentages(totalFeePercent);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CheezburgerStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nabstract contract CheezburgerStructs {\\n    /// @dev Settings for customizing the token\\n    /// @param name The name of the token\\n    /// @param symbol The symbol for the token\\n    /// @param website The website associated with the token\\n    /// @param social A social media link associated with the token\\n    /// @param supply The max supply of the token\\n    struct TokenCustomization {\\n        string name;\\n        string symbol;\\n        string website;\\n        string social;\\n        uint256 supply;\\n    }\\n\\n    /// @dev Settings for dynamic fees that change over time\\n    /// @param duration The duration over which the rate changes\\n    /// @param percentStart The starting percentage rate\\n    /// @param percentEnd The ending percentage rate\\n    struct DynamicSettings {\\n        uint256 duration;\\n        uint16 percentStart;\\n        uint16 percentEnd;\\n    }\\n\\n    /// @dev Settings for liquidity pool fees distributed to addresses\\n    /// @param feeThresholdPercent The percentage threshold that triggers liquidity swaps\\n    /// @param feeAddresses The addresses receiving distributed fee amounts\\n    /// @param feePercentages The percentage fee amounts for each address\\n    struct LiquiditySettings {\\n        uint8 feeThresholdPercent;\\n        address[] feeAddresses;\\n        uint8[] feePercentages;\\n    }\\n\\n    /// @dev Settings for referrals. Referrals get commissions from fees whenever people uses the factory to deploy their token.\\n    /// @param feeReceiver The addresses receiving commissions\\n    /// @param feePercentage The percentage fee\\n    struct ReferralSettings {\\n        address feeReceiver;\\n        uint8 feePercentage;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICheezburgerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\ninterface ICheezburgerFactory {\\n    function afterTokenTransfer(\\n        address _sender,\\n        uint256 _leftSideBalance\\n    ) external;\\n\\n    function selfPair() external returns (IUniswapV2Pair);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts\\n/// @author Cheezburger (https://chz.lol)\\nabstract contract ReentrancyGuard {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    error ReentrancyDetected();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    uint8 private locked = 1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    modifier nonReentrant() virtual {\\n        if (locked == 2) {\\n            revert ReentrancyDetected();\\n        }\\n        locked = 2;\\n        _;\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function use the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    bytes32 private constant _VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if add(allowance_, 1) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), _VERSION_HASH)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), _VERSION_HASH)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if add(allowance_, 1) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, gas(), 0x00, gas(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), gas(), 0x00, gas(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 825\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotReceiveEtherDirectly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetZeroAsRightSide\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"ExistingTokenAsRightSide\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FactoryCannotReceiveFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FactoryNotOpened\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"FeeDurationTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"FeeDurationTooShort\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"FeeEndExceedsStart\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"FeeEndTooHigh\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"FeeStartTooHigh\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"FeeStartTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientLiquidityWei\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentagesLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addressesLength\",\"type\":\"uint256\"}],\"name\":\"InvalidFeePercentagesLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFee\",\"type\":\"uint8\"}],\"name\":\"InvalidLiquidityPoolFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leftSide\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightSide\",\"type\":\"address\"}],\"name\":\"InvalidPair\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"InvalidThreshold\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"}],\"name\":\"MaxWalletDurationTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"MaxWalletDurationTooShort\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"MaxWalletEndTooHigh\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"MaxWalletEndTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"MaxWalletStartTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLength\",\"type\":\"uint256\"}],\"name\":\"NameTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLength\",\"type\":\"uint256\"}],\"name\":\"NameTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"totalFeePercent\",\"type\":\"uint8\"}],\"name\":\"OverflowFeePercentages\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PairNotEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyDetected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralCannotBeFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralFeeCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralFeeExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RouterUndefined\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLength\",\"type\":\"uint256\"}],\"name\":\"SocialUrlTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"SupplyTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"SupplyTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLength\",\"type\":\"uint256\"}],\"name\":\"SymbolTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLength\",\"type\":\"uint256\"}],\"name\":\"SymbolTooShort\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numAddresses\",\"type\":\"uint256\"}],\"name\":\"TooFewFeeAddresses\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numAddresses\",\"type\":\"uint256\"}],\"name\":\"TooManyFeeAddresses\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLength\",\"type\":\"uint256\"}],\"name\":\"WebsiteUrlTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"factoryFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralFee\",\"type\":\"uint256\"}],\"name\":\"CommissionsTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenLeft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenRight\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"half\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRightBalance\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract CheezburgerBun\",\"name\":\"leftSide\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"rightSide\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"feeThresholdPercent\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"feeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"feePercentages\",\"type\":\"uint8[]\"}],\"internalType\":\"struct CheezburgerStructs.LiquiditySettings\",\"name\":\"liquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feePercentage\",\"type\":\"uint8\"}],\"internalType\":\"struct CheezburgerStructs.ReferralSettings\",\"name\":\"referral\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct CheezburgerFactory.Token\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"TokenDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_leftSideBalance\",\"type\":\"uint256\"}],\"name\":\"afterTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"burgerRegistry\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract CheezburgerBun\",\"name\":\"leftSide\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"rightSide\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"feeThresholdPercent\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"feeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"feePercentages\",\"type\":\"uint8[]\"}],\"internalType\":\"struct CheezburgerStructs.LiquiditySettings\",\"name\":\"liquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feePercentage\",\"type\":\"uint8\"}],\"internalType\":\"struct CheezburgerStructs.ReferralSettings\",\"name\":\"referral\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"website\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"social\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"internalType\":\"struct CheezburgerStructs.TokenCustomization\",\"name\":\"_customization\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rightSide\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"feeThresholdPercent\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"feeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"feePercentages\",\"type\":\"uint8[]\"}],\"internalType\":\"struct CheezburgerStructs.LiquiditySettings\",\"name\":\"_liquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"_fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"_wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feePercentage\",\"type\":\"uint8\"}],\"internalType\":\"struct CheezburgerStructs.ReferralSettings\",\"name\":\"_referral\",\"type\":\"tuple\"}],\"name\":\"deployWithNative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"website\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"social\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"internalType\":\"struct CheezburgerStructs.TokenCustomization\",\"name\":\"_customization\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rightSide\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rightSideAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"feeThresholdPercent\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"feeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"feePercentages\",\"type\":\"uint8[]\"}],\"internalType\":\"struct CheezburgerStructs.LiquiditySettings\",\"name\":\"_liquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"_fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentStart\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentEnd\",\"type\":\"uint16\"}],\"internalType\":\"struct CheezburgerStructs.DynamicSettings\",\"name\":\"_wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feePercentage\",\"type\":\"uint8\"}],\"internalType\":\"struct CheezburgerStructs.ReferralSettings\",\"name\":\"_referral\",\"type\":\"tuple\"}],\"name\":\"deployWithToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryLiquidityFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_factoryLiquidityFee\",\"type\":\"uint8\"}],\"name\":\"setLiquidityPoolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CheezburgerFactory", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "825", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}