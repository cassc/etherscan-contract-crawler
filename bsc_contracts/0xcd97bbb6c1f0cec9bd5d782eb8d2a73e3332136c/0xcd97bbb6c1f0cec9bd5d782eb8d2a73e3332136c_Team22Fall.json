{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPancakeFactory {\r\n    function createPair(address tokenA,address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n}\r\n\r\ninterface IPancakeRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IPancakePair {\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract DB {\r\n    string public constant USER_ADDRESS = \"user_address\";\r\n    string public constant PARENT = \"parent\";\r\n    string public constant CHILD1 = \"child1\";\r\n    string public constant CHILD2 = \"child2\";\r\n    string public constant DIRECT_RECOMM_PARENT = \"direct_recomm_parent\";\r\n    //member\r\n    string public constant MEMBER_LEVEL = \"member_level\";\r\n    string public constant MEMBER_U = \"member_u\";\r\n    string public constant TOTAL_POWER = \"total_power\";\r\n\r\n    //team\r\n    string public constant TEAM_MEMBER_CNT = \"team_member_cnt\";\r\n    string public constant TOTAL_TEAM_POWER = \"total_team_power\";\r\n\r\n    //bouns\r\n    string public constant TOTAL_BONUS_LP = \"total_bonus_lp\";\r\n    string public constant UNCLAIMED_BONUS_LP = \"unclaimed_bonus_lp\";\r\n\r\n    //Direct recomm reward\r\n    string public constant TOTAL_DIRECT_REC_REWARD_LP = \"direct_rec_reward_lp\";\r\n    string public constant TOTAL_TEAM_REC_REWARD_LP = \"team_rec_reward_lp\";\r\n\r\n    //black\r\n    string public constant IS_BLACK = \"is_black\";\r\n\r\n    mapping(address => mapping(string => Data)) private teamData;\r\n    mapping(address => address[]) public directRecList;\r\n\r\n    struct Data {\r\n        uint256 intValue;\r\n        address addressValue;\r\n    }\r\n\r\n\r\n    function setIntData(\r\n        address _address,\r\n        string memory _key,\r\n        uint256 _value\r\n    ) internal {\r\n        teamData[_address][_key].intValue = _value;\r\n        if (teamData[_address][USER_ADDRESS].addressValue == address(0)) {\r\n            teamData[_address][USER_ADDRESS].addressValue = _address;\r\n        }\r\n    }\r\n\r\n    function setAddressData(\r\n        address _address,\r\n        string memory _key,\r\n        address _value\r\n    ) internal {\r\n        teamData[_address][_key].addressValue = _value;\r\n        if (teamData[_address][USER_ADDRESS].addressValue == address(0)) {\r\n            teamData[_address][USER_ADDRESS].addressValue = _address;\r\n        }\r\n    }\r\n\r\n\r\n    function getIntData(\r\n        address _address,\r\n        string memory _key\r\n    ) public view returns (uint256) {\r\n        return teamData[_address][_key].intValue;\r\n    }\r\n\r\n    function getAddressData(\r\n        address _address,\r\n        string memory _key\r\n    ) public view returns (address) {\r\n        return teamData[_address][_key].addressValue;\r\n    }\r\n\r\n    function addIntData(\r\n        address _address,\r\n        string memory _key,\r\n        uint256 _value\r\n    ) internal {\r\n        teamData[_address][_key].intValue += _value;\r\n        if (teamData[_address][USER_ADDRESS].addressValue == address(0)) {\r\n            teamData[_address][USER_ADDRESS].addressValue = _address;\r\n        }\r\n    }\r\n\r\n    function isExist(address _address) internal view returns (bool) {\r\n        return teamData[_address][USER_ADDRESS].addressValue != address(0);\r\n    }\r\n\r\n}\r\n\r\ncontract Queue {\r\n    uint256 private front;\r\n    uint256 private rear;\r\n    address[] private queue;\r\n\r\n    constructor() {\r\n        front = 0;\r\n        rear = 0;\r\n    }\r\n\r\n    function enqueue(address data) public {\r\n        queue.push(data);\r\n        rear++;\r\n    }\r\n\r\n    function dequeue() public returns (address) {\r\n        require(front < rear, \"Queue is empty\");\r\n        address data = queue[front];\r\n        delete queue[front];\r\n        front++;\r\n        return data;\r\n    }\r\n\r\n    function getFront() public view returns (address) {\r\n        require(front < rear, \"Queue is empty\");\r\n        return queue[front];\r\n    }\r\n\r\n    function getSize() public view returns (uint256) {\r\n        return rear - front;\r\n    }\r\n}\r\n\r\ncontract Team22Fall is DB, Context, Ownable {\r\n    string private _name;\r\n    string private _symbol;\r\n    string private teamTreeStr;\r\n    //team root\r\n    mapping(address => bool) public teamRoots;\r\n    address[] public teamRootKeys;\r\n\r\n    uint256 public bfsMaxDeep;\r\n\r\n    address public bonusAccount;\r\n    uint256 public triggerBonusMinAmt;\r\n\r\n    address public unClaimAccount;\r\n\r\n    address public usdtAddress;\r\n    address public uniswapV2Pair;\r\n    address public uniswapV2Router;\r\n\r\n    address public tokenAddress;\r\n\r\n    IPancakePair public lpToken;\r\n\r\n    mapping(address => bool) public wList;\r\n    address public managerAddress;\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, \"Team22Fall: LOCKED\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    uint private unlockedClaim = 1;\r\n    modifier lockClaim() {\r\n        require(unlockedClaim == 1, \"Team22Fall: Claim LOCKED\");\r\n        unlockedClaim = 0;\r\n        _;\r\n        unlockedClaim = 1;\r\n    }\r\n\r\n    constructor()  {\r\n        _name = \"Team 22 Fall\";\r\n        _symbol = \"Team22Fall\";\r\n\r\n        bfsMaxDeep = 1000;\r\n        triggerBonusMinAmt = 1000 * 1e18;\r\n\r\n        if(block.chainid == 56) {\r\n            uniswapV2Router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n            usdtAddress = 0x55d398326f99059fF775485246999027B3197955;\r\n        } else {\r\n            uniswapV2Router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\r\n            usdtAddress = 0x1C882684706f2648505ef4eA9729045D37f8d992;\r\n        }\r\n        bonusAccount = 0x0C0bd63B350069a34ad0CC9D830dBb738e218De0;\r\n        unClaimAccount = 0x654b81eAAf6AE9185a43247d844Ba140E4Dda619;\r\n\r\n        setWList(msg.sender, true);\r\n    }\r\n\r\n    function name() public view  returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n \r\n    function decimals() public pure   returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    modifier onlySupervise() {\r\n        require(\r\n            _msgSender() == managerAddress || wList[_msgSender()] || _msgSender() == owner(), \"Ownable: caller is not the supervise\" );\r\n        _;\r\n    }\r\n\r\n    function setManagerAddress(address addr) public onlySupervise {\r\n        managerAddress = addr;\r\n        setWList(managerAddress, true);\r\n    }\r\n\r\n    function setWList(address addr, bool flag) public onlyOwner {\r\n        wList[addr] = flag;\r\n    }\r\n\r\n    function setTokenAddress(address token) public onlySupervise {\r\n        tokenAddress = token;\r\n        wList[token] = true;\r\n    }\r\n\r\n    function setBonusTriggerMinAmt(uint256 minAmt) public onlySupervise {\r\n        triggerBonusMinAmt = minAmt;\r\n    }\r\n\r\n    function setBfsMaxDeep(uint256 maxDeep) public onlySupervise {\r\n        bfsMaxDeep = maxDeep;\r\n    }\r\n\r\n    function setBonusAccount(address account) public onlySupervise {\r\n        bonusAccount = account;\r\n    }\r\n\r\n    function setUnClaimAccount(address account) public onlySupervise {\r\n        unClaimAccount = account;\r\n    }\r\n\r\n    function setTeamRoot(address root, bool isRoot) public onlySupervise {\r\n        teamRoots[root] = isRoot;\r\n        teamRootKeys.push(root);\r\n    }\r\n\r\n    function generateRandomAddress(uint256 input) internal pure returns (address) {\r\n        bytes32 hash = keccak256(abi.encodePacked(input));\r\n        return address(uint160(uint256(hash)));\r\n    }\r\n\r\n    function randomBuildTeam(address recAddr, uint256 num, uint256 level) external onlySupervise {\r\n        setIntData(recAddr, MEMBER_LEVEL, level);\r\n        for (uint i = 0; i< num; i++) {\r\n            address _address = generateRandomAddress(i);\r\n            if (! isExist(_address)) {\r\n                findAndSeat(recAddr, _address, level, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    // function batchSeat(\r\n    //     address[] memory addrs,\r\n    //     address recAddr,\r\n    //     uint256 level\r\n    // ) external lock onlySupervise {\r\n    //     require(isExist(recAddr), \"rec address has not seat!\");\r\n    //     for (uint i = 0; i < addrs.length; i++) {\r\n    //         if (!isExist(addrs[i])) {\r\n    //             findAndSeat(recAddr, addrs[i], level, false);\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    function seat(\r\n        address recAddr,\r\n        address _address,\r\n        uint256 level\r\n    ) external lock onlySupervise returns (bool) {\r\n        require(\r\n            (recAddr != address(0)) && (_address != address(0)),\r\n            \"0x0 address seat fail.\"\r\n        );\r\n        require(isExist(recAddr), \"rec address has not seat!\");\r\n        if (!isExist(_address)) {\r\n            return findAndSeat(recAddr, _address, level, false);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function findAndSeat(\r\n        address recAddr,\r\n        address _address,\r\n        uint256 level,\r\n        bool fundMode\r\n    ) internal returns (bool) {\r\n        Queue queue = new Queue();\r\n        queue.enqueue(recAddr);\r\n        while (queue.getSize() > 0) {\r\n            address currentElement = queue.dequeue();\r\n            if (isExist(currentElement)) {\r\n                address c1 = getAddressData(currentElement, CHILD1);\r\n                address c2 = getAddressData(currentElement, CHILD2);\r\n                address realRecAddr = fundMode ? currentElement : recAddr;\r\n                if (c1 != address(0)) {\r\n                    queue.enqueue(c1);\r\n                } else {\r\n                    setAddressData(currentElement, CHILD1, _address);\r\n                    doSeatAndUpdateDirectRecParent(\r\n                        _address,\r\n                        realRecAddr,\r\n                        currentElement,\r\n                        level\r\n                    );\r\n                    return true;\r\n                }\r\n                if (c2 != address(0)) {\r\n                    queue.enqueue(c2);\r\n                } else {\r\n                    setAddressData(currentElement, CHILD2, _address);\r\n                    doSeatAndUpdateDirectRecParent(\r\n                        _address,\r\n                        realRecAddr,\r\n                        currentElement,\r\n                        level\r\n                    );\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function doSeatAndUpdateDirectRecParent(\r\n        address _address,\r\n        address recAddr,\r\n        address parent,\r\n        uint256 level\r\n    ) internal {\r\n        setAddressData(_address, PARENT, parent);\r\n        setAddressData(_address, DIRECT_RECOMM_PARENT, recAddr);\r\n        setIntData(_address, MEMBER_LEVEL, level);\r\n        directRecList[recAddr].push(_address);\r\n    }\r\n\r\n\r\n    event BUTI(\r\n        address indexed account,\r\n        uint256 totalMemCnt,\r\n        uint256 totalTeamPower\r\n    );\r\n\r\n    /****************************** Update TeamInofs, Batch task 1hours one time. ************************************/\r\n    function batchUpdateTeamInfo(address root) external onlySupervise {\r\n        require(root != address(0) && isExist(root));\r\n        INode memory rootNode;\r\n        rootNode._address = root;\r\n        rootNode.deep = 1;\r\n        INode memory result = bfs(rootNode);\r\n        emit BUTI(root, result.teamMemCnt, result.totalTeamPower);\r\n    }\r\n\r\n    struct INode {\r\n        uint256 deep;\r\n        uint256 teamMemCnt;\r\n        uint256 totalTeamPower;\r\n        address _address;\r\n    }\r\n\r\n    function bfs(INode memory current) internal returns (INode memory) {\r\n        if (current._address == address(0) || current.deep > bfsMaxDeep) {\r\n            return current;\r\n        }\r\n        address lchild = getAddressData(current._address, CHILD1);\r\n        address rchild = getAddressData(current._address, CHILD2);\r\n        uint256 power = getIntData(current._address, TOTAL_POWER);\r\n\r\n        INode memory lc;\r\n        lc._address = lchild;\r\n        lc.deep = current.deep + 1;\r\n        lc = bfs(lc);\r\n        INode memory rc;\r\n        rc._address = rchild;\r\n        rc.deep = current.deep + 1;\r\n        rc = bfs(rc);\r\n\r\n        current.totalTeamPower = power + lc.totalTeamPower + rc.totalTeamPower;\r\n        current.teamMemCnt = 1 + lc.teamMemCnt + rc.teamMemCnt;\r\n\r\n        setIntData(current._address, TOTAL_TEAM_POWER, current.totalTeamPower);\r\n        setIntData(current._address, TEAM_MEMBER_CNT, current.teamMemCnt);\r\n        return current;\r\n    }\r\n\r\n    event BatchExecUnclaimLP(address indexed account, uint256 lpBalance);\r\n\r\n    /****************************** Calc Claim Bonus, Batch task 1 days one time. ************************************/\r\n    function batchExecUnclaimLP() external lockClaim onlySupervise {\r\n        // static all team power amt\r\n        uint256 allTeamPower;\r\n        for (uint256 i = 0; i < teamRootKeys.length; i++) {\r\n            if (teamRoots[teamRootKeys[i]] && isExist(teamRootKeys[i])) {\r\n                allTeamPower += getIntData(teamRootKeys[i], TOTAL_TEAM_POWER);\r\n            }\r\n        }\r\n\r\n        uniswapV2Pair = IPancakeFactory(IPancakeRouter(uniswapV2Router).factory()).getPair(tokenAddress, usdtAddress);\r\n        // 1. query account balance.\r\n        lpToken = IPancakePair(uniswapV2Pair);\r\n        uint256 lpBalance = lpToken.balanceOf(bonusAccount);\r\n        if (lpBalance < triggerBonusMinAmt) {\r\n            emit BatchExecUnclaimLP(bonusAccount, lpBalance);\r\n            return;\r\n        }\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n        require(lpToken.token1() == usdtAddress);\r\n        (, uint256 _reserve1, ) = lpToken.getReserves();\r\n        uint256 lpAmtU = (totalSupply != 0)\r\n            ? ((_reserve1 * lpBalance) / totalSupply)\r\n            : 0;\r\n        uint256 toTransferLp = lpBalance;\r\n        uint256 toTransferU = lpAmtU;\r\n        if (allTeamPower < lpAmtU) {\r\n            toTransferLp = _reserve1 > 0\r\n                ? ((allTeamPower * totalSupply) / _reserve1)\r\n                : 0;\r\n            toTransferU = allTeamPower;\r\n        }\r\n\r\n        if (toTransferLp > 0) {\r\n            bool ret = lpToken.transferFrom(\r\n                bonusAccount,\r\n                unClaimAccount,\r\n                toTransferLp\r\n            );\r\n            require(ret, \"transfer from bonusAccount failed.\");\r\n\r\n            for (uint256 i = 0; i < teamRootKeys.length; i++) {\r\n                if (teamRoots[teamRootKeys[i]] && isExist(teamRootKeys[i])) {\r\n                    levelTraversalUnclaimLP(\r\n                        teamRootKeys[i],\r\n                        allTeamPower,\r\n                        toTransferLp,\r\n                        toTransferU\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        emit BatchExecUnclaimLP(bonusAccount, toTransferLp);\r\n    }\r\n\r\n    function levelTraversalUnclaimLP(\r\n        address root,\r\n        uint256 totalPower,\r\n        uint256 lpBalance,\r\n        uint256 lpAmtU\r\n    ) internal {\r\n        Queue queue = new Queue();\r\n        queue.enqueue(root);\r\n        while (queue.getSize() > 0) {\r\n            address currentElement = queue.dequeue();\r\n            if (currentElement != address(0)) {\r\n                uint256 currentPower = getIntData(currentElement, TOTAL_POWER);\r\n                exeUnclaimLP(currentElement, currentPower, totalPower, lpBalance, lpAmtU);\r\n\r\n                address c1 = getAddressData(currentElement, CHILD1);\r\n                address c2 = getAddressData(currentElement, CHILD2);\r\n                if (c1 != address(0)) {\r\n                    queue.enqueue(c1);\r\n                }\r\n                if (c2 != address(0)) {\r\n                    queue.enqueue(c2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function exeUnclaimLP(\r\n        address _address,\r\n        uint256 power,\r\n        uint256 totalPower,\r\n        uint256 lpBalance,\r\n        uint256 lpAmtU\r\n    ) internal {\r\n        if (power == 0 || totalPower == 0 || lpBalance == 0 || lpAmtU == 0) {\r\n            return;\r\n        }\r\n        uint256 usdtAmtInc = (power * lpAmtU) / totalPower;\r\n        uint256 unClaimLp = power >= usdtAmtInc\r\n            ? ((power * lpBalance) / totalPower)\r\n            : ((power * lpBalance) / lpAmtU);\r\n        uint256 remainPower = power >= usdtAmtInc ? (power - usdtAmtInc) : 0;\r\n        setIntData(_address, TOTAL_POWER, remainPower);\r\n        addIntData(_address, UNCLAIMED_BONUS_LP, unClaimLp);\r\n    }\r\n\r\n    event Claim(address indexed account, uint256 bounsAmt);\r\n\r\n    function claim(\r\n        address _address\r\n    ) external lockClaim onlySupervise returns (uint256) {\r\n        uint256 unClaimAmt = getIntData(_address, UNCLAIMED_BONUS_LP);\r\n        if (unClaimAmt > 0) {\r\n            setIntData(_address, UNCLAIMED_BONUS_LP, 0);\r\n            addIntData(_address, TOTAL_BONUS_LP, unClaimAmt);\r\n            bool ret = lpToken.transferFrom(\r\n                unClaimAccount,\r\n                _address,\r\n                unClaimAmt\r\n            );\r\n            require(ret, \"transfer unClaim bouns failed.\");\r\n\r\n            if (ret) {\r\n                emit Claim(_address, unClaimAmt);\r\n                return unClaimAmt;\r\n            }\r\n        }\r\n        emit Claim(_address, 0);\r\n        return 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalMemCnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTeamPower\",\"type\":\"uint256\"}],\"name\":\"BUTI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"}],\"name\":\"BatchExecUnclaimLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounsAmt\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHILD1\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHILD2\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DIRECT_RECOMM_PARENT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IS_BLACK\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEMBER_LEVEL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEMBER_U\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PARENT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_MEMBER_CNT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_BONUS_LP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_DIRECT_REC_REWARD_LP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_POWER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_TEAM_POWER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_TEAM_REC_REWARD_LP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNCLAIMED_BONUS_LP\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USER_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchExecUnclaimLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"root\",\"type\":\"address\"}],\"name\":\"batchUpdateTeamInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bfsMaxDeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directRecList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"getAddressData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"getIntData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract IPancakePair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"randomBuildTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"seat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxDeep\",\"type\":\"uint256\"}],\"name\":\"setBfsMaxDeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setBonusAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmt\",\"type\":\"uint256\"}],\"name\":\"setBonusTriggerMinAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManagerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"root\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRoot\",\"type\":\"bool\"}],\"name\":\"setTeamRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setUnClaimAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setWList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamRootKeys\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerBonusMinAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unClaimAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Team22Fall", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://022be47d19d4a754d866bc1d03c4457b9da594f70db38ca0dc99dae089d89ed0"}