{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nerror TransferFailed();\r\nerror NeedsMoreThanZero();\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed account,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    function balanceOf(\r\n        address account,\r\n        uint256 id\r\n    ) external view returns (uint256);\r\n\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(\r\n        address account,\r\n        address operator\r\n    ) external view returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Staker_DESX is ReentrancyGuard {\r\n    struct Stake {\r\n        uint256 nftId;\r\n        uint256 amount;\r\n        uint48 timestamp;\r\n        bool haveNFT;\r\n        uint256 interest;\r\n        uint48 stakeTime;\r\n    }\r\n\r\n    mapping(address => Stake) public stakes;\r\n    IERC20 public immutable s_rewardsToken;\r\n    IERC20 public immutable s_stakingToken;\r\n    IERC1155 public immutable s_nft;\r\n\r\n    address public owner;\r\n    uint256 public s_lastUpdateTime;\r\n    uint256 public s_rewardPerTokenStored;\r\n\r\n    uint256[] public nftValues = [5, 10, 15, 20];\r\n    uint256[] public timeValues = [0, 5];\r\n\r\n    mapping(address => uint256) public s_userRewardPerTokenPaid;\r\n    mapping(address => uint256) public s_rewards;\r\n\r\n    uint256 public s_totalSupply;\r\n    uint256 public s_totalStaker;\r\n    mapping(address => uint256) public s_balances;\r\n\r\n    event Staked(address indexed user, uint256 indexed amount);\r\n    event WithdrewStake(address indexed user, uint256 indexed amount);\r\n    event RewardsClaimed(address indexed user, uint256 indexed amount);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor(address rewardsToken, address stakingToken, address nft) {\r\n        owner = msg.sender;\r\n        s_rewardsToken = IERC20(rewardsToken);\r\n        s_stakingToken = IERC20(stakingToken);\r\n        s_nft = IERC1155(nft);\r\n    }\r\n\r\n    /**\r\n     * @notice How much reward a token gets based on how long it's been in and during which \"snapshots\"\r\n     */\r\n     function rewardPerToken(address account) public view returns (uint256) {\r\n        uint256 totalSupply = s_totalSupply;\r\n        uint256 apr = stakes[account].interest;\r\n    \r\n        // Adjusted total APR to be 48% annual percentage\r\n        uint256 totalApr = 48000000000000000000;  // 48 * 1e18\r\n    \r\n        if (totalSupply == 0) {\r\n            return s_rewardPerTokenStored;\r\n        }\r\n    \r\n        return\r\n            s_rewardPerTokenStored +\r\n            ((block.timestamp - s_lastUpdateTime) * apr * 1e18) /\r\n            totalSupply;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @notice How much reward a user has earned\r\n     */\r\n    function earned(address account) public view returns (uint256) {\r\n        return\r\n            (s_balances[account] *\r\n                (rewardPerToken(account) - s_userRewardPerTokenPaid[account])) /\r\n            1e18 +\r\n            s_rewards[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit tokens into this contract or with Nft\r\n     * @param amount | How much to stake\r\n     * @param _haveNft | Stake with Nft\r\n     * @param _nftId | Nft id\r\n     * @param stakeTime | how long will it be staked\r\n     */\r\n    function stake(\r\n        uint256 amount,\r\n        bool _haveNft,\r\n        uint256 _nftId,\r\n        uint48 stakeTime\r\n    ) external updateReward(msg.sender) nonReentrant moreThanZero(amount) {\r\n        require(_nftId < 4, \"Nft id must smaller than 4\");\r\n        require(!(stakes[msg.sender].amount > 0), \"You already have a stake\");\r\n        require(\r\n            stakeTime == 7 days || stakeTime == 30 days,\r\n            \"Stake time must be 7 to 30 days\"\r\n        );\r\n        if (_haveNft) {\r\n            s_nft.safeTransferFrom(msg.sender, address(this), _nftId, 1, \"\");\r\n            stakes[msg.sender].haveNFT = true;\r\n            stakes[msg.sender].nftId = _nftId;\r\n        }\r\n\r\n        s_stakingToken.transferFrom(msg.sender, address(this), amount);\r\n        s_totalSupply = s_totalSupply + amount;\r\n        s_balances[msg.sender] = s_balances[msg.sender] + amount;\r\n        stakes[msg.sender].amount = stakes[msg.sender].amount + amount;\r\n        stakes[msg.sender].timestamp = uint48(block.timestamp);\r\n        stakes[msg.sender].stakeTime = stakeTime;\r\n        stakes[msg.sender].interest = calculateInterest(\r\n            _haveNft,\r\n            _nftId,\r\n            stakeTime\r\n        );\r\n        s_totalStaker = s_totalStaker + 1;\r\n        emit Staked(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw tokens from this contract\r\n     */\r\n    function withdraw() external updateReward(msg.sender) nonReentrant {\r\n        require(stakes[msg.sender].amount > 0, \"You don't have a stake\");\r\n        require(\r\n            block.timestamp - stakes[msg.sender].timestamp > 60 minutes, /////////////////////////\r\n            \"You can't withdraw yet\"\r\n        );\r\n        if (\r\n            block.timestamp - stakes[msg.sender].timestamp <\r\n            stakes[msg.sender].stakeTime\r\n        ) {\r\n            withdrawWithPenalty();\r\n        } else {\r\n            if (stakes[msg.sender].haveNFT) {\r\n                s_nft.safeTransferFrom(\r\n                    address(this),\r\n                    msg.sender,\r\n                    stakes[msg.sender].nftId,\r\n                    1,\r\n                    \"\"\r\n                );\r\n                stakes[msg.sender].haveNFT = false;\r\n                stakes[msg.sender].nftId = 0;\r\n            }\r\n\r\n            uint256 amount = s_balances[msg.sender];\r\n            s_totalSupply = s_totalSupply - amount;\r\n            s_balances[msg.sender] = 0;\r\n            delete (stakes[msg.sender]);\r\n            s_stakingToken.transfer(msg.sender, amount);\r\n            s_totalStaker = s_totalStaker - 1;\r\n            emit WithdrewStake(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim rewards\r\n     */\r\n    function claimReward() external updateReward(msg.sender) nonReentrant {\r\n        uint relasableAmount = calculateRelasableAmount();\r\n        if (relasableAmount > 0) {\r\n            s_rewards[msg.sender] -= relasableAmount;\r\n            s_stakingToken.transfer(msg.sender, relasableAmount);\r\n            emit RewardsClaimed(msg.sender, relasableAmount);\r\n        } else {\r\n            revert(\"You don't have any rewards\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw tokens with penalty\r\n     */\r\n    function withdrawWithPenalty() internal updateReward(msg.sender) {\r\n        require(stakes[msg.sender].amount > 0, \"You don't have a stake\");\r\n        require(\r\n            block.timestamp - stakes[msg.sender].timestamp > 60 minutes, ////////////////\r\n            \"You can't withdraw yet\"\r\n        );\r\n        if (stakes[msg.sender].haveNFT) {\r\n            s_nft.safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                stakes[msg.sender].nftId,\r\n                1,\r\n                \"\"\r\n            );\r\n            stakes[msg.sender].haveNFT = false;\r\n            stakes[msg.sender].nftId = 0;\r\n        }\r\n        uint256 amount = s_balances[msg.sender];\r\n        uint256 penalty = (amount * 10) / 100;\r\n        s_totalSupply = s_totalSupply - amount;\r\n        s_balances[msg.sender] = 0;\r\n        delete (stakes[msg.sender]);\r\n        s_stakingToken.transfer(msg.sender, amount - penalty);\r\n        s_totalStaker = s_totalStaker - 1;\r\n        emit WithdrewStake(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate open stake time\r\n     */\r\n    function calculateRelasableAmount() public view returns (uint) {\r\n        uint currentTime = block.timestamp;\r\n        uint vestingStart = stakes[msg.sender].timestamp + 60 minutes; /////////////////////\r\n        uint earnedToken = s_rewards[msg.sender];\r\n        uint relasableAmount = 0;\r\n\r\n        if (currentTime < vestingStart) {\r\n            relasableAmount = 0;\r\n        } \r\n        else{\r\n            relasableAmount = earnedToken;\r\n        }\r\n        return relasableAmount;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4) {\r\n        return\r\n            bytes4(\r\n                keccak256(\r\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\r\n                )\r\n            );\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    function removeStuckToken(address _address) external onlyOwner {\r\n        require(_address != address(this), \"Can't withdraw tokens destined for liquidity\");\r\n        require(IERC20(_address).balanceOf(address(this)) > 0, \"Can't withdraw 0\");\r\n\r\n        IERC20(_address).transfer(owner, IERC20(_address).balanceOf(address(this)));\r\n    }\r\n    /********************/\r\n    /* Modifiers Functions */\r\n    /********************/\r\n    modifier updateReward(address account) {\r\n        s_rewardPerTokenStored = rewardPerToken(account);\r\n\r\n        s_lastUpdateTime = block.timestamp;\r\n        if (account != address(0)) {\r\n            s_rewards[account] = earned(account);\r\n            s_userRewardPerTokenPaid[account] = s_rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n    modifier moreThanZero(uint256 amount) {\r\n        if (amount == 0) {\r\n            revert NeedsMoreThanZero();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n    /********************/\r\n    /* Getter Functions */\r\n    /********************/\r\n    function calculateOpenStakeTime(\r\n        address account\r\n    ) public view returns (uint256) {\r\n        return stakes[account].stakeTime + stakes[account].timestamp;\r\n    }\r\n\r\n    function getStaked(address account) public view returns (uint256) {\r\n        return s_balances[account];\r\n    }\r\n\r\n    function changePercentNFTs(\r\n        uint256 _bronze,\r\n        uint256 _silver,\r\n        uint256 _gold,\r\n        uint256 _platinum\r\n    ) public onlyOwner returns (uint256[] memory) {\r\n        nftValues[0] = _bronze;\r\n        nftValues[1] = _silver;\r\n        nftValues[2] = _gold;\r\n        nftValues[3] = _platinum;\r\n        return nftValues;\r\n    }\r\n\r\n    function changePercentTimeValues(\r\n        uint256 _oneMonth,\r\n        uint256 _threeMonth\r\n    ) public onlyOwner returns (uint256[] memory) {\r\n        timeValues[0] = _oneMonth;\r\n        timeValues[1] = _threeMonth;\r\n        return timeValues;\r\n    }\r\n\r\n    function calculateInterest(\r\n        bool _haveNft,\r\n        uint256 _nftId,\r\n        uint256 lockTime\r\n    ) public view returns (uint256) {\r\n        require(_nftId < 4, \"Nft id must smaller than 4\");\r\n        require(\r\n            lockTime == 7 days || lockTime == 30 days,\r\n            \"Stake time must be 7 to 30 days\"\r\n        );\r\n        uint256 apr = 0;\r\n        if (_haveNft) {\r\n            uint256 nftType = _nftId;\r\n            apr = nftValues[nftType];\r\n        }\r\n        if (lockTime == 7 days) {\r\n            apr = apr + timeValues[0];\r\n        } else if (lockTime == 30 days) {\r\n            apr = apr + timeValues[1];\r\n        }\r\n        return apr;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NeedsMoreThanZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrewStake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_haveNft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"calculateInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateOpenStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateRelasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bronze\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_silver\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_platinum\",\"type\":\"uint256\"}],\"name\":\"changePercentNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oneMonth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_threeMonth\",\"type\":\"uint256\"}],\"name\":\"changePercentTimeValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"s_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_nft\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"s_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_totalStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"s_userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_haveNft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"stakeTime\",\"type\":\"uint48\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"haveNFT\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"stakeTime\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staker_DESX", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000083f512cba8ad0e1e9fc0feb77a2360ef3d7eb80a00000000000000000000000083f512cba8ad0e1e9fc0feb77a2360ef3d7eb80a000000000000000000000000101d9960bf803bc1f9f3803b5917e76cb6f10ac6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://64534900a73b0c3bf0e6d95f26d2d2c175bfbc94d5838be0df940dbdde84adc7"}