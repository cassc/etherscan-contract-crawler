{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-06-17\r\n*/\r\n\r\n/*\r\n * FOX Finance V2 NFT Collection\r\n * \r\n * https://foxfinance.io/\r\n * \r\n * SPDX-License-Identifier: None\r\n */\r\n\r\npragma solidity 0.8.19;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ninterface IFundsSplitter {\r\n    function sendBnb() external payable;\r\n    function sendToken(IBEP20 token, uint256 amount) external;\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n    constructor () {_registerInterface(_INTERFACE_ID_ERC165);}\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {return _supportedInterfaces[interfaceId];}\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");_supportedInterfaces[interfaceId] = true;}\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IBEP20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0)  return \"0\";\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ncontract ERC721 is ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n    string private _name;\r\n    string private _symbol;\r\n    mapping(uint256 => address) private _owners;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: invalid token ID\");\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {return _name;}\r\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n    function _baseURI() internal view virtual returns (string memory) {return \"\";}\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not token owner or approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        _requireMinted(tokenId);\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {_setApprovalForAll(msg.sender, operator, approved);}\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {return _operatorApprovals[owner][operator];}\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {safeTransferFrom(from, to, tokenId, \"\");}\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {return _owners[tokenId] != address(0);}\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\r\n    }\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {_safeMint(to, tokenId, \"\");}\r\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, data),\"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n        _balances[to]++;\r\n        _owners[tokenId] = to;\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n        delete _tokenApprovals[tokenId];\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n        delete _tokenApprovals[tokenId];\r\n        _balances[from]--;\r\n        _balances[to]++;\r\n        _owners[tokenId] = to;\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n    function _requireMinted(uint256 tokenId) internal view virtual {\r\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n    }\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                else assembly {revert(add(32, reason), mload(reason))}\r\n            }\r\n        } else return true;\r\n    }\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\r\n}\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n    uint256[] private _allTokens;\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {return _allTokens.length;}\r\n\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n        if (from == address(0)) _addTokenToAllTokensEnumeration(tokenId);\r\n        else if (from != to) _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        if (to == address(0)) _removeTokenFromAllTokensEnumeration(tokenId);\r\n        else if (to != from) _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n            _ownedTokens[from][tokenIndex] = lastTokenId;\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n        _allTokens[tokenIndex] = lastTokenId;\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\ninterface IRandomNumberGenerator {\r\n    /**\r\n     * @dev Assigns a random value between minValue and maxValue to each element in an array of \r\n     * length arrayLength such that the sum of all values in the array is totalToBeAssigned.\r\n     * @param totalToBeAssigned The total value to be assigned among the elements of the array.\r\n     * @param arrayLength The length of the output array to be returned.\r\n     * @param maxValue The maximum value to be assigned to each element in the output array.\r\n     * @param minValue The minimum value to be assigned to each element in the output array.\r\n     * @return A uint256 array of length arrayLength with each element assigned a random value between minValue and maxValue.\r\n     */\r\n    function randomlyAssignTotalValueToArray(uint256 totalToBeAssigned, uint256 arrayLength, uint256 maxValue, uint256 minValue) external payable returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Generates an array of `howMany` random numbers between `min` and `max`. Returns the array and their total sum.\r\n     * @param howMany The number of random numbers to generate.\r\n     * @param max The maximum random number to return.\r\n     * @param min The minimum random number to return.\r\n     * @return A uint256 array of length `howMany` with each element assigned a random value between `min` and `max`.\r\n     * @return The total sum of all randomly assigned values.\r\n     */\r\n    function getRandomNumbers(uint256 howMany, uint256 max, uint256 min) external payable returns (uint256[] memory, uint256);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function WETH() external pure returns (address);\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ncontract FOX_NFT is ERC721, ERC721Enumerable {\r\n    using Strings for uint256;\r\n    string private baseURI = \"https://api.codecraftrs.com/fox/nft/\";\r\n    string private _fileExtension;\r\n    address private CEO = 0xc3fC2A765FC09158f365cA381c7A1a0939Ed978a;\r\n    IFundsSplitter private fundsSplitter = IFundsSplitter(0x3089c15506205fe5b3a9cF9e4dB564574d4dfbbd);\r\n    IRandomNumberGenerator public randomnessSupplier = IRandomNumberGenerator(0x435f6f723528085197C5C19c053304788b9555AE);\r\n    uint256 vrfReserve = 0.1 ether;\r\n\r\n    mapping(address => bool) public isFox;\r\n    \r\n    uint256 private _totalSupply;\r\n\r\n    IBEP20 public constant BUSD = IBEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    IBEP20 public constant USDT = IBEP20(0x55d398326f99059fF775485246999027B3197955);\r\n    IBEP20 public constant FOX = IBEP20(0x16a7460B9246AE508f18e87bDa4e5B4C1AE8F112);\r\n    IBEP20 public constant WBNB = IBEP20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    address public constant FOX_BNB_POOL = 0x4d3d40BEaF014a68ac8a24978438F2Ce7B6a286b;\r\n    address public constant BUSD_BNB_POOL = 0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16;\r\n\r\n    uint256 public totalMintFeesInBusd;\r\n    uint256 public totalMintFeesInUsdt;\r\n    uint256 public totalMintFeesInFox;\r\n    uint256 public totalMintFeesInBnb;\r\n\r\n    uint256 public totalUpgradePointFeesInBusd;\r\n    uint256 public totalUpgradePointFeesInUsdt;\r\n    uint256 public totalUpgradePointFeesInFox;\r\n    uint256 public totalUpgradePointFeesInBnb;\r\n\r\n    uint256 public totalRarityUpgradeFeesInBusd;\r\n    uint256 public totalRarityUpgradeFeesInUsdt;\r\n    uint256 public totalRarityUpgradeFeesInFox;\r\n    uint256 public totalRarityUpgradeFeesInBnb;\r\n\r\n    uint256 public totalRerollFeesInBusd;\r\n    uint256 public totalRerollFeesInUsdt;\r\n    uint256 public totalRerollFeesInFox;\r\n    uint256 public totalRerollFeesInBnb;\r\n\r\n    uint256 private constant MULTIPLIER = 10**18;\r\n\r\n    mapping (uint256 => uint256) public priceOfType;\r\n    mapping (uint256 => uint256) public maxNftsOfType;\r\n    mapping (uint256 => uint256) public nftsLeftOfType;\r\n    mapping (uint256 => uint256) public totalSupplyOfType;\r\n    mapping (uint256 => uint256) public openTimeOfType;\r\n    mapping (uint256 => uint256) public closeTimeOfType;\r\n    mapping (uint256 => bool) public isRandomRarity;\r\n    mapping (uint256 => uint256) public rarityOfType;\r\n\r\n    mapping (uint256 => uint256) public typeOfNft;\r\n    mapping (uint256 => uint256) public upgradePoints;\r\n    \r\n    mapping(address => uint256) public rerollCoupons;\r\n\r\n    struct attributes{\r\n        uint256 power;\r\n        uint256 stamina;\r\n        uint256 agility;\r\n        uint256 luck;\r\n        uint256 dexterity;\r\n        uint256 intellect;\r\n    }\r\n\r\n    mapping (uint256 => attributes) public statsOfNft;\r\n\r\n    mapping (uint256 => uint256) public priceOfUpgradePoints;\r\n    mapping (uint256 => uint256) public priceForReroll;\r\n    mapping (uint256 => uint256) public priceForRarityUpgrade;\r\n\r\n    mapping (uint256 => uint256) public rarityWeight;\r\n    uint256 public rarityDivisor = 10000;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == CEO, \"Only the CEO can do that\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyFox() {\r\n        require(isFox[msg.sender], \"Only Fox can do that\");\r\n        _;\r\n    }\r\n\r\n    modifier noCheating {\r\n        if(!isFox[msg.sender]) require(tx.origin == msg.sender, \"Cheating is not allowed\");\r\n        _;\r\n    }\r\n\r\n    event NftMinted(\r\n        uint256 id,\r\n        uint256 typeMinted,\r\n        uint256 rarity,\r\n        uint256 totalStats,\r\n        uint256 power,\r\n        uint256 stamina,\r\n        uint256 agility,\r\n        uint256 luck,\r\n        uint256 dexterity,\r\n        uint256 intellect,\r\n        uint256 upgradePoints\r\n    );\r\n\r\n    event NftUpdated(\r\n        uint256 _id,\r\n        uint256 _type,\r\n        uint256 _rarity,\r\n        uint256 _totalStats,\r\n        uint256 _power,\r\n        uint256 _stamina,\r\n        uint256 _agility,\r\n        uint256 _luck,\r\n        uint256 _dexterity,\r\n        uint256 _intellect,\r\n        uint256 _upgradePoints\r\n    );\r\n\r\n    event NftMintInitiated(address minter, uint256 idOfMintedNFT, uint256 typeMinted);\r\n    event NftRerollInitiated(uint256 idOfRerolledNft);   \r\n    event NftUpgradePointsBought(uint256 _id, uint256 _howMany);\r\n    event NftRarityUpgraded(uint256 _id);\r\n    event NftLevelUpgraded(uint256 _id, uint256 _totalIncrease, uint256 _upgradePoints);\r\n\r\n    event NewTypeCreated(uint256 newType, uint256 price, uint256 maxSupply, uint256 openingTime, uint256 closingTime, bool random, uint256 rarity);\r\n    event TypeModified(uint256 typeToModify, uint256 price, uint256 maxSupply, uint256 openingTime, uint256 closingTime, bool typeIsRandom, uint256 rarity);\r\n    event FoxWalletSet(address foxWallet, bool status);\r\n\r\n    constructor() ERC721(\"Fox Finance NFT\", \"FOXV2NFT\") {\r\n        rarityWeight[1] = 3500;\r\n        rarityWeight[2] = 6500;\r\n        rarityWeight[3] = 8800;\r\n        rarityWeight[4] = 9800;\r\n        rarityWeight[5] = 10000;\r\n        isFox[CEO] = true;\r\n        priceOfUpgradePoints[1] = 0.1 ether;  \r\n        priceForRarityUpgrade[1] = 10 ether; \r\n        priceForReroll[1] = 5 ether;\r\n        priceOfUpgradePoints[2] = 0.5 ether;  \r\n        priceForRarityUpgrade[2] = 25 ether; \r\n        priceForReroll[2] = 10 ether;\r\n        priceOfUpgradePoints[3] = 1 ether;  \r\n        priceForRarityUpgrade[3] = 75 ether; \r\n        priceForReroll[3] = 15 ether;\r\n        priceOfUpgradePoints[4] = 1.75 ether;  \r\n        priceForRarityUpgrade[4] = 125 ether; \r\n        priceForReroll[4] = 20 ether;\r\n        priceOfUpgradePoints[5] = 2.5 ether;   \r\n        priceForReroll[5] = 25 ether;\r\n        BUSD.approve(address(fundsSplitter),type(uint256).max);\r\n        USDT.approve(address(fundsSplitter),type(uint256).max);\r\n        FOX.approve(address(fundsSplitter),type(uint256).max);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable){super._beforeTokenTransfer(from, to, tokenId);}\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool){return super.supportsInterface(interfaceId);}\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {return string(abi.encodePacked(baseURI, tokenId.toString(), _fileExtension));}\r\n    function setBaseUri(string memory uri) external onlyCEO {baseURI = uri;}\r\n\tfunction setFileExtension(string memory ext) external onlyCEO {_fileExtension = ext;}\r\n    function _transfer(address from,address to, uint256 tokenId) internal override {super._transfer(from,to,tokenId);}\r\n\r\n    function _mintToken(address _to, uint256 _tokenId) internal returns (uint256) {\r\n        _mint(_to, _tokenId);\r\n        return _tokenId;\r\n    }\r\n\r\n    function bnbAmountEqualToBusd(uint256 busdAmount) public view returns (uint256 bnbNeeded) {\r\n        return WBNB.balanceOf(BUSD_BNB_POOL) * busdAmount / BUSD.balanceOf(BUSD_BNB_POOL);\r\n    }\r\n\r\n    function foxAmountEqualToBusd(uint256 busdAmount) public view returns (uint256 foxNeeded) {\r\n        uint256 bnbNeeded = bnbAmountEqualToBusd(busdAmount);\r\n        foxNeeded = FOX.balanceOf(FOX_BNB_POOL) * bnbNeeded / WBNB.balanceOf(FOX_BNB_POOL);\r\n        return foxNeeded;\r\n    }\r\n\r\n    function mintPriceInBnb(uint256 typeToMint) public view returns (uint256 bnbNeeded) {\r\n        uint256 price = priceOfType[typeToMint];\r\n        return WBNB.balanceOf(BUSD_BNB_POOL) * price / BUSD.balanceOf(BUSD_BNB_POOL);\r\n    }\r\n\r\n    function mintPriceInFox(uint256 typeToMint) public view returns (uint256 foxNeeded) {\r\n        uint256 price = priceOfType[typeToMint];\r\n        uint256 bnbNeeded = WBNB.balanceOf(BUSD_BNB_POOL) * price / WBNB.balanceOf(BUSD_BNB_POOL);\r\n        foxNeeded = FOX.balanceOf(FOX_BNB_POOL) * bnbNeeded / WBNB.balanceOf(FOX_BNB_POOL);\r\n        return foxNeeded;\r\n    }\r\n\r\n    function mintWithBusd(uint256 typeToMint) external {\r\n        uint256 price = priceOfType[typeToMint];\r\n        require(BUSD.transferFrom(msg.sender, address(this), price),\"BUSD transfer failed\");\r\n        totalMintFeesInBusd += price;\r\n        mintToWallet(msg.sender, typeToMint);\r\n    }\r\n\r\n    function mintWithUsdt(uint256 typeToMint) external {\r\n        uint256 price = priceOfType[typeToMint];\r\n        require(USDT.transferFrom(msg.sender, address(this), price),\"USDT transfer failed\");\r\n        totalMintFeesInUsdt += price;\r\n        mintToWallet(msg.sender, typeToMint);\r\n    }\r\n\r\n    function mintWithFox(uint256 typeToMint) external {\r\n        uint256 price = priceOfType[typeToMint];\r\n        uint256 priceInFox = foxAmountEqualToBusd(price);\r\n        require(FOX.transferFrom(msg.sender, address(this), priceInFox),\"FOX transfer failed\");\r\n        totalMintFeesInFox += priceInFox;\r\n        mintToWallet(msg.sender, typeToMint);\r\n    }\r\n\r\n    function mintWithBnb(uint256 typeToMint) external payable {\r\n        uint256 price = priceOfType[typeToMint];\r\n        uint256 priceInBnb = bnbAmountEqualToBusd(price);\r\n        require(msg.value >= priceInBnb, \"Not enough BNB paid\");\r\n        totalMintFeesInBnb += priceInBnb;\r\n        uint256 refund = msg.value - priceInBnb;\r\n        payable(msg.sender).transfer(refund);\r\n        mintToWallet(msg.sender, typeToMint);\r\n    }\r\n\r\n    function mintForFree(address to, uint256 typeToMint) public onlyFox {\r\n        mintToWallet(to, typeToMint);\r\n    }\r\n\r\n    function mintToWallet(address to, uint256 typeToMint) internal {\r\n        require(openTimeOfType[typeToMint] <= block.timestamp && closeTimeOfType[typeToMint] >= block.timestamp, \"type not available\");\r\n        require(nftsLeftOfType[typeToMint] > 0, \"sold out\");\r\n        uint256 idOfMintedNFT = _mintToken(to, _totalSupply);\r\n        typeOfNft[idOfMintedNFT] = typeToMint;\r\n        _totalSupply++;\r\n        totalSupplyOfType[typeToMint]++;\r\n        nftsLeftOfType[typeToMint]--;\r\n        getRandomAttributes(idOfMintedNFT);\r\n        emit NftMintInitiated(to, idOfMintedNFT, typeToMint);\r\n    }\r\n\r\n    function giveUpgradePointsForFree(uint256 id, uint256 howMany) external onlyFox {\r\n        ( , howMany) = getPriceForUpgradePoints(id, howMany);\r\n        addUpgradePoints(id, howMany);\r\n    }\r\n\r\n    function buyUpgradePointsWithBusd(uint256 id, uint256 howMany) external {\r\n        (uint256 price, uint256 points) = getPriceForUpgradePoints(id, howMany);\r\n        howMany = points;\r\n        require(BUSD.transferFrom(msg.sender, address(this), price),\"BUSD transfer failed\");\r\n        totalUpgradePointFeesInBusd += price;\r\n        addUpgradePoints(id, howMany);\r\n    }\r\n\r\n    function buyUpgradePointsWithUsdt(uint256 id, uint256 howMany) external {\r\n        (uint256 price, uint256 points) = getPriceForUpgradePoints(id, howMany);\r\n        howMany = points;\r\n        require(USDT.transferFrom(msg.sender, address(this), price),\"USDT transfer failed\");\r\n        totalUpgradePointFeesInUsdt += price;\r\n        addUpgradePoints(id, howMany);\r\n    }\r\n\r\n    function buyUpgradePointsWithFox(uint256 id, uint256 howMany) external {\r\n        (uint256 price, uint256 points) = getPriceForUpgradePoints(id, howMany);\r\n        howMany = points;\r\n        uint256 priceInFox = foxAmountEqualToBusd(price);\r\n        require(FOX.transferFrom(msg.sender, address(this), priceInFox),\"FOX transfer failed\");\r\n        totalUpgradePointFeesInFox += priceInFox;\r\n        addUpgradePoints(id, howMany);\r\n    }\r\n\r\n    function buyUpgradePointsWithBnb(uint256 id, uint256 howMany) external payable {\r\n        (uint256 price, uint256 points) = getPriceForUpgradePoints(id, howMany);\r\n        howMany = points;\r\n        uint256 priceInBnb = bnbAmountEqualToBusd(price);\r\n        require(msg.value >= priceInBnb, \"Not enough BNB paid\");\r\n        totalUpgradePointFeesInBnb += priceInBnb;\r\n        if(msg.value > priceInBnb) {\r\n            uint256 refund = msg.value - priceInBnb;\r\n            payable(msg.sender).transfer(refund);\r\n        }\r\n        addUpgradePoints(id, howMany);\r\n    }\r\n    \r\n    function getPriceForUpgradePoints(uint256 id, uint256 howMany) public view returns (uint256, uint256) {\r\n        uint256 totalStats = getTotalStatsOfId(id);\r\n        uint256 nextLevel = totalStats / 100 * 100 + 100;\r\n        if(totalStats + upgradePoints[id] + howMany >= nextLevel) howMany = nextLevel - totalStats - upgradePoints[id] - 1;\r\n        return (howMany * priceOfUpgradePoints[totalStats/100], howMany);\r\n    }\r\n\r\n    function addUpgradePoints(uint256 id, uint256 howMany) internal {\r\n        upgradePoints[id] += howMany;\r\n        emit NftUpgradePointsBought(id, howMany);\r\n        emitUpdatedNftInfo(id);\r\n    }\r\n\r\n    function buyRarityUpgradeWithBusd(uint256 id, uint256 statToUpgrade) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getRarityUpgradePrice(id);\r\n        require(BUSD.transferFrom(msg.sender, address(this), price),\"BUSD transfer failed\");\r\n        totalRarityUpgradeFeesInBusd += price;\r\n        upgradeRarity(id, statToUpgrade);\r\n    }\r\n\r\n    function buyRarityUpgradeWithUsdt(uint256 id, uint256 statToUpgrade) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getRarityUpgradePrice(id);\r\n        require(USDT.transferFrom(msg.sender, address(this), price),\"USDT transfer failed\");\r\n        totalRarityUpgradeFeesInUsdt += price;\r\n        upgradeRarity(id, statToUpgrade);    \r\n    }\r\n\r\n    function buyRarityUpgradeWithFox(uint256 id, uint256 statToUpgrade) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getRarityUpgradePrice(id);\r\n        uint256 priceInFox = foxAmountEqualToBusd(price);\r\n        require(FOX.transferFrom(msg.sender, address(this), priceInFox),\"FOX transfer failed\");\r\n        totalRarityUpgradeFeesInFox += priceInFox;\r\n        upgradeRarity(id, statToUpgrade);\r\n    }\r\n\r\n    function buyRarityUpgradeWithBnb(uint256 id, uint256 statToUpgrade) external payable {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getRarityUpgradePrice(id);\r\n        uint256 priceInBnb = bnbAmountEqualToBusd(price);\r\n        require(msg.value >= priceInBnb, \"Not enough BNB paid\");\r\n        uint256 refund = msg.value - priceInBnb;\r\n        payable(msg.sender).transfer(refund);\r\n        totalRarityUpgradeFeesInBnb += priceInBnb;\r\n        upgradeRarity(id, statToUpgrade);\r\n    }\r\n\r\n    function getRarityUpgradePrice(uint256 id) public view returns (uint256) {\r\n        uint256 totalStats = getTotalStatsOfId(id);\r\n        require(totalStats % 100 == 99 && upgradePoints[id] == 0, \"Level not high enough\");\r\n        require(totalStats < 500,\"Max500\");\r\n        return priceForRarityUpgrade[totalStats/100];\r\n    }\r\n\r\n    function upgradeRarity(uint256 id, uint256 statToUpgrade) internal {\r\n        require(statToUpgrade>0 && statToUpgrade<7,\"1-to-6\");\r\n        if(statToUpgrade == 1) statsOfNft[id].power++;\r\n        if(statToUpgrade == 2) statsOfNft[id].stamina++;\r\n        if(statToUpgrade == 3) statsOfNft[id].agility++;\r\n        if(statToUpgrade == 4) statsOfNft[id].luck++;\r\n        if(statToUpgrade == 5) statsOfNft[id].dexterity++;\r\n        if(statToUpgrade == 6) statsOfNft[id].intellect++;\r\n        require(checkLimit(id),\"Max120\");\r\n        emit NftRarityUpgraded(id);\r\n        emitUpdatedNftInfo(id);\r\n    }\r\n\r\n    function upgradeNft(uint256 id, uint256 powerUp, uint256 staminaUp, uint256 agilityUp, uint256 luckUp, uint256 dexterityUp, uint256 intellectUp) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        require(powerUp + staminaUp + agilityUp + luckUp + dexterityUp + intellectUp <= upgradePoints[id], \"Not enough points\");\r\n        statsOfNft[id].power += uint256(powerUp);\r\n        statsOfNft[id].stamina += uint256(staminaUp);\r\n        statsOfNft[id].agility += uint256(agilityUp);\r\n        statsOfNft[id].luck += uint256(luckUp);\r\n        statsOfNft[id].dexterity += uint256(dexterityUp);\r\n        statsOfNft[id].intellect += uint256(intellectUp);\r\n        upgradePoints[id] -= powerUp + staminaUp + agilityUp + luckUp + dexterityUp + intellectUp;\r\n        require(checkLimit(id),\"Max120\");\r\n        emit NftLevelUpgraded(id,powerUp + staminaUp + agilityUp + luckUp + dexterityUp + intellectUp,upgradePoints[id]); \r\n        emitUpdatedNftInfo(id);\r\n    }\r\n\r\n    function checkLimit(uint256 id) internal view returns(bool) {\r\n        attributes memory current = statsOfNft[id];\r\n        if(current.power > 120) return false;\r\n        if(current.stamina > 120) return false;\r\n        if(current.agility > 120) return false;\r\n        if(current.luck > 120) return false;\r\n        if(current.dexterity > 120) return false;\r\n        if(current.intellect > 120) return false;\r\n        if(current.power + current.stamina + current.agility + current.luck + current.dexterity + current.intellect > 599) return false;\r\n        return true;\r\n    }\r\n\r\n    function rerollNftWithBusd(uint256 id) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getPriceForReroll(id);\r\n        require(BUSD.transferFrom(msg.sender, address(this), price),\"BUSD transfer failed\");\r\n        totalRerollFeesInBusd += price;\r\n        initiateReroll(id);\r\n    }\r\n\r\n    function rerollNftWithUsdt(uint256 id) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getPriceForReroll(id);\r\n        require(USDT.transferFrom(msg.sender, address(this), price),\"USDT transfer failed\");\r\n        totalRerollFeesInUsdt += price;\r\n        initiateReroll(id);\r\n    }\r\n\r\n    function rerollNftWithFox(uint256 id) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getPriceForReroll(id);\r\n        uint256 priceInFox = foxAmountEqualToBusd(price);\r\n        require(FOX.transferFrom(msg.sender, address(this), priceInFox),\"FOX transfer failed\");\r\n        totalRerollFeesInFox += priceInFox;\r\n        initiateReroll(id);\r\n    }\r\n\r\n    function rerollNftWithBnb(uint256 id) external payable {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        uint256 price = getPriceForReroll(id);\r\n        uint256 priceInBnb = bnbAmountEqualToBusd(price);\r\n        require(msg.value >= priceInBnb, \"Not enough BNB paid\");\r\n        totalRerollFeesInBnb += priceInBnb;\r\n        if(msg.value > priceInBnb) {\r\n            uint256 refund = msg.value - priceInBnb;\r\n            payable(msg.sender).transfer(refund);\r\n        }\r\n        initiateReroll(id);\r\n    }\r\n\r\n    function rerollWithCoupon(uint256 id) external {\r\n        require(ownerOf(id) == msg.sender, \"Not yours\");\r\n        require(rerollCoupons[msg.sender]>0,\"No coupon\");\r\n        rerollCoupons[msg.sender]--;\r\n        initiateReroll(id);\r\n    }\r\n\r\n    function giveRerollCoupon(address receiver) external onlyFox {\r\n        rerollCoupons[receiver]++;\r\n    }\r\n\r\n    function initiateReroll(uint256 id) internal {\r\n        getRandomAttributes(id);\r\n        emit NftRerollInitiated(id);\r\n    }\r\n    \r\n    function getPriceForReroll(uint256 id) public view returns (uint256) {\r\n        uint256 totalStats = getTotalStatsOfId(id);\r\n        return priceForReroll[totalStats/100];\r\n    }\r\n\r\n    function getRandomAttributes(uint256 id) internal noCheating {\r\n        attributes memory thisNft;\r\n        uint256 totalStats = getTotalStatsOfId(id);\r\n        bool isMint = totalStats == 0;\r\n        if(isMint) {\r\n            uint256 typeOfThisId = typeOfNft[id];\r\n            uint256 rarity;\r\n\r\n            if(isRandomRarity[typeOfThisId]){\r\n                (uint256[] memory rarityRandomness, ) = randomnessSupplier.getRandomNumbers{value: 0.001 ether}(1, rarityDivisor, 0);\r\n                for(uint256 i= 1; i <= 5; i++){\r\n                    if(rarityRandomness[0] < rarityWeight[i]) {\r\n                        rarity = i;\r\n                        break; \r\n                    }\r\n                }\r\n            } else rarity = rarityOfType[typeOfThisId];\r\n\r\n            totalStats = rarity * 100;\r\n\r\n        } else {\r\n            upgradePoints[id] += totalStats % 100;\r\n            totalStats = totalStats / 100 * 100;\r\n        }\r\n\r\n        uint256[] memory values = randomnessSupplier.randomlyAssignTotalValueToArray{value: 0.001 ether}(totalStats, 6, 120, 0);\r\n\r\n        thisNft.power = uint256(values[0]);\r\n        thisNft.stamina = uint256(values[1]);\r\n        thisNft.agility = uint256(values[2]);\r\n        thisNft.intellect = uint256(values[3]);\r\n        thisNft.dexterity = uint256(values[4]);\r\n        thisNft.luck = uint256(values[5]);\r\n        statsOfNft[id] = thisNft;\r\n\r\n        if(isMint) emit NftMinted(id, typeOfNft[id], totalStats/100, totalStats, thisNft.power, thisNft.stamina, thisNft.agility, thisNft.luck, thisNft.dexterity, thisNft.intellect, 0);\r\n        else emitUpdatedNftInfo(id);\r\n    }\r\n\r\n    function getTotalStatsOfId(uint256 id) public view returns(uint256) {\r\n        require(_exists(id),\"Doesn't exist\");\r\n        uint256 totalStats = statsOfNft[id].power + statsOfNft[id].stamina + statsOfNft[id].agility + statsOfNft[id].luck + statsOfNft[id].dexterity + statsOfNft[id].intellect;\r\n        return totalStats;\r\n    }\r\n\r\n    function getRarityOfId(uint256 id) public view returns(uint256) {\r\n        uint256 totalStats = statsOfNft[id].power + statsOfNft[id].stamina + statsOfNft[id].agility + statsOfNft[id].luck + statsOfNft[id].dexterity + statsOfNft[id].intellect;\r\n        return totalStats / 100;\r\n    }\r\n\r\n    function getAllStatsOfId(uint256 id) public view returns(uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        return(statsOfNft[id].power, statsOfNft[id].stamina, statsOfNft[id].agility, statsOfNft[id].luck, statsOfNft[id].dexterity, statsOfNft[id].intellect);\r\n    }\r\n    \r\n    function emitUpdatedNftInfo(uint256 id) public {\r\n        uint256 totalStats = statsOfNft[id].power + statsOfNft[id].stamina + statsOfNft[id].agility + statsOfNft[id].luck + statsOfNft[id].dexterity + statsOfNft[id].intellect;\r\n        uint256 rarity = totalStats / 100;\r\n        emit NftUpdated(id, typeOfNft[id], rarity, totalStats, statsOfNft[id].power, statsOfNft[id].stamina, statsOfNft[id].agility, statsOfNft[id].luck, statsOfNft[id].dexterity, statsOfNft[id].intellect, upgradePoints[id]);\r\n    }\r\n\r\n    function setUpgradePointCost(uint256 rarity, uint256 priceInBusd) external onlyCEO {priceOfUpgradePoints[rarity] = priceInBusd;}    \r\n    function setPriceForRarityUpgrade(uint256 rarity, uint256 priceInBusd) external onlyCEO {priceForRarityUpgrade[rarity] = priceInBusd;}    \r\n    function setPriceForReroll(uint256 rarity, uint256 priceInBusd) external onlyCEO {priceForReroll[rarity] = priceInBusd;}\r\n    function rescueBnb() external onlyCEO {sendBnb(address(this).balance);}\r\n\r\n    function collectFunds() external onlyFox {\r\n        sendTokens(BUSD);\r\n        sendTokens(USDT);\r\n        sendTokens(FOX);\r\n        sendBnb(address(this).balance - vrfReserve);\r\n    }\r\n\r\n    function sendTokens(IBEP20 token) internal {\r\n        fundsSplitter.sendToken(token,token.balanceOf(address(this)));\r\n    }\r\n\r\n    function sendBnb(uint256 amount) internal {\r\n        fundsSplitter.sendBnb{value: amount}();\r\n    }\r\n\r\n    function setNewFundsSplitter(IFundsSplitter newFundsSplitter) external onlyCEO {\r\n        fundsSplitter = newFundsSplitter;\r\n        BUSD.approve(address(fundsSplitter),type(uint256).max);\r\n        USDT.approve(address(fundsSplitter),type(uint256).max);\r\n        FOX.approve(address(fundsSplitter),type(uint256).max);\r\n    }\r\n\r\n    function setRarityWeights(uint256 common, uint256 uncommon, uint256 rare, uint256 epic, uint256 legendary) external onlyCEO {\r\n        rarityWeight[1] = common;\r\n        rarityWeight[2] = uncommon;\r\n        rarityWeight[3] = rare;\r\n        rarityWeight[4] = epic;\r\n        rarityWeight[5] = legendary;\r\n    }\r\n\r\n    function createNewType(uint256 newType, uint256 price, uint256 maxSupply, uint256 openingTime, uint256 closingTime, bool random, uint256 rarity) external onlyCEO {\r\n        require(maxNftsOfType[newType] == 0, \"Type already exists\");\r\n        require(maxSupply > 0, \"Max0\");\r\n        priceOfType[newType] = price * 1 ether;\r\n        maxNftsOfType[newType] = maxSupply;\r\n        nftsLeftOfType[newType] = maxSupply;\r\n        openTimeOfType[newType] = openingTime;\r\n        closeTimeOfType[newType] = closingTime;\r\n        isRandomRarity[newType] = random;\r\n        if(!random) rarityOfType[newType] = rarity;\r\n        emit NewTypeCreated(newType, price, maxSupply, openingTime, closingTime, random, rarity);\r\n    }\r\n\r\n    function modifyType(uint256 typeToModify, uint256 price, uint256 maxSupply, uint256 openingTime, uint256 closingTime, uint256 rarity) external onlyCEO {\r\n        require(maxNftsOfType[typeToModify] != 0, \"Type doesn't exist yet\");\r\n        if(maxSupply > maxNftsOfType[typeToModify]) nftsLeftOfType[typeToModify] += maxSupply - maxNftsOfType[typeToModify];\r\n        if(maxSupply < maxNftsOfType[typeToModify]) nftsLeftOfType[typeToModify] -= maxNftsOfType[typeToModify] - maxSupply;\r\n        priceOfType[typeToModify] = price * 1 ether;\r\n        maxNftsOfType[typeToModify] = maxSupply;\r\n        openTimeOfType[typeToModify] = openingTime;\r\n        closeTimeOfType[typeToModify] = closingTime;\r\n        rarityOfType[typeToModify] = rarity;\r\n        emit TypeModified(typeToModify, price, maxSupply, openingTime, closingTime, isRandomRarity[typeToModify], rarity);\r\n    } \r\n\r\n    function setFoxWallet(address FoxWallet, bool status) external onlyCEO {\r\n        isFox[FoxWallet] = status;\r\n        emit FoxWalletSet(FoxWallet, status);\r\n    }\r\n\r\n    function transferOwnership(address newCeo) external onlyCEO {\r\n        CEO = newCeo;\r\n        isFox[CEO] = true;\r\n    }\r\n\r\n    function setNewRandomnessSupplier(IRandomNumberGenerator newRandomnessSupplier) external onlyFox {\r\n        randomnessSupplier = newRandomnessSupplier;\r\n    }\r\n\r\n    function setStatsOfNFT(uint256 id, uint256 powerUp, uint256 staminaUp, uint256 agilityUp, uint256 luckUp, uint256 dexterityUp, uint256 intellectUp) external onlyCEO{\r\n        statsOfNft[id].power = uint256(powerUp);\r\n        statsOfNft[id].stamina = uint256(staminaUp);\r\n        statsOfNft[id].agility = uint256(agilityUp);\r\n        statsOfNft[id].luck = uint256(luckUp);\r\n        statsOfNft[id].dexterity = uint256(dexterityUp);\r\n        statsOfNft[id].intellect = uint256(intellectUp);\r\n        require(checkLimit(id),\"Max120\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"foxWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"FoxWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"random\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"}],\"name\":\"NewTypeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_upgradePoints\",\"type\":\"uint256\"}],\"name\":\"NftLevelUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idOfMintedNFT\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typeMinted\",\"type\":\"uint256\"}],\"name\":\"NftMintInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typeMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStats\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stamina\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"agility\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"luck\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dexterity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intellect\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upgradePoints\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"NftRarityUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idOfRerolledNft\",\"type\":\"uint256\"}],\"name\":\"NftRerollInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rarity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalStats\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_power\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stamina\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_agility\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_luck\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dexterity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_intellect\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_upgradePoints\",\"type\":\"uint256\"}],\"name\":\"NftUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_howMany\",\"type\":\"uint256\"}],\"name\":\"NftUpgradePointsBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typeToModify\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"typeIsRandom\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"}],\"name\":\"TypeModified\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD_BNB_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FOX\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FOX_BNB_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"}],\"name\":\"bnbAmountEqualToBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bnbNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statToUpgrade\",\"type\":\"uint256\"}],\"name\":\"buyRarityUpgradeWithBnb\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statToUpgrade\",\"type\":\"uint256\"}],\"name\":\"buyRarityUpgradeWithBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statToUpgrade\",\"type\":\"uint256\"}],\"name\":\"buyRarityUpgradeWithFox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statToUpgrade\",\"type\":\"uint256\"}],\"name\":\"buyRarityUpgradeWithUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"buyUpgradePointsWithBnb\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"buyUpgradePointsWithBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"buyUpgradePointsWithFox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"buyUpgradePointsWithUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"closeTimeOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"random\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"}],\"name\":\"createNewType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"emitUpdatedNftInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"}],\"name\":\"foxAmountEqualToBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"foxNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAllStatsOfId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPriceForReroll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"getPriceForUpgradePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getRarityOfId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getRarityUpgradePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTotalStatsOfId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"giveRerollCoupon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"giveUpgradePointsForFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFox\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isRandomRarity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxNftsOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintForFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintPriceInBnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bnbNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintPriceInFox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"foxNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintWithBnb\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintWithBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintWithFox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToMint\",\"type\":\"uint256\"}],\"name\":\"mintWithUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeToModify\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"}],\"name\":\"modifyType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftsLeftOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"openTimeOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceForRarityUpgrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceForReroll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfUpgradePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomnessSupplier\",\"outputs\":[{\"internalType\":\"contract IRandomNumberGenerator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rarityDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarityOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarityWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rerollCoupons\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rerollNftWithBnb\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rerollNftWithBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rerollNftWithFox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rerollNftWithUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rerollWithCoupon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ext\",\"type\":\"string\"}],\"name\":\"setFileExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"FoxWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setFoxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFundsSplitter\",\"name\":\"newFundsSplitter\",\"type\":\"address\"}],\"name\":\"setNewFundsSplitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRandomNumberGenerator\",\"name\":\"newRandomnessSupplier\",\"type\":\"address\"}],\"name\":\"setNewRandomnessSupplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInBusd\",\"type\":\"uint256\"}],\"name\":\"setPriceForRarityUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInBusd\",\"type\":\"uint256\"}],\"name\":\"setPriceForReroll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"common\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uncommon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"legendary\",\"type\":\"uint256\"}],\"name\":\"setRarityWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"powerUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staminaUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"agilityUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dexterityUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intellectUp\",\"type\":\"uint256\"}],\"name\":\"setStatsOfNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInBusd\",\"type\":\"uint256\"}],\"name\":\"setUpgradePointCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"statsOfNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stamina\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"agility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luck\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dexterity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intellect\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintFeesInBnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintFeesInBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintFeesInFox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintFeesInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRarityUpgradeFeesInBnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRarityUpgradeFeesInBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRarityUpgradeFeesInFox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRarityUpgradeFeesInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRerollFeesInBnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRerollFeesInBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRerollFeesInFox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRerollFeesInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupplyOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUpgradePointFeesInBnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUpgradePointFeesInBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUpgradePointFeesInFox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUpgradePointFeesInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"typeOfNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"powerUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staminaUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"agilityUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dexterityUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intellectUp\",\"type\":\"uint256\"}],\"name\":\"upgradeNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FOX_NFT", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://801241effcaa425db41a376816e15535039e5ccc9dafe9990e3f95851a4d25f9"}