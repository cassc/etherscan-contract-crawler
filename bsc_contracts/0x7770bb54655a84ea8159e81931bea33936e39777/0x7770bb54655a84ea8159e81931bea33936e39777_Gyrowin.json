{"SourceCode": "// SPDX-License-Identifier: BSD-3-Clause\r\n\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\n\r\npragma solidity = 0.8.19;\r\n\r\n/**\r\n* Welcome to Gyrowin,\r\n* Gyrowin is a decentralised cross-chain gaming and defi platform,\r\n* which let's user play lottery and earn interest on their\u00a0winnings\r\n* through lending available within the platform.\r\n* Users will also be able to borrow token to play lottery with zero liquidation on their collateral.\r\n* Moreover, Gyrowin also introduces the new fun way to stake Gyrowin token in Binance chain\r\n* with multiple rewards sources resulting in higher\u00a0yield for the participants.\r\n* https://gyro.win\r\n*/\r\n\r\ncontract Gyrowin {\r\n\r\n    string public constant name = \"Gyrowin\";\r\n    string public constant symbol = \"GW\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant maxTotalSupply = 5000000000 * 10 ** decimals; // 5 billion Gyrowin\r\n\r\n    // totalSupply denotes tokens that have been mined and locked including circulatingSupply\r\n    uint256 private _totalSupply;\r\n\r\n    // circulatingSupply denotes tokens that currently exists in circulation\r\n    uint256 public circulatingSupply;\r\n\r\n    // notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n    // notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n    event NewOwner(address oldOwner, address newOwner);\r\n    event NewMoneyPlantCA(address oldMoneyPlantCA, address newMoneyPlantCA);\r\n    event NewReserveCA(address oldReserveCA, address NewReserveCA);\r\n    event NewTreasury(address oldTreasury, address NewTreasury);\r\n    event NewFreezeLockCA(address oldFreezeLocakCA, address NewFreezeLockCA);\r\n    event NewLoyaltyCA(address oldLoyaltyCA, address NewLoyaltyCA);\r\n    event NewVestingCA(address oldVestingCA, address NewVestingCA);\r\n    /// @notice An event thats emittied when users are able to trade token\r\n    event TradingOpen(bool indexed boolean, uint256 openTime);\r\n    /// @notice An event thats emitted when token are locked and circulating supply in decreased\r\n    event LockInfo(address indexed account, uint256 amount, uint256 lockTime);\r\n    /// @notice An event thats emitted when token are unlocked and circulating supply in increased back again\r\n    event UnlockInfo(address indexed account, uint256 amount, uint256 lockTime);\r\n\r\n    address private _owner;\r\n\r\n    address private constant deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // money plant contract\r\n    address private _moneyPlantCA;\r\n\r\n    // treasury account\r\n    address private _treasury;\r\n\r\n    // vesting contract\r\n    address private _vestingCA;\r\n\r\n    // reserve contract\r\n    address private _reserveCA;\r\n\r\n    // cex listings & loyalty contract\r\n    address private _loyaltyCA;\r\n\r\n    // freeze lock contract\r\n    address private _freezeLockCA;\r\n\r\n\r\n    /**\r\n     * @notice Construct a new Gyrowin token\r\n    */\r\n    bool private _initialize;\r\n    function initialize(address owner) external {\r\n        require(owner == address(0x05803c32E393765a204e22fCF560421729cbCA42), \"GW: !owner\");\r\n        require(_initialize == false, \"GW: initialized\");\r\n        _owner = owner;\r\n        _balance[address(this)] = maxTotalSupply;\r\n\r\n        _totalSupply = maxTotalSupply;\r\n        circulatingSupply = maxTotalSupply;\r\n\r\n        /// @notice buy/sell fee 1%\r\n        _fee = 1;\r\n\r\n        _gasPriceLimit = 5000000000 wei;\r\n\r\n        // exclude fee for owner and this contract\r\n        _excludedFee[owner] = true;\r\n        _excludedFee[address(this)] = true;\r\n\r\n        _initialize = true;\r\n    }\r\n\r\n    receive() payable external {}\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"GW: !owner\"); _;\r\n    }\r\n\r\n    modifier onlyMoneyPlantCA() {\r\n        require(isMoneyPlantCA(msg.sender), \"GW: no money plant contract\"); _;\r\n    }\r\n\r\n    modifier onlyOperatorCA() {\r\n        require(isOperator(msg.sender), \"GW: !operator\"); _;\r\n    }\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public _fee;\r\n\r\n    /// @notice store trading start block by openTrading function\r\n    uint256 private launchBlock;\r\n\r\n    /// @notice initial gas price limit\r\n    uint256 private _gasPriceLimit;\r\n\r\n    /// @notice status of open trading\r\n    bool private _openTrading;\r\n\r\n    /// @notice status of buy/sell fee\r\n    bool private lockedFee;\r\n\r\n    /// @notice status of MEV restriction\r\n    bool private releasedMEV;\r\n\r\n    /// @notice to renounce transfering vesting tokens to vesting contract\r\n    bool private vestingLock;\r\n\r\n    /// @notice list operator\r\n    mapping(address => bool) private _operator;\r\n  \r\n    /// @notice list buy/sell fee execluded account\r\n    mapping(address => bool) private _excludedFee;\r\n\r\n    /// @notice list token pair contract address\r\n    mapping(address => bool) private _swapPair;\r\n\r\n    /// @notice limited gas price for mev\r\n    mapping(address => bool) private _mev;\r\n\r\n    /// @notice notice Official record of token balances for each account\r\n    mapping(address => uint256) private _balance;\r\n\r\n    /// @notice notice Allowance amounts on behalf of others\r\n    mapping(address => mapping(address => uint256)) private _allowance;\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping(address => address) public _delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping(address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH =\r\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH =\r\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping(address => uint256) public nonces;\r\n \r\n\r\n    /// @notice The totalSupply method denotes the current circulating total supply of the tokens including lock\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n     /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param owner The address of the account holding the funds\r\n     * @param spender The address of the account spending the funds\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return _allowance[owner][spender];\r\n    }\r\n\r\n\r\n    // This is an alternative to {approve} that can be used as a mitigation for problems described in {BEP20-approve}.\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowance[_msgSender()][spender] + (addedValue));\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // This is an alternative to {approve} that can be used as a mitigation for problems described in {BEP20-approve}.\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowance[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"GW: decreased allowance below zero\" );\r\n\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n \r\n     /**\r\n     * @notice Transfer `amount` tokens from `sender` to `recepient'\r\n     * @param recipient The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        require(recipient != address(0), \"GW: can't transfer to the zero address\");\r\n\r\n        _transfer(_msgSender(), recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param sender The address of the source account\r\n     * @param recipient The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\r\n        require(recipient != address(0), \"GW: can't transfer to the zero address\");\r\n        require(sender != address(0), \"GW: can't transfer from the zero address\");\r\n        \r\n        _spendAllowance(sender, _msgSender(), amount);\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balance[account];\r\n    }\r\n\r\n\r\n    /**\r\n     * burn and mint for money plant (staking)\r\n     * burnAmount: the amount of burn\r\n     * rewardAmount: the amount of mint\r\n     * rewardAmount can not exceed the burnAmount\r\n     * rewards revert when circulatingSupply is greater than 5% (4.75 billion) of max. total supply\r\n     * circulatingSupply should be 4 billion at least\r\n     */\r\n    function moneyPlant(uint256 burnAmount, uint256 rewardAmount) external onlyMoneyPlantCA() returns (bool) {\r\n        require(_balance[_treasury] >= burnAmount, \"GW: burn amount exceeds treasury balance\");\r\n        require(rewardAmount <= burnAmount, \"GW: reward amount exceeds burn amount\");\r\n\r\n        _totalSupply -= burnAmount;\r\n        _balance[_treasury] -= burnAmount;\r\n        circulatingSupply -= burnAmount;\r\n\r\n        // burn game rewards\r\n        emit Transfer(_treasury, deadAddress, burnAmount);\r\n\r\n        // money plant extra rewards\r\n        if (rewardAmount != 0) {\r\n            circulatingSupply += rewardAmount;\r\n            _balance[_treasury] += rewardAmount;\r\n\r\n            emit Transfer(deadAddress, _treasury, rewardAmount);\r\n\r\n            // totalSupply should be equal and less than 5% of max. total supply with the current run\r\n            if (_totalSupply > maxTotalSupply * 95 / 100) {\r\n                revert(\"GW: require more burn\");\r\n            }\r\n        }\r\n\r\n        // totalSupply should be equal to or greater than 20% of max. total supply\r\n        if (_totalSupply < maxTotalSupply * 80 / 100) {\r\n            revert(\"GW: total supply should be equal to or greater than 4 billion\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {BEP20-_burn}.\r\n     */\r\n    function burn(uint256 amount) external returns (bool) {\r\n        require(_msgSender() != address(0), \"GW: burn from the zero address\");\r\n        require(_balance[_msgSender()] >= amount, \"GW: burn amount exceeds balance\");\r\n        \r\n        _burn(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function burnFrom(address account, uint256 amount) external returns (bool) {\r\n        require(account != address(0), \"GW: burn from the zero address\");\r\n        require(_balance[account] >= amount, \"GW: burn amount exceeds balance\");\r\n\r\n        address spender = _msgSender();\r\n        _spendAllowance(account, spender, amount); // check for the allowance\r\n\r\n        _burn(account, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Delegate votes from `_msgSender()` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public {\r\n        return _delegate(_msgSender(), delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\r\n        );\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\r\n        );\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(\r\n            signatory != address(0),\r\n            \"GW::delegateBySig: invalid signature\"\r\n        );\r\n        require(\r\n            nonce == nonces[signatory]++,\r\n            \"GW::delegateBySig: invalid nonce\"\r\n        );\r\n        require(\r\n            block.timestamp <= expiry,\r\n            \"GW::delegateBySig: signature expired\"\r\n        );\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint256) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return\r\n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint256) {\r\n        require(blockNumber < block.number, \"GW::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = _balance[delegator];\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(address senderRep, address recepientRep, uint256 amount) internal {\r\n        if (senderRep != recepientRep && amount > 0) {\r\n            if (senderRep != address(0)) {\r\n                uint32 senderRepNum = numCheckpoints[senderRep];\r\n                uint256 senderRepOld = senderRepNum > 0\r\n                    ? checkpoints[senderRep][senderRepNum - 1].votes\r\n                    : 0;\r\n                uint256 senderRepNew = senderRepOld - amount;\r\n                _writeCheckpoint(\r\n                    senderRep,\r\n                    senderRepNum,\r\n                    senderRepOld,\r\n                    senderRepNew\r\n                );\r\n            }\r\n\r\n            if (recepientRep != address(0)) {\r\n                uint32 recepientRepNum = numCheckpoints[recepientRep];\r\n                uint256 recepientRepOld = recepientRepNum > 0\r\n                    ? checkpoints[recepientRep][recepientRepNum - 1].votes\r\n                    : 0;\r\n                uint256 recepientRepNew = recepientRepOld + amount;\r\n                _writeCheckpoint(\r\n                    recepientRep,\r\n                    recepientRepNum,\r\n                    recepientRepOld,\r\n                    recepientRepNew\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\r\n        uint32 blockNumber = safe32(\r\n            block.number,\r\n            \"GW::_writeCheckpoint: block number exceeds 32 bits\"\r\n        );\r\n\r\n        if (\r\n            nCheckpoints > 0 &&\r\n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\r\n        ) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(\r\n                blockNumber,\r\n                newVotes\r\n            );\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"GW: can't approve to the zero address\");\r\n        require(spender != address(0), \"GW: can't approve to the zero address\");\r\n\r\n        _allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * the following features added for standard erc20 _transfer function:\r\n     * check either excluded account for buy/sell fee\r\n     * enable to start swap & wallet transfer when _openTrading is true, otheriwse authorized account transfer only\r\n     * check either swap or wallet transfer\r\n     * added buy/sell fee if tranfer is swap\r\n     * the fee goes to Money plant contract\r\n     * first 4 block numbers has gas price limt with 5 gwei after _openTrading is true\r\n     * and then gas limit for only mev if sender/receipient is in _mev variable\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(_balance[sender] >= amount, \"GW: balance is insufficient\");\r\n\r\n        bool takeFee = true;\r\n        if (_excludedFee[sender] || _excludedFee[recipient]) {\r\n            takeFee = false;\r\n        }\r\n\r\n        // start trading\r\n        if (_openTrading) {\r\n            // take fees on buy/sell only, no fees on transfer\r\n            if (_fee != 0 && (_swapPair[sender] || _swapPair[recipient]) && takeFee) {\r\n                uint256 taxAmount = amount * _fee / 100;\r\n                amount = amount - taxAmount;\r\n\r\n                // tax distribute to Money plant\r\n                transferToken(sender, _treasury, taxAmount);\r\n\r\n                // help to protect honest holders from front-running\r\n                if (block.number <= launchBlock + 3 && tx.gasprice > _gasPriceLimit) {\r\n                    revert(\"GW: exceeded Gas Price\");\r\n                } else if (\r\n                    (_mev[sender] || _mev[recipient]) && \r\n                    _gasPriceLimit != 0 &&\r\n                    _gasPriceLimit < tx.gasprice\r\n                    ) {\r\n                    revert(\"GW: exceeded Gas Price\");\r\n                }\r\n            }\r\n            _moveDelegates(_delegates[sender], _delegates[recipient], amount);\r\n            transferToken(sender, recipient, amount);\r\n        // authorized account only\r\n        } else if (_excludedFee[sender]) {\r\n            _moveDelegates(_delegates[sender], _delegates[recipient], amount);\r\n            transferToken(sender, recipient, amount);\r\n        } else {\r\n            revert(\"GW: trading has not been started\");\r\n        }\r\n    }\r\n\r\n    ///@notice normal token transfer\r\n    function transferToken(address sender, address recipient, uint256 amount) internal {\r\n        unchecked {\r\n            _balance[sender] -= amount;\r\n            _balance[recipient] += amount;\r\n        }\r\n\r\n         emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the dead address.\r\n     *\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        unchecked {\r\n            _balance[account] -= amount;\r\n            circulatingSupply -= amount;\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, deadAddress, amount);\r\n\r\n        // totalSupply should be equal to or greater than 20% of max. total supply\r\n        if (_totalSupply < maxTotalSupply * 80 / 100) {\r\n            revert(\"GW: total supply should be equal to or greater than 4 billion\");\r\n        }\r\n    }\r\n\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2 ** 32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n\r\n    function getChainId() internal view returns (uint256) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId;\r\n    }\r\n\r\n\r\n    function renounceOwnership(address dead) external onlyOwner() {\r\n        require(dead == address(0), \"GW: invalid address\");\r\n        _owner = address(0);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice change the owner of the contract\r\n     * @dev only callable by the owner\r\n     * @param account new owner address\r\n     */\r\n    function updateOwner(address account) external onlyOwner() {\r\n        require(account != address(0),\"GW: invalid owner address\");\r\n\r\n        _owner = account;\r\n\r\n        emit NewOwner(_owner, account);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice change the operator of the contract\r\n     * @dev only callable by the owner\r\n     * @param contractAddr new operator address\r\n     */\r\n    function setOperator(address contractAddr, bool status) external onlyOwner() {\r\n        require(isContract(contractAddr), \"GW: !contract\");\r\n        require(\r\n            contractAddr == _vestingCA ||\r\n            contractAddr == _reserveCA ||\r\n            contractAddr == _loyaltyCA ||\r\n            contractAddr == _freezeLockCA,\r\n            \"GW: invalid operator\"\r\n            );\r\n\r\n        if (status == true) {\r\n            require(_operator[contractAddr] == false, \"GW: already listed\");\r\n        }\r\n\r\n        _operator[contractAddr] = status;\r\n    }\r\n\r\n\r\n    ///@notice update money plant contract address, another term for our staking system\r\n    ///@dev only callable by the owner\r\n    function updateMoneyPlantCA(address contractAddr) external onlyOwner() {\r\n        require(isContract(contractAddr), \"GW: !contract\");\r\n\r\n        _moneyPlantCA = contractAddr;\r\n\r\n        emit NewMoneyPlantCA(_moneyPlantCA, contractAddr);\r\n    }\r\n\r\n    /// update treasury account\r\n    /// @dev only callable by the owner\r\n    function updateTreasury(address account) external onlyOwner() {\r\n        _treasury = account;\r\n\r\n        emit NewTreasury(_treasury, account);\r\n    }\r\n\r\n    /// update reserve contract address\r\n    /// @dev only callable by the owner\r\n    function updateReserveCA(address contractAddr) external onlyOwner() {\r\n        require(isContract(contractAddr), \"GW: !contract\");\r\n\r\n        _reserveCA = contractAddr;\r\n\r\n        emit NewReserveCA(_reserveCA, contractAddr);\r\n    }\r\n\r\n    /// update loyalty contract address\r\n    /// @dev only callable by the owner\r\n    function updateLoyaltyCA(address contractAddr) external onlyOwner() {\r\n        require(isContract(contractAddr), \"GW: !contract\");\r\n\r\n        _loyaltyCA = contractAddr;\r\n\r\n        emit NewLoyaltyCA(_loyaltyCA, contractAddr);\r\n    }\r\n\r\n    /// update freeze contract address\r\n    /// @dev only callable by the owner\r\n    function updatefreezeLockCA(address contractAddr) external onlyOwner() {\r\n        require(isContract(contractAddr), \"GW: !contract\");\r\n\r\n        _freezeLockCA = contractAddr;\r\n\r\n        emit NewFreezeLockCA(_freezeLockCA, contractAddr);\r\n    }\r\n\r\n    /// update vesting contract address\r\n    /// @dev only callable by the owner\r\n    function updateVestingCA(address contractAddr) external onlyOwner() {\r\n        require(isContract(contractAddr), \"GW: !contract\");\r\n        \r\n        _vestingCA = contractAddr;\r\n\r\n        emit NewVestingCA(_vestingCA, contractAddr);\r\n    }\r\n\r\n\r\n    /// @notice check if the account address is the owner\r\n    /// @dev call by the owner modifier\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == _owner;\r\n    }\r\n\r\n    /// @notice check if the contract address is the operator\r\n    /// @dev call by the operator modifier\r\n    function isOperator(address contractAddr) public view returns (bool) {\r\n        return _operator[contractAddr];\r\n    }\r\n\r\n    /// @notice check if the address is the staking contract address (money plant)\r\n    function isMoneyPlantCA(address account) public view returns (bool) {\r\n        return account == _moneyPlantCA;\r\n    }\r\n\r\n    /// @notice check if the address is the vesting contract address\r\n    function isVestingCA(address account) public view returns (bool) {\r\n        return account == _vestingCA;\r\n    }\r\n\r\n    /// @notice check if the address is the reserve contract address\r\n    function isReserveCA(address account) public view returns (bool) {\r\n        return account == _reserveCA;\r\n    }\r\n\r\n    /// @notice check if the address is the loyalty contract address\r\n    function isLoyaltyCA(address account) public view returns (bool) {\r\n        return account == _loyaltyCA;\r\n    }\r\n\r\n    /// @notice check if the address is the freezelock contract address\r\n    function isFreezeLockCA(address account) public view returns (bool) {\r\n        return account == _freezeLockCA;\r\n    }\r\n\r\n     /// @notice check if the address is the treasury account\r\n    function isTreasury(address account) public view returns (bool) {\r\n        return account == _treasury;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice set pair token address\r\n     * @dev only callable by the owner\r\n     * @param account address of the pair\r\n     * @param pair check \r\n     */\r\n    function setSwapPair(address account, bool pair) external onlyOwner() {\r\n        require(account != address(0), \"GW: can't be zero address\");\r\n        if (pair == true) {\r\n            require(_swapPair[account] == false, \"GW: already listed\");\r\n        }\r\n        _swapPair[account] = pair;\r\n    }\r\n\r\n    /**\r\n     * @notice check if the address is right pair address\r\n     * @param account address of the swap pair\r\n     * @return Account is valid pair or not\r\n     */\r\n    function isSwapPair(address account) public view returns (bool) {\r\n        return _swapPair[account];\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice set mev to limit the swap gas price\r\n     * @dev this setting is only valid with setGasLimit function and only callable by owner\r\n     * @param account address of the mev\r\n     * @param mev true to set the limit of address swap price\r\n     */\r\n    function setMEV(address[] calldata account, bool mev) external onlyOwner() {\r\n        require(account.length > 0, \"GW: empty accounts\");\r\n        for (uint256 i = 0; i < account.length; i++) {\r\n            _mev[account[i]] = mev;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice set swap gas price limit to prevent mev\r\n     * @dev if gasPriceLimit sets zero then no more limit possible forever with setMEV function\r\n     * and only callable by owner\r\n     * this setting is only valid with setMEV function\r\n     * the minimum gas price is 3gwei\r\n     * @param gasPriceLimit amount of gas limit\r\n     */\r\n    function setGasLimt(uint256 gasPriceLimit) external onlyOwner() {\r\n        require(gasPriceLimit >= 3000000000 wei, \"GW: min. gas price limit is 3gwei\");\r\n        require(releasedMEV == false, \"GW: gas price limit renounced with zero\");\r\n        _gasPriceLimit = gasPriceLimit;\r\n        if (_gasPriceLimit == 0) {\r\n            // release gas price limit & mev forever\r\n            releasedMEV = true;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice exclude trading fee(tax) for operators\r\n     * @dev only callable by the owner\r\n     * @param account address to be excluded\r\n     * @param excluded set wether to be exluded or not\r\n     */\r\n    function excludedFeeAccount(address account, bool excluded) external onlyOwner() {\r\n        if (excluded == true) {\r\n            require(_excludedFee[account] == false, \"GW: already listed\");\r\n        }\r\n        _excludedFee[account] = excluded;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice set fees\r\n     * @dev only callable by the owner\r\n     * @param fee buy and sell fee for the token\r\n     * - requirements\r\n     * require maximum 1% buy/sell fee\r\n     * require zero buy/sell forever if _fee set to zero\r\n     */\r\n    function setFee(uint256 fee) external onlyOwner() {\r\n        require(fee <= 1, \"GW: max fee is 1%\");\r\n        require(lockedFee == false, \"GW: fee renounced with zero\");\r\n        _fee = fee;\r\n        if (_fee == 0) {\r\n            // fee to zero forever\r\n            lockedFee = true;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Set when to open trading\r\n     * @dev set block number to check when _openTrading is true\r\n     * @dev Trading cannot be set false after it started\r\n     */\r\n    function openTrading(bool start) external onlyOwner() {\r\n        require(!_openTrading, \"GW: can't stop trading\");\r\n        launchBlock = block.number;\r\n        _openTrading = start;\r\n\r\n        // renounce transfering vesting tokens to vesting contract\r\n        vestingLock = true;\r\n\r\n        emit TradingOpen(start, block.timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n     * transfer tokens for lock and subtract it from circulatingSupply\r\n     * renounce transferring automatically when trading opened\r\n     */    \r\n    function initializeLock(address contractAddr, uint256 amount) external onlyOperatorCA() {\r\n        require(\r\n            _swapPair[contractAddr] == true ||\r\n            contractAddr == _vestingCA ||\r\n            contractAddr == _reserveCA ||\r\n            contractAddr == _loyaltyCA ||\r\n            contractAddr == _freezeLockCA,\r\n            \"GW: invalid contract\");\r\n        require(amount <= _balance[address(this)], \"GW: amount exceeds balance\");\r\n\r\n        if (!vestingLock && _swapPair[contractAddr] == false) {\r\n            transferToken(address(this), contractAddr, amount);\r\n        }\r\n        \r\n        // subtract locked token from circulatingSupply\r\n        circulatingSupply -= amount;\r\n\r\n        emit LockInfo(contractAddr, amount, block.timestamp);\r\n    }\r\n\r\n    \r\n    // increase circulating supply by unlock    \r\n    function addCirculatingSupply(address contractAddr, uint256 amount) external onlyOperatorCA() {\r\n        require(\r\n            contractAddr == _vestingCA ||\r\n            contractAddr == _reserveCA ||\r\n            contractAddr == _loyaltyCA ||\r\n            contractAddr == _freezeLockCA,\r\n            \"GW: invalid contract\"\r\n            );\r\n        require(amount <= _balance[contractAddr], \"GW: amount exceeds balance\");\r\n\r\n        // add unlocked token to circulatingSupply\r\n        circulatingSupply += amount;\r\n\r\n        emit UnlockInfo(contractAddr, amount, block.timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\r\n     *\r\n     * Does not update the allowance value in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(address owner, address spender, uint256 value) internal {\r\n        uint256 currentAllowance = this.allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n\r\n            require(currentAllowance >= value, \"GW: insufficent allowance\");\r\n\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - value);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice rescue BNB sent to the address\r\n     * @param amount to be retrieved from the contract\r\n     * @param to address of the destination account\r\n     * @dev only callable by the owner\r\n     */\r\n    function rescueBNB(uint256 amount, address payable to) external onlyOwner() {\r\n        require(amount <= address(this).balance, \"GW: insufficient funds\");\r\n        to.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice rescue BEP20 token sent to the address\r\n     * @param amount to be retrieved for BEP20 contract\r\n     * @param recipient address of the destination account\r\n     * @dev only callable by the owner\r\n     */\r\n    function rescusBEP20Token(address token, address recipient, uint256 amount) external payable onlyOwner() {\r\n        require(amount <= IERC20(token).balanceOf(address(this)), \"GW: insufficient funds\");\r\n        IERC20(token).safeTransfer(recipient, amount);\r\n    }   \r\n\r\n\r\n    /**\r\n     * @notice check if the address is contract\r\n     * @param contractAddr address of the contract\r\n     * @return check true if contractAddr is a contract\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     * \r\n     * @dev Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n\r\n     */\r\n    function isContract(address contractAddr) private view returns (bool check) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n        assembly {\r\n            codehash := extcodehash(contractAddr)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    } \r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"LockInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFreezeLocakCA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewFreezeLockCA\",\"type\":\"address\"}],\"name\":\"NewFreezeLockCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLoyaltyCA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewLoyaltyCA\",\"type\":\"address\"}],\"name\":\"NewLoyaltyCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldMoneyPlantCA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMoneyPlantCA\",\"type\":\"address\"}],\"name\":\"NewMoneyPlantCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReserveCA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewReserveCA\",\"type\":\"address\"}],\"name\":\"NewReserveCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewTreasury\",\"type\":\"address\"}],\"name\":\"NewTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldVestingCA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewVestingCA\",\"type\":\"address\"}],\"name\":\"NewVestingCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"boolean\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"}],\"name\":\"TradingOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"UnlockInfo\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addCirculatingSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludedFeeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"initializeLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isFreezeLockCA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isLoyaltyCA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMoneyPlantCA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isReserveCA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSwapPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isTreasury\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isVestingCA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"moneyPlant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"start\",\"type\":\"bool\"}],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dead\",\"type\":\"address\"}],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"rescueBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescusBEP20Token\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasPriceLimit\",\"type\":\"uint256\"}],\"name\":\"setGasLimt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"account\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"mev\",\"type\":\"bool\"}],\"name\":\"setMEV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"pair\",\"type\":\"bool\"}],\"name\":\"setSwapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"updateLoyaltyCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"updateMoneyPlantCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"updateReserveCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"updateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"updateVestingCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"updatefreezeLockCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Gyrowin", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5fc4961689e8d4255acb8bf886ac2b1be6756d456e2096193795d219b38627b4"}