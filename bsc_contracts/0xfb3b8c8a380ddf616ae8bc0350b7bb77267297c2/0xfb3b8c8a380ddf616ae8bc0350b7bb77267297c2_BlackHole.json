{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\nlibrary DateTime {\r\n    /*\r\n     *  Date and Time utilities for ethereum contracts\r\n     *\r\n     */\r\n\r\n    function getNowDateTime() public view returns (uint32) {\r\n        uint256 ts = block.timestamp + 8 hours;\r\n        return uint32(ts / 1 days);\r\n    }\r\n\r\n    function tsToDateTime(uint256 ts) public pure returns (uint32) {\r\n        return uint32((ts + 8 hours) / 1 days);\r\n    }\r\n}\r\n\r\ninterface IPancakeFactory {\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(uint256 amount) external returns (uint256);\r\n\r\n    function destroy(uint256 amount) external returns (uint256);\r\n\r\n    function getPrice() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PublicReward {\r\n    constructor(address USDT, address HD) {\r\n        IERC20(USDT).approve(msg.sender, ~uint256(0));\r\n        IERC20(HD).approve(msg.sender, ~uint256(0));\r\n    }\r\n}\r\n\r\ncontract BlackHole is Ownable, ReentrancyGuard {\r\n    struct User {\r\n        Team team;\r\n        uint8 level; // \u7b49\u7ea7\r\n        uint64 latestLevelPowerTs; // \u6700\u65b0\u66f4\u65b0\u65f6\u95f4\r\n        uint64 latestLPPowerTs; // \u6700\u65b0\u66f4\u65b0\u65f6\u95f4\r\n        uint64 latestClaimTs; // \u6700\u65b0\u9886\u53d6\u65f6\u95f4\r\n        uint256 claimedHDReward; // \u5df2\u9886\u53d6HD\u5956\u52b1\r\n        uint256 claimedUSDTReward; // \u5df2\u9886\u53d6USDT\u5956\u52b1\r\n        uint256 bourtUSDT; // \u5df2\u8d2d\u4e70USDT\u6570\r\n        mapping(uint32 => uint256) teamReward; // \u56e2\u961fBH\u5956\u52b1\r\n        mapping(uint32 => uint256) lpPower; // lp\u7b97\u529b\r\n        mapping(uint32 => uint256) levelPower; // \u7b49\u7ea7\u7b97\u529b\r\n        mapping(uint32 => uint256) dailyTransaction; // \u6bcf\u65e5\u4ea4\u6613\u989d\r\n    }\r\n\r\n    struct Team {\r\n        address add;\r\n        address[] redirects; // \u76f4\u63a8\r\n        address left; // \u5de6\u8282\u70b9\r\n        address right; //  \u53f3\u8282\u70b9\r\n        address middle; //  \u4e2d\u95f4\u8282\u70b9\r\n        address top; // \u7236\u8282\u70b9\r\n        address leader; // \u9886\u5bfc\r\n        uint16 floor; // \u6240\u5728\u5c42\r\n        uint16 reachFloor; // \u6700\u4e0b\u9762\u6ee1\u5c42\u7684\u8be5\u5c42\u5c42\u6570\r\n        uint32 nextCount; // \u76f4\u63a5\u5b50\u8282\u70b9\u6570\r\n        uint32 childCount; // \u5b50\u8282\u70b9\u6570\r\n        uint32 index; // \u6240\u5728\u5c42\u7684\u5e8f\u53f7\r\n        uint32 latestIndex; // \u4e0a\u6b21\u6ed1\u843d\u6240\u5728\u7236\u8282\u70b9\u5e8f\u53f7\r\n        uint64 initTime; // \u521d\u59cb\u5316\u65f6\u95f4\r\n        mapping(uint32 => mapping(uint16 => uint32)) floorChildInfo; // \u4e0b\u9762\u6bcf\u5c42\u7684\u76f4\u63a5\u5b50\u8282\u4fe1\u606f\r\n    }\r\n\r\n    IERC20 USDT;\r\n    IERC20 HD;\r\n\r\n    PublicReward public publicReward;\r\n\r\n    ISwapRouter router;\r\n    IUniswapV2Pair pair;\r\n    mapping(uint256 => mapping(uint256 => address)) public floorUsers;\r\n    mapping(address => User) users;\r\n    mapping(bytes32 => bool) verifiedMessage;\r\n\r\n    // \u6bcf\u4e00\u7ea7\u6240\u9700\u8981\u7684\u6295\u8d44\u989d\r\n    uint256[] public levelPrice = [\r\n        0,\r\n        10,\r\n        20,\r\n        40,\r\n        80,\r\n        160,\r\n        280,\r\n        500,\r\n        1000,\r\n        1500,\r\n        2000,\r\n        3000,\r\n        5000\r\n    ];\r\n\r\n    uint256[] public levelUSDTLimit = [\r\n        0,\r\n        0,\r\n        0,\r\n        500,\r\n        500,\r\n        100000,\r\n        100000,\r\n        100000,\r\n        100000,\r\n        500000,\r\n        500000,\r\n        500000,\r\n        1200000\r\n    ];\r\n\r\n    uint256 latestdailyTotalLevelPowerTs;\r\n    uint256 latestdailyTotalLPPowerTs;\r\n    mapping(uint256 => uint256) public dailyTotalLPPower;\r\n    mapping(uint256 => uint256) public dailyTotalLevelPower;\r\n    mapping(uint256 => uint256) public dailyPublicUSDTReward;\r\n    mapping(uint256 => uint256) public dailyPublicHDReward;\r\n    mapping(uint256 => uint256) public dailyLPPowerValue;\r\n\r\n    mapping(uint256 => bool) public isPublicRewardEveryDay;\r\n    uint256 public publicRewardEveryDayCount;\r\n    uint256 public publicRewardEveryDayBase;\r\n    // \u6bcf\u65e5\u4ea4\u6613\u989d\u4e0a\u9650\r\n    uint256 dailyTransactionLimit = 200000;\r\n\r\n    // must\r\n    address private delegateInviteContract;\r\n    address private delegateUpgradContract;\r\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // after\r\n    uint256 public startTs = 1699765200;\r\n    uint256 public canBuyDay = 15;\r\n    event Buy(address indexed user, uint256 amount);\r\n    event Sell(address indexed user, uint256 amount);\r\n    event Upgrade(address indexed user, address indexed leader, uint256 level);\r\n    event Claim(address indexed user);\r\n\r\n    constructor(\r\n        address _usdt,\r\n        address _hdToken,\r\n        address _router,\r\n        address _factory,\r\n        address _delegateContract1,\r\n        address _delegateContract2\r\n    ) {\r\n        USDT = IERC20(_usdt);\r\n        HD = IERC20(_hdToken);\r\n        router = ISwapRouter(_router);\r\n        pair = IUniswapV2Pair(\r\n            IPancakeFactory(_factory).getPair(_usdt, _hdToken)\r\n        );\r\n        publicReward = new PublicReward(address(USDT), address(HD));\r\n        delegateInviteContract = _delegateContract1;\r\n        delegateUpgradContract = _delegateContract2;\r\n        Team storage topUser = users[deadAddress].team;\r\n        topUser.initTime = _getTs();\r\n        topUser.floor = 1;\r\n        topUser.index = 1;\r\n        topUser.add = deadAddress;\r\n        floorUsers[1][1] = deadAddress;\r\n\r\n        HD.approve(address(router), ~uint256(0));\r\n        USDT.approve(address(router), ~uint256(0));\r\n        pair.approve(address(router), ~uint256(0));\r\n    }\r\n\r\n    modifier verifyMessage(\r\n        bytes32 _hashedMessage,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) {\r\n        require(!verifiedMessage[_hashedMessage], \"message verified\");\r\n        verifiedMessage[_hashedMessage] = true;\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHashMessage = keccak256(\r\n            abi.encodePacked(prefix, _hashedMessage)\r\n        );\r\n        require(msg.sender == ecrecover(prefixedHashMessage, _v, _r, _s));\r\n        _;\r\n    }\r\n\r\n    modifier noContract() {\r\n        require(tx.origin == msg.sender, \"contract not allowed\");\r\n        uint256 size;\r\n        address addr = msg.sender;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n\r\n        require(!(size > 0), \"contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier mustStart() {\r\n        require(block.timestamp > startTs, \"not start\");\r\n        _;\r\n    }\r\n\r\n    function _invite(address add, address _leader) private {\r\n        (bool success, ) = delegateInviteContract.delegatecall(\r\n            abi.encodeWithSignature(\r\n                \"inviteProxy(address,address)\",\r\n                add,\r\n                _leader\r\n            )\r\n        );\r\n        require(success, \"invite failed\");\r\n    }\r\n\r\n    function _getTs() private view returns (uint64) {\r\n        return uint64(block.timestamp);\r\n    }\r\n\r\n    function getPublicRewardAmount(\r\n        address _user\r\n    ) public view returns (uint256 _totalLPReward, uint256 _totalLevelReward) {\r\n        User storage user = users[_user];\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        uint256 latestClaimday = DateTime.tsToDateTime(user.latestClaimTs);\r\n        if (nowDateTime == latestClaimday) {\r\n            return (0, 0);\r\n        }\r\n        uint256 ts;\r\n        if (user.latestClaimTs == 0) {\r\n            ts = user.team.initTime;\r\n        } else {\r\n            ts = user.latestClaimTs;\r\n        }\r\n        uint32 dateTime = DateTime.tsToDateTime(ts);\r\n\r\n        while (dateTime < nowDateTime) {\r\n            _totalLPReward += (\r\n                dailyTotalLPPower[dateTime] == 0\r\n                    ? 0\r\n                    : ((dailyPublicHDReward[dateTime] *\r\n                        user.lpPower[dateTime]) / dailyTotalLPPower[dateTime])\r\n            );\r\n\r\n            _totalLevelReward += dailyTotalLevelPower[dateTime] == 0\r\n                ? 0\r\n                : ((dailyPublicUSDTReward[dateTime] *\r\n                    user.levelPower[dateTime]) /\r\n                    dailyTotalLevelPower[dateTime]);\r\n            ts += 1 days;\r\n            dateTime = DateTime.tsToDateTime(ts);\r\n        }\r\n        return (_totalLPReward, _totalLevelReward);\r\n    }\r\n\r\n    function buy(\r\n        uint256 amount,\r\n        bytes32 _hashedMessage,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        verifyMessage(_hashedMessage, _v, _r, _s)\r\n        mustStart\r\n    {\r\n        require(\r\n            block.timestamp > startTs + canBuyDay * 1 days,\r\n            \"not start buy\"\r\n        );\r\n        if (USDT.balanceOf(msg.sender) < amount) {\r\n            amount = USDT.balanceOf(msg.sender);\r\n        }\r\n        (bool success, ) = delegateUpgradContract.delegatecall(\r\n            abi.encodeWithSignature(\"buy(uint256)\", amount)\r\n        );\r\n        require(success, \"buy error\");\r\n        emit Buy(msg.sender, amount);\r\n    }\r\n\r\n    function sell(\r\n        uint256 amount,\r\n        bytes32 _hashedMessage,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        verifyMessage(_hashedMessage, _v, _r, _s)\r\n        mustStart\r\n    {\r\n        if (HD.balanceOf(msg.sender) < amount) {\r\n            amount = HD.balanceOf(msg.sender);\r\n        }\r\n        (bool success, ) = delegateUpgradContract.delegatecall(\r\n            abi.encodeWithSignature(\"sell(uint256)\", amount)\r\n        );\r\n        require(success, \"sell error\");\r\n        emit Sell(msg.sender, amount);\r\n    }\r\n\r\n    // \u5347\u7ea7\r\n    function upgrade(\r\n        address _leader,\r\n        bytes32 _hashedMessage,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        verifyMessage(_hashedMessage, _v, _r, _s)\r\n        mustStart\r\n    {\r\n        User storage user = users[msg.sender];\r\n        if (user.team.initTime == 0) {\r\n            _invite(msg.sender, _leader);\r\n        }\r\n        (bool success, ) = delegateUpgradContract.delegatecall(\r\n            abi.encodeWithSignature(\"upgrade()\")\r\n        );\r\n        require(success, \"upgrade error\");\r\n        emit Upgrade(msg.sender, user.team.leader, user.level);\r\n    }\r\n\r\n    function invite(\r\n        address add,\r\n        address _leader\r\n    ) external onlyOwner nonReentrant noContract mustStart {\r\n        _invite(add, _leader);\r\n    }\r\n\r\n    function topInvite(\r\n        address _leader,\r\n        address[] memory adds\r\n    ) external onlyOwner nonReentrant noContract {\r\n        uint len = adds.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            _invite(adds[i], _leader);\r\n        }\r\n    }\r\n\r\n    function claim(\r\n        bytes32 _hashedMessage,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        verifyMessage(_hashedMessage, _v, _r, _s)\r\n        mustStart\r\n    {\r\n        (bool success, ) = delegateUpgradContract.delegatecall(\r\n            abi.encodeWithSignature(\"claim()\")\r\n        );\r\n        require(success, \"claim error\");\r\n        emit Claim(msg.sender);\r\n    }\r\n\r\n    function _getUserPower(\r\n        User storage user\r\n    ) private view returns (uint256 lpPower, uint256 levelPower) {\r\n        uint32 latestDate1 = DateTime.tsToDateTime(user.latestLPPowerTs);\r\n        uint32 latestDate2 = DateTime.tsToDateTime(user.latestLevelPowerTs);\r\n        return (user.lpPower[latestDate1], user.levelPower[latestDate2]);\r\n    }\r\n\r\n    function initPublicRewardEveryDayBase() external {\r\n        require(\r\n            publicRewardEveryDayBase == 0,\r\n            \"publicRewardEveryDayBase already init\"\r\n        );\r\n        publicRewardEveryDayBase = HD.balanceOf(address(pair)) / 2;\r\n    }\r\n\r\n    struct _Team {\r\n        address add;\r\n        uint256 initTime; // \u521d\u59cb\u5316\u65f6\u95f4\r\n        address left; // \u5de6\u8282\u70b9\r\n        address right; //  \u53f3\u8282\u70b9\r\n        address middle; //  \u4e2d\u95f4\u8282\u70b9\r\n        uint256 nextCount; // \u76f4\u63a5\u5b50\u8282\u70b9\u6570\r\n        address top; // \u7236\u8282\u70b9\r\n        address leader; // \u9886\u5bfc\r\n        uint256 childCount; // \u5b50\u8282\u70b9\u6570\r\n        uint256 floor; // \u6240\u5728\u5c42\r\n        uint256 index; // \u6240\u5728\u5c42\u7684\u5e8f\u53f7\r\n        uint256 reachFloor; // \u6700\u4e0b\u9762\u6ee1\u5c42\u7684\u8be5\u5c42\u5c42\u6570\r\n        uint256 latestIndex; // \u4e0a\u6b21\u6ed1\u843d\u6240\u5728\u7236\u8282\u70b9\u5e8f\u53f7\r\n    }\r\n\r\n    function getUsers(address _user) public view returns (_Team memory team) {\r\n        team.add = users[_user].team.add;\r\n        team.initTime = users[_user].team.initTime;\r\n        team.left = users[_user].team.left;\r\n        team.right = users[_user].team.right;\r\n        team.middle = users[_user].team.middle;\r\n        team.nextCount = users[_user].team.nextCount;\r\n        team.top = users[_user].team.top;\r\n        team.leader = users[_user].team.leader;\r\n        team.childCount = users[_user].team.childCount;\r\n        team.floor = users[_user].team.floor;\r\n        team.index = users[_user].team.index;\r\n        team.reachFloor = users[_user].team.reachFloor;\r\n    }\r\n\r\n    struct _User {\r\n        uint childCount;\r\n        uint level;\r\n        address[] redirects;\r\n        uint256 lpPower;\r\n        uint256 levelPower;\r\n        uint256 totalLPReward;\r\n        uint256 totalLevelReward;\r\n        uint256 claimedHDReward;\r\n        uint256 claimedUSDTReward;\r\n        uint256 canBuyUSDTAmount;\r\n        uint256 canExchangeAmount;\r\n        uint256 USDTLimit;\r\n        uint256 teamReward;\r\n        uint[] redirectlevels;\r\n        uint[] redirectCounts;\r\n    }\r\n\r\n    function queryUser(\r\n        address __user\r\n    ) public view returns (_User memory _user) {\r\n        User storage user = users[__user];\r\n        if (user.team.initTime == 0) {\r\n            return _user;\r\n        }\r\n        (uint256 lpPower, uint256 levelPower) = _getUserPower(user);\r\n        _user.lpPower = lpPower;\r\n        _user.levelPower = levelPower;\r\n        (\r\n            uint256 _totalLPReward,\r\n            uint256 _totalLevelReward\r\n        ) = getPublicRewardAmount(__user);\r\n        _user.totalLPReward = _totalLPReward;\r\n        _user.totalLevelReward = _totalLevelReward;\r\n        _user.childCount = user.team.childCount;\r\n        _user.level = user.level;\r\n        _user.redirects = user.team.redirects;\r\n        _user.claimedHDReward = user.claimedHDReward;\r\n        _user.claimedUSDTReward = user.claimedUSDTReward;\r\n        _user.USDTLimit = levelUSDTLimit[user.level];\r\n        _user.canBuyUSDTAmount =\r\n            levelUSDTLimit[user.level] *\r\n            10 ** USDT.decimals() -\r\n            user.bourtUSDT;\r\n        _user.canExchangeAmount =\r\n            dailyTransactionLimit *\r\n            10 ** USDT.decimals() -\r\n            user.dailyTransaction[DateTime.getNowDateTime()];\r\n        _user.redirectlevels = new uint256[](_user.redirects.length);\r\n        _user.redirectCounts = new uint256[](_user.redirects.length);\r\n        _user.teamReward = user.teamReward[DateTime.getNowDateTime()];\r\n        for (uint i = 0; i < _user.redirects.length; i++) {\r\n            _user.redirectlevels[i] = (users[_user.redirects[i]].level);\r\n            _user.redirectCounts[i] = (\r\n                users[_user.redirects[i]].team.redirects.length\r\n            );\r\n        }\r\n    }\r\n\r\n    function getTokenPrice() public view returns (uint256) {\r\n        return HD.getPrice();\r\n    }\r\n\r\n    function updateUser(\r\n        address[] memory _user,\r\n        uint8[] memory levels,\r\n        uint256[] memory LPPowers,\r\n        uint256[] memory tokenAmounts,\r\n        uint64 ts\r\n    ) public onlyOwner {\r\n        uint256 allLPPowerAmount;\r\n        uint32 tsDate = DateTime.tsToDateTime(ts);\r\n        for (uint i = 0; i < _user.length; i++) {\r\n            users[_user[i]].lpPower[tsDate] += LPPowers[i];\r\n            users[_user[i]].latestLPPowerTs = ts;\r\n            users[_user[i]].latestLevelPowerTs = ts;\r\n            allLPPowerAmount += LPPowers[i];\r\n            if (levels[i] != 0) {\r\n                users[_user[i]].level = levels[i];\r\n                users[_user[i]].team.initTime = ts;\r\n            }\r\n            if (tokenAmounts[i] == 0) {\r\n                continue;\r\n            }\r\n            HD.mint(tokenAmounts[i]);\r\n            HD.transfer(_user[i], tokenAmounts[i]);\r\n        }\r\n        dailyTotalLPPower[tsDate] += allLPPowerAmount;\r\n    }\r\n\r\n    function updateDelegateContract(\r\n        address _delegateContract1,\r\n        address _delegateContract2\r\n    ) external onlyOwner {\r\n        delegateInviteContract = _delegateContract1;\r\n        delegateUpgradContract = _delegateContract2;\r\n    }\r\n\r\n    function updateCanBuyDay(uint256 _canBuyDay) external onlyOwner {\r\n        canBuyDay = _canBuyDay;\r\n    }\r\n\r\n    function updateStartTs(uint256 _startTs) external onlyOwner {\r\n        startTs = _startTs;\r\n    }\r\n\r\n    function updateHD(address _hd) external onlyOwner {\r\n        HD = IERC20(_hd);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hdToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegateContract1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegateContract2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"leader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_hashedMessage\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canBuyDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedMessage\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyLPPowerValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyPublicHDReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyPublicUSDTReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalLPPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalLevelPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"floorUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPublicRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalLPReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLevelReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"left\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"right\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nextCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reachFloor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct BlackHole._Team\",\"name\":\"team\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initPublicRewardEveryDayBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"}],\"name\":\"invite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPublicRewardEveryDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelUSDTLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicReward\",\"outputs\":[{\"internalType\":\"contract PublicReward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRewardEveryDayBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRewardEveryDayCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__user\",\"type\":\"address\"}],\"name\":\"queryUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"childCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"redirects\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lpPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLPReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevelReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedHDReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedUSDTReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"canBuyUSDTAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"canExchangeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDTLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"redirectlevels\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"redirectCounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct BlackHole._User\",\"name\":\"_user\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_hashedMessage\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"adds\",\"type\":\"address[]\"}],\"name\":\"topInvite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_canBuyDay\",\"type\":\"uint256\"}],\"name\":\"updateCanBuyDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegateContract1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegateContract2\",\"type\":\"address\"}],\"name\":\"updateDelegateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hd\",\"type\":\"address\"}],\"name\":\"updateHD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTs\",\"type\":\"uint256\"}],\"name\":\"updateStartTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"levels\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"LPPowers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint64\",\"name\":\"ts\",\"type\":\"uint64\"}],\"name\":\"updateUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hashedMessage\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlackHole", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000003b93373754049b01c2aff5985a0d089509899b800000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000ca143ce32fe78f1f7019d7d551a6402fc5350c73000000000000000000000000b9fe3cd5a0817cc0729f00c159cdc28ea059aa210000000000000000000000006eeff9fdb4f506b9e5a28e82b5eb142c50e1a264", "EVMVersion": "Default", "Library": "DateTime:74c273362d84e102fc87d1684adac8461c20581b", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5af88d5e2288294f5d497d3ac876a0ee0c0875234292c9f7f385a479eec668a3"}