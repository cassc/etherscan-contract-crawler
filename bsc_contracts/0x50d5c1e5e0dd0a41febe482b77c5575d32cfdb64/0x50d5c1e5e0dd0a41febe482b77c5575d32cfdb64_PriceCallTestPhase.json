{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BNBP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\r\\nimport './interfaces/IPancakeFactory.sol';\\r\\nimport './interfaces/IPotContract.sol';\\r\\n\\r\\ncontract BNBP is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // FIXME: This is for bnb test Network, change to Mainnet before launch\\r\\n    // pulse testnet: 0x70499adEBB11Efd915E3b69E700c331778628707, bnb testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd\\r\\n    address public constant wbnbAddr = 0x70499adEBB11Efd915E3b69E700c331778628707;\\r\\n    // pulse testnet: 0x70499adEBB11Efd915E3b69E700c331778628707, bnb testnet: 0x6725F303b657a9451d8BA641348b6761A6CC7a17\\r\\n    address public constant pancakeswapV2FactoryAddr = 0x6725F303b657a9451d8BA641348b6761A6CC7a17;\\r\\n\\r\\n    address public potContractAddr;\\r\\n    address[] public tokenHolders;\\r\\n    mapping(address => bool) public isTokenHolder;\\r\\n\\r\\n    // Tokenomics Variable\\r\\n    uint256 public lastAirdropTime;\\r\\n    uint256 public lastBurnTime;\\r\\n    uint256 public lastLotteryTime;\\r\\n\\r\\n    // Airdrop Context - all the variables respresent state at the moment of airdrop\\r\\n    uint256 public totalAirdropAmount;\\r\\n    uint256 public currentAirdropUserIndex;\\r\\n    uint256 public totalAirdropUserCount;\\r\\n    uint256 public totalTokenStaking;\\r\\n    uint256 public currentAirdropMinimum;\\r\\n    bool public isAirdropping;\\r\\n\\r\\n    uint256 public stakingMinimum;\\r\\n    uint256 public minimumStakingTime;\\r\\n\\r\\n    //Staking Context\\r\\n    Staking[] public stakingList;\\r\\n    mapping(address => uint256) public userStakingAmount;\\r\\n    mapping(address => uint256) public userStakingCount;\\r\\n\\r\\n    struct Staking {\\r\\n        address user;\\r\\n        uint256 balance;\\r\\n        uint256 timestamp;\\r\\n    }\\r\\n\\r\\n    struct StakingWithId {\\r\\n        address user;\\r\\n        uint256 id;\\r\\n        uint256 balance;\\r\\n        uint256 timestamp;\\r\\n    }\\r\\n\\r\\n    error AirdropTimeError();\\r\\n\\r\\n    event StakedBNBP(uint256 stakingId, address user, uint256 amount);\\r\\n    event UnStakedBNBP(uint256 stakingId, address user);\\r\\n\\r\\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\\r\\n        _mint(msg.sender, 1000000 * 10 ** 18);\\r\\n\\r\\n        lastAirdropTime = block.timestamp;\\r\\n        lastBurnTime = block.timestamp;\\r\\n        lastLotteryTime = block.timestamp;\\r\\n\\r\\n        // stakingMinimum = 5 * 10**18; // 5 BNBP\\r\\n        // minimumStakingTime = 100 * 24 * 3600;\\r\\n\\r\\n        isAirdropping = false;\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) external {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\\r\\n        _checkStaking(from, amount);\\r\\n        _addToTokenHolders(to);\\r\\n    }\\r\\n\\r\\n    modifier validPotLottery() {\\r\\n        require(potContractAddr != address(0), 'PotLottery Contract Address is not valid');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if the given address is valid user - not one of owner,\\r\\n     * liquidity pool, or PotLottery contract\\r\\n     *\\r\\n     * @param addr address to be checked\\r\\n     */\\r\\n    function isUserAddress(address addr) public view returns (bool) {\\r\\n        address pairAddr = calculatePairAddress();\\r\\n\\r\\n        if (addr != owner() && addr != potContractAddr && addr != pairAddr && addr != address(0)) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add address {to} to token holder list\\r\\n     *\\r\\n     * @param to token receiver - this should be user address\\r\\n     */\\r\\n    function _addToTokenHolders(address to) internal {\\r\\n        if (isUserAddress(to) && !isTokenHolder[to]) {\\r\\n            isTokenHolder[to] = true;\\r\\n            tokenHolders.push(to);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check balance if transfer doesn't occupy staking pool\\r\\n     */\\r\\n    function _checkStaking(address from, uint256 amount) internal view {\\r\\n        if (userStakingAmount[from] > 0) {\\r\\n            require(userStakingAmount[from] + amount <= balanceOf(from), 'Cannot occupy staking pool');\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get uniswap pair address between BNBP and BNB\\r\\n     */\\r\\n    function calculatePairAddress() public view returns (address) {\\r\\n        // IPancakeFactory pancakeFactory = IPancakeFactory(pancakeswapV2FactoryAddr);\\r\\n        // address realPair = pancakeFactory.getPair(address(this), wbnbAddr);\\r\\n        // return realPair;\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns total balance of users\\r\\n     */\\r\\n    function totalUserBalance() public view returns (uint256) {\\r\\n        address pairAddr = calculatePairAddress();\\r\\n        uint256 tokenAmount = balanceOf(owner()) + balanceOf(potContractAddr) + balanceOf(pairAddr);\\r\\n        uint256 totalBalance = totalSupply() - tokenAmount;\\r\\n\\r\\n        return totalBalance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev airdrops BNBP to token holders depending on the amount of holding\\r\\n     * tokens in their wallet\\r\\n     *\\r\\n     * @return airdropped amount\\r\\n     *\\r\\n     * NOTE: The caller of this fuction will pay the airdrop fees, so it is\\r\\n     * recommended to be called by PotLottery Contract\\r\\n     */\\r\\n    function performAirdrop() external validPotLottery returns (uint256) {\\r\\n        IPotLottery potLottery = IPotLottery(potContractAddr);\\r\\n        uint256 airdropInterval = potLottery.airdropInterval();\\r\\n        uint256 nextAirdropTime = lastAirdropTime + airdropInterval;\\r\\n\\r\\n        require(nextAirdropTime <= block.timestamp || isAirdropping, \\\"Can't airdrop yet. Should wait more\\\");\\r\\n        require(balanceOf(potContractAddr) > 0, 'No Balance for Airdrop');\\r\\n\\r\\n        if (!isAirdropping) {\\r\\n            uint256 airdropPool = potLottery.airdropPool();\\r\\n            require(airdropPool > 0, 'Airdrop Pool Empty');\\r\\n\\r\\n            if (getTotalStakingAmount() == 0) {\\r\\n                _burn(msg.sender, airdropPool);\\r\\n            }\\r\\n            // Start a new airdrop\\r\\n            currentAirdropMinimum = stakingMinimum;\\r\\n            totalTokenStaking = getTotalStakingAmount();\\r\\n            lastAirdropTime = block.timestamp;\\r\\n            totalAirdropAmount = airdropPool;\\r\\n            totalAirdropUserCount = tokenHolders.length;\\r\\n            currentAirdropUserIndex = 0;\\r\\n            isAirdropping = true;\\r\\n        }\\r\\n        return _continueAirdrop();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev continue the previous airdrop\\r\\n     *\\r\\n     * @return airdropped amount\\r\\n     */\\r\\n    function _continueAirdrop() internal returns (uint256 airdropped) {\\r\\n        uint256 i = currentAirdropUserIndex;\\r\\n        for (uint8 count = 0; count < 150 && i < totalAirdropUserCount; i++) {\\r\\n            address user = tokenHolders[i];\\r\\n            uint256 balance = userStakingAmount[user];\\r\\n\\r\\n            if (balance > 0) {\\r\\n                uint256 amount = (balance * totalAirdropAmount) / totalTokenStaking;\\r\\n\\r\\n                transfer(user, amount);\\r\\n                airdropped += amount;\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        currentAirdropUserIndex = i;\\r\\n        if (currentAirdropUserIndex >= totalAirdropUserCount) {\\r\\n            isAirdropping = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev burns BNBP token accumulated in the burn pool on the PotLottery\\r\\n     * Contract\\r\\n     *\\r\\n     * @return burnt amount\\r\\n     *\\r\\n     * NOTE: The caller of this fuction will burn his BNBP tokens, so it is\\r\\n     * recommended to be called by PotLottery Contract\\r\\n     */\\r\\n    function performBurn() external validPotLottery returns (uint256) {\\r\\n        IPotLottery potLottery = IPotLottery(potContractAddr);\\r\\n        uint256 burnPool = potLottery.burnPool();\\r\\n        uint256 burnInterval = potLottery.burnInterval();\\r\\n        uint256 nextBurnTime = lastBurnTime + burnInterval;\\r\\n\\r\\n        require(nextBurnTime <= block.timestamp, \\\"Can't burn yet. Should wait more\\\");\\r\\n        require(balanceOf(potContractAddr) > 0, 'No Balance for burn');\\r\\n\\r\\n        _burn(msg.sender, burnPool);\\r\\n\\r\\n        lastBurnTime = block.timestamp;\\r\\n        return burnPool;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev gives BNBP token accumulated in the lottery pool to the selected\\r\\n     * winnner\\r\\n     *\\r\\n     * @return given lottery amount\\r\\n     *\\r\\n     * NOTE: The caller of this fuction will pay the lottery fee, so it is\\r\\n     * recommended to be called by PotLottery Contract\\r\\n     */\\r\\n    function performLottery() external validPotLottery returns (address) {\\r\\n        IPotLottery potLottery = IPotLottery(potContractAddr);\\r\\n        uint256 lotteryPool = potLottery.lotteryPool();\\r\\n        uint256 lotteryInterval = potLottery.lotteryInterval();\\r\\n        uint256 nextLotteryTime = lastLotteryTime + lotteryInterval;\\r\\n\\r\\n        require(nextLotteryTime <= block.timestamp, \\\"Can't lottery yet. Should wait more\\\");\\r\\n        require(balanceOf(potContractAddr) > 0, 'No Balance for Lottery');\\r\\n\\r\\n        address winner = _determineLotteryWinner();\\r\\n        transfer(winner, lotteryPool);\\r\\n\\r\\n        return winner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev generates a random number\\r\\n     */\\r\\n    function getRandomNumber() public view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.difficulty, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev gets the winner for the lottery\\r\\n     *\\r\\n     */\\r\\n    function _determineLotteryWinner() internal view returns (address) {\\r\\n        uint256 randomNumber = getRandomNumber();\\r\\n        uint256 winnerValue = randomNumber % getTotalStakingAmount();\\r\\n        uint256 length = tokenHolders.length;\\r\\n        address winner;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            uint256 balance = userStakingAmount[tokenHolders[i]];\\r\\n\\r\\n            if (winnerValue <= balance) {\\r\\n                winner = tokenHolders[i];\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            winnerValue -= balance;\\r\\n        }\\r\\n        return winner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev gets the total staking BNBP balance\\r\\n     */\\r\\n    function getTotalStakingAmount() public view returns (uint256) {\\r\\n        uint256 total;\\r\\n        uint256 length = stakingList.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            total += stakingList[i].balance;\\r\\n        }\\r\\n\\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev stakes given value of BNBP from user address, this is for\\r\\n     * being eligible to get airdrop and lottery\\r\\n     */\\r\\n    function stakeBNBP(uint256 value) external validPotLottery returns (uint256) {\\r\\n        uint256 lockMinimum = stakingMinimum;\\r\\n        uint256 currentLockedAmount = userStakingAmount[msg.sender];\\r\\n        uint256 userBalance = balanceOf(msg.sender);\\r\\n\\r\\n        require(value >= lockMinimum, 'Should be bigger than minimum amount.');\\r\\n        require(userBalance >= currentLockedAmount + value, 'Not enough balance');\\r\\n\\r\\n        stakingList.push(Staking(msg.sender, value, block.timestamp));\\r\\n        userStakingAmount[msg.sender] = currentLockedAmount + value;\\r\\n        userStakingCount[msg.sender]++;\\r\\n\\r\\n        uint256 stakingId = stakingList.length - 1;\\r\\n        emit StakedBNBP(stakingId, msg.sender, value);\\r\\n        return stakingId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev unstakes BNBP if possible\\r\\n     */\\r\\n    function unStakeBNBP(uint256 stakingIndex) external validPotLottery {\\r\\n        Staking storage staking = stakingList[stakingIndex];\\r\\n        uint256 unStakeTime = staking.timestamp + minimumStakingTime;\\r\\n\\r\\n        require(staking.user == msg.sender, 'User Address not correct');\\r\\n        require(unStakeTime <= block.timestamp, 'Not available to unstake');\\r\\n        require(staking.balance > 0, 'Already Unstaked');\\r\\n\\r\\n        userStakingAmount[msg.sender] -= staking.balance;\\r\\n        userStakingCount[msg.sender]--;\\r\\n        staking.balance = 0;\\r\\n\\r\\n        emit UnStakedBNBP(stakingIndex, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns staking list of user\\r\\n     */\\r\\n    function getUserStakingInfo(address user) public view returns (StakingWithId[] memory) {\\r\\n        uint256 count = userStakingCount[user];\\r\\n        uint256 sIndex;\\r\\n        StakingWithId[] memory res;\\r\\n\\r\\n        if (count == 0) {\\r\\n            return res;\\r\\n        }\\r\\n        res = new StakingWithId[](userStakingCount[user]);\\r\\n\\r\\n        for (uint256 i = 0; i < stakingList.length; i++) {\\r\\n            Staking storage staking = stakingList[i];\\r\\n\\r\\n            if (staking.user == user && staking.balance > 0) {\\r\\n                res[sIndex++] = StakingWithId(user, i, staking.balance, staking.timestamp);\\r\\n            }\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets minimum BNBP value to get airdrop and lottery\\r\\n     *\\r\\n     */\\r\\n    function setStakingMinimum(uint256 value) external onlyOwner {\\r\\n        stakingMinimum = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets minimum BNBP value to get airdrop and lottery\\r\\n     *\\r\\n     */\\r\\n    function setMinimumStakingTime(uint256 value) external onlyOwner {\\r\\n        minimumStakingTime = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets the PotLottery Contract address\\r\\n     *\\r\\n     */\\r\\n    function setPotContractAddress(address addr) external onlyOwner {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function bulkTransfer(address[] calldata accounts, uint256[] calldata amounts) external {\\r\\n        for (uint256 i = 0; i < accounts.length; i++) {\\r\\n            transfer(accounts[i], amounts[i]);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.16;\\r\\n\\r\\n\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPotContract.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n// File: PotContract.sol\\r\\n\\r\\ninterface IPotLottery {\\r\\n    struct Token {\\r\\n        address tokenAddress;\\r\\n        string tokenSymbol;\\r\\n        uint256 tokenDecimal;\\r\\n    }\\r\\n\\r\\n    enum POT_STATE {\\r\\n        PAUSED,\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    event EnteredPot(\\r\\n        string tokenName,\\r\\n        address indexed userAddress,\\r\\n        uint256 indexed potRound,\\r\\n        uint256 usdValue,\\r\\n        uint256 amount,\\r\\n        uint256 indexed enteryCount,\\r\\n        bool hasEntryInCurrentPot\\r\\n    );\\r\\n    event CalculateWinner(\\r\\n        address indexed winner,\\r\\n        uint256 indexed potRound,\\r\\n        uint256 potValue,\\r\\n        uint256 amount,\\r\\n        uint256 amountWon,\\r\\n        uint256 participants\\r\\n    );\\r\\n\\r\\n    event PotStateChange(uint256 indexed potRound, POT_STATE indexed potState, uint256 indexed time);\\r\\n    event TokenSwapFailed(string tokenName);\\r\\n\\r\\n    function getRefund() external;\\r\\n\\r\\n    function airdropPool() external view returns (uint256);\\r\\n\\r\\n    function lotteryPool() external view returns (uint256);\\r\\n\\r\\n    function burnPool() external view returns (uint256);\\r\\n\\r\\n    function airdropInterval() external view returns (uint256);\\r\\n\\r\\n    function burnInterval() external view returns (uint256);\\r\\n\\r\\n    function lotteryInterval() external view returns (uint256);\\r\\n\\r\\n    function fullFillRandomness() external view returns (uint256);\\r\\n\\r\\n    function getBNBPrice() external view returns (uint256 price);\\r\\n\\r\\n    function swapAccumulatedFees() external;\\r\\n\\r\\n    function burnAccumulatedBNBP() external;\\r\\n\\r\\n    function airdropAccumulatedBNBP() external returns (uint256);\\r\\n\\r\\n    function addAdminTokenValue(uint256 value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Roulette/RouletteV2.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol';\\r\\nimport '../interfaces/IPancakePair.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IBNBP.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IVRFConsumer.sol';\\r\\nimport '../interfaces/IPegSwap.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\ncontract RoulettePotV2 is ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    uint256 public casinoCount;\\r\\n    mapping(uint256 => Casino) public tokenIdToCasino;\\r\\n    mapping(address => bool) public isStable;\\r\\n\\r\\n    // Info for current round\\r\\n    BetInfo[] currentBets;\\r\\n    uint256 public currentBetCount;\\r\\n    uint256 public roundLiveTime;\\r\\n    bool public isVRFPending;\\r\\n    uint256 public requestId;\\r\\n    uint256 public roundIds;\\r\\n    uint256 public betIds;\\r\\n\\r\\n    address public casinoNFTAddress;\\r\\n    address public BNBPAddress;\\r\\n    address public consumerAddress;\\r\\n    address public potAddress;\\r\\n    address public owner;\\r\\n\\r\\n    address internal constant wbnbAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address internal constant busdAddr = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // testnet: 0x4608Ea31fA832ce7DCF56d78b5434b49830E91B1, mainnet: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\\r\\n    address internal constant pancakeFactoryAddr = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // testnet: 0x6725F303b657a9451d8BA641348b6761A6CC7a17, mainnet: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n    address internal constant pancakeRouterAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    address internal constant coordinatorAddr = 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE; // testnet: 0x6A2AAd07396B36Fe02a22b33cf443582f682c82f, mainnet: 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE\\r\\n    address internal constant linkTokenAddr = 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD; // testnet: 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06, mainnet: 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD\\r\\n    address internal constant pegSwapAddr = 0x1FCc3B22955e76Ca48bF025f1A6993685975Bb9e;\\r\\n    address internal constant link677TokenAddr = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;\\r\\n    uint256 internal constant subscriptionId = 675; // testnet: 2102, mainnet: 675\\r\\n    uint256 public linkPerBet = 45000000000000000; // 0.045 link token per request\\r\\n    mapping(uint256 => uint256) public linkSpent;\\r\\n\\r\\n    struct Casino {\\r\\n        address tokenAddress;\\r\\n        string tokenName;\\r\\n        uint256 liquidity;\\r\\n        uint256 locked;\\r\\n        uint256 initialMaxBet;\\r\\n        uint256 initialMinBet;\\r\\n        uint256 maxBet;\\r\\n        uint256 minBet;\\r\\n        uint256 fee;\\r\\n        int256 profit;\\r\\n        uint256 lastSwapTime;\\r\\n    }\\r\\n\\r\\n    struct BetInfo {\\r\\n        Bet[] bets;\\r\\n        address player;\\r\\n        uint256 tokenId;\\r\\n        uint256 tokenPrice;\\r\\n    }\\r\\n\\r\\n    struct Bet {\\r\\n        /* 5: number, 4: even, odd, 3: 18s, 2: 12s, 1: row, 0: black, red */\\r\\n        uint8 betType;\\r\\n        uint8 number;\\r\\n        uint240 amount;\\r\\n    }\\r\\n\\r\\n    event FinishedBet(\\r\\n        uint256 tokenId,\\r\\n        uint256 betId,\\r\\n        uint256 roundId,\\r\\n        address player,\\r\\n        uint256 nonce,\\r\\n        uint256 totalAmount,\\r\\n        uint256 rewardAmount,\\r\\n        uint256 totalUSD,\\r\\n        uint256 rewardUSD,\\r\\n        uint256 maximumReward\\r\\n    );\\r\\n    event RoundFinished(uint256 roundId, uint256 nonce);\\r\\n    event TransferFailed(uint256 tokenId, address to, uint256 amount);\\r\\n    event TokenSwapFailed(uint256 tokenId, uint256 balance, string reason, uint256 timestamp);\\r\\n    event InitializedBet(uint256 roundId, uint256 tokenId, address player, uint256 amount);\\r\\n    event AddedLiquidity(uint256 tokenId, address owner, uint256 amount);\\r\\n    event RemovedLiquidity(uint256 tokenId, address owner, uint256 amount);\\r\\n    event UpdatedMaxBet(uint256 tokenId, address owner, uint256 value);\\r\\n    event UpdatedMinBet(uint256 tokenId, address owner, uint256 value);\\r\\n    event LiquidityChanged(uint256 tokenId, address changer, uint256 liquidity, uint256 locked, bool isFinishedBet);\\r\\n    event SuppliedBNBP(uint256 amount);\\r\\n    event SuppliedLink(uint256 amount);\\r\\n    event VRFRequested();\\r\\n\\r\\n    constructor(address nftAddr, address _BNBPAddress, address _consumerAddress, address _potAddress) {\\r\\n        address BNBPPair = IPancakeFactory(pancakeFactoryAddr).getPair(wbnbAddr, _BNBPAddress);\\r\\n        require(BNBPPair != address(0), 'No liquidity with BNBP and BNB');\\r\\n\\r\\n        casinoNFTAddress = nftAddr;\\r\\n        BNBPAddress = _BNBPAddress;\\r\\n        consumerAddress = _consumerAddress;\\r\\n        potAddress = _potAddress;\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function onlyCasinoOwner(uint256 tokenId) internal view {\\r\\n        require(IERC721(casinoNFTAddress).ownerOf(tokenId) == msg.sender, 'Not Casino Owner');\\r\\n    }\\r\\n\\r\\n    function onlyOwner() internal view {\\r\\n        require(msg.sender == owner, 'owner');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates pot contract Address\\r\\n     */\\r\\n    function setPotAddress(address addr) external {\\r\\n        onlyOwner();\\r\\n        potAddress = addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets token is stable or not\\r\\n     */\\r\\n    function setTokenStable(address tokenAddr, bool _isStable) external {\\r\\n        onlyOwner();\\r\\n        isStable[tokenAddr] = _isStable;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set how much link token will be consumed per bet\\r\\n     */\\r\\n    function setLinkPerBet(uint256 value) external {\\r\\n        onlyOwner();\\r\\n        linkPerBet = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns list of casinos minted\\r\\n     */\\r\\n    function getCasinoList()\\r\\n        external\\r\\n        view\\r\\n        returns (Casino[] memory casinos, address[] memory owners, uint256[] memory prices)\\r\\n    {\\r\\n        uint256 length = casinoCount;\\r\\n        casinos = new Casino[](length);\\r\\n        owners = new address[](length);\\r\\n        prices = new uint256[](length);\\r\\n        IERC721 nftContract = IERC721(casinoNFTAddress);\\r\\n\\r\\n        for (uint256 i = 1; i <= length; ++i) {\\r\\n            casinos[i - 1] = tokenIdToCasino[i];\\r\\n            owners[i - 1] = nftContract.ownerOf(i);\\r\\n            if (casinos[i - 1].tokenAddress == address(0)) {\\r\\n                prices[i - 1] = getBNBPrice();\\r\\n            } else {\\r\\n                prices[i - 1] = _getTokenUsdPrice(casinos[i - 1].tokenAddress);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRoundStatus()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 roundId, BetInfo[] memory betInfos, bool _isVRFPending, uint256 _roundLiveTime)\\r\\n    {\\r\\n        roundId = roundIds;\\r\\n        _isVRFPending = isVRFPending;\\r\\n        _roundLiveTime = roundLiveTime;\\r\\n        betInfos = _getCurrentBets();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds a new casino\\r\\n     */\\r\\n    function addCasino(\\r\\n        uint256 tokenId,\\r\\n        address tokenAddress,\\r\\n        string calldata tokenName,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external {\\r\\n        require(msg.sender == casinoNFTAddress || msg.sender == owner, 'Only casino nft contract can call');\\r\\n\\r\\n        Casino storage newCasino = tokenIdToCasino[tokenId];\\r\\n        newCasino.tokenAddress = tokenAddress;\\r\\n        newCasino.tokenName = tokenName;\\r\\n        newCasino.initialMaxBet = maxBet;\\r\\n        newCasino.initialMinBet = minBet;\\r\\n        newCasino.maxBet = maxBet;\\r\\n        newCasino.minBet = minBet;\\r\\n        newCasino.fee = fee;\\r\\n        newCasino.liquidity = 0;\\r\\n\\r\\n        casinoCount++;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set max bet limit for casino\\r\\n     */\\r\\n    function setMaxBet(uint256 tokenId, uint256 newMaxBet) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(newMaxBet <= casinoInfo.initialMaxBet, \\\"Can't exceed initial max bet\\\");\\r\\n        require(newMaxBet >= casinoInfo.minBet, \\\"Can't exceed initial max bet\\\");\\r\\n\\r\\n        casinoInfo.maxBet = newMaxBet;\\r\\n        emit UpdatedMaxBet(tokenId, msg.sender, newMaxBet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set min bet limit for casino\\r\\n     */\\r\\n    function setMinBet(uint256 tokenId, uint256 newMinBet) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(newMinBet <= casinoInfo.maxBet, 'min >= max');\\r\\n        require(newMinBet > casinoInfo.initialMinBet, \\\"Can't be lower than initial min bet\\\");\\r\\n\\r\\n        casinoInfo.minBet = newMinBet;\\r\\n        emit UpdatedMinBet(tokenId, msg.sender, newMinBet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns maximum reward amount for given bets\\r\\n     */\\r\\n    function getMaximumReward(Bet[] memory bets) public pure returns (uint256) {\\r\\n        uint256 maxReward;\\r\\n        uint8[6] memory betRewards = [2, 3, 3, 2, 2, 36];\\r\\n\\r\\n        for (uint256 i = 0; i <= 37; ++i) {\\r\\n            uint256 reward;\\r\\n\\r\\n            for (uint256 j = 0; j < bets.length; j++) {\\r\\n                if (_isInBet(bets[j], i)) {\\r\\n                    reward += bets[j].amount * betRewards[bets[j].betType];\\r\\n                }\\r\\n            }\\r\\n            if (maxReward < reward) {\\r\\n                maxReward = reward;\\r\\n            }\\r\\n        }\\r\\n        return maxReward;\\r\\n    }\\r\\n\\r\\n    function _getCurrentBets() internal view returns (BetInfo[] memory) {\\r\\n        BetInfo[] memory infos;\\r\\n        if (currentBetCount == 0) return infos;\\r\\n        infos = new BetInfo[](currentBetCount);\\r\\n\\r\\n        for (uint256 i = 0; i < currentBetCount; ++i) {\\r\\n            infos[i] = currentBets[i];\\r\\n        }\\r\\n        return infos;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns whbnb Bet `b` covers the `number` or not\\r\\n     */\\r\\n    function _isInBet(Bet memory b, uint256 number) public pure returns (bool) {\\r\\n        require(b.betType <= 5, 'Invalid bet type');\\r\\n        require(b.number <= 37, 'Invalid betting number');\\r\\n\\r\\n        if (number == 0 || number == 37) {\\r\\n            if (b.betType == 5) {\\r\\n                return b.number == number;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (b.betType == 5) {\\r\\n            return (b.number == number); /* bet on number */\\r\\n        } else if (b.betType == 4) {\\r\\n            if (b.number == 0) return (number % 2 == 0); /* bet on even */\\r\\n            if (b.number == 1) return (number % 2 == 1); /* bet on odd */\\r\\n        } else if (b.betType == 3) {\\r\\n            if (b.number == 0) return (number <= 18); /* bet on low 18s */\\r\\n            if (b.number == 1) return (number >= 19); /* bet on high 18s */\\r\\n        } else if (b.betType == 2) {\\r\\n            if (b.number == 0) return (number <= 12); /* bet on 1st dozen */\\r\\n            if (b.number == 1) return (number > 12 && number <= 24); /* bet on 2nd dozen */\\r\\n            if (b.number == 2) return (number > 24); /* bet on 3rd dozen */\\r\\n        } else if (b.betType == 1) {\\r\\n            if (b.number == 0) return (number % 3 == 0); /* bet on top row */\\r\\n            if (b.number == 1) return (number % 3 == 1); /* bet on middle row */\\r\\n            if (b.number == 2) return (number % 3 == 2); /* bet on bottom row */\\r\\n        } else if (b.betType == 0) {\\r\\n            if (b.number == 0) {\\r\\n                /* bet on black */\\r\\n                if (number <= 10 || (number >= 19 && number <= 28)) {\\r\\n                    return (number % 2 == 0);\\r\\n                } else {\\r\\n                    return (number % 2 == 1);\\r\\n                }\\r\\n            } else {\\r\\n                /* bet on red */\\r\\n                if (number <= 10 || (number >= 19 && number <= 28)) {\\r\\n                    return (number % 2 == 1);\\r\\n                } else {\\r\\n                    return (number % 2 == 0);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns total bet amount\\r\\n     */\\r\\n    function _getTotalBetAmount(Bet[] memory bets) internal pure returns (uint256) {\\r\\n        /* 5: number, 4: even, odd, 3: 18s, 2: 12s, 1: row, 0: black, red */\\r\\n        uint256[5] memory betCount;\\r\\n        uint256 totalBetAmount;\\r\\n        for (uint256 i = 0; i < bets.length; ++i) {\\r\\n            require(bets[i].betType <= 5, 'Invalid bet type');\\r\\n\\r\\n            totalBetAmount += bets[i].amount;\\r\\n            if (bets[i].betType < 5) {\\r\\n                betCount[bets[i].betType]++;\\r\\n            }\\r\\n        }\\r\\n        require(\\r\\n            betCount[0] < 2 && betCount[1] < 3 && betCount[2] < 3 && betCount[3] < 2 && betCount[4] < 2,\\r\\n            'Bet Restriction'\\r\\n        );\\r\\n\\r\\n        return totalBetAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev calculate total rewards with a given nonce\\r\\n     */\\r\\n    function _spinWheel(Bet[] memory bets, uint256 nonce) internal pure returns (uint256) {\\r\\n        uint256 totalReward;\\r\\n        uint8[6] memory betRewards = [2, 3, 3, 2, 2, 36];\\r\\n\\r\\n        for (uint256 i = 0; i < bets.length; ++i) {\\r\\n            if (_isInBet(bets[i], nonce)) {\\r\\n                totalReward += betRewards[bets[i].betType] * bets[i].amount;\\r\\n            }\\r\\n        }\\r\\n        return totalReward;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev request random number for calculating winner\\r\\n     */\\r\\n    function _requestVRF() internal {\\r\\n        IVRFv2Consumer vrfConsumer = IVRFv2Consumer(consumerAddress);\\r\\n        uint256 _requestId = vrfConsumer.requestRandomWords();\\r\\n        requestId = _requestId;\\r\\n        isVRFPending = true;\\r\\n        emit VRFRequested();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev request nonce if round is finished, start round if the first player has entered\\r\\n     */\\r\\n    function _updateRoundStatus() internal {\\r\\n        if (!isVRFPending && roundLiveTime != 0 && block.timestamp > roundLiveTime + 120) {\\r\\n            _requestVRF();\\r\\n        }\\r\\n        if (currentBetCount == 1) {\\r\\n            roundLiveTime = block.timestamp;\\r\\n            roundIds++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev save user bet info to `currentBets`\\r\\n     */\\r\\n    function _saveUserBetInfo(uint256 tokenId, Bet[] memory bets, uint256 tokenPrice) internal {\\r\\n        uint256 count = currentBetCount;\\r\\n\\r\\n        if (currentBets.length == count) {\\r\\n            currentBets.push();\\r\\n        }\\r\\n\\r\\n        BetInfo storage info = currentBets[count];\\r\\n        info.tokenId = tokenId;\\r\\n        info.player = msg.sender;\\r\\n        info.tokenPrice = tokenPrice;\\r\\n        delete info.bets;\\r\\n\\r\\n        for (uint256 i = 0; i < bets.length; ++i) {\\r\\n            info.bets.push(bets[i]);\\r\\n        }\\r\\n\\r\\n        ++currentBetCount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize bet and request nonce to VRF\\r\\n     *\\r\\n     * NOTE this function only accepts erc20 tokens\\r\\n     *      Bet type should be less than 6, otherwise will revert\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     * @param bets array of bets\\r\\n     */\\r\\n    function initializeTokenBet(uint256 tokenId, Bet[] calldata bets) external nonReentrant {\\r\\n        require(!isVRFPending, 'VRF Pending');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress != address(0), \\\"This casino doesn't support tokens\\\");\\r\\n\\r\\n        IPRC20 token = IPRC20(casinoInfo.tokenAddress);\\r\\n        uint256 approvedAmount = token.allowance(msg.sender, address(this));\\r\\n        uint256 totalBetAmount = _getTotalBetAmount(bets);\\r\\n        uint256 maxReward = getMaximumReward(bets);\\r\\n        uint256 tokenPrice = isStable[casinoInfo.tokenAddress] ? 10 ** 18 : _getTokenUsdPrice(casinoInfo.tokenAddress);\\r\\n        uint256 totalUSDValue = (totalBetAmount * tokenPrice) / 10 ** token.decimals();\\r\\n\\r\\n        require(token.balanceOf(msg.sender) >= totalBetAmount, 'Not enough balance');\\r\\n        require(totalBetAmount <= approvedAmount, 'Not enough allowance');\\r\\n        require(maxReward <= casinoInfo.liquidity + totalBetAmount, 'Not enough liquidity');\\r\\n        require(totalUSDValue <= casinoInfo.maxBet * 10 ** 18, \\\"Can't exceed max bet limit\\\");\\r\\n        require(totalUSDValue >= casinoInfo.minBet * 10 ** 18, \\\"Can't be lower than min bet limit\\\");\\r\\n\\r\\n        token.transferFrom(msg.sender, address(this), totalBetAmount);\\r\\n        casinoInfo.liquidity -= (maxReward - totalBetAmount);\\r\\n        casinoInfo.locked += maxReward;\\r\\n\\r\\n        // linkSpent[tokenId] += linkPerBet;\\r\\n        _saveUserBetInfo(tokenId, bets, tokenPrice);\\r\\n        _updateRoundStatus();\\r\\n\\r\\n        emit InitializedBet(roundIds, tokenId, msg.sender, totalBetAmount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize bet and request nonce to VRF\\r\\n     *\\r\\n     * NOTE this function only accepts bnb\\r\\n     *      Bet type should be less than 6, otherwise will revert\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     * @param bets array of bets\\r\\n     */\\r\\n    function initializeEthBet(uint256 tokenId, Bet[] calldata bets) external payable {\\r\\n        require(!isVRFPending, 'VRF Pending');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress == address(0), 'This casino only support bnb');\\r\\n\\r\\n        IPRC20 busdToken = IPRC20(busdAddr);\\r\\n        uint256 totalBetAmount = _getTotalBetAmount(bets);\\r\\n        uint256 maxReward = getMaximumReward(bets);\\r\\n        uint256 bnbPrice = getBNBPrice();\\r\\n        uint256 totalUSDValue = (bnbPrice * totalBetAmount) / 10 ** 18;\\r\\n\\r\\n        require(msg.value == totalBetAmount, 'Not correct bet amount');\\r\\n        require(maxReward <= casinoInfo.liquidity + totalBetAmount, 'Not enough liquidity');\\r\\n        require(totalUSDValue <= casinoInfo.maxBet * 10 ** busdToken.decimals(), \\\"Can't exceed max bet limit\\\");\\r\\n        require(totalUSDValue >= casinoInfo.minBet * 10 ** busdToken.decimals(), \\\"Can't be lower than min bet limit\\\");\\r\\n\\r\\n        casinoInfo.liquidity -= (maxReward - totalBetAmount);\\r\\n        casinoInfo.locked += maxReward;\\r\\n\\r\\n        _saveUserBetInfo(tokenId, bets, bnbPrice);\\r\\n        _updateRoundStatus();\\r\\n        // IVRFv2Consumer vrfConsumer = IVRFv2Consumer(consumerAddress);\\r\\n        // uint256 requestId = vrfConsumer.requestRandomWords();\\r\\n        // _initializeBetInfo(tokenId, requestId, bets, bnbPrice);\\r\\n\\r\\n        // linkSpent[tokenId] += linkPerBet;\\r\\n\\r\\n        emit InitializedBet(roundIds, tokenId, msg.sender, totalBetAmount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev request nonce when round time is over\\r\\n     */\\r\\n    function requestNonce() external {\\r\\n        require(!isVRFPending && roundLiveTime != 0 && block.timestamp > roundLiveTime + 120, 'Round not ended');\\r\\n        _requestVRF();\\r\\n    }\\r\\n\\r\\n    function isVRFFulfilled() public view returns (bool) {\\r\\n        (bool fulfilled, uint256[] memory nonces) = IVRFv2Consumer(consumerAddress).getRequestStatus(requestId);\\r\\n        return fulfilled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev retrieve nonce and spin the wheel, return reward if user wins\\r\\n     *\\r\\n     */\\r\\n    function finishRound() external nonReentrant {\\r\\n        require(isVRFPending == true, 'VRF not requested');\\r\\n\\r\\n        (bool fulfilled, uint256[] memory nonces) = IVRFv2Consumer(consumerAddress).getRequestStatus(requestId);\\r\\n        require(fulfilled == true, 'not yet fulfilled');\\r\\n\\r\\n        uint256 length = currentBetCount;\\r\\n        uint256 linkPerRound = linkPerBet;\\r\\n        uint256 i;\\r\\n\\r\\n        for (i = 0; i < length; ++i) {\\r\\n            BetInfo memory info = currentBets[i];\\r\\n            linkSpent[info.tokenId] += (linkPerRound / length);\\r\\n            _finishUserBet(info, nonces[0]);\\r\\n        }\\r\\n\\r\\n        isVRFPending = false;\\r\\n        delete roundLiveTime;\\r\\n        delete currentBetCount;\\r\\n        emit RoundFinished(roundIds, nonces[0] % 38);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev finish individual user's pending bet based on the nonce retreived\\r\\n     */\\r\\n    function _finishUserBet(BetInfo memory info, uint256 nonce) internal {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[info.tokenId];\\r\\n        uint256 decimal = casinoInfo.tokenAddress == address(0) ? 18 : IPRC20(casinoInfo.tokenAddress).decimals();\\r\\n        uint256 totalReward = _spinWheel(info.bets, nonce % 38);\\r\\n        uint256 totalBetAmount = _getTotalBetAmount(info.bets);\\r\\n        uint256 maxReward = getMaximumReward(info.bets);\\r\\n        uint256 totalUSDValue = (totalBetAmount * info.tokenPrice) / 10 ** decimal;\\r\\n        uint256 totalRewardUSD = (totalReward * info.tokenPrice) / 10 ** decimal;\\r\\n\\r\\n        betIds++;\\r\\n        if (totalReward > 0) {\\r\\n            if (casinoInfo.tokenAddress != address(0)) {\\r\\n                IPRC20(casinoInfo.tokenAddress).transfer(info.player, totalReward);\\r\\n            } else {\\r\\n                bool sent = payable(info.player).send(totalReward);\\r\\n                require(sent, 'send fail');\\r\\n            }\\r\\n        }\\r\\n        casinoInfo.liquidity = casinoInfo.liquidity + maxReward - totalReward;\\r\\n        casinoInfo.locked -= maxReward;\\r\\n        casinoInfo.profit = casinoInfo.profit + int256(totalBetAmount) - int256(totalReward);\\r\\n\\r\\n        emit FinishedBet(\\r\\n            info.tokenId,\\r\\n            betIds,\\r\\n            roundIds,\\r\\n            info.player,\\r\\n            nonce % 38,\\r\\n            totalBetAmount,\\r\\n            totalReward,\\r\\n            totalUSDValue,\\r\\n            totalRewardUSD,\\r\\n            maxReward\\r\\n        );\\r\\n        emit LiquidityChanged(info.tokenId, info.player, casinoInfo.liquidity, casinoInfo.locked, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds liquidity to the casino pool\\r\\n     * NOTE this is only for casinos that uses tokens\\r\\n     */\\r\\n    function addLiquidityWithTokens(uint256 tokenId, uint256 amount) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress != address(0), \\\"This casino doesn't support tokens\\\");\\r\\n\\r\\n        IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        casinoInfo.liquidity += amount;\\r\\n        emit AddedLiquidity(tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds liquidity to the casino pool\\r\\n     * NOTE this is only for casinos that uses bnb\\r\\n     */\\r\\n    function addLiquidityWithEth(uint256 tokenId) external payable {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n\\r\\n        require(casinoInfo.tokenAddress == address(0), \\\"This casino doesn't supports bnb\\\");\\r\\n        casinoInfo.liquidity += msg.value;\\r\\n        emit AddedLiquidity(tokenId, msg.sender, msg.value);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev removes liquidity from the casino pool\\r\\n     */\\r\\n    function removeLiquidity(uint256 tokenId, uint256 amount) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        uint256 liquidity = casinoInfo.liquidity;\\r\\n\\r\\n        require(int256(liquidity - amount) >= casinoInfo.profit, 'Cannot withdraw profit before it is fee taken');\\r\\n        require(liquidity >= amount, 'Not enough liquidity');\\r\\n\\r\\n        unchecked {\\r\\n            casinoInfo.liquidity -= amount;\\r\\n        }\\r\\n        if (casinoInfo.tokenAddress != address(0)) {\\r\\n            IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n            token.safeTransfer(msg.sender, amount);\\r\\n        } else {\\r\\n            bool sent = payable(msg.sender).send(amount);\\r\\n            require(sent, 'Failed Transfer');\\r\\n        }\\r\\n        emit RemovedLiquidity(tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev update casino's current profit and liquidity.\\r\\n     */\\r\\n    function _updateProfitInfo(uint256 tokenId, uint256 fee, uint256 calculatedProfit) internal {\\r\\n        if (fee == 0) return;\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        casinoInfo.liquidity -= fee;\\r\\n        casinoInfo.profit -= int256(calculatedProfit);\\r\\n        casinoInfo.lastSwapTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev update casino's link consumption info\\r\\n     */\\r\\n    function _updateLinkConsumptionInfo(uint256 tokenId, uint256 tokenAmount) internal {\\r\\n        uint256 linkOut = getLinkAmountForToken(tokenIdToCasino[tokenId].tokenAddress, tokenAmount);\\r\\n        if (linkOut > linkSpent[tokenId]) linkSpent[tokenId] = 0;\\r\\n        else linkSpent[tokenId] -= linkOut;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get usd price of a token by usdt\\r\\n     */\\r\\n    function _getTokenUsdPrice(address tokenAddress) internal view returns (uint256) {\\r\\n        if (isStable[tokenAddress]) return 10 ** 18;\\r\\n\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        IPRC20 token = IPRC20(tokenAddress);\\r\\n\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = wbnbAddr;\\r\\n        path[2] = busdAddr;\\r\\n        uint256 usdValue = router.getAmountsOut(10 ** token.decimals(), path)[2];\\r\\n\\r\\n        return usdValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current pulse price in comparison with BNB and USDT\\r\\n     */\\r\\n    function getBNBPrice() public view returns (uint256 price) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = wbnbAddr;\\r\\n        path[1] = busdAddr;\\r\\n        uint256[] memory amounts = router.getAmountsOut(10 ** 18, path);\\r\\n        return amounts[1];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns token amount needed for `linkAmount` when swapping given token into link\\r\\n     */\\r\\n    function getTokenAmountForLink(address tokenAddr, uint256 linkAmount) public view returns (uint256) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path;\\r\\n        if (tokenAddr == address(0) || tokenAddr == wbnbAddr) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = linkTokenAddr;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = tokenAddr;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = linkTokenAddr;\\r\\n        }\\r\\n\\r\\n        return router.getAmountsIn(linkAmount, path)[0];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns link token amount out when swapping given token into link\\r\\n     */\\r\\n    function getLinkAmountForToken(address tokenAddr, uint256 tokenAmount) public view returns (uint256) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path;\\r\\n        bool isBNB = tokenAddr == address(0) || tokenAddr == wbnbAddr;\\r\\n        if (isBNB) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = linkTokenAddr;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = tokenAddr;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = linkTokenAddr;\\r\\n        }\\r\\n\\r\\n        return router.getAmountsOut(tokenAmount, path)[isBNB ? 1 : 2];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev resets round and return all money back to players\\r\\n     */\\r\\n    function resetRound() external nonReentrant {\\r\\n        onlyOwner();\\r\\n        require(roundLiveTime != 0, 'empty');\\r\\n\\r\\n        uint256 length = currentBetCount;\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            BetInfo memory info = currentBets[i];\\r\\n            Casino storage casinoInfo = tokenIdToCasino[info.tokenId];\\r\\n            uint256 totalBetAmount = _getTotalBetAmount(info.bets);\\r\\n            uint256 maximumReward = getMaximumReward(info.bets);\\r\\n\\r\\n            casinoInfo.locked -= maximumReward;\\r\\n            casinoInfo.liquidity += (maximumReward - totalBetAmount);\\r\\n\\r\\n            // Transfer money back\\r\\n            address tokenAddress = casinoInfo.tokenAddress;\\r\\n            if (tokenAddress != address(0)) {\\r\\n                IPRC20(tokenAddress).transfer(info.player, totalBetAmount);\\r\\n            } else {\\r\\n                bool sent = payable(info.player).send(totalBetAmount);\\r\\n                require(sent, 'send fail');\\r\\n            }\\r\\n        }\\r\\n        delete isVRFPending;\\r\\n        delete currentBetCount;\\r\\n        delete roundLiveTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev swaps profit fees of casinos into BNBP\\r\\n     */\\r\\n    function swapProfitFees() external {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        uint256 totalBNBForGame;\\r\\n        uint256 totalBNBForLink;\\r\\n        uint256 length = casinoCount;\\r\\n        uint256 BNBPPool = 0;\\r\\n\\r\\n        // Swap each token to BNB\\r\\n        for (uint256 i = 1; i <= length; ++i) {\\r\\n            Casino memory casinoInfo = tokenIdToCasino[i];\\r\\n            IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n\\r\\n            if (casinoInfo.liquidity == 0) continue;\\r\\n\\r\\n            uint256 availableProfit = casinoInfo.profit < 0 ? 0 : uint256(casinoInfo.profit);\\r\\n            if (casinoInfo.liquidity < availableProfit) {\\r\\n                availableProfit = casinoInfo.liquidity;\\r\\n            }\\r\\n\\r\\n            uint256 gameFee = (availableProfit * casinoInfo.fee) / 100;\\r\\n            uint256 amountForLinkFee = getTokenAmountForLink(casinoInfo.tokenAddress, linkSpent[i]);\\r\\n            _updateProfitInfo(i, uint256(gameFee), availableProfit);\\r\\n            casinoInfo.liquidity = tokenIdToCasino[i].liquidity;\\r\\n\\r\\n            // If fee from the profit is not enought for link, then use liquidity\\r\\n            if (gameFee < amountForLinkFee) {\\r\\n                if (casinoInfo.liquidity < (amountForLinkFee - gameFee)) {\\r\\n                    amountForLinkFee = gameFee + casinoInfo.liquidity;\\r\\n                    tokenIdToCasino[i].liquidity = 0;\\r\\n                } else {\\r\\n                    tokenIdToCasino[i].liquidity -= (amountForLinkFee - gameFee);\\r\\n                }\\r\\n                gameFee = 0;\\r\\n            } else {\\r\\n                gameFee -= amountForLinkFee;\\r\\n            }\\r\\n\\r\\n            // Update Link consumption info\\r\\n            _updateLinkConsumptionInfo(i, amountForLinkFee);\\r\\n\\r\\n            if (casinoInfo.tokenAddress == address(0)) {\\r\\n                totalBNBForGame += gameFee;\\r\\n                totalBNBForLink += amountForLinkFee;\\r\\n                continue;\\r\\n            }\\r\\n            if (casinoInfo.tokenAddress == BNBPAddress) {\\r\\n                BNBPPool += gameFee;\\r\\n                gameFee = 0;\\r\\n            }\\r\\n\\r\\n            path[0] = casinoInfo.tokenAddress;\\r\\n            path[1] = wbnbAddr;\\r\\n\\r\\n            if (gameFee + amountForLinkFee == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            token.approve(address(router), gameFee + amountForLinkFee);\\r\\n            uint256[] memory swappedAmounts = router.swapExactTokensForETH(\\r\\n                gameFee + amountForLinkFee,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n            totalBNBForGame += (swappedAmounts[1] * gameFee) / (gameFee + amountForLinkFee);\\r\\n            totalBNBForLink += (swappedAmounts[1] * amountForLinkFee) / (gameFee + amountForLinkFee);\\r\\n        }\\r\\n\\r\\n        path[0] = wbnbAddr;\\r\\n        // Convert to LINK\\r\\n        if (totalBNBForLink > 0) {\\r\\n            path[1] = linkTokenAddr;\\r\\n\\r\\n            // Swap BNB into Link Token\\r\\n            uint256 linkAmount = router.swapExactETHForTokens{ value: totalBNBForLink }(\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            )[1];\\r\\n\\r\\n            // Convert Link to ERC677 Link\\r\\n            IERC20(linkTokenAddr).approve(pegSwapAddr, linkAmount);\\r\\n            PegSwap(pegSwapAddr).swap(linkAmount, linkTokenAddr, link677TokenAddr);\\r\\n\\r\\n            // Fund VRF subscription account\\r\\n            LinkTokenInterface(link677TokenAddr).transferAndCall(\\r\\n                coordinatorAddr,\\r\\n                linkAmount,\\r\\n                abi.encode(subscriptionId)\\r\\n            );\\r\\n            emit SuppliedLink(linkAmount);\\r\\n        }\\r\\n\\r\\n        // Swap the rest of BNB to BNBP\\r\\n        if (totalBNBForGame > 0) {\\r\\n            path[1] = BNBPAddress;\\r\\n            BNBPPool += router.swapExactETHForTokens{ value: totalBNBForGame }(0, path, address(this), block.timestamp)[\\r\\n                1\\r\\n            ];\\r\\n        }\\r\\n\\r\\n        if (BNBPPool > 0) {\\r\\n            // add BNBP to tokenomics pool\\r\\n            IERC20(BNBPAddress).approve(potAddress, BNBPPool);\\r\\n            IPotLottery(potAddress).addAdminTokenValue(BNBPPool);\\r\\n\\r\\n            emit SuppliedBNBP(BNBPPool);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakePair.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IPancakePair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBNBP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface IBNBP {\\r\\n    error AirdropTimeError();\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(uint256 amount) external;\\r\\n\\r\\n    function isUserAddress(address addr) external view returns (bool);\\r\\n\\r\\n    function calculatePairAddress() external view returns (address);\\r\\n\\r\\n    function performAirdrop() external returns (uint256);\\r\\n\\r\\n    function performBurn() external returns (uint256);\\r\\n\\r\\n    function performLottery() external returns (address);\\r\\n\\r\\n    function setPotContractAddress(address addr) external;\\r\\n\\r\\n    function setAirdropPercentage(uint8 percentage) external;\\r\\n\\r\\n    function setAirdropInterval(uint256 interval) external;\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPRC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IPRC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IVRFConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface IVRFv2Consumer {\\r\\n    event RequestSent(uint256 requestId, uint32 numWords);\\r\\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\\r\\n\\r\\n    function requestRandomWords() external returns (uint256 requestId);\\r\\n\\r\\n    function getRequestStatus(uint256 _requestId) external view returns (bool fulfilled, uint256[] memory randomWords);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPegSwap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface PegSwap {\\r\\n    /**\\r\\n     * @notice deposits tokens from the target of a swap pair but does not return\\r\\n     * any. WARNING: Liquidity added through this method is only retrievable by\\r\\n     * the owner of the contract.\\r\\n     * @param amount count of liquidity being added\\r\\n     * @param source the token that can be swapped for what is being deposited\\r\\n     * @param target the token that can is being deposited for swapping\\r\\n     */\\r\\n    function addLiquidity(\\r\\n        uint256 amount,\\r\\n        address source,\\r\\n        address target\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice withdraws tokens from the target of a swap pair.\\r\\n     * @dev Only callable by owner\\r\\n     * @param amount count of liquidity being removed\\r\\n     * @param source the token that can be swapped for what is being removed\\r\\n     * @param target the token that can is being withdrawn from swapping\\r\\n     */\\r\\n    function removeLiquidity(\\r\\n        uint256 amount,\\r\\n        address source,\\r\\n        address target\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice exchanges the source token for target token\\r\\n     * @param amount count of tokens being swapped\\r\\n     * @param source the token that is being given\\r\\n     * @param target the token that is being taken\\r\\n     */\\r\\n    function swap(\\r\\n        uint256 amount,\\r\\n        address source,\\r\\n        address target\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice send funds that were accidentally transferred back to the owner. This\\r\\n     * allows rescuing of funds, and poses no additional risk as the owner could\\r\\n     * already withdraw any funds intended to be swapped. WARNING: If not called\\r\\n     * correctly this method can throw off the swappable token balances, but that\\r\\n     * can be recovered from by transferring the discrepancy back to the swap.\\r\\n     * @dev Only callable by owner\\r\\n     * @param amount count of tokens being moved\\r\\n     * @param target the token that is being moved\\r\\n     */\\r\\n    function recoverStuckTokens(uint256 amount, address target) external;\\r\\n\\r\\n    /**\\r\\n     * @notice swap tokens in one transaction if the sending token supports ERC677\\r\\n     * @param sender address that initially initiated the call to the source token\\r\\n     * @param amount count of tokens sent for the swap\\r\\n     * @param targetData address of target token encoded as a bytes array\\r\\n     */\\r\\n    function onTokenTransfer(\\r\\n        address sender,\\r\\n        uint256 amount,\\r\\n        bytes calldata targetData\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Roulette/Roulette.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol';\\r\\nimport '../interfaces/IPancakePair.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IBNBP.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IVRFConsumer.sol';\\r\\nimport '../interfaces/IPegSwap.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\ncontract RoulettePot is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    uint256 public casinoCount;\\r\\n    uint256 public betIds = 1060;\\r\\n    mapping(uint256 => Casino) public tokenIdToCasino;\\r\\n    mapping(address => bool) public isStable;\\r\\n    mapping(address => mapping(uint256 => BetInfo)) public userLastBetInfo;\\r\\n\\r\\n    address public casinoNFTAddress;\\r\\n    address public BNBPAddress;\\r\\n    address public consumerAddress;\\r\\n    address public potAddress;\\r\\n\\r\\n    address internal constant wbnbAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address internal constant busdAddr = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // testnet: 0x4608Ea31fA832ce7DCF56d78b5434b49830E91B1, mainnet: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\\r\\n    address internal constant pancakeFactoryAddr = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // testnet: 0x6725F303b657a9451d8BA641348b6761A6CC7a17, mainnet: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n    address internal constant pancakeRouterAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    address internal constant coordinatorAddr = 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE; // testnet: 0x6A2AAd07396B36Fe02a22b33cf443582f682c82f, mainnet: 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE\\r\\n    address internal constant linkTokenAddr = 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD; // testnet: 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06, mainnet: 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD\\r\\n    address internal constant pegSwapAddr = 0x1FCc3B22955e76Ca48bF025f1A6993685975Bb9e;\\r\\n    address internal constant link677TokenAddr = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;\\r\\n    uint256 internal constant subscriptionId = 675; // testnet: 2102, mainnet: 675\\r\\n    uint256 public linkPerBet = 45000000000000000; // 0.045 link token per request\\r\\n    mapping(uint256 => uint256) public linkSpent;\\r\\n\\r\\n    struct Casino {\\r\\n        address tokenAddress;\\r\\n        string tokenName;\\r\\n        uint256 liquidity;\\r\\n        uint256 locked;\\r\\n        uint256 initialMaxBet;\\r\\n        uint256 initialMinBet;\\r\\n        uint256 maxBet;\\r\\n        uint256 minBet;\\r\\n        uint256 fee;\\r\\n        int256 profit;\\r\\n        uint256 lastSwapTime;\\r\\n    }\\r\\n\\r\\n    struct BetInfo {\\r\\n        bool isPending;\\r\\n        uint256 requestId;\\r\\n        Bet[] bets;\\r\\n        uint256 tokenPrice;\\r\\n    }\\r\\n\\r\\n    struct Bet {\\r\\n        /* 5: number, 4: even, odd, 3: 18s, 2: 12s, 1: row, 0: black, red */\\r\\n        uint8 betType;\\r\\n        uint8 number;\\r\\n        uint240 amount;\\r\\n    }\\r\\n\\r\\n    event FinishedBet(\\r\\n        uint256 tokenId,\\r\\n        uint256 betId,\\r\\n        address player,\\r\\n        uint256 nonce,\\r\\n        uint256 totalAmount,\\r\\n        uint256 rewardAmount,\\r\\n        uint256 totalUSD,\\r\\n        uint256 rewardUSD,\\r\\n        uint256 maximumReward\\r\\n    );\\r\\n    event TransferFailed(uint256 tokenId, address to, uint256 amount);\\r\\n    event TokenSwapFailed(uint256 tokenId, uint256 balance, string reason, uint256 timestamp);\\r\\n    event InitializedBet(uint256 tokenId, address player, uint256 amount);\\r\\n    event AddedLiquidity(uint256 tokenId, address owner, uint256 amount);\\r\\n    event RemovedLiquidity(uint256 tokenId, address owner, uint256 amount);\\r\\n    event UpdatedMaxBet(uint256 tokenId, address owner, uint256 value);\\r\\n    event UpdatedMinBet(uint256 tokenId, address owner, uint256 value);\\r\\n    event LiquidityChanged(uint256 tokenId, address changer, uint256 liquidity, uint256 locked, bool isFinishedBet);\\r\\n    event SuppliedBNBP(uint256 amount);\\r\\n    event SuppliedLink(uint256 amount);\\r\\n\\r\\n    constructor(\\r\\n        address nftAddr,\\r\\n        address _BNBPAddress,\\r\\n        address _consumerAddress,\\r\\n        address _potAddress\\r\\n    ) {\\r\\n        address BNBPPair = IPancakeFactory(pancakeFactoryAddr).getPair(wbnbAddr, _BNBPAddress);\\r\\n        require(BNBPPair != address(0), 'No liquidity with BNBP and BNB');\\r\\n\\r\\n        casinoNFTAddress = nftAddr;\\r\\n        BNBPAddress = _BNBPAddress;\\r\\n        consumerAddress = _consumerAddress;\\r\\n        potAddress = _potAddress;\\r\\n    }\\r\\n\\r\\n    modifier onlyCasinoOwner(uint256 tokenId) {\\r\\n        require(IERC721(casinoNFTAddress).ownerOf(tokenId) == msg.sender, 'Not Casino Owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates pot contract Address\\r\\n     */\\r\\n    function setPotAddress(address addr) external onlyOwner {\\r\\n        potAddress = addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets token is stable or not\\r\\n     */\\r\\n    function setTokenStable(address tokenAddr, bool _isStable) external onlyOwner {\\r\\n        isStable[tokenAddr] = _isStable;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set how much link token will be consumed per bet\\r\\n     */\\r\\n    function setLinkPerBet(uint256 value) external onlyOwner {\\r\\n        linkPerBet = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns list of casinos minted\\r\\n     */\\r\\n    function getCasinoList()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            Casino[] memory casinos,\\r\\n            address[] memory owners,\\r\\n            uint256[] memory prices\\r\\n        )\\r\\n    {\\r\\n        uint256 length = casinoCount;\\r\\n        casinos = new Casino[](length);\\r\\n        owners = new address[](length);\\r\\n        prices = new uint256[](length);\\r\\n        IERC721 nftContract = IERC721(casinoNFTAddress);\\r\\n\\r\\n        for (uint256 i = 1; i <= length; i++) {\\r\\n            casinos[i - 1] = tokenIdToCasino[i];\\r\\n            owners[i - 1] = nftContract.ownerOf(i);\\r\\n            if (casinos[i - 1].tokenAddress == address(0)) {\\r\\n                prices[i - 1] = getBNBPrice();\\r\\n            } else {\\r\\n                prices[i - 1] = _getTokenUsdPrice(casinos[i - 1].tokenAddress);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds a new casino\\r\\n     */\\r\\n    function addCasino(\\r\\n        uint256 tokenId,\\r\\n        address tokenAddress,\\r\\n        string calldata tokenName,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external {\\r\\n        require(msg.sender == casinoNFTAddress || msg.sender == owner(), 'Only casino nft contract can call');\\r\\n\\r\\n        Casino storage newCasino = tokenIdToCasino[tokenId];\\r\\n        newCasino.tokenAddress = tokenAddress;\\r\\n        newCasino.tokenName = tokenName;\\r\\n        newCasino.initialMaxBet = maxBet;\\r\\n        newCasino.initialMinBet = minBet;\\r\\n        newCasino.maxBet = maxBet;\\r\\n        newCasino.minBet = minBet;\\r\\n        newCasino.fee = fee;\\r\\n        newCasino.liquidity = 0;\\r\\n\\r\\n        casinoCount++;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set max bet limit for casino\\r\\n     */\\r\\n    function setMaxBet(uint256 tokenId, uint256 newMaxBet) external onlyCasinoOwner(tokenId) {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(newMaxBet <= casinoInfo.initialMaxBet, \\\"Can't exceed initial max bet\\\");\\r\\n        require(newMaxBet >= casinoInfo.minBet, \\\"Can't exceed initial max bet\\\");\\r\\n\\r\\n        casinoInfo.maxBet = newMaxBet;\\r\\n        emit UpdatedMaxBet(tokenId, msg.sender, newMaxBet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set min bet limit for casino\\r\\n     */\\r\\n    function setMinBet(uint256 tokenId, uint256 newMinBet) external onlyCasinoOwner(tokenId) {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(newMinBet <= casinoInfo.maxBet, 'min >= max');\\r\\n        require(newMinBet > casinoInfo.initialMinBet, \\\"Can't be lower than initial min bet\\\");\\r\\n\\r\\n        casinoInfo.minBet = newMinBet;\\r\\n        emit UpdatedMinBet(tokenId, msg.sender, newMinBet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns maximum reward amount for given bets\\r\\n     */\\r\\n    function getMaximumReward(Bet[] memory bets) public pure returns (uint256) {\\r\\n        uint256 maxReward;\\r\\n        uint8[6] memory betRewards = [2, 3, 3, 2, 2, 36];\\r\\n\\r\\n        for (uint256 i = 0; i <= 37; i++) {\\r\\n            uint256 reward;\\r\\n\\r\\n            for (uint256 j = 0; j < bets.length; j++) {\\r\\n                if (_isInBet(bets[j], i)) {\\r\\n                    reward += bets[j].amount * betRewards[bets[j].betType];\\r\\n                }\\r\\n            }\\r\\n            if (maxReward < reward) {\\r\\n                maxReward = reward;\\r\\n            }\\r\\n        }\\r\\n        return maxReward;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns whbnb Bet `b` covers the `number` or not\\r\\n     */\\r\\n    function _isInBet(Bet memory b, uint256 number) public pure returns (bool) {\\r\\n        require(b.betType <= 5, 'Invalid bet type');\\r\\n        require(b.number <= 37, 'Invalid betting number');\\r\\n\\r\\n        if (number == 0 || number == 37) {\\r\\n            if (b.betType == 5) {\\r\\n                return b.number == number;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (b.betType == 5) {\\r\\n            return (b.number == number); /* bet on number */\\r\\n        } else if (b.betType == 4) {\\r\\n            if (b.number == 0) return (number % 2 == 0); /* bet on even */\\r\\n            if (b.number == 1) return (number % 2 == 1); /* bet on odd */\\r\\n        } else if (b.betType == 3) {\\r\\n            if (b.number == 0) return (number <= 18); /* bet on low 18s */\\r\\n            if (b.number == 1) return (number >= 19); /* bet on high 18s */\\r\\n        } else if (b.betType == 2) {\\r\\n            if (b.number == 0) return (number <= 12); /* bet on 1st dozen */\\r\\n            if (b.number == 1) return (number > 12 && number <= 24); /* bet on 2nd dozen */\\r\\n            if (b.number == 2) return (number > 24); /* bet on 3rd dozen */\\r\\n        } else if (b.betType == 1) {\\r\\n            if (b.number == 0) return (number % 3 == 0); /* bet on top row */\\r\\n            if (b.number == 1) return (number % 3 == 1); /* bet on middle row */\\r\\n            if (b.number == 2) return (number % 3 == 2); /* bet on bottom row */\\r\\n        } else if (b.betType == 0) {\\r\\n            if (b.number == 0) {\\r\\n                /* bet on black */\\r\\n                if (number <= 10 || (number >= 19 && number <= 28)) {\\r\\n                    return (number % 2 == 0);\\r\\n                } else {\\r\\n                    return (number % 2 == 1);\\r\\n                }\\r\\n            } else {\\r\\n                /* bet on red */\\r\\n                if (number <= 10 || (number >= 19 && number <= 28)) {\\r\\n                    return (number % 2 == 1);\\r\\n                } else {\\r\\n                    return (number % 2 == 0);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns total bet amount\\r\\n     */\\r\\n    function _getTotalBetAmount(Bet[] memory bets) internal pure returns (uint256) {\\r\\n        /* 5: number, 4: even, odd, 3: 18s, 2: 12s, 1: row, 0: black, red */\\r\\n        uint256[5] memory betCount;\\r\\n        uint256 totalBetAmount;\\r\\n        for (uint256 i = 0; i < bets.length; i++) {\\r\\n            require(bets[i].betType <= 5, 'Invalid bet type');\\r\\n\\r\\n            totalBetAmount += bets[i].amount;\\r\\n            if (bets[i].betType < 5) {\\r\\n                betCount[bets[i].betType]++;\\r\\n            }\\r\\n        }\\r\\n        require(\\r\\n            betCount[0] < 2 && betCount[1] < 3 && betCount[2] < 3 && betCount[3] < 2 && betCount[4] < 2,\\r\\n            'Bet Restriction'\\r\\n        );\\r\\n\\r\\n        return totalBetAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev calculate total rewards with a given nonce\\r\\n     */\\r\\n    function _spinWheel(Bet[] memory bets, uint256 nonce) internal pure returns (uint256, uint256) {\\r\\n        uint256 totalReward;\\r\\n        uint8[6] memory betRewards = [2, 3, 3, 2, 2, 36];\\r\\n\\r\\n        for (uint256 i = 0; i < bets.length; i++) {\\r\\n            if (_isInBet(bets[i], nonce)) {\\r\\n                totalReward += betRewards[bets[i].betType] * bets[i].amount;\\r\\n            }\\r\\n        }\\r\\n        return (nonce, totalReward);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize user bet info to pending status\\r\\n     */\\r\\n    function _initializeBetInfo(\\r\\n        uint256 tokenId,\\r\\n        uint256 requestId,\\r\\n        Bet[] calldata bets,\\r\\n        uint256 tokenPrice\\r\\n    ) internal {\\r\\n        BetInfo storage info = userLastBetInfo[msg.sender][tokenId];\\r\\n\\r\\n        delete info.bets;\\r\\n        info.requestId = requestId;\\r\\n        info.isPending = true;\\r\\n        info.tokenPrice = tokenPrice;\\r\\n        for (uint256 i = 0; i < bets.length; i++) {\\r\\n            Bet memory bet = bets[i];\\r\\n            info.bets.push(bet);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize bet and request nonce to VRF\\r\\n     *\\r\\n     * NOTE this function only accepts erc20 tokens\\r\\n     *      Bet type should be less than 6, otherwise will revert\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     * @param bets array of bets\\r\\n     */\\r\\n    function initializeTokenBet(uint256 tokenId, Bet[] calldata bets) external nonReentrant returns (uint256) {\\r\\n        require(userLastBetInfo[msg.sender][tokenId].isPending == false, 'Bet not finished');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress != address(0), \\\"This casino doesn't support tokens\\\");\\r\\n\\r\\n        IPRC20 token = IPRC20(casinoInfo.tokenAddress);\\r\\n        uint256 approvedAmount = token.allowance(msg.sender, address(this));\\r\\n        uint256 totalBetAmount = _getTotalBetAmount(bets);\\r\\n        uint256 maxReward = getMaximumReward(bets);\\r\\n        uint256 tokenPrice = isStable[casinoInfo.tokenAddress] ? 10**18 : _getTokenUsdPrice(casinoInfo.tokenAddress);\\r\\n        uint256 totalUSDValue = (totalBetAmount * tokenPrice) / 10**token.decimals();\\r\\n\\r\\n        require(token.balanceOf(msg.sender) >= totalBetAmount, 'Not enough balance');\\r\\n        require(totalBetAmount <= approvedAmount, 'Not enough allowance');\\r\\n        require(maxReward <= casinoInfo.liquidity + totalBetAmount, 'Not enough liquidity');\\r\\n        require(totalUSDValue <= casinoInfo.maxBet * 10**18, \\\"Can't exceed max bet limit\\\");\\r\\n        require(totalUSDValue >= casinoInfo.minBet * 10**18, \\\"Can't be lower than min bet limit\\\");\\r\\n\\r\\n        token.transferFrom(msg.sender, address(this), totalBetAmount);\\r\\n        casinoInfo.liquidity -= (maxReward - totalBetAmount);\\r\\n        casinoInfo.locked += maxReward;\\r\\n\\r\\n        IVRFv2Consumer vrfConsumer = IVRFv2Consumer(consumerAddress);\\r\\n        uint256 requestId = vrfConsumer.requestRandomWords();\\r\\n        _initializeBetInfo(tokenId, requestId, bets, tokenPrice);\\r\\n\\r\\n        linkSpent[tokenId] += linkPerBet;\\r\\n\\r\\n        emit InitializedBet(tokenId, msg.sender, totalBetAmount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n        return requestId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize bet and request nonce to VRF\\r\\n     *\\r\\n     * NOTE this function only accepts bnb\\r\\n     *      Bet type should be less than 6, otherwise will revert\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     * @param bets array of bets\\r\\n     */\\r\\n    function initializeEthBet(uint256 tokenId, Bet[] calldata bets) external payable returns (uint256) {\\r\\n        BetInfo storage info = userLastBetInfo[msg.sender][tokenId];\\r\\n        require(info.isPending == false, 'Bet not finished');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress == address(0), 'This casino only support bnb');\\r\\n\\r\\n        IPRC20 busdToken = IPRC20(busdAddr);\\r\\n        uint256 totalBetAmount = _getTotalBetAmount(bets);\\r\\n        uint256 maxReward = getMaximumReward(bets);\\r\\n        uint256 bnbPrice = getBNBPrice();\\r\\n        uint256 totalUSDValue = (bnbPrice * totalBetAmount) / 10**18;\\r\\n\\r\\n        require(msg.value == totalBetAmount, 'Not correct bet amount');\\r\\n        require(maxReward <= casinoInfo.liquidity + totalBetAmount, 'Not enough liquidity');\\r\\n        require(totalUSDValue <= casinoInfo.maxBet * 10**busdToken.decimals(), \\\"Can't exceed max bet limit\\\");\\r\\n        require(totalUSDValue >= casinoInfo.minBet * 10**busdToken.decimals(), \\\"Can't be lower than min bet limit\\\");\\r\\n\\r\\n        casinoInfo.liquidity -= (maxReward - totalBetAmount);\\r\\n        casinoInfo.locked += maxReward;\\r\\n\\r\\n        IVRFv2Consumer vrfConsumer = IVRFv2Consumer(consumerAddress);\\r\\n        uint256 requestId = vrfConsumer.requestRandomWords();\\r\\n        _initializeBetInfo(tokenId, requestId, bets, bnbPrice);\\r\\n\\r\\n        linkSpent[tokenId] += linkPerBet;\\r\\n\\r\\n        emit InitializedBet(tokenId, msg.sender, totalBetAmount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n        return requestId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev retrieve nonce and spin the wheel, return reward if user wins\\r\\n     *\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     */\\r\\n    function finishBet(uint256 tokenId) external nonReentrant {\\r\\n        BetInfo storage betInfo = userLastBetInfo[msg.sender][tokenId];\\r\\n        require(betInfo.isPending == true, 'Bet not pending');\\r\\n\\r\\n        (bool fulfilled, uint256[] memory nonces) = IVRFv2Consumer(consumerAddress).getRequestStatus(betInfo.requestId);\\r\\n        require(fulfilled == true, 'not yet fulfilled');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        uint256 decimal = casinoInfo.tokenAddress == address(0) ? 18 : IPRC20(casinoInfo.tokenAddress).decimals();\\r\\n        (uint256 nonce, uint256 totalReward) = _spinWheel(betInfo.bets, nonces[0] % 38);\\r\\n        uint256 totalBetAmount = _getTotalBetAmount(betInfo.bets);\\r\\n        uint256 maxReward = getMaximumReward(betInfo.bets);\\r\\n        uint256 totalUSDValue = (totalBetAmount * betInfo.tokenPrice) / 10**decimal;\\r\\n        uint256 totalRewardUSD = (totalReward * betInfo.tokenPrice) / 10**decimal;\\r\\n\\r\\n        betIds++;\\r\\n        betInfo.isPending = false;\\r\\n\\r\\n        if (totalReward > 0) {\\r\\n            if (casinoInfo.tokenAddress != address(0)) {\\r\\n                IPRC20(casinoInfo.tokenAddress).transfer(msg.sender, totalReward);\\r\\n            } else {\\r\\n                bool sent = payable(msg.sender).send(totalReward);\\r\\n                require(sent, 'send fail');\\r\\n            }\\r\\n        }\\r\\n        casinoInfo.liquidity = casinoInfo.liquidity + maxReward - totalReward;\\r\\n        casinoInfo.locked -= maxReward;\\r\\n        casinoInfo.profit = casinoInfo.profit + int256(totalBetAmount) - int256(totalReward);\\r\\n\\r\\n        emit FinishedBet(\\r\\n            tokenId,\\r\\n            betIds,\\r\\n            msg.sender,\\r\\n            nonce,\\r\\n            totalBetAmount,\\r\\n            totalReward,\\r\\n            totalUSDValue,\\r\\n            totalRewardUSD,\\r\\n            maxReward\\r\\n        );\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns VRF nonce status for bet\\r\\n     */\\r\\n    function getBetResult(uint256 tokenId, address user) public view returns (bool, uint256) {\\r\\n        BetInfo storage info = userLastBetInfo[user][tokenId];\\r\\n        IVRFv2Consumer consumer = IVRFv2Consumer(consumerAddress);\\r\\n        (bool fulfilled, uint256[] memory nonces) = consumer.getRequestStatus(info.requestId);\\r\\n        return (fulfilled, nonces[0]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds liquidity to the casino pool\\r\\n     * NOTE this is only for casinos that uses tokens\\r\\n     */\\r\\n    function addLiquidityWithTokens(uint256 tokenId, uint256 amount) external onlyCasinoOwner(tokenId) {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress != address(0), \\\"This casino doesn't support tokens\\\");\\r\\n\\r\\n        IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        casinoInfo.liquidity += amount;\\r\\n        emit AddedLiquidity(tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds liquidity to the casino pool\\r\\n     * NOTE this is only for casinos that uses bnb\\r\\n     */\\r\\n    function addLiquidityWithEth(uint256 tokenId) external payable onlyCasinoOwner(tokenId) {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n\\r\\n        require(casinoInfo.tokenAddress == address(0), \\\"This casino doesn't supports bnb\\\");\\r\\n        casinoInfo.liquidity += msg.value;\\r\\n        emit AddedLiquidity(tokenId, msg.sender, msg.value);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev removes liquidity from the casino pool\\r\\n     */\\r\\n    function removeLiquidity(uint256 tokenId, uint256 amount) external onlyCasinoOwner(tokenId) {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        uint256 liquidity = casinoInfo.liquidity;\\r\\n\\r\\n        require(int256(liquidity - amount) >= casinoInfo.profit, 'Cannot withdraw profit before it is fee taken');\\r\\n        require(liquidity >= amount, 'Not enough liquidity');\\r\\n\\r\\n        unchecked {\\r\\n            casinoInfo.liquidity -= amount;\\r\\n        }\\r\\n        if (casinoInfo.tokenAddress != address(0)) {\\r\\n            IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n            token.safeTransfer(msg.sender, amount);\\r\\n        } else {\\r\\n            bool sent = payable(msg.sender).send(amount);\\r\\n            require(sent, 'Failed Transfer');\\r\\n        }\\r\\n        emit RemovedLiquidity(tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, casinoInfo.liquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev update casino's current profit and liquidity.\\r\\n     */\\r\\n    function _updateProfitInfo(\\r\\n        uint256 tokenId,\\r\\n        uint256 fee,\\r\\n        uint256 calculatedProfit\\r\\n    ) internal {\\r\\n        if (fee == 0) return;\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        casinoInfo.liquidity -= fee;\\r\\n        casinoInfo.profit -= int256(calculatedProfit);\\r\\n        casinoInfo.lastSwapTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev update casino's link consumption info\\r\\n     */\\r\\n    function _updateLinkConsumptionInfo(uint256 tokenId, uint256 tokenAmount) internal {\\r\\n        uint256 linkOut = getLinkAmountForToken(tokenIdToCasino[tokenId].tokenAddress, tokenAmount);\\r\\n        if (linkOut > linkSpent[tokenId]) linkSpent[tokenId] = 0;\\r\\n        else linkSpent[tokenId] -= linkOut;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get usd price of a token by usdt\\r\\n     */\\r\\n    function _getTokenUsdPrice(address tokenAddress) internal view returns (uint256) {\\r\\n        if (isStable[tokenAddress]) return 10**18;\\r\\n\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        IPRC20 token = IPRC20(tokenAddress);\\r\\n\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = wbnbAddr;\\r\\n        path[2] = busdAddr;\\r\\n        uint256 usdValue = router.getAmountsOut(10**token.decimals(), path)[2];\\r\\n\\r\\n        return usdValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current pulse price in comparison with BNB and USDT\\r\\n     */\\r\\n    function getBNBPrice() public view returns (uint256 price) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = wbnbAddr;\\r\\n        path[1] = busdAddr;\\r\\n        uint256[] memory amounts = router.getAmountsOut(10**18, path);\\r\\n        return amounts[1];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns token amount needed for `linkAmount` when swapping given token into link\\r\\n     */\\r\\n    function getTokenAmountForLink(address tokenAddr, uint256 linkAmount) public view returns (uint256) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path;\\r\\n        if (tokenAddr == address(0) || tokenAddr == wbnbAddr) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = linkTokenAddr;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = tokenAddr;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = linkTokenAddr;\\r\\n        }\\r\\n\\r\\n        return router.getAmountsIn(linkAmount, path)[0];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns link token amount out when swapping given token into link\\r\\n     */\\r\\n    function getLinkAmountForToken(address tokenAddr, uint256 tokenAmount) public view returns (uint256) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path;\\r\\n        bool isBNB = tokenAddr == address(0) || tokenAddr == wbnbAddr;\\r\\n        if (isBNB) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = linkTokenAddr;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = tokenAddr;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = linkTokenAddr;\\r\\n        }\\r\\n\\r\\n        return router.getAmountsOut(tokenAmount, path)[isBNB ? 1 : 2];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev swaps profit fees of casinos into BNBP\\r\\n     */\\r\\n    function swapProfitFees() external {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        uint256 totalBNBForGame;\\r\\n        uint256 totalBNBForLink;\\r\\n        uint256 length = casinoCount;\\r\\n        uint256 BNBPPool = 0;\\r\\n\\r\\n        // Swap each token to BNB\\r\\n        for (uint256 i = 1; i <= length; i++) {\\r\\n            Casino memory casinoInfo = tokenIdToCasino[i];\\r\\n            IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n\\r\\n            if (casinoInfo.liquidity == 0) continue;\\r\\n\\r\\n            uint256 availableProfit = casinoInfo.profit < 0 ? 0 : uint256(casinoInfo.profit);\\r\\n            if (casinoInfo.liquidity < availableProfit) {\\r\\n                availableProfit = casinoInfo.liquidity;\\r\\n            }\\r\\n\\r\\n            uint256 gameFee = (availableProfit * casinoInfo.fee) / 100;\\r\\n            uint256 amountForLinkFee = getTokenAmountForLink(casinoInfo.tokenAddress, linkSpent[i]);\\r\\n            _updateProfitInfo(i, uint256(gameFee), availableProfit);\\r\\n            casinoInfo.liquidity = tokenIdToCasino[i].liquidity;\\r\\n\\r\\n            // If fee from the profit is not enought for link, then use liquidity\\r\\n            if (gameFee < amountForLinkFee) {\\r\\n                if (casinoInfo.liquidity < (amountForLinkFee - gameFee)) {\\r\\n                    amountForLinkFee = gameFee + casinoInfo.liquidity;\\r\\n                    tokenIdToCasino[i].liquidity = 0;\\r\\n                } else {\\r\\n                    tokenIdToCasino[i].liquidity -= (amountForLinkFee - gameFee);\\r\\n                }\\r\\n                gameFee = 0;\\r\\n            } else {\\r\\n                gameFee -= amountForLinkFee;\\r\\n            }\\r\\n\\r\\n            // Update Link consumption info\\r\\n            _updateLinkConsumptionInfo(i, amountForLinkFee);\\r\\n\\r\\n            if (casinoInfo.tokenAddress == address(0)) {\\r\\n                totalBNBForGame += gameFee;\\r\\n                totalBNBForLink += amountForLinkFee;\\r\\n                continue;\\r\\n            }\\r\\n            if (casinoInfo.tokenAddress == BNBPAddress) {\\r\\n                BNBPPool += gameFee;\\r\\n                gameFee = 0;\\r\\n            }\\r\\n\\r\\n            path[0] = casinoInfo.tokenAddress;\\r\\n            path[1] = wbnbAddr;\\r\\n\\r\\n            if (gameFee + amountForLinkFee == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            token.approve(address(router), gameFee + amountForLinkFee);\\r\\n            uint256[] memory swappedAmounts = router.swapExactTokensForETH(\\r\\n                gameFee + amountForLinkFee,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n            totalBNBForGame += (swappedAmounts[1] * gameFee) / (gameFee + amountForLinkFee);\\r\\n            totalBNBForLink += (swappedAmounts[1] * amountForLinkFee) / (gameFee + amountForLinkFee);\\r\\n        }\\r\\n\\r\\n        path[0] = wbnbAddr;\\r\\n        // Convert to LINK\\r\\n        if (totalBNBForLink > 0) {\\r\\n            path[1] = linkTokenAddr;\\r\\n\\r\\n            // Swap BNB into Link Token\\r\\n            uint256 linkAmount = router.swapExactETHForTokens{ value: totalBNBForLink }(\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            )[1];\\r\\n\\r\\n            // Convert Link to ERC677 Link\\r\\n            IERC20(linkTokenAddr).approve(pegSwapAddr, linkAmount);\\r\\n            PegSwap(pegSwapAddr).swap(linkAmount, linkTokenAddr, link677TokenAddr);\\r\\n\\r\\n            // Fund VRF subscription account\\r\\n            LinkTokenInterface(link677TokenAddr).transferAndCall(\\r\\n                coordinatorAddr,\\r\\n                linkAmount,\\r\\n                abi.encode(subscriptionId)\\r\\n            );\\r\\n            emit SuppliedLink(linkAmount);\\r\\n        }\\r\\n\\r\\n        // Swap the rest of BNB to BNBP\\r\\n        if (totalBNBForGame > 0) {\\r\\n            path[1] = BNBPAddress;\\r\\n            BNBPPool += router.swapExactETHForTokens{ value: totalBNBForGame }(0, path, address(this), block.timestamp)[\\r\\n                1\\r\\n            ];\\r\\n        }\\r\\n\\r\\n        if (BNBPPool > 0) {\\r\\n            // add BNBP to tokenomics pool\\r\\n            IERC20(BNBPAddress).approve(potAddress, BNBPPool);\\r\\n            IPotLottery(potAddress).addAdminTokenValue(BNBPPool);\\r\\n\\r\\n            emit SuppliedBNBP(BNBPPool);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FortuneWheel/FortuneWheel.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol';\\r\\nimport '../interfaces/IPancakePair.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IBNBP.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IVRFConsumer.sol';\\r\\nimport '../interfaces/IPegSwap.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\ncontract FortuneWheel is ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    uint256 public casinoCount;\\r\\n    mapping(uint256 => Casino) public tokenIdToCasino;\\r\\n    mapping(address => bool) public isStable;\\r\\n\\r\\n    // Info for current round\\r\\n    BetInfo[] currentBets;\\r\\n    OutcomeInfo[] public outcomeInfos;\\r\\n    uint256 public currentBetCount;\\r\\n    uint256 public roundLiveTime;\\r\\n    bool public isVRFPending;\\r\\n    uint256 public requestId;\\r\\n    uint256 public roundIds;\\r\\n    uint256 public betIds;\\r\\n\\r\\n    address public casinoNFTAddress;\\r\\n    address public BNBPAddress;\\r\\n    address public consumerAddress;\\r\\n    address public potAddress;\\r\\n    address public owner;\\r\\n\\r\\n    uint256 public maxOutcome;\\r\\n    uint256 public maxNonceLimit;\\r\\n    address internal constant wbnbAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address internal constant busdAddr = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // testnet: 0x4608Ea31fA832ce7DCF56d78b5434b49830E91B1, mainnet: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\\r\\n    address internal constant pancakeFactoryAddr = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // testnet: 0x6725F303b657a9451d8BA641348b6761A6CC7a17, mainnet: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n    address internal constant pancakeRouterAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    address internal constant coordinatorAddr = 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE; // testnet: 0x6A2AAd07396B36Fe02a22b33cf443582f682c82f, mainnet: 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE\\r\\n    address internal constant linkTokenAddr = 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD; // testnet: 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06, mainnet: 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD\\r\\n    address internal constant pegSwapAddr = 0x1FCc3B22955e76Ca48bF025f1A6993685975Bb9e;\\r\\n    address internal constant link677TokenAddr = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;\\r\\n    uint256 internal constant subscriptionId = 675; // testnet: 2102, mainnet: 675\\r\\n    uint256 public linkPerBet = 45000000000000000; // 0.045 link token per request\\r\\n    mapping(uint256 => uint256) public linkSpent;\\r\\n\\r\\n    struct OutcomeInfo {\\r\\n        uint256 from;\\r\\n        uint256 to;\\r\\n        uint256 outcome;\\r\\n    }\\r\\n\\r\\n    struct Casino {\\r\\n        uint256 nftTokenId;\\r\\n        address tokenAddress;\\r\\n        string tokenName;\\r\\n        uint256 liquidity;\\r\\n        uint256 roundLiquidity;\\r\\n        uint256 locked;\\r\\n        uint256 initialMaxBet;\\r\\n        uint256 initialMinBet;\\r\\n        uint256 maxBet;\\r\\n        uint256 minBet;\\r\\n        uint256 fee;\\r\\n        int256 profit;\\r\\n        uint256 lastSwapTime;\\r\\n        uint256 roundLimit;\\r\\n    }\\r\\n\\r\\n    struct BetInfo {\\r\\n        uint256 amount;\\r\\n        address player;\\r\\n        uint256 tokenId;\\r\\n        uint256 tokenPrice;\\r\\n    }\\r\\n\\r\\n    event FinishedBet(\\r\\n        uint256 tokenId,\\r\\n        uint256 betId,\\r\\n        uint256 roundId,\\r\\n        address player,\\r\\n        uint256 nonce,\\r\\n        uint256 totalAmount,\\r\\n        uint256 rewardAmount,\\r\\n        uint256 totalUSD,\\r\\n        uint256 rewardUSD,\\r\\n        uint256 maximumReward\\r\\n    );\\r\\n    event RoundFinished(uint256 roundId, uint256 nonce, uint256 outcome);\\r\\n    event TransferFailed(uint256 tokenId, address to, uint256 amount);\\r\\n    event TokenSwapFailed(uint256 tokenId, uint256 balance, string reason, uint256 timestamp);\\r\\n    event InitializedBet(uint256 roundId, uint256 tokenId, address player, uint256 amount);\\r\\n    event AddedLiquidity(uint256 tokenId, address owner, uint256 amount);\\r\\n    event RemovedLiquidity(uint256 tokenId, address owner, uint256 amount);\\r\\n    event UpdatedMaxBet(uint256 tokenId, address owner, uint256 value);\\r\\n    event UpdatedMinBet(uint256 tokenId, address owner, uint256 value);\\r\\n    event LiquidityChanged(\\r\\n        uint256 tokenId,\\r\\n        address changer,\\r\\n        uint256 liquidity,\\r\\n        uint256 roundLiquidity,\\r\\n        uint256 locked,\\r\\n        bool isFinishedBet\\r\\n    );\\r\\n    event SuppliedBNBP(uint256 amount);\\r\\n    event SuppliedLink(uint256 amount);\\r\\n    event VRFRequested();\\r\\n\\r\\n    constructor(\\r\\n        address nftAddr,\\r\\n        address _BNBPAddress,\\r\\n        address _consumerAddress,\\r\\n        address _potAddress,\\r\\n        OutcomeInfo[] memory _outcomeInfos\\r\\n    ) {\\r\\n        address BNBPPair = IPancakeFactory(pancakeFactoryAddr).getPair(wbnbAddr, _BNBPAddress);\\r\\n        require(BNBPPair != address(0), 'No liquidity with BNBP and BNB');\\r\\n\\r\\n        casinoNFTAddress = nftAddr;\\r\\n        BNBPAddress = _BNBPAddress;\\r\\n        consumerAddress = _consumerAddress;\\r\\n        potAddress = _potAddress;\\r\\n        owner = msg.sender;\\r\\n        setOutcomeInfos(_outcomeInfos);\\r\\n    }\\r\\n\\r\\n    function onlyCasinoOwner(uint256 tokenId) internal view {\\r\\n        require(IERC721(casinoNFTAddress).ownerOf(tokenId) == msg.sender, 'Not Casino Owner');\\r\\n    }\\r\\n\\r\\n    function onlyOwner() internal view {\\r\\n        require(msg.sender == owner, 'owner');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates pot contract Address\\r\\n     */\\r\\n    function setPotAddress(address addr) external {\\r\\n        onlyOwner();\\r\\n        potAddress = addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets token is stable or not\\r\\n     */\\r\\n    function setTokenStable(address tokenAddr, bool _isStable) external {\\r\\n        onlyOwner();\\r\\n        isStable[tokenAddr] = _isStable;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set how much link token will be consumed per bet\\r\\n     */\\r\\n    function setLinkPerBet(uint256 value) external {\\r\\n        onlyOwner();\\r\\n        linkPerBet = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set outcome infos\\r\\n     */\\r\\n    function setOutcomeInfos(OutcomeInfo[] memory _infos) public {\\r\\n        onlyOwner();\\r\\n        uint256 max = 0;\\r\\n        uint256 maxLimit = 0;\\r\\n\\r\\n        delete outcomeInfos;\\r\\n        for (uint256 i = 0; i < _infos.length; i++) {\\r\\n            if (max < _infos[i].outcome) max = _infos[i].outcome;\\r\\n            if (maxLimit < _infos[i].to) maxLimit = _infos[i].to;\\r\\n            outcomeInfos.push(_infos[i]);\\r\\n        }\\r\\n\\r\\n        maxOutcome = max;\\r\\n        maxNonceLimit = maxLimit;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns list of casinos minted\\r\\n     */\\r\\n    function getCasinoList()\\r\\n        external\\r\\n        view\\r\\n        returns (Casino[] memory casinos, address[] memory owners, uint256[] memory prices)\\r\\n    {\\r\\n        uint256 length = casinoCount;\\r\\n        casinos = new Casino[](length);\\r\\n        owners = new address[](length);\\r\\n        prices = new uint256[](length);\\r\\n        IERC721 nftContract = IERC721(casinoNFTAddress);\\r\\n\\r\\n        for (uint256 i = 1; i <= length; ++i) {\\r\\n            casinos[i - 1] = tokenIdToCasino[i];\\r\\n            owners[i - 1] = nftContract.ownerOf(casinos[i - 1].nftTokenId);\\r\\n            if (casinos[i - 1].tokenAddress == address(0)) {\\r\\n                prices[i - 1] = getBNBPrice();\\r\\n            } else {\\r\\n                prices[i - 1] = _getTokenUsdPrice(casinos[i - 1].tokenAddress);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRoundStatus()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 roundId, BetInfo[] memory betInfos, bool _isVRFPending, uint256 _roundLiveTime)\\r\\n    {\\r\\n        roundId = roundIds;\\r\\n        _isVRFPending = isVRFPending;\\r\\n        _roundLiveTime = roundLiveTime;\\r\\n        betInfos = _getCurrentBets();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds a new casino\\r\\n     */\\r\\n    function addCasino(\\r\\n        uint256 tokenId,\\r\\n        address[] calldata tokenList,\\r\\n        string[] calldata tokenNames,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external {\\r\\n        require(msg.sender == casinoNFTAddress || msg.sender == owner, 'Only casino nft contract can call');\\r\\n\\r\\n        uint256 start = casinoCount;\\r\\n\\r\\n        for (uint256 i = 0; i < tokenList.length; i++) {\\r\\n            Casino storage newCasino = tokenIdToCasino[start + i + 1];\\r\\n            newCasino.tokenAddress = tokenList[i];\\r\\n            newCasino.tokenName = tokenNames[i];\\r\\n            newCasino.initialMaxBet = maxBet;\\r\\n            newCasino.initialMinBet = minBet;\\r\\n            newCasino.maxBet = maxBet;\\r\\n            newCasino.minBet = minBet;\\r\\n            newCasino.fee = fee;\\r\\n            newCasino.liquidity = 0;\\r\\n            newCasino.nftTokenId = tokenId;\\r\\n            newCasino.roundLimit = 100;\\r\\n            newCasino.roundLiquidity = 0;\\r\\n        }\\r\\n\\r\\n        casinoCount += tokenList.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set max bet limit for casino\\r\\n     */\\r\\n    function setMaxBet(uint256 tokenId, uint256 newMaxBet) external {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        onlyCasinoOwner(casinoInfo.nftTokenId);\\r\\n        require(newMaxBet <= casinoInfo.initialMaxBet, \\\"Can't exceed initial max bet\\\");\\r\\n        require(newMaxBet >= casinoInfo.minBet, \\\"Can't exceed initial max bet\\\");\\r\\n\\r\\n        casinoInfo.maxBet = newMaxBet;\\r\\n        emit UpdatedMaxBet(tokenId, msg.sender, newMaxBet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev set min bet limit for casino\\r\\n     */\\r\\n    function setMinBet(uint256 tokenId, uint256 newMinBet) external {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        onlyCasinoOwner(casinoInfo.nftTokenId);\\r\\n\\r\\n        require(newMinBet <= casinoInfo.maxBet, 'min >= max');\\r\\n        require(newMinBet > casinoInfo.initialMinBet, \\\"Can't be lower than initial min bet\\\");\\r\\n\\r\\n        casinoInfo.minBet = newMinBet;\\r\\n        emit UpdatedMinBet(tokenId, msg.sender, newMinBet);\\r\\n    }\\r\\n\\r\\n    function _getCurrentBets() internal view returns (BetInfo[] memory) {\\r\\n        BetInfo[] memory infos;\\r\\n        if (currentBetCount == 0) return infos;\\r\\n        infos = new BetInfo[](currentBetCount);\\r\\n\\r\\n        for (uint256 i = 0; i < currentBetCount; ++i) {\\r\\n            infos[i] = currentBets[i];\\r\\n        }\\r\\n        return infos;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev request random number for calculating winner\\r\\n     */\\r\\n    function _requestVRF() internal {\\r\\n        IVRFv2Consumer vrfConsumer = IVRFv2Consumer(consumerAddress);\\r\\n        uint256 _requestId = vrfConsumer.requestRandomWords();\\r\\n        requestId = _requestId;\\r\\n        isVRFPending = true;\\r\\n        emit VRFRequested();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev request nonce if round is finished, start round if the first player has entered\\r\\n     */\\r\\n    function _updateRoundStatus() internal {\\r\\n        if (!isVRFPending && roundLiveTime != 0 && block.timestamp > roundLiveTime + 120) {\\r\\n            _requestVRF();\\r\\n        }\\r\\n        if (currentBetCount == 1) {\\r\\n            roundLiveTime = block.timestamp;\\r\\n            roundIds++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev save user bet info to `currentBets`\\r\\n     */\\r\\n    function _saveUserBetInfo(uint256 tokenId, uint256 amount, uint256 tokenPrice) internal {\\r\\n        uint256 count = currentBetCount;\\r\\n\\r\\n        if (currentBets.length == count) {\\r\\n            currentBets.push();\\r\\n        }\\r\\n\\r\\n        BetInfo storage info = currentBets[count];\\r\\n        info.tokenId = tokenId;\\r\\n        info.player = msg.sender;\\r\\n        info.tokenPrice = tokenPrice;\\r\\n        info.amount = amount;\\r\\n\\r\\n        ++currentBetCount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize bet and request nonce to VRF\\r\\n     *\\r\\n     * NOTE this function only accepts erc20 tokens\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     * @param amount token amount\\r\\n     */\\r\\n    function initializeTokenBet(uint256 tokenId, uint256 amount) external nonReentrant {\\r\\n        require(!isVRFPending, 'VRF Pending');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        address tokenAddress = casinoInfo.tokenAddress;\\r\\n        uint256 liquidity = casinoInfo.liquidity;\\r\\n        uint256 roundLiquidity = casinoInfo.roundLiquidity;\\r\\n        require(tokenAddress != address(0), \\\"This casino doesn't support tokens\\\");\\r\\n\\r\\n        IPRC20 token = IPRC20(tokenAddress);\\r\\n        IPRC20 busdToken = IPRC20(busdAddr);\\r\\n        uint256 approvedAmount = token.allowance(msg.sender, address(this));\\r\\n        uint256 maxReward = amount * maxOutcome;\\r\\n        uint256 tokenPrice = isStable[tokenAddress] ? 10 ** 18 : _getTokenUsdPrice(tokenAddress);\\r\\n        uint256 totalUSDValue = (amount * tokenPrice) / 10 ** token.decimals();\\r\\n\\r\\n        require(token.balanceOf(msg.sender) >= amount, 'Not enough balance');\\r\\n        require(amount <= approvedAmount, 'Not enough allowance');\\r\\n        require(maxReward <= roundLiquidity + amount, 'Not enough liquidity');\\r\\n        require(totalUSDValue <= casinoInfo.maxBet * 10 ** busdToken.decimals(), \\\"Can't exceed max bet limit\\\");\\r\\n        require(totalUSDValue >= casinoInfo.minBet * 10 ** busdToken.decimals(), \\\"Can't be lower than min bet limit\\\");\\r\\n\\r\\n        token.transferFrom(msg.sender, address(this), amount);\\r\\n        liquidity -= (maxReward - amount);\\r\\n        roundLiquidity -= (maxReward - amount);\\r\\n        casinoInfo.liquidity = liquidity;\\r\\n        casinoInfo.roundLiquidity = roundLiquidity;\\r\\n        casinoInfo.locked += maxReward;\\r\\n\\r\\n        _saveUserBetInfo(tokenId, amount, tokenPrice);\\r\\n        _updateRoundStatus();\\r\\n\\r\\n        emit InitializedBet(roundIds, tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, liquidity, roundLiquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev initialize bet and request nonce to VRF\\r\\n     *\\r\\n     * NOTE this function only accepts bnb\\r\\n     * @param tokenId tokenId of the Casino\\r\\n     * @param amount eth amount\\r\\n     */\\r\\n    function initializeEthBet(uint256 tokenId, uint256 amount) external payable {\\r\\n        require(!isVRFPending, 'VRF Pending');\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        uint256 liquidity = casinoInfo.liquidity;\\r\\n        uint256 roundLiquidity = casinoInfo.roundLiquidity;\\r\\n        require(casinoInfo.tokenAddress == address(0), 'This casino only support bnb');\\r\\n\\r\\n        IPRC20 busdToken = IPRC20(busdAddr);\\r\\n        uint256 maxReward = amount * maxOutcome;\\r\\n        uint256 bnbPrice = getBNBPrice();\\r\\n        uint256 totalUSDValue = (bnbPrice * amount) / 10 ** 18;\\r\\n\\r\\n        require(msg.value == amount, 'Not correct bet amount');\\r\\n        require(maxReward <= roundLiquidity + amount, 'Not enough liquidity');\\r\\n        require(totalUSDValue <= casinoInfo.maxBet * 10 ** busdToken.decimals(), \\\"Can't exceed max bet limit\\\");\\r\\n        require(totalUSDValue >= casinoInfo.minBet * 10 ** busdToken.decimals(), \\\"Can't be lower than min bet limit\\\");\\r\\n\\r\\n        liquidity -= (maxReward - amount);\\r\\n        roundLiquidity -= (maxReward - amount);\\r\\n        casinoInfo.liquidity = liquidity;\\r\\n        casinoInfo.roundLiquidity = roundLiquidity;\\r\\n        casinoInfo.locked += maxReward;\\r\\n\\r\\n        _saveUserBetInfo(tokenId, amount, bnbPrice);\\r\\n        _updateRoundStatus();\\r\\n\\r\\n        emit InitializedBet(roundIds, tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(tokenId, msg.sender, liquidity, roundLiquidity, casinoInfo.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev request nonce when round time is over\\r\\n     */\\r\\n    function requestNonce() external {\\r\\n        require(!isVRFPending && roundLiveTime != 0 && block.timestamp > roundLiveTime + 120, 'Round not ended');\\r\\n        _requestVRF();\\r\\n    }\\r\\n\\r\\n    function isVRFFulfilled() public view returns (bool) {\\r\\n        (bool fulfilled, uint256[] memory nonces) = IVRFv2Consumer(consumerAddress).getRequestStatus(requestId);\\r\\n        return fulfilled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns outcome X from the given nonce\\r\\n     */\\r\\n    function _spinWheel(uint256 nonce) private view returns (uint256 outcome) {\\r\\n        uint256 length = outcomeInfos.length;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (nonce >= outcomeInfos[i].from && nonce <= outcomeInfos[i].to) {\\r\\n                return outcomeInfos[i].outcome;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev retrieve nonce and spin the wheel, return reward if user wins\\r\\n     *\\r\\n     */\\r\\n    function finishRound() external nonReentrant {\\r\\n        require(isVRFPending == true, 'VRF not requested');\\r\\n\\r\\n        (bool fulfilled, uint256[] memory nonces) = IVRFv2Consumer(consumerAddress).getRequestStatus(requestId);\\r\\n        require(fulfilled == true, 'not yet fulfilled');\\r\\n\\r\\n        uint256 nonce = nonces[0] % (maxNonceLimit + 1);\\r\\n        uint256 outcome = _spinWheel(nonce);\\r\\n        uint256 length = currentBetCount;\\r\\n        uint256 linkPerRound = linkPerBet;\\r\\n        uint256 i;\\r\\n\\r\\n        for (i = 0; i < length; ++i) {\\r\\n            BetInfo memory info = currentBets[i];\\r\\n            linkSpent[info.tokenId] += (linkPerRound / length);\\r\\n            _finishUserBet(info, outcome);\\r\\n        }\\r\\n\\r\\n        isVRFPending = false;\\r\\n        delete roundLiveTime;\\r\\n        delete currentBetCount;\\r\\n        emit RoundFinished(roundIds, nonce, outcome);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev finish individual user's pending bet based on the nonce retreived\\r\\n     */\\r\\n    function _finishUserBet(BetInfo memory info, uint256 outcome) internal {\\r\\n        Casino storage casinoInfo = tokenIdToCasino[info.tokenId];\\r\\n        uint256 decimal = casinoInfo.tokenAddress == address(0) ? 18 : IPRC20(casinoInfo.tokenAddress).decimals();\\r\\n        uint256 totalReward = info.amount * outcome;\\r\\n        uint256 maxReward = info.amount * maxOutcome;\\r\\n        uint256 totalUSDValue = (info.amount * info.tokenPrice) / 10 ** decimal;\\r\\n        uint256 totalRewardUSD = (totalReward * info.tokenPrice) / 10 ** decimal;\\r\\n\\r\\n        betIds++;\\r\\n        if (totalReward > 0) {\\r\\n            if (casinoInfo.tokenAddress != address(0)) {\\r\\n                IPRC20(casinoInfo.tokenAddress).transfer(info.player, totalReward);\\r\\n            } else {\\r\\n                bool sent = payable(info.player).send(totalReward);\\r\\n                require(sent, 'send fail');\\r\\n            }\\r\\n        }\\r\\n        casinoInfo.liquidity += maxReward - totalReward;\\r\\n        casinoInfo.roundLiquidity += maxReward - totalReward;\\r\\n        casinoInfo.locked -= maxReward;\\r\\n        casinoInfo.profit = casinoInfo.profit + int256(info.amount) - int256(totalReward);\\r\\n\\r\\n        emit FinishedBet(\\r\\n            info.tokenId,\\r\\n            betIds,\\r\\n            roundIds,\\r\\n            info.player,\\r\\n            outcome,\\r\\n            info.amount,\\r\\n            totalReward,\\r\\n            totalUSDValue,\\r\\n            totalRewardUSD,\\r\\n            maxReward\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds liquidity to the casino pool\\r\\n     * NOTE this is only for casinos that uses tokens\\r\\n     */\\r\\n    function addLiquidityWithTokens(uint256 tokenId, uint256 amount) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        require(casinoInfo.tokenAddress != address(0), \\\"This casino doesn't support tokens\\\");\\r\\n\\r\\n        IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        casinoInfo.liquidity += amount;\\r\\n        casinoInfo.roundLiquidity += (amount * casinoInfo.roundLimit) / 100;\\r\\n        emit AddedLiquidity(tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(\\r\\n            tokenId,\\r\\n            msg.sender,\\r\\n            casinoInfo.liquidity,\\r\\n            casinoInfo.roundLiquidity,\\r\\n            casinoInfo.locked,\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev adds liquidity to the casino pool\\r\\n     * NOTE this is only for casinos that uses bnb\\r\\n     */\\r\\n    function addLiquidityWithEth(uint256 tokenId) external payable {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n\\r\\n        require(casinoInfo.tokenAddress == address(0), \\\"This casino doesn't supports bnb\\\");\\r\\n        casinoInfo.liquidity += msg.value;\\r\\n        casinoInfo.roundLiquidity += (msg.value * casinoInfo.roundLimit) / 100;\\r\\n        emit AddedLiquidity(tokenId, msg.sender, msg.value);\\r\\n        emit LiquidityChanged(\\r\\n            tokenId,\\r\\n            msg.sender,\\r\\n            casinoInfo.liquidity,\\r\\n            casinoInfo.roundLiquidity,\\r\\n            casinoInfo.locked,\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev removes liquidity from the casino pool\\r\\n     */\\r\\n    function removeLiquidity(uint256 tokenId, uint256 amount) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        uint256 liquidity = casinoInfo.liquidity;\\r\\n\\r\\n        require(int256(liquidity - amount) >= casinoInfo.profit, 'Cannot withdraw profit before it is fee taken');\\r\\n        require(liquidity >= amount, 'Not enough liquidity');\\r\\n\\r\\n        unchecked {\\r\\n            casinoInfo.liquidity -= amount;\\r\\n            casinoInfo.roundLiquidity -= (amount * casinoInfo.roundLimit) / 100;\\r\\n        }\\r\\n\\r\\n        if (casinoInfo.tokenAddress != address(0)) {\\r\\n            IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n            token.safeTransfer(msg.sender, amount);\\r\\n        } else {\\r\\n            bool sent = payable(msg.sender).send(amount);\\r\\n            require(sent, 'Failed Transfer');\\r\\n        }\\r\\n        emit RemovedLiquidity(tokenId, msg.sender, amount);\\r\\n        emit LiquidityChanged(\\r\\n            tokenId,\\r\\n            msg.sender,\\r\\n            casinoInfo.liquidity,\\r\\n            casinoInfo.roundLiquidity,\\r\\n            casinoInfo.locked,\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function updateRoundLimit(uint256 tokenId, uint256 value) external {\\r\\n        onlyCasinoOwner(tokenId);\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        Casino memory info = tokenIdToCasino[tokenId];\\r\\n        unchecked {\\r\\n            if (value > info.roundLimit) {\\r\\n                casinoInfo.roundLiquidity += (info.liquidity * (value - info.roundLimit)) / 100;\\r\\n            } else {\\r\\n                casinoInfo.roundLiquidity -= (info.liquidity * (info.roundLimit - value)) / 100;\\r\\n            }\\r\\n        }\\r\\n        casinoInfo.roundLimit = value;\\r\\n        emit LiquidityChanged(tokenId, msg.sender, info.liquidity, casinoInfo.roundLiquidity, info.locked, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev update casino's current profit and liquidity.\\r\\n     */\\r\\n    function _updateProfitInfo(uint256 tokenId, uint256 fee, uint256 calculatedProfit) internal {\\r\\n        if (fee == 0) return;\\r\\n        Casino storage casinoInfo = tokenIdToCasino[tokenId];\\r\\n        casinoInfo.liquidity -= fee;\\r\\n        casinoInfo.profit -= int256(calculatedProfit);\\r\\n        casinoInfo.lastSwapTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev update casino's link consumption info\\r\\n     */\\r\\n    function _updateLinkConsumptionInfo(uint256 tokenId, uint256 tokenAmount) internal {\\r\\n        uint256 linkOut = getLinkAmountForToken(tokenIdToCasino[tokenId].tokenAddress, tokenAmount);\\r\\n        if (linkOut >= linkSpent[tokenId]) linkSpent[tokenId] = 0;\\r\\n        else linkSpent[tokenId] -= linkOut;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get usd price of a token by usdt\\r\\n     */\\r\\n    function _getTokenUsdPrice(address tokenAddress) internal view returns (uint256) {\\r\\n        if (isStable[tokenAddress]) return 10 ** 18;\\r\\n\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        IPRC20 token = IPRC20(tokenAddress);\\r\\n\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = wbnbAddr;\\r\\n        path[2] = busdAddr;\\r\\n        uint256 usdValue = router.getAmountsOut(10 ** token.decimals(), path)[2];\\r\\n\\r\\n        return usdValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current pulse price in comparison with BNB and USDT\\r\\n     */\\r\\n    function getBNBPrice() public view returns (uint256 price) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = wbnbAddr;\\r\\n        path[1] = busdAddr;\\r\\n        uint256[] memory amounts = router.getAmountsOut(10 ** 18, path);\\r\\n        return amounts[1];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns token amount needed for `linkAmount` when swapping given token into link\\r\\n     */\\r\\n    function getTokenAmountForLink(address tokenAddr, uint256 linkAmount) public view returns (uint256) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path;\\r\\n        if (tokenAddr == address(0) || tokenAddr == wbnbAddr) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = linkTokenAddr;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = tokenAddr;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = linkTokenAddr;\\r\\n        }\\r\\n\\r\\n        return router.getAmountsIn(linkAmount, path)[0];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns link token amount out when swapping given token into link\\r\\n     */\\r\\n    function getLinkAmountForToken(address tokenAddr, uint256 tokenAmount) public view returns (uint256) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path;\\r\\n        bool isBNB = tokenAddr == address(0) || tokenAddr == wbnbAddr;\\r\\n        if (isBNB) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = linkTokenAddr;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = tokenAddr;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = linkTokenAddr;\\r\\n        }\\r\\n\\r\\n        return router.getAmountsOut(tokenAmount, path)[isBNB ? 1 : 2];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev resets round and return all money back to players\\r\\n     */\\r\\n    function resetRound() external nonReentrant {\\r\\n        onlyOwner();\\r\\n        require(roundLiveTime != 0, 'empty');\\r\\n\\r\\n        uint256 length = currentBetCount;\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            BetInfo memory info = currentBets[i];\\r\\n            Casino storage casinoInfo = tokenIdToCasino[info.tokenId];\\r\\n            uint256 maximumReward = info.amount * maxOutcome;\\r\\n\\r\\n            casinoInfo.locked -= maximumReward;\\r\\n            casinoInfo.liquidity += (maximumReward - info.amount);\\r\\n            casinoInfo.roundLiquidity = (casinoInfo.liquidity * casinoInfo.roundLimit) / 100;\\r\\n\\r\\n            // Transfer money back\\r\\n            address tokenAddress = casinoInfo.tokenAddress;\\r\\n            if (tokenAddress != address(0)) {\\r\\n                IPRC20(tokenAddress).transfer(info.player, info.amount);\\r\\n            } else {\\r\\n                bool sent = payable(info.player).send(info.amount);\\r\\n                require(sent, 'send fail');\\r\\n            }\\r\\n        }\\r\\n        delete isVRFPending;\\r\\n        delete currentBetCount;\\r\\n        delete roundLiveTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev swaps profit fees of casinos into BNBP\\r\\n     */\\r\\n    function swapProfitFees() external {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        uint256 totalBNBForGame;\\r\\n        uint256 totalBNBForLink;\\r\\n        uint256 length = casinoCount;\\r\\n        uint256 BNBPPool = 0;\\r\\n\\r\\n        // Swap each token to BNB\\r\\n        for (uint256 i = 1; i <= length; ++i) {\\r\\n            Casino memory casinoInfo = tokenIdToCasino[i];\\r\\n            IERC20 token = IERC20(casinoInfo.tokenAddress);\\r\\n\\r\\n            if (casinoInfo.liquidity == 0) continue;\\r\\n\\r\\n            uint256 availableProfit = casinoInfo.profit < 0 ? 0 : uint256(casinoInfo.profit);\\r\\n            if (casinoInfo.liquidity < availableProfit) {\\r\\n                availableProfit = casinoInfo.liquidity;\\r\\n            }\\r\\n\\r\\n            uint256 gameFee = (availableProfit * casinoInfo.fee) / 100;\\r\\n            uint256 amountForLinkFee = getTokenAmountForLink(casinoInfo.tokenAddress, linkSpent[i]);\\r\\n            _updateProfitInfo(i, uint256(gameFee), availableProfit);\\r\\n            casinoInfo.liquidity = tokenIdToCasino[i].liquidity;\\r\\n\\r\\n            // If fee from the profit is not enought for link, then use liquidity\\r\\n            if (gameFee < amountForLinkFee) {\\r\\n                if (casinoInfo.liquidity < (amountForLinkFee - gameFee)) {\\r\\n                    amountForLinkFee = gameFee + casinoInfo.liquidity;\\r\\n                    tokenIdToCasino[i].liquidity = 0;\\r\\n                } else {\\r\\n                    tokenIdToCasino[i].liquidity -= (amountForLinkFee - gameFee);\\r\\n                }\\r\\n                gameFee = 0;\\r\\n            } else {\\r\\n                gameFee -= amountForLinkFee;\\r\\n            }\\r\\n\\r\\n            // Update Link consumption info\\r\\n            _updateLinkConsumptionInfo(i, amountForLinkFee);\\r\\n\\r\\n            if (casinoInfo.tokenAddress == address(0)) {\\r\\n                totalBNBForGame += gameFee;\\r\\n                totalBNBForLink += amountForLinkFee;\\r\\n                continue;\\r\\n            }\\r\\n            if (casinoInfo.tokenAddress == BNBPAddress) {\\r\\n                BNBPPool += gameFee;\\r\\n                gameFee = 0;\\r\\n            }\\r\\n\\r\\n            path[0] = casinoInfo.tokenAddress;\\r\\n            path[1] = wbnbAddr;\\r\\n\\r\\n            if (gameFee + amountForLinkFee == 0) {\\r\\n                continue;\\r\\n            }\\r\\n            token.approve(address(router), gameFee + amountForLinkFee);\\r\\n            uint256[] memory swappedAmounts = router.swapExactTokensForETH(\\r\\n                gameFee + amountForLinkFee,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n            totalBNBForGame += (swappedAmounts[1] * gameFee) / (gameFee + amountForLinkFee);\\r\\n            totalBNBForLink += (swappedAmounts[1] * amountForLinkFee) / (gameFee + amountForLinkFee);\\r\\n        }\\r\\n\\r\\n        path[0] = wbnbAddr;\\r\\n        // Convert to LINK\\r\\n        if (totalBNBForLink > 0) {\\r\\n            path[1] = linkTokenAddr;\\r\\n\\r\\n            // Swap BNB into Link Token\\r\\n            uint256 linkAmount = router.swapExactETHForTokens{ value: totalBNBForLink }(\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            )[1];\\r\\n\\r\\n            // Convert Link to ERC677 Link\\r\\n            IERC20(linkTokenAddr).approve(pegSwapAddr, linkAmount);\\r\\n            PegSwap(pegSwapAddr).swap(linkAmount, linkTokenAddr, link677TokenAddr);\\r\\n\\r\\n            // Fund VRF subscription account\\r\\n            LinkTokenInterface(link677TokenAddr).transferAndCall(\\r\\n                coordinatorAddr,\\r\\n                linkAmount,\\r\\n                abi.encode(subscriptionId)\\r\\n            );\\r\\n            emit SuppliedLink(linkAmount);\\r\\n        }\\r\\n\\r\\n        // Swap the rest of BNB to BNBP\\r\\n        if (totalBNBForGame > 0) {\\r\\n            path[1] = BNBPAddress;\\r\\n            BNBPPool += router.swapExactETHForTokens{ value: totalBNBForGame }(0, path, address(this), block.timestamp)[\\r\\n                1\\r\\n            ];\\r\\n        }\\r\\n\\r\\n        if (BNBPPool > 0) {\\r\\n            // add BNBP to tokenomics pool\\r\\n            IERC20(BNBPAddress).approve(potAddress, BNBPPool);\\r\\n            IPotLottery(potAddress).addAdminTokenValue(BNBPPool);\\r\\n\\r\\n            emit SuppliedBNBP(BNBPPool);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceCall/PriceCallTestPhase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\ncontract PriceCallTestPhase is OwnableUpgradeable {\\r\\n    struct PriceToken {\\r\\n        string tokenName;\\r\\n        address priceFeed;\\r\\n        uint256 digit;\\r\\n    }\\r\\n\\r\\n    struct BetToken {\\r\\n        string tokenName;\\r\\n        address tokenAddress;\\r\\n        bool isStable;\\r\\n    }\\r\\n\\r\\n    struct Bet {\\r\\n        uint256 betId;\\r\\n        uint256 betTokenId;\\r\\n        address player;\\r\\n        uint256 usdValue;\\r\\n    }\\r\\n\\r\\n    struct StableCoinAmount {\\r\\n        address tokenAddress;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    enum RoundStatus {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        CANCELED,\\r\\n        EXPIRED,\\r\\n        FINISHED\\r\\n    }\\r\\n\\r\\n    struct Round {\\r\\n        uint256 roundId;\\r\\n        uint256 priceTokenId;\\r\\n        uint256 operator; // 0: >=, 1: <=\\r\\n        uint256 maxUSDPerPlayer;\\r\\n        uint256 minUSDPerPlayer;\\r\\n        uint256 pricePoint;\\r\\n        uint256 currentTotalUSD;\\r\\n        uint256 roundMaximumValue;\\r\\n        uint256 recordedPrice;\\r\\n        address creator;\\r\\n        bool isCreatorWinner;\\r\\n        RoundStatus status;\\r\\n        Bet[] bets;\\r\\n        StableCoinAmount[] stableCoinAmounts;\\r\\n    }\\r\\n\\r\\n    struct RoundTimeInfo {\\r\\n        uint256 createdTime;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n        uint256 expireTime;\\r\\n    }\\r\\n\\r\\n    struct RoundOption {\\r\\n        bool onlyOneTaker;\\r\\n        bool isPrivate;\\r\\n        bool startEarlyEnabled;\\r\\n    }\\r\\n\\r\\n    PriceToken[] public priceTokens;\\r\\n    BetToken[] public betTokens;\\r\\n    Round[] public rounds;\\r\\n    RoundOption[] public roundOptions;\\r\\n    RoundTimeInfo[] public roundTimeInfos;\\r\\n\\r\\n    mapping(address => bool) private isStable;\\r\\n\\r\\n    uint256 public roundIds;\\r\\n    uint256 public fee;\\r\\n\\r\\n    address public BNBPAddr;\\r\\n    address public potContractAddr;\\r\\n    address internal wbnbAddr; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address internal pancakeRouterAddr; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    address public usdtAddr; // testnet: 0x4608Ea31fA832ce7DCF56d78b5434b49830E91B1, mainnet: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\\r\\n    address public botAddress;\\r\\n    bool public isBotEnabled;\\r\\n    mapping(address => uint256) public userLastCreatedRoundId;\\r\\n    uint256 public botFee;\\r\\n\\r\\n    event RoundCreated(\\r\\n        uint256 roundId,\\r\\n        uint256 priceTokenId,\\r\\n        uint256 operator,\\r\\n        uint256 maxUSDPerPlayer,\\r\\n        uint256 minUSDPerPlayer,\\r\\n        uint256 creatorUSDValue,\\r\\n        uint256 createdTime,\\r\\n        uint256 endTime,\\r\\n        uint256 expireTime,\\r\\n        uint256 pricePoint,\\r\\n        uint256 roundMaximumValue,\\r\\n        address creator,\\r\\n        bool isPrivate,\\r\\n        bool onlyOneTaker\\r\\n    );\\r\\n    event BetPlaced(uint256 roundId, uint256 betId, address player, uint256 usdValue);\\r\\n    event RoundStarted(uint256 roundId, uint256 roundMaximumValue, uint256 creatorUSDValue, uint256 timestamp);\\r\\n    event RoundCanceled(uint256 roundId, uint256 feeAmount, uint256 creatorReturnedAmount);\\r\\n    event RoundFinished(uint256 roundId, uint256 recordedPrice, bool isCreatorWinner, uint256 feeAmount);\\r\\n    event PlayerWon(uint256 roundId, uint256 betId, address player, uint256 amount);\\r\\n\\r\\n    modifier onlyRoundCreator(uint256 roundId) {\\r\\n        require(rounds[roundId].creator == msg.sender, 'only creator');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        address _BNBPAddr,\\r\\n        address _potContractAddr,\\r\\n        address _usdtAddr,\\r\\n        address _routerAddr,\\r\\n        PriceToken[] calldata _priceTokens\\r\\n    ) external initializer {\\r\\n        BNBPAddr = _BNBPAddr;\\r\\n        potContractAddr = _potContractAddr;\\r\\n        usdtAddr = _usdtAddr;\\r\\n        pancakeRouterAddr = _routerAddr;\\r\\n        wbnbAddr = IPancakeRouter02(_routerAddr).WETH();\\r\\n\\r\\n        uint256 i;\\r\\n        for (i = 0; i < _priceTokens.length; i++) {\\r\\n            priceTokens.push(_priceTokens[i]);\\r\\n        }\\r\\n        fee = 0;\\r\\n        botFee = 5;\\r\\n        isBotEnabled = true;\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function addPriceToken(string memory tokenName, address priceFeed, uint256 digit) external onlyOwner {\\r\\n        priceTokens.push(PriceToken(tokenName, priceFeed, digit));\\r\\n    }\\r\\n\\r\\n    function addBetToken(string memory tokenName, address tokenAddress, bool stable) external onlyOwner {\\r\\n        betTokens.push(BetToken(tokenName, tokenAddress, stable));\\r\\n        if (stable) isStable[tokenAddress] = true;\\r\\n    }\\r\\n\\r\\n    function setBNBPAddress(address addr) external onlyOwner {\\r\\n        BNBPAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setPotContractAddr(address addr) external onlyOwner {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setBotAddress(address addr) external onlyOwner {\\r\\n        botAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setBotEnabled(bool value) external onlyOwner {\\r\\n        isBotEnabled = value;\\r\\n    }\\r\\n\\r\\n    function setBotFee(uint256 value) external onlyOwner {\\r\\n        botFee = value;\\r\\n    }\\r\\n\\r\\n    function setFee(uint256 value) external onlyOwner {\\r\\n        fee = value;\\r\\n    }\\r\\n\\r\\n    function createRound(\\r\\n        uint256 priceTokenId,\\r\\n        uint256 endTime,\\r\\n        uint256 expireTime,\\r\\n        uint256 pricePoint,\\r\\n        uint256 operator,\\r\\n        uint256 maxUSDPerPlayer,\\r\\n        uint256 minUSDPerPlayer,\\r\\n        uint256 roundMaximumValue,\\r\\n        bool onlyOneTaker,\\r\\n        bool isPrivate,\\r\\n        bool startEarlyEnabled,\\r\\n        Bet calldata initialBet\\r\\n    ) external payable {\\r\\n        require(priceTokens.length > priceTokenId, 'not valid price token');\\r\\n        require(betTokens.length > initialBet.betTokenId, 'not valid bet token');\\r\\n        require(expireTime == 0 || (expireTime > block.timestamp && expireTime < endTime), 'expire time not valid');\\r\\n        require(roundMaximumValue > initialBet.usdValue, 'creator exceeds maximum');\\r\\n        require(operator < 2, 'invalid operator');\\r\\n\\r\\n        rounds.push();\\r\\n        Round storage newRound = rounds[roundIds];\\r\\n        newRound.roundId = roundIds;\\r\\n        newRound.creator = msg.sender;\\r\\n        newRound.priceTokenId = priceTokenId;\\r\\n        newRound.pricePoint = pricePoint;\\r\\n        newRound.operator = operator;\\r\\n        newRound.maxUSDPerPlayer = maxUSDPerPlayer;\\r\\n        newRound.minUSDPerPlayer = minUSDPerPlayer;\\r\\n        newRound.roundMaximumValue = roundMaximumValue;\\r\\n\\r\\n        roundTimeInfos.push();\\r\\n        RoundTimeInfo storage newTimeInfo = roundTimeInfos[roundIds];\\r\\n        newTimeInfo.createdTime = block.timestamp;\\r\\n        newTimeInfo.endTime = endTime;\\r\\n        newTimeInfo.expireTime = expireTime;\\r\\n\\r\\n        roundOptions.push();\\r\\n        RoundOption storage newRoundOption = roundOptions[roundIds];\\r\\n        newRoundOption.onlyOneTaker = onlyOneTaker;\\r\\n        newRoundOption.isPrivate = isPrivate;\\r\\n        newRoundOption.startEarlyEnabled = startEarlyEnabled;\\r\\n\\r\\n        emit RoundCreated(\\r\\n            roundIds,\\r\\n            priceTokenId,\\r\\n            operator,\\r\\n            maxUSDPerPlayer,\\r\\n            minUSDPerPlayer,\\r\\n            initialBet.usdValue,\\r\\n            block.timestamp,\\r\\n            endTime,\\r\\n            expireTime,\\r\\n            pricePoint,\\r\\n            roundMaximumValue,\\r\\n            msg.sender,\\r\\n            isPrivate,\\r\\n            onlyOneTaker\\r\\n        );\\r\\n        _swapBetTokenToStableCoin(roundIds, initialBet);\\r\\n        _addBet(roundIds, initialBet);\\r\\n\\r\\n        userLastCreatedRoundId[msg.sender] = roundIds;\\r\\n        roundIds++;\\r\\n    }\\r\\n\\r\\n    function placeBet(uint256 roundId, Bet calldata bet) external payable {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundOption storage roundOption = roundOptions[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n\\r\\n        require(roundId < roundIds, 'not valid round');\\r\\n        require(msg.sender != round.creator, 'creator');\\r\\n        require(round.status == RoundStatus.WAITING, 'cannot bet');\\r\\n        require(\\r\\n            (roundTimeInfo.expireTime == 0 && roundTimeInfo.endTime > block.timestamp) ||\\r\\n                roundTimeInfo.expireTime > block.timestamp,\\r\\n            'expired'\\r\\n        );\\r\\n        require(betTokens.length > bet.betTokenId, 'invalid bet token');\\r\\n        require(round.maxUSDPerPlayer == 0 || round.maxUSDPerPlayer >= bet.usdValue, 'max limit exceeded');\\r\\n        require(round.minUSDPerPlayer == 0 || round.minUSDPerPlayer <= bet.usdValue, 'min usd limit');\\r\\n        require(round.currentTotalUSD + bet.usdValue <= round.roundMaximumValue, 'exceeds maximum value');\\r\\n        require(\\r\\n            !roundOption.onlyOneTaker || bet.usdValue == round.roundMaximumValue - round.currentTotalUSD,\\r\\n            'only one taker'\\r\\n        );\\r\\n\\r\\n        _swapBetTokenToStableCoin(roundId, bet);\\r\\n        _addBet(roundId, bet);\\r\\n\\r\\n        if (rounds[roundId].currentTotalUSD == round.roundMaximumValue) {\\r\\n            round.status = RoundStatus.STARTED;\\r\\n            roundTimeInfo.startTime = block.timestamp;\\r\\n            emit RoundStarted(roundId, round.roundMaximumValue, round.bets[0].usdValue, block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function startEarly(uint256 roundId) external onlyRoundCreator(roundId) {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundOption storage roundOption = roundOptions[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n\\r\\n        require(roundId < rounds.length, 'not valid round');\\r\\n        require(round.status == RoundStatus.WAITING, 'cannot start');\\r\\n        require(\\r\\n            (roundTimeInfo.expireTime == 0 && roundTimeInfo.endTime > block.timestamp) ||\\r\\n                block.timestamp < roundTimeInfo.expireTime,\\r\\n            'expired'\\r\\n        );\\r\\n        require(roundOption.startEarlyEnabled, 'start early not enabled');\\r\\n        require(round.bets.length >= 2, 'not enough players');\\r\\n\\r\\n        uint256 originalCreatorBet = round.bets[0].usdValue;\\r\\n        uint256 adjustedCreatorBet = (originalCreatorBet * (round.currentTotalUSD - originalCreatorBet)) /\\r\\n            (round.roundMaximumValue - originalCreatorBet);\\r\\n        uint256 withdrawAmount = originalCreatorBet - adjustedCreatorBet;\\r\\n        uint256 length = round.stableCoinAmounts.length;\\r\\n\\r\\n        // Send remaining money back to creator\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (round.stableCoinAmounts[i].amount > withdrawAmount) {\\r\\n                _transfer(msg.sender, round.stableCoinAmounts[i].tokenAddress, withdrawAmount);\\r\\n                round.stableCoinAmounts[i].amount -= withdrawAmount;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        round.currentTotalUSD -= withdrawAmount;\\r\\n        round.roundMaximumValue = round.currentTotalUSD;\\r\\n        round.bets[0].usdValue = adjustedCreatorBet;\\r\\n        round.status = RoundStatus.STARTED;\\r\\n        roundTimeInfo.startTime = block.timestamp;\\r\\n        emit RoundStarted(roundId, round.roundMaximumValue, adjustedCreatorBet, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function cancelRound(uint256 roundId) external onlyRoundCreator(roundId) {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n        Bet[] memory bets = round.bets;\\r\\n        Bet memory creatorBet = round.bets[0];\\r\\n\\r\\n        require(roundId < roundIds, 'not valid round');\\r\\n        require(round.status == RoundStatus.WAITING, \\\"can't cancel\\\");\\r\\n        bool isExpired = (roundTimeInfo.expireTime == 0 && roundTimeInfo.endTime <= block.timestamp) ||\\r\\n            block.timestamp <= roundTimeInfo.expireTime;\\r\\n\\r\\n        uint256 feeAmount = _getFeeAmount(creatorBet.usdValue);\\r\\n        _takeFee(roundId, feeAmount);\\r\\n        if (isExpired) {\\r\\n            round.status = RoundStatus.EXPIRED;\\r\\n        } else {\\r\\n            round.status = RoundStatus.CANCELED;\\r\\n        }\\r\\n\\r\\n        StableCoinAmount[] memory stableCoinAmounts = round.stableCoinAmounts;\\r\\n\\r\\n        uint256 length = bets.length;\\r\\n        uint256 currentTokenIndex = 0;\\r\\n        uint256 v;\\r\\n\\r\\n        // Send Tokens back to the players\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            v = bets[i].usdValue;\\r\\n            if (i == 0) v -= feeAmount;\\r\\n            do {\\r\\n                if (stableCoinAmounts[currentTokenIndex].amount >= v) {\\r\\n                    _transfer(bets[i].player, stableCoinAmounts[currentTokenIndex].tokenAddress, v);\\r\\n                    stableCoinAmounts[currentTokenIndex].amount -= v;\\r\\n                    v = 0;\\r\\n                } else {\\r\\n                    _transfer(\\r\\n                        bets[i].player,\\r\\n                        stableCoinAmounts[currentTokenIndex].tokenAddress,\\r\\n                        stableCoinAmounts[currentTokenIndex].amount\\r\\n                    );\\r\\n                    v -= stableCoinAmounts[currentTokenIndex].amount;\\r\\n                    stableCoinAmounts[currentTokenIndex].amount = 0;\\r\\n                    currentTokenIndex++;\\r\\n                }\\r\\n            } while (v > 0);\\r\\n        }\\r\\n\\r\\n        emit RoundCanceled(roundId, feeAmount, bets[0].usdValue - feeAmount);\\r\\n    }\\r\\n\\r\\n    function finishRound(uint256 roundId) external {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n\\r\\n        require(round.status == RoundStatus.STARTED, 'cannot finish');\\r\\n        require(roundTimeInfo.endTime < block.timestamp, 'not yet finished');\\r\\n        uint256 currentPrice = getPriceOracle(round.priceTokenId);\\r\\n        uint256 feeAmount = _getFeeAmount(round.currentTotalUSD);\\r\\n        _takeFee(roundId, feeAmount);\\r\\n\\r\\n        StableCoinAmount[] memory stableCoinAmounts = round.stableCoinAmounts;\\r\\n\\r\\n        round.status = RoundStatus.FINISHED;\\r\\n        round.recordedPrice = currentPrice;\\r\\n\\r\\n        // Creator is winner\\r\\n        if (\\r\\n            (round.operator == 0 && currentPrice >= round.pricePoint) ||\\r\\n            ((round.operator == 1 && currentPrice <= round.pricePoint))\\r\\n        ) {\\r\\n            round.isCreatorWinner = true;\\r\\n            uint256 length = stableCoinAmounts.length;\\r\\n            for (uint256 i = 0; i < length; i++) {\\r\\n                _transfer(round.creator, stableCoinAmounts[i].tokenAddress, stableCoinAmounts[i].amount);\\r\\n            }\\r\\n            emit PlayerWon(roundId, 0, round.creator, (feeAmount * 100) / fee - feeAmount);\\r\\n        } else {\\r\\n            // Creator is loser\\r\\n            round.isCreatorWinner = false;\\r\\n            Bet[] memory bets = round.bets;\\r\\n            uint256 length = bets.length;\\r\\n            uint256 total = round.currentTotalUSD - feeAmount; // Total value\\r\\n            uint256 takerTotal = round.currentTotalUSD - bets[0].usdValue; // Takers' total value\\r\\n            uint256 currentTokenIndex = 0;\\r\\n            uint256 v;\\r\\n\\r\\n            // Distribute Rewards to takers\\r\\n            for (uint256 i = 1; i < length; i++) {\\r\\n                v = (bets[i].usdValue * total) / takerTotal;\\r\\n                emit PlayerWon(roundId, i, bets[i].player, v);\\r\\n                do {\\r\\n                    if (stableCoinAmounts[currentTokenIndex].amount >= v) {\\r\\n                        _transfer(bets[i].player, stableCoinAmounts[currentTokenIndex].tokenAddress, v);\\r\\n                        stableCoinAmounts[currentTokenIndex].amount -= v;\\r\\n                        v = 0;\\r\\n                    } else {\\r\\n                        _transfer(\\r\\n                            bets[i].player,\\r\\n                            stableCoinAmounts[currentTokenIndex].tokenAddress,\\r\\n                            stableCoinAmounts[currentTokenIndex].amount\\r\\n                        );\\r\\n                        v -= stableCoinAmounts[currentTokenIndex].amount;\\r\\n                        stableCoinAmounts[currentTokenIndex].amount = 0;\\r\\n                        currentTokenIndex++;\\r\\n                    }\\r\\n                } while (v > 0);\\r\\n            }\\r\\n        }\\r\\n        emit RoundFinished(roundId, currentPrice, round.isCreatorWinner, feeAmount);\\r\\n    }\\r\\n\\r\\n    function _swapBetTokenToStableCoin(uint256 roundId, Bet calldata bet) internal {\\r\\n        address tokenAddress = betTokens[bet.betTokenId].tokenAddress;\\r\\n        if (isStable[tokenAddress]) {\\r\\n            IPRC20(tokenAddress).transferFrom(msg.sender, address(this), bet.usdValue);\\r\\n            _addStableCoinAmountInfo(roundId, tokenAddress, bet.usdValue);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        address[] memory path = _getSwapPath(tokenAddress, usdtAddr);\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        uint256[] memory amounts = router.getAmountsIn(bet.usdValue, path);\\r\\n        uint256 requiredAmount = amounts[0];\\r\\n        bool isBNB = tokenAddress == address(0);\\r\\n\\r\\n        require(!isBNB || requiredAmount <= msg.value, 'insufficient bnb');\\r\\n        require(\\r\\n            isBNB || requiredAmount <= IPRC20(tokenAddress).allowance(msg.sender, address(this)),\\r\\n            'not enough allowance'\\r\\n        );\\r\\n\\r\\n        if (isBNB) {\\r\\n            if (requiredAmount < msg.value) {\\r\\n                _transfer(msg.sender, tokenAddress, msg.value - requiredAmount);\\r\\n            }\\r\\n            router.swapExactETHForTokens{ value: requiredAmount }(bet.usdValue, path, address(this), block.timestamp);\\r\\n        } else {\\r\\n            IPRC20(tokenAddress).transferFrom(msg.sender, address(this), requiredAmount);\\r\\n            IPRC20(tokenAddress).approve(pancakeRouterAddr, requiredAmount);\\r\\n            router.swapExactTokensForTokens(requiredAmount, bet.usdValue, path, address(this), block.timestamp);\\r\\n        }\\r\\n        _addStableCoinAmountInfo(roundId, usdtAddr, bet.usdValue);\\r\\n    }\\r\\n\\r\\n    function _addBet(uint256 roundId, Bet calldata bet) internal {\\r\\n        Round storage round = rounds[roundId];\\r\\n        uint256 newBetId = round.bets.length;\\r\\n        round.bets.push(Bet(newBetId, bet.betTokenId, bet.player, bet.usdValue));\\r\\n        emit BetPlaced(roundId, newBetId, bet.player, bet.usdValue);\\r\\n    }\\r\\n\\r\\n    function _getSwapPath(address from, address to) internal view returns (address[] memory path) {\\r\\n        if (from == address(0)) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = to;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = from;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = to;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getFeeAmount(uint256 amount) internal view returns (uint256) {\\r\\n        if (isBotEnabled) return (amount * (fee + botFee)) / 1000;\\r\\n        return (amount * fee) / 1000;\\r\\n    }\\r\\n\\r\\n    function _addStableCoinAmountInfo(uint256 roundId, address stableCoinAddress, uint256 amount) internal {\\r\\n        Round storage round = rounds[roundId];\\r\\n        uint256 length = round.stableCoinAmounts.length;\\r\\n        round.currentTotalUSD += amount;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (round.stableCoinAmounts[i].tokenAddress == stableCoinAddress) {\\r\\n                round.stableCoinAmounts[i].amount += amount;\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        round.stableCoinAmounts.push(StableCoinAmount(stableCoinAddress, amount));\\r\\n    }\\r\\n\\r\\n    function getPriceOracle(uint256 priceTokenId) public view returns (uint256) {\\r\\n        PriceToken storage priceTokenInfo = priceTokens[priceTokenId];\\r\\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceTokenInfo.priceFeed);\\r\\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\\r\\n        return uint256(answer) * 10 ** (18 - priceTokenInfo.digit);\\r\\n    }\\r\\n\\r\\n    function _transfer(address receiver, address tokenAddress, uint256 amount) internal {\\r\\n        if (tokenAddress != address(0)) {\\r\\n            IPRC20(tokenAddress).transfer(receiver, amount);\\r\\n        } else {\\r\\n            payable(receiver).transfer(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTokenUSDPrice(address tokenAddress) public view returns (uint256) {\\r\\n        if (isStable[tokenAddress]) return 10 ** 18;\\r\\n        if (tokenAddress == address(0)) return _getBNBPrice();\\r\\n\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        IPRC20 token = IPRC20(tokenAddress);\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = wbnbAddr;\\r\\n        path[2] = usdtAddr;\\r\\n        uint256 usdValue = router.getAmountsOut(10 ** token.decimals(), path)[2];\\r\\n\\r\\n        return usdValue;\\r\\n    }\\r\\n\\r\\n    function _takeFee(uint256 roundId, uint256 amount) internal {\\r\\n        if (amount == 0) return;\\r\\n        Round storage round = rounds[roundId];\\r\\n        uint256 length = round.stableCoinAmounts.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (round.stableCoinAmounts[i].amount >= amount) {\\r\\n                _swapAccumulatedFees(round.stableCoinAmounts[i].tokenAddress, amount);\\r\\n                round.stableCoinAmounts[i].amount -= amount;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current BNB price in comparison with BNB and BUSD\\r\\n     */\\r\\n    function _getBNBPrice() internal view returns (uint256 price) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = wbnbAddr;\\r\\n        path[1] = usdtAddr;\\r\\n        uint256[] memory amounts = router.getAmountsOut(10 ** 18, path);\\r\\n        return amounts[1];\\r\\n    }\\r\\n\\r\\n    function _swapAccumulatedFees(address tokenAddress, uint256 amount) internal {\\r\\n        if (isBotEnabled) {\\r\\n            IPRC20(usdtAddr).transfer(botAddress, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPriceTokens() external view returns (PriceToken[] memory list) {\\r\\n        return priceTokens;\\r\\n    }\\r\\n\\r\\n    function getBetTokens()\\r\\n        external\\r\\n        view\\r\\n        returns (BetToken[] memory list, uint256[] memory prices, uint8[] memory decimals)\\r\\n    {\\r\\n        uint256 length = betTokens.length;\\r\\n        prices = new uint256[](length);\\r\\n        decimals = new uint8[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            address tokenAddress = betTokens[i].tokenAddress;\\r\\n            prices[i] = getTokenUSDPrice(tokenAddress);\\r\\n            if (tokenAddress != address(0)) decimals[i] = IPRC20(betTokens[i].tokenAddress).decimals();\\r\\n            else decimals[i] = 18;\\r\\n        }\\r\\n        list = betTokens;\\r\\n    }\\r\\n\\r\\n    function getRounds(\\r\\n        uint256 start,\\r\\n        uint256 length\\r\\n    ) external view returns (Round[] memory list, RoundOption[] memory options, RoundTimeInfo[] memory timeInfos) {\\r\\n        if (start >= rounds.length) return (list, options, timeInfos);\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > rounds.length) end = rounds.length;\\r\\n        list = new Round[](end - start);\\r\\n        options = new RoundOption[](end - start);\\r\\n        timeInfos = new RoundTimeInfo[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            list[i - start] = rounds[i];\\r\\n            options[i - start] = roundOptions[i];\\r\\n            timeInfos[i - start] = roundTimeInfos[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRound(\\r\\n        uint256 roundId\\r\\n    ) external view returns (Round memory round, RoundOption memory option, RoundTimeInfo memory timeInfo) {\\r\\n        return (rounds[roundId], roundOptions[roundId], roundTimeInfos[roundId]);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceCall/PriceCallBot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\nimport '../interfaces/IPriceCall.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\n\\r\\ncontract PriceCallBot is OwnableUpgradeable {\\r\\n    address public tokenAddr; // usdt address\\r\\n    IPancakeRouter02 public router;\\r\\n    IPriceCall public priceCallContract;\\r\\n    uint256 public betTokenId;\\r\\n    uint256 public minDelta;\\r\\n    uint256 public maxDelta;\\r\\n    uint256 public minRoundTime;\\r\\n    uint256 public maxRoundTime;\\r\\n    uint256 public minOdd;\\r\\n    uint256 public maxOdd;\\r\\n    uint256 public betInterval;\\r\\n    uint256 public lastCreatedTime;\\r\\n\\r\\n    uint256[] public roundIds;\\r\\n\\r\\n    function initialize(address _tokenAddr, address _priceCallContract, address _routerAddr) external initializer {\\r\\n        tokenAddr = _tokenAddr;\\r\\n        priceCallContract = IPriceCall(_priceCallContract);\\r\\n        router = IPancakeRouter02(_routerAddr);\\r\\n        minDelta = 5; // min 20%\\r\\n        maxDelta = 50; // max 50%\\r\\n        maxRoundTime = 3600 * 24 * 30; // 10 days\\r\\n        minRoundTime = 3600;\\r\\n        minOdd = 55; // roundMaximumValue is 5x\\r\\n        maxOdd = 99; // roundMaximumValue is 2x\\r\\n        betInterval = 3600 * 24 * 10;\\r\\n        lastCreatedTime = block.timestamp;\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function getCurrentUSDValue(uint256 balance) public view returns (uint256) {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddr;\\r\\n        path[1] = router.WETH();\\r\\n        path[2] = priceCallContract.usdtAddr();\\r\\n        uint256[] memory amounts = router.getAmountsOut(balance, path);\\r\\n        return amounts[2];\\r\\n    }\\r\\n\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.prevrandao, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    function getBetTokenId() public view returns (uint256) {\\r\\n        (IPriceCall.BetToken[] memory tokens, ) = priceCallContract.getBetTokens();\\r\\n        uint256 length = tokens.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (tokens[i].tokenAddress == tokenAddr) {\\r\\n                return i;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function getPriceTokenCount() public view returns (uint256) {\\r\\n        IPriceCall.PriceToken[] memory tokens = priceCallContract.getPriceTokens();\\r\\n        return tokens.length;\\r\\n    }\\r\\n\\r\\n    function createBet() external {\\r\\n        uint256 balance = IPRC20(tokenAddr).balanceOf(address(this));\\r\\n        require(lastCreatedTime + betInterval <= block.timestamp, 'cannot create bet yet');\\r\\n        require(balance > 0, 'no balance');\\r\\n\\r\\n        uint256 random = fullFillRandomness();\\r\\n        uint256 priceTokenId = random % getPriceTokenCount();\\r\\n        uint256 operator = block.timestamp % 2;\\r\\n        uint256 currentPrice = priceCallContract.getPriceOracle(priceTokenId);\\r\\n        uint256 delta = (random % (maxDelta - minDelta + 1)) + minDelta;\\r\\n        uint256 pricePoint;\\r\\n        if (operator == 0) {\\r\\n            // operator 0 is >=, so price point should be bigger\\r\\n            pricePoint = (currentPrice * (100 + delta)) / 100;\\r\\n        } else {\\r\\n            pricePoint = (currentPrice * (100 - delta)) / 100;\\r\\n        }\\r\\n\\r\\n        uint256 endTime = block.timestamp + (random % (maxRoundTime - minRoundTime + 1)) + minRoundTime;\\r\\n        uint256 minUSDPerPlayer = balance / 50; // maximum 50 players\\r\\n        uint256 odd = (random % (maxOdd - minOdd + 1)) + minOdd;\\r\\n        uint256 roundMaximumValue = (balance * 100) / odd;\\r\\n        IPriceCall.Bet memory initialBet;\\r\\n        initialBet.betTokenId = getBetTokenId();\\r\\n        initialBet.player = address(this);\\r\\n        initialBet.usdValue = balance;\\r\\n\\r\\n        IPRC20(tokenAddr).approve(address(priceCallContract), balance);\\r\\n        priceCallContract.createRound(\\r\\n            priceTokenId,\\r\\n            endTime,\\r\\n            0,\\r\\n            pricePoint,\\r\\n            operator,\\r\\n            0,\\r\\n            minUSDPerPlayer,\\r\\n            roundMaximumValue,\\r\\n            false,\\r\\n            false,\\r\\n            false,\\r\\n            initialBet\\r\\n        );\\r\\n        lastCreatedTime = block.timestamp;\\r\\n        // uint256 newRoundId = priceCallContract.roundIds() - 1;\\r\\n        // roundIds.push(newRoundId);\\r\\n    }\\r\\n\\r\\n    function cancelBet(uint256 roundId) external onlyOwner {\\r\\n        priceCallContract.cancelRound(roundId);\\r\\n    }\\r\\n\\r\\n    function setBetInterval(uint256 value) external onlyOwner {\\r\\n        betInterval = value;\\r\\n    }\\r\\n\\r\\n    function setLastCreatedTime(uint256 value) external onlyOwner {\\r\\n        lastCreatedTime = value;\\r\\n    }\\r\\n\\r\\n    function setMaxRoundTime(uint256 value) external onlyOwner {\\r\\n        maxRoundTime = value;\\r\\n    }\\r\\n\\r\\n    function setPriceCallContractAddress(address addr) external onlyOwner {\\r\\n        priceCallContract = IPriceCall(addr);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IPriceCall {\\r\\n    struct PriceToken {\\r\\n        string tokenName;\\r\\n        address priceFeed;\\r\\n        uint256 digit;\\r\\n    }\\r\\n\\r\\n    struct BetToken {\\r\\n        string tokenName;\\r\\n        address tokenAddress;\\r\\n        bool isStable;\\r\\n    }\\r\\n\\r\\n    struct Bet {\\r\\n        uint256 betId;\\r\\n        uint256 betTokenId;\\r\\n        address player;\\r\\n        uint256 usdValue;\\r\\n    }\\r\\n\\r\\n    struct StableCoinAmount {\\r\\n        address tokenAddress;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    enum RoundStatus {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        CANCELED,\\r\\n        EXPIRED,\\r\\n        FINISHED\\r\\n    }\\r\\n\\r\\n    struct Round {\\r\\n        uint256 roundId;\\r\\n        uint256 priceTokenId;\\r\\n        uint256 operator; // 0: >=, 1: <=\\r\\n        uint256 maxUSDPerPlayer;\\r\\n        uint256 minUSDPerPlayer;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n        uint256 expireTime;\\r\\n        uint256 pricePoint;\\r\\n        uint256 currentTotalUSD;\\r\\n        uint256 roundMaximumValue;\\r\\n        uint256 recordedPrice;\\r\\n        address creator;\\r\\n        bool isCreatorWinner;\\r\\n        RoundStatus status;\\r\\n        Bet[] bets;\\r\\n        StableCoinAmount[] stableCoinAmounts;\\r\\n    }\\r\\n\\r\\n    struct RoundOption {\\r\\n        bool onlyOneTaker;\\r\\n        bool isPrivate;\\r\\n        bool startEarlyEnabled;\\r\\n    }\\r\\n\\r\\n    function roundIds() external view returns (uint256);\\r\\n\\r\\n    function BNBPAddr() external view returns (address);\\r\\n\\r\\n    function potContractAddr() external view returns (address);\\r\\n\\r\\n    function usdtAddr() external view returns (address);\\r\\n\\r\\n    event RoundCreated(\\r\\n        uint256 roundId,\\r\\n        uint256 priceTokenId,\\r\\n        uint256 operator,\\r\\n        uint256 maxUSDPerPlayer,\\r\\n        uint256 minUSDPerPlayer,\\r\\n        uint256 endTime,\\r\\n        uint256 expireTime,\\r\\n        uint256 pricePoint,\\r\\n        uint256 roundMaximumValue,\\r\\n        address creator,\\r\\n        bool isPrivate\\r\\n    );\\r\\n    event BetPlaced(uint256 roundId, uint256 betId, address player, uint256 usdValue);\\r\\n    event RoundStarted(uint256 roundId, uint256 roundMaximumValue, uint256 creatorUSDValue);\\r\\n    event RoundCanceled(uint256 roundId, uint256 feeAmount, uint256 creatorReturnedAmount);\\r\\n    event RoundFinished(uint256 roundId, uint256 recordedPrice, bool isCreatorWinner, uint256 feeAmount);\\r\\n    event PlayerWon(uint256 roundId, uint256 betId, address player, uint256 amount);\\r\\n\\r\\n    function createRound(\\r\\n        uint256 priceTokenId,\\r\\n        uint256 endTime,\\r\\n        uint256 expireTime,\\r\\n        uint256 pricePoint,\\r\\n        uint256 operator,\\r\\n        uint256 maxUSDPerPlayer,\\r\\n        uint256 minUSDPerPlayer,\\r\\n        uint256 roundMaximumValue,\\r\\n        bool onlyOneTaker,\\r\\n        bool isPrivate,\\r\\n        bool startEarlyEnabled,\\r\\n        Bet calldata initialBet\\r\\n    ) external payable;\\r\\n\\r\\n    function placeBet(uint256 roundId, Bet calldata bet) external payable;\\r\\n\\r\\n    function startEarly(uint256 roundId) external;\\r\\n\\r\\n    function cancelRound(uint256 roundId) external;\\r\\n\\r\\n    function finishRound(uint256 roundId) external;\\r\\n\\r\\n    function getPriceOracle(uint256 priceTokenId) external view returns (uint256);\\r\\n\\r\\n    function getTokenUSDPrice(address tokenAddress) external view returns (uint256);\\r\\n\\r\\n    function getPriceTokens() external view returns (PriceToken[] memory list);\\r\\n\\r\\n    function getBetTokens() external view returns (BetToken[] memory list, uint256[] memory prices);\\r\\n\\r\\n    function getRounds(\\r\\n        uint256 start,\\r\\n        uint256 length\\r\\n    ) external view returns (Round[] memory list, RoundOption[] memory options);\\r\\n\\r\\n    function getRound(uint256 roundId) external view returns (Round memory round, RoundOption memory option);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/StakingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\n\\r\\ncontract TYRHStaking is OwnableUpgradeable {\\r\\n    IERC20 token;\\r\\n    struct Stake {\\r\\n        uint256 id;\\r\\n        address user;\\r\\n        uint256 amount;\\r\\n        uint256 timestamp;\\r\\n        address airdropToken;\\r\\n        uint256 airdropAmount;\\r\\n        bool isFinished;\\r\\n    }\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 totalAmount;\\r\\n        uint256[] stakeIds;\\r\\n        uint256 stakeCount;\\r\\n    }\\r\\n\\r\\n    struct AirdropToken {\\r\\n        address tokenAddress;\\r\\n        uint256 minimumX; // 1000 = 1x\\r\\n        uint256 maximumX; // 1000 = 1x\\r\\n        bool disabled;\\r\\n    }\\r\\n\\r\\n    struct FreeClaim {\\r\\n        uint256 stakingId;\\r\\n        address tokenAddress;\\r\\n        uint256 airdropAmount;\\r\\n        bool claimable;\\r\\n        bool claimed;\\r\\n    }\\r\\n\\r\\n    Stake[] public stakeList;\\r\\n    AirdropToken[] public airdropTokens;\\r\\n\\r\\n    uint256 public totalAmount;\\r\\n    uint256 public airdropTokenCount;\\r\\n    uint256 public minimumStakingForAirdrop;\\r\\n    uint256 public freeAirdropX;\\r\\n    uint256 internal constant period = 3600 * 24 * 55;\\r\\n\\r\\n    mapping(address => StakingInfo) public userStakingInfo;\\r\\n    mapping(uint256 => FreeClaim) public freeClaimInfo;\\r\\n    mapping(address => bool) public isAllowedContract;\\r\\n\\r\\n    event UserStakingAmountChanged(address user, uint256 stakingId, uint256 totalAmount, bool isFinished);\\r\\n    event Airdropped(\\r\\n        uint256 stakingId,\\r\\n        address user,\\r\\n        address airdroToken,\\r\\n        uint256 stakingAmount,\\r\\n        uint256 airdropAmount,\\r\\n        bool isFreeClaim\\r\\n    );\\r\\n\\r\\n    function initialize(address _TYRHAddr) external initializer {\\r\\n        token = IERC20(_TYRHAddr);\\r\\n        minimumStakingForAirdrop = 1000 * 10 ** 18; // minimum 1000 TYRH for airdrop\\r\\n        freeAirdropX = 50000;\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender || isAllowedContract[msg.sender], 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function fulFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.prevrandao, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) external excludeContract {\\r\\n        uint256 newStakingId = stakeList.length;\\r\\n\\r\\n        token.transferFrom(msg.sender, address(this), amount);\\r\\n        stakeList.push(Stake(newStakingId, msg.sender, amount, block.timestamp, address(0), 0, false));\\r\\n\\r\\n        StakingInfo storage info = userStakingInfo[msg.sender];\\r\\n        info.totalAmount += amount;\\r\\n        info.stakeIds.push(newStakingId);\\r\\n        info.stakeCount++;\\r\\n        totalAmount += amount;\\r\\n\\r\\n        if (amount >= minimumStakingForAirdrop) {\\r\\n            (address airdropToken, uint256 airdropAmount) = _airdrop(newStakingId, amount, false);\\r\\n            stakeList[newStakingId].airdropToken = airdropToken;\\r\\n            stakeList[newStakingId].airdropAmount = airdropAmount;\\r\\n        }\\r\\n\\r\\n        emit UserStakingAmountChanged(msg.sender, newStakingId, info.totalAmount, false);\\r\\n    }\\r\\n\\r\\n    function unStake(uint256 id) external {\\r\\n        Stake memory info = stakeList[id];\\r\\n        StakingInfo storage stakingInfo = userStakingInfo[msg.sender];\\r\\n        require(info.user == msg.sender, 'Not right user');\\r\\n        require(info.isFinished == false, 'Finished already');\\r\\n\\r\\n        if (info.timestamp + period > block.timestamp) {\\r\\n            // apply penalty\\r\\n            uint256 penalty = (info.amount * 5555) / 10000;\\r\\n            token.transfer(address(0xdead), penalty);\\r\\n            token.transfer(msg.sender, info.amount - penalty);\\r\\n        } else {\\r\\n            token.transfer(msg.sender, info.amount);\\r\\n        }\\r\\n\\r\\n        stakingInfo.totalAmount -= info.amount;\\r\\n        stakingInfo.stakeCount--;\\r\\n        totalAmount -= info.amount;\\r\\n        stakeList[id].isFinished = true;\\r\\n\\r\\n        emit UserStakingAmountChanged(msg.sender, id, stakingInfo.totalAmount, true);\\r\\n    }\\r\\n\\r\\n    function getUserStakingList(address user) external view returns (Stake[] memory list) {\\r\\n        StakingInfo memory info = userStakingInfo[user];\\r\\n        list = new Stake[](info.stakeCount);\\r\\n        uint256 sIndex = 0;\\r\\n        uint256 length = info.stakeIds.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            uint256 stakeId = info.stakeIds[i];\\r\\n\\r\\n            if (!stakeList[stakeId].isFinished) {\\r\\n                list[sIndex++] = stakeList[stakeId];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserStakingListByPages(\\r\\n        address user,\\r\\n        uint256 start,\\r\\n        uint256 length\\r\\n    ) external view returns (Stake[] memory list) {\\r\\n        StakingInfo memory info = userStakingInfo[user];\\r\\n        if (start >= info.stakeIds.length) return list;\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > info.stakeIds.length) end = info.stakeIds.length;\\r\\n        list = new Stake[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            uint256 stakeId = info.stakeIds[i];\\r\\n            list[i - start] = stakeList[stakeId];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserFreeClaimInfo(address user) external view returns (FreeClaim[] memory list) {\\r\\n        StakingInfo memory info = userStakingInfo[user];\\r\\n        list = new FreeClaim[](info.stakeCount);\\r\\n        uint256 sIndex = 0;\\r\\n        uint256 length = info.stakeIds.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            uint256 stakeId = info.stakeIds[i];\\r\\n            if (!stakeList[stakeId].isFinished) {\\r\\n                list[sIndex++] = freeClaimInfo[stakeId];\\r\\n                list[sIndex - 1].stakingId = stakeId;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserFreeClaimInfoByPages(\\r\\n        address user,\\r\\n        uint256 start,\\r\\n        uint256 length\\r\\n    ) external view returns (FreeClaim[] memory list) {\\r\\n        StakingInfo memory info = userStakingInfo[user];\\r\\n        if (start >= info.stakeIds.length) return list;\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > info.stakeIds.length) end = info.stakeIds.length;\\r\\n        list = new FreeClaim[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            uint256 stakeId = info.stakeIds[i];\\r\\n            list[i - start] = freeClaimInfo[stakeId];\\r\\n            list[i - start].stakingId = stakeId;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _airdrop(\\r\\n        uint256 stakingId,\\r\\n        uint256 amount,\\r\\n        bool isFreeClaim\\r\\n    ) internal returns (address tokenAddress, uint256 airdropAmount) {\\r\\n        if (airdropTokenCount == 0) return (address(0), 0);\\r\\n        uint256 random = fulFillRandomness();\\r\\n        uint256 selectedTokenId = random % airdropTokenCount;\\r\\n        uint256 i;\\r\\n        uint256 j;\\r\\n        uint256 length = airdropTokens.length;\\r\\n        for (i = 0; i < length; i++) {\\r\\n            if (!airdropTokens[i].disabled) {\\r\\n                j++;\\r\\n            }\\r\\n            if (j == selectedTokenId + 1) break;\\r\\n        }\\r\\n\\r\\n        AirdropToken memory info = airdropTokens[i];\\r\\n        uint256 airdropX = (random % (info.maximumX - info.minimumX + 1)) + info.minimumX;\\r\\n        if (isFreeClaim) airdropX = freeAirdropX;\\r\\n        tokenAddress = info.tokenAddress;\\r\\n        airdropAmount = (amount * airdropX) / 1000;\\r\\n\\r\\n        require(IERC20(tokenAddress).balanceOf(address(this)) >= airdropAmount, 'not enough airdrop token');\\r\\n        IERC20(info.tokenAddress).transfer(msg.sender, airdropAmount);\\r\\n\\r\\n        emit Airdropped(stakingId, msg.sender, tokenAddress, amount, airdropAmount, isFreeClaim);\\r\\n    }\\r\\n\\r\\n    function addAirdropTokens(AirdropToken[] memory tokens) external onlyOwner {\\r\\n        uint256 length = tokens.length;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            AirdropToken memory item = tokens[i];\\r\\n            airdropTokens.push(AirdropToken(item.tokenAddress, item.minimumX, item.maximumX, false));\\r\\n        }\\r\\n        airdropTokenCount += length;\\r\\n    }\\r\\n\\r\\n    function updateAirdropToken(\\r\\n        uint256 id,\\r\\n        address tokenAddress,\\r\\n        uint256 minimumX,\\r\\n        uint256 maximumX\\r\\n    ) external onlyOwner {\\r\\n        AirdropToken storage info = airdropTokens[id];\\r\\n        info.tokenAddress = tokenAddress;\\r\\n        info.minimumX = minimumX;\\r\\n        info.maximumX = maximumX;\\r\\n    }\\r\\n\\r\\n    function setAirdropTokenDisabled(uint256 id, bool value) external onlyOwner {\\r\\n        AirdropToken storage info = airdropTokens[id];\\r\\n        require(info.disabled != value, 'already set');\\r\\n        info.disabled = value;\\r\\n        if (info.disabled) airdropTokenCount--;\\r\\n        else airdropTokenCount++;\\r\\n    }\\r\\n\\r\\n    function addPreviousStakes(Stake[] calldata list) external onlyOwner {\\r\\n        uint256 length = list.length;\\r\\n        uint256 stakeIdStart = stakeList.length;\\r\\n        uint256 totalAdded = 0;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (!list[i].isFinished) {\\r\\n                userStakingInfo[list[i].user].totalAmount += list[i].amount;\\r\\n                userStakingInfo[list[i].user].stakeCount++;\\r\\n                userStakingInfo[list[i].user].stakeIds.push(stakeIdStart + i);\\r\\n                totalAdded += list[i].amount;\\r\\n            }\\r\\n            stakeList.push(\\r\\n                Stake(\\r\\n                    stakeIdStart + i,\\r\\n                    list[i].user,\\r\\n                    list[i].amount,\\r\\n                    list[i].timestamp,\\r\\n                    list[i].airdropToken,\\r\\n                    list[i].airdropAmount,\\r\\n                    list[i].isFinished\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n        totalAmount += totalAdded;\\r\\n    }\\r\\n\\r\\n    function setMinimumStakingForAirdrop(uint256 value) external onlyOwner {\\r\\n        minimumStakingForAirdrop = value;\\r\\n    }\\r\\n\\r\\n    function setStakeFreeClaimable(uint256[] calldata stakeIds) external onlyOwner {\\r\\n        uint256 length = stakeIds.length;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            freeClaimInfo[stakeIds[i]].claimable = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setAllowedContract(address addr) external onlyOwner {\\r\\n        isAllowedContract[addr] = true;\\r\\n    }\\r\\n\\r\\n    function setFreeAirdropX(uint256 value) external onlyOwner {\\r\\n        freeAirdropX = value;\\r\\n    }\\r\\n\\r\\n    function freeClaim(uint256 stakingId) external excludeContract {\\r\\n        Stake memory stakingInfo = stakeList[stakingId];\\r\\n        FreeClaim storage claimInfo = freeClaimInfo[stakingId];\\r\\n\\r\\n        require(stakingInfo.user == msg.sender, 'not owner');\\r\\n        require(claimInfo.claimed == false, 'already claimed');\\r\\n        require(claimInfo.claimable, 'not valid for free claim');\\r\\n\\r\\n        (address airdropToken, uint256 airdropAmount) = _airdrop(stakingId, stakingInfo.amount, true);\\r\\n        claimInfo.tokenAddress = airdropToken;\\r\\n        claimInfo.airdropAmount = airdropAmount;\\r\\n        claimInfo.claimed = true;\\r\\n    }\\r\\n\\r\\n    function withdrawAirdropToken(uint256 id, uint256 amount) external onlyOwner {\\r\\n        address tokenAddress = airdropTokens[id].tokenAddress;\\r\\n        IERC20(tokenAddress).transfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Water/Reservoir.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../../interfaces/IBoosterNFT.sol';\\r\\nimport '../../interfaces/IPancakeFactory.sol';\\r\\nimport '../../interfaces/IPulseXRouter.sol';\\r\\n\\r\\ncontract Reservoir is Ownable {\\r\\n    IERC20 public water;\\r\\n    IERC20 public inc;\\r\\n    IPulseXRouter02 public immutable router;\\r\\n    address public burnPoolAddress;\\r\\n    uint256 public defaultYield;\\r\\n    uint256 public lockDays;\\r\\n    uint256 public incFee;\\r\\n    mapping(address => StakingInfo) public userInfo;\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 amount;\\r\\n        uint256 incAmount;\\r\\n        uint256 yield;\\r\\n        uint256 timestamp;\\r\\n        bool isStaking;\\r\\n    }\\r\\n\\r\\n    event Staked(address user, uint256 amount, uint256 incAmount);\\r\\n    event UnStaked(address user, uint256 amount);\\r\\n    event IncBurnt(address user, uint256 amount);\\r\\n\\r\\n    constructor(address waterAddr, address incAddress, address _burnPoolAddress) {\\r\\n        water = IERC20(waterAddr);\\r\\n        inc = IERC20(incAddress);\\r\\n        router = IPulseXRouter02(0x165C3410fC91EF562C50559f7d2289fEbed552d9);\\r\\n        burnPoolAddress = _burnPoolAddress;\\r\\n        lockDays = 10; // 10 days\\r\\n        defaultYield = 40; // 4%\\r\\n        incFee = 20; // 20% to inc burn\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) external {\\r\\n        StakingInfo storage info = userInfo[msg.sender];\\r\\n        require(info.isStaking == false, 'Already Staking');\\r\\n        water.transferFrom(msg.sender, address(this), amount);\\r\\n        uint256 incFeeAmount = (amount * incFee) / 100;\\r\\n        uint256 stakeAmount = amount - incFeeAmount;\\r\\n\\r\\n        uint256 incAmount = _swapBurnInc(incFeeAmount);\\r\\n        info.yield = defaultYield;\\r\\n        info.amount = stakeAmount;\\r\\n        info.timestamp = block.timestamp;\\r\\n        info.incAmount = incAmount;\\r\\n        info.isStaking = true;\\r\\n        emit Staked(msg.sender, amount, incAmount);\\r\\n    }\\r\\n\\r\\n    function _swapBurnInc(uint256 amount) internal returns (uint256 incAmount) {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(water);\\r\\n        path[1] = router.WPLS();\\r\\n        path[2] = address(inc);\\r\\n\\r\\n        water.approve(address(router), amount);\\r\\n        uint256[] memory amounts = router.swapExactTokensForTokens(amount, 0, path, address(this), block.timestamp);\\r\\n        inc.transfer(burnPoolAddress, amounts[2]);\\r\\n        incAmount = amounts[2];\\r\\n        emit IncBurnt(msg.sender, amounts[2]);\\r\\n    }\\r\\n\\r\\n    function unStake() external {\\r\\n        uint256 oneDay = 24 * 3600;\\r\\n        StakingInfo storage info = userInfo[msg.sender];\\r\\n        require(info.isStaking == true, 'stake first');\\r\\n        require(info.timestamp + lockDays * oneDay < block.timestamp, \\\"Can't unstake yet\\\");\\r\\n        uint256 amount = info.amount;\\r\\n        uint256 yield = info.yield;\\r\\n        for (uint256 i = 0; i < lockDays; i++) {\\r\\n            amount = (amount * (1000 + yield)) / 1000;\\r\\n        }\\r\\n        info.isStaking = false;\\r\\n        water.transfer(msg.sender, amount);\\r\\n        emit UnStaked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function setLockDays(uint256 value) external onlyOwner {\\r\\n        lockDays = value;\\r\\n    }\\r\\n\\r\\n    function setTokenAddresses(address waterAddress, address incAddress) external onlyOwner {\\r\\n        water = IERC20(waterAddress);\\r\\n        inc = IERC20(incAddress);\\r\\n    }\\r\\n\\r\\n    function setBurnPoolAddress(address addr) external onlyOwner {\\r\\n        burnPoolAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setDefaultYield(uint256 value) external onlyOwner {\\r\\n        defaultYield = value;\\r\\n    }\\r\\n\\r\\n    function setIncFee(uint256 value) external onlyOwner {\\r\\n        incFee = value;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBoosterNFT.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\\r\\n\\r\\ninterface ITYRHBoosterNFT {\\r\\n    struct NFTType {\\r\\n        uint256 category; // 0: claim booster, 1: special, 2: league booster\\r\\n        uint256 typeId;\\r\\n        uint256 value;\\r\\n        string uri;\\r\\n        bool enabled;\\r\\n        bool isRandom;\\r\\n        bool isFixed;\\r\\n        uint256 max;\\r\\n        uint256 min;\\r\\n        uint256 defaultWeight;\\r\\n    }\\r\\n\\r\\n    struct NFT {\\r\\n        uint256 typeId;\\r\\n        uint256 tokenId;\\r\\n        uint256 weight;\\r\\n    }\\r\\n\\r\\n    struct NFTWithOwner {\\r\\n        uint256 typeId;\\r\\n        uint256 tokenId;\\r\\n        uint256 weight;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    function nftTypes(uint256 index) external view returns (NFTType memory);\\r\\n\\r\\n    function nfts(uint256 index) external view returns (NFT memory);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev mint Booster NFTS\\r\\n     *\\r\\n     * @param typeId typeId for NFT\\r\\n     */\\r\\n    function mint(uint256 typeId) external;\\r\\n\\r\\n    function getNFTTypes() external view returns (NFTType[] memory);\\r\\n\\r\\n    function getNFTs(uint256 start, uint256 length) external view returns (NFTWithOwner[] memory list);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPulseXRouter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IPulseXRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WPLS() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IPulseXRouter02 is IPulseXRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        _balances[account] += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TYRH/TYRH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPulseXRouter.sol';\\r\\n\\r\\ncontract TYRH is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    IPulseXRouter02 public immutable router;\\r\\n    address public immutable lpPair;\\r\\n\\r\\n    address public burnPoolAddr;\\r\\n    address[] public RHTokens;\\r\\n    mapping(address => bool) public excludedFromFee;\\r\\n    event AccumulatedFee(address account, uint256 amount);\\r\\n    event SwappedFee(address token, uint256 amount);\\r\\n\\r\\n    constructor() ERC20('TYRH', 'TYRH') {\\r\\n        IPulseXRouter02 _router = IPulseXRouter02(0x165C3410fC91EF562C50559f7d2289fEbed552d9); // bsc testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1\\r\\n        router = _router;\\r\\n        lpPair = IPancakeFactory(router.factory()).createPair(address(this), router.WPLS());\\r\\n\\r\\n        excludedFromFee[msg.sender] = true;\\r\\n        excludedFromFee[address(router)] = true;\\r\\n        excludedFromFee[address(this)] = true;\\r\\n        _mint(msg.sender, 1000000000 * 10 ** 18);\\r\\n    }\\r\\n\\r\\n    function addRHToken(address addr) external onlyOwner {\\r\\n        IPancakeFactory factory = IPancakeFactory(router.factory());\\r\\n        require(addr != address(this), '1');\\r\\n        require(addr == address(0) || factory.getPair(addr, router.WPLS()) != address(0), 'not a valid token');\\r\\n        RHTokens.push(addr);\\r\\n    }\\r\\n\\r\\n    function setBurnPoolAddress(address addr) external onlyOwner {\\r\\n        burnPoolAddr = addr;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public override onlyOwner {\\r\\n        excludedFromFee[newOwner] = true;\\r\\n        super.transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n        require(from != address(0), 'ERC20: transfer from the zero address');\\r\\n        require(to != address(0), 'ERC20: transfer to the zero address');\\r\\n        if (from == lpPair && !excludedFromFee[to]) {\\r\\n            // buy, 50% tax\\r\\n            uint256 fee = (amount * 22) / 100;\\r\\n            super._transfer(from, to, amount - fee);\\r\\n            super._transfer(from, address(this), fee);\\r\\n            emit AccumulatedFee(from, fee);\\r\\n        } else if (to == lpPair && !excludedFromFee[from]) {\\r\\n            // sell, 10% tax\\r\\n            uint256 fee = amount / 10;\\r\\n            super._transfer(from, to, amount - fee);\\r\\n            super._transfer(from, address(this), fee);\\r\\n            emit AccumulatedFee(from, fee);\\r\\n        } else {\\r\\n            super._transfer(from, to, amount);\\r\\n            if (balanceOf(address(this)) > 0) {\\r\\n                _swapBackToRHToken();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _swapBackToRHToken() internal {\\r\\n        uint256 amount = balanceOf(address(this));\\r\\n        uint256 index = uint256(\\r\\n            uint128(bytes16(keccak256(abi.encodePacked(block.difficulty, block.number, block.timestamp))))\\r\\n        ) % RHTokens.length;\\r\\n        address swapToken = RHTokens[index];\\r\\n        uint256 outputAmount;\\r\\n        uint256[] memory amounts;\\r\\n        _approve(address(this), address(router), amount);\\r\\n        if (swapToken != address(0)) {\\r\\n            address[] memory path = new address[](3);\\r\\n            path[0] = address(this);\\r\\n            path[1] = router.WPLS();\\r\\n            path[2] = swapToken;\\r\\n            amounts = router.swapExactTokensForTokens(amount, 0, path, burnPoolAddr, block.timestamp);\\r\\n            outputAmount = amounts[2];\\r\\n        } else {\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = address(this);\\r\\n            path[1] = router.WPLS();\\r\\n            amounts = router.swapExactTokensForETH(amount, 0, path, burnPoolAddr, block.timestamp);\\r\\n            outputAmount = amounts[1];\\r\\n        }\\r\\n        emit SwappedFee(swapToken, outputAmount);\\r\\n    }\\r\\n\\r\\n    function getRHTokens() external view returns (address[] memory) {\\r\\n        return RHTokens;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Roulette/CasinoNFT.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/Counters.sol';\\r\\nimport '../interfaces/IRoulette.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\n\\r\\ncontract RouletteCasinoNFT is ERC721URIStorage, Ownable {\\r\\n    using Counters for Counters.Counter;\\r\\n    Counters.Counter public _tokenIds;\\r\\n\\r\\n    address public rouletteContractAddr;\\r\\n    address constant wbnbAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address constant pancakeFactoryAddr = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // testnet: 0x6725F303b657a9451d8BA641348b6761A6CC7a17, mainnet: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n\\r\\n    constructor() ERC721('BNBPot Roulette NFT', 'BNBPR') {}\\r\\n\\r\\n    event Mint(uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev mint Casino NFTS\\r\\n     *\\r\\n     * @param tokenURI metadata url for NFT\\r\\n     * @param newTokenAddress token address that will be used in the casino\\r\\n     */\\r\\n    function mint(\\r\\n        string memory tokenURI,\\r\\n        address newTokenAddress,\\r\\n        string calldata tokenName,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external onlyOwner {\\r\\n        require(maxBet > minBet, 'Min bet bigger than max bet');\\r\\n        require(fee < 100, 'fee should be less than 100%');\\r\\n\\r\\n        if (newTokenAddress != address(0)) {\\r\\n            address BNB_Token_Pair = IPancakeFactory(pancakeFactoryAddr).getPair(newTokenAddress, wbnbAddr);\\r\\n            require(BNB_Token_Pair != address(0));\\r\\n        }\\r\\n\\r\\n        _tokenIds.increment();\\r\\n        uint256 newItemId = _tokenIds.current();\\r\\n\\r\\n        _mint(msg.sender, newItemId);\\r\\n        _setTokenURI(newItemId, tokenURI);\\r\\n\\r\\n        IRoulettePot(rouletteContractAddr).addCasino(newItemId, newTokenAddress, tokenName, maxBet, minBet, fee);\\r\\n        emit Mint(newItemId);\\r\\n    }\\r\\n\\r\\n    function setRouletteContractAddress(address addr) external onlyOwner {\\r\\n        rouletteContractAddr = addr;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721URIStorage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"../../../interfaces/IERC4906.sol\\\";\\n\\n/**\\n * @dev ERC721 token with storage based token URI management.\\n */\\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\\n    using Strings for uint256;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\\n        return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = _baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n\\n        return super.tokenURI(tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Emits {MetadataUpdate}.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721URIStorage: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n\\n        emit MetadataUpdate(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\\n     * the storage mapping.\\n     */\\n    function _burn(uint256 tokenId) internal virtual override {\\n        super._burn(tokenId);\\n\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoulette.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IRoulettePot {\\r\\n    struct Casino {\\r\\n        address tokenAddress;\\r\\n        string tokenName;\\r\\n        uint256 liquidity;\\r\\n        uint256 maxBet;\\r\\n        uint256 minBet;\\r\\n        uint256 fee;\\r\\n    }\\r\\n    struct Bet {\\r\\n        /* 5: number, 4: even, odd, 3: 18s, 2: 12s, 1: row, 0: black, red */\\r\\n        uint8 betType;\\r\\n        uint8 number;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    event RouletteWon(uint256 tokenId, address winner, uint256 nonce, uint256 amount);\\r\\n    event RouletteLost(uint256 tokenId, address loser, uint256 nonce);\\r\\n    event TransferFailed(uint256 tokenId, address to, uint256 amount);\\r\\n\\r\\n    function addCasino(\\r\\n        uint256 tokenId,\\r\\n        address tokenAddress,\\r\\n        string memory tokenName,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external;\\r\\n\\r\\n    function getMaximumReward(Bet[] calldata bets) external pure returns (uint256);\\r\\n\\r\\n    function placeBetsWithTokens(uint256 tokenId, Bet[] calldata bets) external;\\r\\n\\r\\n    function placeBetsWithEth(uint256 tokenId, Bet[] calldata bets) external payable;\\r\\n\\r\\n    function addLiquidtyWithTokens(uint256 tokenId, uint256 amount) external;\\r\\n\\r\\n    function removeLiquidtyWithTokens(uint256 tokenId, uint256 amount) external;\\r\\n\\r\\n    function addLiquidtyWithEth(uint256 tokenId, uint256 amount) external payable;\\r\\n\\r\\n    function removeLiquidtyWithEth(uint256 tokenId, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"contracts/TYRH/BURN/OGNFT.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol';\\r\\nimport '@openzeppelin/contracts/utils/Counters.sol';\\r\\n\\r\\ncontract TYRHOGNFT is ERC721URIStorageUpgradeable, OwnableUpgradeable {\\r\\n    using Counters for Counters.Counter;\\r\\n    Counters.Counter public _tokenIds;\\r\\n\\r\\n    event Mint(uint256 tokenId, uint256 typeId, uint256 weight, address receiver, uint256 amount);\\r\\n\\r\\n    struct NFT {\\r\\n        uint256 tokenId;\\r\\n        uint256 weight;\\r\\n    }\\r\\n\\r\\n    struct NFTWithOwner {\\r\\n        uint256 tokenId;\\r\\n        uint256 weight;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    NFT[] public nfts;\\r\\n    mapping(uint256 => string) uris;\\r\\n\\r\\n    function initialize() external initializer {\\r\\n        __ERC721_init('TYRHOGNFT', 'TYRHOGNFT');\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        NFT memory nft = nfts[tokenId];\\r\\n        return uris[nft.weight];\\r\\n    }\\r\\n\\r\\n    function addNFTs(uint256[] calldata weights, address[] calldata owners) external onlyOwner {\\r\\n        uint256 length = weights.length;\\r\\n        uint256 tokenIds = nfts.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            nfts.push(NFT(tokenIds + i, weights[i]));\\r\\n            _mint(owners[i], tokenIds + i);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getNFTs(uint256 start, uint256 length) external view returns (NFTWithOwner[] memory list) {\\r\\n        if (start >= nfts.length) return list;\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > nfts.length) end = nfts.length;\\r\\n        list = new NFTWithOwner[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            NFT memory nft = nfts[i];\\r\\n            list[i - start].tokenId = i;\\r\\n            list[i - start].weight = nft.weight;\\r\\n            list[i - start].owner = ownerOf(nft.tokenId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateNFTs(uint256[] calldata tokenIds, uint256[] calldata weights) external onlyOwner {\\r\\n        uint256 length = tokenIds.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            nfts[tokenIds[i]].weight = weights[i];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev ERC721 token with storage based token URI management.\\n */\\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\\n    function __ERC721URIStorage_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\\n    }\\n    using StringsUpgradeable for uint256;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = _baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n\\n        return super.tokenURI(tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721URIStorage: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\\n     * the storage mapping.\\n     */\\n    function _burn(uint256 tokenId) internal virtual override {\\n        super._burn(tokenId);\\n\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/TYRH/BURN/BoosterNFT.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';\\r\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/Counters.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\n\\r\\ncontract TYRHBoosterNFT is ERC721URIStorage, Ownable {\\r\\n    using Counters for Counters.Counter;\\r\\n    Counters.Counter public _tokenIds;\\r\\n\\r\\n    IERC20 public token;\\r\\n    event Mint(uint256 tokenId, uint256 typeId, uint256 weight, address receiver, uint256 amount);\\r\\n    struct NFTType {\\r\\n        uint256 category; // 0: claim booster, 1: special, 2: league booster\\r\\n        uint256 typeId;\\r\\n        uint256 value;\\r\\n        string uri;\\r\\n        bool enabled;\\r\\n        bool isRandom;\\r\\n        bool isFixed;\\r\\n        uint256 max;\\r\\n        uint256 min;\\r\\n        uint256 defaultWeight;\\r\\n    }\\r\\n\\r\\n    struct NFT {\\r\\n        uint256 typeId;\\r\\n        uint256 tokenId;\\r\\n        uint256 weight;\\r\\n    }\\r\\n\\r\\n    struct NFTWithOwner {\\r\\n        uint256 typeId;\\r\\n        uint256 tokenId;\\r\\n        uint256 weight;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    mapping(address => uint256) public addressToBurntAmount;\\r\\n    NFTType[] public nftTypes;\\r\\n    NFT[] public nfts;\\r\\n    mapping(uint256 => mapping(uint256 => string)) public uris;\\r\\n\\r\\n    constructor(address tokenAddr) ERC721('TYRHNFTTEST', 'TYRHNFTTEST') {\\r\\n        token = IERC20(tokenAddr);\\r\\n    }\\r\\n\\r\\n    function addNFTType(\\r\\n        uint256 category,\\r\\n        uint256 value,\\r\\n        string memory uri,\\r\\n        bool isRandom,\\r\\n        bool isFixed,\\r\\n        uint256 max,\\r\\n        uint256 min,\\r\\n        uint256 defaultWeight\\r\\n    ) public onlyOwner {\\r\\n        uint256 newTypeId = nftTypes.length;\\r\\n        nftTypes.push(NFTType(category, newTypeId, value, uri, true, isRandom, isFixed, max, min, defaultWeight));\\r\\n    }\\r\\n\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.prevrandao, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev mint Booster NFTS\\r\\n     *\\r\\n     * @param typeId typeId for NFT\\r\\n     */\\r\\n    function mint(uint256 typeId) external {\\r\\n        NFTType memory nftType = nftTypes[typeId];\\r\\n        require(nftType.enabled, 'type not enabled');\\r\\n\\r\\n        // Burn token\\r\\n        uint256 amount = nftTypes[typeId].value;\\r\\n        token.transferFrom(msg.sender, address(0xdead), amount);\\r\\n\\r\\n        // Mint NFT\\r\\n        uint256 newItemId = _tokenIds.current();\\r\\n        _mint(msg.sender, newItemId);\\r\\n\\r\\n        // Set weight\\r\\n        uint256 weight = nftType.defaultWeight;\\r\\n        if (nftType.isRandom) {\\r\\n            uint256 length = nftType.max - nftType.min + 1;\\r\\n            weight = (fullFillRandomness() % length) + nftType.min;\\r\\n        }\\r\\n        nfts.push(NFT(typeId, newItemId, weight));\\r\\n        emit Mint(newItemId, typeId, weight, msg.sender, amount);\\r\\n        _tokenIds.increment();\\r\\n    }\\r\\n\\r\\n    function setTokenAddr(address addr) external onlyOwner {\\r\\n        token = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function updateNFTType(\\r\\n        uint256 typeId,\\r\\n        uint256 category,\\r\\n        uint256 value,\\r\\n        string memory uri,\\r\\n        bool enabled,\\r\\n        bool isRandom,\\r\\n        bool isFixed,\\r\\n        uint256 max,\\r\\n        uint256 min,\\r\\n        uint256 defaultWeight\\r\\n    ) external onlyOwner {\\r\\n        NFTType storage item = nftTypes[typeId];\\r\\n        item.category = category;\\r\\n        item.value = value;\\r\\n        item.uri = uri;\\r\\n        item.enabled = enabled;\\r\\n        item.isRandom = isRandom;\\r\\n        item.isFixed = isFixed;\\r\\n        item.max = max;\\r\\n        item.min = min;\\r\\n        item.defaultWeight = defaultWeight;\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        NFTType memory nftType = nftTypes[nfts[tokenId].typeId];\\r\\n        uint256 typeId = nfts[tokenId].typeId;\\r\\n        uint256 weight = nfts[tokenId].weight;\\r\\n        if (bytes(uris[typeId][weight]).length != 0) {\\r\\n            return uris[typeId][weight];\\r\\n        }\\r\\n        return string.concat(nftType.uri, '/', Strings.toString(weight), '.json');\\r\\n    }\\r\\n\\r\\n    function getNFTTypes() external view returns (NFTType[] memory) {\\r\\n        return nftTypes;\\r\\n    }\\r\\n\\r\\n    function setURI(uint256 typeId, uint256 weight, string memory value) external onlyOwner {\\r\\n        uris[typeId][weight] = value;\\r\\n    }\\r\\n\\r\\n    function getNFTs(uint256 start, uint256 length) external view returns (NFTWithOwner[] memory list) {\\r\\n        if (start >= nfts.length) return list;\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > nfts.length) end = nfts.length;\\r\\n        list = new NFTWithOwner[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            NFT memory nft = nfts[i];\\r\\n            list[i - start].tokenId = nft.tokenId;\\r\\n            list[i - start].typeId = nft.typeId;\\r\\n            list[i - start].weight = nft.weight;\\r\\n            list[i - start].owner = ownerOf(nft.tokenId);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Water/Water.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract Water is ERC20, Ownable {\\r\\n    constructor() ERC20('WATER', 'WATER') {\\r\\n        _mint(msg.sender, 100 * 1000000000 * 10 ** 18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Water/Holy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract Holy is ERC20, Ownable {\\r\\n    constructor() ERC20('HOLY', 'HOLY') {\\r\\n        _mint(msg.sender, 5000 * 10 ** 18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Plant/Seed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract Seed is ERC20, Ownable {\\r\\n    constructor() ERC20('SEED', 'SEED') {\\r\\n        _mint(msg.sender, 10000 * 10 ** 18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Plant/Plant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract Plant is ERC20, Ownable {\\r\\n    constructor() ERC20('PLANT', 'PLANT') {\\r\\n        _mint(msg.sender, 100 * 1000000000 * 10 ** 18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/BURN/BURN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract BURN is ERC20, Ownable {\\r\\n    constructor() ERC20('BURN', 'BURN') {\\r\\n        _mint(msg.sender, 100 * 1000000000 * 10 ** 18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/BURN/BonFire.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract BonFire is Ownable {\\r\\n    IERC20 public token;\\r\\n    uint256 public yield;\\r\\n    uint256 public minimumLockTime;\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 amount;\\r\\n        uint256 timestamp;\\r\\n    }\\r\\n    mapping(address => StakingInfo) public userInfo;\\r\\n    event Staked(address user, uint256 amount);\\r\\n    event UnStaked(address user);\\r\\n\\r\\n    constructor(address tokenAddr) {\\r\\n        yield = 10; // 1%\\r\\n        minimumLockTime = 3600 * 24 * 3; // 3 days\\r\\n        token = IERC20(tokenAddr);\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) external {\\r\\n        StakingInfo storage info = userInfo[msg.sender];\\r\\n        require(info.timestamp == 0, 'Already Staking');\\r\\n        token.transferFrom(msg.sender, address(this), amount);\\r\\n        info.amount = amount;\\r\\n        info.timestamp = block.timestamp;\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function unStake() external {\\r\\n        StakingInfo storage info = userInfo[msg.sender];\\r\\n        require(info.timestamp != 0, 'stake first');\\r\\n        require(info.timestamp + minimumLockTime < block.timestamp, \\\"Can't unstake yet\\\");\\r\\n        uint256 oneDay = 3600 * 24;\\r\\n        uint256 daysPassed = (block.timestamp - info.timestamp) / oneDay;\\r\\n        uint256 amount = info.amount;\\r\\n        for (uint256 i = 0; i < daysPassed; i++) {\\r\\n            amount = (amount * (1000 + yield)) / 1000;\\r\\n        }\\r\\n        info.amount = 0;\\r\\n        info.timestamp = 0;\\r\\n        token.transfer(msg.sender, amount);\\r\\n        emit UnStaked(msg.sender);\\r\\n    }\\r\\n\\r\\n    function setMinimumLockTime(uint256 time) external onlyOwner {\\r\\n        minimumLockTime = time;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyOwner {\\r\\n        token = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setYield(uint256 value) external onlyOwner {\\r\\n        yield = value;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Token1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\r\\n\\r\\ncontract Token1 is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\\r\\n        _mint(msg.sender, 1000000000 * 10 ** 18);\\r\\n    }\\r\\n\\r\\n    function mint(address to, uint256 amount) external {\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n\\r\\n    // function burn(uint256 amount) external {\\r\\n    //     _burn(msg.sender, amount);\\r\\n    // }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceCall/FUSDT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\r\\n\\r\\ncontract FakeUSDT is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor() ERC20('FakeUSDT', 'FUSDT') {\\r\\n        _mint(msg.sender, 1000000000 * 10 ** 18);\\r\\n    }\\r\\n\\r\\n    function mint(address to, uint256 amount) external {\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n\\r\\n    function bulkTransfer(address[] calldata accounts, uint256[] calldata amounts) external {\\r\\n        for (uint256 i = 0; i < accounts.length; i++) {\\r\\n            transfer(accounts[i], amounts[i]);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PotContract/PotContractv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '../interfaces/IPancakePair.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IBNBP.sol';\\r\\n\\r\\n// File: PotContract.sol\\r\\n\\r\\ncontract PotLottery is ReentrancyGuard {\\r\\n    /*\\r\\n     ***Start of function, Enum, Variables, array and mappings to set and edit the Pot State such that accounts can enter the pot\\r\\n     */\\r\\n\\r\\n    struct Token {\\r\\n        address tokenAddress;\\r\\n        address pairAddress;\\r\\n        bool swapToBNB;\\r\\n        bool isStable;\\r\\n        string tokenSymbol;\\r\\n        uint256 tokenDecimal;\\r\\n    }\\r\\n\\r\\n    enum POT_STATE {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    address public owner;\\r\\n    address public admin;\\r\\n\\r\\n    address public wbnbAddr;\\r\\n    address public busdAddr;\\r\\n    address public pancakeswapV2FactoryAddr;\\r\\n    IPancakeRouter02 public router;\\r\\n\\r\\n    POT_STATE public pot_state;\\r\\n\\r\\n    mapping(string => Token) public tokenWhiteList;\\r\\n    string[] public tokenWhiteListNames;\\r\\n    uint256 public minEntranceInUsd;\\r\\n    uint256 public potCount;\\r\\n    uint256 public potDuration;\\r\\n    uint256 public percentageFee;\\r\\n    uint256 public PotEntryCount;\\r\\n    uint256 public entriesCount;\\r\\n    address public BNBP_Address;\\r\\n    uint256 public BNBP_Standard;\\r\\n\\r\\n    mapping(string => uint256) public tokenLatestPriceFeed;\\r\\n\\r\\n    uint256 public potLiveTime;\\r\\n    uint256 public potStartTime;\\r\\n    uint256 public timeBeforeRefund;\\r\\n    uint256 public participantCount;\\r\\n    address[] public participants;\\r\\n    string[] public tokensInPotNames;\\r\\n    address[] public entriesAddress;\\r\\n    uint256[] public entriesUsdValue;\\r\\n    string[] public entriesTokenName;\\r\\n    uint256[] public entriesTokenAmount;\\r\\n    address public LAST_POT_WINNER;\\r\\n\\r\\n    // Tokenomics\\r\\n    uint256 public airdropInterval;\\r\\n    uint256 public burnInterval;\\r\\n    uint256 public lotteryInterval;\\r\\n    uint256 constant maxInterval = 24 * 3600 * 100; //100 days\\r\\n\\r\\n    uint8 public airdropPercentage;\\r\\n    uint8 public burnPercentage;\\r\\n    uint8 public lotteryPercentage;\\r\\n\\r\\n    uint256 public airdropPool;\\r\\n    uint256 public burnPool;\\r\\n    uint256 public lotteryPool;\\r\\n\\r\\n    uint256 public stakingMinimum;\\r\\n    uint256 public minimumStakingTime;\\r\\n\\r\\n    string[] public adminFeeToken;\\r\\n    mapping(string => uint256) public adminFeeTokenValues;\\r\\n\\r\\n    mapping(string => uint256) public tokenTotalEntry;\\r\\n\\r\\n    address public hotWalletAddress;\\r\\n    uint256 public hotWalletMinBalance;\\r\\n    uint256 public hotWalletMaxBalance;\\r\\n\\r\\n    mapping(address => bool) public allowedContracts;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n        admin = _owner;\\r\\n        pot_state = POT_STATE.WAITING;\\r\\n        potDuration = 180; // 3 minutes\\r\\n        minEntranceInUsd = 49000000000; //490 cents ~ 1$\\r\\n        percentageFee = 3;\\r\\n        potCount = 1943;\\r\\n        timeBeforeRefund = 86400; //24 hours\\r\\n        PotEntryCount = 0;\\r\\n        entriesCount = 14215;\\r\\n\\r\\n        airdropInterval = 86400 * 30;\\r\\n        burnInterval = 86400;\\r\\n        lotteryInterval = 86400 * 7;\\r\\n\\r\\n        airdropPercentage = 75;\\r\\n        burnPercentage = 20;\\r\\n        lotteryPercentage = 5;\\r\\n\\r\\n        stakingMinimum = 5 * 10 ** 18; // 5 BNBP\\r\\n        minimumStakingTime = 100 * 86400; // 100 days\\r\\n\\r\\n        wbnbAddr = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\r\\n        busdAddr = 0x4608Ea31fA832ce7DCF56d78b5434b49830E91B1;\\r\\n        pancakeswapV2FactoryAddr = 0x6725F303b657a9451d8BA641348b6761A6CC7a17;\\r\\n        router = IPancakeRouter02(0xD99D1c33F9fC3444f8101754aBC46c52416550D1);\\r\\n\\r\\n        BNBP_Address = 0xcAf4f8C9f1e511B3FEb3226Dc3534E4c4b2f3D70;\\r\\n        BNBP_Standard = 100;\\r\\n        hotWalletAddress = 0xCf4560A9c128B844F139581A75218e757cc1bbb2;\\r\\n        hotWalletMinBalance = 5 * 10 ** 18;\\r\\n        hotWalletMaxBalance = 10 * 10 ** 18;\\r\\n\\r\\n        // addToken(\\r\\n        //     'BUSD',\\r\\n        //     'BUSD',\\r\\n        //     0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56,\\r\\n        //     0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16,\\r\\n        //     true,\\r\\n        //     true,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'USDT',\\r\\n        //     'USDT',\\r\\n        //     0x55d398326f99059fF775485246999027B3197955,\\r\\n        //     0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE,\\r\\n        //     true,\\r\\n        //     true,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'USDC',\\r\\n        //     'USDC',\\r\\n        //     0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d,\\r\\n        //     0xd99c7F6C65857AC913a8f880A4cb84032AB2FC5b,\\r\\n        //     true,\\r\\n        //     true,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'BNB',\\r\\n        //     'BNB',\\r\\n        //     0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c,\\r\\n        //     0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16,\\r\\n        //     false,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'Wrapped BNB',\\r\\n        //     'WBNB',\\r\\n        //     0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c,\\r\\n        //     0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16,\\r\\n        //     true,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'BNBP',\\r\\n        //     'BNBP',\\r\\n        //     0x4D9927a8Dc4432B93445dA94E4084D292438931F,\\r\\n        //     0x4C736d24d72D874cc2465553500c1Ff3Fc7b3BDA,\\r\\n        //     true,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'Cake',\\r\\n        //     'CAKE',\\r\\n        //     0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82,\\r\\n        //     0x0eD7e52944161450477ee417DE9Cd3a859b14fD0,\\r\\n        //     true,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'Ethereum',\\r\\n        //     'ETH',\\r\\n        //     0x2170Ed0880ac9A755fd29B2688956BD959F933F8,\\r\\n        //     0x74E4716E431f45807DCF19f284c7aA99F18a4fbc,\\r\\n        //     true,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'Cardano Token',\\r\\n        //     'ADA',\\r\\n        //     0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47,\\r\\n        //     0x28415ff2C35b65B9E5c7de82126b4015ab9d031F,\\r\\n        //     true,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n        // addToken(\\r\\n        //     'SHIBA INU',\\r\\n        //     'SHIBA',\\r\\n        //     0x2859e4544C4bB03966803b044A93563Bd2D0DD4D,\\r\\n        //     0x6b7b3523a6660a5fcE3c28E1536CC8dd8D57f7E0,\\r\\n        //     true,\\r\\n        //     false,\\r\\n        //     18\\r\\n        // );\\r\\n\\r\\n        // UpdatePrice('BUSD');\\r\\n        // UpdatePrice('USDT');\\r\\n        // UpdatePrice('USDC');\\r\\n        // UpdatePrice('BNB');\\r\\n        // UpdatePrice('Wrapped BNB');\\r\\n        // UpdatePrice('BNBP');\\r\\n        // UpdatePrice('Cake');\\r\\n        // UpdatePrice('Ethereum');\\r\\n        // UpdatePrice('Cardano Token');\\r\\n        // UpdatePrice('SHIBA INU');\\r\\n\\r\\n        // changeAdmin(0x5E12E3D87dfD69ed40862c8e58027C83A07E40Fd);\\r\\n        // changeOwner(0x7804f2Bf970C857c8252Bd6d5eFaBDBc77F63011);\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin || msg.sender == owner, '!admin');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, '!owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validBNBP() {\\r\\n        require(BNBP_Address != address(0), '!BNBP Addr');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender, 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //-----I added a new event\\r\\n    event BalanceNotEnough(address indexed userAddress, string tokenName);\\r\\n\\r\\n    event EnteredPot(\\r\\n        string tokenName, //\\r\\n        address indexed userAddress, //\\r\\n        uint256 indexed potRound,\\r\\n        uint256 usdValue,\\r\\n        uint256 amount,\\r\\n        uint256 indexed enteryCount, //\\r\\n        bool hasEntryInCurrentPot\\r\\n    );\\r\\n\\r\\n    event CalculateWinner(\\r\\n        address indexed winner,\\r\\n        uint256 indexed potRound,\\r\\n        uint256 potValue,\\r\\n        uint256 amount,\\r\\n        uint256 amountWon,\\r\\n        uint256 participants\\r\\n    );\\r\\n\\r\\n    event TokenSwapFailedString(string tokenName, string reason);\\r\\n    event TokenSwapFailedBytes(string tokenName, bytes reason);\\r\\n    event BurnSuccess(uint256 amount);\\r\\n    event AirdropSuccess(uint256 amount);\\r\\n    event LotterySuccess(address indexed winner);\\r\\n    event HotWalletSupplied(address addr, uint256 amount);\\r\\n\\r\\n    /**   @dev returns the usd value of a token amount\\r\\n     * @param _tokenName the name of the token\\r\\n     * @param _amount the amount of the token\\r\\n     * @return usdValue usd value of the token amount\\r\\n     */\\r\\n    function getTokenUsdValue(string memory _tokenName, uint256 _amount) public view returns (uint256) {\\r\\n        return ((tokenLatestPriceFeed[_tokenName] * _amount) / 10 ** tokenWhiteList[_tokenName].tokenDecimal);\\r\\n    }\\r\\n\\r\\n    /**   @dev changes contract owner address\\r\\n     * @param _owner the new owner\\r\\n     * @notice only the owner can call this function\\r\\n     */\\r\\n    function changeOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    /**   @dev changes contract admin address\\r\\n     * @param _adminAddress the new admin\\r\\n     * @notice only the owner can call this function\\r\\n     */\\r\\n    function changeAdmin(address _adminAddress) public onlyOwner {\\r\\n        admin = _adminAddress;\\r\\n    }\\r\\n\\r\\n    /**   @dev set the BNBP address\\r\\n     * @param _address the BNBP address\\r\\n     * @notice only the admin or owner can call this function\\r\\n     */\\r\\n    function setBNBPAddress(address _address) public onlyAdmin {\\r\\n        BNBP_Address = _address;\\r\\n    }\\r\\n\\r\\n    /**   @dev set the BNBP minimum balance to get 50% reduction in fee\\r\\n     * @param _amount the BNBP minimum balance for 50% reduction in fee\\r\\n     * @notice only the admin or owner can call this function\\r\\n     */\\r\\n    function setBNBP_Standard(uint256 _amount) public onlyAdmin {\\r\\n        BNBP_Standard = _amount;\\r\\n    }\\r\\n\\r\\n    /**   @dev add token to list of white listed token\\r\\n     * @param _tokenName the name of the token\\r\\n     * @param _tokenSymbol the symbol of the token\\r\\n     * @param _tokenAddress the address of the token\\r\\n     * @param _decimal the token decimal\\r\\n     * @notice only the admin or owner can call this function\\r\\n     */\\r\\n    //@edited__\\r\\n    function addToken(\\r\\n        string memory _tokenName,\\r\\n        string memory _tokenSymbol,\\r\\n        address _tokenAddress,\\r\\n        address _tokenPairAddress,\\r\\n        bool _swapToBNB,\\r\\n        bool _isStable,\\r\\n        uint256 _decimal\\r\\n    ) public onlyAdmin {\\r\\n        require(_tokenAddress != address(0), '0x');\\r\\n        if (tokenWhiteList[_tokenName].tokenAddress == address(0)) {\\r\\n            tokenWhiteListNames.push(_tokenName);\\r\\n        }\\r\\n        tokenWhiteList[_tokenName] = Token(\\r\\n            _tokenAddress,\\r\\n            _tokenPairAddress,\\r\\n            _swapToBNB,\\r\\n            _isStable,\\r\\n            _tokenSymbol,\\r\\n            _decimal\\r\\n        );\\r\\n        if (_isStable) {\\r\\n            updateTokenUsdValue(_tokenName, 10 ** 10);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev remove token from the list of white listed token\\r\\n     * @param _tokenName the name of the token\\r\\n     * @notice only the admin or owner can call this function\\r\\n     */\\r\\n    function removeToken(string memory _tokenName) public onlyAdmin {\\r\\n        for (uint256 index = 0; index < tokenWhiteListNames.length; index++) {\\r\\n            if (keccak256(bytes(_tokenName)) == keccak256(bytes(tokenWhiteListNames[index]))) {\\r\\n                delete tokenWhiteList[_tokenName];\\r\\n                delete tokenLatestPriceFeed[_tokenName];\\r\\n                tokenWhiteListNames[index] = tokenWhiteListNames[tokenWhiteListNames.length - 1];\\r\\n                tokenWhiteListNames.pop();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev set token usd value\\r\\n     * @param _tokenName the name of the token\\r\\n     * @param _valueInUsd the usd value to set token price to\\r\\n     * @notice set BNBP price to 30usd when price is below 30usd on dex\\r\\n     * @notice add extra 10% to price of BNBP when price above 30usd on dex\\r\\n     */\\r\\n    function updateTokenUsdValue(string memory _tokenName, uint256 _valueInUsd) internal tokenInWhiteList(_tokenName) {\\r\\n        if (keccak256(bytes(_tokenName)) == keccak256(bytes('BNBP'))) {\\r\\n            tokenLatestPriceFeed[_tokenName] = _valueInUsd < 30 * 10 ** 10 ? 30 * 10 ** 10 : (_valueInUsd * 11) / 10;\\r\\n        } else {\\r\\n            tokenLatestPriceFeed[_tokenName] = _valueInUsd;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier tokenInWhiteList(string memory _tokenName) {\\r\\n        bool istokenWhiteListed = false;\\r\\n        for (uint256 index = 0; index < tokenWhiteListNames.length; index++) {\\r\\n            if (keccak256(bytes(tokenWhiteListNames[index])) == keccak256(bytes(_tokenName))) {\\r\\n                istokenWhiteListed = true;\\r\\n            }\\r\\n        }\\r\\n        require(istokenWhiteListed, '!supp');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**   @dev Attempts to enter pot with an array of values\\r\\n     * @param _tokenNames an array of token names to enter pot with\\r\\n     * @param _amounts an array of token amount to enter pot with\\r\\n     * @param _participants an array of participant address to enter pot with\\r\\n     * @notice attempts to calculate winner firstly if pot duration is over\\r\\n     * @notice only callable by the admin or owner account\\r\\n     * @notice entry will not be allowed if contract token balance is not enough or entry is less than minimum usd value\\r\\n     * @notice entry with native token is not allowed\\r\\n     */\\r\\n    ///This is the Centralized enterPot function\\r\\n    function EnterPot(\\r\\n        string[] memory _tokenNames,\\r\\n        uint256[] memory _amounts,\\r\\n        address[] memory _participants\\r\\n    ) external excludeContract {\\r\\n        require(msg.sender == hotWalletAddress, '!hot wallet');\\r\\n\\r\\n        for (uint256 index = 0; index < _tokenNames.length; index++) {\\r\\n            if (\\r\\n                (keccak256(bytes(_tokenNames[index])) == keccak256(bytes('BNB'))) ||\\r\\n                (getTokenUsdValue(_tokenNames[index], _amounts[index]) < minEntranceInUsd)\\r\\n            ) {\\r\\n                continue;\\r\\n            }\\r\\n            if (\\r\\n                IPRC20(tokenWhiteList[(_tokenNames[index])].tokenAddress).balanceOf(address(this)) <\\r\\n                (_amounts[index] + adminFeeTokenValues[_tokenNames[index]]) + tokenTotalEntry[_tokenNames[index]]\\r\\n            ) {\\r\\n                emit BalanceNotEnough(_participants[index], _tokenNames[index]);\\r\\n                continue;\\r\\n            }\\r\\n            _EnterPot(_tokenNames[index], _amounts[index], _participants[index]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev Attempts to enter pot with an array of values\\r\\n     * @param _tokenName an array of token names to enter pot with\\r\\n     * @param _amount an array of token amount to enter pot with\\r\\n     * @param _participant an array of participant address to enter pot with\\r\\n     * @notice attempts to calculate winner firstly if pot duration is over\\r\\n     * @notice publicly callable by any address\\r\\n     * @notice entry will not be allowed if approved value is less than _amounts or entry is less than minimum usd value\\r\\n     * @notice entry with native token is not allowed\\r\\n     */\\r\\n    ///This is the Decentralized enterPot function\\r\\n    function enterPot(string memory _tokenName, uint256 _amount, address _participant) external excludeContract {\\r\\n        require(keccak256(bytes(_tokenName)) != keccak256(bytes('BNB')), 'BNB');\\r\\n        require(getTokenUsdValue(_tokenName, _amount) >= minEntranceInUsd, 'Min');\\r\\n\\r\\n        IPRC20(tokenWhiteList[_tokenName].tokenAddress).transferFrom(_participant, address(this), _amount);\\r\\n        _EnterPot(_tokenName, _amount, _participant);\\r\\n    }\\r\\n\\r\\n    /**   @dev Attempts to enter a single pot entry\\r\\n     * @param _tokenName token name to enter pot with\\r\\n     * @param _amount token amount to enter pot with\\r\\n     * @param _participant participant address to enter pot with\\r\\n     */\\r\\n    function _EnterPot(string memory _tokenName, uint256 _amount, address _participant) internal {\\r\\n        if ((potLiveTime + potDuration) <= block.timestamp && (participantCount > 1) && (potStartTime != 0)) {\\r\\n            calculateWinner();\\r\\n        }\\r\\n        if (participantCount == 1) {\\r\\n            UpdatePrice(_tokenName);\\r\\n        }\\r\\n        if (participantsTotalEntryInUsd(_participant) == 0) {\\r\\n            _addToParticipants(_participant);\\r\\n        }\\r\\n        if (tokenTotalEntry[_tokenName] == 0) {\\r\\n            tokensInPotNames.push(_tokenName);\\r\\n        }\\r\\n\\r\\n        tokenTotalEntry[_tokenName] += _amount;\\r\\n\\r\\n        //@optimize\\r\\n        if (entriesAddress.length == PotEntryCount) {\\r\\n            entriesAddress.push(_participant);\\r\\n            entriesUsdValue.push(getTokenUsdValue(_tokenName, _amount));\\r\\n            entriesTokenName.push(_tokenName);\\r\\n            entriesTokenAmount.push(_amount);\\r\\n        } else {\\r\\n            entriesAddress[PotEntryCount] = _participant;\\r\\n            entriesUsdValue[PotEntryCount] = getTokenUsdValue(_tokenName, _amount);\\r\\n            entriesTokenName[PotEntryCount] = _tokenName;\\r\\n            entriesTokenAmount[PotEntryCount] = _amount;\\r\\n        }\\r\\n\\r\\n        if (participantCount == 2 && pot_state != POT_STATE.LIVE) {\\r\\n            potLiveTime = block.timestamp;\\r\\n            pot_state = POT_STATE.LIVE;\\r\\n        }\\r\\n        if (PotEntryCount == 0) {\\r\\n            pot_state = POT_STATE.STARTED;\\r\\n            potStartTime = block.timestamp;\\r\\n        }\\r\\n        PotEntryCount++;\\r\\n        entriesCount++;\\r\\n        emit EnteredPot(\\r\\n            _tokenName,\\r\\n            _participant,\\r\\n            potCount,\\r\\n            getTokenUsdValue(_tokenName, _amount),\\r\\n            _amount,\\r\\n            entriesCount,\\r\\n            participantsTotalEntryInUsd(_participant) == 0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**   @dev Attempts to calculate pot round winner\\r\\n     */\\r\\n\\r\\n    function calculateWinner() public nonReentrant {\\r\\n        if ((potLiveTime + potDuration) <= block.timestamp && (participantCount > 1) && (potStartTime != 0)) {\\r\\n            uint256 _totalPotUsdValue = totalPotUsdValue();\\r\\n            address pot_winner = determineWinner(_totalPotUsdValue);\\r\\n            uint256 _usdAmt = getAmountToPayAsFees(pot_winner, _totalPotUsdValue);\\r\\n            uint256 valueToPay = 0;\\r\\n            do {\\r\\n                string memory _tokenHigh = getPotTokenWithHighestValue();\\r\\n                valueToPay =\\r\\n                    (_usdAmt * 10 ** tokenWhiteList[_tokenHigh].tokenDecimal) /\\r\\n                    tokenLatestPriceFeed[_tokenHigh];\\r\\n                if (valueToPay > tokenTotalEntry[_tokenHigh]) {\\r\\n                    valueToPay = tokenTotalEntry[_tokenHigh];\\r\\n                }\\r\\n                deductAmountToPayAsFees(_tokenHigh, valueToPay);\\r\\n                tokenTotalEntry[_tokenHigh] -= valueToPay;\\r\\n                uint256 _usdValueToPay = getTokenUsdValue(_tokenHigh, valueToPay);\\r\\n\\r\\n                _usdAmt -= _usdAmt - _usdValueToPay <= minEntranceInUsd ? _usdAmt : _usdValueToPay;\\r\\n            } while (_usdAmt > 0);\\r\\n\\r\\n            for (uint256 index = 0; index < tokensInPotNames.length; index++) {\\r\\n                _payAccount(tokensInPotNames[index], pot_winner, tokenTotalEntry[tokensInPotNames[index]]);\\r\\n            } //Transfer all required tokens to the Pot winner\\r\\n            LAST_POT_WINNER = pot_winner;\\r\\n\\r\\n            emit CalculateWinner(\\r\\n                pot_winner,\\r\\n                potCount,\\r\\n                _totalPotUsdValue,\\r\\n                participantsTotalEntryInUsd(pot_winner),\\r\\n                (_totalPotUsdValue * (100 - percentageFee)) / 100,\\r\\n                participantCount\\r\\n            );\\r\\n            startNewPot();\\r\\n            //Start the new Pot and set calculating winner to true\\r\\n            //After winner has been sent the token then set calculating winner to false\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev Attempts to select a random winner\\r\\n     */\\r\\n    function determineWinner(uint256 totalUsdValue) internal view returns (address winner) {\\r\\n        uint256 winning_point = fullFillRandomness() % totalUsdValue;\\r\\n        for (uint256 index = 0; index < PotEntryCount; index++) {\\r\\n            if (winning_point <= entriesUsdValue[index]) {\\r\\n                //That means that the winner has been found here\\r\\n                winner = entriesAddress[index];\\r\\n                return winner;\\r\\n            }\\r\\n            winning_point -= entriesUsdValue[index];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @dev returns the totalUsd value of an address in the latest pot\\r\\n    @return usdValue commulative usd value of a particular address in current pot\\r\\n */\\r\\n    function participantsTotalEntryInUsd(address _address) internal view returns (uint256 usdValue) {\\r\\n        usdValue = 0;\\r\\n        for (uint256 index = 0; index < PotEntryCount; index++) {\\r\\n            if (_address == entriesAddress[index]) {\\r\\n                usdValue += entriesUsdValue[index];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function totalPotUsdValue() internal view returns (uint256 totalUsd) {\\r\\n        for (uint256 index = 0; index < PotEntryCount; index++) {\\r\\n            totalUsd += entriesUsdValue[index];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev process a refund for user if there is just one participant for 24 hrs\\r\\n     */\\r\\n    function getRefund() public nonReentrant {\\r\\n        if (timeBeforeRefund + potStartTime < block.timestamp && participantCount == 1 && (potStartTime != 0)) {\\r\\n            uint256 _totalPotUsdValue = totalPotUsdValue();\\r\\n            uint256 _usdAmt = getAmountToPayAsFees(participants[0], _totalPotUsdValue);\\r\\n            uint256 valueToPay = 0;\\r\\n            do {\\r\\n                string memory _tokenHigh = getPotTokenWithHighestValue();\\r\\n\\r\\n                valueToPay =\\r\\n                    (_usdAmt * 10 ** tokenWhiteList[_tokenHigh].tokenDecimal) /\\r\\n                    tokenLatestPriceFeed[_tokenHigh];\\r\\n                if (valueToPay >= tokenTotalEntry[_tokenHigh]) valueToPay = tokenTotalEntry[_tokenHigh];\\r\\n\\r\\n                deductAmountToPayAsFees(_tokenHigh, valueToPay);\\r\\n                tokenTotalEntry[_tokenHigh] -= valueToPay;\\r\\n                uint256 _usdValueToPay = getTokenUsdValue(_tokenHigh, valueToPay);\\r\\n                _usdAmt -= _usdAmt - _usdValueToPay <= minEntranceInUsd ? _usdAmt : _usdValueToPay;\\r\\n            } while (_usdAmt > 0);\\r\\n\\r\\n            for (uint256 index = 0; index < tokensInPotNames.length; index++) {\\r\\n                _payAccount(tokensInPotNames[index], participants[0], tokenTotalEntry[tokensInPotNames[index]]);\\r\\n            }\\r\\n            startNewPot();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev remove the amount to pay as fee\\r\\n     * @param _tokenName the name of the token to remove the fee from\\r\\n     * @param _value the amount to remove as fee\\r\\n     */\\r\\n    function deductAmountToPayAsFees(string memory _tokenName, uint256 _value) internal {\\r\\n        bool tokenInFee = false;\\r\\n        for (uint256 index = 0; index < adminFeeToken.length; index++) {\\r\\n            if (keccak256(bytes(_tokenName)) == keccak256(bytes(adminFeeToken[index]))) {\\r\\n                tokenInFee = true;\\r\\n            }\\r\\n        }\\r\\n        if (!tokenInFee) {\\r\\n            adminFeeToken.push(_tokenName);\\r\\n        }\\r\\n        adminFeeTokenValues[_tokenName] += _value;\\r\\n        if (keccak256(bytes(_tokenName)) == keccak256(bytes('BNBP'))) {\\r\\n            _updateTokenomicsPool(_value, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev remove the amount to pay as fee\\r\\n     * @param _address the name of the token to remove the fee from\\r\\n     * @return valueToPay the usd amount to remove as fee\\r\\n     * @notice _address current BNBP holding determine how much fee reduction you get\\r\\n     */\\r\\n    function getAmountToPayAsFees(address _address, uint256 _potUsdValue) internal view returns (uint256 valueToPay) {\\r\\n        _potUsdValue = (_potUsdValue * percentageFee) / 100;\\r\\n        uint256 balance = IPRC20(BNBP_Address).balanceOf(_address);\\r\\n        valueToPay = (balance >= BNBP_Standard)\\r\\n            ? _potUsdValue / 2\\r\\n            : (_potUsdValue - (balance * _potUsdValue) / (2 * BNBP_Standard));\\r\\n    }\\r\\n\\r\\n    /**   @dev attempt to update token price from dex\\r\\n          @notice price is only updated when there are no participant in pot\\r\\n    */\\r\\n    function UpdatePrice(string memory _tokenName) public nonReentrant excludeContract {\\r\\n        Token storage _token = tokenWhiteList[_tokenName];\\r\\n        if (_token.isStable) {\\r\\n            return;\\r\\n        }\\r\\n        (uint256 Res0, uint256 Res1) = _getTokenReserves(_token.pairAddress, _token.tokenAddress);\\r\\n        uint256 res1 = Res1 * (10 ** _token.tokenDecimal);\\r\\n        uint256 price = res1 / Res0;\\r\\n        if (_token.swapToBNB && keccak256(bytes(_token.tokenSymbol)) != keccak256(bytes('WBNB'))) {\\r\\n            uint256 _BNBPrice = getBNBPrice();\\r\\n            updateTokenUsdValue(\\r\\n                _tokenName,\\r\\n                ((price * 10 ** 10) * _BNBPrice) /\\r\\n                    10 ** (tokenWhiteList['BNB'].tokenDecimal + tokenWhiteList['BUSD'].tokenDecimal)\\r\\n            );\\r\\n        } else {\\r\\n            updateTokenUsdValue(_tokenName, (price * 10 ** 10) / 10 ** tokenWhiteList['BUSD'].tokenDecimal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev gets token reserves for given token pair\\r\\n     */\\r\\n    function _getTokenReserves(address _pairAddress, address token0) internal view returns (uint256, uint256) {\\r\\n        IPancakePair pair = IPancakePair(_pairAddress);\\r\\n\\r\\n        if (address(pair) == address(0)) {\\r\\n            return (0, 0);\\r\\n        }\\r\\n\\r\\n        (uint256 Res0, uint256 Res1, ) = pair.getReserves();\\r\\n        if (token0 == pair.token0()) {\\r\\n            return (Res0, Res1);\\r\\n        }\\r\\n        return (Res1, Res0);\\r\\n    }\\r\\n\\r\\n    /**   @dev returns the token name with the highest usd value in pot\\r\\n          @return tokenWithHighestValue price is only updated when there are no participant in pot\\r\\n    */\\r\\n    function getPotTokenWithHighestValue() internal view returns (string memory tokenWithHighestValue) {\\r\\n        tokenWithHighestValue = '';\\r\\n        for (uint256 index = 0; index < tokensInPotNames.length; index++) {\\r\\n            if (\\r\\n                tokenTotalEntry[tokensInPotNames[index]] * tokenLatestPriceFeed[tokensInPotNames[index]] >\\r\\n                tokenTotalEntry[tokenWithHighestValue] * tokenLatestPriceFeed[tokenWithHighestValue]\\r\\n            ) {\\r\\n                if (keccak256(bytes(tokensInPotNames[index])) != keccak256(bytes('BNBP'))) {\\r\\n                    tokenWithHighestValue = tokensInPotNames[index];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (keccak256(bytes(tokenWithHighestValue)) == keccak256(bytes(''))) {\\r\\n            tokenWithHighestValue = 'BNBP';\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev reset pot state to start a new round\\r\\n     */\\r\\n    function startNewPot() internal {\\r\\n        for (uint256 index1 = 0; index1 < tokensInPotNames.length; index1++) {\\r\\n            delete tokenTotalEntry[tokensInPotNames[index1]];\\r\\n        }\\r\\n        //@optimize\\r\\n        // delete participants;\\r\\n        delete participantCount;\\r\\n        delete tokensInPotNames;\\r\\n\\r\\n        // @optimize\\r\\n        // delete entriesAddress;\\r\\n        // delete entriesUsdValue;\\r\\n        delete PotEntryCount;\\r\\n\\r\\n        pot_state = POT_STATE.WAITING;\\r\\n        delete potLiveTime;\\r\\n        delete potStartTime;\\r\\n        potCount++;\\r\\n    }\\r\\n\\r\\n    /**   @dev pays a specify address the specified token\\r\\n          @param _tokenName name of the token to send\\r\\n          @param _accountToPay address of the account to send token to\\r\\n          @param _tokenValue the token value to send\\r\\n    */\\r\\n    function _payAccount(\\r\\n        string memory _tokenName,\\r\\n        address _accountToPay,\\r\\n        uint256 _tokenValue\\r\\n    ) internal returns (bool paid) {\\r\\n        if (_tokenValue <= 0) return paid;\\r\\n        if (keccak256(bytes(_tokenName)) == keccak256(bytes('BNB'))) {\\r\\n            paid = payable(_accountToPay).send(_tokenValue);\\r\\n        } else {\\r\\n            paid = IPRC20(tokenWhiteList[_tokenName].tokenAddress).transfer(_accountToPay, _tokenValue);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**   @dev generates a random number\\r\\n     */\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(getBNBPrice(), block.difficulty, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add new particiant to particiants list, optimzing gas fee\\r\\n     */\\r\\n    function _addToParticipants(address participant) internal {\\r\\n        if (participantCount == participants.length) {\\r\\n            participants.push(participant);\\r\\n        } else {\\r\\n            participants[participantCount] = participant;\\r\\n        }\\r\\n        participantCount++;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current BNB price in comparison with BNB and USDT\\r\\n     */\\r\\n    function getBNBPrice() public view returns (uint256 price) {\\r\\n        (uint256 Res0, uint256 Res1) = _getTokenReserves(\\r\\n            tokenWhiteList['BNB'].pairAddress,\\r\\n            tokenWhiteList['BNB'].tokenAddress\\r\\n        );\\r\\n        uint256 res1 = Res1 * (10 ** IPRC20(wbnbAddr).decimals());\\r\\n        price = res1 / Res0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps accumulated fees into BNB, or BUSD first, and then to BNBP\\r\\n     */\\r\\n    function swapAccumulatedFees() external validBNBP nonReentrant {\\r\\n        require(tokenWhiteListNames.length > 0, 'whitelisted = 0');\\r\\n        address[] memory path2 = new address[](2);\\r\\n        address[] memory path3 = new address[](3);\\r\\n        path2[1] = router.WETH();\\r\\n        path3[1] = busdAddr;\\r\\n        path3[2] = router.WETH();\\r\\n\\r\\n        // Swap each token to BNB\\r\\n        for (uint256 i = 0; i < adminFeeToken.length; i++) {\\r\\n            uint256 balance = adminFeeTokenValues[adminFeeToken[i]];\\r\\n            if (balance == 0) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            string storage tokenName = adminFeeToken[i];\\r\\n            Token storage tokenInfo = tokenWhiteList[tokenName];\\r\\n            ERC20 token = ERC20(tokenInfo.tokenAddress);\\r\\n\\r\\n            if (keccak256(bytes(tokenName)) == keccak256(bytes('BNB'))) continue;\\r\\n            if (tokenInfo.tokenAddress == BNBP_Address) continue;\\r\\n\\r\\n            if (balance > 0) {\\r\\n                token.approve(address(router), balance);\\r\\n\\r\\n                if (tokenInfo.swapToBNB) {\\r\\n                    path2[0] = tokenInfo.tokenAddress;\\r\\n                } else {\\r\\n                    path3[0] = tokenInfo.tokenAddress;\\r\\n                }\\r\\n\\r\\n                try\\r\\n                    router.swapExactTokensForETH(\\r\\n                        balance,\\r\\n                        0,\\r\\n                        tokenInfo.swapToBNB ? path2 : path3,\\r\\n                        address(this),\\r\\n                        block.timestamp\\r\\n                    )\\r\\n                returns (uint256[] memory swappedAmounts) {\\r\\n                    adminFeeTokenValues[tokenName] -= swappedAmounts[0];\\r\\n                    adminFeeTokenValues['BNB'] += swappedAmounts[swappedAmounts.length - 1];\\r\\n                } catch Error(string memory reason) {\\r\\n                    emit TokenSwapFailedString(tokenName, reason);\\r\\n                } catch (bytes memory reason) {\\r\\n                    emit TokenSwapFailedBytes(tokenName, reason);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Swap converted BNB to BNBP\\r\\n\\r\\n        if (hotWalletAddress != address(0)) {\\r\\n            uint256 hotWalletBalance = hotWalletAddress.balance;\\r\\n            uint256 hotWalletFee;\\r\\n\\r\\n            if (hotWalletBalance <= hotWalletMinBalance) {\\r\\n                hotWalletFee = hotWalletMaxBalance - hotWalletBalance;\\r\\n                uint256 BNBFee = adminFeeTokenValues['BNB'];\\r\\n\\r\\n                if (hotWalletFee > BNBFee) {\\r\\n                    address[] memory BNBPPath = new address[](2);\\r\\n                    BNBPPath[0] = BNBP_Address;\\r\\n                    BNBPPath[1] = wbnbAddr;\\r\\n                    uint256[] memory amounts = router.getAmountsIn(hotWalletFee - BNBFee, BNBPPath);\\r\\n                    hotWalletFee = BNBFee;\\r\\n\\r\\n                    if (amounts[0] > adminFeeTokenValues['BNBP']) {\\r\\n                        amounts[0] = adminFeeTokenValues['BNBP'];\\r\\n                    }\\r\\n                    if (amounts[0] > 0) {\\r\\n                        IPRC20(BNBP_Address).approve(address(router), amounts[0]);\\r\\n                        uint256[] memory swappedAmounts = router.swapExactTokensForETH(\\r\\n                            amounts[0],\\r\\n                            0,\\r\\n                            BNBPPath,\\r\\n                            address(this),\\r\\n                            block.timestamp\\r\\n                        );\\r\\n                        adminFeeTokenValues['BNBP'] -= swappedAmounts[0];\\r\\n                        adminFeeTokenValues['BNB'] += swappedAmounts[1];\\r\\n                        _updateTokenomicsPool(swappedAmounts[0], false);\\r\\n                        hotWalletFee += swappedAmounts[1];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if (hotWalletFee > 0) {\\r\\n                bool sent = payable(hotWalletAddress).send(hotWalletFee);\\r\\n                if (!sent) {\\r\\n                    hotWalletFee = 0;\\r\\n                } else {\\r\\n                    emit HotWalletSupplied(hotWalletAddress, hotWalletFee);\\r\\n                }\\r\\n            }\\r\\n            adminFeeTokenValues['BNB'] -= hotWalletFee;\\r\\n        }\\r\\n\\r\\n        if (adminFeeTokenValues['BNB'] > 0) {\\r\\n            path2[0] = router.WETH();\\r\\n            path2[1] = BNBP_Address;\\r\\n\\r\\n            uint256[] memory bnbSwapAmounts = router.swapExactETHForTokens{ value: adminFeeTokenValues['BNB'] }(\\r\\n                0,\\r\\n                path2,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n            adminFeeTokenValues['BNB'] -= (bnbSwapAmounts[0]);\\r\\n            adminFeeTokenValues['BNBP'] += bnbSwapAmounts[1];\\r\\n            _updateTokenomicsPool(bnbSwapAmounts[1], true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets hot wallet address\\r\\n     */\\r\\n    function setHotWalletAddress(address addr) external onlyAdmin {\\r\\n        hotWalletAddress = addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets hot wallet min and max balance\\r\\n     */\\r\\n    function setHotWalletSettings(uint256 min, uint256 max) external onlyAdmin {\\r\\n        require(min < max, 'Min !< Max');\\r\\n        hotWalletMinBalance = min;\\r\\n        hotWalletMaxBalance = max;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns accumulated BNBP fees\\r\\n     *\\r\\n     * NOTE can't burn before the burn interval\\r\\n     */\\r\\n    function burnAccumulatedBNBP() external validBNBP {\\r\\n        IBNBP BNBPToken = IBNBP(BNBP_Address);\\r\\n        uint256 BNBP_Balance = BNBPToken.balanceOf(address(this));\\r\\n\\r\\n        require(BNBP_Balance > 0, 'No BNBP');\\r\\n        require(burnPool > 0, 'No burn amt');\\r\\n        require(burnPool <= BNBP_Balance, 'Wrong BNBP Fee');\\r\\n\\r\\n        BNBPToken.performBurn();\\r\\n        adminFeeTokenValues['BNBP'] -= burnPool;\\r\\n        burnPool = 0;\\r\\n        emit BurnSuccess(burnPool);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev call for an airdrop on the BNBP token contract\\r\\n     */\\r\\n    function airdropAccumulatedBNBP() external validBNBP returns (uint256) {\\r\\n        IBNBP BNBPToken = IBNBP(BNBP_Address);\\r\\n        uint256 amount = BNBPToken.performAirdrop();\\r\\n\\r\\n        airdropPool -= amount;\\r\\n        adminFeeTokenValues['BNBP'] -= amount;\\r\\n\\r\\n        emit AirdropSuccess(amount);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev call for an airdrop on the BNBP token contract\\r\\n     */\\r\\n    function lotteryAccumulatedBNBP() external validBNBP returns (address) {\\r\\n        IBNBP BNBPToken = IBNBP(BNBP_Address);\\r\\n        uint256 BNBP_Balance = BNBPToken.balanceOf(address(this));\\r\\n\\r\\n        require(BNBP_Balance > 0, 'No BNBP');\\r\\n        require(lotteryPool > 0, 'No lott amt');\\r\\n        require(lotteryPool <= BNBP_Balance, 'Wrg BNBP Fee');\\r\\n\\r\\n        address winner = BNBPToken.performLottery();\\r\\n        adminFeeTokenValues['BNBP'] -= lotteryPool;\\r\\n        lotteryPool = 0;\\r\\n\\r\\n        emit LotterySuccess(winner);\\r\\n        return winner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates percentages for airdrop, lottery, and burn\\r\\n     *\\r\\n     * NOTE The sum of 3 params should be 100, otherwise it reverts\\r\\n     */\\r\\n    function setTokenomicsPercentage(uint8 _airdrop, uint8 _lottery, uint8 _burn) external onlyAdmin {\\r\\n        require(_airdrop + _lottery + _burn == 100, 'Shld be 100');\\r\\n\\r\\n        airdropPercentage = _airdrop;\\r\\n        lotteryPercentage = _lottery;\\r\\n        burnPercentage = _burn;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev change BNBP balance of tokenomics pools\\r\\n     *\\r\\n     */\\r\\n    function _updateTokenomicsPool(uint256 value, bool increase) internal {\\r\\n        if (increase) {\\r\\n            uint256 deltaAirdropAmount = (value * airdropPercentage) / 100;\\r\\n            uint256 deltaLotteryAmount = (value * lotteryPercentage) / 100;\\r\\n            uint256 deltaBurnAmount = value - deltaAirdropAmount - deltaLotteryAmount;\\r\\n\\r\\n            airdropPool += deltaAirdropAmount;\\r\\n            lotteryPool += deltaLotteryAmount;\\r\\n            burnPool += deltaBurnAmount;\\r\\n        } else {\\r\\n            uint256 airdropDelta = airdropPool >= value ? value : airdropPool;\\r\\n            value -= airdropDelta;\\r\\n            airdropPool -= airdropDelta;\\r\\n            if (value == 0) return;\\r\\n\\r\\n            uint256 lotteryDelta = lotteryPool >= value ? value : lotteryPool;\\r\\n            value -= lotteryDelta;\\r\\n            lotteryPool -= lotteryDelta;\\r\\n            if (value == 0) return;\\r\\n\\r\\n            uint256 burnDelta = burnPool >= value ? value : burnPool;\\r\\n            value -= burnDelta;\\r\\n            burnPool -= burnDelta;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets Airdrop interval\\r\\n     *\\r\\n     */\\r\\n    function setAirdropInterval(uint256 interval) external onlyAdmin {\\r\\n        require(interval < maxInterval, 'max');\\r\\n        airdropInterval = interval;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets Burn interval\\r\\n     *\\r\\n     */\\r\\n    function setBurnInterval(uint256 interval) external onlyAdmin {\\r\\n        require(interval < maxInterval, 'max');\\r\\n        burnInterval = interval;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets minimum BNBP value to get airdrop and lottery\\r\\n     *\\r\\n     */\\r\\n    function setStakingMinimum(uint256 value) external onlyAdmin {\\r\\n        stakingMinimum = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets minimum BNBP value to get airdrop and lottery\\r\\n     *\\r\\n     */\\r\\n    function setMinimumStakingTime(uint256 value) external onlyAdmin {\\r\\n        minimumStakingTime = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add accumulated BNBP fees to the pool (can be only called by allowed contracts)\\r\\n     */\\r\\n    function addAdminTokenValue(uint256 value) external {\\r\\n        require(allowedContracts[msg.sender], 'N');\\r\\n\\r\\n        IPRC20(BNBP_Address).transferFrom(msg.sender, address(this), value);\\r\\n        adminFeeTokenValues['BNBP'] += value;\\r\\n        _updateTokenomicsPool(value, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a contract to send BNBP to the pool\\r\\n     */\\r\\n    function allowFeeContract(address addr) external onlyAdmin {\\r\\n        allowedContracts[addr] = true;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        if (msg.sender == address(router)) return;\\r\\n        require((tokenLatestPriceFeed['BNB'] * msg.value) / 10 ** 18 >= minEntranceInUsd, '< min');\\r\\n        _EnterPot('BNB', msg.value, msg.sender);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Powerball/PowerballBNBP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IBNBP.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\n// File: PotContract.sol\\r\\n\\r\\ncontract PowerBallBNBP is ReentrancyGuard {\\r\\n    enum STATE {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    struct Entry {\\r\\n        address player;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    address public owner;\\r\\n    address public admin;\\r\\n    address public tokenAddress;\\r\\n    uint8 public tokenDecimal;\\r\\n\\r\\n    STATE public roundStatus;\\r\\n    uint256 public entryIds;\\r\\n    uint256 public roundIds;\\r\\n    uint256 public roundDuration;\\r\\n    uint256 public roundStartTime;\\r\\n    uint256 public roundLiveTime;\\r\\n    uint256 public minEntranceAmount;\\r\\n    uint256 public currentEntryCount;\\r\\n    Entry[] public currentEntries;\\r\\n\\r\\n    uint256 public totalEntryAmount;\\r\\n    uint256 public nonce;\\r\\n    uint256 public calculateIndex;\\r\\n\\r\\n    uint256 public burnFee = 125;\\r\\n    uint256 public stakerFee = 125;\\r\\n\\r\\n    address constant BNBPAddr = 0x4D9927a8Dc4432B93445dA94E4084D292438931F; // mainnet: 0x4D9927a8Dc4432B93445dA94E4084D292438931F, testnet: 0xcAf4f8C9f1e511B3FEb3226Dc3534E4c4b2f3D70\\r\\n    address public potContractAddr;\\r\\n\\r\\n    constructor(address _potContractAddr) {\\r\\n        owner = msg.sender;\\r\\n        admin = msg.sender;\\r\\n        tokenAddress = BNBPAddr;\\r\\n        tokenDecimal = IPRC20(tokenAddress).decimals();\\r\\n        roundStatus = STATE.WAITING;\\r\\n        roundDuration = 5; // 5 secs\\r\\n        roundIds = 1;\\r\\n\\r\\n        minEntranceAmount = 1 * 10 ** tokenDecimal; // 2 BNBP\\r\\n        potContractAddr = _potContractAddr;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin || msg.sender == owner, '!admin');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, '!owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validBNBP() {\\r\\n        require(BNBPAddr != address(0), '!BNBP Addr');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender, 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event EnteredPot(uint256 indexed roundId, uint256 indexed entryId, address indexed player, uint256 amount);\\r\\n    event StartedCalculating(uint256 indexed roundId);\\r\\n    event CalculateWinner(\\r\\n        uint256 indexed roundId,\\r\\n        address indexed winner,\\r\\n        uint256 reward,\\r\\n        uint256 total,\\r\\n        uint256 index,\\r\\n        uint256 burn,\\r\\n        uint256 staker\\r\\n    );\\r\\n\\r\\n    function changeOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    function changeAdmin(address _adminAddress) public onlyOwner {\\r\\n        admin = _adminAddress;\\r\\n    }\\r\\n\\r\\n    function enterPot(uint256 _amount) external excludeContract {\\r\\n        unchecked {\\r\\n            require(_amount >= minEntranceAmount, 'Min');\\r\\n            require(roundLiveTime == 0 || block.timestamp <= roundLiveTime + roundDuration, 'ended');\\r\\n\\r\\n            IBNBP token = IBNBP(tokenAddress);\\r\\n            uint256 beforeBalance = token.balanceOf(address(this));\\r\\n            token.transferFrom(msg.sender, address(this), _amount);\\r\\n            uint256 rAmount = token.balanceOf(address(this)) - beforeBalance;\\r\\n\\r\\n            uint256 count = currentEntryCount;\\r\\n            if (currentEntries.length == count) {\\r\\n                currentEntries.push();\\r\\n            }\\r\\n\\r\\n            Entry storage entry = currentEntries[count];\\r\\n            entry.player = msg.sender;\\r\\n            entry.amount = rAmount;\\r\\n            ++currentEntryCount;\\r\\n            ++entryIds;\\r\\n            totalEntryAmount = totalEntryAmount + rAmount;\\r\\n\\r\\n            if (\\r\\n                currentEntryCount >= 2 && currentEntries[count - 1].player != msg.sender && roundStatus == STATE.STARTED\\r\\n            ) {\\r\\n                roundStatus = STATE.LIVE;\\r\\n                roundLiveTime = block.timestamp;\\r\\n            } else if (currentEntryCount == 1) {\\r\\n                roundStatus = STATE.STARTED;\\r\\n                roundStartTime = block.timestamp;\\r\\n            }\\r\\n\\r\\n            emit EnteredPot(roundIds, entryIds, msg.sender, rAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateWinner() public {\\r\\n        bool isRoundEnded = roundStatus == STATE.LIVE && roundLiveTime + roundDuration < block.timestamp;\\r\\n        require(isRoundEnded || roundStatus == STATE.CALCULATING_WINNER, 'Not ended');\\r\\n\\r\\n        if (isRoundEnded) {\\r\\n            nonce = fullFillRandomness() % totalEntryAmount;\\r\\n            calculateIndex = 0;\\r\\n        }\\r\\n        (address winner, uint256 index) = determineWinner();\\r\\n        if (winner != address(0)) {\\r\\n            IBNBP token = IBNBP(tokenAddress);\\r\\n            uint256 totalFeePercent = burnFee + stakerFee;\\r\\n            uint256 feeAmount = (totalEntryAmount * totalFeePercent) / 1000;\\r\\n            uint256 burnAmount = (feeAmount * burnFee) / totalFeePercent;\\r\\n            uint256 stakerAmount = feeAmount - burnAmount;\\r\\n            uint256 reward = totalEntryAmount - feeAmount;\\r\\n\\r\\n            token.transfer(winner, reward);\\r\\n            token.burn(burnAmount);\\r\\n            IPRC20(BNBPAddr).approve(potContractAddr, stakerAmount);\\r\\n            IPotLottery(potContractAddr).addAdminTokenValue(stakerAmount);\\r\\n\\r\\n            emit CalculateWinner(roundIds, winner, reward, totalEntryAmount, index, burnAmount, stakerAmount);\\r\\n\\r\\n            initializeRound();\\r\\n        } else {\\r\\n            roundStatus = STATE.CALCULATING_WINNER;\\r\\n            emit StartedCalculating(roundIds);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to select a random winner\\r\\n     */\\r\\n    function determineWinner() internal returns (address winner, uint256 winnerIndex) {\\r\\n        uint256 start = calculateIndex;\\r\\n        uint256 length = currentEntryCount;\\r\\n        uint256 _nonce = nonce;\\r\\n        for (uint256 index = 0; index < 3000 && (start + index) < length; index++) {\\r\\n            uint256 amount = currentEntries[start + index].amount;\\r\\n            if (_nonce <= amount) {\\r\\n                //That means that the winner has been found here\\r\\n                winner = currentEntries[start + index].player;\\r\\n                winnerIndex = start + index;\\r\\n                return (winner, winnerIndex);\\r\\n            }\\r\\n            _nonce -= amount;\\r\\n        }\\r\\n        nonce = _nonce;\\r\\n        calculateIndex = start + 3000;\\r\\n    }\\r\\n\\r\\n    function initializeRound() internal {\\r\\n        delete currentEntryCount;\\r\\n        delete roundLiveTime;\\r\\n        delete roundStartTime;\\r\\n        delete totalEntryAmount;\\r\\n        roundStatus = STATE.WAITING;\\r\\n        ++roundIds;\\r\\n    }\\r\\n\\r\\n    /**   @dev generates a random number\\r\\n     */\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.difficulty, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns status of current round\\r\\n     */\\r\\n    function getRoundStatus()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _roundIds,\\r\\n            STATE _roundStatus,\\r\\n            uint256 _roundStartTime,\\r\\n            uint256 _roundLiveTime,\\r\\n            uint256 _roundDuration,\\r\\n            uint256 _totalAmount,\\r\\n            uint256 _entryCount,\\r\\n            uint256 _minEntranceAmount,\\r\\n            uint256 _burnFee,\\r\\n            uint256 _stakerFee\\r\\n        )\\r\\n    {\\r\\n        _roundIds = roundIds;\\r\\n        _roundStatus = roundStatus;\\r\\n        _roundLiveTime = roundLiveTime;\\r\\n        _roundStartTime = roundStartTime;\\r\\n        _roundDuration = roundDuration;\\r\\n        _minEntranceAmount = minEntranceAmount;\\r\\n        _totalAmount = totalEntryAmount;\\r\\n        _entryCount = currentEntryCount;\\r\\n        _burnFee = burnFee;\\r\\n        _stakerFee = stakerFee;\\r\\n    }\\r\\n\\r\\n    function setRoundDuration(uint256 value) external onlyAdmin {\\r\\n        roundDuration = value;\\r\\n    }\\r\\n\\r\\n    function setFeePercent(uint256 _burn, uint256 _staker) external onlyAdmin {\\r\\n        burnFee = _burn;\\r\\n        stakerFee = _staker;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyAdmin {\\r\\n        tokenAddress = addr;\\r\\n    }\\r\\n\\r\\n    function withdrawETH(address receiver, uint256 amount) external onlyAdmin {\\r\\n        bool sent = payable(receiver).send(amount);\\r\\n        require(sent, 'fail');\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address receiver, address _tokenAddr, uint256 amount) external onlyAdmin {\\r\\n        if (_tokenAddr == tokenAddress) {\\r\\n            uint256 balance = IPRC20(_tokenAddr).balanceOf(address(this));\\r\\n            require(balance >= totalEntryAmount + amount, 'f');\\r\\n        }\\r\\n\\r\\n        IPRC20(_tokenAddr).transfer(receiver, amount);\\r\\n    }\\r\\n\\r\\n    function setPotContractAddr(address addr) external onlyAdmin {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setMinimumEntranceAmount(uint256 amount) external onlyAdmin {\\r\\n        minEntranceAmount = amount;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Powerball/PowerballVoltInu.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IVolt.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\n// File: PotContract.sol\\r\\n\\r\\ncontract PowerBallVoltInu is ReentrancyGuard {\\r\\n    enum STATE {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    struct Entry {\\r\\n        address player;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    address public owner;\\r\\n    address public admin;\\r\\n    address public tokenAddress;\\r\\n    uint8 public tokenDecimal;\\r\\n\\r\\n    address internal constant pancakeRouterAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    IPancakeRouter02 public router;\\r\\n\\r\\n    STATE public roundStatus;\\r\\n    uint256 public entryIds;\\r\\n    uint256 public roundIds;\\r\\n    uint256 public roundDuration;\\r\\n    uint256 public roundStartTime;\\r\\n    uint256 public roundLiveTime;\\r\\n    uint256 public minEntranceAmount;\\r\\n    uint256 public currentEntryCount;\\r\\n    Entry[] public currentEntries;\\r\\n\\r\\n    uint256 public totalEntryAmount;\\r\\n    uint256 public nonce;\\r\\n    uint256 public calculateIndex;\\r\\n\\r\\n    uint256 public platformFee = 75;\\r\\n    uint256 public marketingFee = 100;\\r\\n    uint256 public burnFee = 75;\\r\\n    uint256 constant upperLimit = 400;\\r\\n\\r\\n    address public BNBPAddr = 0x4D9927a8Dc4432B93445dA94E4084D292438931F; // mainnet: 0x4D9927a8Dc4432B93445dA94E4084D292438931F, testnet: 0xcAf4f8C9f1e511B3FEb3226Dc3534E4c4b2f3D70\\r\\n    address public potContractAddr;\\r\\n    address public marketingAddress;\\r\\n    address public burnAddress;\\r\\n\\r\\n    constructor(address _tokenAddress, address _potContractAddr, address _marketingAddr, address _burnAddr) {\\r\\n        owner = msg.sender;\\r\\n        admin = msg.sender;\\r\\n        tokenAddress = _tokenAddress;\\r\\n        marketingAddress = _marketingAddr;\\r\\n        burnAddress = _burnAddr;\\r\\n        tokenDecimal = IVolt(tokenAddress).decimals();\\r\\n        roundStatus = STATE.WAITING;\\r\\n        roundDuration = 5; // 5 secs\\r\\n        roundIds = 1;\\r\\n\\r\\n        minEntranceAmount = 1700000 * 10 ** tokenDecimal; // 1 USD Volt\\r\\n\\r\\n        router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        potContractAddr = _potContractAddr;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin || msg.sender == owner, '!admin');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, '!owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validBNBP() {\\r\\n        require(BNBPAddr != address(0), '!BNBP Addr');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender, 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event EnteredPot(uint256 indexed roundId, uint256 indexed entryId, address indexed player, uint256 amount);\\r\\n    event StartedCalculating(uint256 indexed roundId);\\r\\n    event CalculateWinner(\\r\\n        uint256 indexed roundId,\\r\\n        address indexed winner,\\r\\n        uint256 reward,\\r\\n        uint256 total,\\r\\n        uint256 index,\\r\\n        uint256 marketing,\\r\\n        uint256 burn,\\r\\n        uint256 platform\\r\\n    );\\r\\n\\r\\n    event TokenSwapFailedString(string tokenName, string reason);\\r\\n    event TokenSwapFailedBytes(string tokenName, bytes reason);\\r\\n\\r\\n    function changeOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    function changeAdmin(address _adminAddress) public onlyOwner {\\r\\n        admin = _adminAddress;\\r\\n    }\\r\\n\\r\\n    function setBNBPAddress(address _address) public onlyAdmin {\\r\\n        BNBPAddr = _address;\\r\\n    }\\r\\n\\r\\n    function enterPot(uint256 _amount) external excludeContract {\\r\\n        unchecked {\\r\\n            require(_amount >= minEntranceAmount, 'Min');\\r\\n            require(roundLiveTime == 0 || block.timestamp <= roundLiveTime + roundDuration, 'ended');\\r\\n\\r\\n            IVolt token = IVolt(tokenAddress);\\r\\n            uint256 beforeBalance = token.balanceOf(address(this));\\r\\n            token.transferFrom(msg.sender, address(this), _amount);\\r\\n            uint256 rAmount = token.balanceOf(address(this)) - beforeBalance;\\r\\n\\r\\n            uint256 count = currentEntryCount;\\r\\n            if (currentEntries.length == count) {\\r\\n                currentEntries.push();\\r\\n            }\\r\\n\\r\\n            Entry storage entry = currentEntries[count];\\r\\n            entry.player = msg.sender;\\r\\n            entry.amount = rAmount;\\r\\n            ++currentEntryCount;\\r\\n            ++entryIds;\\r\\n            totalEntryAmount = totalEntryAmount + rAmount;\\r\\n\\r\\n            if (\\r\\n                currentEntryCount >= 2 && currentEntries[count - 1].player != msg.sender && roundStatus == STATE.STARTED\\r\\n            ) {\\r\\n                roundStatus = STATE.LIVE;\\r\\n                roundLiveTime = block.timestamp;\\r\\n            } else if (currentEntryCount == 1) {\\r\\n                roundStatus = STATE.STARTED;\\r\\n                roundStartTime = block.timestamp;\\r\\n            }\\r\\n\\r\\n            emit EnteredPot(roundIds, entryIds, msg.sender, rAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateWinner() public {\\r\\n        bool isRoundEnded = roundStatus == STATE.LIVE && roundLiveTime + roundDuration < block.timestamp;\\r\\n        require(isRoundEnded || roundStatus == STATE.CALCULATING_WINNER, 'Not ended');\\r\\n\\r\\n        if (isRoundEnded) {\\r\\n            nonce = fullFillRandomness() % (totalEntryAmount + 1);\\r\\n            calculateIndex = 0;\\r\\n        }\\r\\n        (address winner, uint256 index) = determineWinner();\\r\\n        if (winner != address(0)) {\\r\\n            IVolt token = IVolt(tokenAddress);\\r\\n            uint256 totalFeePercent = platformFee + marketingFee + burnFee;\\r\\n            uint256 totalFeeAmount = (totalEntryAmount * totalFeePercent) / 1000;\\r\\n            uint256 reward = totalEntryAmount - totalFeeAmount;\\r\\n            uint256 marketingAmount = (totalFeeAmount * marketingFee) / totalFeePercent;\\r\\n            uint256 burnAmount = (totalFeeAmount * burnFee) / totalFeePercent;\\r\\n            uint256 amount = totalFeeAmount - marketingAmount - burnAmount;\\r\\n\\r\\n            token.transfer(winner, reward);\\r\\n            token.transfer(marketingAddress, marketingAmount);\\r\\n            token.transfer(burnAddress, burnAmount);\\r\\n            emit CalculateWinner(\\r\\n                roundIds,\\r\\n                winner,\\r\\n                reward,\\r\\n                totalEntryAmount,\\r\\n                index,\\r\\n                marketingAmount,\\r\\n                burnAmount,\\r\\n                amount\\r\\n            );\\r\\n\\r\\n            swapAccumulatedFees(amount);\\r\\n            initializeRound();\\r\\n        } else {\\r\\n            roundStatus = STATE.CALCULATING_WINNER;\\r\\n            emit StartedCalculating(roundIds);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to select a random winner\\r\\n     */\\r\\n    function determineWinner() internal returns (address winner, uint256 winnerIndex) {\\r\\n        uint256 start = calculateIndex;\\r\\n        uint256 length = currentEntryCount;\\r\\n        uint256 _nonce = nonce;\\r\\n        for (uint256 index = 0; index < 3000 && (start + index) < length; index++) {\\r\\n            uint256 amount = currentEntries[start + index].amount;\\r\\n            if (_nonce <= amount) {\\r\\n                //That means that the winner has been found here\\r\\n                winner = currentEntries[start + index].player;\\r\\n                winnerIndex = start + index;\\r\\n                return (winner, winnerIndex);\\r\\n            }\\r\\n            _nonce -= amount;\\r\\n        }\\r\\n        nonce = _nonce;\\r\\n        calculateIndex = start + 3000;\\r\\n    }\\r\\n\\r\\n    function initializeRound() internal {\\r\\n        delete currentEntryCount;\\r\\n        delete roundLiveTime;\\r\\n        delete roundStartTime;\\r\\n        delete totalEntryAmount;\\r\\n        roundStatus = STATE.WAITING;\\r\\n        ++roundIds;\\r\\n    }\\r\\n\\r\\n    /**   @dev generates a random number\\r\\n     */\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.difficulty, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps accumulated fees into BNB, and then to BNBP\\r\\n     */\\r\\n    function swapAccumulatedFees(uint256 amount) internal validBNBP {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = router.WETH();\\r\\n        path[2] = BNBPAddr;\\r\\n        IVolt(tokenAddress).approve(address(router), amount);\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\\r\\n        uint256 balance = IPRC20(BNBPAddr).balanceOf(address(this));\\r\\n        IPRC20(BNBPAddr).approve(potContractAddr, balance);\\r\\n        IPotLottery(potContractAddr).addAdminTokenValue(balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns status of current round\\r\\n     */\\r\\n    function getRoundStatus()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _roundIds,\\r\\n            STATE _roundStatus,\\r\\n            uint256 _roundStartTime,\\r\\n            uint256 _roundLiveTime,\\r\\n            uint256 _roundDuration,\\r\\n            uint256 _totalAmount,\\r\\n            uint256 _entryCount,\\r\\n            uint256 _minEntranceAmount,\\r\\n            uint256 _marketingFee,\\r\\n            uint256 _burnFee,\\r\\n            uint256 _platformFee\\r\\n        )\\r\\n    {\\r\\n        _roundIds = roundIds;\\r\\n        _roundStatus = roundStatus;\\r\\n        _roundLiveTime = roundLiveTime;\\r\\n        _roundStartTime = roundStartTime;\\r\\n        _roundDuration = roundDuration;\\r\\n        _minEntranceAmount = minEntranceAmount;\\r\\n        _totalAmount = totalEntryAmount;\\r\\n        _entryCount = currentEntryCount;\\r\\n        _marketingFee = marketingFee;\\r\\n        _burnFee = burnFee;\\r\\n        _platformFee = platformFee;\\r\\n    }\\r\\n\\r\\n    function setRoundDuration(uint256 value) external onlyAdmin {\\r\\n        roundDuration = value;\\r\\n    }\\r\\n\\r\\n    function setMarketingAddress(address addr) external onlyAdmin {\\r\\n        marketingAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setBurnAddress(address addr) external onlyAdmin {\\r\\n        burnAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setPotContractAddress(address addr) external onlyAdmin {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyAdmin {\\r\\n        tokenAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setMinimumEntranceAmount(uint256 amount) external onlyAdmin {\\r\\n        minEntranceAmount = amount;\\r\\n    }\\r\\n\\r\\n    function setFeePercent(uint256 _marketing, uint256 _burn, uint256 _platform) external onlyAdmin {\\r\\n        require(_marketing + _burn + _platform < upperLimit, 'Upper limit');\\r\\n        marketingFee = _marketing;\\r\\n        burnFee = _burn;\\r\\n        platformFee = _platform;\\r\\n    }\\r\\n\\r\\n    function withdrawETH(address receiver, uint256 amount) external onlyAdmin {\\r\\n        bool sent = payable(receiver).send(amount);\\r\\n        require(sent, 'fail');\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address receiver, address _tokenAddr, uint256 amount) external onlyAdmin {\\r\\n        if (_tokenAddr == tokenAddress) {\\r\\n            uint256 balance = IPRC20(_tokenAddr).balanceOf(address(this));\\r\\n            require(balance >= totalEntryAmount + amount, 'f');\\r\\n        }\\r\\n\\r\\n        IPRC20(_tokenAddr).transfer(receiver, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IVolt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IVolt {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function marketingAddress() external view returns (address);\\r\\n\\r\\n    function burningAddress() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Powerball/PowerballSafuu.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\ncontract PowerBallSafuuGo is ReentrancyGuard {\\r\\n    enum STATE {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    struct Entry {\\r\\n        address player;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    address public owner;\\r\\n    address public admin;\\r\\n    address public tokenAddress;\\r\\n    uint8 public tokenDecimal;\\r\\n\\r\\n    address internal constant pancakeRouterAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    IPancakeRouter02 public router;\\r\\n\\r\\n    STATE public roundStatus;\\r\\n    uint256 public entryIds;\\r\\n    uint256 public roundIds;\\r\\n    uint256 public roundDuration;\\r\\n    uint256 public roundStartTime;\\r\\n    uint256 public roundLiveTime;\\r\\n    uint256 public minEntranceAmount;\\r\\n    uint256 public currentEntryCount;\\r\\n    Entry[] public currentEntries;\\r\\n\\r\\n    uint256 public totalEntryAmount;\\r\\n    uint256 public nonce;\\r\\n    uint256 public calculateIndex;\\r\\n\\r\\n    uint256 public platformFee = 100;\\r\\n    uint256 public treasuryFee = 100;\\r\\n    uint256 public burnFee = 100;\\r\\n    uint256 constant upperLimit = 400;\\r\\n\\r\\n    address public BNBPAddr = 0x4D9927a8Dc4432B93445dA94E4084D292438931F; // mainnet: 0x4D9927a8Dc4432B93445dA94E4084D292438931F, testnet: 0xcAf4f8C9f1e511B3FEb3226Dc3534E4c4b2f3D70\\r\\n    address public potContractAddr;\\r\\n    address public treasuryAddress;\\r\\n    address public burnAddress;\\r\\n\\r\\n    constructor(address _tokenAddress, address _potContractAddr, address _treasuryAddr, address _burnAddr) {\\r\\n        owner = msg.sender;\\r\\n        admin = msg.sender;\\r\\n        tokenAddress = _tokenAddress;\\r\\n        treasuryAddress = _treasuryAddr;\\r\\n        burnAddress = _burnAddr;\\r\\n        tokenDecimal = IPRC20(tokenAddress).decimals();\\r\\n        roundStatus = STATE.WAITING;\\r\\n        roundDuration = 60; // 5 secs\\r\\n        roundIds = 1;\\r\\n\\r\\n        minEntranceAmount = 1700000 * 10 ** tokenDecimal; // 1 USD Volt\\r\\n\\r\\n        router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        potContractAddr = _potContractAddr;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin || msg.sender == owner, '!admin');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, '!owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validBNBP() {\\r\\n        require(BNBPAddr != address(0), '!BNBP Addr');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender, 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event EnteredPot(uint256 indexed roundId, uint256 indexed entryId, address indexed player, uint256 amount);\\r\\n    event StartedCalculating(uint256 indexed roundId);\\r\\n    event CalculateWinner(\\r\\n        uint256 indexed roundId,\\r\\n        address indexed winner,\\r\\n        uint256 reward,\\r\\n        uint256 total,\\r\\n        uint256 index,\\r\\n        uint256 treasury,\\r\\n        uint256 burn,\\r\\n        uint256 platform\\r\\n    );\\r\\n\\r\\n    event TokenSwapFailedString(string tokenName, string reason);\\r\\n    event TokenSwapFailedBytes(string tokenName, bytes reason);\\r\\n\\r\\n    function changeOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    function changeAdmin(address _adminAddress) public onlyOwner {\\r\\n        admin = _adminAddress;\\r\\n    }\\r\\n\\r\\n    function setBNBPAddress(address _address) public onlyAdmin {\\r\\n        BNBPAddr = _address;\\r\\n    }\\r\\n\\r\\n    function enterPot(uint256 _amount) external excludeContract {\\r\\n        unchecked {\\r\\n            require(_amount >= minEntranceAmount, 'Min');\\r\\n            require(roundLiveTime == 0 || block.timestamp <= roundLiveTime + roundDuration, 'ended');\\r\\n\\r\\n            IPRC20 token = IPRC20(tokenAddress);\\r\\n            uint256 beforeBalance = token.balanceOf(address(this));\\r\\n            token.transferFrom(msg.sender, address(this), _amount);\\r\\n            uint256 rAmount = token.balanceOf(address(this)) - beforeBalance;\\r\\n\\r\\n            uint256 count = currentEntryCount;\\r\\n            if (currentEntries.length == count) {\\r\\n                currentEntries.push();\\r\\n            }\\r\\n\\r\\n            Entry storage entry = currentEntries[count];\\r\\n            entry.player = msg.sender;\\r\\n            entry.amount = rAmount;\\r\\n            ++currentEntryCount;\\r\\n            ++entryIds;\\r\\n            totalEntryAmount = totalEntryAmount + rAmount;\\r\\n\\r\\n            if (\\r\\n                currentEntryCount >= 2 && currentEntries[count - 1].player != msg.sender && roundStatus == STATE.STARTED\\r\\n            ) {\\r\\n                roundStatus = STATE.LIVE;\\r\\n                roundLiveTime = block.timestamp;\\r\\n            } else if (currentEntryCount == 1) {\\r\\n                roundStatus = STATE.STARTED;\\r\\n                roundStartTime = block.timestamp;\\r\\n            }\\r\\n\\r\\n            emit EnteredPot(roundIds, entryIds, msg.sender, rAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateWinner() public {\\r\\n        bool isRoundEnded = roundStatus == STATE.LIVE && roundLiveTime + roundDuration < block.timestamp;\\r\\n        require(isRoundEnded || roundStatus == STATE.CALCULATING_WINNER, 'Not ended');\\r\\n\\r\\n        if (isRoundEnded) {\\r\\n            nonce = fullFillRandomness() % (totalEntryAmount + 1);\\r\\n            calculateIndex = 0;\\r\\n        }\\r\\n        (address winner, uint256 index) = determineWinner();\\r\\n        if (winner != address(0)) {\\r\\n            IPRC20 token = IPRC20(tokenAddress);\\r\\n            uint256 totalFeePercent = platformFee + treasuryFee + burnFee;\\r\\n            uint256 totalFeeAmount = (totalEntryAmount * totalFeePercent) / 1000;\\r\\n            uint256 reward = totalEntryAmount - totalFeeAmount;\\r\\n            uint256 treasuryAmount = (totalFeeAmount * treasuryFee) / totalFeePercent;\\r\\n            uint256 burnAmount = (totalFeeAmount * burnFee) / totalFeePercent;\\r\\n            uint256 amount = totalFeeAmount - treasuryAmount - burnAmount;\\r\\n\\r\\n            token.transfer(winner, reward);\\r\\n            token.transfer(treasuryAddress, treasuryAmount);\\r\\n            token.transfer(burnAddress, burnAmount);\\r\\n            emit CalculateWinner(roundIds, winner, reward, totalEntryAmount, index, treasuryAmount, burnAmount, amount);\\r\\n\\r\\n            swapAccumulatedFees(amount);\\r\\n            initializeRound();\\r\\n        } else {\\r\\n            roundStatus = STATE.CALCULATING_WINNER;\\r\\n            emit StartedCalculating(roundIds);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to select a random winner\\r\\n     */\\r\\n    function determineWinner() internal returns (address winner, uint256 winnerIndex) {\\r\\n        uint256 start = calculateIndex;\\r\\n        uint256 length = currentEntryCount;\\r\\n        uint256 _nonce = nonce;\\r\\n        for (uint256 index = 0; index < 3000 && (start + index) < length; index++) {\\r\\n            uint256 amount = currentEntries[start + index].amount;\\r\\n            if (_nonce <= amount) {\\r\\n                //That means that the winner has been found here\\r\\n                winner = currentEntries[start + index].player;\\r\\n                winnerIndex = start + index;\\r\\n                return (winner, winnerIndex);\\r\\n            }\\r\\n            _nonce -= amount;\\r\\n        }\\r\\n        nonce = _nonce;\\r\\n        calculateIndex = start + 3000;\\r\\n    }\\r\\n\\r\\n    function initializeRound() internal {\\r\\n        delete currentEntryCount;\\r\\n        delete roundLiveTime;\\r\\n        delete roundStartTime;\\r\\n        delete totalEntryAmount;\\r\\n        roundStatus = STATE.WAITING;\\r\\n        ++roundIds;\\r\\n    }\\r\\n\\r\\n    /**   @dev generates a random number\\r\\n     */\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.difficulty, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps accumulated fees into BNB, and then to BNBP\\r\\n     */\\r\\n    function swapAccumulatedFees(uint256 amount) internal validBNBP {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = router.WETH();\\r\\n        path[2] = BNBPAddr;\\r\\n        IPRC20(tokenAddress).approve(address(router), amount);\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\\r\\n        uint256 balance = IPRC20(BNBPAddr).balanceOf(address(this));\\r\\n        IPRC20(BNBPAddr).approve(potContractAddr, balance);\\r\\n        IPotLottery(potContractAddr).addAdminTokenValue(balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns status of current round\\r\\n     */\\r\\n    function getRoundStatus()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _roundIds,\\r\\n            STATE _roundStatus,\\r\\n            uint256 _roundStartTime,\\r\\n            uint256 _roundLiveTime,\\r\\n            uint256 _roundDuration,\\r\\n            uint256 _totalAmount,\\r\\n            uint256 _entryCount,\\r\\n            uint256 _minEntranceAmount,\\r\\n            uint256 _treasuryFee,\\r\\n            uint256 _burnFee,\\r\\n            uint256 _platformFee\\r\\n        )\\r\\n    {\\r\\n        _roundIds = roundIds;\\r\\n        _roundStatus = roundStatus;\\r\\n        _roundLiveTime = roundLiveTime;\\r\\n        _roundStartTime = roundStartTime;\\r\\n        _roundDuration = roundDuration;\\r\\n        _minEntranceAmount = minEntranceAmount;\\r\\n        _totalAmount = totalEntryAmount;\\r\\n        _entryCount = currentEntryCount;\\r\\n        _treasuryFee = treasuryFee;\\r\\n        _burnFee = burnFee;\\r\\n        _platformFee = platformFee;\\r\\n    }\\r\\n\\r\\n    function setRoundDuration(uint256 value) external onlyAdmin {\\r\\n        roundDuration = value;\\r\\n    }\\r\\n\\r\\n    function setTreasuryAddress(address addr) external onlyAdmin {\\r\\n        treasuryAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setBurnAddress(address addr) external onlyAdmin {\\r\\n        burnAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setPotContractAddress(address addr) external onlyAdmin {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyAdmin {\\r\\n        tokenAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setMinimumEntranceAmount(uint256 amount) external onlyAdmin {\\r\\n        minEntranceAmount = amount;\\r\\n    }\\r\\n\\r\\n    function setFeePercent(uint256 _treasury, uint256 _burn, uint256 _platform) external onlyAdmin {\\r\\n        require(_treasury + _burn + _platform < upperLimit, 'Upper limit');\\r\\n        treasuryFee = _treasury;\\r\\n        burnFee = _burn;\\r\\n        platformFee = _platform;\\r\\n    }\\r\\n\\r\\n    function withdrawETH(address receiver, uint256 amount) external onlyAdmin {\\r\\n        bool sent = payable(receiver).send(amount);\\r\\n        require(sent, 'fail');\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address receiver, address _tokenAddr, uint256 amount) external onlyAdmin {\\r\\n        if (_tokenAddr == tokenAddress) {\\r\\n            uint256 balance = IPRC20(_tokenAddr).balanceOf(address(this));\\r\\n            require(balance >= totalEntryAmount + amount, 'f');\\r\\n        }\\r\\n\\r\\n        IPRC20(_tokenAddr).transfer(receiver, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Water/Lourdes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../../interfaces/IBoosterNFT.sol';\\r\\n\\r\\ncontract Lourdes is Ownable {\\r\\n    IERC20 public holy;\\r\\n    IERC20 public water;\\r\\n    address reservoirAddress;\\r\\n    ITYRHBoosterNFT public boosterNFT;\\r\\n    Staking[] public stakings;\\r\\n    StakingType[] public stakingTypes;\\r\\n    mapping(uint256 => uint256) public nftType; // 1: time, 2: volume\\r\\n    mapping(address => uint256[]) public userStakingIds;\\r\\n    uint256 public totalStakingCount;\\r\\n\\r\\n    struct StakingType {\\r\\n        uint256 waterAmount;\\r\\n        uint256 holyAmount;\\r\\n        uint256 lockTime;\\r\\n    }\\r\\n\\r\\n    struct Staking {\\r\\n        uint256 id;\\r\\n        uint256 typeId;\\r\\n        address owner;\\r\\n        uint256 waterAmount;\\r\\n        uint256 holyAmount;\\r\\n        uint256 startTimestamp;\\r\\n        uint256 lockTime;\\r\\n        uint256[] nftIds;\\r\\n        bool finished;\\r\\n        bool canceled;\\r\\n    }\\r\\n\\r\\n    event Staked(address user, uint256 amount, uint256 lockTime);\\r\\n    event ClaimedHoly(uint256 stakingId, address user, uint256 amount);\\r\\n    event StakeCanceled(uint256 stakingId, address user, uint256 amount, uint256 penalty);\\r\\n\\r\\n    constructor(address waterAddr, address holyAddr, address NFTAddr, address _reservoirAddress) {\\r\\n        water = IERC20(waterAddr);\\r\\n        holy = IERC20(holyAddr);\\r\\n        boosterNFT = ITYRHBoosterNFT(NFTAddr);\\r\\n        reservoirAddress = _reservoirAddress;\\r\\n\\r\\n        uint256 oneDay = 3600 * 24;\\r\\n        stakingTypes.push(StakingType(100 * 1000000 * 10 ** 18, 1 * 10 ** 18, 150 * oneDay)); // 100M water, 1 holy, 150 days\\r\\n        stakingTypes.push(StakingType(500 * 1000000 * 10 ** 18, 10 * 10 ** 18, 100 * oneDay)); // 500M water, 10 holy, 100 days\\r\\n        stakingTypes.push(StakingType(1000 * 1000000 * 10 ** 18, 25 * 10 ** 18, 50 * oneDay)); // 1B water, 25 holy, 50 days\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stake water to get Holy\\r\\n     * @param typeId type of staking\\r\\n     * @param nftIds ids of NFTs\\r\\n     * NOTE the array should have fixed length of 2,\\r\\n     * each element indicates NFT ids for each NFT type - Time, Volum.\\r\\n     * If the value is 0, it means no NFTs used for that type.\\r\\n     */\\r\\n    function stake(uint256 typeId, uint256[] memory nftIds) external {\\r\\n        StakingType memory stakingType = stakingTypes[typeId];\\r\\n        require(typeId < stakingTypes.length, 'invalid typeId');\\r\\n        require(nftIds.length == 2, 'not enough nfts');\\r\\n        uint256 timeReduction;\\r\\n        uint256 volumeBoost;\\r\\n        uint256 i;\\r\\n\\r\\n        for (i = 0; i < nftIds.length; i++) {\\r\\n            if (nftIds[i] == 0) continue;\\r\\n            ITYRHBoosterNFT.NFT memory nft = boosterNFT.nfts(nftIds[i]);\\r\\n            uint256 typeInfo = nftType[nft.typeId];\\r\\n            require(boosterNFT.ownerOf(nftIds[i]) == msg.sender, 'not nft owner');\\r\\n            require(typeInfo == i + 1, 'not holy nft');\\r\\n\\r\\n            // burn NFT\\r\\n            boosterNFT.transferFrom(msg.sender, address(0xdead), nftIds[i]);\\r\\n\\r\\n            if (typeInfo == 1) {\\r\\n                // time NFT\\r\\n                timeReduction += nft.weight;\\r\\n            } else if (typeInfo == 2) {\\r\\n                // volume NFT\\r\\n                volumeBoost += nft.weight;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 lockTime = (stakingType.lockTime * (100 - timeReduction)) / 100;\\r\\n        uint256 holyAmount = (stakingType.holyAmount * ((100 + volumeBoost))) / 100;\\r\\n\\r\\n        water.transferFrom(msg.sender, address(this), stakingType.waterAmount);\\r\\n        // Add Tree\\r\\n        stakings.push();\\r\\n        uint256 stakingId = stakings.length - 1;\\r\\n        Staking storage myStaking = stakings[stakingId];\\r\\n        myStaking.id = stakingId;\\r\\n        myStaking.typeId = typeId;\\r\\n        myStaking.waterAmount = stakingType.waterAmount;\\r\\n        myStaking.lockTime = lockTime;\\r\\n        myStaking.holyAmount = holyAmount;\\r\\n        myStaking.owner = msg.sender;\\r\\n        myStaking.startTimestamp = block.timestamp;\\r\\n        myStaking.nftIds = nftIds;\\r\\n        totalStakingCount++;\\r\\n        userStakingIds[msg.sender].push(stakingId);\\r\\n        emit Staked(msg.sender, stakingType.waterAmount, lockTime);\\r\\n    }\\r\\n\\r\\n    function claim(uint256 stakingId) external {\\r\\n        Staking memory staking = stakings[stakingId];\\r\\n        require(staking.owner == msg.sender, 'not owner');\\r\\n        require(staking.startTimestamp + staking.lockTime < block.timestamp, 'not yet finished');\\r\\n        require(!staking.finished && !staking.canceled, 'finished');\\r\\n        holy.transfer(msg.sender, staking.holyAmount);\\r\\n        water.transfer(msg.sender, staking.waterAmount);\\r\\n        stakings[stakingId].finished = true;\\r\\n        emit ClaimedHoly(stakingId, msg.sender, staking.holyAmount);\\r\\n    }\\r\\n\\r\\n    function cancelStake(uint256 stakingId) external {\\r\\n        Staking memory staking = stakings[stakingId];\\r\\n        require(staking.owner == msg.sender, 'not owner');\\r\\n        require(!staking.finished && !staking.canceled, 'finished');\\r\\n        uint256 penalty = 5555;\\r\\n        uint256 penaltyAmount = (staking.waterAmount * penalty) / 10000;\\r\\n        uint256 returnAmount = staking.waterAmount - penaltyAmount;\\r\\n        water.transfer(reservoirAddress, penaltyAmount);\\r\\n        water.transfer(msg.sender, returnAmount);\\r\\n        stakings[stakingId].canceled = true;\\r\\n        emit StakeCanceled(stakingId, msg.sender, staking.waterAmount, penaltyAmount);\\r\\n    }\\r\\n\\r\\n    function getUserStakingList(address user) external view returns (Staking[] memory list) {\\r\\n        uint256[] memory stakingIds = userStakingIds[user];\\r\\n        uint256 length = stakingIds.length;\\r\\n        list = new Staking[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            uint256 stakeId = stakingIds[i];\\r\\n            list[i] = stakings[stakeId];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getStakingTypes() external view returns (StakingType[] memory) {\\r\\n        return stakingTypes;\\r\\n    }\\r\\n\\r\\n    function updateStakingType(\\r\\n        uint256 typeId,\\r\\n        uint256 waterAmount,\\r\\n        uint256 holyAmount,\\r\\n        uint256 lockTime\\r\\n    ) external onlyOwner {\\r\\n        StakingType storage stakingType = stakingTypes[typeId];\\r\\n        stakingType.waterAmount = waterAmount;\\r\\n        stakingType.holyAmount = holyAmount;\\r\\n        stakingType.lockTime = lockTime;\\r\\n    }\\r\\n\\r\\n    function addStakingType(uint256 waterAmount, uint256 holyAmount, uint256 lockTime) external onlyOwner {\\r\\n        stakingTypes.push();\\r\\n        StakingType storage stakingType = stakingTypes[stakingTypes.length - 1];\\r\\n        stakingType.waterAmount = waterAmount;\\r\\n        stakingType.holyAmount = holyAmount;\\r\\n        stakingType.lockTime = lockTime;\\r\\n    }\\r\\n\\r\\n    function setNFTType(uint256[] memory typeIds, uint256[] memory values) external onlyOwner {\\r\\n        uint256 i;\\r\\n        uint256 length = typeIds.length;\\r\\n        for (i = 0; i < length; i++) {\\r\\n            nftType[typeIds[i]] = values[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setBoosterNFTAddress(address addr) external onlyOwner {\\r\\n        boosterNFT = ITYRHBoosterNFT(addr);\\r\\n    }\\r\\n\\r\\n    function setWaterAddress(address addr) external onlyOwner {\\r\\n        water = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setHolyAddress(address addr) external onlyOwner {\\r\\n        holy = IERC20(addr);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Water/Fountain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../../interfaces/ITYRHStaking.sol';\\r\\nimport '../../interfaces/IBoosterNFT.sol';\\r\\n\\r\\ncontract Fountain is Ownable {\\r\\n    IERC20 public water;\\r\\n    ITYRHBoosterNFT public nftContract;\\r\\n    ClaimInfo[] public claims;\\r\\n    uint256 public waterPerDay;\\r\\n    uint256 public minimumClaimCycle;\\r\\n    uint256 public lastClaimTimestamp;\\r\\n    uint256 public claimCount;\\r\\n    uint256 public passNFTType;\\r\\n    mapping(address => uint256) public userLastClaimTimestamp;\\r\\n    mapping(uint256 => uint256) public nftLastUsedTimestamp;\\r\\n\\r\\n    struct ClaimInfo {\\r\\n        address user;\\r\\n        uint256 amount;\\r\\n        uint256 timestamp;\\r\\n    }\\r\\n    event FaucetClaimed(address user, uint256 amount);\\r\\n\\r\\n    constructor(address tokenAddress, address nftAddress) {\\r\\n        water = IERC20(tokenAddress);\\r\\n        nftContract = ITYRHBoosterNFT(nftAddress);\\r\\n        waterPerDay = 10 * 1000000 * 10 ** 18; // 10M per day\\r\\n        minimumClaimCycle = 3600 * 24; // only claim once a day\\r\\n        lastClaimTimestamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function claim(uint256 nftId) external {\\r\\n        uint256 timestamp = userLastClaimTimestamp[msg.sender];\\r\\n        require(timestamp + minimumClaimCycle < block.timestamp, 'cannot claim yet');\\r\\n        require(nftId > 0, 'need NFT');\\r\\n        ITYRHBoosterNFT.NFT memory nftInfo = nftContract.nfts(nftId);\\r\\n        require(nftInfo.typeId == passNFTType, 'not correct NFT type');\\r\\n        require(nftContract.ownerOf(nftId) == msg.sender, 'not nft owner');\\r\\n        require(nftLastUsedTimestamp[nftId] + minimumClaimCycle < block.timestamp, 'nft cannot be used');\\r\\n        nftLastUsedTimestamp[nftId] = block.timestamp;\\r\\n\\r\\n        uint256 oneDay = 3600 * 24;\\r\\n        uint256 timePassed = block.timestamp - lastClaimTimestamp;\\r\\n        uint256 amount = (timePassed * waterPerDay) / oneDay;\\r\\n\\r\\n        water.transfer(msg.sender, amount);\\r\\n        claims.push(ClaimInfo(msg.sender, amount, block.timestamp));\\r\\n        lastClaimTimestamp = block.timestamp;\\r\\n        userLastClaimTimestamp[msg.sender] = block.timestamp;\\r\\n        claimCount++;\\r\\n\\r\\n        emit FaucetClaimed(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function setWaterPerDay(uint256 value) external onlyOwner {\\r\\n        waterPerDay = value;\\r\\n    }\\r\\n\\r\\n    function setMinimumClaimCycle(uint256 value) external onlyOwner {\\r\\n        minimumClaimCycle = value;\\r\\n    }\\r\\n\\r\\n    function setWaterAddress(address addr) external onlyOwner {\\r\\n        water = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setPassNFTType(uint256 value) external onlyOwner {\\r\\n        passNFTType = value;\\r\\n    }\\r\\n\\r\\n    function getClaimInfos(uint256 start, uint256 end) external view returns (ClaimInfo[] memory list) {\\r\\n        list = new ClaimInfo[](end - start);\\r\\n        for (uint256 i = start; i < end; i++) {\\r\\n            list[i - start] = claims[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getFountainInfo()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _lastClaimTimestamp,\\r\\n            uint256 _claimCount,\\r\\n            uint256 _minimumClaimCycle,\\r\\n            uint256 _waterPerDay,\\r\\n            uint256 _fountainBalance\\r\\n        )\\r\\n    {\\r\\n        _lastClaimTimestamp = lastClaimTimestamp;\\r\\n        _claimCount = claimCount;\\r\\n        _minimumClaimCycle = minimumClaimCycle;\\r\\n        _waterPerDay = waterPerDay;\\r\\n        _fountainBalance = water.balanceOf(address(this));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITYRHStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface ITYRHStaking {\\r\\n    struct Stake {\\r\\n        uint256 id;\\r\\n        address user;\\r\\n        uint256 amount;\\r\\n        uint256 timestamp;\\r\\n        bool isFinished;\\r\\n    }\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 totalAmount;\\r\\n        uint256[] stakeIds;\\r\\n        uint256 stakeCount;\\r\\n    }\\r\\n\\r\\n    function stakeList(uint256 id) external returns (Stake memory);\\r\\n\\r\\n    function userStakingInfo(address user) external returns (StakingInfo memory);\\r\\n    function stake(uint256 amount) external;\\r\\n    function unStake(uint256 id) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Saver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../interfaces/ITYRHStaking.sol';\\r\\n\\r\\ncontract TYRHStakingSaver is Ownable {\\r\\n    IERC20 tyrh;\\r\\n    ITYRHStaking stakingContract;\\r\\n\\r\\n    constructor(address tokenAddress, address contractAddress) {\\r\\n        tyrh = IERC20(tokenAddress);\\r\\n        stakingContract = ITYRHStaking(contractAddress);\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) external onlyOwner {\\r\\n        tyrh.approve(address(stakingContract), amount);\\r\\n        stakingContract.stake(amount);\\r\\n    }\\r\\n\\r\\n    function unStake(uint256 id, uint256 times) external onlyOwner {\\r\\n        for (uint256 i = 0; i < times; i++) {\\r\\n            stakingContract.unStake(id);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) external onlyOwner {\\r\\n        address receiver = owner();\\r\\n        tyrh.transfer(receiver, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Plant/SproutHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../../interfaces/IBoosterNFT.sol';\\r\\n\\r\\ncontract SproutHouse is Ownable {\\r\\n    IERC20 public plant;\\r\\n    ITYRHBoosterNFT public NFTContract;\\r\\n    Staking[] public stakings;\\r\\n    mapping(address => uint256[]) public userStakingIds;\\r\\n    mapping(uint256 => bool) public isYieldBoosterNFT;\\r\\n    uint256 public totalStakingCount;\\r\\n    uint256 public minimumYield;\\r\\n    uint256 public maximumYield;\\r\\n    uint256 public minimumLockTime;\\r\\n\\r\\n    struct Staking {\\r\\n        uint256 id;\\r\\n        address owner;\\r\\n        uint256 amount;\\r\\n        uint256 yield;\\r\\n        uint256 timestamp;\\r\\n        uint256 nftId;\\r\\n        bool finished;\\r\\n    }\\r\\n\\r\\n    event Staked(uint256 stakingId, address user, uint256 amount, uint256 yield, uint256 nftId);\\r\\n    event UnStaked(uint256 stakingId, address user, uint256 amount);\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender, 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address tokenAddr, address nftAddress) {\\r\\n        minimumLockTime = 3600 * 24 * 10; // 10 days\\r\\n        minimumYield = 100; // 0.1%\\r\\n        maximumYield = 1500; // 1.5%\\r\\n        plant = IERC20(tokenAddr);\\r\\n        NFTContract = ITYRHBoosterNFT(nftAddress);\\r\\n    }\\r\\n\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.prevrandao, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount, uint256 nftId) external excludeContract {\\r\\n        uint256 yield = (fullFillRandomness() % (maximumYield - minimumYield + 1)) + minimumYield;\\r\\n        uint256 yieldBoost = 0;\\r\\n\\r\\n        if (nftId > 0) {\\r\\n            ITYRHBoosterNFT.NFT memory nftInfo = NFTContract.nfts(nftId);\\r\\n            require(isYieldBoosterNFT[nftInfo.typeId], 'not sprouthouse nft');\\r\\n            require(NFTContract.ownerOf(nftId) == msg.sender, 'not nft owner');\\r\\n            NFTContract.transferFrom(msg.sender, address(0xdead), nftId);\\r\\n            yieldBoost = nftInfo.weight;\\r\\n        }\\r\\n\\r\\n        yield = (yield * (100 + yieldBoost)) / 100;\\r\\n        plant.transferFrom(msg.sender, address(this), amount);\\r\\n        stakings.push();\\r\\n        uint256 stakingId = stakings.length - 1;\\r\\n        Staking storage myStaking = stakings[stakingId];\\r\\n        myStaking.id = stakingId;\\r\\n        myStaking.owner = msg.sender;\\r\\n        myStaking.yield = yield;\\r\\n        myStaking.amount = amount;\\r\\n        myStaking.timestamp = block.timestamp;\\r\\n        myStaking.nftId = nftId;\\r\\n        userStakingIds[msg.sender].push(stakingId);\\r\\n        totalStakingCount++;\\r\\n        emit Staked(stakingId, msg.sender, amount, yield, nftId);\\r\\n    }\\r\\n\\r\\n    function unStake(uint256 stakingId) external {\\r\\n        Staking storage info = stakings[stakingId];\\r\\n        require(info.finished == false && info.timestamp != 0, 'stake ended');\\r\\n        require(info.timestamp + minimumLockTime < block.timestamp, \\\"Can't unstake yet\\\");\\r\\n        uint256 oneDay = 3600 * 24;\\r\\n        uint256 daysPassed = (block.timestamp - info.timestamp) / oneDay;\\r\\n        uint256 amount = info.amount;\\r\\n        uint256 yield = info.yield;\\r\\n        for (uint256 i = 0; i < daysPassed; i++) {\\r\\n            amount = (amount * (100000 + yield)) / 100000;\\r\\n        }\\r\\n        info.finished = true;\\r\\n        plant.transfer(msg.sender, amount);\\r\\n        emit UnStaked(stakingId, msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function getUserStakingList(address user) external view returns (Staking[] memory list) {\\r\\n        uint256[] memory stakingIds = userStakingIds[user];\\r\\n        uint256 length = stakingIds.length;\\r\\n        list = new Staking[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            uint256 stakeId = stakingIds[i];\\r\\n            list[i] = stakings[stakeId];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setMinimumLockTime(uint256 time) external onlyOwner {\\r\\n        minimumLockTime = time;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyOwner {\\r\\n        plant = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setNFTAddress(address addr) external onlyOwner {\\r\\n        NFTContract = ITYRHBoosterNFT(addr);\\r\\n    }\\r\\n\\r\\n    function setYield(uint256 min, uint256 max) external onlyOwner {\\r\\n        minimumYield = min;\\r\\n        maximumYield = max;\\r\\n    }\\r\\n\\r\\n    function setYieldBoosterNFTTypes(uint256[] memory typeIds, bool[] memory values) external onlyOwner {\\r\\n        uint256 i;\\r\\n        uint256 length = typeIds.length;\\r\\n        for (i = 0; i < length; i++) {\\r\\n            isYieldBoosterNFT[typeIds[i]] = values[i];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Plant/SeedBank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../../interfaces/IBoosterNFT.sol';\\r\\n\\r\\ncontract SeedBank is Ownable {\\r\\n    IERC20 public seed;\\r\\n    IERC20 public plant;\\r\\n    ITYRHBoosterNFT public NFTContract;\\r\\n    uint256 public initialValue;\\r\\n    uint256 public minimumTime;\\r\\n    uint256 public initialTime;\\r\\n    uint256 public defaultSeedAmount;\\r\\n    mapping(uint256 => uint256) public nftType; // 1: time, 2: amount\\r\\n    mapping(address => StakingInfo) public userStakingInfo;\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 amount;\\r\\n        uint256 seedAmount;\\r\\n        uint256 lifeCycle;\\r\\n        uint256 startTimestamp;\\r\\n        uint256 lastClaimTimestamp;\\r\\n        uint256[] nftIds;\\r\\n        bool isStaking;\\r\\n    }\\r\\n\\r\\n    event Staked(address user, uint256 plantAmount);\\r\\n    event SeedHarvested(address user, uint256 seedAmount);\\r\\n    event StoppedStaking(address user);\\r\\n\\r\\n    constructor(address plantAddress, address seedAddress, address nftAddress) {\\r\\n        plant = IERC20(plantAddress);\\r\\n        seed = IERC20(seedAddress);\\r\\n        NFTContract = ITYRHBoosterNFT(nftAddress);\\r\\n        initialValue = 100 * 1000000 * 10 ** 18; // 100M\\r\\n        minimumTime = 3 * 3600; // 3 hours\\r\\n        initialTime = 480 * 3600; // 48 hours\\r\\n        defaultSeedAmount = 10 ** 18; // 1 seed per claim\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stake plant to get Seed\\r\\n     * @param amount plant amount\\r\\n     * @param nftIds ids of NFTs\\r\\n     * NOTE the array should have fixed length of 2,\\r\\n     * each element indicates NFT ids for each NFT type - Time, Volume.\\r\\n     * If the value is 0, it means no NFTs used for that type.\\r\\n     */\\r\\n    function stake(uint256 amount, uint256[] memory nftIds) external {\\r\\n        StakingInfo storage info = userStakingInfo[msg.sender];\\r\\n        require(info.isStaking == false, 'already staking');\\r\\n        require(nftIds.length == 2, 'not enought nfts');\\r\\n        plant.transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        uint256 time = (initialTime * initialValue) / amount;\\r\\n        uint256 seedAmount = defaultSeedAmount;\\r\\n        uint256 timeReduction = 0;\\r\\n        uint256 seedAmountBoost = 0;\\r\\n\\r\\n        for (uint256 i = 0; i < 2; i++) {\\r\\n            uint256 nftId = nftIds[i];\\r\\n            if (nftId == 0) continue;\\r\\n            ITYRHBoosterNFT.NFT memory nftInfo = NFTContract.nfts(nftId);\\r\\n            uint256 typeInfo = nftType[nftInfo.typeId];\\r\\n\\r\\n            require(typeInfo == i + 1, 'not Seed NFT');\\r\\n            require(NFTContract.ownerOf(nftId) == msg.sender, 'not nft owner');\\r\\n\\r\\n            NFTContract.transferFrom(msg.sender, address(0xdead), nftId);\\r\\n            if (typeInfo == 1) {\\r\\n                // time NFT\\r\\n                timeReduction += nftInfo.weight;\\r\\n            } else {\\r\\n                seedAmountBoost += nftInfo.weight;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        time = (time * (100 - timeReduction)) / 100;\\r\\n        seedAmount = (defaultSeedAmount * (100 + seedAmountBoost)) / 100;\\r\\n        if (time < minimumTime) time = minimumTime;\\r\\n        info.lifeCycle = time;\\r\\n        info.amount = amount;\\r\\n        info.seedAmount = seedAmount;\\r\\n        info.startTimestamp = block.timestamp;\\r\\n        info.lastClaimTimestamp = block.timestamp;\\r\\n        info.isStaking = true;\\r\\n        info.nftIds = nftIds;\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function harvest() external {\\r\\n        StakingInfo storage info = userStakingInfo[msg.sender];\\r\\n        require(info.isStaking, 'not staking');\\r\\n        require(info.lastClaimTimestamp + info.lifeCycle < block.timestamp, 'not yet claimable');\\r\\n\\r\\n        info.lastClaimTimestamp = block.timestamp;\\r\\n        seed.transfer(msg.sender, info.seedAmount);\\r\\n        emit SeedHarvested(msg.sender, info.seedAmount);\\r\\n    }\\r\\n\\r\\n    function withdraw() external {\\r\\n        StakingInfo storage info = userStakingInfo[msg.sender];\\r\\n        require(info.isStaking, 'not staking');\\r\\n        info.isStaking = false;\\r\\n        info.amount = 0;\\r\\n        plant.transfer(msg.sender, info.amount);\\r\\n        emit StoppedStaking(msg.sender);\\r\\n    }\\r\\n\\r\\n    function getUserStakingInfo(address user) external view returns (StakingInfo memory) {\\r\\n        return userStakingInfo[user];\\r\\n    }\\r\\n\\r\\n    function setTokenAddresses(address plantAddress, address seedAddress, address nftAddress) external onlyOwner {\\r\\n        plant = IERC20(plantAddress);\\r\\n        seed = IERC20(seedAddress);\\r\\n        NFTContract = ITYRHBoosterNFT(nftAddress);\\r\\n    }\\r\\n\\r\\n    function setInitialValues(uint256 _initialValue, uint256 _minimumTime, uint256 _initialTime) external onlyOwner {\\r\\n        initialValue = _initialValue;\\r\\n        initialTime = _initialTime;\\r\\n        minimumTime = _minimumTime;\\r\\n    }\\r\\n\\r\\n    function setSeedNFTTypes(uint256[] memory typeIds, uint256[] memory values) external onlyOwner {\\r\\n        uint256 i;\\r\\n        uint256 length = typeIds.length;\\r\\n        for (i = 0; i < length; i++) {\\r\\n            nftType[typeIds[i]] = values[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawSeed() external onlyOwner {\\r\\n        seed.transfer(msg.sender, seed.balanceOf(address(this)));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Plant/Plantation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../../interfaces/IBoosterNFT.sol';\\r\\n\\r\\ncontract Plantation is Ownable {\\r\\n    IERC20 public plant;\\r\\n    IERC20 public water;\\r\\n    ITYRHBoosterNFT public boosterNFT;\\r\\n    address public reservoirAddress;\\r\\n    address public sproutHouseAddress;\\r\\n    uint256 public defaultGrowthTime;\\r\\n    uint256 public totalTreeWeight;\\r\\n    uint256 public treeCount;\\r\\n    uint256 public totalStep;\\r\\n    mapping(uint256 => uint256) public nftType; // 1: time, 2: water, 3: weight\\r\\n    mapping(address => uint256[]) public userTrees;\\r\\n    mapping(uint256 => uint256[]) public treeNFTIds;\\r\\n    TreeType[] public treeTypes;\\r\\n    Tree[] public trees;\\r\\n\\r\\n    struct TreeType {\\r\\n        uint256 amount;\\r\\n        uint256 weight;\\r\\n    }\\r\\n\\r\\n    struct Tree {\\r\\n        uint256 id;\\r\\n        uint256 typeId;\\r\\n        address owner;\\r\\n        uint256 weight;\\r\\n        uint256 stepStartTimestamp;\\r\\n        uint256 stepEndTimestamp;\\r\\n        uint256 currentStep;\\r\\n        uint256 growthTime;\\r\\n        uint256 waterAmount;\\r\\n        uint256 plantAmount;\\r\\n        bool grownUp;\\r\\n    }\\r\\n\\r\\n    struct TreeWithNFTIds {\\r\\n        uint256 id;\\r\\n        uint256 typeId;\\r\\n        address owner;\\r\\n        uint256 weight;\\r\\n        uint256 stepStartTimestamp;\\r\\n        uint256 stepEndTimestamp;\\r\\n        uint256 currentStep;\\r\\n        uint256 growthTime;\\r\\n        uint256 waterAmount;\\r\\n        uint256 plantAmount;\\r\\n        uint256[] nftIds;\\r\\n        bool grownUp;\\r\\n    }\\r\\n\\r\\n    event DeployedTree(uint256 treeId, address user, uint256 plantAmount, uint256 waterAmount);\\r\\n    event TreeGrownUp(uint256 treeId, address owner, uint256 weight);\\r\\n\\r\\n    constructor(\\r\\n        address plantTokenAddr,\\r\\n        address waterTokenAddr,\\r\\n        address NFTAddr,\\r\\n        address _sproutHouseAddress,\\r\\n        address _reservoirAddress\\r\\n    ) {\\r\\n        plant = IERC20(plantTokenAddr);\\r\\n        water = IERC20(waterTokenAddr);\\r\\n        boosterNFT = ITYRHBoosterNFT(NFTAddr);\\r\\n        sproutHouseAddress = _sproutHouseAddress;\\r\\n        reservoirAddress = _reservoirAddress;\\r\\n        defaultGrowthTime = 3600 * 24 * 25; // 25 days\\r\\n        totalStep = 5;\\r\\n\\r\\n        treeTypes.push(TreeType(25 * 1000000 * 10 ** 18, 100)); // Cattails\\r\\n        treeTypes.push(TreeType(50 * 1000000 * 10 ** 18, 250)); // Bush\\r\\n        treeTypes.push(TreeType(100 * 1000000 * 10 ** 18, 600)); // Tree\\r\\n        treeTypes.push(TreeType(250 * 1000000 * 10 ** 18, 1700)); // Pine\\r\\n        treeTypes.push(TreeType(375 * 1000000 * 10 ** 18, 2600)); // Plam\\r\\n        treeTypes.push(TreeType(500 * 1000000 * 10 ** 18, 4000)); // Sherman\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev deploy a tree\\r\\n     * @param typeId type of tree\\r\\n     * @param nftIds ids of NFTs\\r\\n     * NOTE the array should have fixed length of 3,\\r\\n     * each element indicates NFT ids for each NFT type - Time, Water, Weight.\\r\\n     * If the value is 0, it means no NFTs used for that type.\\r\\n     */\\r\\n    function deployTree(uint256 typeId, uint256[] memory nftIds) external {\\r\\n        TreeType memory treeType = treeTypes[typeId];\\r\\n        require(typeId < treeTypes.length, 'invalid typeId');\\r\\n        require(nftIds.length == 3, 'not enough nfts');\\r\\n        uint256 weight = treeType.weight;\\r\\n        uint256 waterAmount = treeType.amount;\\r\\n        uint256 plantAmount = treeType.amount;\\r\\n        uint256 growthTime = defaultGrowthTime;\\r\\n        uint256 weightBoost;\\r\\n        uint256 timeReduction;\\r\\n        uint256 waterReduction;\\r\\n        uint256 i;\\r\\n\\r\\n        for (i = 0; i < nftIds.length; i++) {\\r\\n            if (nftIds[i] == 0) continue;\\r\\n            ITYRHBoosterNFT.NFT memory nft = boosterNFT.nfts(nftIds[i]);\\r\\n            uint256 typeInfo = nftType[nft.typeId];\\r\\n            require(boosterNFT.ownerOf(nftIds[i]) == msg.sender, 'not nft owner');\\r\\n            require(typeInfo == i + 1, 'not tree nft');\\r\\n\\r\\n            // burn NFT\\r\\n            boosterNFT.transferFrom(msg.sender, address(0xdead), nftIds[i]);\\r\\n\\r\\n            if (typeInfo == 1) {\\r\\n                // time NFT\\r\\n                timeReduction += nft.weight;\\r\\n            } else if (typeInfo == 2) {\\r\\n                // water NFT\\r\\n                waterReduction += nft.weight;\\r\\n            } else if (typeInfo == 3) {\\r\\n                // weight NFT\\r\\n                weightBoost += nft.weight;\\r\\n            }\\r\\n        }\\r\\n        weight = (weight * (100 + weightBoost)) / 100;\\r\\n        waterAmount = (waterAmount * (100 - waterReduction)) / 100;\\r\\n        growthTime = (growthTime * (100 - timeReduction)) / 100;\\r\\n        plant.transferFrom(msg.sender, sproutHouseAddress, plantAmount);\\r\\n        // Add Tree\\r\\n        trees.push();\\r\\n        uint256 treeId = trees.length - 1;\\r\\n        Tree storage myTree = trees[treeId];\\r\\n        myTree.id = treeId;\\r\\n        myTree.typeId = typeId;\\r\\n        myTree.plantAmount = plantAmount;\\r\\n        myTree.waterAmount = waterAmount;\\r\\n        myTree.growthTime = growthTime;\\r\\n        myTree.weight = weight;\\r\\n        myTree.owner = msg.sender;\\r\\n        myTree.currentStep = 0;\\r\\n        myTree.stepStartTimestamp = block.timestamp;\\r\\n        myTree.stepEndTimestamp = block.timestamp;\\r\\n        treeNFTIds[treeId] = nftIds;\\r\\n        userTrees[msg.sender].push(treeId);\\r\\n        treeCount++;\\r\\n        emit DeployedTree(treeId, msg.sender, plantAmount, waterAmount);\\r\\n    }\\r\\n\\r\\n    function waterTree(uint256 treeId) external {\\r\\n        Tree memory myTree = trees[treeId];\\r\\n        uint256 _totalStep = totalStep;\\r\\n        require(myTree.owner == msg.sender, 'not owner');\\r\\n        require(!myTree.grownUp, 'Already grown up');\\r\\n        require(block.timestamp > myTree.stepEndTimestamp, 'step not finished');\\r\\n        water.transferFrom(msg.sender, reservoirAddress, myTree.waterAmount / _totalStep);\\r\\n        trees[treeId].currentStep += 1;\\r\\n        if (myTree.currentStep == _totalStep) {\\r\\n            trees[treeId].grownUp = true;\\r\\n            totalTreeWeight += myTree.weight;\\r\\n            emit TreeGrownUp(treeId, myTree.owner, myTree.weight);\\r\\n        } else {\\r\\n            trees[treeId].stepStartTimestamp = block.timestamp;\\r\\n            trees[treeId].stepEndTimestamp = block.timestamp + myTree.growthTime / _totalStep;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateTreeType(uint256 typeId, uint256 amount, uint256 weight) external onlyOwner {\\r\\n        TreeType storage treeType = treeTypes[typeId];\\r\\n        treeType.amount = amount;\\r\\n        treeType.weight = weight;\\r\\n    }\\r\\n\\r\\n    function addTreeType(uint256 amount, uint256 weight) external onlyOwner {\\r\\n        treeTypes.push();\\r\\n        TreeType storage treeType = treeTypes[treeTypes.length - 1];\\r\\n        treeType.amount = amount;\\r\\n        treeType.weight = weight;\\r\\n    }\\r\\n\\r\\n    function setNFTType(uint256[] memory typeIds, uint256[] memory values) external onlyOwner {\\r\\n        uint256 i;\\r\\n        uint256 length = typeIds.length;\\r\\n        for (i = 0; i < length; i++) {\\r\\n            nftType[typeIds[i]] = values[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setDefaultGrowthTime(uint256 time) external onlyOwner {\\r\\n        defaultGrowthTime = time;\\r\\n    }\\r\\n\\r\\n    function setBoosterNFTAddress(address addr) external onlyOwner {\\r\\n        boosterNFT = ITYRHBoosterNFT(addr);\\r\\n    }\\r\\n\\r\\n    function setWaterAddress(address addr) external onlyOwner {\\r\\n        water = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setPlantAddress(address addr) external onlyOwner {\\r\\n        plant = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setSproutHouseAddress(address addr) external onlyOwner {\\r\\n        sproutHouseAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setReservoirAddress(address addr) external onlyOwner {\\r\\n        reservoirAddress = addr;\\r\\n    }\\r\\n\\r\\n    function getTreeTypes() external view returns (TreeType[] memory types) {\\r\\n        types = treeTypes;\\r\\n    }\\r\\n\\r\\n    function getUserTrees(address user) external view returns (TreeWithNFTIds[] memory list) {\\r\\n        uint256 length = userTrees[user].length;\\r\\n        list = new TreeWithNFTIds[](length);\\r\\n        for (uint i = 0; i < length; i++) {\\r\\n            uint256 treeId = userTrees[user][i];\\r\\n            Tree memory tree = trees[treeId];\\r\\n            list[i].id = tree.id;\\r\\n            list[i].typeId = tree.typeId;\\r\\n            list[i].owner = tree.owner;\\r\\n            list[i].weight = tree.weight;\\r\\n            list[i].stepStartTimestamp = tree.stepStartTimestamp;\\r\\n            list[i].stepEndTimestamp = tree.stepEndTimestamp;\\r\\n            list[i].currentStep = tree.currentStep;\\r\\n            list[i].growthTime = tree.growthTime;\\r\\n            list[i].waterAmount = tree.waterAmount;\\r\\n            list[i].plantAmount = tree.plantAmount;\\r\\n            list[i].grownUp = tree.grownUp;\\r\\n            list[i].nftIds = treeNFTIds[treeId];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserTreesWithoutNFTs(address user) external view returns (Tree[] memory list) {\\r\\n        uint256 length = userTrees[user].length;\\r\\n        list = new Tree[](length);\\r\\n        for (uint i = 0; i < length; i++) {\\r\\n            list[i] = trees[userTrees[user][i]];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/MarketplaceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\nimport '../interfaces/ITYRH.sol';\\r\\nimport '../interfaces/IBoosterNFT.sol';\\r\\nimport '../interfaces/IPulseXRouter.sol';\\r\\n\\r\\ncontract TYRHNFTMarketplaceV2 is OwnableUpgradeable {\\r\\n    IPulseXRouter02 public router;\\r\\n    Listing[] public listings;\\r\\n    IERC20 public swapToken;\\r\\n    uint256 public totalCount;\\r\\n    uint256 public royalty;\\r\\n    address public sendTo;\\r\\n    mapping(address => bool) isMarketCurrency;\\r\\n    mapping(address => bool) isValidNFTContract;\\r\\n    struct Listing {\\r\\n        address nftAddress;\\r\\n        uint256 listingId;\\r\\n        uint256 tokenId;\\r\\n        address seller;\\r\\n        address buyer;\\r\\n        uint256 amount;\\r\\n        address currency;\\r\\n        uint256 listedAt;\\r\\n        uint256 finishedAt;\\r\\n        uint256 status; // 0: listing, 1: success, 2: canceled\\r\\n    }\\r\\n\\r\\n    event NFTListed(uint256 listingId, address user, uint256 tokenId, uint256 amount, address currency);\\r\\n    event NFTBought(\\r\\n        uint256 listingId,\\r\\n        address buyer,\\r\\n        address seller,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        address currency,\\r\\n        address swapToken,\\r\\n        uint256 swappedAmount\\r\\n    );\\r\\n    event ListingCanceled(uint256 listingId);\\r\\n\\r\\n    function initialize(\\r\\n        address[] memory nftAddresses,\\r\\n        address[] memory currencies,\\r\\n        address swapTokenAddress\\r\\n    ) external initializer {\\r\\n        router = IPulseXRouter02(0x165C3410fC91EF562C50559f7d2289fEbed552d9);\\r\\n        uint256 i;\\r\\n        for (i = 0; i < nftAddresses.length; i++) {\\r\\n            isValidNFTContract[nftAddresses[i]] = true;\\r\\n        }\\r\\n\\r\\n        for (i = 0; i < currencies.length; i++) {\\r\\n            isMarketCurrency[currencies[i]] = true;\\r\\n        }\\r\\n\\r\\n        royalty = 5; // 5%\\r\\n        sendTo = address(0xdead); // burn\\r\\n        swapToken = IERC20(swapTokenAddress); // tyrh\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function listNFT(address nftAddress, uint256 tokenId, address currency, uint256 amount) external {\\r\\n        ITYRHBoosterNFT nftContract = ITYRHBoosterNFT(nftAddress);\\r\\n        require(nftContract.ownerOf(tokenId) == msg.sender, 'not owner');\\r\\n        require(isMarketCurrency[currency], 'not valid currency');\\r\\n        require(isValidNFTContract[nftAddress], 'not valid NFT contract');\\r\\n\\r\\n        nftContract.transferFrom(msg.sender, address(this), tokenId);\\r\\n        listings.push();\\r\\n\\r\\n        uint256 id = listings.length - 1;\\r\\n        Listing storage item = listings[id];\\r\\n        item.nftAddress = nftAddress;\\r\\n        item.listingId = id;\\r\\n        item.tokenId = tokenId;\\r\\n        item.seller = msg.sender;\\r\\n        item.amount = amount;\\r\\n        item.currency = currency;\\r\\n        item.listedAt = block.timestamp;\\r\\n        item.status = 0;\\r\\n        totalCount++;\\r\\n\\r\\n        emit NFTListed(id, msg.sender, tokenId, amount, currency);\\r\\n    }\\r\\n\\r\\n    function buyNFT(uint256 listingId) external {\\r\\n        Listing memory item = listings[listingId];\\r\\n        IERC20 currency = IERC20(item.currency);\\r\\n        ITYRHBoosterNFT nftContract = ITYRHBoosterNFT(item.nftAddress);\\r\\n        uint256 royaltyAmount = (item.amount * royalty) / 100;\\r\\n\\r\\n        currency.transferFrom(msg.sender, item.seller, item.amount - royaltyAmount);\\r\\n        currency.transferFrom(msg.sender, address(this), royaltyAmount);\\r\\n        nftContract.transferFrom(address(this), msg.sender, item.tokenId);\\r\\n\\r\\n        uint256 swappedAmount = _swapTransfer(item.currency, royaltyAmount);\\r\\n\\r\\n        listings[listingId].buyer = msg.sender;\\r\\n        listings[listingId].status = 1;\\r\\n        listings[listingId].finishedAt = block.timestamp;\\r\\n\\r\\n        emit NFTBought(\\r\\n            listingId,\\r\\n            msg.sender,\\r\\n            item.seller,\\r\\n            item.tokenId,\\r\\n            item.amount,\\r\\n            item.currency,\\r\\n            address(swapToken),\\r\\n            swappedAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function cancelListing(uint256 listingId) external {\\r\\n        Listing storage item = listings[listingId];\\r\\n        require(item.seller == msg.sender, 'not owner');\\r\\n        require(item.status == 0, 'not active');\\r\\n\\r\\n        ITYRHBoosterNFT nftContract = ITYRHBoosterNFT(item.nftAddress);\\r\\n        nftContract.transferFrom(address(this), item.seller, item.tokenId);\\r\\n        item.status = 2;\\r\\n        item.finishedAt = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function _swapTransfer(address token, uint256 amount) internal returns (uint256 outputAmount) {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = token;\\r\\n        path[1] = router.WPLS();\\r\\n        path[2] = address(swapToken);\\r\\n\\r\\n        IERC20(token).approve(address(router), amount);\\r\\n        uint256 balanceBefore = swapToken.balanceOf(address(this));\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\\r\\n        uint256 balanceAfter = swapToken.balanceOf(address(this));\\r\\n        swapToken.transfer(sendTo, balanceAfter - balanceBefore);\\r\\n        outputAmount = balanceAfter - balanceBefore;\\r\\n    }\\r\\n\\r\\n    function getListings(uint256 start, uint256 length) external view returns (Listing[] memory list) {\\r\\n        if (start >= listings.length) return list;\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > listings.length) end = listings.length;\\r\\n        list = new Listing[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            list[i - start] = listings[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setNFTContractValid(address addr, bool value) external onlyOwner {\\r\\n        isValidNFTContract[addr] = value;\\r\\n    }\\r\\n\\r\\n    function setCurrency(address addr, bool value) external onlyOwner {\\r\\n        isMarketCurrency[addr] = value;\\r\\n    }\\r\\n\\r\\n    function setRoyalty(uint256 value) external onlyOwner {\\r\\n        royalty = value;\\r\\n    }\\r\\n\\r\\n    function setSendTo(address addr) external onlyOwner {\\r\\n        sendTo = addr;\\r\\n    }\\r\\n\\r\\n    function setSwapToken(address addr) external onlyOwner {\\r\\n        swapToken = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITYRH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface ITYRH {\\r\\n    function isUserAddress(address addr) external view returns (bool);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function getRHTokens() external view returns (address[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Marketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '../interfaces/ITYRH.sol';\\r\\nimport '../interfaces/IBoosterNFT.sol';\\r\\nimport '../interfaces/IPulseXRouter.sol';\\r\\n\\r\\ncontract TYRHNFTMarketplace is Ownable {\\r\\n    ITYRHBoosterNFT public nftContract;\\r\\n    IPulseXRouter02 public immutable router;\\r\\n    Listing[] public listings;\\r\\n    IERC20 public swapToken;\\r\\n    uint256 public totalCount;\\r\\n    uint256 public royalty;\\r\\n    address public sendTo;\\r\\n    mapping(address => bool) isMarketCurrency;\\r\\n    struct Listing {\\r\\n        uint256 listingId;\\r\\n        uint256 tokenId;\\r\\n        address seller;\\r\\n        address buyer;\\r\\n        uint256 amount;\\r\\n        address currency;\\r\\n        uint256 listedAt;\\r\\n        uint256 finishedAt;\\r\\n        uint256 status; // 0: listing, 1: success, 2: canceled\\r\\n    }\\r\\n\\r\\n    event NFTListed(uint256 listingId, address user, uint256 tokenId, uint256 amount, address currency);\\r\\n    event NFTBought(\\r\\n        uint256 listingId,\\r\\n        address buyer,\\r\\n        address seller,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        address currency,\\r\\n        address swapToken,\\r\\n        uint256 swappedAmount\\r\\n    );\\r\\n    event ListingCanceled(uint256 listingId);\\r\\n\\r\\n    constructor(address nftAddress, address[] memory currencies, address swapTokenAddress) {\\r\\n        nftContract = ITYRHBoosterNFT(nftAddress);\\r\\n        router = IPulseXRouter02(0x165C3410fC91EF562C50559f7d2289fEbed552d9);\\r\\n        for (uint256 i = 0; i < currencies.length; i++) {\\r\\n            isMarketCurrency[currencies[i]] = true;\\r\\n        }\\r\\n\\r\\n        royalty = 5; // 5%\\r\\n        sendTo = address(0xdead); // burn\\r\\n        swapToken = IERC20(swapTokenAddress); // tyrh\\r\\n    }\\r\\n\\r\\n    function listNFT(uint256 tokenId, address currency, uint256 amount) external {\\r\\n        require(nftContract.ownerOf(tokenId) == msg.sender, 'not owner');\\r\\n        require(isMarketCurrency[currency], 'not valid currency');\\r\\n\\r\\n        nftContract.transferFrom(msg.sender, address(this), tokenId);\\r\\n        listings.push();\\r\\n\\r\\n        uint256 id = listings.length - 1;\\r\\n        Listing storage item = listings[id];\\r\\n        item.listingId = id;\\r\\n        item.tokenId = tokenId;\\r\\n        item.seller = msg.sender;\\r\\n        item.amount = amount;\\r\\n        item.currency = currency;\\r\\n        item.listedAt = block.timestamp;\\r\\n        item.status = 0;\\r\\n        totalCount++;\\r\\n\\r\\n        emit NFTListed(id, msg.sender, tokenId, amount, currency);\\r\\n    }\\r\\n\\r\\n    function buyNFT(uint256 listingId) external {\\r\\n        Listing memory item = listings[listingId];\\r\\n        IERC20 currency = IERC20(item.currency);\\r\\n\\r\\n        uint256 royaltyAmount = (item.amount * royalty) / 100;\\r\\n\\r\\n        currency.transferFrom(msg.sender, item.seller, item.amount - royaltyAmount);\\r\\n        currency.transferFrom(msg.sender, address(this), royaltyAmount);\\r\\n        nftContract.transferFrom(address(this), msg.sender, item.tokenId);\\r\\n\\r\\n        uint256 swappedAmount = _swapTransfer(item.currency, royaltyAmount);\\r\\n\\r\\n        listings[listingId].buyer = msg.sender;\\r\\n        listings[listingId].status = 1;\\r\\n        listings[listingId].finishedAt = block.timestamp;\\r\\n\\r\\n        emit NFTBought(\\r\\n            listingId,\\r\\n            msg.sender,\\r\\n            item.seller,\\r\\n            item.tokenId,\\r\\n            item.amount,\\r\\n            item.currency,\\r\\n            address(swapToken),\\r\\n            swappedAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function cancelListing(uint256 listingId) external {\\r\\n        Listing storage item = listings[listingId];\\r\\n        require(item.seller == msg.sender, 'not owner');\\r\\n        require(item.status == 0, 'not active');\\r\\n\\r\\n        nftContract.transferFrom(address(this), item.seller, item.tokenId);\\r\\n        item.status = 2;\\r\\n        item.finishedAt = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function _swapTransfer(address token, uint256 amount) internal returns (uint256 outputAmount) {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = token;\\r\\n        path[1] = router.WPLS();\\r\\n        path[2] = address(swapToken);\\r\\n\\r\\n        IERC20(token).approve(address(router), amount);\\r\\n        uint256 balanceBefore = swapToken.balanceOf(address(this));\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\\r\\n        uint256 balanceAfter = swapToken.balanceOf(address(this));\\r\\n        swapToken.transfer(sendTo, balanceAfter - balanceBefore);\\r\\n        outputAmount = balanceAfter - balanceBefore;\\r\\n    }\\r\\n\\r\\n    function getListings(uint256 start, uint256 length) external view returns (Listing[] memory list) {\\r\\n        if (start >= listings.length) return list;\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > listings.length) end = listings.length;\\r\\n        list = new Listing[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            list[i - start] = listings[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setNFTContract(address addr) external onlyOwner {\\r\\n        nftContract = ITYRHBoosterNFT(addr);\\r\\n    }\\r\\n\\r\\n    function setCurrency(address addr, bool value) external onlyOwner {\\r\\n        isMarketCurrency[addr] = value;\\r\\n    }\\r\\n\\r\\n    function setRoyalty(uint256 value) external onlyOwner {\\r\\n        royalty = value;\\r\\n    }\\r\\n\\r\\n    function setSendTo(address addr) external onlyOwner {\\r\\n        sendTo = addr;\\r\\n    }\\r\\n\\r\\n    function setSwapToken(address addr) external onlyOwner {\\r\\n        swapToken = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/BurnPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '../interfaces/ITYRH.sol';\\r\\n\\r\\ncontract TYRHBurnPool {\\r\\n    address public TYRHAddr;\\r\\n    mapping(address => uint256) public burntAmount;\\r\\n    event RHTokenBurnt(address token, uint256 amount);\\r\\n\\r\\n    constructor(address _TYRHAddr) {\\r\\n        TYRHAddr = _TYRHAddr;\\r\\n    }\\r\\n\\r\\n    function burn() external {\\r\\n        address[] memory tokens = ITYRH(TYRHAddr).getRHTokens();\\r\\n        address burnAddress = address(0xdead);\\r\\n        for (uint256 i = 0; i < tokens.length; i++) {\\r\\n            uint256 amount;\\r\\n            if (tokens[i] != address(0)) {\\r\\n                IERC20 token = IERC20(tokens[i]);\\r\\n                amount = token.balanceOf(address(this));\\r\\n                IERC20(tokens[i]).transfer(burnAddress, token.balanceOf(address(this)));\\r\\n            } else {\\r\\n                amount = address(this).balance;\\r\\n                payable(burnAddress).transfer(address(this).balance);\\r\\n            }\\r\\n            burntAmount[tokens[i]] += amount;\\r\\n            emit RHTokenBurnt(tokens[i], amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FortuneWheel/FortuneWheelCasinoNFT.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/Counters.sol';\\r\\nimport '../interfaces/IFortuneWheel.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\n\\r\\ncontract WheelCasinoNFT is ERC721URIStorage, Ownable {\\r\\n    using Counters for Counters.Counter;\\r\\n    Counters.Counter public _tokenIds;\\r\\n\\r\\n    address public wheelContractAddr;\\r\\n    address constant wbnbAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address constant pancakeFactoryAddr = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // testnet: 0x6725F303b657a9451d8BA641348b6761A6CC7a17, mainnet: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n\\r\\n    constructor() ERC721('BNBPot Fortune Wheel NFT', 'BNBPFW') {}\\r\\n\\r\\n    event Mint(uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev mint Casino NFTS\\r\\n     *\\r\\n     * @param tokenURI metadata url for NFT\\r\\n     * @param tokenList token address list that will be used in the casino\\r\\n     */\\r\\n    function mint(\\r\\n        string memory tokenURI,\\r\\n        address[] calldata tokenList,\\r\\n        string[] calldata tokenNames,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external onlyOwner {\\r\\n        require(maxBet > minBet, 'Min bet bigger than max bet');\\r\\n        require(fee < 100, 'fee should be less than 100%');\\r\\n\\r\\n        for (uint256 i = 0; i < tokenList.length; i++) {\\r\\n            if (tokenList[i] != address(0)) {\\r\\n                address BNB_Token_Pair = IPancakeFactory(pancakeFactoryAddr).getPair(tokenList[i], wbnbAddr);\\r\\n                require(BNB_Token_Pair != address(0));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _tokenIds.increment();\\r\\n        uint256 newItemId = _tokenIds.current();\\r\\n\\r\\n        _mint(msg.sender, newItemId);\\r\\n        _setTokenURI(newItemId, tokenURI);\\r\\n\\r\\n        IFortuneWheel(wheelContractAddr).addCasino(newItemId, tokenList, tokenNames, maxBet, minBet, fee);\\r\\n        emit Mint(newItemId);\\r\\n    }\\r\\n\\r\\n    function setFortuneWheelContract(address addr) external onlyOwner {\\r\\n        wheelContractAddr = addr;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IFortuneWheel.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IFortuneWheel {\\r\\n    struct Casino {\\r\\n        address[] tokenList;\\r\\n        string tokenName;\\r\\n        uint256 liquidity;\\r\\n        uint256 maxBet;\\r\\n        uint256 minBet;\\r\\n        uint256 fee;\\r\\n    }\\r\\n\\r\\n    function addCasino(\\r\\n        uint256 tokenId,\\r\\n        address[] calldata tokenList,\\r\\n        string[] calldata tokenNames,\\r\\n        uint256 maxBet,\\r\\n        uint256 minBet,\\r\\n        uint256 fee\\r\\n    ) external;\\r\\n\\r\\n    function placeBetsWithTokens(uint256 tokenId, uint256 amount) external;\\r\\n\\r\\n    function placeBetsWithEth(uint256 tokenId, uint256 amount) external payable;\\r\\n\\r\\n    function addLiquidtyWithTokens(uint256 tokenId, uint256 amount) external;\\r\\n\\r\\n    function removeLiquidtyWithTokens(uint256 tokenId, uint256 amount) external;\\r\\n\\r\\n    function addLiquidtyWithEth(uint256 tokenId, uint256 amount) external payable;\\r\\n\\r\\n    function removeLiquidtyWithEth(uint256 tokenId, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Claim.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract TYRHSnapshotClaim is Ownable {\\r\\n    IERC20 public token;\\r\\n\\r\\n    struct ClaimInfo {\\r\\n        uint256 amount;\\r\\n        bool claimed;\\r\\n    }\\r\\n    mapping(address => ClaimInfo) public userInfo;\\r\\n    event Claimed(address user, uint256 amount);\\r\\n\\r\\n    constructor(address tokenAddr) {\\r\\n        token = IERC20(tokenAddr);\\r\\n    }\\r\\n\\r\\n    function setClaimInfo(address[] memory users, uint256[] memory amounts) external onlyOwner {\\r\\n        for (uint256 i = 0; i < users.length; i++) {\\r\\n            userInfo[users[i]].amount = amounts[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyOwner {\\r\\n        token = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function claim() external {\\r\\n        ClaimInfo storage info = userInfo[msg.sender];\\r\\n        require(!info.claimed, 'Already Claimed');\\r\\n        token.transfer(msg.sender, info.amount);\\r\\n        info.claimed = true;\\r\\n        emit Claimed(msg.sender, info.amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) external onlyOwner {\\r\\n        token.transfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PulseFaucet/PulseFaucet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.7;\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract PulseFaucet is Ownable {\\r\\n    uint256 transferAmount = 2500 * 10 ** 18;\\r\\n    mapping(address => bool) public isWhitelisted;\\r\\n\\r\\n    function setWhitelisted(address addr, bool value) external onlyOwner {\\r\\n        isWhitelisted[addr] = value;\\r\\n    }\\r\\n\\r\\n    function transferPLS(address addr) external {\\r\\n        require(isWhitelisted[msg.sender], 'not hot wallet');\\r\\n        require(address(this).balance > transferAmount, 'not enough balance');\\r\\n        bool sent = payable(addr).send(transferAmount);\\r\\n        require(sent, 'failed sending');\\r\\n    }\\r\\n\\r\\n    function withdrawPLS(address addr) external onlyOwner {\\r\\n        bool sent = payable(addr).send(address(this).balance);\\r\\n        require(sent, 'failed sending');\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceCall/PriceCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IPancakeFactory.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\ncontract PriceCall is OwnableUpgradeable {\\r\\n    struct PriceToken {\\r\\n        string tokenName;\\r\\n        address priceFeed;\\r\\n        uint256 digit;\\r\\n    }\\r\\n\\r\\n    struct BetToken {\\r\\n        string tokenName;\\r\\n        address tokenAddress;\\r\\n        bool isStable;\\r\\n    }\\r\\n\\r\\n    struct Bet {\\r\\n        uint256 betId;\\r\\n        uint256 betTokenId;\\r\\n        address player;\\r\\n        uint256 usdValue;\\r\\n    }\\r\\n\\r\\n    struct StableCoinAmount {\\r\\n        address tokenAddress;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    enum RoundStatus {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        CANCELED,\\r\\n        EXPIRED,\\r\\n        FINISHED\\r\\n    }\\r\\n\\r\\n    struct Round {\\r\\n        uint256 roundId;\\r\\n        uint256 priceTokenId;\\r\\n        uint256 operator; // 0: >=, 1: <=\\r\\n        uint256 maxUSDPerPlayer;\\r\\n        uint256 minUSDPerPlayer;\\r\\n        uint256 pricePoint;\\r\\n        uint256 currentTotalUSD;\\r\\n        uint256 roundMaximumValue;\\r\\n        uint256 recordedPrice;\\r\\n        address creator;\\r\\n        bool isCreatorWinner;\\r\\n        RoundStatus status;\\r\\n        Bet[] bets;\\r\\n        StableCoinAmount[] stableCoinAmounts;\\r\\n    }\\r\\n\\r\\n    struct RoundTimeInfo {\\r\\n        uint256 createdTime;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n        uint256 expireTime;\\r\\n    }\\r\\n\\r\\n    struct RoundOption {\\r\\n        bool onlyOneTaker;\\r\\n        bool isPrivate;\\r\\n        bool startEarlyEnabled;\\r\\n    }\\r\\n\\r\\n    PriceToken[] public priceTokens;\\r\\n    BetToken[] public betTokens;\\r\\n    Round[] public rounds;\\r\\n    RoundOption[] public roundOptions;\\r\\n    RoundTimeInfo[] public roundTimeInfos;\\r\\n\\r\\n    mapping(address => bool) private isStable;\\r\\n\\r\\n    uint256 public roundIds;\\r\\n    uint256 public fee;\\r\\n\\r\\n    address public BNBPAddr;\\r\\n    address public potContractAddr;\\r\\n    address internal wbnbAddr; // testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, mainnet: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\r\\n    address internal pancakeRouterAddr; // testnet: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1, mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    address public usdtAddr; // testnet: 0x4608Ea31fA832ce7DCF56d78b5434b49830E91B1, mainnet: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\\r\\n    address public botAddress;\\r\\n    bool public isBotEnabled;\\r\\n    mapping(address => uint256) public userLastCreatedRoundId;\\r\\n    uint256 public botFee;\\r\\n\\r\\n    event RoundCreated(\\r\\n        uint256 roundId,\\r\\n        uint256 priceTokenId,\\r\\n        uint256 operator,\\r\\n        uint256 maxUSDPerPlayer,\\r\\n        uint256 minUSDPerPlayer,\\r\\n        uint256 creatorUSDValue,\\r\\n        uint256 createdTime,\\r\\n        uint256 endTime,\\r\\n        uint256 expireTime,\\r\\n        uint256 pricePoint,\\r\\n        uint256 roundMaximumValue,\\r\\n        address creator,\\r\\n        bool isPrivate,\\r\\n        bool onlyOneTaker\\r\\n    );\\r\\n    event BetPlaced(uint256 roundId, uint256 betId, address player, uint256 usdValue);\\r\\n    event RoundStarted(uint256 roundId, uint256 roundMaximumValue, uint256 creatorUSDValue, uint256 timestamp);\\r\\n    event RoundCanceled(uint256 roundId, uint256 feeAmount, uint256 creatorReturnedAmount);\\r\\n    event RoundFinished(uint256 roundId, uint256 recordedPrice, bool isCreatorWinner, uint256 feeAmount);\\r\\n    event PlayerWon(uint256 roundId, uint256 betId, address player, uint256 amount);\\r\\n\\r\\n    modifier onlyRoundCreator(uint256 roundId) {\\r\\n        require(rounds[roundId].creator == msg.sender, 'only creator');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        address _BNBPAddr,\\r\\n        address _potContractAddr,\\r\\n        address _usdtAddr,\\r\\n        address _routerAddr,\\r\\n        PriceToken[] calldata _priceTokens\\r\\n    ) external initializer {\\r\\n        BNBPAddr = _BNBPAddr;\\r\\n        potContractAddr = _potContractAddr;\\r\\n        usdtAddr = _usdtAddr;\\r\\n        pancakeRouterAddr = _routerAddr;\\r\\n        wbnbAddr = IPancakeRouter02(_routerAddr).WETH();\\r\\n\\r\\n        uint256 i;\\r\\n        for (i = 0; i < _priceTokens.length; i++) {\\r\\n            priceTokens.push(_priceTokens[i]);\\r\\n        }\\r\\n        fee = 5;\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function addPriceToken(string memory tokenName, address priceFeed, uint256 digit) external onlyOwner {\\r\\n        priceTokens.push(PriceToken(tokenName, priceFeed, digit));\\r\\n    }\\r\\n\\r\\n    function addBetToken(string memory tokenName, address tokenAddress, bool stable) external onlyOwner {\\r\\n        if (tokenAddress != address(0)) {\\r\\n            address pancakeFactoryAddr = IPancakeRouter02(pancakeRouterAddr).factory();\\r\\n            address BNB_Token_Pair = IPancakeFactory(pancakeFactoryAddr).getPair(tokenAddress, wbnbAddr);\\r\\n            require(BNB_Token_Pair != address(0), 'no pair with BNB');\\r\\n        }\\r\\n\\r\\n        betTokens.push(BetToken(tokenName, tokenAddress, stable));\\r\\n        if (stable) isStable[tokenAddress] = true;\\r\\n    }\\r\\n\\r\\n    function setBNBPAddress(address addr) external onlyOwner {\\r\\n        BNBPAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setPotContractAddr(address addr) external onlyOwner {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setBotAddress(address addr) external onlyOwner {\\r\\n        botAddress = addr;\\r\\n    }\\r\\n\\r\\n    function setBotEnabled(bool value) external onlyOwner {\\r\\n        isBotEnabled = value;\\r\\n    }\\r\\n\\r\\n    function setBotFee(uint256 value) external onlyOwner {\\r\\n        botFee = value;\\r\\n    }\\r\\n\\r\\n    function setFee(uint256 value) external onlyOwner {\\r\\n        fee = value;\\r\\n    }\\r\\n\\r\\n    function createRound(\\r\\n        uint256 priceTokenId,\\r\\n        uint256 endTime,\\r\\n        uint256 expireTime,\\r\\n        uint256 pricePoint,\\r\\n        uint256 operator,\\r\\n        uint256 maxUSDPerPlayer,\\r\\n        uint256 minUSDPerPlayer,\\r\\n        uint256 roundMaximumValue,\\r\\n        bool onlyOneTaker,\\r\\n        bool isPrivate,\\r\\n        bool startEarlyEnabled,\\r\\n        Bet calldata initialBet\\r\\n    ) external payable {\\r\\n        require(priceTokens.length > priceTokenId, 'not valid price token');\\r\\n        require(betTokens.length > initialBet.betTokenId, 'not valid bet token');\\r\\n        require(expireTime == 0 || (expireTime > block.timestamp && expireTime < endTime), 'expire time not valid');\\r\\n        require(roundMaximumValue > initialBet.usdValue, 'creator exceeds maximum');\\r\\n        require(operator < 2, 'invalid operator');\\r\\n\\r\\n        rounds.push();\\r\\n        Round storage newRound = rounds[roundIds];\\r\\n        newRound.roundId = roundIds;\\r\\n        newRound.creator = msg.sender;\\r\\n        newRound.priceTokenId = priceTokenId;\\r\\n        newRound.pricePoint = pricePoint;\\r\\n        newRound.operator = operator;\\r\\n        newRound.maxUSDPerPlayer = maxUSDPerPlayer;\\r\\n        newRound.minUSDPerPlayer = minUSDPerPlayer;\\r\\n        newRound.roundMaximumValue = roundMaximumValue;\\r\\n\\r\\n        roundTimeInfos.push();\\r\\n        RoundTimeInfo storage newTimeInfo = roundTimeInfos[roundIds];\\r\\n        newTimeInfo.createdTime = block.timestamp;\\r\\n        newTimeInfo.endTime = endTime;\\r\\n        newTimeInfo.expireTime = expireTime;\\r\\n\\r\\n        roundOptions.push();\\r\\n        RoundOption storage newRoundOption = roundOptions[roundIds];\\r\\n        newRoundOption.onlyOneTaker = onlyOneTaker;\\r\\n        newRoundOption.isPrivate = isPrivate;\\r\\n        newRoundOption.startEarlyEnabled = startEarlyEnabled;\\r\\n\\r\\n        emit RoundCreated(\\r\\n            roundIds,\\r\\n            priceTokenId,\\r\\n            operator,\\r\\n            maxUSDPerPlayer,\\r\\n            minUSDPerPlayer,\\r\\n            initialBet.usdValue,\\r\\n            block.timestamp,\\r\\n            endTime,\\r\\n            expireTime,\\r\\n            pricePoint,\\r\\n            roundMaximumValue,\\r\\n            msg.sender,\\r\\n            isPrivate,\\r\\n            onlyOneTaker\\r\\n        );\\r\\n        _swapBetTokenToStableCoin(roundIds, initialBet);\\r\\n        _addBet(roundIds, initialBet);\\r\\n\\r\\n        userLastCreatedRoundId[msg.sender] = roundIds;\\r\\n        roundIds++;\\r\\n    }\\r\\n\\r\\n    function placeBet(uint256 roundId, Bet calldata bet) external payable {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundOption storage roundOption = roundOptions[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n\\r\\n        require(roundId < roundIds, 'not valid round');\\r\\n        require(msg.sender != round.creator, 'creator');\\r\\n        require(round.status == RoundStatus.WAITING, 'cannot bet');\\r\\n        require(\\r\\n            (roundTimeInfo.expireTime == 0 && roundTimeInfo.endTime > block.timestamp) ||\\r\\n                roundTimeInfo.expireTime > block.timestamp,\\r\\n            'expired'\\r\\n        );\\r\\n        require(betTokens.length > bet.betTokenId, 'invalid bet token');\\r\\n        require(round.maxUSDPerPlayer == 0 || round.maxUSDPerPlayer >= bet.usdValue, 'max limit exceeded');\\r\\n        require(round.minUSDPerPlayer == 0 || round.minUSDPerPlayer <= bet.usdValue, 'min usd limit');\\r\\n        require(round.currentTotalUSD + bet.usdValue <= round.roundMaximumValue, 'exceeds maximum value');\\r\\n        require(\\r\\n            !roundOption.onlyOneTaker || bet.usdValue == round.roundMaximumValue - round.currentTotalUSD,\\r\\n            'only one taker'\\r\\n        );\\r\\n\\r\\n        _swapBetTokenToStableCoin(roundId, bet);\\r\\n        _addBet(roundId, bet);\\r\\n\\r\\n        if (rounds[roundId].currentTotalUSD == round.roundMaximumValue) {\\r\\n            round.status = RoundStatus.STARTED;\\r\\n            roundTimeInfo.startTime = block.timestamp;\\r\\n            emit RoundStarted(roundId, round.roundMaximumValue, round.bets[0].usdValue, block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function startEarly(uint256 roundId) external onlyRoundCreator(roundId) {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundOption storage roundOption = roundOptions[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n\\r\\n        require(roundId < rounds.length, 'not valid round');\\r\\n        require(round.status == RoundStatus.WAITING, 'cannot start');\\r\\n        require(\\r\\n            (roundTimeInfo.expireTime == 0 && roundTimeInfo.endTime > block.timestamp) ||\\r\\n                block.timestamp < roundTimeInfo.expireTime,\\r\\n            'expired'\\r\\n        );\\r\\n        require(roundOption.startEarlyEnabled, 'start early not enabled');\\r\\n        require(round.bets.length >= 2, 'not enough players');\\r\\n\\r\\n        uint256 originalCreatorBet = round.bets[0].usdValue;\\r\\n        uint256 adjustedCreatorBet = (originalCreatorBet * (round.currentTotalUSD - originalCreatorBet)) /\\r\\n            (round.roundMaximumValue - originalCreatorBet);\\r\\n        uint256 withdrawAmount = originalCreatorBet - adjustedCreatorBet;\\r\\n        uint256 length = round.stableCoinAmounts.length;\\r\\n\\r\\n        // Send remaining money back to creator\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (round.stableCoinAmounts[i].amount > withdrawAmount) {\\r\\n                _transfer(msg.sender, round.stableCoinAmounts[i].tokenAddress, withdrawAmount);\\r\\n                round.stableCoinAmounts[i].amount -= withdrawAmount;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        round.currentTotalUSD -= withdrawAmount;\\r\\n        round.roundMaximumValue = round.currentTotalUSD;\\r\\n        round.bets[0].usdValue = adjustedCreatorBet;\\r\\n        round.status = RoundStatus.STARTED;\\r\\n        roundTimeInfo.startTime = block.timestamp;\\r\\n        emit RoundStarted(roundId, round.roundMaximumValue, adjustedCreatorBet, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function cancelRound(uint256 roundId) external onlyRoundCreator(roundId) {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n        Bet[] memory bets = round.bets;\\r\\n        Bet memory creatorBet = round.bets[0];\\r\\n\\r\\n        require(roundId < roundIds, 'not valid round');\\r\\n        require(round.status == RoundStatus.WAITING, \\\"can't cancel\\\");\\r\\n        bool isExpired = (roundTimeInfo.expireTime == 0 && roundTimeInfo.endTime <= block.timestamp) ||\\r\\n            block.timestamp <= roundTimeInfo.expireTime;\\r\\n\\r\\n        uint256 feeAmount = _getFeeAmount(creatorBet.usdValue);\\r\\n        _takeFee(roundId, feeAmount);\\r\\n        if (isExpired) {\\r\\n            round.status = RoundStatus.EXPIRED;\\r\\n        } else {\\r\\n            round.status = RoundStatus.CANCELED;\\r\\n        }\\r\\n\\r\\n        StableCoinAmount[] memory stableCoinAmounts = round.stableCoinAmounts;\\r\\n\\r\\n        uint256 length = bets.length;\\r\\n        uint256 currentTokenIndex = 0;\\r\\n        uint256 v;\\r\\n\\r\\n        // Send Tokens back to the players\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            v = bets[i].usdValue;\\r\\n            if (i == 0) v -= feeAmount;\\r\\n            do {\\r\\n                if (stableCoinAmounts[currentTokenIndex].amount >= v) {\\r\\n                    _transfer(bets[i].player, stableCoinAmounts[currentTokenIndex].tokenAddress, v);\\r\\n                    stableCoinAmounts[currentTokenIndex].amount -= v;\\r\\n                    v = 0;\\r\\n                } else {\\r\\n                    _transfer(\\r\\n                        bets[i].player,\\r\\n                        stableCoinAmounts[currentTokenIndex].tokenAddress,\\r\\n                        stableCoinAmounts[currentTokenIndex].amount\\r\\n                    );\\r\\n                    v -= stableCoinAmounts[currentTokenIndex].amount;\\r\\n                    stableCoinAmounts[currentTokenIndex].amount = 0;\\r\\n                    currentTokenIndex++;\\r\\n                }\\r\\n            } while (v > 0);\\r\\n        }\\r\\n\\r\\n        emit RoundCanceled(roundId, feeAmount, bets[0].usdValue - feeAmount);\\r\\n    }\\r\\n\\r\\n    function finishRound(uint256 roundId) external {\\r\\n        Round storage round = rounds[roundId];\\r\\n        RoundTimeInfo storage roundTimeInfo = roundTimeInfos[roundId];\\r\\n\\r\\n        require(round.status == RoundStatus.STARTED, 'cannot finish');\\r\\n        require(roundTimeInfo.endTime < block.timestamp, 'not yet finished');\\r\\n        uint256 currentPrice = getPriceOracle(round.priceTokenId);\\r\\n        uint256 feeAmount = _getFeeAmount(round.currentTotalUSD);\\r\\n        _takeFee(roundId, feeAmount);\\r\\n\\r\\n        StableCoinAmount[] memory stableCoinAmounts = round.stableCoinAmounts;\\r\\n\\r\\n        round.status = RoundStatus.FINISHED;\\r\\n        round.recordedPrice = currentPrice;\\r\\n\\r\\n        // Creator is winner\\r\\n        if (\\r\\n            (round.operator == 0 && currentPrice >= round.pricePoint) ||\\r\\n            ((round.operator == 1 && currentPrice <= round.pricePoint))\\r\\n        ) {\\r\\n            round.isCreatorWinner = true;\\r\\n            uint256 length = stableCoinAmounts.length;\\r\\n            for (uint256 i = 0; i < length; i++) {\\r\\n                _transfer(round.creator, stableCoinAmounts[i].tokenAddress, stableCoinAmounts[i].amount);\\r\\n            }\\r\\n            emit PlayerWon(roundId, 0, round.creator, (feeAmount * 100) / fee - feeAmount);\\r\\n        } else {\\r\\n            // Creator is loser\\r\\n            round.isCreatorWinner = false;\\r\\n            Bet[] memory bets = round.bets;\\r\\n            uint256 length = bets.length;\\r\\n            uint256 total = round.currentTotalUSD - feeAmount; // Total value\\r\\n            uint256 takerTotal = round.currentTotalUSD - bets[0].usdValue; // Takers' total value\\r\\n            uint256 currentTokenIndex = 0;\\r\\n            uint256 v;\\r\\n\\r\\n            // Distribute Rewards to takers\\r\\n            for (uint256 i = 1; i < length; i++) {\\r\\n                v = (bets[i].usdValue * total) / takerTotal;\\r\\n                emit PlayerWon(roundId, i, bets[i].player, v);\\r\\n                do {\\r\\n                    if (stableCoinAmounts[currentTokenIndex].amount >= v) {\\r\\n                        _transfer(bets[i].player, stableCoinAmounts[currentTokenIndex].tokenAddress, v);\\r\\n                        stableCoinAmounts[currentTokenIndex].amount -= v;\\r\\n                        v = 0;\\r\\n                    } else {\\r\\n                        _transfer(\\r\\n                            bets[i].player,\\r\\n                            stableCoinAmounts[currentTokenIndex].tokenAddress,\\r\\n                            stableCoinAmounts[currentTokenIndex].amount\\r\\n                        );\\r\\n                        v -= stableCoinAmounts[currentTokenIndex].amount;\\r\\n                        stableCoinAmounts[currentTokenIndex].amount = 0;\\r\\n                        currentTokenIndex++;\\r\\n                    }\\r\\n                } while (v > 0);\\r\\n            }\\r\\n        }\\r\\n        emit RoundFinished(roundId, currentPrice, round.isCreatorWinner, feeAmount);\\r\\n    }\\r\\n\\r\\n    function _swapBetTokenToStableCoin(uint256 roundId, Bet calldata bet) internal {\\r\\n        address tokenAddress = betTokens[bet.betTokenId].tokenAddress;\\r\\n        if (isStable[tokenAddress]) {\\r\\n            IPRC20(tokenAddress).transferFrom(msg.sender, address(this), bet.usdValue);\\r\\n            _addStableCoinAmountInfo(roundId, tokenAddress, bet.usdValue);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        address[] memory path = _getSwapPath(tokenAddress, usdtAddr);\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        uint256[] memory amounts = router.getAmountsIn(bet.usdValue, path);\\r\\n        uint256 requiredAmount = amounts[0];\\r\\n        bool isBNB = tokenAddress == address(0);\\r\\n\\r\\n        require(!isBNB || requiredAmount <= msg.value, 'insufficient bnb');\\r\\n        require(\\r\\n            isBNB || requiredAmount <= IPRC20(tokenAddress).allowance(msg.sender, address(this)),\\r\\n            'not enough allowance'\\r\\n        );\\r\\n\\r\\n        if (isBNB) {\\r\\n            if (requiredAmount < msg.value) {\\r\\n                _transfer(msg.sender, tokenAddress, msg.value - requiredAmount);\\r\\n            }\\r\\n            router.swapExactETHForTokens{ value: requiredAmount }(bet.usdValue, path, address(this), block.timestamp);\\r\\n        } else {\\r\\n            IPRC20(tokenAddress).transferFrom(msg.sender, address(this), requiredAmount);\\r\\n            IPRC20(tokenAddress).approve(pancakeRouterAddr, requiredAmount);\\r\\n            router.swapExactTokensForTokens(requiredAmount, bet.usdValue, path, address(this), block.timestamp);\\r\\n        }\\r\\n        _addStableCoinAmountInfo(roundId, usdtAddr, bet.usdValue);\\r\\n    }\\r\\n\\r\\n    function _addBet(uint256 roundId, Bet calldata bet) internal {\\r\\n        Round storage round = rounds[roundId];\\r\\n        uint256 newBetId = round.bets.length;\\r\\n        round.bets.push(Bet(newBetId, bet.betTokenId, bet.player, bet.usdValue));\\r\\n        emit BetPlaced(roundId, newBetId, bet.player, bet.usdValue);\\r\\n    }\\r\\n\\r\\n    function _getSwapPath(address from, address to) internal view returns (address[] memory path) {\\r\\n        if (from == address(0)) {\\r\\n            path = new address[](2);\\r\\n            path[0] = wbnbAddr;\\r\\n            path[1] = to;\\r\\n        } else {\\r\\n            path = new address[](3);\\r\\n            path[0] = from;\\r\\n            path[1] = wbnbAddr;\\r\\n            path[2] = to;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getFeeAmount(uint256 amount) internal view returns (uint256) {\\r\\n        if (isBotEnabled) return (amount * (fee + botFee)) / 1000;\\r\\n        return (amount * fee) / 1000;\\r\\n    }\\r\\n\\r\\n    function _addStableCoinAmountInfo(uint256 roundId, address stableCoinAddress, uint256 amount) internal {\\r\\n        Round storage round = rounds[roundId];\\r\\n        uint256 length = round.stableCoinAmounts.length;\\r\\n        round.currentTotalUSD += amount;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (round.stableCoinAmounts[i].tokenAddress == stableCoinAddress) {\\r\\n                round.stableCoinAmounts[i].amount += amount;\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        round.stableCoinAmounts.push(StableCoinAmount(stableCoinAddress, amount));\\r\\n    }\\r\\n\\r\\n    function getPriceOracle(uint256 priceTokenId) public view returns (uint256) {\\r\\n        PriceToken storage priceTokenInfo = priceTokens[priceTokenId];\\r\\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceTokenInfo.priceFeed);\\r\\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\\r\\n        return uint256(answer) * 10 ** (18 - priceTokenInfo.digit);\\r\\n    }\\r\\n\\r\\n    function _transfer(address receiver, address tokenAddress, uint256 amount) internal {\\r\\n        if (tokenAddress != address(0)) {\\r\\n            IPRC20(tokenAddress).transfer(receiver, amount);\\r\\n        } else {\\r\\n            payable(receiver).transfer(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTokenUSDPrice(address tokenAddress) public view returns (uint256) {\\r\\n        if (isStable[tokenAddress]) return 10 ** 18;\\r\\n        if (tokenAddress == address(0)) return _getBNBPrice();\\r\\n\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        IPRC20 token = IPRC20(tokenAddress);\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = wbnbAddr;\\r\\n        path[2] = usdtAddr;\\r\\n        uint256 usdValue = router.getAmountsOut(10 ** token.decimals(), path)[2];\\r\\n\\r\\n        return usdValue;\\r\\n    }\\r\\n\\r\\n    function _takeFee(uint256 roundId, uint256 amount) internal {\\r\\n        if (amount == 0) return;\\r\\n        Round storage round = rounds[roundId];\\r\\n        uint256 length = round.stableCoinAmounts.length;\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (round.stableCoinAmounts[i].amount >= amount) {\\r\\n                _swapAccumulatedFees(round.stableCoinAmounts[i].tokenAddress, amount);\\r\\n                round.stableCoinAmounts[i].amount -= amount;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current BNB price in comparison with BNB and BUSD\\r\\n     */\\r\\n    function _getBNBPrice() internal view returns (uint256 price) {\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = wbnbAddr;\\r\\n        path[1] = usdtAddr;\\r\\n        uint256[] memory amounts = router.getAmountsOut(10 ** 18, path);\\r\\n        return amounts[1];\\r\\n    }\\r\\n\\r\\n    function _swapAccumulatedFees(address tokenAddress, uint256 amount) internal {\\r\\n        bool _isBotEnabled = isBotEnabled;\\r\\n\\r\\n        IPancakeRouter02 router = IPancakeRouter02(pancakeRouterAddr);\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = router.WETH();\\r\\n        IPRC20(tokenAddress).approve(address(router), amount);\\r\\n\\r\\n        if (_isBotEnabled) {\\r\\n            uint256 botFeeAmount = (amount * botFee) / (botFee + fee);\\r\\n            amount -= botFeeAmount;\\r\\n            if (tokenAddress == usdtAddr) {\\r\\n                IPRC20(usdtAddr).transfer(botAddress, botFeeAmount);\\r\\n            } else {\\r\\n                path[2] = usdtAddr;\\r\\n                router.swapExactTokensForTokens(botFeeAmount, 0, path, botAddress, block.timestamp);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        path[2] = BNBPAddr;\\r\\n        uint256[] memory amounts = router.swapExactTokensForTokens(amount, 0, path, address(this), block.timestamp);\\r\\n        uint256 balance = amounts[2];\\r\\n        IPRC20(BNBPAddr).approve(potContractAddr, balance);\\r\\n        IPotLottery(potContractAddr).addAdminTokenValue(balance);\\r\\n    }\\r\\n\\r\\n    function getPriceTokens() external view returns (PriceToken[] memory list) {\\r\\n        return priceTokens;\\r\\n    }\\r\\n\\r\\n    function getBetTokens()\\r\\n        external\\r\\n        view\\r\\n        returns (BetToken[] memory list, uint256[] memory prices, uint8[] memory decimals)\\r\\n    {\\r\\n        uint256 length = betTokens.length;\\r\\n        prices = new uint256[](length);\\r\\n        decimals = new uint8[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            address tokenAddress = betTokens[i].tokenAddress;\\r\\n            prices[i] = getTokenUSDPrice(tokenAddress);\\r\\n            if (tokenAddress != address(0)) decimals[i] = IPRC20(betTokens[i].tokenAddress).decimals();\\r\\n            else decimals[i] = 18;\\r\\n        }\\r\\n        list = betTokens;\\r\\n    }\\r\\n\\r\\n    function getRounds(\\r\\n        uint256 start,\\r\\n        uint256 length\\r\\n    ) external view returns (Round[] memory list, RoundOption[] memory options, RoundTimeInfo[] memory timeInfos) {\\r\\n        if (start >= rounds.length) return (list, options, timeInfos);\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = start + length;\\r\\n\\r\\n        if (end > rounds.length) end = rounds.length;\\r\\n        list = new Round[](end - start);\\r\\n        options = new RoundOption[](end - start);\\r\\n        timeInfos = new RoundTimeInfo[](end - start);\\r\\n\\r\\n        for (i = start; i < end; i++) {\\r\\n            list[i - start] = rounds[i];\\r\\n            options[i - start] = roundOptions[i];\\r\\n            timeInfos[i - start] = roundTimeInfos[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRound(\\r\\n        uint256 roundId\\r\\n    ) external view returns (Round memory round, RoundOption memory option, RoundTimeInfo memory timeInfo) {\\r\\n        return (rounds[roundId], roundOptions[roundId], roundTimeInfos[roundId]);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TYRH/Plant/TreeClaim.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\r\\nimport '../../interfaces/IPlantation.sol';\\r\\n\\r\\ncontract TreeClaim is OwnableUpgradeable {\\r\\n    IERC20 public tyrh;\\r\\n    IPlantation public plantation;\\r\\n    bool public claimStarted;\\r\\n    uint256 public totalClaimAmount;\\r\\n    uint256 public remainingClaimAmount;\\r\\n    uint256 public lastTreeCount;\\r\\n    uint256 public lastTotalWeight;\\r\\n    uint256 public claimRoundId;\\r\\n    address[] public exploiters;\\r\\n    mapping(address => bool) isExploiter;\\r\\n    mapping(address => mapping(uint256 => bool)) public userClaimed;\\r\\n\\r\\n    event StartedClaim(uint256 amount);\\r\\n    event StopppedClaim();\\r\\n    event UserClaimed(address user, uint256 amount);\\r\\n\\r\\n    function initialize(address tokenAddress, address plantationAddress) external initializer {\\r\\n        tyrh = IERC20(tokenAddress);\\r\\n        plantation = IPlantation(plantationAddress);\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function startClaim(uint256 amount, uint256 exploitersTreeWeight) external onlyOwner {\\r\\n        require(claimStarted == false, 'claim already started');\\r\\n        require(tyrh.balanceOf(address(this)) >= amount, 'insufficient balance');\\r\\n        totalClaimAmount = amount;\\r\\n        remainingClaimAmount = amount;\\r\\n        lastTreeCount = plantation.treeCount();\\r\\n        lastTotalWeight = plantation.totalTreeWeight() - exploitersTreeWeight;\\r\\n        claimStarted = true;\\r\\n        emit StartedClaim(amount);\\r\\n    }\\r\\n\\r\\n    function claim() external {\\r\\n        require(claimStarted, 'claim not started');\\r\\n        require(userClaimed[msg.sender][claimRoundId] == false, 'Already claimed');\\r\\n        require(!isExploiter[msg.sender], 'exploiter');\\r\\n\\r\\n        IPlantation.Tree[] memory trees = plantation.getUserTreesWithoutNFTs(msg.sender);\\r\\n        uint256 weight;\\r\\n        uint i;\\r\\n        for (i = 0; i < trees.length; i++) {\\r\\n            if (trees[i].id < lastTreeCount) {\\r\\n                if (trees[i].grownUp) {\\r\\n                    weight += trees[i].weight;\\r\\n                }\\r\\n            } else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        uint256 claimAmount = (totalClaimAmount * weight) / lastTotalWeight;\\r\\n        remainingClaimAmount -= claimAmount;\\r\\n        tyrh.transfer(msg.sender, claimAmount);\\r\\n        userClaimed[msg.sender][claimRoundId] = true;\\r\\n        emit UserClaimed(msg.sender, claimAmount);\\r\\n    }\\r\\n\\r\\n    function stopClaim() external onlyOwner {\\r\\n        claimStarted = false;\\r\\n        claimRoundId++;\\r\\n        emit StopppedClaim();\\r\\n    }\\r\\n\\r\\n    function setPlantationAddress(address addr) external onlyOwner {\\r\\n        plantation = IPlantation(addr);\\r\\n    }\\r\\n\\r\\n    function setTYRHAddress(address addr) external onlyOwner {\\r\\n        tyrh = IERC20(addr);\\r\\n    }\\r\\n\\r\\n    function setExploiters(address[] memory _exploiters) external onlyOwner {\\r\\n        uint256 length = _exploiters.length;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            if (!isExploiter[_exploiters[i]]) {\\r\\n                exploiters.push(_exploiters[i]);\\r\\n                isExploiter[_exploiters[i]] = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function whitelistUser(address user) external onlyOwner {\\r\\n        isExploiter[user] = false;\\r\\n    }\\r\\n\\r\\n    function isUserClaimed(address user) external view returns (bool) {\\r\\n        return userClaimed[user][claimRoundId];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPlantation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\n\\r\\ninterface IPlantation {\\r\\n    function userTrees(address) external view returns (uint256[] memory);\\r\\n\\r\\n    function trees(uint256) external view returns (Tree memory);\\r\\n\\r\\n    function totalTreeWeight() external view returns (uint256);\\r\\n\\r\\n    function treeCount() external view returns (uint256);\\r\\n\\r\\n    struct Tree {\\r\\n        uint256 id;\\r\\n        uint256 typeId;\\r\\n        address owner;\\r\\n        uint256 weight;\\r\\n        uint256 stepStartTimestamp;\\r\\n        uint256 stepEndTimestamp;\\r\\n        uint256 currentStep;\\r\\n        uint256 growthTime;\\r\\n        uint256 waterAmount;\\r\\n        uint256 plantAmount;\\r\\n        bool grownUp;\\r\\n    }\\r\\n\\r\\n    struct TreeWithNFTIds {\\r\\n        uint256 id;\\r\\n        uint256 typeId;\\r\\n        address owner;\\r\\n        uint256 weight;\\r\\n        uint256 stepStartTimestamp;\\r\\n        uint256 stepEndTimestamp;\\r\\n        uint256 currentStep;\\r\\n        uint256 growthTime;\\r\\n        uint256 waterAmount;\\r\\n        uint256 plantAmount;\\r\\n        uint256[] nftIds;\\r\\n        bool grownUp;\\r\\n    }\\r\\n\\r\\n    event TreeGrownUp(uint256 treeId, address owner, uint256 weight);\\r\\n\\r\\n    function deployTree(uint256 typeId, uint256[] memory nftIds) external;\\r\\n\\r\\n    function waterTree(uint256 treeId) external;\\r\\n\\r\\n    function getUserTrees(address user) external view returns (TreeWithNFTIds[] memory);\\r\\n\\r\\n    function getUserTreesWithoutNFTs(address user) external view returns (Tree[] memory list);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"u\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorReturnedAmount\",\"type\":\"uint256\"}],\"name\":\"RoundCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUSDPerPlayer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minUSDPerPlayer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorUSDValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundMaximumValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onlyOneTaker\",\"type\":\"bool\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recordedPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isCreatorWinner\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"RoundFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundMaximumValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorUSDValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BNBPAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"addBetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"digit\",\"type\":\"uint256\"}],\"name\":\"addPriceToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betTokens\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"cancelRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundMaximumValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"onlyOneTaker\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"startEarlyEnabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.Bet\",\"name\":\"initialBet\",\"type\":\"tuple\"}],\"name\":\"createRound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"finishRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBetTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"}],\"internalType\":\"struct PriceCallTestPhase.BetToken[]\",\"name\":\"list\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"decimals\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceTokenId\",\"type\":\"uint256\"}],\"name\":\"getPriceOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"digit\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.PriceToken[]\",\"name\":\"list\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTotalUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundMaximumValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recordedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCreatorWinner\",\"type\":\"bool\"},{\"internalType\":\"enum PriceCallTestPhase.RoundStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.Bet[]\",\"name\":\"bets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.StableCoinAmount[]\",\"name\":\"stableCoinAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PriceCallTestPhase.Round\",\"name\":\"round\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"onlyOneTaker\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"startEarlyEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct PriceCallTestPhase.RoundOption\",\"name\":\"option\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"createdTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.RoundTimeInfo\",\"name\":\"timeInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getRounds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTotalUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundMaximumValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recordedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCreatorWinner\",\"type\":\"bool\"},{\"internalType\":\"enum PriceCallTestPhase.RoundStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.Bet[]\",\"name\":\"bets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.StableCoinAmount[]\",\"name\":\"stableCoinAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PriceCallTestPhase.Round[]\",\"name\":\"list\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"onlyOneTaker\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"startEarlyEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct PriceCallTestPhase.RoundOption[]\",\"name\":\"options\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"createdTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.RoundTimeInfo[]\",\"name\":\"timeInfos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BNBPAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_potContractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_routerAddr\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"digit\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.PriceToken[]\",\"name\":\"_priceTokens\",\"type\":\"tuple[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBotEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceCallTestPhase.Bet\",\"name\":\"bet\",\"type\":\"tuple\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potContractAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceTokens\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"digit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundOptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"onlyOneTaker\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"startEarlyEnabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundTimeInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createdTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minUSDPerPlayer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTotalUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundMaximumValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recordedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCreatorWinner\",\"type\":\"bool\"},{\"internalType\":\"enum PriceCallTestPhase.RoundStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setBNBPAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setBotAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setBotEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBotFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPotContractAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"startEarly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLastCreatedRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PriceCallTestPhase", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "5", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}