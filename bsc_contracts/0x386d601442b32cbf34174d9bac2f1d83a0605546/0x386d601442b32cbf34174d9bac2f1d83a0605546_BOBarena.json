{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"BOBchain/BOBchain/BOBchain/BOBchain/BOBarena.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\nimport \\\"./BOBHelper.sol\\\"; \\nimport \\\"./Marketplace.sol\\\";\\n\\ncontract BOBarena {\\n\\n    struct Chest {\\n        uint256 BaseEther;\\n        uint256 revealBlock;\\n    }\\n\\n    struct Items {\\n        uint256 itemType; //.1 Merge .2 SMerge //3. GCrystal\\n        uint256 mkt;\\n        bool exist;\\n        bool isBusy;  //marketiplace sellings\\n        address owner;\\n    }\\n\\n\\n    struct Hero {\\n        uint256 level;\\n        uint256 yield;\\n        uint256 baseEther;\\n        uint256 mkt;\\n        uint256 revealBlock;\\n        bool isBusy;\\n        bool isEvolving;\\n        bool isSafe;\\n        address owner;\\n    }\\n\\n\\n    struct Quest {\\n        uint256 heroId;\\n        uint256 startTime;\\n        uint256 checkPoint;\\n        uint256 revealBlock;\\n        bool isActive;\\n    }\\n\\n    struct User {\\n        uint256 level;\\n        uint256 totDep;\\n        uint256 totEarned;\\n        uint256[] chestIDs;\\n        uint256[] itemIDs;\\n        uint256[] heroIDs;\\n        uint256 shards;\\n\\n        mapping(uint256 => Chest) chests; // User's chests indexed by chestId\\n        mapping(uint256 => Items) items;   // User's items indexed by itemId\\n        mapping(uint256 => Hero) heroes;  // User's heroes indexed by heroId\\n\\n    }\\n\\n    mapping(address => Quest) public userQuests;\\n    mapping(address => User) public users;\\n\\n\\n    BOBHelper public Helper;\\n    Marketplace public market;\\n\\n    uint256 public TOTAL_YIELD = 0;\\n\\n    uint256 public nextheroID = 1;\\n\\n    //itemID should never be 0 for green crystals to never cause issues\\n    uint256 public nextItemId = 1;\\n\\n    uint256 public capRandom = 785;\\n\\n    address public owner; \\n    address public mkt; \\n    uint256 public totDep;\\n\\n    uint256 internal startDate = 1703260800; \\n    uint256 internal fundslock = 250 days;\\n\\n    bool public isPromoDay = false; \\n    uint256 public promoPerc = 0;\\n\\n    constructor(address _owner, address _mkt){\\n        Helper = new BOBHelper( capRandom, address(this));\\n        market = new Marketplace(address(this),_owner);\\n        owner = _owner;\\n        mkt = _mkt;\\n    }\\n\\n     modifier hasStarted() {\\n            require(block.timestamp > startDate, \\\"Not started yet\\\");\\n            _;\\n        }\\n\\n    event ChestPurchased(address indexed user, uint256 chestId, uint256 revealBlock);\\n    event ChestOpened(address indexed user, uint256 chestId, uint256 level, uint256 randomNumber);\\n    event HeroUpgraded(address indexed user, bool success, uint256 heroId, uint256 newLevel, uint256 newYield);\\n    event QuestFinished(address indexed user, uint256[] itemType, uint256 towithdraw);\\n\\n    //CHESTS\\n    function buyChest(uint256 number, address user, address promocode) external payable hasStarted{\\n        require(users[msg.sender].chestIDs.length == 0, \\\"Open your chests firsts\\\");    \\n\\n        //@dev user is used instead of msg.sender so users can gift chests\\n        require(number <= 10 && number > 0, \\\"Max 10\\\");\\n        require(msg.value / number >= 0.1 ether && msg.value / number <= 2 ether, \\\"Min 0.1 max 2 BNB\\\"); //0.05 one chest cost\\n        require(users[user].chestIDs.length + number <= 20, \\\"You can own up to 20 chests only\\\");    \\n\\n        uint256 totprice = msg.value;\\n        if (isPromoDay && promocode != msg.sender && users[promocode].totDep >= 1 ether){\\n                totprice = totprice - (promoPerc * totprice / 100);\\n                payable(promocode).transfer(totprice * 3 / 100 );\\n                payable(msg.sender).transfer((promoPerc - 3) * totprice / 100);\\n        } \\n\\n        if (users[user].level == 0){\\n            users[user].level = 1;\\n        }\\n\\n            addChest(user,number,msg.value / number);\\n            payable(owner).transfer(totprice * 7 / 100 );\\n            payable(mkt).transfer(totprice / 100 );\\n            users[user].totDep += totprice;\\n            totDep += totprice;\\n        }\\n            \\n    function addChest(address user, uint256 number, uint256 basePrice ) internal{\\n        for (uint256 i = 0; i < number; i++) {\\n\\n            Chest memory newChest = Chest({\\n                BaseEther: basePrice,\\n                revealBlock: block.number + 1\\n            });\\n\\n            users[user].chests[nextheroID] = newChest;\\n            users[msg.sender].chestIDs.push(nextheroID); \\n            nextheroID += 1;   \\n\\n            emit ChestPurchased(msg.sender, nextheroID, newChest.revealBlock);\\n        }\\n    }\\n\\n   function openChest(uint256 number) external {\\n        uint256 lastchest = users[msg.sender].chestIDs[number - 1];\\n        require(block.number >= users[msg.sender].chests[lastchest].revealBlock, \\\"Too early\\\");\\n        require(users[msg.sender].heroIDs.length + number <= 20, \\\"You can own up to 20 heroes only\\\");    \\n\\n        require(number > 0 && number <= 10 , \\\"Too many chests selected would lead to gas failure\\\");\\n\\n        for (uint256 i = 0; i < number; i++) {\\n            uint256 firstChestID = users[msg.sender].chestIDs[0];\\n            Chest storage chest = users[msg.sender].chests[firstChestID];\\n\\n            require(block.number > chest.revealBlock, \\\"Wait for the reveal block!\\\");\\n            uint256 randomNumber;\\n            randomNumber = uint256(keccak256(abi.encodePacked(blockhash(chest.revealBlock), msg.sender, firstChestID, i))) % (capRandom + 1);\\n\\n            uint256 level = generateHero(randomNumber , firstChestID , chest.BaseEther);\\n\\n            uint256 lastChestIndex = users[msg.sender].chestIDs.length - 1;\\n           \\n            users[msg.sender].chestIDs[0] = users[msg.sender].chestIDs[lastChestIndex];\\n            users[msg.sender].chestIDs.pop();\\n            delete users[msg.sender].chests[firstChestID];\\n            emit ChestOpened(msg.sender, firstChestID, level , randomNumber);\\n        }\\n    }\\n\\n        //HEROES\\n        function initiateHeroUpgrade(uint256 heroId) external payable hasStarted{\\n            checkHeroElegible(msg.sender,heroId);\\n            Hero storage hero = users[msg.sender].heroes[heroId];\\n\\n            if (hero.isSafe){\\n                require (msg.value == users[msg.sender].heroes[heroId].yield / 8,\\\"Not the right amount\\\");\\n            } else {\\n                require (msg.value == users[msg.sender].heroes[heroId].yield / 4,\\\"Not the right amount\\\");\\n            }\\n            \\n            hero.isEvolving = true;\\n            hero.revealBlock = block.number + 1;\\n        }\\n\\n\\n        function executeHeroUpgrade(uint256 heroId) external {\\n            Hero storage hero = users[msg.sender].heroes[heroId];\\n            require(hero.isEvolving, \\\"Hero is not in the upgrade process.\\\");\\n            require(hero.owner == msg.sender, \\\"You do not own this hero.\\\");\\n\\n            hero.isEvolving = false;\\n\\n            require(block.number > hero.revealBlock && hero.revealBlock != 0, \\\"Invalid Block!\\\");\\n            uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(hero.revealBlock), msg.sender, heroId))) % (capRandom + 1);\\n\\n            //uint256 randomNumber = uint256(keccak256(abi.encodePacked( msg.sender, heroId))) % (capRandom + 1);\\n            uint256 probability = Helper.executeHeroUpgrade(hero.level, randomNumber);\\n            bool success = false;\\n\\n            if (probability != 0){\\n                uint256 yield = Helper.getYield(probability,hero.baseEther);\\n                TOTAL_YIELD += (yield - hero.yield);\\n                hero.level += 1;\\n                hero.yield = yield;\\n                success = true;\\n            } else if (!hero.isSafe){\\n                TOTAL_YIELD -= hero.yield;\\n                users[msg.sender].shards += 1;\\n                removeHeroId(heroId, msg.sender);\\n                delete users[msg.sender].heroes[heroId];  \\n            } else {\\n                hero.isSafe = false;                \\n            }\\n            emit HeroUpgraded(msg.sender, success , heroId, hero.level, hero.yield);\\n        }\\n\\n\\n    function generateHero(uint256 number, uint256 firstChestID, uint256 baseEther) internal returns(uint256){\\n            (uint256 level, uint256 yield) = Helper.generateHero(number, baseEther);\\n\\n            Hero memory newHero = Hero({\\n                level: level,\\n                yield: yield,\\n                baseEther: baseEther,\\n                mkt: 0,\\n                revealBlock : 0,\\n                isBusy: false,\\n                isEvolving: false,\\n                isSafe: false,\\n                owner: msg.sender\\n            });\\n        TOTAL_YIELD += yield;\\n        users[msg.sender].heroes[firstChestID] = newHero;\\n        users[msg.sender].heroIDs.push(firstChestID); \\n\\n        return level;\\n    }\\n\\n    //QUESTS\\n    function startQuest(uint256 heroId) external hasStarted{\\n        Quest storage quest = userQuests[msg.sender];\\n        require(!quest.isActive, \\\"You already have an active quest.\\\");\\n        //require check yield\\n        checkHeroElegible(msg.sender,heroId);\\n\\n        //@dev the lev system prevents users to withdraw too early in case of a big hero drop\\n        if (users[msg.sender].heroes[heroId].level >= 7 ){\\n            require(users[msg.sender].level == 4,\\\"You level is too low to use this hero\\\");\\n        } else if (users[msg.sender].heroes[heroId].level == 6 ){\\n            require(users[msg.sender].level >= 3,\\\"You level is too low to use this hero\\\");\\n        } else if (users[msg.sender].heroes[heroId].level == 5 ){\\n            require(users[msg.sender].level >= 2,\\\"You level is too low to use this hero\\\");\\n        }\\n        users[msg.sender].heroes[heroId].isBusy = true;\\n        userQuests[msg.sender] = Quest(heroId, block.timestamp,block.timestamp,block.number + 1, true);\\n    }\\n\\n    function stopQuest() external {\\n        Quest storage quest = userQuests[msg.sender];\\n\\n        require(quest.isActive, \\\"You do not have any active quest\\\");\\n        require(block.timestamp <= quest.startTime + 5 days, \\\"Quest has finished.\\\"); \\n\\n        users[msg.sender].heroes[quest.heroId].isBusy = false;\\n        userQuests[msg.sender] = Quest(0, 0, 0, 0, false); \\n    }\\n\\n\\n    function finishQuest() external returns (uint256){\\n        Quest memory quest = userQuests[msg.sender];\\n        require(quest.isActive, \\\"You have no active quest.\\\");\\n        require(block.timestamp >= quest.startTime + 5 days, \\\"Quest is not finished yet.\\\"); \\n\\n        Hero memory hero = users[msg.sender].heroes[quest.heroId];\\n        uint256 towithdraw = hero.yield;\\n\\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(quest.revealBlock), msg.sender, quest.heroId))) % (101);\\n        uint256[] memory itemTypes = Helper.drawItem(hero.level, randomNumber , quest.revealBlock);\\n\\n        userQuests[msg.sender] = Quest(0, 0, 0, 0, false); \\n\\n        if (users[msg.sender].level < 4){\\n            users[msg.sender].level += 1;\\n        }\\n        removeHeroId(quest.heroId, msg.sender);\\n        delete users[msg.sender].heroes[quest.heroId];   \\n\\n        //@dev create a shard\\n        users[msg.sender].shards += 1;\\n\\n        uint256 contractBalance = address(this).balance;\\n        bool isNerf;\\n        contractBalance <= towithdraw ? isNerf = true : isNerf = false;\\n\\n        //@dev Safe dynamic to prevent an early runout of tvl\\n        if (isNerf){\\n            if (contractBalance <= towithdraw / 2){\\n                towithdraw = contractBalance /2;\\n            } else {\\n                towithdraw = towithdraw / 2;\\n                }\\n            }\\n\\n        payable(msg.sender).transfer(towithdraw);\\n\\n        if (itemTypes.length != 0){\\n            createItems(itemTypes);\\n            }\\n        users[msg.sender].totEarned += towithdraw;\\n        TOTAL_YIELD -= towithdraw;\\n        emit QuestFinished(msg.sender, itemTypes ,towithdraw);\\n        return quest.heroId;\\n    }\\n\\n\\n    \\n    //ITEMS\\n    //@dev 0 will return into a non super chest being created, other numbers will instead create a new item\\n    function createItems(uint256[] memory itemType) internal {\\n        for (uint256 i = 0; i < itemType.length; i++) {\\n            if (itemType[i] == 0){\\n                Chest memory newChest = Chest({\\n                    BaseEther: 0.2 ether,\\n                    revealBlock: block.number + 1\\n                });\\n                users[msg.sender].chests[nextheroID] = newChest;  \\n                users[msg.sender].chestIDs.push(nextheroID); \\n                nextheroID += 1;\\n            } else {\\n                nextItemId++;\\n                users[msg.sender].items[nextItemId] = Items(itemType[i], 0,true, false, msg.sender);\\n                users[msg.sender].itemIDs.push(nextItemId); \\n                }\\n            }\\n        }\\n\\n    function useMerge( uint256 mergeID) external {\\n            require(users[msg.sender].shards >= 2, \\\"Not enough shards\\\");\\n            require(users[msg.sender].items[mergeID].owner == msg.sender, \\\"You do not own this item\\\");\\n            require(users[msg.sender].items[mergeID].itemType == 1, \\\"You do not own this item\\\");\\n            require(users[msg.sender].items[mergeID].isBusy == false, \\\"item is busy\\\");\\n\\n            users[msg.sender].shards -= 2;\\n                    Chest memory newChest = Chest({\\n                                BaseEther: 0.2 ether,\\n                                revealBlock: block.number + 1\\n                            });\\n            users[msg.sender].chests[nextheroID] = newChest;  \\n            users[msg.sender].chestIDs.push(nextheroID); \\n            nextheroID += 1;\\n            removeItemId(mergeID , msg.sender);\\n            delete users[msg.sender].items[mergeID];\\n        }\\n\\n    function useSuperMerge( uint256 mergeID) external {\\n            require(users[msg.sender].shards >= 3, \\\"Not enough shards\\\");\\n            require(users[msg.sender].items[mergeID].owner == msg.sender, \\\"You do not own this item\\\");\\n            require(users[msg.sender].items[mergeID].itemType == 2, \\\"You do not own this item\\\");\\n            require(users[msg.sender].items[mergeID].isBusy == false, \\\"item is busy\\\");\\n\\n            users[msg.sender].shards -= 3;\\n                    Chest memory newChest = Chest({\\n                                BaseEther: 0.4 ether,\\n                                revealBlock: block.number + 1\\n                            });\\n            users[msg.sender].chests[nextheroID] = newChest;  \\n            users[msg.sender].chestIDs.push(nextheroID); \\n            nextheroID += 1;\\n            removeItemId(mergeID , msg.sender);\\n            delete users[msg.sender].items[mergeID];\\n        }\\n    \\n    function useGcrystal(uint256 greencrystalID, uint256 heroId) external {\\n            Hero storage hero = users[msg.sender].heroes[heroId];\\n            checkHeroElegible(msg.sender,heroId);\\n            require(greencrystalID > 0 , \\\"cannot be ID 0\\\");\\n            require(users[msg.sender].items[greencrystalID].owner == msg.sender, \\\"You do not own this item\\\");\\n            require(users[msg.sender].items[greencrystalID].itemType == 3, \\\"Wrong Type\\\");\\n            require(users[msg.sender].items[greencrystalID].isBusy == false, \\\"item is busy\\\");\\n\\n            hero.isSafe = true;\\n            removeItemId(greencrystalID , msg.sender);\\n            delete users[msg.sender].items[greencrystalID];\\n        }\\n\\n\\n\\n    //TRIMMERS\\n    function removeHeroId(uint256 _id, address user) internal {\\n        uint256[] storage heroArray = users[user].heroIDs;\\n        for (uint256 i = 0; i < heroArray.length; i++) {\\n            if (heroArray[i] == _id) {\\n                heroArray[i] = heroArray[heroArray.length - 1];\\n                heroArray.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function removeItemId(uint256 _id, address user) internal {\\n        uint256[] storage itemArray = users[user].itemIDs;\\n        for (uint256 i = 0; i < itemArray.length; i++) {\\n            if (itemArray[i] == _id) {\\n                itemArray[i] = itemArray[itemArray.length - 1];\\n                itemArray.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function checkHeroElegible(address user, uint256 ID) internal view{\\n        Hero storage hero = users[user].heroes[ID];\\n        require(hero.owner == msg.sender, \\\"You are not the owner.\\\"); \\n        require(!hero.isBusy, \\\"Hero is already busy.\\\"); \\n        require(hero.mkt == 0, \\\"This hero has been used already\\\"); \\n        require(!hero.isEvolving, \\\"Hero is evolving.\\\");\\n    }\\n\\n    //MARKETPLACE\\n    function listHero(uint256 _id, uint256 price) external hasStarted {\\n        checkHeroElegible(msg.sender,_id);\\n        users[msg.sender].heroes[_id].isBusy = true;\\n        uint256 mktID = market.listHero( _id, price, msg.sender);\\n        users[msg.sender].heroes[_id].mkt = mktID;\\n    }\\n\\n    function listItem(uint256 _id, uint256 price) external {\\n        require(users[msg.sender].items[_id].isBusy == false, \\\"You cannot sell this item\\\");\\n        require(users[msg.sender].items[_id].mkt == 0, \\\"Already Selling\\\");\\n        require(users[msg.sender].items[_id].owner == msg.sender, \\\"You do not own this\\\");\\n        uint256 mktID = market.listItem( _id, price, msg.sender);\\n        users[msg.sender].items[_id].mkt = mktID;\\n        users[msg.sender].items[_id].isBusy = true;\\n    }\\n\\n    function buyHero(uint256 _mktid) external payable {\\n        (address oldowner,uint256 id) = market.buyHero{value: msg.value}(_mktid);\\n        uint256 mktID = users[oldowner].heroes[id].mkt;\\n        require(mktID != 0, \\\"item is not for sale\\\");\\n        require(users[msg.sender].level > 0,\\\"You level is too low to use the marketplace\\\");\\n\\n        users[msg.sender].heroes[id] = users[oldowner].heroes[id];\\n        users[msg.sender].heroes[id].isBusy = false;\\n        users[msg.sender].heroes[id].owner = msg.sender;\\n        users[msg.sender].heroes[id].mkt = 0;\\n\\n        users[msg.sender].heroIDs.push(id);\\n        removeHeroId(id, oldowner);\\n        delete users[oldowner].heroes[id];\\n    }\\n\\n\\n    function buyItem(uint256 _mktid) external payable {\\n        (address oldowner,uint256 id) = market.buyItem{value: msg.value}(_mktid);\\n        require(users[oldowner].items[id].mkt != 0,\\\"item is not for sale\\\");\\n        require(users[oldowner].items[id].owner == oldowner,\\\"item does not exist\\\");\\n        require(users[msg.sender].level > 0,\\\"You level is too low to use the marketplace\\\");\\n\\n        users[msg.sender].items[id] = users[oldowner].items[id];\\n        users[msg.sender].items[id].isBusy = false;\\n        users[msg.sender].items[id].owner = msg.sender;\\n        users[msg.sender].items[id].mkt = 0;\\n\\n        users[msg.sender].itemIDs.push(id);\\n        removeItemId(id, oldowner);\\n        delete users[oldowner].items[id];  \\n\\n    }\\n\\n    function delistHero(uint256 _mktid) external {\\n        uint256 ID = market.removeHeroListing(_mktid, msg.sender);\\n        require(users[msg.sender].heroes[ID].owner == msg.sender,\\\"you are not the owner\\\");\\n        require(users[msg.sender].heroes[ID].mkt != 0,\\\"not listed\\\");\\n\\n        users[msg.sender].heroes[ID].mkt = 0;\\n        users[msg.sender].heroes[ID].isBusy = false;\\n    }\\n\\n    function delistItem(uint256 _itemmktid) external {\\n        uint256 ID = market.removeItemListing(_itemmktid, msg.sender);\\n        require(users[msg.sender].items[ID].owner == msg.sender,\\\"you are not the owner\\\");\\n        require(users[msg.sender].items[ID].mkt != 0,\\\"not listed\\\");\\n\\n        users[msg.sender].items[ID].mkt = 0;\\n        users[msg.sender].items[ID].isBusy = false;\\n    }\\n\\n    //PROMO CODES\\n    function activatePromo(bool isPromo , uint256 _perc) external {\\n            require(msg.sender == owner, \\\"Only owner\\\");\\n            if (isPromo){\\n                require(_perc > 0 && _perc <= 20, \\\"Wrong value\\\");\\n            }\\n            isPromoDay = isPromo;\\n            promoPerc = _perc;\\n        }\\n\\n    //IMPORTANT: SAFELOCK \\n    //@dev After 9 months fund are unlocked, this might be useful in case of users funds need to be moved, to migrate over a new contract, expand the game or emergency use\\n    function SafeLock() external {\\n            require(msg.sender == owner, \\\"Only owner\\\");\\n            require(block.timestamp > startDate + fundslock);\\n            uint256 contractBalance = address(this).balance;\\n            payable(owner).transfer(contractBalance);\\n        }\\n    \\n    //@dev owner can decide no further development will be needed and renounce\\n    function changeTeam(address _owner, address _mkt) external {\\n            require(msg.sender == owner);\\n            owner = _owner;\\n            mkt = _mkt;\\n        }\\n\\n    //@dev lock can be extended at any time\\n    function Extend(uint256 newtime) external {\\n            require(newtime > fundslock, \\\"Only more than initial value\\\");\\n            require(msg.sender == owner, \\\"Only owner\\\");\\n            fundslock = newtime;\\n        }\\n        \\n\\n    //UI CALLS\\n\\n    function getPromo() external view returns (bool,uint256) {\\n        return (isPromoDay,promoPerc);\\n    }\\n\\n    function getUpgradeprice(address user, uint256 heroId) external view returns (uint256,uint256) {\\n        return (users[user].heroes[heroId].yield / 4, users[user].heroes[heroId].yield / 8);\\n    }\\n\\n    function getUserInfo(address userAddress) external view returns (uint256,uint256) {\\n        return (users[userAddress].totDep,users[userAddress].totEarned);\\n    }\\n\\n     function getUserChestsIDs(address userAddress) external view returns (uint256[] memory) {\\n        return (users[userAddress].chestIDs);\\n    }\\n\\n    function getUserHeroIDs(address userAddress) external view returns (uint256[] memory) {\\n        return (users[userAddress].heroIDs);\\n    }\\n\\n    function getUserItemIDs(address userAddress) external view returns (uint256[] memory) {\\n        return users[userAddress].itemIDs;\\n    }\\n\\n    function getUserChestbyID( address user, uint256 id) public view returns (Chest memory) {\\n            return users[user].chests[id];    \\n    }\\n\\n    function getUserItemByID(address user, uint256 id) public view returns (Items memory) {\\n        return users[user].items[id];\\n    }\\n\\n\\n    function getUserHeroByID(address user, uint256 id) public view returns (Hero memory) {\\n        return users[user].heroes[id];\\n    }\\n\\n\\n\\n    receive() external payable { }\\n\\n}\"\r\n    },\r\n    \"BOBchain/BOBchain/BOBchain/BOBchain/Marketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ncontract Marketplace {\\n\\n    struct Mkt {\\n        uint256 mktid;\\n        uint256 id;\\n        uint256 price; \\n        uint256 date; \\n        address owner;\\n    }\\n\\n    struct MktItem {\\n        uint256 mktid;\\n        uint256 id;\\n        uint256 price; \\n        uint256 date; \\n        address owner;\\n    }\\n\\n    struct itemperUser {\\n        uint256[] allIDs;\\n    }\\n\\n    struct heroperUser {\\n        uint256[] allIDs;\\n    }\\n\\n    mapping(address => itemperUser) internal numItems;\\n    mapping(address => heroperUser) internal numHeroes;\\n\\n    mapping(uint256 => Mkt) public marketId;\\n    mapping(uint256 => MktItem) public itemId;\\n\\n    address public mainBOB;\\n    address public owner;\\n\\n\\n    //IDs 0 are reserved for not selling heroes in BOBchain contract\\n    uint256 public heroes_IDs = 1;\\n    uint256 public items_IDs = 1;\\n    uint256 public totVolume;\\n    uint256 public itemsSold;\\n\\n\\n    constructor(address _mainBOB, address _owner) {\\n        mainBOB = _mainBOB;\\n        owner = _owner;\\n    }\\n\\n    modifier onlyContract() {\\n            require(msg.sender == mainBOB, \\\"Caller is not the BOBChain contract\\\");\\n            _;\\n        }\\n\\n    \\n\\n    function listHero(uint256 _id, uint256 price, address user) external onlyContract returns(uint256){\\n        require(numHeroes[user].allIDs.length < 5, \\\"max 4 listings per user\\\");\\n        require(price >= 0.001 ether && price <= 1000 ether, \\\"Enter a valid price\\\");\\n\\n        uint256 currentID = heroes_IDs;\\n        numHeroes[user].allIDs.push(heroes_IDs);\\n        marketId[heroes_IDs] = Mkt(heroes_IDs, _id, price, block.timestamp ,user);\\n        heroes_IDs++;\\n        return currentID;\\n    }\\n\\n    function listItem(uint256 _id, uint256 price, address user) external onlyContract returns(uint256){\\n        require(numItems[user].allIDs.length < 5, \\\"max 4 listings per user\\\");\\n        require(price >= 0.001 ether && price <= 1000 ether, \\\"Enter a valid price\\\");\\n        uint256 currentID = items_IDs;\\n        numItems[user].allIDs.push(items_IDs);\\n        itemId[items_IDs] = MktItem(items_IDs, _id, price, block.timestamp ,user);\\n        items_IDs++;\\n        return currentID;\\n    }\\n\\n\\n    function buyHero(uint256 mkt_id) external payable onlyContract returns(address,uint256){\\n        Mkt storage mkt = marketId[mkt_id];\\n\\n        require(msg.value == mkt.price,\\\"send the right amount\\\");\\n        require(mkt.id != 0,\\\"Item was possibly sold\\\");\\n\\n        totVolume += msg.value;\\n        itemsSold += 1;\\n        uint256 idretrieved = mkt.id;\\n        address oldowner = mkt.owner;\\n\\n        payTaxes(msg.value , oldowner);\\n        delete marketId[mkt_id];\\n        removeIdFromUserArray(mkt_id, numHeroes[oldowner].allIDs);\\n\\n        return (oldowner,idretrieved);\\n    }\\n\\n     function buyItem(uint256 mkt_id) external payable onlyContract returns(address,uint256){\\n        MktItem storage mktI = itemId[mkt_id];\\n        require(msg.value == mktI.price);\\n        require(mktI.id != 0,\\\"Item was possibly sold\\\");\\n        \\n        totVolume += msg.value;\\n        itemsSold += 1;\\n        uint256 idretrieved = mktI.id;\\n\\n        address oldowner = mktI.owner;\\n\\n        payTaxes(msg.value , oldowner);\\n        delete itemId[mkt_id];\\n        removeIdFromUserArray(mkt_id, numItems[oldowner].allIDs);\\n\\n        return (oldowner,idretrieved);\\n    }\\n\\n    function payTaxes(uint256 _amount , address _oldowner) internal{\\n        \\n        uint256 tax = _amount* 8 / 100;\\n        payable(_oldowner).transfer(_amount - tax);\\n        //50% tax to owner and 50% back to the contract\\n        payable(owner).transfer(_amount* 3 / 100); \\n        payable(mainBOB).transfer(_amount* 5 / 100); \\n        \\n    }\\n\\n    function removeHeroListing(uint256 heroId, address user) external onlyContract returns(uint256){\\n        require(marketId[heroId].owner == user, \\\"Caller is not the owner\\\");\\n        require(numHeroes[user].allIDs.length > 0);\\n        uint256 IDdeleted = marketId[heroId].id;\\n\\n        // Delete the hero from the marketId mapping\\n        delete marketId[heroId];\\n\\n        // Remove the hero ID from the user's array\\n        removeIdFromUserArray(heroId, numHeroes[user].allIDs);\\n        return IDdeleted;\\n    }\\n\\n    function removeItemListing(uint256 itemID, address user) external onlyContract returns(uint256){\\n        require(itemId[itemID].owner == user, \\\"Caller is not the owner\\\");\\n        require(numItems[user].allIDs.length > 0, \\\"No items to remove\\\");\\n        uint256 IDdeleted = itemId[itemID].id;\\n        // Delete the item from the itemId mapping\\n        delete itemId[itemID];\\n\\n        // Remove the item ID from the user's array\\n        removeIdFromUserArray(itemID, numItems[user].allIDs);\\n        return IDdeleted;\\n    }\\n\\n\\n    function removeIdFromUserArray(uint256 id, uint256[] storage userArray) internal {\\n        uint256 length = userArray.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (userArray[i] == id) {\\n                userArray[i] = userArray[length - 1];\\n                userArray.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function getItemsInRange(uint256 start, uint256 end) external view returns (MktItem[] memory) {\\n        require(start <= end, \\\"Invalid range\\\");\\n        require(end < items_IDs, \\\"Range exceeds total items\\\");\\n\\n        uint256 rangeSize = end - start + 1;\\n        MktItem[] memory items = new MktItem[](rangeSize);\\n\\n        for (uint256 i = 0; i < rangeSize; i++) {\\n            uint256 currentId = start + i;\\n            items[i] = itemId[currentId];\\n        }\\n\\n        return items;\\n    }\\n\\n    function getHeroesInRange(uint256 start, uint256 end) external view returns (Mkt[] memory) {\\n        require(start <= end, \\\"Invalid range\\\");\\n        require(end < heroes_IDs, \\\"Range exceeds total heroes\\\");\\n\\n        uint256 rangeSize = end - start + 1;\\n        Mkt[] memory heroes = new Mkt[](rangeSize);\\n\\n        for (uint256 i = 0; i < rangeSize; i++) {\\n            uint256 currentId = start + i;\\n            heroes[i] = marketId[currentId];\\n        }\\n\\n        return heroes;\\n    }\\n\\n\\n    function getnumHeroes() external view returns (uint256) {\\n        return heroes_IDs - 1;\\n    }\\n\\n    function getmkt() external view returns (uint256,uint256) {\\n        return (totVolume,itemsSold);\\n    }\\n\\n    function getnumItems() external view returns (uint256) {\\n        return items_IDs - 1;\\n    }\\n\\n    function viewAllHeroIdsOfUser(address user) external view returns (uint256[] memory) {\\n        return numHeroes[user].allIDs;\\n    }\\n\\n    function viewAllitemIdsOfUser(address user) external view returns (uint256[] memory) {\\n        return numItems[user].allIDs;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n}\"\r\n    },\r\n    \"BOBchain/BOBchain/BOBchain/BOBchain/BOBHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract BOBHelper {\\n\\n    uint256 public capRandom;\\n    address public mainBOB;\\n\\n    constructor( uint256 _capRandom, address _mainBOB) {\\n        capRandom = _capRandom;\\n        mainBOB = _mainBOB;\\n    }\\n\\n    modifier onlyContract() {\\n            require(msg.sender == mainBOB, \\\"Caller is not the BOBChain contract\\\");\\n            _;\\n        }\\n\\n    function getYield(uint256 probability,uint256 baseYield) public view returns (uint256) {\\n        \\n        require(probability > 0, \\\"Probability cannot be zero\\\");\\n        return (baseYield * capRandom) / probability / 3;\\n    }\\n\\n    function generateHero(uint256 number, uint256 baseYield) public view returns(uint256,uint256){\\n        uint256 level;\\n        uint256 probability;\\n        uint256 yield;\\n\\n        if (number <= 390) {\\n            level = 1;\\n            probability = 750;\\n        } else if (number <= 550) { \\n            level = 2;\\n            probability = 240;\\n        } else if (number <= 680) {  \\n            level = 3;\\n            probability = 140;\\n        } else if (number <= 720) {\\n            level = 4;\\n            probability = 90;\\n        } else if (number <= 770) {\\n            level = 5;\\n            probability = 60;\\n        } else if (number <= 785) {\\n            level = 6;\\n            probability = 40;\\n        } \\n\\n        yield = getYield(probability,baseYield);\\n\\n        return (level,yield);\\n    }\\n\\n    function executeHeroUpgrade(uint256 level , uint256 randomNumber) public pure returns(uint256) {\\n            \\n            uint256 probability;\\n\\n             if (randomNumber <= 460 && level == 1) {\\n                probability = 240;\\n            } else if (randomNumber <= 392 && level == 2) {\\n                probability = 140;\\n            } else if (randomNumber <= 380 && level == 3) {\\n                probability = 90;\\n            } else if (randomNumber <= 360 && level == 4) {\\n                probability = 60;\\n            } else if (randomNumber <= 340 && level == 5) {\\n                probability = 40;\\n            } else if (randomNumber <= 250 && level == 6) {\\n                probability = 20;\\n            } else if (randomNumber <= 200 && level == 7) {\\n                probability = 12;\\n            } else {\\n                probability = 0;\\n            } \\n            return probability;\\n        }\\n\\n        \\n        function drawItem(uint256 level, uint256 randomNumber, uint256 Iblock) external view returns (uint256[] memory) {\\n            uint256 itemQuantity = (uint256(keccak256(abi.encodePacked(Iblock, randomNumber, msg.sender))) % (level + 1)); // 0 to level\\n            uint256[] memory itemTypes;\\n            if (itemQuantity > 0) {\\n                //@dev can return an array of n numbers up to the level of the hero, will return empty string in case of no items found\\n                itemTypes = new uint256[](itemQuantity);\\n\\n                for (uint256 i = 0; i < itemQuantity; i++) {\\n                    uint256 itemType = (uint256(keccak256(abi.encodePacked(randomNumber, msg.sender, i))) % 4); // 0 to 3\\n                    itemTypes[i] = itemType;\\n                }\\n            }\\n\\n            return itemTypes;\\n        }\\n\\n\\n\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mkt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"ChestOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"revealBlock\",\"type\":\"uint256\"}],\"name\":\"ChestPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newYield\",\"type\":\"uint256\"}],\"name\":\"HeroUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"itemType\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"towithdraw\",\"type\":\"uint256\"}],\"name\":\"QuestFinished\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newtime\",\"type\":\"uint256\"}],\"name\":\"Extend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Helper\",\"outputs\":[{\"internalType\":\"contract BOBHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SafeLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_YIELD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPromo\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"activatePromo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"promocode\",\"type\":\"address\"}],\"name\":\"buyChest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mktid\",\"type\":\"uint256\"}],\"name\":\"buyHero\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mktid\",\"type\":\"uint256\"}],\"name\":\"buyItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capRandom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mkt\",\"type\":\"address\"}],\"name\":\"changeTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mktid\",\"type\":\"uint256\"}],\"name\":\"delistHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemmktid\",\"type\":\"uint256\"}],\"name\":\"delistItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"executeHeroUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishQuest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPromo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"getUpgradeprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserChestbyID\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"BaseEther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct BOBarena.Chest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserChestsIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserHeroByID\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseEther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mkt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBusy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEvolving\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSafe\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct BOBarena.Hero\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserHeroIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserItemByID\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mkt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isBusy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct BOBarena.Items\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserItemIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"initiateHeroUpgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPromoDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"listHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"listItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"contract Marketplace\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mkt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextItemId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextheroID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"openChest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"promoPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"startQuest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopQuest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totDep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"greencrystalID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"useGcrystal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mergeID\",\"type\":\"uint256\"}],\"name\":\"useMerge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mergeID\",\"type\":\"uint256\"}],\"name\":\"useSuperMerge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userQuests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totDep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BOBarena", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004966e978a6a838a0a3102e23d808fea5242a254f000000000000000000000000404b13350c1ab8b595dc7b6364176e6fab65b724", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}