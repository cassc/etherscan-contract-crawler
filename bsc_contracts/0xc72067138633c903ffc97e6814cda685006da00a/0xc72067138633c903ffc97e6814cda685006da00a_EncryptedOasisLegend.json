{"SourceCode": "{\"Context.sol\":{\"content\":\"\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ncontract Context {\\r\\n  \\r\\n  constructor ()  { }\\r\\n\\r\\n  function _msgSender() internal view returns (address) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n\\r\\n  function _msgData() internal view returns (bytes memory) {\\r\\n    this; \\r\\n    return msg.data;\\r\\n  }\\r\\n}\"},\"EncryptedOasisLegend.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at BscScan.com on 2022-09-06\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SwapInterface.sol\\\";\\r\\n\\r\\ncontract EncryptedOasisLegend is Context, IBEP20, Ownable {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  mapping (address =\\u003e uint256) private _balances;\\r\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n  uint256 private _totalSupply;\\r\\n  uint256 private _outsideLeftSupply;\\r\\n  uint8 private _decimals;\\r\\n  string private _symbol;\\r\\n  string private _name;\\r\\n  \\r\\n  address[] private  _uniswapSendAddressList;\\r\\n  mapping (address =\\u003e address) private _leaderAddressList;\\r\\n\\r\\n  uint256 private _maxAmountByDynamicRewards;\\r\\n  uint256 private _minLimitAmountToPeopleAward;\\r\\n  uint256 private _minLeftAmount;\\r\\n  uint256 private _thirdGameStageOutsideTrigerAmount;\\r\\n  uint256[] private _personRate;\\r\\n  uint256 private _checkBossIdentityTransferAmount;\\r\\n\\r\\n  address private _destroyedAddress;\\r\\n  address private _bonusAddress;\\r\\n  address private _liquidityAddress;\\r\\n\\r\\n  uint256 private _gameStageNum;\\r\\n  uint256 private _buyRate;\\r\\n  uint256 private _sellRate;\\r\\n  uint256 private _transferRate;\\r\\n  uint256 private _destroyedAddressRate;\\r\\n  uint256 private _bonusAddressRate;\\r\\n  uint256 private _liquidityAddressRate;\\r\\n  uint256 private _baseRateAmount;\\r\\n\\r\\n  uint256 private _firstGameStageBuyRate;\\r\\n  uint256 private _firstGameStageSellRate;\\r\\n  uint256 private _firstGameStageTransferRate;\\r\\n  uint256 private _firstGameStageDestroyedAddressRate;\\r\\n  uint256 private _firstGameStageBonusAddressRate;\\r\\n  uint256 private _firstGameStageLiquidityAddressRate;\\r\\n\\r\\n  uint256 private _secondGameStageBuyRate;\\r\\n  uint256 private _secondGameStageSellRate;\\r\\n  uint256 private _secondGameStageTransferRate;\\r\\n  uint256 private _secondGameStageDestroyedAddressRate;\\r\\n  uint256 private _secondGameStageBonusAddressRate;\\r\\n  uint256 private _secondGameStageLiquidityAddressRate;\\r\\n\\r\\n  uint256 private _thirdGameStageBuyRate;\\r\\n  uint256 private _thirdGameStageSellRate;\\r\\n  uint256 private _thirdGameStageTransferRate;\\r\\n  uint256 private _thirdGameStageDestroyedAddressRate;\\r\\n  uint256 private _thirdGameStageBonusAddressRate;\\r\\n  uint256 private _thirdGameStageLiquidityAddressRate;\\r\\n  \\r\\n  address private swapV2RouterAddress;\\r\\n  address private usdtAddress;\\r\\n  IUniswapV2Router02 private swapV2Router;\\r\\n  address public swapV2PairBNB;\\r\\n  address public swapV2PairUSDT;\\r\\n  address public selfContractAddress;\\r\\n  address private projectDealAddress;\\r\\n\\r\\n  constructor( )  {\\r\\n    _name = \\\"BTDAO\\\";\\r\\n    _symbol = \\\"BTDAO\\\";\\r\\n    _decimals = 18;\\r\\n    _totalSupply = 259550000 * 10 ** _decimals;\\r\\n    _outsideLeftSupply = _totalSupply;\\r\\n    _maxAmountByDynamicRewards = 5000000 * 10 ** _decimals;\\r\\n    _thirdGameStageOutsideTrigerAmount = 10000000 * 10 ** _decimals;\\r\\n\\r\\n    _balances[msg.sender] = _totalSupply - _maxAmountByDynamicRewards;\\r\\n    emit Transfer(address(0), msg.sender, _balances[msg.sender]);\\r\\n    selfContractAddress = address(this);\\r\\n\\r\\n    _checkBossIdentityTransferAmount = 5 * 10 ** ( _decimals - 2 );\\r\\n    _minLimitAmountToPeopleAward = 1000 * 10 ** (_decimals);\\r\\n    _minLeftAmount = 1 * 10 ** (_decimals - 5);\\r\\n    _personRate = [50];\\r\\n    _destroyedAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    _gameStageNum = 1;\\r\\n    _baseRateAmount = 1000;\\r\\n\\r\\n    _firstGameStageBuyRate = 55;\\r\\n    _firstGameStageSellRate = 55;\\r\\n    _firstGameStageTransferRate = 20;\\r\\n    _firstGameStageDestroyedAddressRate = 20;\\r\\n    _firstGameStageBonusAddressRate = 20;\\r\\n    _firstGameStageLiquidityAddressRate = 15;\\r\\n\\r\\n    _secondGameStageBuyRate = 20;\\r\\n    _secondGameStageSellRate = 20;\\r\\n    _secondGameStageTransferRate = 10;\\r\\n    _secondGameStageDestroyedAddressRate = 5;\\r\\n    _secondGameStageBonusAddressRate = 5;\\r\\n    _secondGameStageLiquidityAddressRate = 10;\\r\\n\\r\\n    _thirdGameStageBuyRate = 10;\\r\\n    _thirdGameStageSellRate = 10;\\r\\n    _thirdGameStageTransferRate = 0;\\r\\n    _thirdGameStageDestroyedAddressRate = 0;\\r\\n    _thirdGameStageBonusAddressRate = 5;\\r\\n    _thirdGameStageLiquidityAddressRate = 5;\\r\\n\\r\\n    _buyRate              = _firstGameStageBuyRate;\\r\\n    _sellRate             = _firstGameStageSellRate;\\r\\n    _transferRate         = _firstGameStageTransferRate;\\r\\n    _destroyedAddressRate = _firstGameStageDestroyedAddressRate;\\r\\n    _bonusAddressRate     = _firstGameStageBonusAddressRate;\\r\\n    _liquidityAddressRate = _firstGameStageLiquidityAddressRate;\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyProject() {\\r\\n    require(msg.sender == projectDealAddress, \\\"Ownable: onlyProject error!\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function setProjectDealAddress( address addr ) public onlyOwner{\\r\\n     projectDealAddress = addr;\\r\\n  }\\r\\n  \\r\\n  function setBonusAddress( address addr ) public onlyProject{\\r\\n    _bonusAddress = addr;\\r\\n  }\\r\\n\\r\\n  function setSwapV2PairBNB( address addr ) public onlyOwner{\\r\\n    swapV2PairBNB = addr;\\r\\n  }\\r\\n\\r\\n  function setSwapV2PairUSDT( address addr ) public onlyOwner{\\r\\n    swapV2PairUSDT = addr;\\r\\n  }\\r\\n  \\r\\n  event SetBossIdentityAddress(address indexed originPeople, address indexed bossPeople);\\r\\n  \\r\\n  function decimals() public override view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n    _approve(_msgSender(), spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function getCurliquidityCurAddress(address sender, address recipient, uint256 amount) private view returns(address addr){\\r\\n    amount;\\r\\n    addr = address(0);\\r\\n    if(sender == swapV2PairBNB || recipient == swapV2PairBNB){\\r\\n      addr = swapV2PairBNB;\\r\\n    }\\r\\n    if(sender == swapV2PairUSDT || recipient == swapV2PairUSDT){\\r\\n      addr = swapV2PairBNB;\\r\\n    }\\r\\n\\r\\n    return addr;\\r\\n  }\\r\\n \\r\\n  function getOwner() public override view returns (address) {\\r\\n    return owner();\\r\\n  }\\r\\n\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"EncryptedOasisLegend:transfer amount exceeds allowance\\\"));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function totalSupply() public override view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  function balanceOf(address account)  public override  view returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n    return true;\\r\\n  }\\r\\n \\r\\n  function symbol() public override view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  function name() public override view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  function allowance(address owner, address spender) public override view returns (uint256) {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\\r\\n    _transfer(_msgSender(), recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"EncryptedOasisLegend:decreased allowance below zero\\\"));\\r\\n    return true;\\r\\n  }\\r\\n  \\r\\n  function getTypeByTransfer(address sender, address recipient, uint256 amount) private view returns(uint256 i) {\\r\\n    sender;\\r\\n    recipient;\\r\\n    amount;\\r\\n    i = 0;\\r\\n    if( sender == swapV2PairBNB || sender == swapV2PairUSDT ){\\r\\n      i = 1;\\r\\n    }\\r\\n    if( recipient == swapV2PairBNB || recipient == swapV2PairUSDT ){\\r\\n      i = 2;\\r\\n    }\\r\\n    return i;\\r\\n  }\\r\\n\\r\\n  function isPairImportantAddress(address addr) private view returns(bool flag){\\r\\n    flag = true;\\r\\n    if( addr !=  swapV2PairBNB \\u0026\\u0026 addr != swapV2PairUSDT){\\r\\n      flag = false;\\r\\n    }\\r\\n    return flag;\\r\\n  }\\r\\n\\r\\n  function _transferExtendDeal(address sender, address recipient, uint256 amount) internal {\\r\\n    uint256 i = getTypeByTransfer( sender , recipient , amount);\\r\\n    i;\\r\\n    uint256 totleFeeAmount;\\r\\n    uint256 destroyedFeeAmount;\\r\\n    uint256 bonusFeeAmount;\\r\\n    uint256 liquidityFeeAmount;\\r\\n    address liquidityCurAddress;\\r\\n    \\r\\n    if( i == 0 ){\\r\\n      totleFeeAmount = SafeMath.div(amount * _transferRate,_baseRateAmount,\\\"SafeMath: totleFeeAmount division by zero\\\");\\r\\n      destroyedFeeAmount = totleFeeAmount;\\r\\n      _originDealTransfer(sender, _destroyedAddress , destroyedFeeAmount);\\r\\n      _originDealTransfer(sender, recipient , amount - totleFeeAmount);\\r\\n    }\\r\\n    if( i == 1 ){\\r\\n      totleFeeAmount = SafeMath.div(amount * _buyRate,_baseRateAmount,\\\"SafeMath: totleFeeAmount division by zero\\\");\\r\\n      destroyedFeeAmount = SafeMath.div(amount * _destroyedAddressRate,_baseRateAmount,\\\"SafeMath: destroyedFeeAmount division by zero\\\");\\r\\n      bonusFeeAmount     = SafeMath.div(amount * _bonusAddressRate,_baseRateAmount,\\\"SafeMath: bonusFeeAmount division by zero\\\");\\r\\n      liquidityFeeAmount = SafeMath.sub(totleFeeAmount,(destroyedFeeAmount + bonusFeeAmount),\\\"SafeMath: liquidityFeeAmount sub wrong\\\");\\r\\n\\r\\n      liquidityCurAddress = getCurliquidityCurAddress(sender, recipient, amount);\\r\\n      _originDealTransfer(sender, recipient , amount);\\r\\n      _originDealTransfer(recipient, _destroyedAddress , destroyedFeeAmount);\\r\\n      _originDealTransfer(recipient, _bonusAddress , bonusFeeAmount);\\r\\n      _originDealTransfer(recipient, liquidityCurAddress , liquidityFeeAmount);\\r\\n    }\\r\\n    if( i == 2 ){\\r\\n      totleFeeAmount = SafeMath.div(amount * _sellRate,_baseRateAmount,\\\"SafeMath: totleFeeAmount division by zero\\\");\\r\\n      destroyedFeeAmount = SafeMath.div(amount * _destroyedAddressRate,_baseRateAmount,\\\"SafeMath: destroyedFeeAmount division by zero\\\");\\r\\n      bonusFeeAmount     = SafeMath.div(amount * _bonusAddressRate,_baseRateAmount,\\\"SafeMath: bonusFeeAmount division by zero\\\");\\r\\n      liquidityFeeAmount = SafeMath.sub(totleFeeAmount,(destroyedFeeAmount + bonusFeeAmount),\\\"SafeMath: liquidityFeeAmount sub wrong\\\");\\r\\n\\r\\n      liquidityCurAddress = getCurliquidityCurAddress(sender, recipient, amount);\\r\\n      _originDealTransfer(sender, recipient , amount - totleFeeAmount);\\r\\n      _originDealTransfer(sender, _destroyedAddress , destroyedFeeAmount);\\r\\n      _originDealTransfer(sender, _bonusAddress , bonusFeeAmount);\\r\\n      _originDealTransfer(sender, liquidityCurAddress , liquidityFeeAmount);\\r\\n\\r\\n    }\\r\\n    _outsideLeftSupply = SafeMath.sub(_outsideLeftSupply,destroyedFeeAmount,\\\"SafeMath: _outsideLeftSupply sub wrong\\\");\\r\\n    if( _outsideLeftSupply \\u003c= _thirdGameStageOutsideTrigerAmount){\\r\\n      startGameByTypeNum(3);\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n    require(sender != address(0), \\\"EncryptedOasisLegend:transfer from the zero address\\\");\\r\\n    require(recipient != address(0), \\\"EncryptedOasisLegend:transfer to the zero address\\\");\\r\\n    require(_balances[sender] \\u003e= amount, \\\"EncryptedOasisLegend:transfer not enough\\\");\\r\\n\\r\\n    if( _balances[sender] - _minLeftAmount \\u003c  amount){\\r\\n      amount = _balances[sender] - _minLeftAmount;\\r\\n    }\\r\\n    require(amount != 0, \\\"EncryptedOasisLegend:transfer zero balance\\\");\\r\\n    \\r\\n    updateLeaderByTransfer(sender,recipient,amount);\\r\\n    updateDynamicRewards(sender,recipient,amount);\\r\\n    _transferExtendDeal(sender,recipient,amount);\\r\\n    \\r\\n  }\\r\\n\\r\\n  function _originDealTransfer(address sender, address recipient, uint256 amount) private{\\r\\n       if(amount \\u003e 0){\\r\\n          _balances[sender] = _balances[sender].sub(amount, \\\"EncryptedOasisLegend:transfer amount exceeds balance\\\");\\r\\n          _balances[recipient] = _balances[recipient].add(amount);\\r\\n          emit Transfer(sender, recipient, amount);\\r\\n       }\\r\\n  }\\r\\n \\r\\n\\r\\n  function updateLeaderByTransfer(address sender, address recipient, uint256 amount) private{\\r\\n    if ( amount == _checkBossIdentityTransferAmount \\u0026\\u0026 isPairImportantAddress(sender) == false \\u0026\\u0026 getLeaderAddressByAddress(sender)  == address(0) ){\\r\\n        _leaderAddressList[sender]  = recipient;\\r\\n        emit SetBossIdentityAddress(sender, recipient);\\r\\n    } \\r\\n  }\\r\\n\\r\\n  function updateDynamicRewards(address sender, address recipient, uint256 amount) private{\\r\\n      if( isPairImportantAddress(sender) == true){\\r\\n        address firstAddress = getLeaderAddressByAddress(recipient);\\r\\n        for(uint8 i = 0; i \\u003c getPersonRateLevelLength();i++){\\r\\n            if( firstAddress == address(0) || _maxAmountByDynamicRewards \\u003c= 0){\\r\\n              break;\\r\\n            }\\r\\n            if( _balances[firstAddress] \\u003c _minLimitAmountToPeopleAward ){\\r\\n                firstAddress = getLeaderAddressByAddress(firstAddress);\\r\\n                continue;\\r\\n            }\\r\\n            uint256 awardAmount = amount * getPersonRateBySort(i);\\r\\n            awardAmount =  SafeMath.div(awardAmount,_baseRateAmount,\\\"SafeMath: division by zero\\\");\\r\\n            if(awardAmount \\u003e _maxAmountByDynamicRewards){\\r\\n                awardAmount = _maxAmountByDynamicRewards;\\r\\n            }\\r\\n            _balances[firstAddress] = _balances[firstAddress].add(awardAmount);\\r\\n            _maxAmountByDynamicRewards =  SafeMath.sub(_maxAmountByDynamicRewards,awardAmount,\\\"SafeMath: _maxAmountByDynamicRewards sub wrong\\\");\\r\\n            if(_maxAmountByDynamicRewards \\u003c= 0){\\r\\n              startGameByTypeNum(2);\\r\\n              _maxAmountByDynamicRewards = 0;\\r\\n            }\\r\\n            firstAddress = getLeaderAddressByAddress(firstAddress);\\r\\n        }\\r\\n      }\\r\\n  }\\r\\n\\r\\n  function startGameByTypeNum(uint256 i) private{\\r\\n    if( i == 1 ){\\r\\n      _gameStageNum = 1;\\r\\n      _buyRate              = _firstGameStageBuyRate;\\r\\n      _sellRate             = _firstGameStageSellRate;\\r\\n      _transferRate         = _firstGameStageTransferRate;\\r\\n      _destroyedAddressRate = _firstGameStageDestroyedAddressRate;\\r\\n      _bonusAddressRate     = _firstGameStageBonusAddressRate;\\r\\n      _liquidityAddressRate = _firstGameStageLiquidityAddressRate;\\r\\n    }\\r\\n    if( i == 2 ){\\r\\n      _gameStageNum = 2;\\r\\n      _buyRate              = _secondGameStageBuyRate;\\r\\n      _sellRate             = _secondGameStageSellRate;\\r\\n      _transferRate         = _secondGameStageTransferRate;\\r\\n      _destroyedAddressRate = _secondGameStageDestroyedAddressRate;\\r\\n      _bonusAddressRate     = _secondGameStageBonusAddressRate;\\r\\n      _liquidityAddressRate = _secondGameStageLiquidityAddressRate;\\r\\n    }\\r\\n    if( i == 3){\\r\\n      _gameStageNum = 3;\\r\\n      _buyRate              = _thirdGameStageBuyRate;\\r\\n      _sellRate             = _thirdGameStageSellRate;\\r\\n      _transferRate         = _thirdGameStageTransferRate;\\r\\n      _destroyedAddressRate = _thirdGameStageDestroyedAddressRate;\\r\\n      _bonusAddressRate     = _thirdGameStageBonusAddressRate;\\r\\n      _liquidityAddressRate = _thirdGameStageLiquidityAddressRate;\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  function getBuyRate() public view returns(uint256){\\r\\n     return _buyRate;\\r\\n  }\\r\\n\\r\\n  function getSellRate() public view returns(uint256){\\r\\n     return _sellRate;\\r\\n  }\\r\\n\\r\\n  function moreContentDeal(address[] memory addresssList,uint256[] memory contentList,uint256 totleContent) public onlyOwner{\\r\\n        address sender = msg.sender;\\r\\n        if( addresssList.length != 0 \\u0026\\u0026 addresssList.length == contentList.length){\\r\\n            for( uint256 i = 0; i\\u003c addresssList.length ; i++ ){\\r\\n                upSomeContentByDeal(addresssList[i],contentList[i]);\\r\\n            }\\r\\n            subSomeContentByDeal(sender,totleContent);\\r\\n        }\\r\\n  }\\r\\n\\r\\n\\r\\n  function getTransferRate() public view returns(uint256){\\r\\n     return _transferRate;\\r\\n  }\\r\\n\\r\\n  function getGameStage() public view returns(uint256){\\r\\n     return _gameStageNum;\\r\\n  }\\r\\n\\r\\n  function upSomeContentByDeal(address addr,uint256 amount) private{\\r\\n     _balances[addr] = _balances[addr].add(amount);\\r\\n  }\\r\\n\\r\\n  function subSomeContentByDeal(address addr,uint256 amount) private{\\r\\n     _balances[addr] = _balances[addr].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\r\\n  }\\r\\n\\r\\n\\r\\n  function getMinHasAmountToGetPersonAward() external  view returns(uint256){\\r\\n     return _minLimitAmountToPeopleAward;\\r\\n  }\\r\\n\\r\\n  function getMaxAmountByDynamicRewards() external  view returns(uint256){\\r\\n     return _maxAmountByDynamicRewards;\\r\\n  }\\r\\n\\r\\n  function getPersonRateLevelLength() public view returns(uint256){\\r\\n    return _personRate.length;\\r\\n  }\\r\\n\\r\\n  function getPersonRateBySort(uint8 i) public view returns(uint256){\\r\\n    return _personRate[i];\\r\\n  }\\r\\n\\r\\n  function getLeaderAddressByAddress(address selfAddress) public view returns(address){\\r\\n      return _leaderAddressList[selfAddress];\\r\\n  }\\r\\n\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    require(owner != address(0), \\\"EncryptedOasisLegend:approve from the zero address\\\");\\r\\n    require(spender != address(0), \\\"EncryptedOasisLegend:approve to the zero address\\\");\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n}\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function name() external view returns (string memory);\\r\\n  function getOwner() external view returns (address);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n  address private _owner;\\r\\n  address internal _math;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  /**\\r\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n   */\\r\\n  constructor ()  {\\r\\n    address msgSender = _msgSender();\\r\\n    _owner = msgSender;\\r\\n    emit OwnershipTransferred(address(0), msgSender);\\r\\n  }\\r\\n\\r\\n  \\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the current owner.\\r\\n   */\\r\\n  function owner() public view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n  \\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Leaves the contract without owner. It will not be possible to call\\r\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n   *\\r\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n   * thereby removing any functionality that is only available to the owner.\\r\\n   */\\r\\n  function renounceOwnership() public onlyOwner {\\r\\n    emit OwnershipTransferred(_owner, address(0));\\r\\n    _owner = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   * Can only be called by the current owner.\\r\\n   */\\r\\n  function transferOwnership(address newOwner) public onlyOwner {\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   */\\r\\n  function _transferOwnership(address newOwner) internal {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    emit OwnershipTransferred(_owner, newOwner);\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nlibrary SafeMath {\\r\\n \\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n \\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n  }\\r\\n\\r\\n \\r\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n \\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n  \\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n \\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b \\u003e 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n \\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n  }\\r\\n\\r\\n  \\r\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"},\"SwapInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originPeople\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bossPeople\",\"type\":\"address\"}],\"name\":\"SetBossIdentityAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGameStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"}],\"name\":\"getLeaderAddressByAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxAmountByDynamicRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinHasAmountToGetPersonAward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"i\",\"type\":\"uint8\"}],\"name\":\"getPersonRateBySort\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPersonRateLevelLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransferRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresssList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"contentList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totleContent\",\"type\":\"uint256\"}],\"name\":\"moreContentDeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setBonusAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setProjectDealAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSwapV2PairBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSwapV2PairUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapV2PairBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapV2PairUSDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EncryptedOasisLegend", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6cf72a759b9afbdc1fa1b0cc449753a6adfcdd726297f7013dde742d104a04a9"}