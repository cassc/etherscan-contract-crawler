{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RVL/RewardDistributor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IToken {\\n    function getOwner() external view returns (address);\\n}\\n\\ninterface IMAXI {\\n    function token() external view returns (IERC20);\\n}\\n\\ncontract RewardDistributor is IERC20 {\\n\\n    // Token With Governance\\n    address public immutable ownableToken;\\n\\n    // MAXI Staking Protocol\\n    address public immutable MAXI;\\n\\n    // Internal Token Metrics\\n    string private constant _name = 'RVL Rewards';\\n    string private constant _symbol = 'rBUSD';\\n    uint8 private _decimals;\\n\\n    // Reward Token Structure\\n    struct RewardToken {\\n        bool hasBeenAdded;\\n        address swapper;\\n        uint256 totalRewards;\\n    }\\n    mapping ( address => RewardToken ) public rewardToken;\\n    address[] public allRewardTokens;\\n\\n    // Current Reward Token\\n    address public currentRewardToken;\\n\\n    // User -> Share\\n    struct UserInfo {\\n        // share in MAXI\\n        uint256 balance;\\n        // excluded reward debt\\n        uint256 totalExcluded;\\n        // index in allUsers array\\n        uint256 index;\\n    }\\n    mapping ( address => UserInfo ) public userInfo;\\n    address[] public allUsers;\\n\\n    // Tracking Info\\n    uint256 public totalShares;\\n    uint256 private dividendsPerShare;\\n    uint256 private constant precision = 10**18;\\n\\n    // Ownership\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == IToken(ownableToken).getOwner(),\\n            'Only Token Owner'\\n        );\\n        _;\\n    }\\n    \\n    modifier onlyMAXI() {\\n        require(\\n            msg.sender == MAXI,\\n            'Only MAXI Can Call'\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address MAXI_,\\n        address rewardToken_,\\n        address rewardTokenSwapper_\\n    ) {\\n        require(\\n            MAXI_ != address(0) &&\\n            rewardToken_ != address(0) &&\\n            rewardTokenSwapper_ != address(0),\\n            'Zero Addresses'\\n        );\\n\\n        // immutables\\n        ownableToken = address(IMAXI(MAXI_).token());\\n        MAXI = MAXI_;\\n\\n        // current reward token data\\n        currentRewardToken = rewardToken_;\\n\\n        // global reward token data\\n        rewardToken[rewardToken_].swapper = rewardTokenSwapper_;\\n        rewardToken[rewardToken_].hasBeenAdded = true;\\n        allRewardTokens.push(rewardToken_);\\n\\n        // name + symbol\\n        _decimals = IERC20(rewardToken_).decimals();\\n    }\\n\\n\\n\\n    ////////////////////////////////\\n    /////    TOKEN FUNCTIONS    ////\\n    ////////////////////////////////\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n    function decimals() external view override returns (uint8) {\\n        return _decimals;\\n    }\\n    function totalSupply() external view override returns (uint256) {\\n        return IERC20(currentRewardToken).balanceOf(address(this));\\n    }\\n\\n    /** Shows The Amount Of Users' Pending Rewards */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return pendingRewards(account);\\n    }\\n\\n    function transfer(address recipient, uint256) external override returns (bool) {\\n        require(\\n            userInfo[recipient].balance > 0,\\n            'Zero Balance'\\n        );\\n        _sendReward(recipient);\\n        return true;\\n    }\\n    function transferFrom(address, address recipient, uint256) external override returns (bool) {\\n        require(\\n            userInfo[recipient].balance > 0,\\n            'Zero Balance'\\n        );\\n        _sendReward(recipient);\\n        return true;\\n    }\\n\\n    /** function has no use in contract */\\n    function allowance(address, address) external pure override returns (uint256) { \\n        return 0;\\n    }\\n    /** function has no use in contract */\\n    function approve(address, uint256) public override returns (bool) {\\n        emit Approval(msg.sender, msg.sender, 0);\\n        return true;\\n    }\\n\\n\\n\\n    ////////////////////////////////\\n    /////    OWNER FUNCTIONS    ////\\n    ////////////////////////////////\\n\\n    function setRewardTokenSwapper(address newRewardSwapper) external onlyOwner {\\n        rewardToken[currentRewardToken].swapper = newRewardSwapper;\\n    }\\n\\n    function withdraw(address token, uint256 amount) external onlyOwner {\\n        IERC20(token).transfer(msg.sender, amount);\\n    }\\n\\n    /**\\n        MAKE SURE OWNER MASSCLAIMS() FOR ALL USERS PRIOR TO SETTING NEW REWARD TOKEN\\n    */\\n    function setRewardToken(address newRewardToken, address newRewardSwapper) external onlyOwner {\\n        require(\\n            newRewardToken != address(0) &&\\n            newRewardSwapper != address(0),\\n            'Zero Addresses'\\n        );\\n\\n        // set global reward token stats\\n        rewardToken[newRewardToken].swapper = newRewardSwapper;\\n\\n        // if new reward token\\n        if (rewardToken[newRewardToken].hasBeenAdded == false) {\\n            allRewardTokens.push(newRewardToken);\\n            rewardToken[newRewardToken].hasBeenAdded = true;\\n        }\\n\\n        // update state\\n        currentRewardToken = newRewardToken;\\n\\n        // update token display stats\\n        _decimals = IERC20(newRewardToken).decimals();\\n    }\\n\\n    function setShare(address user, uint256 newShare) external onlyMAXI {\\n        if (userInfo[user].balance > 0) {\\n            _sendReward(user);\\n        }\\n\\n        if (userInfo[user].balance == 0 && newShare > 0) {\\n            // new user\\n            userInfo[user].index = allUsers.length;\\n            allUsers.push(user);\\n        } else if (userInfo[user].balance > 0 && newShare == 0) {\\n            // user is leaving\\n            _removeUser(user);\\n        }\\n\\n        // update total supply and user tracking info\\n        totalShares = totalShares - userInfo[user].balance + newShare;\\n        userInfo[user].balance = newShare;\\n        userInfo[user].totalExcluded = getTotalExcluded(newShare);\\n    }\\n\\n\\n\\n    /////////////////////////////////\\n    /////   PUBLIC FUNCTIONS    /////\\n    /////////////////////////////////\\n\\n    function donateRewards() external payable {\\n        _donateRewards();\\n    }\\n\\n    receive() external payable {\\n        _donateRewards();\\n    }\\n\\n    function donate(uint256 amount) external {\\n        uint256 received = _transferIn(currentRewardToken, amount);\\n        _register(received);\\n    }\\n\\n    function massClaim() external {\\n        _massClaim(0, allUsers.length);\\n    }\\n\\n    function massClaimFromIndexToIndex(uint256 startIndex, uint256 endIndex) external {\\n        _massClaim(startIndex, endIndex);\\n    }\\n\\n    /////////////////////////////////\\n    ////   INTERNAL FUNCTIONS    ////\\n    /////////////////////////////////\\n\\n    function _donateRewards() internal {\\n\\n        // Token Before\\n        uint before = IERC20(currentRewardToken).balanceOf(address(this));\\n\\n        // Use Reward Token Swapper To Purchase Reward Tokens\\n        (bool s,) = payable(rewardToken[currentRewardToken].swapper).call{value: address(this).balance}(\\\"\\\");\\n        require(s, 'Failure On Swapper Purchase');\\n\\n        // Check Amount Received\\n        uint After = IERC20(currentRewardToken).balanceOf(address(this));\\n        require(\\n            After > before,\\n            'Zero Received'\\n        );\\n\\n        // Register Amount Received\\n        uint received = After - before;\\n        _register(received);\\n    }\\n\\n    function _sendReward(address user) internal {\\n        if (userInfo[user].balance == 0) {\\n            return;\\n        }\\n\\n        // track pending\\n        uint pending = pendingRewards(user);\\n\\n        // avoid overflow\\n        if (pending > IERC20(currentRewardToken).balanceOf(address(this))) {\\n            pending = IERC20(currentRewardToken).balanceOf(address(this));\\n        }\\n\\n        // update excluded earnings\\n        userInfo[user].totalExcluded = getTotalExcluded(userInfo[user].balance);\\n        \\n        // send reward to user\\n        if (pending > 0) {\\n            IERC20(currentRewardToken).transfer(user, pending);\\n        }\\n    }\\n\\n    function _register(uint256 amount) internal {\\n\\n        // Increment Total Rewards\\n        rewardToken[currentRewardToken].totalRewards += amount;\\n\\n        if (totalShares > 0) {\\n            // Add Dividends Per Share\\n            dividendsPerShare += ( precision * amount ) / totalShares;\\n        }\\n    }\\n\\n    function _transferIn(address token, uint256 amount) internal returns (uint256) {\\n        uint before = IERC20(token).balanceOf(address(this));\\n        require(\\n            IERC20(token).transferFrom(msg.sender, address(this), amount),\\n            'Failure On TransferFrom'\\n        );\\n        uint After = IERC20(token).balanceOf(address(this));\\n        require(\\n            After > before,\\n            'Error On Transfer In'\\n        );\\n        return After - before;\\n    }\\n\\n    function _removeUser(address user) internal {\\n\\n        // index to replace\\n        uint256 replaceIndex = userInfo[user].index;\\n        if (allUsers[replaceIndex] != user) {\\n            return;\\n        }\\n\\n        // last user in array\\n        address lastUser = allUsers[allUsers.length - 1];\\n\\n        // set last user's index to the replace index\\n        userInfo[lastUser].index = replaceIndex;\\n\\n        // set replace index in array to last user\\n        allUsers[replaceIndex] = lastUser;\\n\\n        // pop last user off the end of the array\\n        allUsers.pop();\\n        delete userInfo[user].index;\\n    }\\n\\n    function _massClaim(uint256 startIndex, uint256 endIndex) internal {\\n        require(\\n            endIndex <= allUsers.length,\\n            'End Length Too Large'\\n        );\\n\\n        for (uint i = startIndex; i < endIndex;) {\\n            _sendReward(allUsers[i]);\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    ////////////////////////////////\\n    /////    READ FUNCTIONS    /////\\n    ////////////////////////////////\\n\\n    function pendingRewards(address user) public view returns (uint256) {\\n        if(userInfo[user].balance == 0){ return 0; }\\n\\n        uint256 userTotalExcluded = getTotalExcluded(userInfo[user].balance);\\n        uint256 userTrackedExcluded = userInfo[user].totalExcluded;\\n\\n        if(userTotalExcluded <= userTrackedExcluded){ return 0; }\\n\\n        return userTotalExcluded - userTrackedExcluded;\\n    }\\n\\n    function getTotalExcluded(uint256 amount) public view returns (uint256) {\\n        return ( amount * dividendsPerShare ) / precision;\\n    }\\n\\n    function viewAllRewardTokens() external view returns (address[] memory) {\\n        return allRewardTokens;\\n    }\\n\\n    function viewAllUsers() external view returns (address[] memory) {\\n        return allUsers;\\n    }\\n\\n    function holderCount() external view returns (uint256) {\\n        return allUsers.length;\\n    }\\n}\"\r\n    },\r\n    \"contracts/RVL/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n    \\n    function symbol() external view returns(string memory);\\n    \\n    function name() external view returns(string memory);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n    \\n    /**\\n     * @dev Returns the number of decimal places\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"MAXI_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenSwapper_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAXI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allRewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donateRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTotalExcluded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"massClaimFromIndexToIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownableToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasBeenAdded\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newRewardSwapper\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardSwapper\",\"type\":\"address\"}],\"name\":\"setRewardTokenSwapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newShare\",\"type\":\"uint256\"}],\"name\":\"setShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAllRewardTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAllUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RewardDistributor", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000073abbf935bf87e9045e8d8f283a96d4c8e4283c3000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000795d737649b2884531cda7260a1dde0a7437d162", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}