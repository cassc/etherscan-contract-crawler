{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Powerball/PowerballBNBP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\r\\nimport '../interfaces/IPancakeRouter.sol';\\r\\nimport '../interfaces/IPRC20.sol';\\r\\nimport '../interfaces/IBNBP.sol';\\r\\nimport '../interfaces/IPotContract.sol';\\r\\n\\r\\n// File: PotContract.sol\\r\\n\\r\\ncontract PowerBallBNBP is ReentrancyGuard {\\r\\n    enum STATE {\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    struct Entry {\\r\\n        address player;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    address public owner;\\r\\n    address public admin;\\r\\n    address public tokenAddress;\\r\\n    uint8 public tokenDecimal;\\r\\n\\r\\n    STATE public roundStatus;\\r\\n    uint256 public entryIds;\\r\\n    uint256 public roundIds;\\r\\n    uint256 public roundDuration;\\r\\n    uint256 public roundStartTime;\\r\\n    uint256 public roundLiveTime;\\r\\n    uint256 public minEntranceAmount;\\r\\n    uint256 public currentEntryCount;\\r\\n    Entry[] public currentEntries;\\r\\n\\r\\n    uint256 public totalEntryAmount;\\r\\n    uint256 public nonce;\\r\\n    uint256 public calculateIndex;\\r\\n\\r\\n    uint256 public burnFee = 125;\\r\\n    uint256 public stakerFee = 125;\\r\\n\\r\\n    address constant BNBPAddr = 0x4D9927a8Dc4432B93445dA94E4084D292438931F; // mainnet: 0x4D9927a8Dc4432B93445dA94E4084D292438931F, testnet: 0xcAf4f8C9f1e511B3FEb3226Dc3534E4c4b2f3D70\\r\\n    address public potContractAddr;\\r\\n\\r\\n    constructor(address _potContractAddr) {\\r\\n        owner = msg.sender;\\r\\n        admin = msg.sender;\\r\\n        tokenAddress = BNBPAddr;\\r\\n        tokenDecimal = IPRC20(tokenAddress).decimals();\\r\\n        roundStatus = STATE.WAITING;\\r\\n        roundDuration = 5; // 5 secs\\r\\n        roundIds = 1;\\r\\n\\r\\n        minEntranceAmount = 1 * 10 ** tokenDecimal; // 2 BNBP\\r\\n        potContractAddr = _potContractAddr;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin || msg.sender == owner, '!admin');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, '!owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validBNBP() {\\r\\n        require(BNBPAddr != address(0), '!BNBP Addr');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier excludeContract() {\\r\\n        require(tx.origin == msg.sender, 'Contract');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event EnteredPot(uint256 indexed roundId, uint256 indexed entryId, address indexed player, uint256 amount);\\r\\n    event StartedCalculating(uint256 indexed roundId);\\r\\n    event CalculateWinner(\\r\\n        uint256 indexed roundId,\\r\\n        address indexed winner,\\r\\n        uint256 reward,\\r\\n        uint256 total,\\r\\n        uint256 index,\\r\\n        uint256 burn,\\r\\n        uint256 staker\\r\\n    );\\r\\n\\r\\n    function changeOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    function changeAdmin(address _adminAddress) public onlyOwner {\\r\\n        admin = _adminAddress;\\r\\n    }\\r\\n\\r\\n    function enterPot(uint256 _amount) external excludeContract {\\r\\n        unchecked {\\r\\n            require(_amount >= minEntranceAmount, 'Min');\\r\\n            require(roundLiveTime == 0 || block.timestamp <= roundLiveTime + roundDuration, 'ended');\\r\\n\\r\\n            IBNBP token = IBNBP(tokenAddress);\\r\\n            uint256 beforeBalance = token.balanceOf(address(this));\\r\\n            token.transferFrom(msg.sender, address(this), _amount);\\r\\n            uint256 rAmount = token.balanceOf(address(this)) - beforeBalance;\\r\\n\\r\\n            uint256 count = currentEntryCount;\\r\\n            if (currentEntries.length == count) {\\r\\n                currentEntries.push();\\r\\n            }\\r\\n\\r\\n            Entry storage entry = currentEntries[count];\\r\\n            entry.player = msg.sender;\\r\\n            entry.amount = rAmount;\\r\\n            ++currentEntryCount;\\r\\n            ++entryIds;\\r\\n            totalEntryAmount = totalEntryAmount + rAmount;\\r\\n\\r\\n            if (\\r\\n                currentEntryCount >= 2 && currentEntries[count - 1].player != msg.sender && roundStatus == STATE.STARTED\\r\\n            ) {\\r\\n                roundStatus = STATE.LIVE;\\r\\n                roundLiveTime = block.timestamp;\\r\\n            } else if (currentEntryCount == 1) {\\r\\n                roundStatus = STATE.STARTED;\\r\\n                roundStartTime = block.timestamp;\\r\\n            }\\r\\n\\r\\n            emit EnteredPot(roundIds, entryIds, msg.sender, rAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateWinner() public {\\r\\n        bool isRoundEnded = roundStatus == STATE.LIVE && roundLiveTime + roundDuration < block.timestamp;\\r\\n        require(isRoundEnded || roundStatus == STATE.CALCULATING_WINNER, 'Not ended');\\r\\n\\r\\n        if (isRoundEnded) {\\r\\n            nonce = fullFillRandomness() % totalEntryAmount;\\r\\n            calculateIndex = 0;\\r\\n        }\\r\\n        (address winner, uint256 index) = determineWinner();\\r\\n        if (winner != address(0)) {\\r\\n            IBNBP token = IBNBP(tokenAddress);\\r\\n            uint256 totalFeePercent = burnFee + stakerFee;\\r\\n            uint256 feeAmount = (totalEntryAmount * totalFeePercent) / 1000;\\r\\n            uint256 burnAmount = (feeAmount * burnFee) / totalFeePercent;\\r\\n            uint256 stakerAmount = feeAmount - burnAmount;\\r\\n            uint256 reward = totalEntryAmount - feeAmount;\\r\\n\\r\\n            token.transfer(winner, reward);\\r\\n            token.burn(burnAmount);\\r\\n            IPRC20(BNBPAddr).approve(potContractAddr, stakerAmount);\\r\\n            IPotLottery(potContractAddr).addAdminTokenValue(stakerAmount);\\r\\n\\r\\n            emit CalculateWinner(roundIds, winner, reward, totalEntryAmount, index, burnAmount, stakerAmount);\\r\\n\\r\\n            initializeRound();\\r\\n        } else {\\r\\n            roundStatus = STATE.CALCULATING_WINNER;\\r\\n            emit StartedCalculating(roundIds);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Attempts to select a random winner\\r\\n     */\\r\\n    function determineWinner() internal returns (address winner, uint256 winnerIndex) {\\r\\n        uint256 start = calculateIndex;\\r\\n        uint256 length = currentEntryCount;\\r\\n        uint256 _nonce = nonce;\\r\\n        for (uint256 index = 0; index < 3000 && (start + index) < length; index++) {\\r\\n            uint256 amount = currentEntries[start + index].amount;\\r\\n            if (_nonce <= amount) {\\r\\n                //That means that the winner has been found here\\r\\n                winner = currentEntries[start + index].player;\\r\\n                winnerIndex = start + index;\\r\\n                return (winner, winnerIndex);\\r\\n            }\\r\\n            _nonce -= amount;\\r\\n        }\\r\\n        nonce = _nonce;\\r\\n        calculateIndex = start + 3000;\\r\\n    }\\r\\n\\r\\n    function initializeRound() internal {\\r\\n        delete currentEntryCount;\\r\\n        delete roundLiveTime;\\r\\n        delete roundStartTime;\\r\\n        delete totalEntryAmount;\\r\\n        roundStatus = STATE.WAITING;\\r\\n        ++roundIds;\\r\\n    }\\r\\n\\r\\n    /**   @dev generates a random number\\r\\n     */\\r\\n    function fullFillRandomness() internal view returns (uint256) {\\r\\n        return uint256(uint128(bytes16(keccak256(abi.encodePacked(block.difficulty, block.timestamp)))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns status of current round\\r\\n     */\\r\\n    function getRoundStatus()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _roundIds,\\r\\n            STATE _roundStatus,\\r\\n            uint256 _roundStartTime,\\r\\n            uint256 _roundLiveTime,\\r\\n            uint256 _roundDuration,\\r\\n            uint256 _totalAmount,\\r\\n            uint256 _entryCount,\\r\\n            uint256 _minEntranceAmount,\\r\\n            uint256 _burnFee,\\r\\n            uint256 _stakerFee\\r\\n        )\\r\\n    {\\r\\n        _roundIds = roundIds;\\r\\n        _roundStatus = roundStatus;\\r\\n        _roundLiveTime = roundLiveTime;\\r\\n        _roundStartTime = roundStartTime;\\r\\n        _roundDuration = roundDuration;\\r\\n        _minEntranceAmount = minEntranceAmount;\\r\\n        _totalAmount = totalEntryAmount;\\r\\n        _entryCount = currentEntryCount;\\r\\n        _burnFee = burnFee;\\r\\n        _stakerFee = stakerFee;\\r\\n    }\\r\\n\\r\\n    function setRoundDuration(uint256 value) external onlyAdmin {\\r\\n        roundDuration = value;\\r\\n    }\\r\\n\\r\\n    function setFeePercent(uint256 _burn, uint256 _staker) external onlyAdmin {\\r\\n        burnFee = _burn;\\r\\n        stakerFee = _staker;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address addr) external onlyAdmin {\\r\\n        tokenAddress = addr;\\r\\n    }\\r\\n\\r\\n    function withdrawETH(address receiver, uint256 amount) external onlyAdmin {\\r\\n        bool sent = payable(receiver).send(amount);\\r\\n        require(sent, 'fail');\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address receiver, address _tokenAddr, uint256 amount) external onlyAdmin {\\r\\n        if (_tokenAddr == tokenAddress) {\\r\\n            uint256 balance = IPRC20(_tokenAddr).balanceOf(address(this));\\r\\n            require(balance >= totalEntryAmount + amount, 'f');\\r\\n        }\\r\\n\\r\\n        IPRC20(_tokenAddr).transfer(receiver, amount);\\r\\n    }\\r\\n\\r\\n    function setPotContractAddr(address addr) external onlyAdmin {\\r\\n        potContractAddr = addr;\\r\\n    }\\r\\n\\r\\n    function setMinimumEntranceAmount(uint256 amount) external onlyAdmin {\\r\\n        minEntranceAmount = amount;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPRC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IPRC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPotContract.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2022-04-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n// File: PotContract.sol\\r\\n\\r\\ninterface IPotLottery {\\r\\n    struct Token {\\r\\n        address tokenAddress;\\r\\n        string tokenSymbol;\\r\\n        uint256 tokenDecimal;\\r\\n    }\\r\\n\\r\\n    enum POT_STATE {\\r\\n        PAUSED,\\r\\n        WAITING,\\r\\n        STARTED,\\r\\n        LIVE,\\r\\n        CALCULATING_WINNER\\r\\n    }\\r\\n\\r\\n    event EnteredPot(\\r\\n        string tokenName,\\r\\n        address indexed userAddress,\\r\\n        uint256 indexed potRound,\\r\\n        uint256 usdValue,\\r\\n        uint256 amount,\\r\\n        uint256 indexed enteryCount,\\r\\n        bool hasEntryInCurrentPot\\r\\n    );\\r\\n    event CalculateWinner(\\r\\n        address indexed winner,\\r\\n        uint256 indexed potRound,\\r\\n        uint256 potValue,\\r\\n        uint256 amount,\\r\\n        uint256 amountWon,\\r\\n        uint256 participants\\r\\n    );\\r\\n\\r\\n    event PotStateChange(uint256 indexed potRound, POT_STATE indexed potState, uint256 indexed time);\\r\\n    event TokenSwapFailed(string tokenName);\\r\\n\\r\\n    function getRefund() external;\\r\\n\\r\\n    function airdropPool() external view returns (uint256);\\r\\n\\r\\n    function lotteryPool() external view returns (uint256);\\r\\n\\r\\n    function burnPool() external view returns (uint256);\\r\\n\\r\\n    function airdropInterval() external view returns (uint256);\\r\\n\\r\\n    function burnInterval() external view returns (uint256);\\r\\n\\r\\n    function lotteryInterval() external view returns (uint256);\\r\\n\\r\\n    function fullFillRandomness() external view returns (uint256);\\r\\n\\r\\n    function getBNBPrice() external view returns (uint256 price);\\r\\n\\r\\n    function swapAccumulatedFees() external;\\r\\n\\r\\n    function burnAccumulatedBNBP() external;\\r\\n\\r\\n    function airdropAccumulatedBNBP() external returns (uint256);\\r\\n\\r\\n    function addAdminTokenValue(uint256 value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBNBP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface IBNBP {\\r\\n    error AirdropTimeError();\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(uint256 amount) external;\\r\\n\\r\\n    function isUserAddress(address addr) external view returns (bool);\\r\\n\\r\\n    function calculatePairAddress() external view returns (address);\\r\\n\\r\\n    function performAirdrop() external returns (uint256);\\r\\n\\r\\n    function performBurn() external returns (uint256);\\r\\n\\r\\n    function performLottery() external returns (address);\\r\\n\\r\\n    function setPotContractAddress(address addr) external;\\r\\n\\r\\n    function setAirdropPercentage(uint8 percentage) external;\\r\\n\\r\\n    function setAirdropInterval(uint256 interval) external;\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_potContractAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"staker\",\"type\":\"uint256\"}],\"name\":\"CalculateWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"entryId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EnteredPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"StartedCalculating\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentEntries\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEntryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterPot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoundStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundIds\",\"type\":\"uint256\"},{\"internalType\":\"enum PowerBallBNBP.STATE\",\"name\":\"_roundStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_roundStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roundLiveTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roundDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_entryCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minEntranceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakerFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minEntranceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potContractAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundLiveTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundStatus\",\"outputs\":[{\"internalType\":\"enum PowerBallBNBP.STATE\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_staker\",\"type\":\"uint256\"}],\"name\":\"setFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinimumEntranceAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPotContractAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setRoundDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDecimal\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEntryAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PowerBallBNBP", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "5", "ConstructorArguments": "000000000000000000000000fb0232ecaf4f963af6874daa7d986e56fe0d0cc6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}