{"SourceCode": "{\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\ncontract ERC20Detailed is IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string name, string symbol, uint8 decimals) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = decimals;\\n  }\\n\\n  /**\\n   * @return the name of the token.\\n   */\\n  function name() public view returns(string) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @return the symbol of the token.\\n   */\\n  function symbol() public view returns(string) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @return the number of decimals of the token.\\n   */\\n  function decimals() public view returns(uint8) {\\n    return _decimals;\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"Roster.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nlibrary Roster {\\n    using SafeMath for uint256;\\n\\n    event Set(address,uint);\\n    event Remove(address,uint);\\n    struct roster {\\n        mapping(address=\\u003ebool) data;\\n        mapping(address=\\u003eaddress) next;\\n        uint length;\\n        address firstAddress;\\n    }\\n\\n    //List details\\n    function details(roster storage obj) internal view returns(address[] memory){\\n        address[] memory res = new address[](obj.length);\\n        if (obj.firstAddress == address(0)){\\n            return res;\\n        }\\n        address curraddress = obj.firstAddress;\\n        res[0] = curraddress;\\n        uint index = 1;\\n        while ( obj.next[curraddress] != address(0)){\\n            res[index] = obj.next[curraddress];\\n            curraddress = obj.next[curraddress];\\n            index = index.add(1);\\n        }\\n        return res;\\n    }\\n    //set  Roster\\n    function set(roster storage obj,address _address,uint _extend ) internal {\\n        require(_address != address(0),\\\"Empty address\\\");\\n        require(!obj.data[_address],\\\"Has been set\\\");\\n        obj.data[_address] =true;\\n        obj.length = obj.length.add(1);\\n        if (obj.firstAddress == address(0)){\\n            obj.firstAddress = _address;\\n        }else{\\n            address curraddress = obj.firstAddress;\\n            while ( obj.next[curraddress] != address(0)){\\n                curraddress = obj.next[curraddress];\\n            }\\n            obj.next[curraddress] = _address;\\n        }\\n        emit Set(_address,_extend);\\n    }\\n\\n    //remove Roster\\n    function remove(roster storage obj,address _address,uint _extend) internal{\\n        require(_address != address(0),\\\"Empty address\\\");\\n        require(obj.data[_address],\\\"Is not set\\\");\\n        obj.data[_address] = false;\\n        obj.length = obj.length.sub(1);\\n        if (obj.firstAddress == _address){\\n            obj.firstAddress = obj.next[_address];\\n            obj.next[_address] = address(0);\\n        }else{\\n            address curraddress = obj.firstAddress;\\n            while ( obj.next[curraddress] != _address ){\\n                curraddress = obj.next[curraddress];\\n            }\\n            obj.next[curraddress] = obj.next[_address];\\n            obj.next[_address] = address(0);\\n        }\\n        emit Remove(_address,_extend);\\n    }\\n    \\n    function isexists(roster storage obj,address _address) internal view returns(bool){\\n        return obj.data[_address];\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, reverts on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b,\\\"SafeMath:Calculation error\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003e 0,\\\"SafeMath: B cannot be 0\\\"); // Solidity only automatically asserts when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a,\\\"SafeMath:B cannot be greater than A\\\");\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, reverts on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a,\\\"SafeMath:Calculation error\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\r\\n  * reverts when dividing by zero.\\r\\n  */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0,\\\"SafeMath: B cannot be 0\\\");\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"},\"tk.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n//import \\\"./IERC20.sol\\\";\\r\\nimport \\\"./ERC20Detailed.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Roster.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Standard ERC20 token\\r\\n *\\r\\n * @dev Implementation of the basic standard token.\\r\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\r\\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\r\\n */\\r\\n  contract ERC20 is ERC20Detailed {\\r\\n    using SafeMath for uint256;\\r\\n    using Roster for Roster.roster;\\r\\n\\r\\n    event  SetWhite(address,uint8);\\r\\n    event  RemoveWhite(address,uint8);\\r\\n\\r\\n    event  SetAllotAddress(address,uint8);\\r\\n\\r\\n    event OwnershipTransferred(address, address);\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    address _owner;\\r\\n   \\r\\n    //Release of the pool\\r\\n    address public addressRelease;\\r\\n    \\r\\n    address public addressFixed;\\r\\n    //LP Pool\\r\\n    address public addressLp;\\r\\n    //white list (from)\\r\\n    Roster.roster public whiteListFrom;\\r\\n      //white list (to)\\r\\n    Roster.roster public whiteListTo;\\r\\n\\r\\n    uint constant digit = 1E18;\\r\\n    constructor (string name, string symbol, uint256 total ) public ERC20Detailed(name, symbol,18)  {\\r\\n        _owner = msg.sender;\\r\\n        _totalSupply =total.mul(digit);\\r\\n        _balances[msg.sender] = _totalSupply;\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setReleaseAddress(address _address) external onlyOwner{\\r\\n        require(_address != address(0),\\\"The address is empty\\\");\\r\\n        addressRelease = _address;\\r\\n        emit SetAllotAddress(_address,1);\\r\\n    }\\r\\n\\r\\n    function setLpAddress(address _address) external onlyOwner{\\r\\n        require(_address != address(0),\\\"The address is empty\\\");\\r\\n        addressLp = _address;\\r\\n        emit SetAllotAddress(_address,2);\\r\\n    }\\r\\n    \\r\\n    function setFixedAddress(address _address) external onlyOwner{\\r\\n        require(_address != address(0),\\\"The address is empty\\\");\\r\\n        addressFixed = _address;\\r\\n        emit SetAllotAddress(_address,3);\\r\\n    }\\r\\n\\r\\n    function WhiteFromList() external view returns(address[] memory){\\r\\n      return(whiteListFrom.details());\\r\\n    }\\r\\n    function WhiteToList() external view returns(address[] memory){\\r\\n      return(whiteListTo.details());\\r\\n    }\\r\\n    function WhiteFrom(address _address) external view returns(bool){\\r\\n      return(whiteListFrom.isexists(_address));\\r\\n    }\\r\\n    function WhiteTo(address _address) external view returns(bool){\\r\\n      return(whiteListTo.isexists(_address));\\r\\n    }\\r\\n  \\r\\n    function SetWhiteFrom(address _address) external onlyOwner{\\r\\n        whiteListFrom.set(_address,1);\\r\\n    }\\r\\n\\r\\n    function RemoveWhiteFrom(address _address) external onlyOwner{ \\r\\n      whiteListFrom.remove(_address,1);\\r\\n    }\\r\\n\\r\\n    function SetWhiteTo(address _address) external onlyOwner{\\r\\n      whiteListTo.set(_address,2);\\r\\n    }\\r\\n\\r\\n    function RemoveWhiteTo(address _address) external onlyOwner{ \\r\\n      whiteListTo.remove(_address,2);\\r\\n    }\\r\\n  \\r\\n    function transferOwnership(address _newOwner) external   onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"  new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, _newOwner);\\r\\n        _owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Total number of tokens in existence\\r\\n    */\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n  \\r\\n\\r\\n  /**\\r\\n  * @dev Gets the balance of the specified address.\\r\\n  * @param owner The address to query the balance of.\\r\\n  * @return An uint256 representing the amount owned by the passed address.\\r\\n  */\\r\\n  function balanceOf(address owner) external view returns (uint256) {\\r\\n    return _balances[owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\r\\n   * @param owner address The address which owns the funds.\\r\\n   * @param spender address The address which will spend the funds.\\r\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\r\\n   */\\r\\n  function allowance(\\r\\n    address owner,\\r\\n    address spender\\r\\n   )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return _allowed[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Transfer token for a specified address\\r\\n  * @param to The address to transfer to.\\r\\n  * @param value The amount to be transferred.\\r\\n  */\\r\\n  function transfer(address to, uint256 value) external returns (bool) {\\r\\n    _transfer(msg.sender, to, value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   * @param spender The address which will spend the funds.\\r\\n   * @param value The amount of tokens to be spent.\\r\\n   */\\r\\n  function approve(address spender, uint256 value) external returns (bool) {\\r\\n    require(spender != address(0),\\\"the address is empty\\\");\\r\\n\\r\\n    _allowed[msg.sender][spender] = value;\\r\\n    emit Approval(msg.sender, spender, value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfer tokens from one address to another\\r\\n   * @param from address The address which you want to send tokens from\\r\\n   * @param to address The address which you want to transfer to\\r\\n   * @param value uint256 the amount of tokens to be transferred\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  )\\r\\n    external\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(value \\u003c= _allowed[from][msg.sender],\\\"Transfer amount greater than current balance\\\");\\r\\n\\r\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\r\\n    _transfer(from, to, value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\r\\n   * approve should be called when allowed_[_spender] == 0. To increment\\r\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n   * the first transaction is mined)\\r\\n   * From MonolithDAO Token.sol\\r\\n   * @param spender The address which will spend the funds.\\r\\n   * @param addedValue The amount of tokens to increase the allowance by.\\r\\n   */\\r\\n  function increaseAllowance(\\r\\n    address spender,\\r\\n    uint256 addedValue\\r\\n  )\\r\\n    external\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(spender != address(0),\\\"the address is empty\\\");\\r\\n\\r\\n    _allowed[msg.sender][spender] = (\\r\\n    _allowed[msg.sender][spender].add(addedValue));\\r\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\r\\n   * approve should be called when allowed_[_spender] == 0. To decrement\\r\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n   * the first transaction is mined)\\r\\n   * From MonolithDAO Token.sol\\r\\n   * @param spender The address which will spend the funds.\\r\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\r\\n   */\\r\\n  function decreaseAllowance(\\r\\n    address spender,\\r\\n    uint256 subtractedValue\\r\\n  )\\r\\n    external\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(spender != address(0),\\\"the address is empty\\\");\\r\\n\\r\\n    _allowed[msg.sender][spender] = (\\r\\n      _allowed[msg.sender][spender].sub(subtractedValue));\\r\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Transfer token for a specified addresses\\r\\n  * @param from The address to transfer from.\\r\\n  * @param to The address to transfer to.\\r\\n  * @param value The amount to be transferred.\\r\\n  */\\r\\n  function _transfer(address from, address to, uint256 value) internal {\\r\\n    require(value \\u003c= _balances[from],\\\"Transfer amount greater than current balance\\\");\\r\\n    require(to != address(0),\\\"to address is empty\\\");\\r\\n\\r\\n    uint valueM = value;\\r\\n      if ((!whiteListFrom.isexists(from) ) \\u0026\\u0026 (!whiteListTo.isexists(to))){\\r\\n          require(addressRelease != address(0),\\\"Release address is empty\\\");\\r\\n          require(addressLp != address(0),\\\"Lp address is empty\\\");\\r\\n          require(addressFixed != address(0),\\\"Fixed address is empty\\\");\\r\\n         \\r\\n          uint valueRelease = value.mul(2).div(100);\\r\\n          uint valueFixed = value.mul(2).div(100);\\r\\n          uint valueLp = value.mul(6).div(100);\\r\\n          //to address Value\\r\\n          valueM = value.sub(valueRelease).sub(valueFixed).sub(valueLp);\\r\\n          //Release pool Buckle point\\r\\n          _balances[from] = _balances[from].sub(valueRelease);\\r\\n          _balances[addressRelease] = _balances[addressRelease].add(valueRelease);\\r\\n          emit Transfer(from, addressRelease, valueRelease);\\r\\n          //Fixed address Buckle point\\r\\n           _balances[from] = _balances[from].sub(valueFixed);\\r\\n          _balances[addressFixed] = _balances[addressFixed].add(valueFixed);\\r\\n          emit Transfer(from, addressFixed, valueFixed);\\r\\n           //Lp pool Buckle point\\r\\n          _balances[from] = _balances[from].sub(valueLp);\\r\\n          _balances[addressLp] = _balances[addressLp].add(valueLp);\\r\\n           emit Transfer(from, addressLp, valueLp);\\r\\n      }\\r\\n      _balances[from] = _balances[from].sub(valueM);\\r\\n      _balances[to] = _balances[to].add(valueM);\\r\\n      emit Transfer(from, to, valueM);\\r\\n  }\\r\\n}\\r\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemoveWhiteTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"WhiteTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressLp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SetWhiteTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WhiteFromList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressFixed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SetWhiteFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLpAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WhiteToList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setFixedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setReleaseAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemoveWhiteFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListFrom\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"},{\"name\":\"firstAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"WhiteFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListTo\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"},{\"name\":\"firstAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"SetWhite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"RemoveWhite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"SetAllotAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "ERC20", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000e8d4a51000000000000000000000000000000000000000000000000000000000000000000448454c4100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000448454c4100000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://9caa8e40aa2894f3b9cf54431f2920a06385d6e53a4bbd42b5b0bf5c88a7bc32"}