{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/lens/OrderLens.sol\": {\r\n      \"content\": \"pragma solidity 0.8.15;\\n\\nimport \\\"src/interfaces/ILevelOracle.sol\\\";\\n\\ninterface IOrderManagerForOrderLens {\\n    struct Order {\\n        address pool;\\n        address owner;\\n        address indexToken;\\n        address collateralToken;\\n        address payToken;\\n        uint256 expiresAt;\\n        uint256 submissionBlock;\\n        uint256 price;\\n        uint256 executionFee;\\n        bool triggerAboveThreshold;\\n    }\\n\\n    struct Request {\\n        uint8 side;\\n        uint256 sizeChange;\\n        uint256 collateral;\\n        uint8 updateType;\\n    }\\n\\n    struct SwapOrder {\\n        address pool;\\n        address owner;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        uint256 price;\\n        uint256 executionFee;\\n    }\\n\\n    function orders(uint256) external view returns (Order memory);\\n    function requests(uint256) external view returns (Request memory);\\n    function swapOrders(uint256) external view returns (SwapOrder memory);\\n    function oracle() external view returns (ILevelOracle);\\n    function isMarketSwap(uint256) external view returns (bool);\\n    function swapOrderSubmissionTimestamp(uint256) external view returns (uint256);\\n}\\n\\ninterface IPoolForOrderLens {\\n    struct Position {\\n        /// @dev contract size is evaluated in dollar\\n        uint256 size;\\n        /// @dev collateral value in dollar\\n        uint256 collateralValue;\\n        /// @dev contract size in indexToken\\n        uint256 reserveAmount;\\n        /// @dev average entry price\\n        uint256 entryPrice;\\n        /// @dev last cumulative interest rate\\n        uint256 borrowIndex;\\n    }\\n\\n    function positions(bytes32 id) external view returns (Position memory);\\n    function calcSwapOutput(address _tokenIn, address _tokenOut, uint256 _amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut, uint256 feeAmount);\\n    function fee()\\n        external\\n        view\\n        returns (\\n            uint256 positionFee,\\n            uint256 liquidationFee,\\n            uint256 baseSwapFee,\\n            uint256 taxBasisPoint,\\n            uint256 stableCoinBaseSwapFee,\\n            uint256 stableCoinTaxBasisPoint,\\n            uint256 daoFee\\n        );\\n}\\n\\ncontract OrderLens {\\n    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address constant WETH = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\n\\n    uint256 constant MARKET_ORDER_TIMEOUT = 5 minutes;\\n\\n    function canExecuteOrders(IOrderManagerForOrderLens _orders, IPoolForOrderLens _pool, uint256[] calldata _orderIds)\\n        external\\n        view\\n        returns (bool[] memory)\\n    {\\n        uint256 count = _orderIds.length;\\n        bool[] memory rejected = new bool[](count);\\n        (uint256 positionFee, uint256 liquidationFee,,,,,) = _pool.fee();\\n        for (uint256 i = 0; i < count; i++) {\\n            uint256 orderId = _orderIds[i];\\n            IOrderManagerForOrderLens.Order memory order = _orders.orders(orderId);\\n            IOrderManagerForOrderLens.Request memory request = _orders.requests(orderId);\\n            IPoolForOrderLens.Position memory position =\\n                _pool.positions(_getPositionKey(order.owner, order.indexToken, order.collateralToken, request.side));\\n            if (order.expiresAt != 0 && order.expiresAt < block.timestamp) {\\n                continue;\\n            }\\n            if (order.owner == address(0)) {\\n                rejected[i] = true;\\n                continue;\\n            }\\n\\n            if (request.updateType == 1) {\\n                //decrease\\n                if (position.size == 0) {\\n                    rejected[i] = true;\\n                    continue;\\n                }\\n\\n                if (position.size > request.sizeChange) {\\n                    if (position.collateralValue < request.collateral) {\\n                        rejected[i] = true;\\n                        continue;\\n                    }\\n                    uint256 newSize = position.size - request.sizeChange;\\n                    uint256 fee = positionFee * request.sizeChange / 1e10;\\n                    uint256 newCollateral = position.collateralValue - request.collateral;\\n                    newCollateral = newCollateral > fee ? newCollateral - fee : 0;\\n                    rejected[i] = newCollateral < liquidationFee || newCollateral > newSize; // leverage\\n                    continue;\\n                }\\n            }\\n        }\\n\\n        return rejected;\\n    }\\n\\n    function canExecuteSwapOrders(\\n        IOrderManagerForOrderLens _orders,\\n        IPoolForOrderLens _pool,\\n        uint256[] calldata _orderIds\\n    ) external view returns (bool[] memory rejected) {\\n        uint256 count = _orderIds.length;\\n        rejected = new bool[](count);\\n\\n        for (uint256 i = 0; i < count; ++i) {\\n            uint256 orderId = _orderIds[i];\\n            IOrderManagerForOrderLens.SwapOrder memory order = _orders.swapOrders(orderId);\\n\\n            if (order.owner == address(0)) {\\n                rejected[i] = true;\\n                continue;\\n            }\\n\\n            bool isMarket = _orders.isMarketSwap(orderId);\\n            uint256 submissionTimestamp = _orders.swapOrderSubmissionTimestamp(orderId);\\n            if (isMarket && submissionTimestamp + MARKET_ORDER_TIMEOUT < block.timestamp) {\\n                continue;\\n            }\\n\\n            address tokenIn = order.tokenIn == ETH ? WETH : order.tokenIn;\\n            address tokenOut = order.tokenOut == ETH ? WETH : order.tokenOut;\\n            (uint256 amountOut,) = _pool.calcSwapOutput(tokenIn, tokenOut, order.amountIn);\\n            rejected[i] = amountOut < order.minAmountOut;\\n        }\\n    }\\n\\n    function _getPositionKey(address _owner, address _indexToken, address _collateralToken, uint8 _side)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_owner, _indexToken, _collateralToken, _side));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILevelOracle.sol\": {\r\n      \"content\": \"pragma solidity >= 0.8.0;\\n\\ninterface ILevelOracle {\\n    /**\\n     * @notice get price of single token\\n     * @param token address of token to consult\\n     * @param max if true returns max price and vice versa\\n     */\\n    function getPrice(address token, bool max) external view returns (uint256);\\n\\n    function getMultiplePrices(address[] calldata tokens, bool max) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice returns chainlink price used when liquidate\\n     */\\n    function getReferencePrice(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice returns timestamp of last posted price\\n     */\\n    function lastAnswerTimestamp(address token) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IOrderManagerForOrderLens\",\"name\":\"_orders\",\"type\":\"address\"},{\"internalType\":\"contract IPoolForOrderLens\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_orderIds\",\"type\":\"uint256[]\"}],\"name\":\"canExecuteOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOrderManagerForOrderLens\",\"name\":\"_orders\",\"type\":\"address\"},{\"internalType\":\"contract IPoolForOrderLens\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_orderIds\",\"type\":\"uint256[]\"}],\"name\":\"canExecuteSwapOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"rejected\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OrderLens", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}