{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\nabstract contract Staking\\n{\\n    uint256 constant internal RATE_PRECISION=1e40;\\n\\n    uint256 public rewardRate;//\u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043d\u0430\u0433\u0440\u0430\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 1 ORN \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0443 \u043d\u0430 \u0432\u0441\u0435\u0445 (\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c 10**48)\\n\\n    struct UserState\\n    {\\n        uint256 stake;\\n        uint256 rateCumulative;\\n        uint256 reward;\\n        uint256 rewardWithdraw;\\n    }\\n\\n    uint256 public allStake; //\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u0441\u0442\u0435\u0439\u043a\u043e\u0432\\n    mapping(address => UserState) public poolStake;//\u0441\u0442\u0435\u0439\u043a\u0438 \u043f\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\\n\\n    uint256 public rateCumulative;\\n    uint256 public rateTime;\\n    uint256 private rewardCumulativeTotal;//\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u043d\u0430\u0433\u0440\u0430\u0434\\n\\n    event SetRewards(uint64 rewards, uint64 duration, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 timestamp);\\n    event Stake(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    event Unstake(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    event ClaimReward(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    \\n\\n    //  Set the overall reward\\n    function _setRewards(uint64 rewards, uint64 duration) internal\\n    {\\n        require(duration > 0, \\\"_setRewards: zero duration\\\");\\n\\n        _writeCumulative();\\n\\n        //  ORN / sec\\n        rewardRate = RATE_PRECISION * rewards / duration;\\n\\n        emit SetRewards(rewards, duration, rewardCumulativeTotal, rateCumulative, block.timestamp);\\n    }\\n\\n    //\u0420\u0430\u0441\u0447\u0435\u0442 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u043d\u0430\u0433\u0440\u0430\u0434\u044b\\n    function calcNewRate() public virtual view returns (uint256)\\n    {\\n        uint256 Rate=0;\\n        if(allStake>0)\\n        {\\n            Rate=rewardRate/allStake;\\n        }\\n\\n        return Rate*(block.timestamp-rateTime);\\n    }\\n\\n    function _writeCumulative() virtual internal\\n    {\\n        uint256 newRate = calcNewRate();\\n\\n        rewardCumulativeTotal += newRate*allStake/RATE_PRECISION;\\n        rateCumulative += newRate;\\n        rateTime=block.timestamp;\\n    }\\n\\n    function _stake(address account, uint256 amount) internal\\n    {\\n        require(amount>0,\\\"_stake: zero stake amount\\\");\\n\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n        item.reward=_calcReward(item, rateCumulative);\\n        item.stake += amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        allStake += amount;\\n\\n        emit Stake(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n    function _claimReward(address account, uint256 amount) internal\\n    {\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n\\n        item.reward=_calcReward(item, rateCumulative);\\n        require(item.reward - item.rewardWithdraw >= amount,\\\"Error claim amount\\\");\\n        item.rewardWithdraw += amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        emit ClaimReward(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n    function _unstake(address account, uint256 amount) internal\\n    {\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n        require(item.stake >= amount,\\\"Error unstake amount\\\");\\n        \\n        item.reward=_calcReward(item, rateCumulative);\\n        item.stake -= amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        allStake -= amount;\\n\\n        emit Unstake(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n\\n    function _calcReward(UserState memory item, uint256 _rateCumulative) internal pure returns (uint256)\\n    {\\n        return item.reward + (_rateCumulative-item.rateCumulative)*item.stake/RATE_PRECISION;\\n    }\\n\\n    function getReward(address account) public virtual view returns (uint256)\\n    {\\n        UserState memory item=poolStake[account];\\n        uint256 _rateCumulative = rateCumulative + calcNewRate();\\n        return _calcReward(item, _rateCumulative) - item.rewardWithdraw;\\n    }\\n\\n    function getStake(address account) public view returns (uint256)\\n    {\\n        return poolStake[account].stake;\\n    }\\n\\n    function getRewardWithdraw(address account) external view returns (uint256)\\n    {\\n        return poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulative(address account) external view returns (uint256)\\n    {\\n        return getReward(account) + poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulativeAll() public view returns (uint256)\\n    {\\n        uint256 newRate = calcNewRate();\\n        return rewardCumulativeTotal + newRate*allStake/RATE_PRECISION;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/base/StakingReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./Staking.sol\\\";\\nimport \\\"../interfaces/IOrionVoting.sol\\\";\\nimport \\\"../interfaces/ITWBalance.sol\\\";\\nimport \\\"../interfaces/IveORN.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\ncontract StakingReward is Staking\\n{\\n    uint128 constant YEAR = 365 * 86400;\\n    uint256 constant MAXTIME = 2 * YEAR;\\n\\n    uint256 constant internal BOOST_PRECISION=1e18;\\n    uint128 public constant  MAX_LOCK_MULTIPLIER = 2;\\n    uint128 public constant  MAX_VEORN_MULTIPLIER = 2;\\n    uint128 public constant  MAX_BOOSTED_REWARD = 4;\\n\\n    struct UserStateTime\\n    {\\n        uint48 lock_start;\\n        uint48 lock_period;\\n        bool   staking;\\n\\n        ITWBalance.TWItem balanceTW;\\n        ITWBalance.TWItem totalTW;\\n    }\\n\\n    uint256 public usedRewardForRate;//\u0443\u0447\u0442\u0435\u043d\u043d\u0430\u044f \u043d\u0430\u0433\u0440\u0430\u0434\u0430 \u043f\u0440\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u0435 \u043a\u0443\u0440\u0441\u0430\\n    mapping(address => UserStateTime) public poolTimeStake;//\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043c\u0435\u0442\u043a\u0438 \u043b\u043e\u043a\u0430 \u043f\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\\n\\n    address public parentSmart;\\n    address public tokenStake;\\n    address public immutable smartVote;\\n    address public immutable veORN;\\n\\n    event Deposit(address indexed provider, uint256 value, uint256 indexed lock_period, uint256 ts);\\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\\n    event ClaimReward2(address indexed provider, uint256 value, uint256 originValue, uint256 ts);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == parentSmart, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    \\n    constructor(address _smartVote)\\n    {\\n        smartVote=_smartVote;\\n        veORN=IOrionVoting(_smartVote).veORN();\\n    }\\n    \\n    function init(address _token) external\\n    {\\n        require(parentSmart==address(0),\\\"StakingReward: Was init\\\");\\n\\n        parentSmart=msg.sender;\\n        tokenStake=_token;\\n        /*smartVote=_smartVote;\\n        veORN=IOrionVoting(_smartVote).veORN();\\n        */\\n    }\\n\\n\\n    //override\\n    function calcNewRate() public override view returns (uint256)\\n    {\\n        uint256 Rate=0;\\n        if(allStake>0)\\n        {\\n            uint256 rewardPool=IOrionVoting(smartVote).getRewardCumulative(tokenStake);\\n\\n            //\u043e\u0442\u043d\u0438\u043c\u0430\u0435\u043c \u0443\u0436\u0435 \u0443\u0447\u0442\u0435\u043d\u043d\u0443\u044e \u043d\u0430\u0433\u0440\u0430\u0434\u0443 \u043f\u0440\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u0435 \u043a\u0443\u0440\u0441\u0430\\n            rewardPool -= usedRewardForRate;\\n\\n            Rate=RATE_PRECISION*rewardPool/allStake;\\n        }\\n\\n        return Rate;\\n    }\\n    function _writeCumulative() override internal\\n    {\\n        super._writeCumulative();\\n        usedRewardForRate=IOrionVoting(smartVote).getRewardCumulative(tokenStake);\\n    }\\n\\n    function getReward(address account) public override view returns (uint256)\\n    {\\n        uint256 Reward = super.getReward(account) / (MAX_BOOSTED_REWARD+1);\\n\\n        uint256 Boost = getBoost(account);\\n\\n        return Boost  * Reward / BOOST_PRECISION;\\n    }\\n\\n\\n    //external\\n    function stake(address account, uint256 amount, uint256 lock_period) onlyOwner external returns(uint256 reward)\\n    {\\n        require(IOrionVoting(smartVote).havePool(tokenStake),\\\"Pool not found in voting\\\");\\n\\n        reward = __claimReward(account);\\n\\n        bool needWrite=false;\\n        UserStateTime memory item=poolTimeStake[account];\\n        if(lock_period>0)\\n        {\\n            require(lock_period <= MAXTIME, \\\"Staking lock can be 2 years max\\\");\\n\\n            if(item.lock_period>0)\\n            {\\n                //\u0443\u0436\u0435 \u0431\u044b\u043b \u043b\u043e\u043a, \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0447\u0442\u043e \u043a\u043e\u043d\u0435\u0447\u043d\u0430\u044f \u0434\u0430\u0442\u0430 \u043d\u0435 \u0443\u043c\u0435\u043d\u044c\u0448\u0438\u043b\u0430\u0441\u044c\\n                uint256 timeLockWas = item.lock_start + item.lock_period;\\n                uint256 timeLockNew = block.timestamp + lock_period;\\n\\n                require(timeLockNew >= timeLockWas, \\\"Can only increase lock duration\\\");\\n            }\\n\\n            item.lock_start = uint48(block.timestamp);\\n            item.lock_period = uint48(lock_period);\\n            needWrite=true;\\n        }\\n\\n\\n        if(!item.staking)\\n        {\\n            //\u043f\u0440\u0438 \u043f\u0435\u0440\u0432\u043e\u043c \u0441\u0442\u0435\u0439\u043a\u0438\u043d\u0433\u0435 \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c TW \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0441\u0440\u0435\u0434\u043d\u0435\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430\\n            item.balanceTW = IveORN(veORN).balanceOfTW(account);\\n            item.totalTW = IveORN(veORN).totalSupplyTW();\\n            item.staking=true;\\n            needWrite=true;\\n        }\\n\\n        if(needWrite)\\n        {\\n            poolTimeStake[account]=item;\\n        }\\n\\n\\n        if(amount>0)\\n        {\\n            _stake(account, amount);\\n        }\\n        emit Deposit(account, amount, lock_period, block.timestamp);\\n    }\\n\\n    function withdraw(address account) onlyOwner external returns(uint256 reward, uint256 amount)\\n    {\\n        UserStateTime memory item=poolTimeStake[account];\\n        require(item.lock_period == 0 || item.lock_start + item.lock_period <= block.timestamp,\\\"The lock didn't expire\\\");\\n\\n        reward = __claimReward(account);\\n        amount = getStake(account);\\n\\n        _unstake(account, amount);\\n\\n        delete poolStake[account];\\n        delete poolTimeStake[account];\\n\\n        emit Withdraw(account, amount, block.timestamp);\\n    }\\n\\n    function claimReward(address account) onlyOwner  external returns(uint256)\\n    {\\n        return __claimReward(account);\\n    }\\n\\n    //internal\\n    function __claimReward(address account) internal returns(uint256 reward)\\n    {\\n        reward=getReward(account);//reward with boost\\n        if(reward>0)\\n        {\\n            uint256 originReward=super.getReward(account);\\n            _claimReward(account, originReward);\\n\\n            uint256 _useRewardAdd = originReward-reward;\\n\\n            //\u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043d\u0435\u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u0443\u044e \u043d\u0430\u0433\u0440\u0430\u0434\u0443 \u0431\u0443\u0441\u0442\u0438\u043d\u0433\u0430\\n            usedRewardForRate -= _useRewardAdd; //usedRewardForRate \u0432\u0441\u0435\u0433\u0434\u0430 \u0431\u043e\u043b\u044c\u0448\u0435 _useRewardAdd\\n            emit ClaimReward2(account, reward, originReward, block.timestamp);\\n        }\\n    }\\n\\n    //View\\n\\n    function getBoost(address account) public view returns (uint256)\\n    {\\n        UserStateTime memory item=poolTimeStake[account];\\n\\n        uint256 totalLiquidity = allStake;\\n        uint256 totalVeORN=IveORN(veORN).totalSupplyAvg(item.totalTW);\\n        uint256 currentPoolReward=IOrionVoting(smartVote).getRewardCumulative(tokenStake);\\n        uint256 BoostVeORN=0;\\n        if(totalVeORN>0 && totalLiquidity>0 && currentPoolReward>0)\\n        {\\n            uint256 currentLiquidity = getStake(account);\\n            uint256 currentVeORN=IveORN(veORN).balanceOfAvg(account, item.balanceTW);\\n\\n            uint256 totalReward=IOrionVoting(smartVote).getRewardCumulativeAll();\\n\\n            uint256 KVeorn=BOOST_PRECISION*currentVeORN/totalVeORN;\\n            uint256 KLiquidity=BOOST_PRECISION*currentLiquidity/totalLiquidity;\\n\\n            if(KLiquidity>0)\\n            {\\n                uint256 KPoolReverse = BOOST_PRECISION*totalReward/currentPoolReward;\\n                BoostVeORN = KVeorn*KPoolReverse*MAX_VEORN_MULTIPLIER/KLiquidity;\\n                if(BoostVeORN > MAX_VEORN_MULTIPLIER*BOOST_PRECISION)\\n                    BoostVeORN = MAX_VEORN_MULTIPLIER*BOOST_PRECISION;\\n            }\\n        }\\n\\n        uint256 BoostStaking = MAX_LOCK_MULTIPLIER*BOOST_PRECISION*item.lock_period/MAXTIME;\\n\\n        return BoostVeORN + BoostStaking + BOOST_PRECISION;\\n    }\\n\\n\\n    function lockTimeStart(address account) external view returns (uint48)\\n    {\\n        return poolTimeStake[account].lock_start;\\n    }\\n    function lockTimePeriod(address account) external view returns (uint48)\\n    {\\n        return poolTimeStake[account].lock_period;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IOrionVoting is IStaking\\n{\\n\\n    //admin\\n    function setSmart(address addr, bool bUse) external;\\n    function setRewards(uint64 rewards, uint64 duration) external;\\n    function addPool(address pool) external;\\n    function deletePool(address pool) external;\\n\\n\\n    //user\\n    function vote(address pool, uint256 amount) external;\\n    function voteArr(address[] calldata pools, uint256[] calldata amounts) external;\\n    function unvote(address pool, uint256 amount) external;\\n    function unvoteAll(address account) external;\\n\\n    //smart\\n    function claimReward(address pool, address to, uint256 amount) external;\\n\\n    //vew\\n    function countPool() external view returns (uint256);//number of pools\\n    function poolList(uint256) external view returns (address);//list of pools\\n    function poolIndex(address pool) external view returns (uint256);//whether there is a pool in the list (index numbers starting from 1)\\n    function users(address user) external view returns (uint256);//user votes across all pools\\n    function usersPool(address user,address pool) external view returns (uint256);//user votes by pool\\n    function smarts(address smart) external view returns (bool);//white list of trusted farm contracts\\n\\n    function veORN() external view returns (address);\\n    function ORN() external view returns (address);\\n\\n    function havePool(address account) external view returns (bool);\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IStaking\\n{\\n    //staking\\n    function getReward(address account) external view returns (uint256);\\n    function getStake(address account) external view returns (uint256);\\n    function allStake() external view returns (uint256);\\n    function rewardRate() external view returns (uint256);\\n    function rateCumulative() external view returns (uint256);\\n    function rateTime() external view returns (uint256);\\n\\n\\n    function getRewardWithdraw(address account) external view returns (uint256);\\n    function getRewardCumulative(address account) external view returns (uint256);\\n    function getRewardCumulativeAll() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITWBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface ITWBalance\\n{\\n    struct TWItem\\n    {\\n        // the block timestamp\\n        uint48  timestamp;        \\n        // the amount accumulator, i.e. amount * time elapsed\\n        uint208 amountTW;\\n    }\\n\\n    /// @notice Returns the time weight (TW) amount of tokens in existence.\\n    function totalSupplyTW() external view returns (TWItem memory);\\n\\n    /// @notice Calculates the average aamount of tokens in existence from the specified TW period\\n    function totalSupplyAvg(TWItem memory itemStart) view external returns (uint256);\\n\\n    /// @notice Returns the time weight (TW) balance of a token\\n    /// @param user The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOfTW(address user) external view returns (TWItem memory);\\n    \\n    /// @notice Calculates the average address balance from the specified TW period\\n    function balanceOfAvg(address user, TWItem memory itemStart) view external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IveORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ITWBalance.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IveORN is ITWBalance,IStaking\\n{\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n    function totalSupply(uint256 ts) external view returns (uint256);\\n    function totalSupply0() external view returns (uint256);//balance on start timestamp\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n    function balanceOf(address account, uint256 ts) external view returns (uint256);\\n    function balanceOf0(address account) external view returns (uint256);//balance on start timestamp\\n\\n    function balanceTokenOf(address account) external view  returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n    \\n    function name() pure external returns(string memory);\\n    function symbol() pure external returns(string memory);\\n \\n\\n    function ORN() external view returns (address);\\n\\n    function lockTime(address account) external view returns (uint48);\\n\\n    \\n    //staking ORN\\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\\n    //function deposit_for(address _addr, uint256 _value) external;\\n    function increase_amount(uint256 _value) external;\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n    function increase_unlock_period(uint256 unlock_period) external;\\n    function create_lock_period(uint256 _value, uint256 unlock_period) external;\\n\\n    function withdraw() external;\\n    function claimReward() external;\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartVote\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"ClaimReward2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lock_period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SetRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_BOOSTED_REWARD\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LOCK_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VEORN_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcNewRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardCumulativeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockTimePeriod\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockTimeStart\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parentSmart\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolTimeStake\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"lock_start\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lock_period\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"staking\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint208\",\"name\":\"amountTW\",\"type\":\"uint208\"}],\"internalType\":\"struct ITWBalance.TWItem\",\"name\":\"balanceTW\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint208\",\"name\":\"amountTW\",\"type\":\"uint208\"}],\"internalType\":\"struct ITWBalance.TWItem\",\"name\":\"totalTW\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lock_period\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usedRewardForRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veORN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingReward", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000465f42eedd6471e38695362b3b43516f079f23c1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}