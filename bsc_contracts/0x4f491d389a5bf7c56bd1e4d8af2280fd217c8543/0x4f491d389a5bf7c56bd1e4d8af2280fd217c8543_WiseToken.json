{"SourceCode": "{\"BEP20.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\ncontract Context {\\r\\n\\r\\n    /**\\r\\n     * @dev returns address executing the method\\r\\n     */\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns data passed into the method\\r\\n     */\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BEP20 is Context {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    /**\\r\\n     * @dev initial private\\r\\n     */\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev \ud83d\udc7b ghost supply - unclaimable\\r\\n     */\\r\\n    uint256 private _totalSupply = 0.404E18;\\r\\n\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    constructor (string memory tokenName, string memory tokenSymbol) {\\r\\n        _name = tokenName;\\r\\n        _symbol = tokenSymbol;\\r\\n        _decimals = 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals of the token.\\r\\n     */\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total supply of the token.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token balance of specific address.\\r\\n     */\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(\\r\\n            _msgSender(),\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns approved balance to be spent by another address\\r\\n     * by using transferFrom method\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the token allowance to another spender\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows to transfer tokens on senders behalf\\r\\n     * based on allowance approved for the executer\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(sender,\\r\\n            _msgSender(), _allowances[sender][_msgSender()].sub(\\r\\n                amount\\r\\n            )\\r\\n        );\\r\\n\\r\\n        _transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            sender != address(0x0)\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            recipient != address(0x0)\\r\\n        );\\r\\n\\r\\n        _balances[sender] =\\r\\n        _balances[sender].sub(amount);\\r\\n\\r\\n        _balances[recipient] =\\r\\n        _balances[recipient].add(amount);\\r\\n\\r\\n        emit Transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            account != address(0x0)\\r\\n        );\\r\\n\\r\\n        _totalSupply =\\r\\n        _totalSupply.add(amount);\\r\\n\\r\\n        _balances[account] =\\r\\n        _balances[account].add(amount);\\r\\n\\r\\n        emit Transfer(\\r\\n            address(0x0),\\r\\n            account,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows to burn tokens if token sender\\r\\n     * wants to reduce totalSupply() of the token\\r\\n     */\\r\\n    function burn(\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            account != address(0x0)\\r\\n        );\\r\\n\\r\\n        _balances[account] =\\r\\n        _balances[account].sub(amount);\\r\\n\\r\\n        _totalSupply =\\r\\n        _totalSupply.sub(amount);\\r\\n\\r\\n        emit Transfer(\\r\\n            account,\\r\\n            address(0x0),\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            owner != address(0x0)\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            spender != address(0x0)\\r\\n        );\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n\\r\\n        emit Approval(\\r\\n            owner,\\r\\n            spender,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\"},\"Declaration.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./Global.sol\\\";\\r\\n\\r\\ninterface ISyntheticBNB {\\r\\n\\r\\n    function deposit()\\r\\n        external\\r\\n        payable;\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapV2Factory {\\r\\n\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (\\r\\n        address pair\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapRouterV2 {\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (\\r\\n        uint[] memory amounts\\r\\n    );\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (\\r\\n        uint[] memory amounts\\r\\n    );\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (\\r\\n        uint[] memory amounts\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapV2Pair {\\r\\n\\r\\n    function getReserves() external view returns (\\r\\n        uint112 reserve0,\\r\\n        uint112 reserve1,\\r\\n        uint32 blockTimestampLast\\r\\n    );\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ILiquidityGuard {\\r\\n\\r\\n    function getInflation(\\r\\n        uint32 _amount\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IBUSDEquivalent {\\r\\n\\r\\n    function getBUSDEquivalent()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IBEP20Token {\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n}\\r\\n\\r\\nabstract contract Declaration is Global {\\r\\n\\r\\n    uint256 constant _decimals = 18;\\r\\n    uint256 constant YODAS_PER_WISE = 10 ** _decimals;\\r\\n\\r\\n    uint32 constant SECONDS_IN_DAY = 86400 seconds;\\r\\n    uint16 constant MIN_LOCK_DAYS = 1;\\r\\n    uint16 constant FORMULA_DAY = 25;\\r\\n    uint16 constant MAX_LOCK_DAYS = 15330;\\r\\n    uint16 constant MAX_BONUS_DAYS_A = 1825;\\r\\n    uint16 constant MAX_BONUS_DAYS_B = 13505;\\r\\n    uint16 constant MIN_REFERRAL_DAYS = 365;\\r\\n\\r\\n    uint32 constant MIN_STAKE_AMOUNT = 1000000;\\r\\n    uint32 constant REFERRALS_RATE = 366816973; // 1.000% (direct value, can be used right away)\\r\\n    uint32 constant INFLATION_RATE_MAX = 103000; // 3.000% (indirect -\\u003e checks throgh LiquidityGuard)\\r\\n\\r\\n    uint32 public INFLATION_RATE = 103000; // 3.000% (indirect -\\u003e checks throgh LiquidityGuard)\\r\\n    uint32 public LIQUIDITY_RATE = 100006; // 0.006% (indirect -\\u003e checks throgh LiquidityGuard)\\r\\n\\r\\n    uint64 constant PRECISION_RATE = 1E18;\\r\\n    uint96 constant THRESHOLD_LIMIT = 10000E18; // $10,000 $BUSD\\r\\n\\r\\n    uint96 constant DAILY_BONUS_A = 13698630136986302; // 25%:1825 = 0.01369863013 per day;\\r\\n    uint96 constant DAILY_BONUS_B = 370233246945575;   // 5%:13505 = 0.00037023324 per day;\\r\\n\\r\\n    uint256 public LTBalance;\\r\\n    uint256 public LAUNCH_TIME;\\r\\n\\r\\n    address constant public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n\\r\\n    ISyntheticBNB public SBNB;\\r\\n\\r\\n    IPancakeSwapRouterV2 public constant PANCAKE_ROUTER = IPancakeSwapRouterV2(\\r\\n        0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n    );\\r\\n\\r\\n    IPancakeSwapV2Factory public constant PANCAKE_FACTORY = IPancakeSwapV2Factory(\\r\\n        0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\\r\\n    );\\r\\n\\r\\n    ILiquidityGuard public constant LIQUIDITY_GUARD = ILiquidityGuard(\\r\\n        0x44CD20CeCd1e8466477f2f11aA207f2623EbfF17\\r\\n    );\\r\\n\\r\\n    bool public isLiquidityGuardActive;\\r\\n    IPancakeSwapV2Pair public PANCAKE_PAIR;\\r\\n    IBUSDEquivalent public BUSD_EQ;\\r\\n\\r\\n    constructor() {\\r\\n        LAUNCH_TIME = 1619395200; // (26th April 2021 @00:00 GMT == day 0)\\r\\n    }\\r\\n\\r\\n    function createPair()\\r\\n        external\\r\\n    {\\r\\n        PANCAKE_PAIR = IPancakeSwapV2Pair(\\r\\n            PANCAKE_FACTORY.createPair(\\r\\n                address(SBNB),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    struct Stake {\\r\\n        uint256 stakesShares;\\r\\n        uint256 stakedAmount;\\r\\n        uint256 rewardAmount;\\r\\n        uint64 startDay;\\r\\n        uint64 lockDays;\\r\\n        uint64 finalDay;\\r\\n        uint64 closeDay;\\r\\n        uint256 scrapeDay;\\r\\n        uint256 daiEquivalent;\\r\\n        uint256 referrerShares;\\r\\n        address referrer;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    struct ReferrerLink {\\r\\n        address staker;\\r\\n        bytes16 stakeID;\\r\\n        uint256 rewardAmount;\\r\\n        uint256 processedDays;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    struct LiquidityStake {\\r\\n        uint256 stakedAmount;\\r\\n        uint256 rewardAmount;\\r\\n        uint64 startDay;\\r\\n        uint64 closeDay;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    struct CriticalMass {\\r\\n        uint256 totalAmount;\\r\\n        uint256 activationDay;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e uint256) public stakeCount;\\r\\n    mapping(address =\\u003e uint256) public referralCount;\\r\\n    mapping(address =\\u003e uint256) public liquidityStakeCount;\\r\\n\\r\\n    mapping(address =\\u003e CriticalMass) public criticalMass;\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e uint256)) public scrapes;\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e Stake)) public stakes;\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e ReferrerLink)) public referrerLinks;\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e LiquidityStake)) public liquidityStakes;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public scheduledToEnd;\\r\\n    mapping(uint256 =\\u003e uint256) public referralSharesToEnd;\\r\\n    mapping(uint256 =\\u003e uint256) public totalPenalties;\\r\\n}\\r\\n\"},\"Events.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\ncontract Events {\\n\\n    event StakeStart(\\n        bytes16 indexed stakeID,\\n        address indexed stakerAddress,\\n        address indexed referralAddress,\\n        uint256 stakedAmount,\\n        uint256 stakesShares,\\n        uint256 referralShares,\\n        uint256 startDay,\\n        uint256 lockDays,\\n        uint256 daiEquivalent\\n    );\\n\\n    event StakeEnd(\\n        bytes16 indexed stakeID,\\n        address indexed stakerAddress,\\n        address indexed referralAddress,\\n        uint256 stakedAmount,\\n        uint256 stakesShares,\\n        uint256 referralShares,\\n        uint256 rewardAmount,\\n        uint256 closeDay,\\n        uint256 penaltyAmount\\n    );\\n\\n    event InterestScraped(\\n        bytes16 indexed stakeID,\\n        address indexed stakerAddress,\\n        uint256 scrapeAmount,\\n        uint256 scrapeDay,\\n        uint256 stakersPenalty,\\n        uint256 referrerPenalty,\\n        uint256 currentWiseDay\\n    );\\n\\n    event ReferralCollected(\\n        address indexed staker,\\n        bytes16 indexed stakeID,\\n        address indexed referrer,\\n        bytes16 referrerID,\\n        uint256 rewardAmount\\n    );\\n\\n    event NewGlobals(\\n        uint256 totalShares,\\n        uint256 totalStaked,\\n        uint256 shareRate,\\n        uint256 referrerShares,\\n        uint256 indexed currentWiseDay\\n    );\\n\\n    event NewSharePrice(\\n        uint256 newSharePrice,\\n        uint256 oldSharePrice,\\n        uint64 currentWiseDay\\n    );\\n\\n    event PancakeSwapReserves(\\n        uint112 reserveA,\\n        uint112 reserveB,\\n        uint32 blockTimestampLast\\n    );\\n\\n    event LiquidityGuardStatus(\\n        bool isActive\\n    );\\n}\"},\"Global.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nimport \\\"./BEP20.sol\\\";\\nimport \\\"./Events.sol\\\";\\n\\nabstract contract Global is BEP20, Events {\\n\\n    using SafeMath for uint256;\\n\\n    struct Globals {\\n        uint256 totalStaked;\\n        uint256 totalShares;\\n        uint256 sharePrice;\\n        uint256 currentWiseDay;\\n        uint256 referralShares;\\n        uint256 liquidityShares;\\n    }\\n\\n    Globals public globals;\\n\\n    constructor() {\\n        globals.sharePrice = 100E15;\\n    }\\n\\n    function _increaseGlobals(\\n        uint256 _staked,\\n        uint256 _shares,\\n        uint256 _rshares\\n    )\\n        internal\\n    {\\n        globals.totalStaked =\\n        globals.totalStaked.add(_staked);\\n\\n        globals.totalShares =\\n        globals.totalShares.add(_shares);\\n\\n        if (_rshares \\u003e 0) {\\n\\n            globals.referralShares =\\n            globals.referralShares.add(_rshares);\\n        }\\n\\n        _logGlobals();\\n    }\\n\\n    function _decreaseGlobals(\\n        uint256 _staked,\\n        uint256 _shares,\\n        uint256 _rshares\\n    )\\n        internal\\n    {\\n        globals.totalStaked =\\n        globals.totalStaked \\u003e _staked ?\\n        globals.totalStaked - _staked : 0;\\n\\n        globals.totalShares =\\n        globals.totalShares \\u003e _shares ?\\n        globals.totalShares - _shares : 0;\\n\\n        if (_rshares \\u003e 0) {\\n\\n            globals.referralShares =\\n            globals.referralShares \\u003e _rshares ?\\n            globals.referralShares - _rshares : 0;\\n\\n        }\\n\\n        _logGlobals();\\n    }\\n\\n    function _logGlobals()\\n        private\\n    {\\n        emit NewGlobals(\\n            globals.totalShares,\\n            globals.totalStaked,\\n            globals.sharePrice,\\n            globals.referralShares,\\n            globals.currentWiseDay\\n        );\\n    }\\n}\\n\"},\"Helper.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nimport \\\"./Timing.sol\\\";\\n\\nabstract contract Helper is Timing {\\n\\n    using SafeMath for uint256;\\n\\n    function notContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size == 0);\\n    }\\n\\n    function toBytes16(uint256 x) internal pure returns (bytes16 b) {\\n       return bytes16(bytes32(x));\\n    }\\n\\n    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\\n        b = toBytes16(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(x, y, z)\\n                )\\n            )\\n        );\\n    }\\n\\n    function generateStakeID(address _staker) internal view returns (bytes16 stakeID) {\\n        return generateID(_staker, stakeCount[_staker], 0x01);\\n    }\\n\\n    function generateReferralID(address _referrer) internal view returns (bytes16 referralID) {\\n        return generateID(_referrer, referralCount[_referrer], 0x02);\\n    }\\n\\n    function generateLiquidityStakeID(address _staker) internal view returns (bytes16 liquidityStakeID) {\\n        return generateID(_staker, liquidityStakeCount[_staker], 0x03);\\n    }\\n\\n    function stakesPagination(\\n        address _staker,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        external\\n        view\\n        returns (bytes16[] memory _stakes)\\n    {\\n        uint256 start = _offset \\u003e 0 \\u0026\\u0026\\n            stakeCount[_staker] \\u003e _offset ?\\n            stakeCount[_staker] - _offset : stakeCount[_staker];\\n\\n        uint256 finish = _length \\u003e 0 \\u0026\\u0026\\n            start \\u003e _length ?\\n            start - _length : 0;\\n\\n        uint256 i;\\n\\n        _stakes = new bytes16[](start - finish);\\n\\n        for (uint256 _stakeIndex = start; _stakeIndex \\u003e finish; _stakeIndex--) {\\n            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\\n            if (stakes[_staker][_stakeID].stakedAmount \\u003e 0) {\\n                _stakes[i] = _stakeID; i++;\\n            }\\n        }\\n    }\\n\\n    function referralsPagination(\\n        address _referrer,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        external\\n        view\\n        returns (bytes16[] memory _referrals)\\n    {\\n        uint256 start = _offset \\u003e 0 \\u0026\\u0026\\n            referralCount[_referrer] \\u003e _offset ?\\n            referralCount[_referrer] - _offset : referralCount[_referrer];\\n\\n        uint256 finish = _length \\u003e 0 \\u0026\\u0026\\n            start \\u003e _length ?\\n            start - _length : 0;\\n\\n        uint256 i;\\n\\n        _referrals = new bytes16[](start - finish);\\n\\n        for (uint256 _rIndex = start; _rIndex \\u003e finish; _rIndex--) {\\n            bytes16 _rID = generateID(_referrer, _rIndex - 1, 0x02);\\n            if (_nonZeroAddress(referrerLinks[_referrer][_rID].staker)) {\\n                _referrals[i] = _rID; i++;\\n            }\\n        }\\n    }\\n\\n    function latestStakeID(address _staker) external view returns (bytes16) {\\n        return stakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, stakeCount[_staker].sub(1), 0x01);\\n    }\\n\\n    function latestReferralID(address _referrer) external view returns (bytes16) {\\n        return referralCount[_referrer] == 0 ? bytes16(0) : generateID(_referrer, referralCount[_referrer].sub(1), 0x02);\\n    }\\n\\n    function latestLiquidityStakeID(address _staker) external view returns (bytes16) {\\n        return liquidityStakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, liquidityStakeCount[_staker].sub(1), 0x03);\\n    }\\n\\n    function _increaseStakeCount(address _staker) internal {\\n        stakeCount[_staker] = stakeCount[_staker] + 1;\\n    }\\n\\n    function _increaseReferralCount(address _referrer) internal {\\n        referralCount[_referrer] = referralCount[_referrer] + 1;\\n    }\\n\\n    function _increaseLiquidityStakeCount(address _staker) internal {\\n        liquidityStakeCount[_staker] = liquidityStakeCount[_staker] + 1;\\n    }\\n\\n    function _isMatureStake(Stake memory _stake) internal view returns (bool) {\\n        return _stake.closeDay \\u003e 0\\n            ? _stake.finalDay \\u003c= _stake.closeDay\\n            : _stake.finalDay \\u003c= _currentWiseDay();\\n    }\\n\\n    function _notCriticalMassReferrer(address _referrer) internal view returns (bool) {\\n        return criticalMass[_referrer].activationDay == 0;\\n    }\\n\\n    function _stakeNotStarted(Stake memory _stake) internal view returns (bool) {\\n        return _stake.closeDay \\u003e 0\\n            ? _stake.startDay \\u003e _stake.closeDay\\n            : _stake.startDay \\u003e _currentWiseDay();\\n    }\\n\\n    function _stakeEnded(Stake memory _stake) internal view returns (bool) {\\n        return _stake.isActive == false || _isMatureStake(_stake);\\n    }\\n\\n    function _daysLeft(Stake memory _stake) internal view returns (uint256) {\\n        return _stake.isActive == false\\n            ? _daysDiff(_stake.closeDay, _stake.finalDay)\\n            : _daysDiff(_currentWiseDay(), _stake.finalDay);\\n    }\\n\\n    function _daysDiff(uint256 _startDate, uint256 _endDate) internal pure returns (uint256) {\\n        return _startDate \\u003e _endDate ? 0 : _endDate.sub(_startDate);\\n    }\\n\\n    function _calculationDay(Stake memory _stake) internal view returns (uint256) {\\n        return _stake.finalDay \\u003e globals.currentWiseDay ? globals.currentWiseDay : _stake.finalDay;\\n    }\\n\\n    function _startingDay(Stake memory _stake) internal pure returns (uint256) {\\n        return _stake.scrapeDay == 0 ? _stake.startDay : _stake.scrapeDay;\\n    }\\n\\n    function _notFuture(uint256 _day) internal view returns (bool) {\\n        return _day \\u003c= _currentWiseDay();\\n    }\\n\\n    function _notPast(uint256 _day) internal view returns (bool) {\\n        return _day \\u003e= _currentWiseDay();\\n    }\\n\\n    function _nonZeroAddress(address _address) internal pure returns (bool) {\\n        return _address != address(0x0);\\n    }\\n\\n    function _getLockDays(Stake memory _stake) internal pure returns (uint256) {\\n        return\\n            _stake.lockDays \\u003e 1 ?\\n            _stake.lockDays - 1 : 1;\\n    }\\n\\n    function _preparePath(\\n        address _tokenAddress,\\n        address _syntheticAddress,\\n        address _wiseAddress\\n    )\\n        internal\\n        pure\\n        returns (address[] memory _path)\\n    {\\n        _path = new address[](3);\\n        _path[0] = _tokenAddress;\\n        _path[1] = _syntheticAddress;\\n        _path[2] = _wiseAddress;\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                0xa9059cbb,\\n                to,\\n                value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool)))\\n            // \\u0027WISE: transfer failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                0x23b872dd,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool)))\\n            // \\u0027WISE: transferFrom failed\\u0027\\n        );\\n    }\\n}\\n\"},\"LiquidityToken.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nimport \\\"./StakingToken.sol\\\";\\n\\nabstract contract LiquidityToken is StakingToken {\\n\\n    using SafeMath for uint;\\n\\n    /**\\n     * @notice A method for a staker to create a liquidity stake\\n     * @param _liquidityTokens amount of UNI-WISE staked.\\n     */\\n    function createLiquidityStake(\\n        uint256 _liquidityTokens\\n    )\\n        snapshotTrigger\\n        external\\n        returns (bytes16 liquidityStakeID)\\n    {\\n        require(\\n            isLiquidityGuardActive == true\\n            // WISE: LiquidityGuard is not active\\n        );\\n\\n        safeTransferFrom(\\n            address(PANCAKE_PAIR),\\n            msg.sender,\\n            address(this),\\n            _liquidityTokens\\n        );\\n\\n        LiquidityStake memory newLiquidityStake;\\n\\n        liquidityStakeID = generateLiquidityStakeID(\\n            msg.sender\\n        );\\n\\n        newLiquidityStake.startDay = _nextWiseDay();\\n        newLiquidityStake.stakedAmount = _liquidityTokens;\\n        newLiquidityStake.isActive = true;\\n\\n        globals.liquidityShares =\\n        globals.liquidityShares.add(_liquidityTokens);\\n\\n        liquidityStakes[msg.sender][liquidityStakeID] = newLiquidityStake;\\n\\n        _increaseLiquidityStakeCount(\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice A method for a staker to end a liquidity stake\\n     * @param _liquidityStakeID - identification number\\n     */\\n    function endLiquidityStake(\\n        bytes16 _liquidityStakeID\\n    )\\n        snapshotTrigger\\n        external\\n        returns (uint256)\\n    {\\n        LiquidityStake memory liquidityStake =\\n        liquidityStakes[msg.sender][_liquidityStakeID];\\n\\n        require(\\n            liquidityStake.isActive\\n            // \\u0027WISE: not an active stake\\u0027\\n        );\\n\\n        liquidityStake.isActive = false;\\n        liquidityStake.closeDay = _currentWiseDay();\\n\\n        liquidityStake.rewardAmount = _calculateRewardAmount(\\n            liquidityStake\\n        );\\n\\n        _mint(\\n            msg.sender,\\n            liquidityStake.rewardAmount\\n        );\\n\\n        safeTransfer(\\n            address(PANCAKE_PAIR),\\n            msg.sender,\\n            liquidityStake.stakedAmount\\n        );\\n\\n        globals.liquidityShares =\\n        globals.liquidityShares.sub(liquidityStake.stakedAmount);\\n\\n        liquidityStakes[msg.sender][_liquidityStakeID] = liquidityStake;\\n\\n        return liquidityStake.rewardAmount;\\n    }\\n\\n    /**\\n     * @notice returns full view and details of\\n     * a liquidity stake belonging to caller\\n     * @param _liquidityStakeID - stakeID\\n     */\\n    function checkLiquidityStakeByID(\\n        address _staker,\\n        bytes16 _liquidityStakeID\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startDay,\\n            uint256 stakedAmount,\\n            uint256 rewardAmount,\\n            uint256 closeDay,\\n            bool isActive\\n        )\\n    {\\n        LiquidityStake memory stake = liquidityStakes[_staker][_liquidityStakeID];\\n        startDay = stake.startDay;\\n        stakedAmount = stake.stakedAmount;\\n        rewardAmount = _calculateRewardAmount(stake);\\n        closeDay = stake.closeDay;\\n        isActive = stake.isActive;\\n    }\\n\\n    /**\\n     * @notice calculates reward when closing liquidity stake\\n     * @param _liquidityStake - stake instance\\n     */\\n    function _calculateRewardAmount(\\n        LiquidityStake memory _liquidityStake\\n    )\\n        private\\n        view\\n        returns (uint256 _rewardAmount)\\n    {\\n        uint256 maxCalculationDay = _liquidityStake.startDay + MIN_REFERRAL_DAYS;\\n\\n        uint256 calculationDay =\\n            globals.currentWiseDay \\u003c maxCalculationDay ?\\n            globals.currentWiseDay : maxCalculationDay;\\n\\n        for (uint256 _day = _liquidityStake.startDay; _day \\u003c calculationDay; _day++) {\\n            _rewardAmount += _liquidityStake.stakedAmount * PRECISION_RATE / lsnapshots[_day].inflationAmount;\\n        }\\n    }\\n}\\n\"},\"ReferralToken.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./Snapshot.sol\\\";\\r\\n\\r\\nabstract contract ReferralToken is Snapshot {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function _addReferrerSharesToEnd(\\r\\n        uint256 _finalDay,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        referralSharesToEnd[_finalDay] =\\r\\n        referralSharesToEnd[_finalDay].add(_shares);\\r\\n    }\\r\\n\\r\\n    function _removeReferrerSharesToEnd(\\r\\n        uint256 _finalDay,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if (_notPast(_finalDay)) {\\r\\n\\r\\n            referralSharesToEnd[_finalDay] =\\r\\n            referralSharesToEnd[_finalDay] \\u003e _shares ?\\r\\n            referralSharesToEnd[_finalDay] - _shares : 0;\\r\\n\\r\\n        } else {\\r\\n\\r\\n            uint256 _day = _previousWiseDay();\\r\\n            rsnapshots[_day].scheduledToEnd =\\r\\n            rsnapshots[_day].scheduledToEnd \\u003e _shares ?\\r\\n            rsnapshots[_day].scheduledToEnd - _shares : 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _belowThresholdLevel(\\r\\n        address _referrer\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return criticalMass[_referrer].totalAmount \\u003c THRESHOLD_LIMIT;\\r\\n    }\\r\\n\\r\\n    function _addCriticalMass(\\r\\n        address _referrer,\\r\\n        uint256 _daiEquivalent\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        criticalMass[_referrer].totalAmount =\\r\\n        criticalMass[_referrer].totalAmount.add(_daiEquivalent);\\r\\n        criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\\r\\n    }\\r\\n\\r\\n    function _removeCriticalMass(\\r\\n        address _referrer,\\r\\n        uint256 _daiEquivalent,\\r\\n        uint256 _startDay\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if (\\r\\n            _notFuture(_startDay) == false \\u0026\\u0026\\r\\n            _nonZeroAddress(_referrer)\\r\\n        ) {\\r\\n            criticalMass[_referrer].totalAmount =\\r\\n            criticalMass[_referrer].totalAmount \\u003e _daiEquivalent ?\\r\\n            criticalMass[_referrer].totalAmount - _daiEquivalent : 0;\\r\\n            criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _determineActivationDay(\\r\\n        address _referrer\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _belowThresholdLevel(_referrer) ? 0 : _activationDay(_referrer);\\r\\n    }\\r\\n\\r\\n    function _activationDay(\\r\\n        address _referrer\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            criticalMass[_referrer].activationDay \\u003e 0 ?\\r\\n            criticalMass[_referrer].activationDay : _currentWiseDay();\\r\\n    }\\r\\n\\r\\n    function getBUSDEquivalent()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getBUSDEquivalent();\\r\\n    }\\r\\n\\r\\n    function _getBUSDEquivalent()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return BUSD_EQ.getBUSDEquivalent();\\r\\n    }\\r\\n\\r\\n    function referrerInterest(\\r\\n        bytes16 _referralID,\\r\\n        uint256 _scrapeDays\\r\\n    )\\r\\n        external\\r\\n        snapshotTrigger\\r\\n    {\\r\\n        _referrerInterest(\\r\\n            msg.sender,\\r\\n            _referralID,\\r\\n            _scrapeDays\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function referrerInterestBulk(\\r\\n        bytes16[] memory _referralIDs,\\r\\n        uint256[] memory _scrapeDays\\r\\n    )\\r\\n        external\\r\\n        snapshotTrigger\\r\\n    {\\r\\n        for(uint256 i = 0; i \\u003c _referralIDs.length; i++) {\\r\\n            _referrerInterest(\\r\\n                msg.sender,\\r\\n                _referralIDs[i],\\r\\n                _scrapeDays[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _referrerInterest(\\r\\n        address _referrer,\\r\\n        bytes16 _referralID,\\r\\n        uint256 _processDays\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        ReferrerLink memory link =\\r\\n        referrerLinks[_referrer][_referralID];\\r\\n\\r\\n        require(\\r\\n            link.isActive == true\\r\\n        );\\r\\n\\r\\n        address staker = link.staker;\\r\\n        bytes16 stakeID = link.stakeID;\\r\\n\\r\\n        Stake memory stake = stakes[staker][stakeID];\\r\\n\\r\\n        uint256 startDay = _determineStartDay(stake, link);\\r\\n        uint256 finalDay = _determineFinalDay(stake);\\r\\n\\r\\n        if (_stakeEnded(stake)) {\\r\\n\\r\\n            if (\\r\\n                _processDays \\u003e 0 \\u0026\\u0026\\r\\n                _processDays \\u003c _daysDiff(startDay, finalDay)\\r\\n                )\\r\\n            {\\r\\n\\r\\n                link.processedDays =\\r\\n                link.processedDays.add(_processDays);\\r\\n\\r\\n                finalDay =\\r\\n                startDay.add(_processDays);\\r\\n\\r\\n            } else {\\r\\n\\r\\n                link.isActive = false;\\r\\n            }\\r\\n\\r\\n        } else {\\r\\n\\r\\n            _processDays = _daysDiff(startDay, _currentWiseDay());\\r\\n\\r\\n            link.processedDays =\\r\\n            link.processedDays.add(_processDays);\\r\\n\\r\\n            finalDay =\\r\\n            startDay.add(_processDays);\\r\\n        }\\r\\n\\r\\n        uint256 referralInterest = _checkReferralInterest(\\r\\n            stake,\\r\\n            startDay,\\r\\n            finalDay\\r\\n        );\\r\\n\\r\\n        link.rewardAmount =\\r\\n        link.rewardAmount.add(referralInterest);\\r\\n\\r\\n        referrerLinks[_referrer][_referralID] = link;\\r\\n\\r\\n        _mint(\\r\\n            _referrer,\\r\\n            referralInterest\\r\\n        );\\r\\n\\r\\n        emit ReferralCollected(\\r\\n            staker,\\r\\n            stakeID,\\r\\n            _referrer,\\r\\n            _referralID,\\r\\n            referralInterest\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function checkReferralsByID(\\r\\n        address _referrer,\\r\\n        bytes16 _referralID\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address staker,\\r\\n            bytes16 stakeID,\\r\\n            uint256 referrerShares,\\r\\n            uint256 referralInterest,\\r\\n            bool isActiveReferral,\\r\\n            bool isActiveStake,\\r\\n            bool isMatureStake,\\r\\n            bool isEndedStake\\r\\n        )\\r\\n    {\\r\\n        ReferrerLink memory link = referrerLinks[_referrer][_referralID];\\r\\n\\r\\n        staker = link.staker;\\r\\n        stakeID = link.stakeID;\\r\\n        isActiveReferral = link.isActive;\\r\\n\\r\\n        Stake memory stake = stakes[staker][stakeID];\\r\\n        referrerShares = stake.referrerShares;\\r\\n\\r\\n        referralInterest = _checkReferralInterest(\\r\\n            stake,\\r\\n            _determineStartDay(stake, link),\\r\\n            _determineFinalDay(stake)\\r\\n        );\\r\\n\\r\\n        isActiveStake = stake.isActive;\\r\\n        isEndedStake = _stakeEnded(stake);\\r\\n        isMatureStake = _isMatureStake(stake);\\r\\n    }\\r\\n\\r\\n    function _checkReferralInterest(Stake memory _stake, uint256 _startDay, uint256 _finalDay) internal view returns (uint256 _referralInterest) {\\r\\n        return _notCriticalMassReferrer(_stake.referrer) ? 0 : _getReferralInterest(_stake, _startDay, _finalDay);\\r\\n    }\\r\\n\\r\\n    function _getReferralInterest(Stake memory _stake, uint256 _startDay, uint256 _finalDay) private view returns (uint256 _referralInterest) {\\r\\n        for (uint256 _day = _startDay; _day \\u003c _finalDay; _day++) {\\r\\n            _referralInterest += _stake.stakesShares * PRECISION_RATE / rsnapshots[_day].inflationAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _determineStartDay(Stake memory _stake, ReferrerLink memory _link) internal view returns (uint256) {\\r\\n        return (\\r\\n            criticalMass[_stake.referrer].activationDay \\u003e _stake.startDay ?\\r\\n            criticalMass[_stake.referrer].activationDay : _stake.startDay\\r\\n        ).add(_link.processedDays);\\r\\n    }\\r\\n\\r\\n    function _determineFinalDay(\\r\\n        Stake memory _stake\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            _stake.closeDay \\u003e 0 ?\\r\\n            _stake.closeDay : _calculationDay(_stake);\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"},\"Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nimport \\\"./Helper.sol\\\";\\n\\nabstract contract Snapshot is Helper {\\n\\n    using SafeMath for uint;\\n\\n    // regular shares\\n    struct SnapShot {\\n        uint256 totalShares;\\n        uint256 inflationAmount;\\n        uint256 scheduledToEnd;\\n    }\\n\\n    // referral shares\\n    struct rSnapShot {\\n        uint256 totalShares;\\n        uint256 inflationAmount;\\n        uint256 scheduledToEnd;\\n    }\\n\\n    // liquidity shares\\n    struct lSnapShot {\\n        uint256 totalShares;\\n        uint256 inflationAmount;\\n    }\\n\\n    mapping(uint256 =\\u003e SnapShot) public snapshots;\\n    mapping(uint256 =\\u003e rSnapShot) public rsnapshots;\\n    mapping(uint256 =\\u003e lSnapShot) public lsnapshots;\\n\\n    modifier snapshotTrigger() {\\n        _dailySnapshotPoint(_currentWiseDay());\\n        _;\\n    }\\n\\n    /**\\n     * @notice allows to activate/deactivate\\n     * liquidity guard manually based on the\\n     * liquidity in PANCAKE pair contract\\n     */\\n    function liquidityGuardTrigger() public {\\n\\n        (\\n            uint112 reserveA,\\n            uint112 reserveB,\\n            uint32 blockTimestampLast\\n        ) = PANCAKE_PAIR.getReserves();\\n\\n        emit PancakeSwapReserves(\\n            reserveA,\\n            reserveB,\\n            blockTimestampLast\\n        );\\n\\n        uint256 onPancake = PANCAKE_PAIR.token1() == address(SBNB)\\n            ? reserveA\\n            : reserveB;\\n\\n        uint256 ratio = totalSupply() == 0\\n            ? 0\\n            : onPancake\\n                .mul(200)\\n                .div(totalSupply());\\n\\n        if (ratio \\u003c 40 \\u0026\\u0026 isLiquidityGuardActive == false) enableLiquidityGuard();\\n        if (ratio \\u003e 60 \\u0026\\u0026 isLiquidityGuardActive == true) disableLiquidityGuard();\\n\\n        emit LiquidityGuardStatus(\\n            isLiquidityGuardActive\\n        );\\n    }\\n\\n    function enableLiquidityGuard() private {\\n        isLiquidityGuardActive = true;\\n    }\\n\\n    function disableLiquidityGuard() private {\\n        isLiquidityGuardActive = false;\\n    }\\n\\n    /**\\n     * @notice allows volunteer to offload snapshots\\n     * to save on gas during next start/end stake\\n     */\\n    function manualDailySnapshot()\\n        external\\n    {\\n        _dailySnapshotPoint(_currentWiseDay());\\n    }\\n\\n    /**\\n     * @notice allows volunteer to offload snapshots\\n     * to save on gas during next start/end stake\\n     * in case manualDailySnapshot reach block limit\\n     */\\n    function manualDailySnapshotPoint(\\n        uint64 _updateDay\\n    )\\n        external\\n    {\\n        require(\\n            _updateDay \\u003e 0 \\u0026\\u0026\\n            _updateDay \\u003c _currentWiseDay()\\n            // \\u0027WISE: snapshot day does not exist yet\\u0027\\n        );\\n\\n        require(\\n            _updateDay \\u003e globals.currentWiseDay\\n            // \\u0027WISE: snapshot already taken for that day\\u0027\\n        );\\n\\n        _dailySnapshotPoint(_updateDay);\\n    }\\n\\n    /**\\n     * @notice internal function that offloads\\n     * global values to daily snapshots\\n     * updates globals.currentWiseDay\\n     */\\n    function _dailySnapshotPoint(\\n        uint64 _updateDay\\n    )\\n        private\\n    {\\n        liquidityGuardTrigger();\\n\\n        uint256 scheduledToEndToday;\\n        uint256 totalStakedToday = globals.totalStaked;\\n\\n        for (uint256 _day = globals.currentWiseDay; _day \\u003c _updateDay; _day++) {\\n\\n            // ------------------------------------\\n            // prepare snapshot for regular shares\\n            // reusing scheduledToEndToday variable\\n\\n            scheduledToEndToday = scheduledToEnd[_day] + snapshots[_day - 1].scheduledToEnd;\\n\\n            SnapShot memory snapshot = snapshots[_day];\\n            snapshot.scheduledToEnd = scheduledToEndToday;\\n\\n            snapshot.totalShares =\\n                globals.totalShares \\u003e scheduledToEndToday ?\\n                globals.totalShares - scheduledToEndToday : 0;\\n\\n            snapshot.inflationAmount =  snapshot.totalShares\\n                .mul(PRECISION_RATE)\\n                .div(\\n                    _inflationAmount(\\n                        totalStakedToday,\\n                        totalSupply(),\\n                        totalPenalties[_day],\\n                        LIQUIDITY_GUARD.getInflation(\\n                            INFLATION_RATE\\n                        )\\n                    )\\n                );\\n\\n            // store regular snapshot\\n            snapshots[_day] = snapshot;\\n\\n\\n            // ------------------------------------\\n            // prepare snapshot for referrer shares\\n            // reusing scheduledToEndToday variable\\n\\n            scheduledToEndToday = referralSharesToEnd[_day] + rsnapshots[_day - 1].scheduledToEnd;\\n\\n            rSnapShot memory rsnapshot = rsnapshots[_day];\\n            rsnapshot.scheduledToEnd = scheduledToEndToday;\\n\\n            rsnapshot.totalShares =\\n                globals.referralShares \\u003e scheduledToEndToday ?\\n                globals.referralShares - scheduledToEndToday : 0;\\n\\n            rsnapshot.inflationAmount = rsnapshot.totalShares\\n                .mul(PRECISION_RATE)\\n                .div(\\n                    _referralInflation(\\n                        totalStakedToday,\\n                        totalSupply()\\n                    )\\n                );\\n\\n            // store referral snapshot\\n            rsnapshots[_day] = rsnapshot;\\n\\n\\n            // ------------------------------------\\n            // prepare snapshot for liquidity shares\\n            // reusing scheduledToEndToday variable\\n\\n            lSnapShot memory lsnapshot = lsnapshots[_day];\\n            lsnapshot.totalShares = globals.liquidityShares;\\n\\n            lsnapshot.inflationAmount = lsnapshot.totalShares\\n                .mul(PRECISION_RATE).div(\\n                    _liquidityInflation(\\n                        totalStakedToday,\\n                        totalSupply(),\\n                        LIQUIDITY_GUARD.getInflation(\\n                            LIQUIDITY_RATE\\n                        )\\n                    )\\n                );\\n\\n            // store liquidity snapshot\\n            lsnapshots[_day] = lsnapshot;\\n\\n            adjustLiquidityRates();\\n            globals.currentWiseDay++;\\n        }\\n    }\\n\\n    /**\\n     * @notice moves inflation up and down by 0.006%\\n     * from regular shares to liquidity shares\\n     * if the liquidityGuard is active (visa-versa)\\n     */\\n    function adjustLiquidityRates() private {\\n        if (\\n            isLiquidityGuardActive ==  true \\u0026\\u0026\\n            LIQUIDITY_RATE \\u003c INFLATION_RATE_MAX\\n            )\\n        {\\n            LIQUIDITY_RATE = LIQUIDITY_RATE + 6;\\n            INFLATION_RATE = INFLATION_RATE - 6;\\n            return;\\n        }\\n        if (\\n            isLiquidityGuardActive == false \\u0026\\u0026\\n            INFLATION_RATE \\u003c INFLATION_RATE_MAX\\n            )\\n        {\\n            INFLATION_RATE = INFLATION_RATE + 6;\\n            LIQUIDITY_RATE = LIQUIDITY_RATE - 6;\\n            return;\\n        }\\n    }\\n\\n    function _inflationAmount(uint256 _totalStaked, uint256 _totalSupply, uint256 _totalPenalties, uint256 _INFLATION_RATE) private pure returns (uint256) {\\n        return (_totalStaked + _totalSupply) * 10000 / _INFLATION_RATE + _totalPenalties;\\n    }\\n\\n    function _referralInflation(uint256 _totalStaked, uint256 _totalSupply) private pure returns (uint256) {\\n        return (_totalStaked + _totalSupply) * 10000 / REFERRALS_RATE;\\n    }\\n\\n    function _liquidityInflation(uint256 _totalStaked, uint256 _totalSupply, uint256 _LIQUIDITY_RATE) private pure returns (uint256) {\\n        return (_totalStaked + _totalSupply) * 10000 / _LIQUIDITY_RATE;\\n    }\\n}\\n\"},\"StakingToken.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./ReferralToken.sol\\\";\\r\\n\\r\\nabstract contract StakingToken is ReferralToken {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @notice A method for a staker to create multiple stakes\\r\\n     * @param _stakedAmount amount of WISE staked.\\r\\n     * @param _lockDays amount of days it is locked for.\\r\\n     * @param _referrer address of the referrer\\r\\n     */\\r\\n    function createStakeBulk(\\r\\n        uint256[] memory _stakedAmount,\\r\\n        uint64[] memory _lockDays,\\r\\n        address[] memory _referrer\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        for(uint256 i = 0; i \\u003c _stakedAmount.length; i++) {\\r\\n            createStake(\\r\\n                _stakedAmount[i],\\r\\n                _lockDays[i],\\r\\n                _referrer[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A method for a staker to create a stake\\r\\n     * @param _stakedAmount amount of WISE staked.\\r\\n     * @param _lockDays amount of days it is locked for.\\r\\n     * @param _referrer address of the referrer\\r\\n     */\\r\\n    function createStake(\\r\\n        uint256 _stakedAmount,\\r\\n        uint64 _lockDays,\\r\\n        address _referrer\\r\\n    )\\r\\n        snapshotTrigger\\r\\n        public\\r\\n        returns (bytes16, uint256, bytes16 referralID)\\r\\n    {\\r\\n        require(\\r\\n            msg.sender != _referrer \\u0026\\u0026\\r\\n            notContract(_referrer)\\r\\n            // \\u0027WISE: invalid referrer\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            _lockDays \\u003e= MIN_LOCK_DAYS \\u0026\\u0026\\r\\n            _lockDays \\u003c= MAX_LOCK_DAYS\\r\\n            // \\u0027WISE: stake is not in range\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            _stakedAmount \\u003e= MIN_STAKE_AMOUNT\\r\\n            // \\u0027WISE: stake is not large enough\\u0027\\r\\n        );\\r\\n\\r\\n        (\\r\\n            Stake memory newStake,\\r\\n            bytes16 stakeID,\\r\\n            uint256 _startDay\\r\\n        ) =\\r\\n\\r\\n        _createStake(msg.sender, _stakedAmount, _lockDays, _referrer);\\r\\n\\r\\n        if (newStake.referrerShares \\u003e 0) {\\r\\n\\r\\n            ReferrerLink memory referrerLink;\\r\\n\\r\\n            referrerLink.staker = msg.sender;\\r\\n            referrerLink.stakeID = stakeID;\\r\\n            referrerLink.isActive = true;\\r\\n\\r\\n            referralID = generateReferralID(_referrer);\\r\\n            referrerLinks[_referrer][referralID] = referrerLink;\\r\\n\\r\\n            _increaseReferralCount(\\r\\n                _referrer\\r\\n            );\\r\\n\\r\\n            _addReferrerSharesToEnd(\\r\\n                newStake.finalDay,\\r\\n                newStake.referrerShares\\r\\n            );\\r\\n        }\\r\\n\\r\\n        stakes[msg.sender][stakeID] = newStake;\\r\\n\\r\\n        _increaseStakeCount(\\r\\n            msg.sender\\r\\n        );\\r\\n\\r\\n        _increaseGlobals(\\r\\n            newStake.stakedAmount,\\r\\n            newStake.stakesShares,\\r\\n            newStake.referrerShares\\r\\n        );\\r\\n\\r\\n        _addScheduledShares(\\r\\n            newStake.finalDay,\\r\\n            newStake.stakesShares\\r\\n        );\\r\\n\\r\\n        emit StakeStart(\\r\\n            stakeID,\\r\\n            msg.sender,\\r\\n            _referrer,\\r\\n            newStake.stakedAmount,\\r\\n            newStake.stakesShares,\\r\\n            newStake.referrerShares,\\r\\n            newStake.startDay,\\r\\n            newStake.lockDays,\\r\\n            newStake.daiEquivalent\\r\\n        );\\r\\n\\r\\n        return (stakeID, _startDay, referralID);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice A method for a staker to start a stake\\r\\n    * @param _staker ...\\r\\n    * @param _stakedAmount ...\\r\\n    * @param _lockDays ...\\r\\n    */\\r\\n    function _createStake(\\r\\n        address _staker,\\r\\n        uint256 _stakedAmount,\\r\\n        uint64 _lockDays,\\r\\n        address _referrer\\r\\n    )\\r\\n        private\\r\\n        returns (\\r\\n            Stake memory _newStake,\\r\\n            bytes16 _stakeID,\\r\\n            uint64 _startDay\\r\\n        )\\r\\n    {\\r\\n        _burn(\\r\\n            _staker,\\r\\n            _stakedAmount\\r\\n        );\\r\\n\\r\\n        _startDay = _nextWiseDay();\\r\\n        _stakeID = generateStakeID(_staker);\\r\\n\\r\\n        _newStake.lockDays = _lockDays;\\r\\n        _newStake.startDay = _startDay;\\r\\n        _newStake.finalDay = _startDay + _lockDays;\\r\\n        _newStake.isActive = true;\\r\\n\\r\\n        _newStake.stakedAmount = _stakedAmount;\\r\\n        _newStake.stakesShares = _stakesShares(\\r\\n            _stakedAmount,\\r\\n            _lockDays,\\r\\n            _referrer,\\r\\n            globals.sharePrice\\r\\n        );\\r\\n\\r\\n        _newStake.daiEquivalent = _getBUSDEquivalent()\\r\\n            .mul(_newStake.stakedAmount)\\r\\n            .div(YODAS_PER_WISE);\\r\\n\\r\\n        if (_nonZeroAddress(_referrer)) {\\r\\n\\r\\n            _newStake.referrer = _referrer;\\r\\n\\r\\n            _addCriticalMass(\\r\\n                _newStake.referrer,\\r\\n                _newStake.daiEquivalent\\r\\n            );\\r\\n\\r\\n            _newStake.referrerShares = _referrerShares(\\r\\n                _stakedAmount,\\r\\n                _lockDays,\\r\\n                _referrer\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice A method for a staker to remove a stake\\r\\n    * belonging to his address by providing ID of a stake.\\r\\n    * @param _stakeID unique bytes sequence reference to the stake\\r\\n    */\\r\\n    function endStake(\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        snapshotTrigger\\r\\n        external\\r\\n        returns (uint256)\\r\\n    {\\r\\n        (\\r\\n            Stake memory endedStake,\\r\\n            uint256 penaltyAmount\\r\\n        ) =\\r\\n\\r\\n        _endStake(\\r\\n            msg.sender,\\r\\n            _stakeID\\r\\n        );\\r\\n\\r\\n        _decreaseGlobals(\\r\\n            endedStake.stakedAmount,\\r\\n            endedStake.stakesShares,\\r\\n            endedStake.referrerShares\\r\\n        );\\r\\n\\r\\n        _removeScheduledShares(\\r\\n            endedStake.finalDay,\\r\\n            endedStake.stakesShares\\r\\n        );\\r\\n\\r\\n        _removeReferrerSharesToEnd(\\r\\n            endedStake.finalDay,\\r\\n            endedStake.referrerShares\\r\\n        );\\r\\n\\r\\n        _removeCriticalMass(\\r\\n            endedStake.referrer,\\r\\n            endedStake.daiEquivalent,\\r\\n            endedStake.startDay\\r\\n        );\\r\\n\\r\\n        _storePenalty(\\r\\n            endedStake.closeDay,\\r\\n            penaltyAmount\\r\\n        );\\r\\n\\r\\n        _sharePriceUpdate(\\r\\n            endedStake.stakedAmount \\u003e penaltyAmount ?\\r\\n            endedStake.stakedAmount - penaltyAmount : 0,\\r\\n            endedStake.rewardAmount + scrapes[msg.sender][_stakeID],\\r\\n            endedStake.referrer,\\r\\n            endedStake.lockDays,\\r\\n            endedStake.stakesShares\\r\\n        );\\r\\n\\r\\n        emit StakeEnd(\\r\\n            _stakeID,\\r\\n            msg.sender,\\r\\n            endedStake.referrer,\\r\\n            endedStake.stakedAmount,\\r\\n            endedStake.stakesShares,\\r\\n            endedStake.referrerShares,\\r\\n            endedStake.rewardAmount,\\r\\n            endedStake.closeDay,\\r\\n            penaltyAmount\\r\\n        );\\r\\n\\r\\n        return endedStake.rewardAmount;\\r\\n    }\\r\\n\\r\\n    function _endStake(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        private\\r\\n        returns (\\r\\n            Stake storage _stake,\\r\\n            uint256 _penalty\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            stakes[_staker][_stakeID].isActive\\r\\n            // \\u0027WISE: not an active stake\\u0027\\r\\n        );\\r\\n\\r\\n        _stake = stakes[_staker][_stakeID];\\r\\n        _stake.closeDay = _currentWiseDay();\\r\\n        _stake.rewardAmount = _calculateRewardAmount(_stake);\\r\\n        _penalty = _calculatePenaltyAmount(_stake);\\r\\n\\r\\n        _stake.isActive = false;\\r\\n\\r\\n        _mint(\\r\\n            _staker,\\r\\n            _stake.stakedAmount \\u003e _penalty ?\\r\\n            _stake.stakedAmount - _penalty : 0\\r\\n        );\\r\\n\\r\\n        _mint(\\r\\n            _staker,\\r\\n            _stake.rewardAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice alloes to scrape interest from active stake\\r\\n    * @param _stakeID unique bytes sequence reference to the stake\\r\\n    * @param _scrapeDays amount of days to proccess, 0 = all\\r\\n    */\\r\\n    function scrapeInterest(\\r\\n        bytes16 _stakeID,\\r\\n        uint64 _scrapeDays\\r\\n    )\\r\\n        external\\r\\n        snapshotTrigger\\r\\n        returns (\\r\\n            uint256 scrapeDay,\\r\\n            uint256 scrapeAmount,\\r\\n            uint256 remainingDays,\\r\\n            uint256 stakersPenalty,\\r\\n            uint256 referrerPenalty\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            stakes[msg.sender][_stakeID].isActive\\r\\n            // \\u0027WISE: not an active stake\\u0027\\r\\n        );\\r\\n\\r\\n        Stake memory stake = stakes[msg.sender][_stakeID];\\r\\n\\r\\n        scrapeDay = _scrapeDays \\u003e 0\\r\\n            ? _startingDay(stake).add(_scrapeDays)\\r\\n            : _calculationDay(stake);\\r\\n\\r\\n        scrapeDay = scrapeDay \\u003e stake.finalDay\\r\\n            ? _calculationDay(stake)\\r\\n            : scrapeDay;\\r\\n\\r\\n        scrapeAmount = _loopRewardAmount(\\r\\n            stake.stakesShares,\\r\\n            _startingDay(stake),\\r\\n            scrapeDay\\r\\n        );\\r\\n\\r\\n        if (_isMatureStake(stake) == false) {\\r\\n\\r\\n            remainingDays = _daysLeft(stake);\\r\\n\\r\\n            stakersPenalty = _stakesShares(\\r\\n                scrapeAmount,\\r\\n                remainingDays,\\r\\n                msg.sender,\\r\\n                globals.sharePrice\\r\\n            );\\r\\n\\r\\n            stake.stakesShares =\\r\\n            stake.stakesShares.sub(stakersPenalty);\\r\\n\\r\\n            _removeScheduledShares(\\r\\n                stake.finalDay,\\r\\n                stakersPenalty\\r\\n            );\\r\\n\\r\\n            if (stake.referrerShares \\u003e 0) {\\r\\n\\r\\n                referrerPenalty = _stakesShares(\\r\\n                    scrapeAmount,\\r\\n                    remainingDays,\\r\\n                    address(0x0),\\r\\n                    globals.sharePrice\\r\\n                );\\r\\n\\r\\n                stake.referrerShares =\\r\\n                stake.referrerShares.sub(referrerPenalty);\\r\\n\\r\\n                _removeReferrerSharesToEnd(\\r\\n                    stake.finalDay,\\r\\n                    referrerPenalty\\r\\n                );\\r\\n            }\\r\\n\\r\\n            _decreaseGlobals(\\r\\n                0,\\r\\n                stakersPenalty,\\r\\n                referrerPenalty\\r\\n            );\\r\\n\\r\\n            _sharePriceUpdate(\\r\\n                stake.stakedAmount,\\r\\n                scrapeAmount,\\r\\n                stake.referrer,\\r\\n                stake.lockDays,\\r\\n                stake.stakesShares\\r\\n            );\\r\\n        }\\r\\n        else {\\r\\n            scrapes[msg.sender][_stakeID] =\\r\\n            scrapes[msg.sender][_stakeID].add(scrapeAmount);\\r\\n\\r\\n            _sharePriceUpdate(\\r\\n                stake.stakedAmount,\\r\\n                scrapes[msg.sender][_stakeID],\\r\\n                stake.referrer,\\r\\n                stake.lockDays,\\r\\n                stake.stakesShares\\r\\n            );\\r\\n        }\\r\\n\\r\\n        stake.scrapeDay = scrapeDay;\\r\\n        stakes[msg.sender][_stakeID] = stake;\\r\\n\\r\\n        _mint(\\r\\n            msg.sender,\\r\\n            scrapeAmount\\r\\n        );\\r\\n\\r\\n        emit InterestScraped(\\r\\n            _stakeID,\\r\\n            msg.sender,\\r\\n            scrapeAmount,\\r\\n            scrapeDay,\\r\\n            stakersPenalty,\\r\\n            referrerPenalty,\\r\\n            _currentWiseDay()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _addScheduledShares(\\r\\n        uint256 _finalDay,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        scheduledToEnd[_finalDay] =\\r\\n        scheduledToEnd[_finalDay].add(_shares);\\r\\n    }\\r\\n\\r\\n    function _removeScheduledShares(\\r\\n        uint256 _finalDay,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if (_notPast(_finalDay)) {\\r\\n\\r\\n            scheduledToEnd[_finalDay] =\\r\\n            scheduledToEnd[_finalDay] \\u003e _shares ?\\r\\n            scheduledToEnd[_finalDay] - _shares : 0;\\r\\n\\r\\n        } else {\\r\\n\\r\\n            uint256 _day = _previousWiseDay();\\r\\n            snapshots[_day].scheduledToEnd =\\r\\n            snapshots[_day].scheduledToEnd \\u003e _shares ?\\r\\n            snapshots[_day].scheduledToEnd - _shares : 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sharePriceUpdate(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _rewardAmount,\\r\\n        address _referrer,\\r\\n        uint256 _lockDays,\\r\\n        uint256 _stakeShares\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n        if (_stakeShares \\u003e 0 \\u0026\\u0026 _currentWiseDay() \\u003e FORMULA_DAY) {\\r\\n\\r\\n            uint256 newSharePrice = _getNewSharePrice(\\r\\n                _stakedAmount,\\r\\n                _rewardAmount,\\r\\n                _stakeShares,\\r\\n                _lockDays,\\r\\n                _referrer\\r\\n            );\\r\\n\\r\\n            if (newSharePrice \\u003e globals.sharePrice) {\\r\\n\\r\\n                newSharePrice =\\r\\n                    newSharePrice \\u003c globals.sharePrice.mul(110).div(100) ?\\r\\n                    newSharePrice : globals.sharePrice.mul(110).div(100);\\r\\n\\r\\n                emit NewSharePrice(\\r\\n                    newSharePrice,\\r\\n                    globals.sharePrice,\\r\\n                    _currentWiseDay()\\r\\n                );\\r\\n\\r\\n                globals.sharePrice = newSharePrice;\\r\\n            }\\r\\n\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (_currentWiseDay() == FORMULA_DAY) {\\r\\n            globals.sharePrice = 110E15;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getNewSharePrice(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _rewardAmount,\\r\\n        uint256 _stakeShares,\\r\\n        uint256 _lockDays,\\r\\n        address _referrer\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n\\r\\n        uint256 _bonusAmount = _getBonus(\\r\\n            _lockDays, _nonZeroAddress(_referrer) ? 11E9 : 10E9\\r\\n        );\\r\\n\\r\\n        return\\r\\n            _stakedAmount\\r\\n                .add(_rewardAmount)\\r\\n                .mul(_bonusAmount)\\r\\n                .mul(1E8)\\r\\n                .div(_stakeShares);\\r\\n    }\\r\\n\\r\\n    function checkMatureStake(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (bool isMature)\\r\\n    {\\r\\n        Stake memory stake = stakes[_staker][_stakeID];\\r\\n        isMature = _isMatureStake(stake);\\r\\n    }\\r\\n\\r\\n    function checkStakeByID(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 startDay,\\r\\n            uint256 lockDays,\\r\\n            uint256 finalDay,\\r\\n            uint256 closeDay,\\r\\n            uint256 scrapeDay,\\r\\n            uint256 stakedAmount,\\r\\n            uint256 stakesShares,\\r\\n            uint256 rewardAmount,\\r\\n            uint256 penaltyAmount,\\r\\n            bool isActive,\\r\\n            bool isMature\\r\\n        )\\r\\n    {\\r\\n        Stake memory stake = stakes[_staker][_stakeID];\\r\\n        startDay = stake.startDay;\\r\\n        lockDays = stake.lockDays;\\r\\n        finalDay = stake.finalDay;\\r\\n        closeDay = stake.closeDay;\\r\\n        scrapeDay = stake.scrapeDay;\\r\\n        stakedAmount = stake.stakedAmount;\\r\\n        stakesShares = stake.stakesShares;\\r\\n        rewardAmount = _checkRewardAmount(stake);\\r\\n        penaltyAmount = _calculatePenaltyAmount(stake);\\r\\n        isActive = stake.isActive;\\r\\n        isMature = _isMatureStake(stake);\\r\\n    }\\r\\n\\r\\n    function _stakesShares(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _lockDays,\\r\\n        address _referrer,\\r\\n        uint256 _sharePrice\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _nonZeroAddress(_referrer)\\r\\n            ? _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 11E9)\\r\\n            : _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 10E9);\\r\\n    }\\r\\n\\r\\n    function _sharesAmount(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _lockDays,\\r\\n        uint256 _sharePrice,\\r\\n        uint256 _extraBonus\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _baseAmount(_stakedAmount, _sharePrice)\\r\\n            .mul(_getBonus(_lockDays, _extraBonus))\\r\\n            .div(10E9);\\r\\n    }\\r\\n\\r\\n    function _getBonus(\\r\\n        uint256 _lockDays,\\r\\n        uint256 _extraBonus\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            _regularBonus(_lockDays, DAILY_BONUS_A, MAX_BONUS_DAYS_A) +\\r\\n            _regularBonus(\\r\\n                _lockDays \\u003e MAX_BONUS_DAYS_A ?\\r\\n                _lockDays - MAX_BONUS_DAYS_A : 0, DAILY_BONUS_B, MAX_BONUS_DAYS_B\\r\\n            ) + _extraBonus;\\r\\n    }\\r\\n\\r\\n    function _regularBonus(\\r\\n        uint256 _lockDays,\\r\\n        uint256 _daily,\\r\\n        uint256 _maxDays\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (\\r\\n            _lockDays \\u003e _maxDays\\r\\n                ? _maxDays.mul(_daily)\\r\\n                : _lockDays.mul(_daily)\\r\\n            ).div(10E9);\\r\\n    }\\r\\n\\r\\n    function _baseAmount(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _sharePrice\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            _stakedAmount\\r\\n                .mul(PRECISION_RATE)\\r\\n                .div(_sharePrice);\\r\\n    }\\r\\n\\r\\n    function _referrerShares(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _lockDays,\\r\\n        address _referrer\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            _notCriticalMassReferrer(_referrer) ||\\r\\n            _lockDays \\u003c MIN_REFERRAL_DAYS\\r\\n                ? 0\\r\\n                : _sharesAmount(\\r\\n                    _stakedAmount,\\r\\n                    _lockDays,\\r\\n                    globals.sharePrice,\\r\\n                    10E9\\r\\n                );\\r\\n    }\\r\\n\\r\\n    function _checkRewardAmount(Stake memory _stake) private view returns (uint256) {\\r\\n        return _stake.isActive ? _detectReward(_stake) : _stake.rewardAmount;\\r\\n    }\\r\\n\\r\\n    function _detectReward(Stake memory _stake) private view returns (uint256) {\\r\\n        return _stakeNotStarted(_stake) ? 0 : _calculateRewardAmount(_stake);\\r\\n    }\\r\\n\\r\\n    function _storePenalty(\\r\\n        uint64 _storeDay,\\r\\n        uint256 _penalty\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n        if (_penalty \\u003e 0) {\\r\\n            totalPenalties[_storeDay] =\\r\\n            totalPenalties[_storeDay].add(_penalty);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calculatePenaltyAmount(\\r\\n        Stake memory _stake\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _stakeNotStarted(_stake) || _isMatureStake(_stake) ? 0 : _getPenalties(_stake);\\r\\n    }\\r\\n\\r\\n    function _getPenalties(Stake memory _stake)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _stake.stakedAmount * (100 + (800 * (_daysLeft(_stake) - 1) / (_getLockDays(_stake)))) / 1000;\\r\\n    }\\r\\n\\r\\n    function _calculateRewardAmount(\\r\\n        Stake memory _stake\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _loopRewardAmount(\\r\\n            _stake.stakesShares,\\r\\n            _startingDay(_stake),\\r\\n            _calculationDay(_stake)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _loopRewardAmount(\\r\\n        uint256 _stakeShares,\\r\\n        uint256 _startDay,\\r\\n        uint256 _finalDay\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 _rewardAmount)\\r\\n    {\\r\\n        for (uint256 _day = _startDay; _day \\u003c _finalDay; _day++) {\\r\\n            _rewardAmount += _stakeShares * PRECISION_RATE / snapshots[_day].inflationAmount;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"Timing.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\n\\npragma solidity =0.7.5;\\n\\nimport \\\"./Declaration.sol\\\";\\n\\nabstract contract Timing is Declaration {\\n\\n    function currentWiseDay() public view returns (uint64) {\\n        return _getNow() \\u003e= LAUNCH_TIME ? _currentWiseDay() : 0;\\n    }\\n\\n    function _currentWiseDay() internal view returns (uint64) {\\n        return _wiseDayFromStamp(_getNow());\\n    }\\n\\n    function _nextWiseDay() internal view returns (uint64) {\\n        return _currentWiseDay() + 1;\\n    }\\n\\n    function _previousWiseDay() internal view returns (uint64) {\\n        return _currentWiseDay() - 1;\\n    }\\n\\n    function _wiseDayFromStamp(uint256 _timestamp) internal view returns (uint64) {\\n        return uint64((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\\n    }\\n\\n    function _getNow() internal view returns (uint256) {\\n        return block.timestamp;\\n    }\\n}\\n\"},\"WiseToken.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\udd89 % \ud83e\udd5e --\\r\\n\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"./LiquidityToken.sol\\\";\\r\\n\\r\\ncontract WiseToken is LiquidityToken {\\r\\n\\r\\n    address public LIQUIDITY_TRANSFORMER;\\r\\n    address public transformerGateKeeper;\\r\\n\\r\\n    constructor(\\r\\n        address _syntheticBNBAddress\\r\\n    ) BEP20(\\r\\n        \\\"Wise Token\\\",\\r\\n        \\\"WISB\\\"\\r\\n    )\\r\\n        payable\\r\\n    {\\r\\n        SBNB = ISyntheticBNB(\\r\\n            _syntheticBNBAddress\\r\\n        );\\r\\n\\r\\n        transformerGateKeeper = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyKeeper() {\\r\\n        require(\\r\\n            transformerGateKeeper == msg.sender\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n    function setLiquidityTransfomer(\\r\\n        address _immutableTransformer\\r\\n    )\\r\\n        external\\r\\n        onlyKeeper\\r\\n    {\\r\\n        LIQUIDITY_TRANSFORMER =\\r\\n        _immutableTransformer;\\r\\n    }\\r\\n\\r\\n    function setBUSD(\\r\\n        address _equalizerAddress\\r\\n    )\\r\\n        external\\r\\n        onlyKeeper\\r\\n    {\\r\\n        BUSD_EQ = IBUSDEquivalent(\\r\\n            _equalizerAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function renounceKeeper()\\r\\n        external\\r\\n        onlyKeeper\\r\\n    {\\r\\n        transformerGateKeeper = address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows liquidityTransformer to mint supply\\r\\n     * @dev executed from liquidityTransformer upon PANCAKESWAP transfer\\r\\n     * and during reservation payout to contributors and referrers\\r\\n     * @param _investorAddress address for minting WISE tokens\\r\\n     * @param _amount of tokens to mint for _investorAddress\\r\\n     */\\r\\n    function mintSupply(\\r\\n        address _investorAddress,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == LIQUIDITY_TRANSFORMER\\r\\n        );\\r\\n\\r\\n        _mint(\\r\\n            _investorAddress,\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows to create stake directly with BNB\\r\\n     * if you don\\u0027t have WISE tokens method will wrap\\r\\n     * your BNB to SBNB and use that amount on PANCAKESWAP\\r\\n     * returned amount of WISE tokens will be used to stake\\r\\n     * @param _lockDays amount of days it is locked for.\\r\\n     * @param _referrer referrer address for +10% bonus\\r\\n     */\\r\\n    function createStakeWithBNB(\\r\\n        uint64 _lockDays,\\r\\n        address _referrer\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (bytes16, uint256, bytes16 referralID)\\r\\n    {\\r\\n        address[] memory path = new address[](3);\\r\\n            path[0] = WBNB;\\r\\n            path[1] = address(SBNB);\\r\\n            path[2] = address(this);\\r\\n\\r\\n        uint256[] memory amounts =\\r\\n        PANCAKE_ROUTER.swapExactETHForTokens{\\r\\n            value: msg.value\\r\\n        }(\\r\\n            YODAS_PER_WISE,\\r\\n            path,\\r\\n            msg.sender,\\r\\n            block.timestamp + 2 hours\\r\\n        );\\r\\n\\r\\n        return createStake(\\r\\n            amounts[2],\\r\\n            _lockDays,\\r\\n            _referrer\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows to create stake with another token\\r\\n     * if you don\\u0027t have WISE tokens method will convert\\r\\n     * and use amount returned from PANCAKESWAP to open a stake\\r\\n     * @dev the token must have WBNB pair on PANCAKESWAP\\r\\n     * @param _tokenAddress any BEP20 token address\\r\\n     * @param _tokenAmount amount to be converted to WISE\\r\\n     * @param _lockDays amount of days it is locked for.\\r\\n     * @param _referrer referrer address for +10% bonus\\r\\n     */\\r\\n    function createStakeWithToken(\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount,\\r\\n        uint64 _lockDays,\\r\\n        address _referrer\\r\\n    )\\r\\n        external\\r\\n        returns (bytes16, uint256, bytes16 referralID)\\r\\n    {\\r\\n        IBEP20Token token = IBEP20Token(\\r\\n            _tokenAddress\\r\\n        );\\r\\n\\r\\n        token.transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _tokenAmount\\r\\n        );\\r\\n\\r\\n        token.approve(\\r\\n            address(PANCAKE_ROUTER),\\r\\n            _tokenAmount\\r\\n        );\\r\\n\\r\\n        address[] memory path = new address[](4);\\r\\n            path[0] = _tokenAddress;\\r\\n            path[1] = WBNB;\\r\\n            path[2] = address(SBNB);\\r\\n            path[3] = address(this);\\r\\n\\r\\n        uint256[] memory amounts =\\r\\n        PANCAKE_ROUTER.swapExactTokensForTokens(\\r\\n            _tokenAmount,\\r\\n            YODAS_PER_WISE,\\r\\n            path,\\r\\n            msg.sender,\\r\\n            block.timestamp + 2 hours\\r\\n        );\\r\\n\\r\\n        return createStake(\\r\\n            amounts[3],\\r\\n            _lockDays,\\r\\n            _referrer\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getPairAddress()\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(PANCAKE_PAIR);\\r\\n    }\\r\\n\\r\\n    function getTotalStaked()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return globals.totalStaked;\\r\\n    }\\r\\n\\r\\n    function getLiquidityTransformer()\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return LIQUIDITY_TRANSFORMER;\\r\\n    }\\r\\n\\r\\n    function getSyntheticTokenAddress()\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(SBNB);\\r\\n    }\\r\\n\\r\\n    function extendLTAuction()\\r\\n        external\\r\\n    {\\r\\n        if (_currentWiseDay() == uint64(15)) {\\r\\n            if (LAUNCH_TIME + 16 days - block.timestamp \\u003c= 10 minutes) {\\r\\n                uint256 newBalance = address(LIQUIDITY_TRANSFORMER).balance;\\r\\n                if (newBalance - LTBalance \\u003e= 10 ether) {\\r\\n                    LTBalance = newBalance;\\r\\n                    LAUNCH_TIME = LAUNCH_TIME + 10 minutes;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (_currentWiseDay() \\u003e uint64(15)) {\\r\\n            LAUNCH_TIME = 1619395200;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_syntheticBNBAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentWiseDay\",\"type\":\"uint256\"}],\"name\":\"InterestScraped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"LiquidityGuardStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentWiseDay\",\"type\":\"uint256\"}],\"name\":\"NewGlobals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"currentWiseDay\",\"type\":\"uint64\"}],\"name\":\"NewSharePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserveA\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserveB\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blockTimestampLast\",\"type\":\"uint32\"}],\"name\":\"PancakeSwapReserves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"referrerID\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiEquivalent\",\"type\":\"uint256\"}],\"name\":\"StakeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD_EQ\",\"outputs\":[{\"internalType\":\"contract IBUSDEquivalent\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INFLATION_RATE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAUNCH_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_GUARD\",\"outputs\":[{\"internalType\":\"contract ILiquidityGuard\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_RATE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_TRANSFORMER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_FACTORY\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_PAIR\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_ROUTER\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SBNB\",\"outputs\":[{\"internalType\":\"contract ISyntheticBNB\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_liquidityStakeID\",\"type\":\"bytes16\"}],\"name\":\"checkLiquidityStakeByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkMatureStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_referralID\",\"type\":\"bytes16\"}],\"name\":\"checkReferralsByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralInterest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActiveReferral\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActiveStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMatureStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEndedStake\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkStakeByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityTokens\",\"type\":\"uint256\"}],\"name\":\"createLiquidityStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"liquidityStakeID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_stakedAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_lockDays\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"_referrer\",\"type\":\"address[]\"}],\"name\":\"createStakeBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStakeWithBNB\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStakeWithToken\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"criticalMass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationDay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentWiseDay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_liquidityStakeID\",\"type\":\"bytes16\"}],\"name\":\"endLiquidityStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extendLTAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"z\",\"type\":\"bytes1\"}],\"name\":\"generateID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"b\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBUSDEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityTransformer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSyntheticTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWiseDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLiquidityGuardActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestLiquidityStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"latestReferralID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGuardTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityStakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"liquidityStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"closeDay\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lsnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailySnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_updateDay\",\"type\":\"uint64\"}],\"name\":\"manualDailySnapshotPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralSharesToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"referralsPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_referrals\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_referralID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"_scrapeDays\",\"type\":\"uint256\"}],\"name\":\"referrerInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_referralIDs\",\"type\":\"bytes16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_scrapeDays\",\"type\":\"uint256[]\"}],\"name\":\"referrerInterestBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"referrerLinks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processedDays\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rsnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scheduledToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint64\",\"name\":\"_scrapeDays\",\"type\":\"uint64\"}],\"name\":\"scrapeInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerPenalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"scrapes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_equalizerAddress\",\"type\":\"address\"}],\"name\":\"setBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableTransformer\",\"type\":\"address\"}],\"name\":\"setLiquidityTransfomer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockDays\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finalDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"closeDay\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiEquivalent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"stakesPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_stakes\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transformerGateKeeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WiseToken", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e90444c38a8cd2dceee9d954042ac817a794e9a9", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8f967d364252188abc1e5e6609e01912a83d1dac844f429a888586f4dc34465b"}