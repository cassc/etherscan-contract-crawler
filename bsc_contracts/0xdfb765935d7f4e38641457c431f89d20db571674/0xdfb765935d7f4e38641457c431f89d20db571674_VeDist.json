{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/vote/VeDist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"../../lib/Math.sol\\\";\\nimport \\\"../../interface/IERC20.sol\\\";\\nimport \\\"../../interface/IVeDist.sol\\\";\\nimport \\\"../../interface/IVe.sol\\\";\\nimport \\\"../../lib/SafeERC20.sol\\\";\\n\\ncontract VeDist is IVeDist {\\n  using SafeERC20 for IERC20;\\n\\n  event CheckpointToken(\\n    uint time,\\n    uint tokens\\n  );\\n\\n  event Claimed(\\n    uint tokenId,\\n    uint amount,\\n    uint claimEpoch,\\n    uint maxEpoch\\n  );\\n\\n  struct ClaimCalculationResult {\\n    uint toDistribute;\\n    uint userEpoch;\\n    uint weekCursor;\\n    uint maxUserEpoch;\\n    bool success;\\n  }\\n\\n\\n  uint constant WEEK = 7 * 86400;\\n\\n  uint public startTime;\\n  uint public timeCursor;\\n  mapping(uint => uint) public timeCursorOf;\\n  mapping(uint => uint) public userEpochOf;\\n\\n  uint public lastTokenTime;\\n  uint[1000000000000000] public tokensPerWeek;\\n\\n  address public votingEscrow;\\n  address public token;\\n  uint public tokenLastBalance;\\n\\n  uint[1000000000000000] public veSupply;\\n\\n  address public depositor;\\n\\n  constructor(address _votingEscrow) {\\n    uint _t = block.timestamp / WEEK * WEEK;\\n    startTime = _t;\\n    lastTokenTime = _t;\\n    timeCursor = _t;\\n    address _token = IVe(_votingEscrow).token();\\n    token = _token;\\n    votingEscrow = _votingEscrow;\\n    depositor = msg.sender;\\n    IERC20(_token).safeIncreaseAllowance(_votingEscrow, type(uint).max);\\n  }\\n\\n  function timestamp() external view returns (uint) {\\n    return block.timestamp / WEEK * WEEK;\\n  }\\n\\n  function _checkpointToken() internal {\\n    uint tokenBalance = IERC20(token).balanceOf(address(this));\\n    uint toDistribute = tokenBalance - tokenLastBalance;\\n    tokenLastBalance = tokenBalance;\\n\\n    uint t = lastTokenTime;\\n    uint sinceLast = block.timestamp - t;\\n    lastTokenTime = block.timestamp;\\n    uint thisWeek = t / WEEK * WEEK;\\n    uint nextWeek = 0;\\n\\n    for (uint i = 0; i < 20; i++) {\\n      nextWeek = thisWeek + WEEK;\\n      if (block.timestamp < nextWeek) {\\n        tokensPerWeek[thisWeek] += _adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\\n        break;\\n      } else {\\n        tokensPerWeek[thisWeek] += _adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\\n      }\\n      t = nextWeek;\\n      thisWeek = nextWeek;\\n    }\\n    emit CheckpointToken(block.timestamp, toDistribute);\\n  }\\n\\n  /// @dev For testing purposes.\\n  function adjustToDistribute(\\n    uint toDistribute,\\n    uint t0,\\n    uint t1,\\n    uint sinceLastCall\\n  ) external pure returns (uint) {\\n    return _adjustToDistribute(\\n      toDistribute,\\n      t0,\\n      t1,\\n      sinceLastCall\\n    );\\n  }\\n\\n  function _adjustToDistribute(\\n    uint toDistribute,\\n    uint t0,\\n    uint t1,\\n    uint sinceLast\\n  ) internal pure returns (uint) {\\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\\n      return toDistribute;\\n    }\\n    return toDistribute * (t0 - t1) / sinceLast;\\n  }\\n\\n  function checkpointToken() external override {\\n    require(msg.sender == depositor, \\\"!depositor\\\");\\n    _checkpointToken();\\n  }\\n\\n  function _findTimestampEpoch(address ve, uint _timestamp) internal view returns (uint) {\\n    uint _min = 0;\\n    uint _max = IVe(ve).epoch();\\n    for (uint i = 0; i < 128; i++) {\\n      if (_min >= _max) break;\\n      uint _mid = (_min + _max + 2) / 2;\\n      IVe.Point memory pt = IVe(ve).pointHistory(_mid);\\n      if (pt.ts <= _timestamp) {\\n        _min = _mid;\\n      } else {\\n        _max = _mid - 1;\\n      }\\n    }\\n    return _min;\\n  }\\n\\n  function findTimestampUserEpoch(address ve, uint tokenId, uint _timestamp, uint maxUserEpoch) external view returns (uint) {\\n    return _findTimestampUserEpoch(ve, tokenId, _timestamp, maxUserEpoch);\\n  }\\n\\n  function _findTimestampUserEpoch(address ve, uint tokenId, uint _timestamp, uint maxUserEpoch) internal view returns (uint) {\\n    uint _min = 0;\\n    uint _max = maxUserEpoch;\\n    for (uint i = 0; i < 128; i++) {\\n      if (_min >= _max) break;\\n      uint _mid = (_min + _max + 2) / 2;\\n      IVe.Point memory pt = IVe(ve).userPointHistory(tokenId, _mid);\\n      if (pt.ts <= _timestamp) {\\n        _min = _mid;\\n      } else {\\n        _max = _mid - 1;\\n      }\\n    }\\n    return _min;\\n  }\\n\\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\\n    address ve = votingEscrow;\\n    uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\\n    uint epoch = _findTimestampUserEpoch(ve, _tokenId, _timestamp, maxUserEpoch);\\n    IVe.Point memory pt = IVe(ve).userPointHistory(_tokenId, epoch);\\n    return uint(int256(Math.positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\\n  }\\n\\n  function _checkpointTotalSupply() internal {\\n    address ve = votingEscrow;\\n    uint t = timeCursor;\\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\\n    IVe(ve).checkpoint();\\n\\n    // assume will be called more frequently than 20 weeks\\n    for (uint i = 0; i < 20; i++) {\\n      if (t > roundedTimestamp) {\\n        break;\\n      } else {\\n        uint epoch = _findTimestampEpoch(ve, t);\\n        IVe.Point memory pt = IVe(ve).pointHistory(epoch);\\n        veSupply[t] = _adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\\n      }\\n      t += WEEK;\\n    }\\n    timeCursor = t;\\n  }\\n\\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) external pure returns (uint) {\\n    return _adjustVeSupply(t, ptTs, ptBias, ptSlope);\\n  }\\n\\n  function _adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) internal pure returns (uint) {\\n    if (t < ptTs) {\\n      return 0;\\n    }\\n    int128 dt = int128(int256(t - ptTs));\\n    if (ptBias < ptSlope * dt) {\\n      return 0;\\n    }\\n    return uint(int256(Math.positiveInt128(ptBias - ptSlope * dt)));\\n  }\\n\\n  function checkpointTotalSupply() external override {\\n    _checkpointTotalSupply();\\n  }\\n\\n  function _claim(uint _tokenId, address ve, uint _lastTokenTime) internal returns (uint) {\\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\\n    if (result.success) {\\n      userEpochOf[_tokenId] = result.userEpoch;\\n      timeCursorOf[_tokenId] = result.weekCursor;\\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\\n    }\\n    return result.toDistribute;\\n  }\\n\\n  function _calculateClaim(uint _tokenId, address ve, uint _lastTokenTime) internal view returns (ClaimCalculationResult memory) {\\n    uint userEpoch;\\n    uint toDistribute;\\n    uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\\n    uint _startTime = startTime;\\n\\n    if (maxUserEpoch == 0) {\\n      return ClaimCalculationResult(0, 0, 0, 0, false);\\n    }\\n\\n    uint weekCursor = timeCursorOf[_tokenId];\\n\\n    if (weekCursor == 0) {\\n      userEpoch = _findTimestampUserEpoch(ve, _tokenId, _startTime, maxUserEpoch);\\n    } else {\\n      userEpoch = userEpochOf[_tokenId];\\n    }\\n\\n    if (userEpoch == 0) userEpoch = 1;\\n\\n    IVe.Point memory userPoint = IVe(ve).userPointHistory(_tokenId, userEpoch);\\n    if (weekCursor == 0) {\\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\\n    }\\n    if (weekCursor >= lastTokenTime) {\\n      return ClaimCalculationResult(0, 0, 0, 0, false);\\n    }\\n    if (weekCursor < _startTime) {\\n      weekCursor = _startTime;\\n    }\\n\\n    IVe.Point memory oldUserPoint;\\n    {\\n      for (uint i = 0; i < 50; i++) {\\n        if (weekCursor >= _lastTokenTime) {\\n          break;\\n        }\\n        if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\\n          userEpoch += 1;\\n          oldUserPoint = userPoint;\\n          if (userEpoch > maxUserEpoch) {\\n            userPoint = IVe.Point(0, 0, 0, 0);\\n          } else {\\n            userPoint = IVe(ve).userPointHistory(_tokenId, userEpoch);\\n          }\\n        } else {\\n          int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\\n          uint balanceOf = uint(int256(Math.positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\\n          if (balanceOf == 0 && userEpoch > maxUserEpoch) {\\n            break;\\n          }\\n          toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\\n          weekCursor += WEEK;\\n        }\\n      }\\n    }\\n    return ClaimCalculationResult(\\n      toDistribute,\\n      Math.min(maxUserEpoch, userEpoch - 1),\\n      weekCursor,\\n      maxUserEpoch,\\n      true\\n    );\\n  }\\n\\n  function claimable(uint _tokenId) external view returns (uint) {\\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, votingEscrow, _lastTokenTime);\\n    return result.toDistribute;\\n  }\\n\\n  function claim(uint _tokenId) external returns (uint) {\\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\\n    uint _lastTokenTime = lastTokenTime;\\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\\n    uint amount = _claim(_tokenId, votingEscrow, _lastTokenTime);\\n    if (amount != 0) {\\n      IVe(votingEscrow).depositFor(_tokenId, amount);\\n      tokenLastBalance -= amount;\\n    }\\n    return amount;\\n  }\\n\\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\\n    uint _lastTokenTime = lastTokenTime;\\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\\n    address _votingEscrow = votingEscrow;\\n    uint total = 0;\\n\\n    for (uint i = 0; i < _tokenIds.length; i++) {\\n      uint _tokenId = _tokenIds[i];\\n      if (_tokenId == 0) break;\\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\\n      if (amount != 0) {\\n        IVe(_votingEscrow).depositFor(_tokenId, amount);\\n        total += amount;\\n      }\\n    }\\n    if (total != 0) {\\n      tokenLastBalance -= total;\\n    }\\n\\n    return true;\\n  }\\n\\n  // Once off event on contract initialize\\n  function setDepositor(address _depositor) external {\\n    require(msg.sender == depositor, \\\"!depositor\\\");\\n    depositor = _depositor;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nlibrary Math {\\n\\n  function max(uint a, uint b) internal pure returns (uint) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function min(uint a, uint b) internal pure returns (uint) {\\n    return a < b ? a : b;\\n  }\\n\\n  function positiveInt128(int128 value) internal pure returns (int128) {\\n    return value < 0 ? int128(0) : value;\\n  }\\n\\n  function closeTo(uint a, uint b, uint target) internal pure returns (bool) {\\n    if (a > b) {\\n      if (a - b <= target) {\\n        return true;\\n      }\\n    } else {\\n      if (b - a <= target) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function sqrt(uint y) internal pure returns (uint z) {\\n    if (y > 3) {\\n      z = y;\\n      uint x = y / 2 + 1;\\n      while (x < z) {\\n        z = x;\\n        x = (y / x + x) / 2;\\n      }\\n    } else if (y != 0) {\\n      z = 1;\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IVeDist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IVeDist {\\n\\n  function checkpointToken() external;\\n\\n  function checkpointTotalSupply() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IVe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IVe {\\n\\n  enum DepositType {\\n    DEPOSIT_FOR_TYPE,\\n    CREATE_LOCK_TYPE,\\n    INCREASE_LOCK_AMOUNT,\\n    INCREASE_UNLOCK_TIME,\\n    MERGE_TYPE\\n  }\\n\\n  struct Point {\\n    int128 bias;\\n    int128 slope; // # -dweight / dt\\n    uint ts;\\n    uint blk; // block\\n  }\\n  /* We cannot really do block numbers per se b/c slope is per time, not per block\\n  * and per block could be fairly bad b/c Ethereum changes blocktimes.\\n  * What we can do is to extrapolate ***At functions */\\n\\n  struct LockedBalance {\\n    int128 amount;\\n    uint end;\\n  }\\n\\n  function token() external view returns (address);\\n\\n  function balanceOfNFT(uint) external view returns (uint);\\n\\n  function isApprovedOrOwner(address, uint) external view returns (bool);\\n\\n  function createLockFor(uint, uint, address) external returns (uint);\\n\\n  function userPointEpoch(uint tokenId) external view returns (uint);\\n\\n  function epoch() external view returns (uint);\\n\\n  function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\\n\\n  function pointHistory(uint loc) external view returns (Point memory);\\n\\n  function checkpoint() external;\\n\\n  function depositFor(uint tokenId, uint value) external;\\n\\n  function attachToken(uint tokenId) external;\\n\\n  function detachToken(uint tokenId) external;\\n\\n  function voting(uint tokenId) external;\\n\\n  function abstain(uint tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"../interface/IERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint value\\n  ) internal {\\n    uint newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity 0.8.15;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n    (bool success, bytes memory returndata) = target.call(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_votingEscrow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"CheckpointToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxEpoch\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toDistribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sinceLastCall\",\"type\":\"uint256\"}],\"name\":\"adjustToDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ptTs\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"ptBias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"ptSlope\",\"type\":\"int128\"}],\"name\":\"adjustVeSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUserEpoch\",\"type\":\"uint256\"}],\"name\":\"findTimestampUserEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTokenTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeCursorOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLastBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensPerWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userEpochOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"veForAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"veSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingEscrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VeDist", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000875976aef383fe4135b93c3989671056c4decdff", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}