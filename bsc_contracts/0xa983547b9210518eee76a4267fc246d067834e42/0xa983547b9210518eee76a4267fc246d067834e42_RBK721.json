{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RBK721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {\\n    ERC721RentableUpgradeable,\\n    IERC721RentableUpgradeable\\n} from \\\"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721RentableUpgradeable.sol\\\";\\n\\nimport { IRBK721 } from \\\"./interfaces/IRBK721.sol\\\";\\n\\nimport { IAuthority, IBKTreasury, BK721, Roles } from \\\"src/token/BK721.sol\\\";\\n\\ncontract RBK721 is BK721, IRBK721, ERC721RentableUpgradeable {\\n    function initialize(\\n        string calldata name_,\\n        string calldata symbol_,\\n        string calldata baseURI_,\\n        uint96 feeAmt_,\\n        address feeToken_,\\n        IAuthority authority_\\n    )\\n        external\\n        initializer\\n    {\\n        __BK_init(name_, symbol_, baseURI_, feeAmt_, feeToken_, authority_);\\n    }\\n\\n    function setUser(\\n        address user_,\\n        uint256 tokenId,\\n        uint64 expires_,\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    )\\n        external\\n        whenNotPaused\\n        whenUseSignature(deadline_)\\n    {\\n        ownerOf(tokenId);\\n\\n        _verifySig(\\n            keccak256(\\n                abi.encode(\\n                    ///@dev value is equal to keccak256(\\\"Permit(address user,uint256 tokenId,uint256 expires,uint256\\n                    /// deadline,uint256 nonce)\\\")\\n                    0x791d178915e3bc91599d5bc6c1eab516b25cb66fc0b46b415e2018109bbaa078,\\n                    user_,\\n                    tokenId,\\n                    expires_,\\n                    deadline_,\\n                    _useNonce(bytes32(tokenId))\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _users.slot)\\n            let key := keccak256(0x00, 0x40)\\n            let data := sload(key)\\n\\n            if gt(shr(160, data), timestamp()) {\\n                mstore(0x00, 0xb5a13506)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            let unixExpires := add(expires_, timestamp())\\n            if gt(unixExpires, 0xffffffffffffffff) { revert(0, 0) }\\n\\n            sstore(key, or(shl(160, unixExpires), user_))\\n\\n            mstore(0x00, expires_)\\n            log3(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"UpdateUser(uint256,address,uint64)\\\")\\n                0x4e06b4e7000e659094299b3533b47b6aa8ad048e95e872d23d1f4ee55af89cfe,\\n                tokenId,\\n                user_\\n            )\\n        }\\n    }\\n\\n    function setUser(uint256 tokenId_, address user_, uint64 expires_) public override whenNotPaused {\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId_)) {\\n            revert ERC721Rentable__OnlyOwnerOrApproved();\\n        }\\n\\n        assembly {\\n            mstore(0x00, tokenId_)\\n            mstore(0x20, _users.slot)\\n            let key := keccak256(0x00, 0x40)\\n            let data := sload(key)\\n\\n            if gt(shr(160, data), timestamp()) {\\n                mstore(0x00, 0xb5a13506)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            let unixExpires := add(expires_, timestamp())\\n            if gt(unixExpires, 0xffffffffffffffff) { revert(0, 0) }\\n\\n            sstore(key, or(shl(160, unixExpires), user_))\\n\\n            mstore(0x00, expires_)\\n            log3(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"UpdateUser(uint256,address,uint64)\\\")\\n                0x4e06b4e7000e659094299b3533b47b6aa8ad048e95e872d23d1f4ee55af89cfe,\\n                tokenId_,\\n                user_\\n            )\\n        }\\n    }\\n\\n    function fixTokenIdTrackers(uint256 typeId_, uint256 value_) public onlyRole(Roles.OPERATOR_ROLE) {\\n        _setTypeIdTrackers(typeId_, value_);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId_)\\n        public\\n        view\\n        override(BK721, ERC721RentableUpgradeable)\\n        returns (bool)\\n    {\\n        return interfaceId_ == type(IRBK721).interfaceId || super.supportsInterface(interfaceId_);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from_,\\n        address to_,\\n        uint256 tokenId_,\\n        uint256 batchSize_\\n    )\\n        internal\\n        override(BK721, ERC721RentableUpgradeable)\\n    {\\n        super._beforeTokenTransfer(from_, to_, tokenId_, batchSize_);\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721RentableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IERC165Upgradeable, ERC721Upgradeable } from \\\"../ERC721Upgradeable.sol\\\";\\n\\nimport { IERC721RentableUpgradeable } from \\\"./IERC721RentableUpgradeable.sol\\\";\\n\\nabstract contract ERC721RentableUpgradeable is ERC721Upgradeable, IERC721RentableUpgradeable {\\n    mapping(uint256 => UserInfo) internal _users;\\n\\n    function setUser(uint256 tokenId, address user, uint64 expires) public virtual {\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {\\n            revert ERC721Rentable__OnlyOwnerOrApproved();\\n        }\\n\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _users.slot)\\n\\n            sstore(keccak256(0x00, 0x40), or(shl(160, expires), user))\\n\\n            mstore(0x00, expires)\\n            log3(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"UpdateUser(uint256,address,uint64)\\\")\\n                0x4e06b4e7000e659094299b3533b47b6aa8ad048e95e872d23d1f4ee55af89cfe,\\n                tokenId,\\n                user\\n            )\\n        }\\n    }\\n\\n    function userOf(uint256 tokenId) public view virtual override returns (address user) {\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _users.slot)\\n            let rentInfo := sload(keccak256(0x00, 0x40))\\n\\n            // leave dirty bytes uncleaned\\n            if gt(shr(160, rentInfo), timestamp()) { user := rentInfo }\\n        }\\n    }\\n\\n    function userExpires(uint256 tokenId) public view virtual override returns (uint256 expires) {\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _users.slot)\\n            expires := shr(160, sload(keccak256(0x00, 0x40)))\\n        }\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(IERC165Upgradeable, ERC721Upgradeable)\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC721RentableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    )\\n        internal\\n        virtual\\n        override\\n    {\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\n\\n        assembly {\\n            if iszero(eq(from, to)) {\\n                mstore(0x00, firstTokenId)\\n                mstore(0x20, _users.slot)\\n                let key := keccak256(0x00, 0x40)\\n                let rentInfo := sload(key)\\n\\n                if iszero(iszero(and(rentInfo, 0xffffffffffffffffffffffffffffffffffffffff))) {\\n                    sstore(key, 0)\\n\\n                    mstore(0x00, 0)\\n                    log3(\\n                        0x00,\\n                        0x20,\\n                        /// @dev value is equal to keccak256(\\\"UpdateUser(uint256,address,uint64)\\\")\\n                        0x4e06b4e7000e659094299b3533b47b6aa8ad048e95e872d23d1f4ee55af89cfe,\\n                        0,\\n                        0\\n                    )\\n                }\\n            }\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRBK721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport { IBK721 } from \\\"./IBK721.sol\\\";\\n\\ninterface IRBK721 is IBK721 {\\n    error RBK721__Rented();\\n    error RBK721__Expired();\\n    error RBK721__InvalidSignature();\\n\\n    function setUser(\\n        address user_,\\n        uint256 tokenId,\\n        uint64 expires_,\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"src/token/BK721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {\\n    ERC721Upgradeable,\\n    IERC165Upgradeable,\\n    ERC721PermitUpgradeable\\n} from \\\"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721PermitUpgradeable.sol\\\";\\nimport { ERC721EnumerableUpgradeable } from\\n    \\\"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\\\";\\n\\nimport { Roles, IAuthority, ManagerUpgradeable } from \\\"src/oz-custom/presets-upgradeable/base/ManagerUpgradeable.sol\\\";\\nimport { ProtocolFeeUpgradeable } from \\\"src/oz-custom/internal-upgradeable/ProtocolFeeUpgradeable.sol\\\";\\nimport { BKFundForwarderUpgradeable } from \\\"src/internal-upgradeable/BKFundForwarderUpgradeable.sol\\\";\\nimport { IWithdrawableUpgradeable } from \\\"src/oz-custom/internal-upgradeable/interfaces/IWithdrawableUpgradeable.sol\\\";\\n\\nimport { IFundForwarderUpgradeable } from \\\"src/oz-custom/internal-upgradeable/interfaces/IFundForwarderUpgradeable.sol\\\";\\n\\nimport { ERC721BurnableUpgradeable } from\\n    \\\"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\\\";\\n\\nimport { IBK721 } from \\\"src/interfaces/IBK721.sol\\\";\\nimport { IBKTreasury } from \\\"src/interfaces/IBKTreasury.sol\\\";\\n\\nimport { SSTORE2 } from \\\"src/oz-custom/libraries/SSTORE2.sol\\\";\\nimport { StringLib } from \\\"src/oz-custom/libraries/StringLib.sol\\\";\\nimport { Bytes32Address } from \\\"src/oz-custom/libraries/Bytes32Address.sol\\\";\\n\\nabstract contract BK721 is\\n    IBK721,\\n    ManagerUpgradeable,\\n    ProtocolFeeUpgradeable,\\n    ERC721PermitUpgradeable,\\n    BKFundForwarderUpgradeable,\\n    ERC721EnumerableUpgradeable\\n{\\n    using SSTORE2 for *;\\n    using StringLib for *;\\n    using Bytes32Address for *;\\n\\n    bytes32 private __baseTokenURIPtr;\\n\\n    mapping(uint256 => uint256) public typeIdTrackers;\\n\\n    mapping(address => mapping(uint248 => uint256)) private __nonceBitMaps;\\n\\n    modifier whenUseSignature(uint256 deadline_) {\\n        _checkExpiry(deadline_);\\n        _;\\n    }\\n\\n    function exchangeAssets(\\n        IBK721 forNFT_,\\n        uint256 forAmount_,\\n        uint256 forTypeId_,\\n        uint256 nonce_,\\n        uint256 deadline_,\\n        uint256[] calldata myIds_,\\n        bytes calldata signature_\\n    )\\n        external\\n        whenNotPaused\\n        whenUseSignature(deadline_)\\n        returns (uint256[] memory forIds)\\n    {\\n        address sender = _msgSender();\\n        /// @dev get rid of stack too deep\\n        {\\n            address[] memory addrs = new address[](1);\\n            addrs[0] = sender;\\n            _checkBlacklistMulti(addrs);\\n        }\\n\\n        address _vault = vault();\\n        IBK721 forNFT = forNFT_;\\n        uint256 forTypeId = forTypeId_;\\n        uint256 forAmount = forAmount_;\\n        /// @dev get rid of stack too deep\\n        {\\n            bytes memory data = abi.encodePacked(myIds_);\\n            uint256 nonce = nonce_;\\n            uint256 deadline = deadline_;\\n            data = abi.encode(\\n                /// @dev value is equal to keccak256(\\\"Exchange(address forNFT,uint256 forAmount,uint256\\n                /// forTypeId,address sendTo,uint256 nonce,uint256 deadline,uint256[] myIds)\\\")\\n                0xab1a661df2bfbb2fff43d8fb9aa517b6fb6f2001f8c41686daca79a469dcf903,\\n                forNFT,\\n                forAmount,\\n                forTypeId,\\n                _vault,\\n                nonce,\\n                deadline,\\n                keccak256(data)\\n            );\\n            _invalidateNonce(sender, sender, nonce);\\n            _verifySig(keccak256(data), signature_);\\n        }\\n\\n        /// @dev get rid of stack too deep\\n        {\\n            emit Exchanged(sender, forNFT, forTypeId, forAmount, myIds_);\\n            uint256 length = myIds_.length;\\n            bytes memory _safeTransferHeader = safeTransferHeader();\\n            uint256 myId;\\n            for (uint256 i; i < length;) {\\n                myId = myIds_[i];\\n\\n                if (ownerOf(myId) != sender) revert BK721__Unauthorized();\\n                _safeTransferFrom(sender, _vault, myId, _safeTransferHeader);\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            forIds = forNFT.safeMintBatch(sender, forTypeId, forAmount);\\n        }\\n    }\\n\\n    function redeemBulk(\\n        uint256 nonce_,\\n        uint256 amount_,\\n        uint256 typeId_,\\n        address claimer_,\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    )\\n        external\\n        whenNotPaused\\n        whenUseSignature(deadline_)\\n    {\\n        address sender = _msgSender();\\n\\n        address[] memory addrs = new address[](2);\\n        addrs[0] = claimer_;\\n        addrs[1] = sender;\\n\\n        _checkBlacklistMulti(addrs);\\n\\n        _invalidateNonce(sender, claimer_, nonce_);\\n\\n        _verifySig(\\n            keccak256(\\n                abi.encode(\\n                    ///@dev value is equal to keccak256(\\\"Redeem(address claimer,uint256 typeId,uint256 amount,uint256\\n                    /// nonce,uint256 deadline)\\\")\\n                    0x77ef6871868b6364332f0081c63b10b340f7531a5d1010a6bd3356568ffcf11d,\\n                    claimer_,\\n                    typeId_,\\n                    amount_,\\n                    // @dev resitance to reentrancy\\n                    nonce_,\\n                    deadline_\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        uint256 cursor = nextIdFromType(typeId_);\\n        for (uint256 i; i < amount_;) {\\n            unchecked {\\n                _mint(claimer_, cursor);\\n                ++cursor;\\n                ++i;\\n            }\\n        }\\n\\n        _setTypeIdTrackers(typeId_, cursor);\\n\\n        emit Redeemded(sender, claimer_, typeId_, amount_);\\n    }\\n\\n    function changeVault(address vault_) external override onlyRole(Roles.TREASURER_ROLE) {\\n        _changeVault(vault_);\\n    }\\n\\n    function setBaseURI(string calldata baseURI_) external onlyRole(Roles.OPERATOR_ROLE) {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function merge(\\n        uint256[] calldata fromIds_,\\n        uint256 toId_,\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    )\\n        external\\n        whenUseSignature(deadline_)\\n    {\\n        address user = _msgSender();\\n        _verifySig(\\n            keccak256(\\n                abi.encode(\\n                    ///@dev value is equal to keccak256(\\\"Swap(address user,uint256 toId,uint256 deadline,uint256\\n                    /// nonce,uint256[] fromIds)\\\")\\n                    0x085ba72701c4339ed5b893f5421cabf9405901f059ff0c12083eb0b1df6bc19a,\\n                    user,\\n                    toId_,\\n                    deadline_,\\n                    _useNonce(user.fillLast12Bytes()), // @dev resitance to reentrancy\\n                    keccak256(abi.encodePacked(fromIds_))\\n                )\\n            ),\\n            signature_\\n        );\\n\\n        uint256 fromId;\\n        uint256 length = fromIds_.length;\\n        for (uint256 i; i < length;) {\\n            fromId = fromIds_[i];\\n            if (ownerOf(fromId) != user) revert BK721__Unauthorized();\\n            if (fromId != toId_) _burn(fromId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        address ownerOfToId = ownerOf(toId_);\\n        if (!(ownerOfToId == address(0) || ownerOfToId == user)) {\\n            revert BK721__Unauthorized();\\n        }\\n\\n        if (ownerOfToId == address(0)) _mintTransfer(user, toId_);\\n\\n        emit Merged(user, fromIds_, toId_);\\n    }\\n\\n    function setRoyalty(address feeToken_, uint96 feeAmt_) external onlyRole(Roles.OPERATOR_ROLE) {\\n        if (!IBKTreasury(vault()).supportedPayment(feeToken_)) {\\n            revert BK721__TokenNotSupported();\\n        }\\n\\n        _setRoyalty(feeToken_, feeAmt_);\\n\\n        emit ProtocolFeeUpdated(_msgSender(), feeToken_, feeAmt_);\\n    }\\n\\n    function safeMint(address to_, uint256 typeId_) external onlyRole(Roles.PROXY_ROLE) returns (uint256 tokenId) {\\n        _safeMint(to_, tokenId = _useTypeIdTrackers(typeId_));\\n    }\\n\\n    function safeMintBatch(\\n        address to_,\\n        uint256 typeId_,\\n        uint256 length_\\n    )\\n        external\\n        onlyRole(Roles.PROXY_ROLE)\\n        returns (uint256[] memory tokenIds)\\n    {\\n        tokenIds = new uint256[](length_);\\n        uint256 cursor = nextIdFromType(typeId_);\\n        for (uint256 i; i < length_;) {\\n            unchecked {\\n                _safeMint(to_, tokenIds[i] = cursor);\\n                ++cursor;\\n                ++i;\\n            }\\n        }\\n\\n        address sender = _msgSender();\\n        assembly {\\n            mstore(0x00, typeId_)\\n            mstore(0x20, typeIdTrackers.slot)\\n            sstore(keccak256(0x00, 0x40), sub(cursor, 1))\\n\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"BatchTransfered(address,address,uint256)\\\")\\n                0xef50f834ec47321b2a791fa7e4f6ccb0ea5fb5852c73a68f7ce1ab9b759d609d,\\n                sender,\\n                to_,\\n                length_\\n            )\\n        }\\n    }\\n\\n    function mint(address to_, uint256 typeId_) external onlyRole(Roles.MINTER_ROLE) returns (uint256 tokenId) {\\n        _mint(to_, tokenId = _useTypeIdTrackers(typeId_));\\n    }\\n\\n    function transferBatch(address from_, address[] calldata tos_, uint256[] calldata tokenIds_) external {\\n        uint256 length = tos_.length;\\n        if (length != tokenIds_.length) revert BK721__LengthMismatch();\\n\\n        uint256 i;\\n        while (i < length && gasleft() > 250_000) {\\n            transferFrom(from_, tos_[i], tokenIds_[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        unchecked {\\n            emit BatchTransfered(_msgSender(), from_, i < length - 1 ? tokenIds_[i] : 0);\\n        }\\n    }\\n\\n    function mintBatch(uint256 typeId_, address[] calldata tos_) external onlyRole(Roles.MINTER_ROLE) {\\n        uint256 length = tos_.length;\\n        uint256 cursor = nextIdFromType(typeId_);\\n        for (uint256 i; i < length;) {\\n            unchecked {\\n                _mint(tos_[i], cursor);\\n                ++cursor;\\n                ++i;\\n            }\\n        }\\n\\n        unchecked {\\n            _setTypeIdTrackers(typeId_, cursor - 1);\\n        }\\n\\n        emit BatchMinted(_msgSender(), length, tos_);\\n    }\\n\\n    function safeMint(\\n        address to_,\\n        uint256 typeId_,\\n        uint256 length_\\n    )\\n        external\\n        onlyRole(Roles.PROXY_ROLE)\\n        returns (uint256[] memory tokenIds)\\n    {\\n        tokenIds = new uint256[](length_);\\n        uint256 cursor = nextIdFromType(typeId_);\\n        for (uint256 i; i < length_;) {\\n            unchecked {\\n                _safeMint(to_, tokenIds[i] = cursor);\\n                ++cursor;\\n                ++i;\\n            }\\n        }\\n\\n        address sender = _msgSender();\\n        assembly {\\n            mstore(0x00, typeId_)\\n            mstore(0x20, typeIdTrackers.slot)\\n            sstore(keccak256(0x00, 0x40), sub(cursor, 1))\\n\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"BatchTransfered(address,address,uint256)\\\")\\n                0xef50f834ec47321b2a791fa7e4f6ccb0ea5fb5852c73a68f7ce1ab9b759d609d,\\n                sender,\\n                to_,\\n                length_\\n            )\\n        }\\n    }\\n\\n    function nonces(address account_) external view returns (uint256 nonce) {\\n        assembly {\\n            mstore(0x00, account_)\\n            mstore(0x20, _nonces.slot)\\n            nonce := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    function nonceBitMaps(address account_, uint256 nonce_) external view returns (uint256 bitmap, bool isDirtied) {\\n        assembly {\\n            mstore(0x00, account_)\\n            mstore(0x20, __nonceBitMaps.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, and(shr(8, nonce_), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))\\n\\n            bitmap := sload(keccak256(0x00, 0x40))\\n            isDirtied := iszero(iszero(and(bitmap, shl(and(nonce_, 0xff), 1))))\\n        }\\n    }\\n\\n    function invalidateNonce(\\n        address account_,\\n        uint248 wordPos_,\\n        uint256 mask_\\n    )\\n        external\\n        onlyRole(Roles.OPERATOR_ROLE)\\n        whenPaused\\n    {\\n        assembly {\\n            mstore(0x00, account_)\\n            mstore(0x20, __nonceBitMaps.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, wordPos_)\\n            let key := keccak256(0x00, 0x40)\\n            let bitmap := sload(key)\\n            sstore(key, or(bitmap, mask_))\\n\\n            log4(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"NonceUsed(address,address,uint256,uint248)\\\")\\n                0x0df261ec91401191ee6858fdd0e1c4334f5faa334b5db219ea5847b0122164a8,\\n                caller(),\\n                account_,\\n                mask_\\n            )\\n        }\\n    }\\n\\n    function baseURI() external view returns (string memory) {\\n        return string(__baseTokenURIPtr.read());\\n    }\\n\\n    function metadataOf(uint256 tokenId_) external view returns (uint256 typeId, uint256 index) {\\n        ownerOf(tokenId_);\\n\\n        typeId = tokenId_ >> 32;\\n        index = tokenId_ & 0xffffffff;\\n    }\\n\\n    function nextIdFromType(uint256 typeId_) public view returns (uint256 nextId) {\\n        assembly {\\n            mstore(0x00, typeId_)\\n            mstore(0x20, typeIdTrackers.slot)\\n\\n            nextId := or(shl(32, typeId_), add(1, sload(keccak256(0x00, 0x40))))\\n        }\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        ownerOf(tokenId);\\n        return string(abi.encodePacked(__baseTokenURIPtr.read(), address(this).toHexString(), \\\"/\\\", tokenId.toString()));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId_)\\n        public\\n        view\\n        virtual\\n        override(ERC721PermitUpgradeable, ERC721EnumerableUpgradeable)\\n        returns (bool)\\n    {\\n        return type(IERC165Upgradeable).interfaceId == interfaceId_ || super.supportsInterface(interfaceId_);\\n    }\\n\\n    function version() public pure returns (bytes32) {\\n        /// @dev value is equal to keccak256(\\\"BKNFT_v1\\\")\\n        return 0x379792d4af837d435deaf8f2b7ca3c489899f24f02d5309487fe8be0aa778cca;\\n    }\\n\\n    function _setBaseURI(string calldata baseURI_) internal {\\n        __baseTokenURIPtr = bytes(baseURI_).write();\\n    }\\n\\n    function _invalidateNonce(address sender_, address account_, uint256 nonce_) internal {\\n        assembly {\\n            mstore(0x00, account_)\\n            mstore(0x20, __nonceBitMaps.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            let wordPos := and(shr(8, nonce_), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            mstore(0x00, wordPos)\\n            let key := keccak256(0x00, 0x40)\\n            let bitmap := sload(key)\\n            let bitPosMask := shl(and(nonce_, 0xff), 1)\\n            if iszero(iszero(and(bitmap, bitPosMask))) {\\n                mstore(0x00, 0x716c4752)\\n                revert(0x1c, 0x04)\\n            }\\n            sstore(key, or(bitmap, bitPosMask))\\n\\n            log4(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"NonceUsed(address,address,uint256,uint248)\\\")\\n                0x0df261ec91401191ee6858fdd0e1c4334f5faa334b5db219ea5847b0122164a8,\\n                sender_,\\n                account_,\\n                bitPosMask\\n            )\\n        }\\n    }\\n\\n    function __BK_init(\\n        string calldata name_,\\n        string calldata symbol_,\\n        string calldata baseURI_,\\n        uint96 feeAmt_,\\n        address feeToken_,\\n        IAuthority authority_\\n    )\\n        internal\\n        onlyInitializing\\n    {\\n        __BK_init_unchained(baseURI_);\\n        __ERC721Permit_init(name_, symbol_);\\n        __Manager_init_unchained(authority_, 0);\\n        __ProtocolFee_init_unchained(feeToken_, feeAmt_);\\n        __FundForwarder_init_unchained(IFundForwarderUpgradeable(address(authority_)).vault());\\n    }\\n\\n    function __BK_init_unchained(string calldata baseURI_) internal onlyInitializing {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function _useTypeIdTrackers(uint256 typeId_) internal returns (uint256 tokenId) {\\n        assembly {\\n            mstore(0x00, typeId_)\\n            mstore(0x20, typeIdTrackers.slot)\\n            let key := keccak256(0x00, 0x40)\\n            let typeIdTracker := sload(key)\\n            tokenId := or(shl(32, typeId_), typeIdTracker)\\n\\n            sstore(key, add(1, typeIdTracker))\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from_,\\n        address to_,\\n        uint256 tokenId_,\\n        uint256 batchSize_\\n    )\\n        internal\\n        virtual\\n        override(ERC721EnumerableUpgradeable, ERC721Upgradeable)\\n        whenNotPaused\\n    {\\n        super._beforeTokenTransfer(from_, to_, tokenId_, batchSize_);\\n\\n        address sender = _msgSender();\\n\\n        address[] memory addrs = new address[](3);\\n        addrs[0] = to_;\\n        addrs[1] = sender;\\n        addrs[2] = from_;\\n\\n        _checkBlacklistMulti(addrs);\\n\\n        if ((to_ == address(0) || from_ == address(0) || _hasRole(Roles.OPERATOR_ROLE, sender))) {\\n            return;\\n        }\\n\\n        FeeInfo memory _feeInfo = feeInfo;\\n\\n        address token = _feeInfo.token;\\n        uint256 royalty = _feeInfo.royalty;\\n\\n        if (royalty == 0) return;\\n\\n        address _vault = vault();\\n\\n        bytes memory _safeTransferHeader = safeTransferHeader();\\n        _safeTransferFrom(token, sender, _vault, royalty, _safeTransferHeader);\\n        if (token == address(0)) return;\\n\\n        if (\\n            IWithdrawableUpgradeable(_vault).notifyERC20Transfer(token, royalty, _safeTransferHeader)\\n                == IWithdrawableUpgradeable.notifyERC20Transfer.selector\\n        ) return;\\n\\n        revert BK721__ExecutionFailed();\\n    }\\n\\n    function _setTypeIdTrackers(uint256 typeId_, uint256 value_) internal {\\n        assembly {\\n            mstore(0x00, typeId_)\\n            mstore(0x20, typeIdTrackers.slot)\\n            sstore(keccak256(0x00, 0x40), value_)\\n        }\\n    }\\n\\n    function _mintTransfer(address to_, uint256 tokenId_) private {\\n        _mint(address(this), tokenId_);\\n        _transfer(address(this), to_, tokenId_);\\n    }\\n\\n    function _verifySig(bytes32 digest_, bytes calldata signature_) internal view {\\n        if (!_hasRole(Roles.SIGNER_ROLE, _recoverSigner(digest_, signature_))) {\\n            revert BK721__InvalidSignature();\\n        }\\n    }\\n\\n    function _checkExpiry(uint256 deadline_) internal view {\\n        assembly {\\n            if lt(deadline_, timestamp()) {\\n                mstore(0x00, 0xc5d24601)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return string(__baseTokenURIPtr.read());\\n    }\\n\\n    function _beforeRecover(bytes memory) internal override whenPaused onlyRole(Roles.OPERATOR_ROLE) { }\\n\\n    function _afterRecover(address, address, uint256, bytes memory) internal override { }\\n\\n    uint256[47] private __gap;\\n}\\n\\ninterface IBKNFT {\\n    function initialize(\\n        string calldata name_,\\n        string calldata symbol_,\\n        string calldata baseURI_,\\n        uint96 feeAmt_,\\n        address feeToken_,\\n        IAuthority authority_\\n    )\\n        external;\\n}\\n\\ncontract BKNFT is IBKNFT, BK721, ERC721BurnableUpgradeable {\\n    function initialize(\\n        string calldata name_,\\n        string calldata symbol_,\\n        string calldata baseURI_,\\n        uint96 feeAmt_,\\n        address feeToken_,\\n        IAuthority authority_\\n    )\\n        external\\n        initializer\\n    {\\n        __BK_init(name_, symbol_, baseURI_, feeAmt_, feeToken_, authority_);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId_)\\n        public\\n        view\\n        virtual\\n        override(BK721, ERC721BurnableUpgradeable)\\n        returns (bool)\\n    {\\n        return type(IBK721).interfaceId == interfaceId_ || super.supportsInterface(interfaceId_);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from_,\\n        address to_,\\n        uint256 tokenId_,\\n        uint256 batchSize_\\n    )\\n        internal\\n        override(BK721, ERC721Upgradeable)\\n    {\\n        super._beforeTokenTransfer(from_, to_, tokenId_, batchSize_);\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.10;\\n\\nimport {ContextUpgradeable} from \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport {\\n    ERC165Upgradeable,\\n    IERC165Upgradeable\\n} from \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\n\\nimport {IERC721Upgradeable} from \\\"./IERC721Upgradeable.sol\\\";\\nimport {\\n    IERC721MetadataUpgradeable\\n} from \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\n\\nimport {BitMapsUpgradeable} from \\\"../../utils/structs/BitMapsUpgradeable.sol\\\";\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721Upgradeable is\\n    ContextUpgradeable,\\n    ERC165Upgradeable,\\n    IERC721Upgradeable,\\n    IERC721MetadataUpgradeable\\n{\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n    string public symbol;\\n\\n    function _baseURI() internal view virtual returns (string memory);\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => bytes32) internal _ownerOf;\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(\\n        uint256 id\\n    ) public view virtual override returns (address owner) {\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            owner := sload(keccak256(0x00, 0x40))\\n\\n            if iszero(owner) {\\n                // Store the function selector of `ERC721__NotMinted()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0xf2c8ced6)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    function balanceOf(\\n        address owner\\n    ) public view virtual returns (uint256 balance_) {\\n        assembly {\\n            if iszero(owner) {\\n                // Store the function selector of `ERC721__NonZeroAddress()`.\\n                // Revert with (offset, size).\\n                mstore(0, 0xf8a06d80)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // balance_ = _balanceOf[owner]\\n            mstore(0x00, owner)\\n            mstore(0x20, _balanceOf.slot)\\n            balance_ := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => bytes32) internal _getApproved;\\n\\n    mapping(address => BitMapsUpgradeable.BitMap) internal _isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(\\n        string calldata name_,\\n        string calldata symbol_\\n    ) internal onlyInitializing {\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(\\n        string memory name_,\\n        string memory symbol_\\n    ) internal onlyInitializing {\\n        if (bytes(name_).length > 32 || bytes(symbol_).length > 32)\\n            revert ERC721__StringTooLong();\\n\\n        name = name_;\\n        symbol = symbol_;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address sender = _msgSender();\\n        assembly {\\n            /// @dev owner = _ownerOf[id]\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            let owner := sload(keccak256(0x00, 0x40))\\n\\n            /// @dev if (sender != owner)\\n            if iszero(eq(sender, owner)) {\\n                // check whether sender has approval for all id of owner\\n                mstore(0x00, owner)\\n                mstore(0x20, _isApprovedForAll.slot)\\n                // store _isApprovedForAll[owner] key at 0x20\\n                mstore(0x20, keccak256(0x00, 0x40))\\n                // override last 248 bit of sender as index to 0x00 for hashing\\n                mstore(0x00, shr(0x08, sender))\\n\\n                // revert if the approved bit is not set\\n                if iszero(\\n                    and(\\n                        sload(keccak256(0x00, 0x40)),\\n                        shl(and(sender, 0xff), 0x01)\\n                    )\\n                ) {\\n                    // Store the function selector of `ERC721__Unauthorized()`.\\n                    // Revert with (offset, size).\\n                    mstore(0x00, 0x1fad8706)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            //  _getApproved[id] = spender\\n            mstore(0x00, id)\\n            mstore(0x20, _getApproved.slot)\\n            sstore(keccak256(0x00, 0x40), spender)\\n\\n            // emit Approval(owner, spender, id)\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Approval(address,address,uint256)\\\")\\n                0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925,\\n                owner,\\n                spender,\\n                id\\n            )\\n        }\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public virtual {\\n        address sender = _msgSender();\\n        assembly {\\n            //  _isApprovedForAll[sender].setTo(operator, approved)\\n            mstore(0, sender)\\n            mstore(32, _isApprovedForAll.slot)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, shr(8, operator))\\n\\n            let mapKey := keccak256(0, 64)\\n            let value := sload(mapKey)\\n\\n            // The following sets the bit at `shift` without branching.\\n            let shift := and(operator, 0xff)\\n            // Isolate the bit at `shift`.\\n            let x := and(shr(shift, value), 1)\\n            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.\\n            x := xor(x, approved)\\n            // Shifts the bit back. Then, xor with value.\\n            // Only the bit at `shift` will be flipped if they differ.\\n            // Every other bit will stay the same, as they are xor'ed with zeroes.\\n            value := xor(value, shl(shift, x))\\n\\n            sstore(mapKey, value)\\n\\n            //  emit ApprovalForAll(sender, operator, approved)\\n            mstore(0x00, approved)\\n\\n            log3(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"ApprovalForAll(address,address,bool)\\\")\\n                0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31,\\n                sender,\\n                operator\\n            )\\n        }\\n    }\\n\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view override returns (address approval) {\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _getApproved.slot)\\n            approval := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool approved) {\\n        assembly {\\n            mstore(0x00, owner)\\n            mstore(0x20, _isApprovedForAll.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, shr(0x08, operator))\\n            approved := and(\\n                sload(keccak256(0x00, 0x40)),\\n                shl(and(operator, 0xff), 1)\\n            )\\n        }\\n    }\\n\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool isApprovedOrOwner_) {\\n        address owner = ownerOf(tokenId);\\n        assembly {\\n            // if spender is owner\\n            if eq(spender, owner) {\\n                isApprovedOrOwner_ := true\\n            }\\n\\n            if iszero(isApprovedOrOwner_) {\\n                // if _getApproved[tokenId] == spender\\n                mstore(0x00, tokenId)\\n                mstore(0x20, _getApproved.slot)\\n                let approved := sload(keccak256(0x00, 0x40))\\n                if eq(approved, spender) {\\n                    isApprovedOrOwner_ := true\\n                }\\n\\n                if iszero(isApprovedOrOwner_) {\\n                    // if _isApprovedForAll[owner][spender] == true\\n                    mstore(0x00, owner)\\n                    mstore(0x20, _isApprovedForAll.slot)\\n                    // store _isApprovedForAll[owner] key at 0x20\\n                    mstore(0x20, keccak256(0x00, 0x40))\\n\\n                    // store last 248 bit of spender as index\\n                    mstore(0x00, shr(0x08, spender))\\n\\n                    // check if the bit is turned in the bitmap\\n                    approved := and(\\n                        sload(keccak256(0x00, 0x40)),\\n                        shl(and(spender, 0xff), 1)\\n                    )\\n\\n                    if approved {\\n                        isApprovedOrOwner_ := true\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 /* firstTokenId */,\\n        uint256 batchSize\\n    ) internal virtual {\\n        assembly {\\n            if gt(batchSize, 1) {\\n                mstore(0x20, _balanceOf.slot)\\n                let key\\n                let balanceBefore\\n                if iszero(iszero(from)) {\\n                    mstore(0x00, from)\\n                    key := keccak256(0x00, 0x40)\\n                    balanceBefore := sload(key)\\n                    //  underflow check\\n                    if gt(balanceBefore, batchSize) {\\n                        revert(0, 0)\\n                    }\\n                    sstore(key, sub(balanceBefore, batchSize))\\n                }\\n                if iszero(iszero(to)) {\\n                    mstore(0x00, to)\\n                    key := keccak256(0x00, 0x40)\\n                    balanceBefore := sload(key)\\n                    //  overflow check\\n                    balanceBefore := add(balanceBefore, batchSize)\\n                    if lt(balanceBefore, batchSize) {\\n                        revert(0, 0)\\n                    }\\n                    sstore(key, balanceBefore)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual override {\\n        _beforeTokenTransfer(from, to, id, 1);\\n\\n        address sender = _msgSender();\\n        assembly {\\n            if iszero(to) {\\n                // Store the function selector of `ERC721__InvalidRecipient()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x28ede692)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x00, id)\\n            mstore(32, _ownerOf.slot)\\n            let ownerOfKey := keccak256(0, 64)\\n\\n            if iszero(eq(from, sload(ownerOfKey))) {\\n                // Store the function selector of `ERC721__WrongFrom()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x0ef14eef)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x20, _getApproved.slot)\\n            let approvedKey := keccak256(0x00, 0x40)\\n\\n            if iszero(eq(sender, from)) {\\n                if iszero(eq(sender, sload(approvedKey))) {\\n                    mstore(0x00, from)\\n                    mstore(0x20, _isApprovedForAll.slot)\\n\\n                    mstore(0x20, keccak256(0x00, 0x40))\\n                    mstore(0x00, shr(0x08, sender))\\n\\n                    if iszero(\\n                        and(sload(keccak256(0, 64)), shl(and(sender, 0xff), 1))\\n                    ) {\\n                        // Store the function selector of `ERC721__Unauthorized()`.\\n                        // Revert with (offset, size).\\n                        mstore(0x00, 0x1fad8706)\\n                        revert(0x1c, 0x04)\\n                    }\\n                }\\n            }\\n\\n            // Underflow of the sender's balance is impossible because we check for\\n            // ownership above and the recipient's balance can't realistically\\n\\n            //  ++_balanceOf[to];\\n            mstore(0x00, to)\\n            mstore(0x20, _balanceOf.slot)\\n            let key := keccak256(0x00, 0x40)\\n            let balanceBefore := add(1, sload(key))\\n            sstore(key, balanceBefore)\\n\\n            //  --_balanceOf[from];\\n            mstore(0x00, from)\\n            key := keccak256(0x00, 0x40)\\n            balanceBefore := sub(sload(key), 1)\\n            sstore(key, balanceBefore)\\n\\n            //  _ownerOf[id] = to\\n            sstore(ownerOfKey, to)\\n            //  delete _getApproved[id];\\n            sstore(approvedKey, 0)\\n\\n            // emit Transfer(from, to, id);\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                from,\\n                to,\\n                id\\n            )\\n        }\\n\\n        _afterTokenTransfer(from, to, id, 1);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiverUpgradeable(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiverUpgradeable.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiverUpgradeable(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    tokenId,\\n                    data\\n                ) ==\\n                ERC721TokenReceiverUpgradeable.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        assembly {\\n            // if to == address(0) revert\\n            if iszero(to) {\\n                // Store the function selector of `ERC721__InvalidRecipient()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x28ede692)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // cache tokenId at 0x00 for later use\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _ownerOf.slot)\\n            let key := keccak256(0x00, 0x40)\\n\\n            if iszero(eq(from, sload(key))) {\\n                // Store the function selector of `ERC721__WrongFrom()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x0ef14eef)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            //  _ownerOf[tokenId] = to\\n            sstore(key, to)\\n\\n            //  emit Transfer(from, to, tokenId);\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                from,\\n                to,\\n                tokenId\\n            )\\n\\n            // delete _getApproved[tokenId];\\n            mstore(0x20, _getApproved.slot)\\n            sstore(keccak256(0x00, 0x40), 0)\\n\\n            // ++_balanceOf[to]\\n            // cached _balanceOf slot for later use\\n            mstore(0x20, _balanceOf.slot)\\n            mstore(0x00, to)\\n            key := keccak256(0x00, 0x40)\\n            sstore(key, add(1, sload(key)))\\n\\n            // --_balanceOf[from]\\n            mstore(0x00, from)\\n            key := keccak256(0x00, 0x40)\\n            sstore(key, sub(sload(key), 1))\\n        }\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiverUpgradeable(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiverUpgradeable.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    )\\n        public\\n        view\\n        virtual\\n        override(ERC165Upgradeable, IERC165Upgradeable)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        _beforeTokenTransfer(address(0), to, id, 1);\\n\\n        assembly {\\n            if iszero(to) {\\n                // Store the function selector of `ERC721__InvalidRecipient()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x28ede692)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            let key := keccak256(0x00, 0x40)\\n            /// @dev cachedVal = _ownerOf[id]\\n            let cachedVal := sload(key)\\n\\n            /// @dev if (owner != 0) revert\\n            if iszero(iszero(cachedVal)) {\\n                mstore(0x00, 0xec125a85)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            /// @dev emit Transfer(address(0), to, id)\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                0,\\n                to,\\n                id\\n            )\\n\\n            /// @dev _ownerOf[id] = to\\n            sstore(key, to)\\n\\n            mstore(0x00, to)\\n            mstore(0x20, _balanceOf.slot)\\n            key := keccak256(0x00, 0x40)\\n            /// @dev cachedVal = _balanceOf[to] + 1\\n            cachedVal := add(sload(key), 1)\\n            sstore(key, cachedVal)\\n        }\\n\\n        _afterTokenTransfer(address(0), to, id, 1);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        bytes32 key;\\n        address owner;\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            key := keccak256(0x00, 0x40)\\n            owner := sload(key)\\n            if iszero(owner) {\\n                // Store the function selector of `ERC721__NotMinted()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0xf2c8ced6)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        _beforeTokenTransfer(owner, address(0), id, 1);\\n\\n        assembly {\\n            // delete _ownerOf[id]\\n            sstore(key, 0)\\n\\n            //  delete _getApproved[id];\\n            mstore(0x00, id)\\n            mstore(0x20, _getApproved.slot)\\n            sstore(keccak256(0x00, 0x40), 0)\\n\\n            //  emit Transfer(owner, address(0), id);\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                owner,\\n                0,\\n                id\\n            )\\n\\n            // Ownership check above ensures no underflow.\\n            //  --_balanceOf[owner]\\n            mstore(0x00, owner)\\n            mstore(0x20, _balanceOf.slot)\\n            key := keccak256(0x00, 0x40)\\n            sstore(key, sub(sload(key), 1))\\n        }\\n\\n        _afterTokenTransfer(owner, address(0), id, 1);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiverUpgradeable(to).onERC721Received(\\n                    _msgSender(),\\n                    address(0),\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiverUpgradeable.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiverUpgradeable(to).onERC721Received(\\n                    _msgSender(),\\n                    address(0),\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiverUpgradeable.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[44] private __gap;\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiverUpgradeable {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiverUpgradeable.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/IERC721RentableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IERC721Upgradeable} from \\\"../IERC721Upgradeable.sol\\\";\\n\\ninterface IERC721RentableUpgradeable is IERC721Upgradeable {\\n    error ERC721Rentable__NotValidTransfer();\\n    error ERC721Rentable__OnlyOwnerOrApproved();\\n\\n    struct UserInfo {\\n        address user; // address of user role\\n        uint64 expires; // unix timestamp, user expires\\n    }\\n\\n    // Logged when the user of an NFT is changed or expires is changed\\n    /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed\\n    /// The zero address for user indicates that there is no user address\\n    event UpdateUser(\\n        uint256 indexed tokenId,\\n        address indexed user,\\n        uint64 expires\\n    );\\n\\n    /// @notice set the user and expires of an NFT\\n    /// @dev The zero address indicates there is no user\\n    /// Throws if `tokenId` is not valid NFT\\n    /// @param user  The new user of the NFT\\n    /// @param expires  UNIX timestamp, The new user could use the NFT before expires\\n    function setUser(uint256 tokenId, address user, uint64 expires) external;\\n\\n    /// @notice Get the user address of an NFT\\n    /// @dev The zero address indicates that there is no user or the user is expired\\n    /// @param tokenId The NFT to get the user address for\\n    /// @return The user address for this NFT\\n    function userOf(uint256 tokenId) external view returns (address);\\n\\n    /// @notice Get the user expires of an NFT\\n    /// @dev The zero value indicates that there is no user\\n    /// @param tokenId The NFT to get the user expires for\\n    /// @return The user expires for this NFT\\n    function userExpires(uint256 tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBK721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport { IBKAsset } from \\\"./IBKAsset.sol\\\";\\n\\ninterface IBK721 is IBKAsset {\\n    /**\\n     * @dev Throws if the exchange request has already expired.\\n     */\\n    error BK721__Expired();\\n    /**\\n     * @dev Throws if the exchange request is not authorized.\\n     */\\n    error BK721__Unauthorized();\\n    /**\\n     * @dev Throws if the length of an array does not match the expected length.\\n     */\\n    error BK721__LengthMismatch();\\n    /**\\n     * @dev Throws if an execution fails.\\n     */\\n    error BK721__ExecutionFailed();\\n    /**\\n     * @dev Throws if the signature is invalid.\\n     */\\n    error BK721__InvalidSignature();\\n    /**\\n     * @dev Throws if the token is not supported.\\n     */\\n    error BK721__TokenNotSupported();\\n\\n    /**\\n     * @dev Emitted when tokens are exchanged between two users.\\n     * @param sender The address of the sender.\\n     * @param forNFT The instance of IBK721.\\n     * @param forTypeId The type ID of the token.\\n     * @param forAmount The amount of tokens being exchanged.\\n     * @param senderNFTIds The token IDs being transferred.\\n     */\\n    event Exchanged(\\n        address indexed sender,\\n        IBK721 indexed forNFT,\\n        uint256 indexed forTypeId,\\n        uint256 forAmount,\\n        uint256[] senderNFTIds\\n    );\\n\\n    /**\\n     * @dev Emitted when two or more NFTs are merged into a single NFT.\\n     * @param account The account to which the NFT is merged.\\n     * @param from The token IDs being merged.\\n     * @param to The token ID of the resulting merged NFT.\\n     */\\n    event Merged(address indexed account, uint256[] from, uint256 to);\\n\\n    /**\\n     * @dev Emitted when tokens are redeemed by a user.\\n     * @param operator The address of the operator redeeming the tokens.\\n     * @param claimer The address of the user claiming the tokens.\\n     * @param typeId The type ID of the token.\\n     * @param amount The amount of tokens being redeemed.\\n     */\\n    event Redeemded(address indexed operator, address indexed claimer, uint256 indexed typeId, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when tokens are minted in bulk by an operator.\\n     * @param operator The address of the operator minting the tokens.\\n     * @param amount The amount of tokens being minted.\\n     * @param tos The addresses of the users receiving the tokens.\\n     */\\n    event BatchMinted(address indexed operator, uint256 indexed amount, address[] tos);\\n\\n    /**\\n     * @dev Emitted when tokens are transferred in bulk from one user to multiple users.\\n     * @param operator The address of the operator performing the transfer.\\n     * @param from The address of the user transferring the tokens.\\n     * @param nextId The next available token ID.\\n     */\\n    event BatchTransfered(address indexed operator, address indexed from, uint256 indexed nextId);\\n\\n    function exchangeAssets(\\n        IBK721 forNFT_,\\n        uint256 forAmount_,\\n        uint256 forTypeId_,\\n        uint256 nonce_,\\n        uint256 deadline_,\\n        uint256[] calldata myIds_,\\n        bytes calldata signature_\\n    )\\n        external\\n        returns (uint256[] memory forIds);\\n\\n    function redeemBulk(\\n        uint256 nonce_,\\n        uint256 amount_,\\n        uint256 typeId_,\\n        address claimer_,\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    )\\n        external;\\n\\n    function transferBatch(address from_, address[] calldata tos_, uint256[] calldata tokenIds_) external;\\n\\n    function mint(address to_, uint256 tokenId_) external returns (uint256 tokenId);\\n\\n    function safeMint(address to_, uint256 typeId_) external returns (uint256 tokenId);\\n\\n    function mintBatch(uint256 typeId_, address[] calldata tos_) external;\\n\\n    function safeMintBatch(\\n        address to_,\\n        uint256 typeId_,\\n        uint256 length_\\n    )\\n        external\\n        returns (uint256[] memory tokenIds);\\n\\n    function merge(uint256[] calldata fromIds_, uint256 toId_, uint256 deadline_, bytes calldata signature_) external;\\n\\n    function nonces(address account_) external view returns (uint256);\\n\\n    function nonceBitMaps(address account_, uint256 nonce_) external view returns (uint256 bitmap, bool isDirtied);\\n\\n    function invalidateNonce(address account_, uint248 wordPos_, uint256 mask_) external;\\n\\n    function nextIdFromType(uint256 typeId_) external view returns (uint256);\\n\\n    function baseURI() external view returns (string memory);\\n\\n    function setBaseURI(string calldata baseURI_) external;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport {ERC721Upgradeable, IERC165Upgradeable} from \\\"../ERC721Upgradeable.sol\\\";\\nimport {\\n    SignableUpgradeable\\n} from \\\"../../../../internal-upgradeable/SignableUpgradeable.sol\\\";\\n\\nimport {IERC721PermitUpgradeable} from \\\"./IERC721PermitUpgradeable.sol\\\";\\n\\n/// @title ERC721 with permit\\n/// @notice Nonfungible tokens that support an approve via signature, i.e. permit\\nabstract contract ERC721PermitUpgradeable is\\n    ERC721Upgradeable,\\n    SignableUpgradeable,\\n    IERC721PermitUpgradeable\\n{\\n    function __ERC721Permit_init(\\n        string calldata name_,\\n        string calldata symbol_\\n    ) internal onlyInitializing {\\n        __EIP712_init_unchained(name_, \\\"1\\\");\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    /// @dev Gets the current nonce for a token ID and then increments it, returning the original value\\n\\n    /// @inheritdoc IERC721PermitUpgradeable\\n    function DOMAIN_SEPARATOR()\\n        public\\n        view\\n        override(IERC721PermitUpgradeable, SignableUpgradeable)\\n        returns (bytes32)\\n    {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /// @dev Value is equal to to keccak256(\\\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant __PERMIT_TYPEHASH =\\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\\n\\n    /// @inheritdoc IERC721PermitUpgradeable\\n    function permit(\\n        address spender_,\\n        uint256 tokenId_,\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    ) external override {\\n        address owner = ownerOf(tokenId_);\\n\\n        bytes32 digest;\\n        assembly {\\n            // if (block.timestamp > deadline_) revert ERC721Permit__Expired();\\n            if lt(deadline_, timestamp()) {\\n                mstore(0x00, 0x7b860b42)\\n                revert(0x1c, 0x04)\\n            }\\n            //  if (spender_ == owner) revert ERC721Permit__SelfApproving();\\n            if eq(spender_, owner) {\\n                mstore(0x00, 0x6916b4d5)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            let freeMemPtr := mload(0x40)\\n            mstore(freeMemPtr, __PERMIT_TYPEHASH)\\n            mstore(add(freeMemPtr, 0x20), spender_)\\n\\n            mstore(add(freeMemPtr, 0x40), tokenId_)\\n            let nonceMemPtr := add(freeMemPtr, 0x60)\\n            mstore(nonceMemPtr, _nonces.slot)\\n\\n            // increment nonce\\n            let nonceKey := keccak256(add(freeMemPtr, 0x40), 0x40)\\n            let nonce := sload(nonceKey)\\n            sstore(nonceKey, add(1, nonce))\\n\\n            mstore(nonceMemPtr, nonce)\\n            mstore(add(freeMemPtr, 0x80), deadline_)\\n            digest := keccak256(freeMemPtr, 0xa0)\\n        }\\n\\n        _verify(owner, digest, signature_);\\n\\n        assembly {\\n            mstore(0x00, tokenId_)\\n            mstore(0x20, _getApproved.slot)\\n            sstore(keccak256(0x00, 0x40), spender_)\\n        }\\n    }\\n\\n    function nonces(\\n        uint256 tokenId_\\n    ) external view override returns (uint256 nonce) {\\n        assembly {\\n            mstore(0x00, tokenId_)\\n            mstore(0x20, _nonces.slot)\\n            nonce := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Overridden from ERC721 here in order to include the interface of this EIP\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    )\\n        public\\n        view\\n        virtual\\n        override(ERC721Upgradeable, IERC165Upgradeable)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721PermitUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {ERC721Upgradeable, IERC165Upgradeable} from \\\"../ERC721Upgradeable.sol\\\";\\n\\nimport {Bytes32Address} from \\\"../../../../libraries/Bytes32Address.sol\\\";\\n\\nimport {\\n    IERC721EnumerableUpgradeable\\n} from \\\"./IERC721EnumerableUpgradeable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721EnumerableUpgradeable is\\n    ERC721Upgradeable,\\n    IERC721EnumerableUpgradeable\\n{\\n    // Array with all token ids, used for enumeration\\n    uint256[] private __allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private __allTokensIndex;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private __ownedTokensIndex;\\n\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private __ownedTokens;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    )\\n        public\\n        view\\n        virtual\\n        override(IERC165Upgradeable, ERC721Upgradeable)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721EnumerableUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) public view virtual override returns (uint256 tokenId) {\\n        assembly {\\n            mstore(0x00, owner)\\n            mstore(0x20, _balanceOf.slot)\\n            let _balance := sload(keccak256(0x00, 0x40))\\n            if gt(index, _balance) {\\n                mstore(0x00, 0xf67f2b58)\\n                revert(0x1c, 0x04)\\n            }\\n            if eq(index, _balance) {\\n                mstore(0x00, 0xf67f2b58)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x20, __ownedTokens.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, index)\\n\\n            tokenId := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply()\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256 supply)\\n    {\\n        assembly {\\n            supply := sload(__allTokens.slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(\\n        uint256 index\\n    ) public view virtual override returns (uint256 tokenId) {\\n        assembly {\\n            let length := sload(__allTokens.slot)\\n\\n            if gt(index, length) {\\n                mstore(0x00, 0x28c37220)\\n                revert(0x1c, 0x04)\\n            }\\n            if eq(index, length) {\\n                mstore(0x00, 0x28c37220)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x00, __allTokens.slot)\\n            tokenId := sload(add(keccak256(0x00, 0x20), shl(5, index)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\n\\n        if (batchSize > 1)\\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\\n            revert ERC721Enumerable__ConsecutiveTransferNotSupported();\\n\\n        if (from == address(0)) _addTokenToAllTokensEnumeration(firstTokenId);\\n        else if (from != to)\\n            _removeTokenFromOwnerEnumeration(from, firstTokenId);\\n\\n        if (to == address(0))\\n            _removeTokenFromAllTokensEnumeration(firstTokenId);\\n        else if (to != from) _addTokenToOwnerEnumeration(to, firstTokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        assembly {\\n            // length = _balanceOf[to]\\n            mstore(0x00, to)\\n            mstore(0x20, _balanceOf.slot)\\n            let length := sload(keccak256(0x00, 0x40))\\n\\n            // __ownedTokens[to][length] = tokenId;\\n            mstore(0x20, __ownedTokens.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, length)\\n            sstore(keccak256(0x00, 0x40), tokenId)\\n\\n            // __ownedTokensIndex[tokenId] = length;\\n            mstore(0x00, tokenId)\\n            mstore(0x20, __ownedTokensIndex.slot)\\n            sstore(keccak256(0x00, 0x40), length)\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        assembly {\\n            // __allTokensIndex[tokenId] = __allTokens.length;\\n            mstore(0x00, tokenId)\\n            mstore(0x20, __allTokensIndex.slot)\\n            let length := sload(__allTokens.slot)\\n            sstore(keccak256(0x00, 0x40), length)\\n\\n            // ++__allTokens.length\\n            sstore(__allTokens.slot, add(1, length))\\n            // __allTokens[length] = tokenId\\n            mstore(0x00, __allTokens.slot)\\n            sstore(add(keccak256(0x00, 0x20), shl(5, length)), tokenId)\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(\\n        address from,\\n        uint256 tokenId\\n    ) private {\\n        assembly {\\n            mstore(0x00, from)\\n            mstore(0x20, _balanceOf.slot)\\n            let lastTokenIndex := sload(keccak256(0x00, 0x40))\\n            //  underflow check\\n            if iszero(lastTokenIndex) {\\n                revert(0, 0)\\n            }\\n\\n            lastTokenIndex := sub(lastTokenIndex, 1)\\n\\n            mstore(0x00, tokenId)\\n            mstore(0x20, __ownedTokensIndex.slot)\\n            let ownedTokensIndexKey := keccak256(0x00, 0x40)\\n            let tokenIndex := sload(ownedTokensIndexKey)\\n            // cache __ownedtokens[from] key\\n            let ownedTokensFromLastKey\\n            // When the token to delete is the last token, the swap operation is unnecessary\\n            if iszero(eq(tokenIndex, lastTokenIndex)) {\\n                // lastTokenId = __ownedTokens[from][lastTokenIndex];\\n                mstore(0x00, from)\\n                mstore(0x20, __ownedTokens.slot)\\n                let ownedTokensFromKey := keccak256(0x00, 0x40)\\n                mstore(0x00, lastTokenIndex)\\n                mstore(0x20, ownedTokensFromKey)\\n                ownedTokensFromLastKey := keccak256(0x00, 0x40)\\n                let lastTokenId := sload(ownedTokensFromLastKey)\\n\\n                // __ownedTokens[from][tokenIndex] = lastTokenId;\\n                // Move the last token to the slot of the to-delete token\\n                mstore(0x00, tokenIndex)\\n                mstore(0x20, ownedTokensFromKey)\\n                sstore(keccak256(0x00, 0x40), lastTokenId)\\n\\n                // __ownedTokensIndex[lastTokenId] = tokenIndex;\\n                // Update the moved token's index\\n                mstore(0x00, lastTokenId)\\n                mstore(0x20, __ownedTokensIndex.slot)\\n                sstore(keccak256(0x00, 0x40), tokenIndex)\\n            }\\n\\n            // This also deletes the contents at the last position of the array\\n            // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n            // then delete the last slot (swap and pop).\\n\\n            // delete __ownedTokensIndex[tokenId];\\n            sstore(ownedTokensIndexKey, 0)\\n\\n            // delete __ownedTokens[from][lastTokenIndex];\\n            sstore(ownedTokensFromLastKey, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n        assembly {\\n            // uint256 lastTokenIndex = __allTokens.length - 1;\\n            let lastTokenIndex := sload(__allTokens.slot)\\n            // underflow check\\n            if iszero(lastTokenIndex) {\\n                revert(0, 0)\\n            }\\n            lastTokenIndex := sub(lastTokenIndex, 1)\\n\\n            // uint256 tokenIndex = __allTokensIndex[tokenId];\\n            mstore(0x00, tokenId)\\n            mstore(0x20, __allTokensIndex.slot)\\n            let allTokensIndexKey := keccak256(0x00, 0x40)\\n            let tokenIndex := sload(allTokensIndexKey)\\n\\n            // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n            // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n            // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n            // uint256 lastTokenId = __allTokens[lastTokenIndex];\\n            mstore(0x00, __allTokens.slot)\\n            let lastTokenId := sload(\\n                add(shl(5, lastTokenIndex), keccak256(0x00, 0x20))\\n            )\\n\\n            // __allTokens[tokenIndex] = lastTokenId;\\n            // Move the last token to the slot of the to-delete token\\n            sstore(add(shl(5, tokenIndex), keccak256(0x00, 0x20)), lastTokenId)\\n\\n            // __allTokensIndex[lastTokenId] = tokenIndex;\\n            // Update the moved token's index\\n            mstore(0x00, lastTokenId)\\n            mstore(0x20, __allTokensIndex.slot)\\n            sstore(keccak256(0x00, 0x40), tokenIndex)\\n\\n            // This also deletes the contents at the last position of the array\\n            //delete __allTokensIndex[tokenId];\\n            sstore(allTokensIndexKey, 0)\\n\\n            //  __allTokens.pop();\\n            sstore(__allTokens.slot, lastTokenIndex)\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[46] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/presets-upgradeable/base/ManagerUpgradeable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ContextUpgradeable\\n} from \\\"../../oz-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport {\\n    UUPSUpgradeable\\n} from \\\"../../oz-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport {\\n    ProxyCheckerUpgradeable\\n} from \\\"../../internal-upgradeable/ProxyCheckerUpgradeable.sol\\\";\\nimport {IManager, IAuthority} from \\\"./interfaces/IManager.sol\\\";\\n\\nimport {\\n    IPausableUpgradeable\\n} from \\\"../../oz-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport {\\n    IAccessControlUpgradeable\\n} from \\\"../../oz-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\nimport {\\n    IBlacklistableUpgradeable\\n} from \\\"../../internal-upgradeable/interfaces/IBlacklistableUpgradeable.sol\\\";\\n\\nimport {Roles} from \\\"../../libraries/Roles.sol\\\";\\nimport {ErrorHandler} from \\\"../../libraries/ErrorHandler.sol\\\";\\nimport {\\n    ERC165CheckerUpgradeable\\n} from \\\"../../oz-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\\\";\\n\\nabstract contract ManagerUpgradeable is\\n    IManager,\\n    UUPSUpgradeable,\\n    ContextUpgradeable,\\n    ProxyCheckerUpgradeable\\n{\\n    using ErrorHandler for bool;\\n    using ERC165CheckerUpgradeable for address;\\n\\n    bytes32 private __authority;\\n    bytes32 private __requestedRole;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    modifier onlyWhitelisted() {\\n        _checkBlacklist(_msgSender());\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    function __Manager_init(\\n        IAuthority authority_,\\n        bytes32 role_\\n    ) internal onlyInitializing {\\n        __Manager_init_unchained(authority_, role_);\\n    }\\n\\n    function __Manager_init_unchained(\\n        IAuthority authority_,\\n        bytes32 role_\\n    ) internal onlyInitializing {\\n        assembly {\\n            sstore(__requestedRole.slot, role_)\\n        }\\n        address sender = _msgSender();\\n        emit RequestRoleCached(sender, role_);\\n\\n        (bool ok, bytes memory revertData) = address(authority_).call(\\n            abi.encodeCall(IAuthority.requestAccess, (role_))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(revertData);\\n\\n        __updateAuthority(authority_);\\n        emit AuthorityUpdated(sender, IAuthority(address(0)), authority_);\\n    }\\n\\n    /// @inheritdoc IManager\\n    function updateAuthority(\\n        IAuthority authority_\\n    ) external onlyRole(Roles.OPERATOR_ROLE) {\\n        IAuthority old = authority();\\n        if (old == authority_) revert Manager__AlreadySet();\\n\\n        (bool ok, bytes memory revertData) = address(authority_).call(\\n            abi.encodeCall(IAuthority.requestAccess, (__requestedRole))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(revertData);\\n\\n        __updateAuthority(authority_);\\n\\n        emit AuthorityUpdated(_msgSender(), old, authority_);\\n    }\\n\\n    /// @inheritdoc IManager\\n    function authority() public view returns (IAuthority) {\\n        return IAuthority(_authority());\\n    }\\n\\n    /**\\n     * @notice Returns the address of the authority contract, for internal use.\\n     * @dev This function is for internal use only and should not be called by external contracts.\\n     * @return authority_ is the address of the authority contract.\\n     */\\n    function _authority() internal view returns (address authority_) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            authority_ := sload(__authority.slot)\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the given account is blacklisted by the authority contract.\\n     * @param account_ The address to check for blacklisting.\\n     * @dev This function should be called before allowing the given account to perform certain actions.\\n     * @custom:throws Manager__Blacklisted if the given account is blacklisted.\\n     */\\n    function _checkBlacklist(address account_) internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IBlacklistableUpgradeable.isBlacklisted, (account_))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (abi.decode(returnOrRevertData, (bool)))\\n            revert Manager__Blacklisted();\\n    }\\n\\n    function _checkBlacklistMulti(address[] memory accounts_) internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(\\n                IBlacklistableUpgradeable.areBlacklisted,\\n                (accounts_)\\n            )\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (abi.decode(returnOrRevertData, (bool)))\\n            revert Manager__Blacklisted();\\n    }\\n\\n    /**\\n     * @notice Checks if the given account has the given role.\\n     * @param role_ The role to check for.\\n     * @param account_ The address to check for the role.\\n     * @dev This function should be called before allowing the given account to perform certain actions.\\n     * @custom:throws Manager__Unauthorized if the given account does not have the given role.\\n     */\\n    function _checkRole(bytes32 role_, address account_) internal view {\\n        if (!_hasRole(role_, account_)) revert Manager__Unauthorized();\\n    }\\n\\n    function __updateAuthority(IAuthority authority_) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            sstore(__authority.slot, authority_)\\n        }\\n    }\\n\\n    function _requirePaused() internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IPausableUpgradeable.paused, ())\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (!abi.decode(returnOrRevertData, (bool)))\\n            revert Manager__NotPaused();\\n    }\\n\\n    function _requireNotPaused() internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IPausableUpgradeable.paused, ())\\n        );\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (abi.decode(returnOrRevertData, (bool))) revert Manager__Paused();\\n    }\\n\\n    function _hasRole(\\n        bytes32 role_,\\n        address account_\\n    ) internal view returns (bool) {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(\\n                IAccessControlUpgradeable.hasRole,\\n                (role_, account_)\\n            )\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        return abi.decode(returnOrRevertData, (bool));\\n    }\\n\\n    function __checkAuthority(address authority_) private view {\\n        if (\\n            authority_ == address(0) ||\\n            !_isProxy(authority_) ||\\n            !authority_.supportsInterface(type(IAuthority).interfaceId)\\n        ) revert Manager__InvalidArgument();\\n    }\\n\\n    function _authorizeUpgrade(\\n        address implement_\\n    ) internal override onlyRole(Roles.UPGRADER_ROLE) {}\\n\\n    uint256[48] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/ProtocolFeeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Initializable} from \\\"../oz-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {\\n    ContextUpgradeable\\n} from \\\"../oz-upgradeable/utils/ContextUpgradeable.sol\\\";\\n\\nimport {\\n    IProtocolFeeUpgradeable\\n} from \\\"./interfaces/IProtocolFeeUpgradeable.sol\\\";\\n\\n/**\\n * @title ProtocolFeeUpgradeable\\n * @dev Abstract contract for protocol fees.\\n * @dev An implementation of this contract should define the `_percentageFraction` function, which returns the percentage fraction of the fee.\\n * @dev The fee amount is calculated as the product of the fee percentage and the fee value.\\n */\\nabstract contract ProtocolFeeUpgradeable is\\n    Initializable,\\n    ContextUpgradeable,\\n    IProtocolFeeUpgradeable\\n{\\n    FeeInfo public feeInfo;\\n\\n    function __ProtocolFee_init(\\n        address token_,\\n        uint96 feeAmt_\\n    ) internal virtual onlyInitializing {\\n        __ProtocolFee_init_unchained(token_, feeAmt_);\\n    }\\n\\n    function __ProtocolFee_init_unchained(\\n        address token_,\\n        uint96 feeAmt_\\n    ) internal virtual onlyInitializing {\\n        _setRoyalty(token_, feeAmt_);\\n    }\\n\\n    /**\\n     * @dev Sets the royalty fee information\\n     * @param token_ Token address of the fee\\n     * @param amount_ Fee amount\\n     */\\n    function _setRoyalty(address token_, uint96 amount_) internal virtual {\\n        address sender = _msgSender();\\n        assembly {\\n            sstore(feeInfo.slot, or(shl(0xa0, amount_), token_))\\n\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"ProtocolFeeUpdated(address,address,uint256)\\\")\\n                0x2e25af38da02ef39388b1eb731f19781b0bc2bd6d4eb7700732d0c0e6b910c67,\\n                sender,\\n                token_,\\n                amount_\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Pure virtual function to return the percentage fraction of the fee\\n     * @return Percentage fraction of the fee\\n     */\\n    function _percentageFraction() internal pure virtual returns (uint256) {\\n        return 10_000;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/internal-upgradeable/BKFundForwarderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {\\n    IFundForwarderUpgradeable,\\n    FundForwarderUpgradeable\\n} from \\\"src/oz-custom/internal-upgradeable/FundForwarderUpgradeable.sol\\\";\\n\\nimport { ITreasury } from \\\"src/oz-custom/presets-upgradeable/interfaces/ITreasury.sol\\\";\\n\\nimport { ERC165CheckerUpgradeable } from \\\"src/oz-custom/oz-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\\\";\\n\\nabstract contract BKFundForwarderUpgradeable is FundForwarderUpgradeable {\\n    using ERC165CheckerUpgradeable for address;\\n\\n    function safeRecoverHeader() public pure override returns (bytes memory) {\\n        /// @dev value is equal keccak256(\\\"SAFE_RECOVER_HEADER\\\")\\n        return bytes.concat(bytes32(0x556d79614195ebefcc31ab1ee514b9953934b87d25857902370689cbd29b49de));\\n    }\\n\\n    function safeTransferHeader() public pure override returns (bytes memory) {\\n        /// @dev value is equal keccak256(\\\"SAFE_TRANSFER\\\")\\n        return bytes.concat(bytes32(0xc9627ddb76e5ee80829319617b557cc79498bbbc5553d8c632749a7511825f5d));\\n    }\\n\\n    function _checkValidAddress(address vault_) internal view virtual override {\\n        super._checkValidAddress(vault_);\\n        if (!vault_.supportsInterface(type(ITreasury).interfaceId)) {\\n            revert FundForwarder__InvalidArgument();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/interfaces/IWithdrawableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IWithdrawableUpgradeable {\\n    event Withdrawn(\\n        address indexed token,\\n        address indexed to,\\n        uint256 indexed value\\n    );\\n\\n    /**\\n     * @dev Event emitted when funds are received by the contract\\n     */\\n    event Received(\\n        address indexed sender,\\n        address indexed token,\\n        bytes value,\\n        bytes data\\n    );\\n\\n    function notifyERC20Transfer(\\n        address token_,\\n        uint256 value_,\\n        bytes calldata data_\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Withdraws the given amount of tokens or Ether from the contract\\n     * @param token_ Address of the token contract to withdraw. If zero address, withdraw Ether.\\n     * @param to_ Address to send the tokens or Ether to\\n     * @param value_ Amount of tokens or Ether to withdraw\\n     */\\n    function withdraw(\\n        address token_,\\n        address to_,\\n        uint256 value_,\\n        bytes calldata data_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/interfaces/IFundForwarderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    IERC20Upgradeable\\n} from \\\"../../oz-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport {\\n    IERC721Upgradeable,\\n    IERC721EnumerableUpgradeable\\n} from \\\"../../oz-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\n\\ninterface IFundForwarderUpgradeable {\\n    error FundForwarder__InvalidArgument();\\n\\n    struct RecoveryCallData {\\n        address token;\\n        uint256 value;\\n        bytes4 fnSelector;\\n        bytes params;\\n    }\\n\\n    /**\\n     * @dev Emits when the vault address is updated\\n     * @param from Old vault address\\n     * @param to New vault address\\n     */\\n    event VaultUpdated(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to\\n    );\\n\\n    /**\\n     *@dev Emits when a single ERC721 token is recovered\\n     *@param operator Address of the contract calling this function\\n     *@param token Address of the token contract\\n     *@param value Token ID of the recovered token\\n     */\\n    event Recovered(\\n        address indexed operator,\\n        address indexed token,\\n        uint256 indexed value,\\n        bytes params\\n    );\\n\\n    /**\\n     * @dev Emits when funds are forwarded\\n     * @param from Address of the sender\\n     * @param amount Amount of funds forwarded\\n     */\\n    event Forwarded(address indexed from, uint256 indexed amount);\\n\\n    function safeRecoverHeader() external pure returns (bytes memory);\\n\\n    function safeTransferHeader() external pure returns (bytes memory);\\n\\n    function vault() external view returns (address);\\n\\n    function changeVault(address vault_) external;\\n\\n    /**\\n     * @dev Recovers native currency to the vault address\\n     */\\n    function recoverNative() external;\\n\\n    function recover(RecoveryCallData[] calldata calldata_) external;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\\n\\npragma solidity ^0.8.10;\\n\\nimport {\\n    ERC721Upgradeable,\\n    IERC165Upgradeable,\\n    IERC721Upgradeable\\n} from \\\"../ERC721Upgradeable.sol\\\";\\n\\ninterface IERC721BurnableUpgradeable is IERC721Upgradeable {\\n    error ERC721Burnable__OnlyOwnerOrApproved();\\n\\n    function burn(uint256 tokenId) external;\\n}\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be burned (destroyed).\\n */\\n\\nabstract contract ERC721BurnableUpgradeable is\\n    ERC721Upgradeable,\\n    IERC721BurnableUpgradeable\\n{\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        //solhint-disable-next-line max-line-length\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId))\\n            revert ERC721Burnable__OnlyOwnerOrApproved();\\n        _burn(tokenId);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId_\\n    )\\n        public\\n        view\\n        virtual\\n        override(ERC721Upgradeable, IERC165Upgradeable)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId_ == type(IERC721BurnableUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId_);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBKTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IBKTreasury {\\n    error BKTreasury__LengthMismatch();\\n    error BKTreasury__UnsupportedToken();\\n\\n    event PaymentsUpdated(address indexed operator, address[] payments, bool[] statuses);\\n    event PricesUpdated(address indexed operator, address[] tokens, uint256[] prices);\\n\\n    function priceOf(address token_) external view returns (uint256);\\n\\n    function supportedPayment(address token_) external view returns (bool);\\n\\n    function viewSupportedPayments() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/libraries/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    error SSTORE2__ReadOutOfBounds();\\n    error SSTORE2__DeploymentFailed();\\n\\n    // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n    uint256 internal constant DATA_OFFSET = 1;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (bytes32 ptr) {\\n        // Note: The assembly block below does not expand the memory.\\n        address pointer;\\n        assembly {\\n            let originalDataLength := mload(data)\\n\\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\\n            let dataSize := add(originalDataLength, 1)\\n\\n            /**\\n             * ------------------------------------------------------------------------------------+\\n             *   Opcode  | Opcode + Arguments  | Description       | Stack View                    |\\n             * ------------------------------------------------------------------------------------|\\n             *   0x61    | 0x61XXXX            | PUSH2 codeSize    | codeSize                      |\\n             *   0x80    | 0x80                | DUP1              | codeSize codeSize             |\\n             *   0x60    | 0x600A              | PUSH1 10          | 10 codeSize codeSize          |\\n             *   0x3D    | 0x3D                | RETURNDATASIZE    | 0 10 codeSize codeSize        |\\n             *   0x39    | 0x39                | CODECOPY          | codeSize                      |\\n             *   0x3D    | 0x3D                | RETURNDATASZIE    | 0 codeSize                    |\\n             *   0xF3    | 0xF3                | RETURN            |                               |\\n             *   0x00    | 0x00                | STOP              |                               |\\n             * ------------------------------------------------------------------------------------+\\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called. Also PUSH2 is\\n             * used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\\n             */\\n            mstore(\\n                data,\\n                or(\\n                    0x61000080600a3d393df300,\\n                    shl(64, dataSize) // shift `dataSize` so that it lines up with the 0000 after PUSH2\\n                )\\n            )\\n\\n            // Deploy a new contract with the generated creation code.\\n            pointer := create(0, add(data, 21), add(dataSize, 10))\\n\\n            // Restore original length of the variable size `data`\\n            mstore(data, originalDataLength)\\n        }\\n\\n        if (pointer == address(0)) revert SSTORE2__DeploymentFailed();\\n\\n        assembly {\\n            ptr := pointer\\n        }\\n    }\\n\\n    function writeToAddr(\\n        bytes memory data\\n    ) internal returns (address pointer) {\\n        // Note: The assembly block below does not expand the memory.\\n        assembly {\\n            let originalDataLength := mload(data)\\n\\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\\n            let dataSize := add(originalDataLength, 1)\\n\\n            /**\\n             * ------------------------------------------------------------------------------------+\\n             *   Opcode  | Opcode + Arguments  | Description       | Stack View                    |\\n             * ------------------------------------------------------------------------------------|\\n             *   0x61    | 0x61XXXX            | PUSH2 codeSize    | codeSize                      |\\n             *   0x80    | 0x80                | DUP1              | codeSize codeSize             |\\n             *   0x60    | 0x600A              | PUSH1 10          | 10 codeSize codeSize          |\\n             *   0x3D    | 0x3D                | RETURNDATASIZE    | 0 10 codeSize codeSize        |\\n             *   0x39    | 0x39                | CODECOPY          | codeSize                      |\\n             *   0x3D    | 0x3D                | RETURNDATASZIE    | 0 codeSize                    |\\n             *   0xF3    | 0xF3                | RETURN            |                               |\\n             *   0x00    | 0x00                | STOP              |                               |\\n             * ------------------------------------------------------------------------------------+\\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called. Also PUSH2 is\\n             * used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\\n             */\\n            mstore(\\n                data,\\n                or(\\n                    0x61000080600a3d393df300,\\n                    shl(64, dataSize) // shift `dataSize` so that it lines up with the 0000 after PUSH2\\n                )\\n            )\\n\\n            // Deploy a new contract with the generated creation code.\\n            pointer := create(0, add(data, 21), add(dataSize, 10))\\n\\n            // Restore original length of the variable size `data`\\n            mstore(data, originalDataLength)\\n        }\\n\\n        if (pointer == address(0)) revert SSTORE2__DeploymentFailed();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address ptr) internal view returns (bytes memory) {\\n        return readBytecode(ptr, DATA_OFFSET, ptr.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(bytes32 ptr) internal view returns (bytes memory) {\\n        address pointer;\\n        assembly {\\n            pointer := ptr\\n        }\\n        return\\n            readBytecode(\\n                pointer,\\n                DATA_OFFSET,\\n                pointer.code.length - DATA_OFFSET\\n            );\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        if (pointer.code.length < end) revert SSTORE2__ReadOutOfBounds();\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 63 (32 + 31) to size and running the result through the logic\\n            // above ensures the memory pointer remains word-aligned, following\\n            // the Solidity convention.\\n            mstore(0x40, add(data, and(add(size, 63), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/libraries/StringLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nerror StringLib__LengthInsufiicient();\\n\\n/// @notice Efficient library for creating string representations of integers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\\nlibrary StringLib {\\n    uint256 private constant __ADDRESS_LENGTH = 20;\\n    bytes32 private constant __SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) return toString(uint256(value));\\n\\n        unchecked {\\n            str = toString(uint256(-value));\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Note: This is only safe because we over-allocate memory\\n                // and write the string from right to left in toString(uint256),\\n                // and thus can be sure that sub(str, 1) is an unused memory location.\\n\\n                let length := mload(str) // Load the string length.\\n                // Put the - character at the start of the string contents.\\n                mstore(str, 45) // 45 is the ASCII code for the - character.\\n                str := sub(str, 1) // Move back the string pointer by a byte.\\n                mstore(str, add(length, 1)) // Update the string length.\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes((length << 1) + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        unchecked {\\n            for (uint256 i = (length << 1) + 1; i > 1; --i) {\\n                buffer[i] = __SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n        if (value != 0) revert StringLib__LengthInsufiicient();\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), __ADDRESS_LENGTH);\\n    }\\n\\n    function toString(\\n        uint256 value\\n    ) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\\n            let newFreeMemoryPointer := add(mload(0x40), 160)\\n\\n            // Update the free memory pointer to avoid overriding our string.\\n            mstore(0x40, newFreeMemoryPointer)\\n\\n            // Assign str to the end of the zone of newly allocated memory.\\n            str := sub(newFreeMemoryPointer, 32)\\n\\n            // Clean the last word of memory it may not be overwritten.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                // Move the pointer 1 byte to the left.\\n                str := sub(str, 1)\\n\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n\\n                // Keep dividing temp until zero.\\n                temp := div(temp, 10)\\n\\n                 // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute and cache the final total length of the string.\\n            let length := sub(end, str)\\n\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 32)\\n\\n            // Store the string's length at the start of memory allocated for our string.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/libraries/Bytes32Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Bytes32Address {\\n    function fromFirst20Bytes(\\n        bytes32 bytesValue\\n    ) internal pure returns (address addr) {\\n        assembly {\\n            addr := bytesValue\\n        }\\n    }\\n\\n    function fillLast12Bytes(\\n        address addressValue\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := addressValue\\n        }\\n    }\\n\\n    function fromFirst160Bits(\\n        uint256 uintValue\\n    ) internal pure returns (address addr) {\\n        assembly {\\n            addr := uintValue\\n        }\\n    }\\n\\n    function fillLast96Bits(\\n        address addressValue\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := addressValue\\n        }\\n    }\\n\\n    function fromLast160Bits(\\n        uint256 uintValue\\n    ) internal pure returns (address addr) {\\n        assembly {\\n            addr := shr(0x60, uintValue)\\n        }\\n    }\\n\\n    function fillFirst96Bits(\\n        address addressValue\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := shl(0x60, addressValue)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC165Upgradeable} from \\\"./IERC165Upgradeable.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {}\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {\\n    IERC165Upgradeable\\n} from \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    error ERC721__NotMinted();\\n    error ERC721__WrongFrom();\\n    error ERC721__Unauthorized();\\n    error ERC721__StringTooLong();\\n    error ERC721__AlreadyMinted();\\n    error ERC721__NonZeroAddress();\\n    error ERC721__UnsafeRecipient();\\n    error ERC721__InvalidRecipient();\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC721Upgradeable} from \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/structs/BitMapsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMapsUpgradeable {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(\\n        BitMap storage bitmap,\\n        uint256 index\\n    ) internal view returns (bool isSet) {\\n        uint256 value = bitmap._data[index >> 8] & (1 << (index & 0xff));\\n\\n        assembly {\\n            isSet := value // Assign isSet to whether the value is non zero.\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool shouldSet\\n    ) internal {\\n        uint256 value = bitmap._data[index >> 8];\\n\\n        assembly {\\n            // The following sets the bit at `shift` without branching.\\n            let shift := and(index, 0xff)\\n            // Isolate the bit at `shift`.\\n            let x := and(shr(shift, value), 1)\\n            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.\\n            x := xor(x, shouldSet)\\n            // Shifts the bit back. Then, xor with value.\\n            // Only the bit at `shift` will be flipped if they differ.\\n            // Every other bit will stay the same, as they are xor'ed with zeroes.\\n            value := xor(value, shl(shift, x))\\n        }\\n        bitmap._data[index >> 8] = value;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        bitmap._data[index >> 8] |= 1 << (index & 0xff);\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        bitmap._data[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBKAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IBKAsset {\\n    function typeIdTrackers(uint256 typeId_) external view returns (uint256);\\n\\n    function metadataOf(uint256 tokenId_) external view returns (uint256 typeId, uint256 index);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/SignableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ContextUpgradeable\\n} from \\\"../oz-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport {\\n    ECDSAUpgradeable,\\n    EIP712Upgradeable\\n} from \\\"../oz-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\\\";\\n\\nimport {ISignableUpgradeable} from \\\"./interfaces/ISignableUpgradeable.sol\\\";\\n\\nimport {Bytes32Address} from \\\"../libraries/Bytes32Address.sol\\\";\\n\\n/**\\n * @title SignableUpgradeable\\n * @dev Abstract contract for signing and verifying typed data.\\n */\\nabstract contract SignableUpgradeable is\\n    EIP712Upgradeable,\\n    ContextUpgradeable,\\n    ISignableUpgradeable\\n{\\n    using Bytes32Address for address;\\n    using ECDSAUpgradeable for bytes32;\\n\\n    /**\\n     * @dev Mapping of nonces for each id\\n     */\\n    mapping(bytes32 => uint256) internal _nonces;\\n\\n    /**\\n     * @dev Constructor that initializes EIP712 with the given name and version\\n     * @param name_ Name of the typed data\\n     * @param version_ Version of the typed data\\n     */\\n    function __Signable_init(\\n        string calldata name_,\\n        string calldata version_\\n    ) internal onlyInitializing {\\n        __Signable_init_unchained(name_, version_);\\n    }\\n\\n    function __Signable_init_unchained(\\n        string memory name_,\\n        string memory version_\\n    ) internal onlyInitializing {\\n        __EIP712_init_unchained(name_, version_);\\n    }\\n\\n    /**\\n     * @dev Verifies that the signer of the typed data is the given address\\n     * @param verifier_ Address to verify\\n     * @param structHash_ Hash of the typed data\\n     * @param signature_ Signature of the typed data\\n     */\\n    function _verify(\\n        address verifier_,\\n        bytes32 structHash_,\\n        bytes calldata signature_\\n    ) internal view virtual {\\n        if (_recoverSigner(structHash_, signature_) != verifier_)\\n            revert Signable__InvalidSignature();\\n    }\\n\\n    /**\\n     * @dev Verifies that the signer of the typed data is the given address\\n     * @param verifier_ Address to verify\\n     * @param structHash_ Hash of the typed data\\n     * @param v ECDSA recovery value\\n     * @param r ECDSA r value\\n     * @param s ECDSA s value\\n     */\\n    function _verify(\\n        address verifier_,\\n        bytes32 structHash_,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view virtual {\\n        if (_recoverSigner(structHash_, v, r, s) != verifier_)\\n            revert Signable__InvalidSignature();\\n    }\\n\\n    /**\\n     * @dev Recovers the signer of the typed data from the signature\\n     * @param structHash_ Hash of the typed data\\n     * @param signature_ Signature of the typed data\\n     * @return Address of the signer\\n     */\\n    function _recoverSigner(\\n        bytes32 structHash_,\\n        bytes calldata signature_\\n    ) internal view returns (address) {\\n        return _hashTypedDataV4(structHash_).recover(signature_);\\n    }\\n\\n    /**\\n     * @dev Recovers the signer of the typed data from the signature\\n     * @param structHash_ Hash of the typed data\\n     * @param v ECDSA recovery value\\n     * @param r ECDSA r value\\n     * @param s ECDSA s value\\n     * @return Address of the signer\\n     */\\n    function _recoverSigner(\\n        bytes32 structHash_,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address) {\\n        return _hashTypedDataV4(structHash_).recover(v, r, s);\\n    }\\n\\n    /**\\n     * @dev Increases the nonce for the given account by 1\\n     * @param id_ ID to increase the nonce for\\n     * @return nonce The new nonce for the account\\n     */\\n    function _useNonce(bytes32 id_) internal virtual returns (uint256 nonce) {\\n        address sender = _msgSender();\\n        assembly {\\n            mstore(0x00, id_)\\n            mstore(0x20, _nonces.slot)\\n            let key := keccak256(0x00, 0x40)\\n            nonce := sload(key)\\n            sstore(key, add(nonce, 1))\\n\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"NonceIncremented(address,bytes32,uint256)\\\")\\n                0x81950aaf2c3573be1f953223448244747f16268d5a0573dea6bd6fa249a4c86e,\\n                sender,\\n                id_,\\n                nonce\\n            )\\n        }\\n    }\\n\\n    /// @inheritdoc ISignableUpgradeable\\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/IERC721PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport {IERC721Upgradeable} from \\\"../IERC721Upgradeable.sol\\\";\\n\\n/// @title ERC721 with permit\\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\\ninterface IERC721PermitUpgradeable is IERC721Upgradeable {\\n    error ERC721Permit__Expired();\\n    error ERC721Permit__SelfApproving();\\n\\n    /// @notice The domain separator used in the permit signature\\n    /// @return The domain seperator used in encoding of permit signature\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice function to be called by anyone to approve `spender` using a Permit signature\\n    /// @dev Anyone can call this to approve `spender`, even a third-party\\n    /// @param spender the actor to approve\\n    /// @param tokenId the token id\\n    /// @param deadline the deadline for the permit to be used\\n    /// @param signature permit\\n    function permit(\\n        address spender,\\n        uint256 tokenId,\\n        uint256 deadline,\\n        bytes calldata signature\\n    ) external;\\n\\n    function nonces(uint256 tokenId_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC721Upgradeable} from \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    error ERC721Enumerable__OutOfBounds();\\n    error ERC721Enumerable__GlobalIndexOutOfBounds();\\n    error ERC721Enumerable__ConsecutiveTransferNotSupported();\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\nimport {\\n    ERC1967UpgradeUpgradeable\\n} from \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport {\\n    IERC1822ProxiableUpgradeable\\n} from \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\n\\nerror UUPSUpgradeable__OnlyCall();\\nerror UUPSUpgradeable__OnlyActiveProxy();\\nerror UUPSUpgradeable__OnlyDelegateCall();\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is\\n    Initializable,\\n    ERC1967UpgradeUpgradeable,\\n    IERC1822ProxiableUpgradeable\\n{\\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\\n\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        __checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        __checkDelegated();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID()\\n        external\\n        view\\n        virtual\\n        override\\n        notDelegated\\n        returns (bytes32)\\n    {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, \\\"\\\", false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data\\n    ) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    function __checkProxy() private view {\\n        address self = __self;\\n        if (address(this) == self) revert UUPSUpgradeable__OnlyDelegateCall();\\n        if (_getImplementation() != self)\\n            revert UUPSUpgradeable__OnlyActiveProxy();\\n    }\\n\\n    function __checkDelegated() private view {\\n        if (address(this) != __self) revert UUPSUpgradeable__OnlyCall();\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/ProxyCheckerUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Revert error if call is made from a proxy contract\\n */\\nerror ProxyChecker__EOAUnallowed();\\n\\n/**\\n * @dev Revert error if call is made from an externally owned account\\n */\\nerror ProxyChecker__ProxyUnallowed();\\n\\n/**\\n * @title ProxyCheckerUpgradeable\\n * @dev Abstract contract for checking if a call was made by a proxy contract or an externally owned account.\\n */\\nabstract contract ProxyCheckerUpgradeable {\\n    modifier onlyEOA() {\\n        _onlyEOA(msg.sender);\\n        _;\\n    }\\n\\n    function _onlyEOA(address sender_) internal view {\\n        _onlyEOA(sender_, _txOrigin());\\n    }\\n\\n    function _onlyEOA(address msgSender_, address txOrigin_) internal pure {\\n        if (_isProxyCall(msgSender_, txOrigin_))\\n            revert ProxyChecker__ProxyUnallowed();\\n    }\\n\\n    function _onlyProxy(address sender_) internal view {\\n        if (!(_isProxyCall(sender_, _txOrigin()) || _isProxy(sender_)))\\n            revert ProxyChecker__EOAUnallowed();\\n    }\\n\\n    function _onlyProxy(address msgSender_, address txOrigin_) internal view {\\n        if (!(_isProxyCall(msgSender_, txOrigin_) || _isProxy(msgSender_)))\\n            revert ProxyChecker__EOAUnallowed();\\n    }\\n\\n    function _isProxyCall(\\n        address msgSender_,\\n        address txOrigin_\\n    ) internal pure returns (bool) {\\n        return msgSender_ != txOrigin_;\\n    }\\n\\n    function _isProxy(address caller_) internal view returns (bool) {\\n        return caller_.code.length != 0;\\n    }\\n\\n    function _txOrigin() internal view returns (address) {\\n        return tx.origin;\\n    }\\n\\n    uint256[50] private _gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/presets-upgradeable/base/interfaces/IManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IAuthority} from \\\"../../interfaces/IAuthority.sol\\\";\\n\\ninterface IManager {\\n    error Manager__Paused();\\n    error Manager__NotPaused();\\n    error Manager__AlreadySet();\\n    error Manager__Blacklisted();\\n    error Manager__Unauthorized();\\n    error Manager__RequestFailed();\\n    error Manager__InvalidArgument();\\n    error Manager__ExecutionFailed();\\n\\n    event AuthorityUpdated(\\n        address indexed operator,\\n        IAuthority indexed from,\\n        IAuthority indexed to\\n    );\\n    event RequestRoleCached(address indexed operator, bytes32 indexed role);\\n\\n    /**\\n     * @notice Updates the authority of this contract. This can only be done by an operator.\\n     * @param authority_ The new authority contract.\\n     * @dev The authority contract must allow this contract to have the role specified in the constructor.\\n     * @custom:throws Manager__AlreadySet if the new authority is the same as the current authority.\\n     * @custom:throws Manager__RequestFailed if the request to the new authority contract fails.\\n     */\\n    function updateAuthority(IAuthority authority_) external;\\n\\n    /**\\n     * @notice Returns the authority contract of this contract.\\n     * @return authority_ is The address of the authority contract.\\n     */\\n    function authority() external view returns (IAuthority authority_);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\n\\ninterface IPausableUpgradeable {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev Pauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Unpauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.\\n     */\\n    function unpause() external;\\n\\n    function paused() external view returns (bool isPaused);\\n}\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is\\n    ContextUpgradeable,\\n    IPausableUpgradeable\\n{\\n    uint256 private __paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        __paused = 1;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool isPaused) {\\n        assembly {\\n            isPaused := eq(2, sload(__paused.slot))\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) revert Pausable__Paused();\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) revert Pausable__NotPaused();\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual {\\n        _requireNotPaused();\\n        __paused = 2;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual {\\n        _requirePaused();\\n        __paused = 1;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    error AccessControl__Unauthorized();\\n    error AccessControl__RoleMissing(bytes32 role, address account);\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/interfaces/IBlacklistableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IBlacklistableUpgradeable {\\n    event UserStatusSet(\\n        address indexed operator,\\n        address indexed account,\\n        bool indexed isBlacklisted\\n    );\\n\\n    /**\\n     * @dev Set the status of an account to either blacklisted or not blacklisted.\\n     * @param account_ The address to change the status of.\\n     * @param status The new status for the address. True for blacklisted, false for not blacklisted.\\n     */\\n    function setUserStatus(address account_, bool status) external;\\n\\n    /**\\n     * @dev Check if an address is blacklisted.\\n     * @param account_ The address to check.\\n     * @return True if the address is blacklisted, false otherwise.\\n     */\\n    function isBlacklisted(address account_) external view returns (bool);\\n\\n    function areBlacklisted(\\n        address[] calldata accounts_\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/libraries/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Roles {\\n    bytes32 public constant PROXY_ROLE =\\n        0x77d72916e966418e6dc58a19999ae9934bef3f749f1547cde0a86e809f19c89b;\\n    bytes32 public constant SIGNER_ROLE =\\n        0xe2f4eaae4a9751e85a3e4a7b9587827a877f29914755229b07a7b2da98285f70;\\n    bytes32 public constant PAUSER_ROLE =\\n        0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a;\\n    bytes32 public constant MINTER_ROLE =\\n        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\\n    bytes32 public constant OPERATOR_ROLE =\\n        0x97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b929;\\n    bytes32 public constant UPGRADER_ROLE =\\n        0x189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e3;\\n    bytes32 public constant TREASURER_ROLE =\\n        0x3496e2e73c4d42b75d702e60d9e48102720b8691234415963a5a857b86425d07;\\n    bytes32 public constant FACTORY_ROLE =\\n        0xdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/libraries/ErrorHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nerror ErrorHandler__ExecutionFailed();\\n\\nlibrary ErrorHandler {\\n    function handleRevertIfNotSuccess(\\n        bool ok_,\\n        bytes memory revertData_\\n    ) internal pure {\\n        assembly {\\n            if iszero(ok_) {\\n                let revertLength := mload(revertData_)\\n                if iszero(iszero(revertLength)) {\\n                    // Start of revert data bytes. The 0x20 offset is always the same.\\n                    revert(add(revertData_, 0x20), revertLength)\\n                }\\n\\n                //  revert ErrorHandler__ExecutionFailed()\\n                mstore(0x00, 0xa94eec76)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC165Upgradeable} from \\\"./IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165CheckerUpgradeable {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant __INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(\\n                account,\\n                type(IERC165Upgradeable).interfaceId\\n            ) &&\\n            !supportsERC165InterfaceUnchecked(account, __INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        address account,\\n        bytes4 interfaceId\\n    ) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return\\n            supportsERC165(account) &&\\n            supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] calldata interfaceIds\\n    ) internal view returns (bool[] memory interfaceIdsSupported) {\\n        uint256 length = interfaceIds.length;\\n\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        interfaceIdsSupported = new bool[](length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i; i < length; ) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(\\n                    account,\\n                    interfaceIds[i]\\n                );\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(\\n        address account,\\n        bytes4[] calldata interfaceIds\\n    ) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) return false;\\n\\n        uint256 length = interfaceIds.length;\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i; i < length; ) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i]))\\n                return false;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(\\n        address account,\\n        bytes4 interfaceId\\n    ) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeCall(\\n            IERC165Upgradeable.supportsInterface,\\n            (interfaceId)\\n        );\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(\\n                30000,\\n                account,\\n                add(encodedParams, 0x20),\\n                mload(encodedParams),\\n                0x00,\\n                0x20\\n            )\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nerror Initializable__Initializing();\\nerror Initializable__NotInitializing();\\nerror Initializable__AlreadyInitialized();\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint256 private __initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    uint256 private __initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint256 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = __beforeInitialized();\\n        _;\\n        __afterInitialized(isTopLevelCall);\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        __beforeReinitialized(version);\\n        _;\\n        __afterReinitialized();\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        __checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        if (__initializing != 1) revert Initializable__Initializing();\\n        if (__initialized < 0xff) {\\n            __initialized = 0xff;\\n            emit Initialized(0xff);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8 version) {\\n        assembly {\\n            version := sload(__initialized.slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return __initializing == 2;\\n    }\\n\\n    function __checkInitializing() private view {\\n        if (__initializing != 2) revert Initializable__NotInitializing();\\n    }\\n\\n    function __beforeInitialized() private returns (bool isTopLevelCall) {\\n        isTopLevelCall = __initializing != 2;\\n        uint256 initialized = __initialized;\\n\\n        if (\\n            !((isTopLevelCall && initialized == 0) ||\\n                (initialized == 1 && address(this).code.length == 0))\\n        ) revert Initializable__AlreadyInitialized();\\n\\n        __initialized = 1;\\n        if (isTopLevelCall) __initializing = 2;\\n    }\\n\\n    function __afterInitialized(bool isTopLevelCall_) private {\\n        if (isTopLevelCall_) {\\n            __initializing = 1;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    function __beforeReinitialized(uint8 version) private {\\n        if (__initializing != 1 || __initialized >= version)\\n            revert Initializable__AlreadyInitialized();\\n        __initialized = version;\\n        __initializing = 2;\\n    }\\n\\n    function __afterReinitialized() private {\\n        __initializing = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/interfaces/IProtocolFeeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IProtocolFeeUpgradeable {\\n    /**\\n     * @dev Fee information structure\\n     */\\n    struct FeeInfo {\\n        address token;\\n        uint96 royalty;\\n    }\\n\\n    event ProtocolFeeUpdated(\\n        address indexed operator,\\n        address indexed payment,\\n        uint256 indexed royalty\\n    );\\n\\n    function setRoyalty(address token_, uint96 feeAmt_) external;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/FundForwarderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ContextUpgradeable\\n} from \\\"../oz-upgradeable/utils/ContextUpgradeable.sol\\\";\\n\\nimport {TransferableUpgradeable} from \\\"./TransferableUpgradeable.sol\\\";\\nimport {ProxyCheckerUpgradeable} from \\\"./ProxyCheckerUpgradeable.sol\\\";\\n\\nimport {\\n    IERC20Upgradeable,\\n    IERC721Upgradeable,\\n    IFundForwarderUpgradeable,\\n    IERC721EnumerableUpgradeable\\n} from \\\"./interfaces/IFundForwarderUpgradeable.sol\\\";\\n\\nimport {ErrorHandler} from \\\"../libraries/ErrorHandler.sol\\\";\\n\\n/**\\n * @title FundForwarderUpgradeable\\n * @dev Abstract contract for forwarding funds to a specified address.\\n */\\nabstract contract FundForwarderUpgradeable is\\n    ContextUpgradeable,\\n    ProxyCheckerUpgradeable,\\n    TransferableUpgradeable,\\n    IFundForwarderUpgradeable\\n{\\n    using ErrorHandler for bool;\\n\\n    /**\\n     * @dev Address to forward funds to\\n     */\\n    bytes32 private __vault;\\n\\n    /**\\n     * @dev Receives funds and forwards them to the vault address\\n     */\\n    receive() external payable virtual onlyEOA {\\n        address _vault = vault();\\n\\n        _safeNativeTransfer(_vault, msg.value, safeRecoverHeader());\\n\\n        emit Forwarded(_msgSender(), msg.value);\\n\\n        _afterRecover(_vault, address(0), msg.value, \\\"\\\");\\n    }\\n\\n    function __FundForwarder_init(\\n        address vault_\\n    ) internal virtual onlyInitializing {\\n        __FundForwarder_init_unchained(vault_);\\n    }\\n\\n    function __FundForwarder_init_unchained(\\n        address vault_\\n    ) internal virtual onlyInitializing {\\n        _changeVault(vault_);\\n    }\\n\\n    function recover(RecoveryCallData[] calldata calldata_) external virtual {\\n        _beforeRecover(\\\"\\\");\\n\\n        address _vault = vault();\\n        address sender = _msgSender();\\n        uint256 length = calldata_.length;\\n        bytes[] memory results = new bytes[](length);\\n\\n        bool ok;\\n        bytes memory result;\\n        for (uint256 i; i < length; ) {\\n            (ok, result) = calldata_[i].token.call{value: calldata_[i].value}(\\n                abi.encodePacked(calldata_[i].fnSelector, calldata_[i].params)\\n            );\\n\\n            ok.handleRevertIfNotSuccess(result);\\n\\n            results[i] = result;\\n\\n            _afterRecover(\\n                _vault,\\n                calldata_[i].token,\\n                calldata_[i].value,\\n                calldata_[i].params\\n            );\\n\\n            emit Recovered(\\n                sender,\\n                calldata_[i].token,\\n                calldata_[i].value,\\n                calldata_[i].params\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IFundForwarderUpgradeable\\n    function recoverNative() external virtual {\\n        _beforeRecover(\\\"\\\");\\n        address sender = _msgSender();\\n        _onlyEOA(sender);\\n\\n        address _vault = vault();\\n        uint256 balance = address(this).balance;\\n        _safeNativeTransfer(_vault, balance, safeRecoverHeader());\\n\\n        emit Recovered(sender, address(0), balance, \\\"\\\");\\n\\n        _afterRecover(_vault, address(0), balance, \\\"\\\");\\n    }\\n\\n    function vault() public view virtual returns (address vault_) {\\n        assembly {\\n            vault_ := sload(__vault.slot)\\n        }\\n\\n        _checkValidAddress(vault_);\\n    }\\n\\n    /**\\n     * @dev Changes the vault address\\n     * @param vault_ New vault address\\n     */\\n    function _changeVault(address vault_) internal virtual {\\n        _checkValidAddress(vault_);\\n\\n        assembly {\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"VaultUpdated(address,address,address)\\\")\\n                0x2afec66505e0ceed692012e3833f6609d4933ded34732135bc05f28423744065,\\n                caller(),\\n                sload(__vault.slot),\\n                vault_\\n            )\\n\\n            sstore(__vault.slot, vault_)\\n        }\\n    }\\n\\n    function safeRecoverHeader() public pure virtual returns (bytes memory);\\n\\n    function safeTransferHeader() public pure virtual returns (bytes memory);\\n\\n    function _beforeRecover(bytes memory data_) internal virtual;\\n\\n    function _afterRecover(\\n        address vault_,\\n        address token_,\\n        uint256 value_,\\n        bytes memory params_\\n    ) internal virtual;\\n\\n    /**\\n     *@dev Asserts that the given address is not the zero address\\n     *@param addr_ The address to check\\n     *@custom:throws FundForwarder__InvalidArgument if the address is the zero address\\n     */\\n    function _checkValidAddress(address addr_) internal view virtual {\\n        if (addr_ == address(0) || addr_ == address(this))\\n            revert FundForwarder__InvalidArgument();\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/presets-upgradeable/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ITreasury} from \\\"../../presets/interfaces/ITreasury.sol\\\";\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    error ERC20__Expired();\\n    error ERC20__StringTooLong();\\n    error ERC20__InvalidSignature();\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ECDSAUpgradeable, EIP712Upgradeable} from \\\"./EIP712Upgradeable.sol\\\";\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/interfaces/ISignableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface ISignableUpgradeable {\\n    error Signable__InvalidSignature();\\n\\n    event NonceIncremented(\\n        address indexed operator,\\n        bytes32 indexed id,\\n        uint256 indexed value\\n    );\\n\\n    /**\\n     * @dev Returns the domain separator for EIP712 v4\\n     * @return Domain separator for EIP712 v4\\n     */\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport {Initializable} from \\\"../utils/Initializable.sol\\\";\\n\\nimport {IBeaconUpgradeable} from \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport {\\n    IERC1822ProxiableUpgradeable\\n} from \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\n\\nimport {StorageSlotUpgradeable} from \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\n\\nerror ERC1967UpgradeUpgradeable__NonZeroAddress();\\nerror ERC1967UpgradeUpgradeable__ExecutionFailed();\\nerror ERC1967UpgradeUpgradeable__TargetIsNotContract();\\nerror ERC1967UpgradeUpgradeable__ImplementationIsNotUUPS();\\nerror ERC1967UpgradeUpgradeable__UnsupportedProxiableUUID();\\nerror ERC1967UpgradeUpgradeable__DelegateCallToNonContract();\\nerror ERC1967UpgradeUpgradeable__ImplementationIsNotContract();\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant __ROLLBACK_SLOT =\\n        0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return\\n            StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (!_isContract(newImplementation))\\n            revert ERC1967UpgradeUpgradeable__ImplementationIsNotContract();\\n        StorageSlotUpgradeable\\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\\n            .value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (forceCall || data.length > 0) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(__ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try\\n                IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID()\\n            returns (bytes32 slot) {\\n                if (slot != _IMPLEMENTATION_SLOT)\\n                    revert ERC1967UpgradeUpgradeable__UnsupportedProxiableUUID();\\n            } catch {\\n                revert ERC1967UpgradeUpgradeable__ImplementationIsNotUUPS();\\n            }\\n\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0))\\n            revert ERC1967UpgradeUpgradeable__NonZeroAddress();\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT =\\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (!_isContract(newBeacon))\\n            revert ERC1967UpgradeUpgradeable__TargetIsNotContract();\\n        if (!_isContract(IBeaconUpgradeable(newBeacon).implementation()))\\n            revert ERC1967UpgradeUpgradeable__ImplementationIsNotContract();\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes calldata data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (forceCall || data.length > 0) {\\n            _functionDelegateCall(\\n                IBeaconUpgradeable(newBeacon).implementation(),\\n                data\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(\\n        address target,\\n        bytes memory data\\n    ) private returns (bytes memory) {\\n        if (!_isContract(target))\\n            revert ERC1967UpgradeUpgradeable__DelegateCallToNonContract();\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata);\\n    }\\n\\n    function _isContract(address addr_) internal view returns (bool) {\\n        return addr_.code.length != 0;\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata\\n    ) internal pure returns (bytes memory) {\\n        if (success) return returndata;\\n        else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length != 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    revert(add(32, returndata), mload(returndata))\\n                }\\n            } else revert ERC1967UpgradeUpgradeable__ExecutionFailed();\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/presets-upgradeable/interfaces/IAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IAuthority} from \\\"../../presets/interfaces/IAuthority.sol\\\";\\n\"\r\n    },\r\n    \"src/oz-custom/internal-upgradeable/TransferableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Initializable} from \\\"../oz-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {\\n    IERC20Upgradeable\\n} from \\\"../oz-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nerror Transferable__TransferFailed();\\nerror Transferable__InvalidArguments();\\n\\n/**\\n * @dev Library for transferring Ether and tokens between accounts\\n */\\nabstract contract TransferableUpgradeable is Initializable {\\n    /**\\n     * @dev Reverts the transaction if the transfer fails\\n     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.\\n     * @param from_ Address to transfer from\\n     * @param to_ Address to transfer to\\n     * @param value_ Amount of tokens or Ether to transfer\\n     */\\n    function _safeTransferFrom(\\n        address token_,\\n        address from_,\\n        address to_,\\n        uint256 value_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, value_);\\n\\n        if (\\n            token_ == address(0)\\n                ? _nativeTransfer(to_, value_, data_)\\n                : _ERC20TransferFrom(\\n                    IERC20Upgradeable(token_),\\n                    from_,\\n                    to_,\\n                    value_\\n                )\\n        ) return;\\n\\n        revert Transferable__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Reverts the transaction if the transfer fails\\n     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.\\n     * @param to_ Address to transfer to\\n     * @param value_ Amount of tokens or Ether to transfer\\n     */\\n    function _safeTransfer(\\n        address token_,\\n        address to_,\\n        uint256 value_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, value_);\\n\\n        if (\\n            token_ == address(0)\\n                ? _nativeTransfer(to_, value_, data_)\\n                : _ERC20Transfer(IERC20Upgradeable(token_), to_, value_)\\n        ) return;\\n\\n        revert Transferable__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Reverts the transaction if the Ether transfer fails\\n     * @param to_ Address to transfer to\\n     * @param amount_ Amount of Ether to transfer\\n     */\\n    function _safeNativeTransfer(\\n        address to_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n        if (!_nativeTransfer(to_, amount_, data_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _safeERC20Transfer(\\n        IERC20Upgradeable token_,\\n        address to_,\\n        uint256 amount_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n        if (!_ERC20Transfer(token_, to_, amount_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _safeERC20TransferFrom(\\n        IERC20Upgradeable token_,\\n        address from_,\\n        address to_,\\n        uint256 amount_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n\\n        if (!_ERC20TransferFrom(token_, from_, to_, amount_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _nativeTransfer(\\n        address to_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal virtual returns (bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(\\n                gas(),\\n                to_,\\n                amount_,\\n                add(data_, 32),\\n                mload(data_),\\n                0,\\n                0\\n            )\\n        }\\n    }\\n\\n    function _ERC20Transfer(\\n        IERC20Upgradeable token_,\\n        address to_,\\n        uint256 value_\\n    ) internal virtual returns (bool success) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to_) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), value_) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n    }\\n\\n    function _ERC20TransferFrom(\\n        IERC20Upgradeable token_,\\n        address from_,\\n        address to_,\\n        uint256 value_\\n    ) internal virtual returns (bool success) {\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), from_)\\n            mstore(add(freeMemoryPointer, 36), to_)\\n            mstore(add(freeMemoryPointer, 68), value_)\\n\\n            success := and(\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n    }\\n\\n    function __checkValidTransfer(address to_, uint256 value_) private pure {\\n        if (value_ == 0 || to_ == address(0))\\n            revert Transferable__InvalidArguments();\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/presets/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface ITreasury {\\n    error Treasury__Expired();\\n    error Treasury__LengthMismatch();\\n    error Treasury__InvalidBalance();\\n    error Treasury__InvalidArgument();\\n    error Treasury__InvalidSignature();\\n    error Treasury__MistakenTransfer();\\n    error Treasury__InvalidTokenAddress();\\n    error Treasury__InvalidFunctionCall();\\n    error Treasury__UnauthorizedWithdrawal();\\n\\n    event BalanceInitiated(address indexed operator, uint256 indexed balance);\\n\\n    function withdraw(\\n        address token_,\\n        address to_,\\n        uint256 value_,\\n        uint256 amount_, // if withdraw ERC1155\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    ) external;\\n\\n    function nonces(address account_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/cryptography/EIP712Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {ECDSAUpgradeable} from \\\"./ECDSAUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n *\\n * @custom:storage-size 52\\n */\\nabstract contract EIP712Upgradeable is Initializable {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private _HASHED_NAME;\\n    bytes32 private _HASHED_VERSION;\\n\\n    ///@dev value is equal to keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 internal constant _TYPE_HASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    function __EIP712_init(\\n        string calldata name,\\n        string calldata version\\n    ) internal onlyInitializing {\\n        __EIP712_init_unchained(name, version);\\n    }\\n\\n    function __EIP712_init_unchained(\\n        string memory name,\\n        string memory version\\n    ) internal onlyInitializing {\\n        _HASHED_NAME = keccak256(bytes(name));\\n        _HASHED_VERSION = keccak256(bytes(version));\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return\\n            _buildDomainSeparator(\\n                _TYPE_HASH,\\n                _EIP712NameHash(),\\n                _EIP712VersionHash()\\n            );\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) internal view returns (bytes32 domainSeparatorV4) {\\n        assembly {\\n            let freeMemPtr := mload(0x40)\\n            mstore(freeMemPtr, typeHash)\\n            mstore(add(freeMemPtr, 0x20), nameHash)\\n            mstore(add(freeMemPtr, 0x40), versionHash)\\n            mstore(add(freeMemPtr, 0x60), chainid())\\n            mstore(add(freeMemPtr, 0x80), address())\\n            domainSeparatorV4 := keccak256(freeMemPtr, 160)\\n        }\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(\\n        bytes32 structHash\\n    ) internal view virtual returns (bytes32) {\\n        return\\n            ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712NameHash() internal view virtual returns (bytes32) {\\n        return _HASHED_NAME;\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712VersionHash() internal view virtual returns (bytes32) {\\n        return _HASHED_VERSION;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(\\n        bytes32 slot\\n    ) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(\\n        bytes32 slot\\n    ) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(\\n        bytes32 slot\\n    ) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(\\n        bytes32 slot\\n    ) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/presets/interfaces/IAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IAuthority {\\n    error Authority__InvalidRole();\\n    error Authority__LengthMismatch();\\n\\n    event VaultMultiUpdated(\\n        address indexed operator,\\n        address indexed vault,\\n        bool[] success\\n    );\\n\\n    event ProxyAccessGranted(address indexed operator, address indexed proxy);\\n\\n    /**\\n     * @dev Sets the admin of the specified role to the specified admin role.\\n     * @param role bytes32 representing the role to set the admin of\\n     * @param adminRole bytes32 representing the role to set as the admin of the role\\n     */\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\\n\\n    /**\\n     * @dev Allows a user to request access to the contract as a proxy.\\n     * Only callable by accounts with the OPERATOR_ROLE and only if the sender is a proxy of the caller.\\n     * Grants the PROXY_ROLE and the specified role to the sender.\\n     * @param role bytes32 representing the role to grant to the sender in addition to the PROXY_ROLE\\n     */\\n    function requestAccess(bytes32 role) external;\\n}\\n\"\r\n    },\r\n    \"src/oz-custom/oz-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (address result) {\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            // Directly load `s` from the calldata.\\n            let s := calldataload(add(signature.offset, 0x20))\\n\\n            switch signature.length\\n            case 64 {\\n                // Here, `s` is actually `vs` that needs to be recovered into `v` and `s`.\\n                // Compute `v` and store it in the scratch space.\\n                mstore(0x20, add(shr(255, s), 27))\\n                // prettier-ignore\\n                s := and(s, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            }\\n            case 65 {\\n                // Compute `v` and store it in the scratch space.\\n                mstore(\\n                    0x20,\\n                    byte(0, calldataload(add(signature.offset, 0x40)))\\n                )\\n            }\\n\\n            // If `s` in lower half order, such that the signature is not malleable.\\n            // prettier-ignore\\n            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {\\n                mstore(0x00, hash)\\n                calldatacopy(0x40, signature.offset, 0x20) // Directly copy `r` over.\\n                mstore(0x60, s)\\n                pop(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        0x01, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x40, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(sub(0x60, returndatasize()))\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address result) {\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            mstore(0x20, v)\\n            // If `s` in lower half order, such that the signature is not malleable.\\n            // prettier-ignore\\n            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {\\n                mstore(0x00, hash)\\n                mstore(0x40, r)\\n                mstore(0x60, s)\\n                pop(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        0x01, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x40, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(sub(0x60, returndatasize()))\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(\\n        bytes32 hash\\n    ) internal pure returns (bytes32 result) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        assembly {\\n            // Store into scratch space for keccak256.\\n            mstore(0x20, hash)\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            // 0x40 - 0x04 = 0x3c\\n            result := keccak256(0x04, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(\\n        bytes memory s\\n    ) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We need at most 128 bytes for Ethereum signed message header.\\n            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.\\n            // The length of \\\"\\\\x19Ethereum Signed Message:\\\\n\\\" is 26 bytes.\\n            // The next multiple of 32 above 78 + 26 is 128.\\n\\n            // Instead of allocating, we temporarily copy the 128 bytes before the\\n            // start of `s` data to some variables.\\n            let m3 := mload(sub(s, 0x60))\\n            let m2 := mload(sub(s, 0x40))\\n            let m1 := mload(sub(s, 0x20))\\n            // The length of `s` is in bytes.\\n            let sLength := mload(s)\\n\\n            let ptr := add(s, 0x20)\\n\\n            // `end` marks the end of the memory which we will compute the keccak256 of.\\n            let end := add(ptr, sLength)\\n\\n            // Convert the length of the bytes to ASCII decimal representation\\n            // and store it into the memory.\\n            for {\\n                let temp := sLength\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n            } temp {\\n                temp := div(temp, 10)\\n            } {\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n            }\\n\\n            // Move the pointer 32 bytes lower to make room for the string.\\n            // `start` marks the start of the memory which we will compute the keccak256 of.\\n            let start := sub(ptr, 32)\\n            // Copy the header over to the memory.\\n            mstore(\\n                start,\\n                \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n\\\"\\n            )\\n            start := add(start, 6)\\n\\n            // Compute the keccak256 of the memory.\\n            result := keccak256(start, sub(end, start))\\n\\n            // Restore the previous memory.\\n            mstore(s, sLength)\\n            mstore(sub(s, 0x20), m1)\\n            mstore(sub(s, 0x40), m2)\\n            mstore(sub(s, 0x60), m3)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(\\n        bytes32 domainSeparator,\\n        bytes32 structHash\\n    ) internal pure returns (bytes32 result) {\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(\\n                memPtr,\\n                0x1901000000000000000000000000000000000000000000000000000000000000\\n            ) // EIP191 header\\n            mstore(add(memPtr, 2), domainSeparator) // EIP712 domain hash\\n            mstore(add(memPtr, 34), structHash) // Hash of struct\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 66)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/\",\r\n      \"v2-core/=lib/v2-core/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BK721__ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BK721__Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BK721__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BK721__LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BK721__TokenNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BK721__Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967UpgradeUpgradeable__DelegateCallToNonContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967UpgradeUpgradeable__ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967UpgradeUpgradeable__ImplementationIsNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967UpgradeUpgradeable__ImplementationIsNotUUPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967UpgradeUpgradeable__UnsupportedProxiableUUID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Enumerable__ConsecutiveTransferNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Enumerable__GlobalIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Enumerable__OutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Permit__Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Permit__SelfApproving\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Rentable__NotValidTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Rentable__OnlyOwnerOrApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__AlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__NonZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__NotMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__UnsafeRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__WrongFrom\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FundForwarder__InvalidArgument\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Initializable__AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Initializable__NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__AlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__Blacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__InvalidArgument\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__RequestFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyChecker__ProxyUnallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RBK721__Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RBK721__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RBK721__Rented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSTORE2__DeploymentFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Signable__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StringLib__LengthInsufiicient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transferable__InvalidArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transferable__TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUpgradeable__OnlyActiveProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUpgradeable__OnlyCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUpgradeable__OnlyDelegateCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IAuthority\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IAuthority\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"}],\"name\":\"BatchMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nextId\",\"type\":\"uint256\"}],\"name\":\"BatchTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IBK721\",\"name\":\"forNFT\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"forTypeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"senderNFTIds\",\"type\":\"uint256[]\"}],\"name\":\"Exchanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Forwarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"from\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"Merged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NonceIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payment\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeemded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"RequestRoleCached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expires\",\"type\":\"uint64\"}],\"name\":\"UpdateUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"VaultUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"changeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBK721\",\"name\":\"forNFT_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"forAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forTypeId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"myIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"exchangeAssets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"forIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"royalty\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"name\":\"fixTokenIdTrackers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"approval\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"uint96\",\"name\":\"feeAmt_\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"feeToken_\",\"type\":\"address\"},{\"internalType\":\"contract IAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint248\",\"name\":\"wordPos_\",\"type\":\"uint248\"},{\"internalType\":\"uint256\",\"name\":\"mask_\",\"type\":\"uint256\"}],\"name\":\"invalidateNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"fromIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"toId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"merge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"metadataOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tos_\",\"type\":\"address[]\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"}],\"name\":\"nextIdFromType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce_\",\"type\":\"uint256\"}],\"name\":\"nonceBitMaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmap\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDirtied\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct IFundForwarderUpgradeable.RecoveryCallData[]\",\"name\":\"calldata_\",\"type\":\"tuple[]\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimer_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"redeemBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length_\",\"type\":\"uint256\"}],\"name\":\"safeMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"}],\"name\":\"safeMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length_\",\"type\":\"uint256\"}],\"name\":\"safeMintBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeRecoverHeader\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeTransferHeader\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeToken_\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeAmt_\",\"type\":\"uint96\"}],\"name\":\"setRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"expires_\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"setUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expires_\",\"type\":\"uint64\"}],\"name\":\"setUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tos_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"transferBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"typeIdTrackers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"updateAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"userExpires\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"userOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RBK721", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}