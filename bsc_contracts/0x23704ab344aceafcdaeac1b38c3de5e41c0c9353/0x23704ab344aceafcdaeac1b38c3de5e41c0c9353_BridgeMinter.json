{"SourceCode": "{\"contract-5cf96abae8.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\ncontract BridgeMinter {\\n    address owner = msg.sender;\\n    address WDNR = 0x7c2d95c6b4D51f824bd69239400f2156072a2c45;\\n\\n    mapping(uint256 =\\u003e bool) usedNonces;\\n\\n    constructor() payable {}\\n\\n    function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external {\\n        require(!usedNonces[nonce]);\\n        usedNonces[nonce] = true;\\n\\n        // this recreates the message that was signed on the client\\n        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));\\n\\n        require(recoverSigner(message, signature) == owner);\\n\\n        IERC20(WDNR).transfer(msg.sender, amount);\\n    }\\n\\n    /// reclaim the leftover funds.\\n    function shutdown() external {\\n        require(msg.sender == owner);\\n        IERC20 wdnr = IERC20(WDNR);\\n        wdnr.transfer(msg.sender, wdnr.balanceOf(address(this)));\\n    }\\n\\n    /// signature methods.\\n    function splitSignature(bytes memory sig)\\n        internal\\n        pure\\n        returns (uint8 v, bytes32 r, bytes32 s)\\n    {\\n        require(sig.length == 65);\\n\\n        assembly {\\n            // first 32 bytes, after the length prefix.\\n            r := mload(add(sig, 32))\\n            // second 32 bytes.\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes).\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        return (v, r, s);\\n    }\\n\\n    function recoverSigner(bytes32 message, bytes memory sig)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\\n\\n        return ecrecover(message, v, r, s);\\n    }\\n\\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claimPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BridgeMinter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f7857025d8cacec51d94f69fa9a01f973f946ecb2b18bd1171bf27cd194ec63"}