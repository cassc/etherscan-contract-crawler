{"SourceCode": "pragma solidity ^0.4.20;\r\n\r\n// \ud83d\ude38 WWW.SWAP.CAT \ud83d\ude38\r\n//\r\n// a simple DEX for fixed price token offers directly from wallet to wallet\r\n//\r\n// users can set up erc20 tokens for sale for any other erc20\r\n//\r\n// funds stay in users wallets, dex contract gets a spending allowance\r\n//\r\n// payments go directly into the sellers wallet\r\n//\r\n// this DEX takes no fees\r\n//\r\n// mostly useful to provide stablecoin liquidity or sell tokens for a premium\r\n//\r\n// offers have to be adjusted by the user if prices change\r\n//\r\n\r\n\r\n\r\n\r\n// we need the erc20 interface to access the tokens details\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    // no return value on transfer and transferFrom to tolerate old erc20 tokens\r\n    // we work around that in the buy function by checking balance twice\r\n    function transferFrom(address sender, address recipient, uint256 amount) external;\r\n    function transfer(address to, uint256 amount) external;\r\n    function decimals() external view returns (uint256);\r\n    function symbol() external view returns (string);\r\n    function name() external view returns (string);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract SWAPCAT {\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// lets make mappings to store offer data\r\n\r\n    mapping (uint24 => uint256) internal price;\r\n    mapping (uint24 => address) internal offertoken;\r\n    mapping (uint24 => address) internal buyertoken;\r\n    mapping (uint24 => address) internal seller;\r\n    uint24 internal offercount;\r\n\r\n\r\n// admin address, receives donations and can move stuck funds, nothing else    \r\n    address internal admin = 0xc965E082B0082449047501032F0E9e7F3DC5Cc12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// set up your erc20 offer. give token addresses and the price in baseunits\r\n// to change a price simply call this again with the changed price + offerid\r\n\r\nfunction makeoffer(address _offertoken, address _buyertoken, uint256 _price, uint24 _offerid) public returns (uint24) {\r\n\r\n// if no offerid is given a new offer is made, if offerid is given only the offers price is changed if owner matches\r\n        if(_offerid==0)\r\n                    {\r\n                    _offerid=offercount;\r\n                    offercount++;seller[_offerid]=msg.sender;\r\n                    offertoken[_offerid]=_offertoken;\r\n                    buyertoken[_offerid]=_buyertoken;\r\n                    }\r\n                    else\r\n                    {\r\n                    require(seller[_offerid]==msg.sender,\"only original seller can change offer!\");\r\n                    }\r\n        price[_offerid]=_price;\r\n\r\n// returns the offerid\r\n        return _offerid;\r\n    }\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// delete an offer\r\n\r\nfunction deleteoffer(uint24 _offerid) public returns (string) {\r\n        require(seller[_offerid]==msg.sender,\"only original seller can change offer!\");\r\n        delete seller[_offerid];\r\n        delete offertoken[_offerid];\r\n        delete buyertoken[_offerid];\r\n        delete price[_offerid];\r\n        return \"offer deleted\";\r\n    }\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// return the total number of offers to loop through all offers\r\n// its the web frontends job to keep track of offers\r\n\r\nfunction getoffercount() public view returns (uint24){ return offercount-1;}\r\n\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// get a tokens name, symbol and decimals \r\n\r\n    function tokeninfo(address _tokenaddr) public view returns (uint256, string, string) {\r\n        IERC20 tokeni = IERC20(_tokenaddr);\r\n        return (tokeni.decimals(),tokeni.symbol(),tokeni.name());\r\n        }   \r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// get a single offers details\r\n\r\n    function showoffer(uint24 _offerid) public view returns (address, address, address, uint256, uint256) {\r\n        \r\n\r\n        IERC20 offertokeni = IERC20(offertoken[_offerid]);\r\n\r\n\r\n// get offertokens balance and allowance, whichever is lower is the available amount        \r\n        uint256 availablebalance = offertokeni.balanceOf(seller[_offerid]);\r\n        uint256 availableallow = offertokeni.allowance(seller[_offerid],address(this));\r\n\r\n        if(availableallow<availablebalance){availablebalance = availableallow;}\r\n\r\n        return (offertoken[_offerid],buyertoken[_offerid],seller[_offerid],price[_offerid],availablebalance);\r\n        \r\n    }   \r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// return the price in buyertokens for the specified amount of offertokens\r\n\r\nfunction pricepreview(uint24 _offerid, uint256 _amount) public view returns (uint256) {\r\n        IERC20 offertokeni = IERC20(offertoken[_offerid]);\r\n        return  _amount * price[_offerid] / (uint256(10) ** offertokeni.decimals())+1;\r\n    }\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// return the amount in offertokens for the specified amount of buyertokens, for debugging\r\n\r\n//function pricepreviewreverse(uint24 _offerid, uint256 _amount) public view returns (uint256) {\r\n//        IERC20 offertokeni = IERC20(offertoken[_offerid]);\r\n//        return  _amount * (uint256(10) ** offertokeni.decimals()) / price[_offerid];\r\n//    }\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// the actual exchange function\r\n// the buyer must bring the price correctly to ensure no frontrunning / changed offer\r\n// if the offer is changed in meantime, it will not execute\r\n\r\nfunction buy(uint24 _offerid, uint256 _offertokenamount, uint256 _price) public returns (string) {\r\n\r\n        IERC20 offertokeninterface = IERC20(offertoken[_offerid]);\r\n        IERC20 buyertokeninterface = IERC20(buyertoken[_offerid]);\r\n\r\n\r\n// given price is being checked with recorded data from mappings\r\n       require(price[_offerid] == _price,\"offer price wrong\");\r\n\r\n\r\n// calculate the price of the order\r\n        uint256 buyertokenAmount =  _offertokenamount * _price / (uint256(10) ** offertokeninterface.decimals())+1;\r\n\r\n\r\n////// these 4 checks have been spared out since the final check suffices, this save ~50000 gas\r\n////        // check if the buyers allowance and balance are right\r\n////                require(buyertokeninterface.allowance(msg.sender, address(this)) >= buyertokenAmount, \"Check the buyers token allowance\");\r\n////                require(buyertokeninterface.balanceOf(msg.sender) >= buyertokenAmount,\"buyer not enough to pay\");\r\n////        // check if the sellers allowance and balance are right        \r\n////                require(offertokeninterface.allowance(seller[_offerid], address(this)) >= _offertokenamount, \"Check the sellers token allowance\");\r\n////                require(offertokeninterface.balanceOf(seller[_offerid]) >= _offertokenamount,\"seller not enough on stock\");\r\n  \r\n        \r\n// some old erc20 tokens give no return value so we must work around by getting their balance before and after the exchange        \r\n        uint256 oldbuyerbalance = buyertokeninterface.balanceOf(msg.sender);\r\n        uint256 oldsellerbalance = offertokeninterface.balanceOf(seller[_offerid]);\r\n\r\n\r\n// finally do the exchange        \r\n        buyertokeninterface.transferFrom(msg.sender,seller[_offerid], buyertokenAmount);\r\n        offertokeninterface.transferFrom(seller[_offerid],msg.sender,_offertokenamount);\r\n\r\n\r\n// now check if the balances changed on both accounts.\r\n// we do not check for exact amounts since some tokens behave differently with fees, burnings, etc\r\n// we assume if both balances are higher than before all is good\r\n        require(oldbuyerbalance > buyertokeninterface.balanceOf(msg.sender),\"buyer error\");\r\n        require(oldsellerbalance > offertokeninterface.balanceOf(seller[_offerid]),\"seller error\");\r\n        return \"tokens exchanged. ENJOY!\";\r\n    }\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// in case someone wrongfully directly sends erc20 to this contract address, the admin can move them out\r\nfunction losttokens(address token) public {\r\n        IERC20 tokeninterface = IERC20(token);\r\n        tokeninterface.transfer(admin,tokeninterface.balanceOf(address(this)));\r\n}\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// straight ether payments to this contract are considered donations. thank you!\r\nfunction () public payable {admin.transfer(address(this).balance);        }\r\n//\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenaddr\",\"type\":\"address\"}],\"name\":\"tokeninfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"losttokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offerid\",\"type\":\"uint24\"}],\"name\":\"deleteoffer\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offertoken\",\"type\":\"address\"},{\"name\":\"_buyertoken\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_offerid\",\"type\":\"uint24\"}],\"name\":\"makeoffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_offerid\",\"type\":\"uint24\"}],\"name\":\"showoffer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_offerid\",\"type\":\"uint24\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pricepreview\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offerid\",\"type\":\"uint24\"},{\"name\":\"_offertokenamount\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getoffercount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "SWAPCAT", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b088d9bf973f3dcbd9bb8f46440b7deed70730b363a6daa0daf08e942a5e209e"}