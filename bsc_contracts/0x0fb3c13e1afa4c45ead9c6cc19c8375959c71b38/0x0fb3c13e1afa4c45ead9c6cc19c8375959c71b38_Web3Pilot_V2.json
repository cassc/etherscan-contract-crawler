{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.18;\r\n\r\ncontract Web3Pilot_V2 {\r\n\r\n    IBEP20 public donationToken;\r\n    IVault public vault;\r\n    address public dev;\r\n    address public owner;\r\n    bool public paused;\r\n\r\n    uint256 public constant MAX_LEVEL = 10;\r\n    uint256 public constant REFERRAL_BONUS_PERCENT = 10; //1%\r\n    uint256 public constant TAX_PERCENT = 100; //10%\r\n    uint256 public constant PRECISION = 1000;\r\n\r\n    uint256 public withdrawalTimeLimit = 1 days;\r\n    uint256 public dailyMaxWithdrawable = 60 ether;\r\n    uint256 public minWithdrawal = 10 ether;\r\n    uint256 public withdrawalTax = 100; //10%\r\n\r\n    uint256[MAX_LEVEL] public levelEntryAmount = [10 ether, 10 ether, 20 ether, 25 ether, 30 ether, 35 ether, 40 ether, 45 ether, 50 ether, 55 ether];\r\n  uint256[MAX_LEVEL] public levelEarningAmount = [16 ether, 24 ether, 32 ether, 40 ether, 44 ether, 48 ether, 52 ether, 56 ether, 58 ether, 200 ether];\r\n       uint256[MAX_LEVEL] public levelCapacity = [10000 ether, 15000 ether, 5000 ether, 5000 ether, 5000 ether, 5000 ether, 5000 ether, 5000 ether, 5000 ether, 5000 ether];\r\n    \r\n    mapping(address => bool) public isAdmin;\r\n    uint256 private immutable uncertaintyGuard;\r\n\r\n    // Events\r\n    event Deposited(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event Upgraded(address indexed user, uint256 level);\r\n    event ReferralRewarded(address indexed referrer, address indexed referee, uint256 amount);\r\n    event EmergencyWithdrawal(address indexed owner, uint256 amount);\r\n    event ReferralBonusSent(address indexed user, uint256 bonusAmount);\r\n\r\n     // Hardcoded founders' addresses and their share percentages\r\n    address[7] private founders = [\r\n        0xa43aC8661ca47c19c6CD438bDF102534Aa856513,\r\n        0x5f26c28A02dc012F3ac70256C4342D807928d0Bf,\r\n        0x12A1479620529566cd53D4cfec7B6f4C24EE0c68,\r\n        0xAdeF1Dd9c2Ad269A6517aD49b6B3A36B5b2B801f,\r\n        0xeD907194Bd42952A5a0aa0b289Bba8bDb506c036,\r\n        0xA13Ae3478F290e8F0D14b99Da3B2FDC066b4A444,\r\n        0x30C039581214393CDf222e02e3e22ab77c969edd\r\n    ];\r\n    uint16[7] private shares = [350, 165, 200, 45, 45, 45, 150]; \r\n\r\n    modifier onlyDev() {\r\n        require(dev == msg.sender, \"Caller is not dev\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Platform paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"Platform not paused\");\r\n        _;\r\n    }\r\n\r\n    bool private reentrancySafe = false;\r\n    modifier nonReentrant() {\r\n        require(!reentrancySafe, \"Reentrant call\");\r\n        reentrancySafe = true;\r\n        _;\r\n        reentrancySafe = false;\r\n    }\r\n\r\n    constructor(address _donationToken, address _vault, uint256 _uncertintyGuard) {\r\n        donationToken = IBEP20(_donationToken); //BUSD(USDT) mainnet\r\n        vault = IVault(_vault);\r\n        uncertaintyGuard = _uncertintyGuard;\r\n        dev = msg.sender;\r\n        isAdmin[msg.sender] = true;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //////     EXTERNAL FUNCTIONS      /////\r\n    ////////////////////////////////////////\r\n\r\n    function donate(address _referrer) external whenNotPaused nonReentrant {\r\n        address msgSender =  msg.sender;\r\n        uint8 levelIndex = 0;\r\n        uint256 donationAmount = levelEntryAmount[levelIndex];\r\n        uint256 userEarning = levelEarningAmount[levelIndex];\r\n        \r\n        IVault.User memory user = getUser(msgSender);\r\n        IVault.Level memory level = getLevel(levelIndex);\r\n\r\n        require(!user.exists, \"User exists\");\r\n        require(getAllowance(msgSender) >= donationAmount, \"Insufficient allowance\");\r\n        require(IBEP20(donationToken).transferFrom(msgSender, address(this), donationAmount), \"Token donation failed\");\r\n        \r\n        _createDonation(level.donationsIndex, levelIndex, msgSender, donationAmount, userEarning, block.timestamp);\r\n        _updateLevel(levelIndex, (level.balance+donationAmount), (level.donationsIndex+1), level.payoutsIndex, (level.totalDonated+donationAmount), level.totalPaidOut);\r\n        \r\n        IVault.User memory referrer = getUser(_referrer);\r\n\r\n        if(_referrer != address(0) && _referrer != msg.sender && referrer.exists){\r\n            uint256 referralBonus = _percentageOfValue(donationAmount, REFERRAL_BONUS_PERCENT);\r\n\r\n        //_updateUser(msgSender, levelIndex, donationAmount, 0, 0, _referrer, 0, 0, 0, 0, 0, true, true);\r\n        User memory userStruct = User({\r\n            level: levelIndex,\r\n            donationBalance: donationAmount, \r\n            withdrawableBalance: 0, \r\n            totalDownlines: 0, \r\n            referrer: _referrer,\r\n            referralBonus: 0, \r\n            referralBonusWithdrawn: 0,\r\n            totalEarned: 0, \r\n            totalWithdrawn: 0, \r\n            nextWithdrawTime: 0, \r\n            isAwaitingTurn: true, \r\n            exists: true\r\n        });\r\n        _updateUser(msgSender, userStruct);\r\n\r\n        User memory userStruct2 = User({\r\n            level: referrer.level,\r\n            donationBalance: referrer.donationBalance, \r\n            withdrawableBalance: referrer.withdrawableBalance, \r\n            totalDownlines: referrer.totalDownlines + 1, \r\n            referrer: referrer.referrer,\r\n            referralBonus: referrer.referralBonus + referralBonus, \r\n            referralBonusWithdrawn: referrer.referralBonusWithdrawn,\r\n            totalEarned: referrer.totalEarned, \r\n            totalWithdrawn: referrer.totalWithdrawn, \r\n            nextWithdrawTime: referrer.nextWithdrawTime, \r\n            isAwaitingTurn: referrer.isAwaitingTurn, \r\n            exists: referrer.exists\r\n        });\r\n        _updateUser(_referrer, userStruct2);\r\n        \r\n        }else{\r\n\r\n            User memory userStruct3 = User({\r\n                level: levelIndex,\r\n                donationBalance: donationAmount, \r\n                withdrawableBalance: 0, \r\n                totalDownlines: 0, \r\n                referrer: address(0),\r\n                referralBonus: 0, \r\n                referralBonusWithdrawn: 0,\r\n                totalEarned: 0, \r\n                totalWithdrawn: 0, \r\n                nextWithdrawTime: 0, \r\n                isAwaitingTurn: true, \r\n                exists: true\r\n            });\r\n            _updateUser(msgSender, userStruct3);\r\n        }\r\n\r\n        vault.incrementPlatformUsers();\r\n        vault.updatePlatformDonated(donationAmount);\r\n        vault.updateUserLevelCount(levelIndex, true); //increment users\r\n\r\n        _settleAndUpgradeFrontUserInternal(levelIndex);\r\n    }\r\n\r\n    function upgrade() external whenNotPaused nonReentrant {\r\n        address msgSender =  msg.sender;\r\n\r\n        IVault.User memory user = getUser(msgSender);\r\n\r\n        require(user.exists, \"User does not exist\");\r\n        require(!user.isAwaitingTurn, \"User is in a queue\");\r\n\r\n        //uint8 usersCurrentLevel = user.level;\r\n        uint8 usersNewLevel;\r\n        \r\n        if(user.level == (MAX_LEVEL - 1)){ // Reset user to [0] (level 1)\r\n            usersNewLevel = 0;\r\n        }else{\r\n            usersNewLevel = user.level + 1;\r\n        }\r\n\r\n        uint256 newLevelDonationsAmount = levelEntryAmount[usersNewLevel];\r\n        uint256 newLevelExpected = levelEarningAmount[usersNewLevel];\r\n\r\n        require(getAllowance(msgSender) >= newLevelDonationsAmount, \"Insufficient allowance\");\r\n        require(IBEP20(donationToken).transferFrom(msgSender, address(this), newLevelDonationsAmount), \"Token donation failed\");\r\n        \r\n        //Fetch user's new level\r\n        IVault.Level memory newLevel = getLevel(usersNewLevel);\r\n\r\n        //Create donations in new level\r\n        _createDonation(newLevel.donationsIndex, usersNewLevel, msgSender, newLevelDonationsAmount, newLevelExpected, block.timestamp);\r\n\r\n        //Upgrade user to new level\r\n        User memory userStruct = User({\r\n            level: usersNewLevel,\r\n            donationBalance: newLevelDonationsAmount, \r\n            withdrawableBalance: user.withdrawableBalance, \r\n            totalDownlines: user.totalDownlines, \r\n            referrer: user.referrer,\r\n            referralBonus: user.referralBonus, \r\n            referralBonusWithdrawn: user.referralBonusWithdrawn,\r\n            totalEarned: user.totalEarned, \r\n            totalWithdrawn: user.totalWithdrawn, \r\n            nextWithdrawTime: user.nextWithdrawTime, \r\n            isAwaitingTurn: true, \r\n            exists: user.exists\r\n        });\r\n        _updateUser(msgSender, userStruct);\r\n        \r\n        //Reward referrer (if exists)\r\n        _sendReferralBonus(user.referrer, _percentageOfValue(newLevelDonationsAmount, REFERRAL_BONUS_PERCENT));\r\n        _distributeToFounders(_percentageOfValue(newLevelDonationsAmount, TAX_PERCENT));\r\n\r\n       //update the level user just entered\r\n        _updateLevel(usersNewLevel, (newLevel.balance+newLevelDonationsAmount), (newLevel.donationsIndex+1), newLevel.payoutsIndex, (newLevel.totalDonated+newLevelDonationsAmount), newLevel.totalPaidOut);\r\n\r\n        vault.updatePlatformDonated(newLevelDonationsAmount);\r\n        vault.updateUserLevelCount(user.level, false); //decrement user count\r\n        vault.updateUserLevelCount(usersNewLevel, true); //increment user count\r\n\r\n        _settleAndUpgradeFrontUserInternal(usersNewLevel);\r\n    }\r\n\r\n    function withdraw(uint256 _withdrawalAmount) external whenNotPaused nonReentrant {\r\n        address msgSender =  msg.sender;\r\n        \r\n        IVault.User memory user = getUser(msgSender);\r\n        uint256 balance = user.withdrawableBalance;\r\n        \r\n        require(_withdrawalAmount > 0, \"Withdraw more than zero\");\r\n        require(_withdrawalAmount >= minWithdrawal, \"Withdraw more than miniumum\");\r\n        require(_withdrawalAmount <= dailyMaxWithdrawable, \"Withdraw less than daily max\");\r\n        require(balance >= _withdrawalAmount, \"Insuffecient balance\");\r\n\r\n        //Zero(0) for first time withdrawal \r\n        require(user.nextWithdrawTime == 0 || user.nextWithdrawTime < block.timestamp, \"Wait for next withdrawal time\");\r\n            User memory userStruct = User({\r\n                level: user.level,\r\n                donationBalance: user.donationBalance, \r\n                withdrawableBalance: balance - _withdrawalAmount, \r\n                totalDownlines: user.totalDownlines, \r\n                referrer: user.referrer,\r\n                referralBonus: user.referralBonus, \r\n                referralBonusWithdrawn: user.referralBonusWithdrawn,\r\n                totalEarned: user.totalEarned, \r\n                totalWithdrawn: user.totalWithdrawn + balance, \r\n                nextWithdrawTime: block.timestamp + withdrawalTimeLimit, \r\n                isAwaitingTurn: user.isAwaitingTurn, \r\n                exists: user.exists\r\n            });\r\n            _updateUser(msgSender, userStruct);\r\n\r\n        uint256 tax = _percentageOfValue(_withdrawalAmount, withdrawalTax);\r\n\r\n        _sendDonationToken(msgSender, _withdrawalAmount - tax);\r\n        _distributeToFounders(tax);\r\n\r\n        vault.updatePlatformPaidOut(_withdrawalAmount);\r\n\r\n        emit Withdrawn(msgSender, balance);\r\n    }\r\n\r\n    function settleAndUpgradeFrontUser(uint8 _levelIndex) external {\r\n        require(isAdmin[msg.sender], \"Caller is not an admin\");\r\n        _settleAndUpgradeFrontUserInternal(_levelIndex);\r\n    }\r\n\r\n    function withdrawReferralReward(uint256 _amount) external whenNotPaused nonReentrant {\r\n        address msgSender = msg.sender;\r\n\r\n        IVault.User memory user = getUser(msgSender);\r\n        uint256 bonus = user.referralBonus;\r\n\r\n        require(_amount > 0, \"Can not claim zero\");\r\n        require(bonus > 0, \"No bonus to withdraw\");\r\n        require(bonus >= _amount, \"Insuffecient bonus\");\r\n\r\n        //_updateUser(msgSender, user.level, user.donationBalance, user.withdrawableBalance, user.totalDownlines, user.referrer, newBonus, user.referralBonusWithdrawn+bonus, user.totalEarned, user.totalWithdrawn, user.nextWithdrawTime, user.isAwaitingTurn, user.exists);\r\n        User memory userStruct = User({\r\n            level: user.level,\r\n            donationBalance: user.donationBalance, \r\n            withdrawableBalance: user.withdrawableBalance, \r\n            totalDownlines: user.totalDownlines, \r\n            referrer: user.referrer,\r\n            referralBonus: bonus - _amount, \r\n            referralBonusWithdrawn: user.referralBonusWithdrawn + _amount,\r\n            totalEarned: user.totalEarned, \r\n            totalWithdrawn: user.totalWithdrawn, \r\n            nextWithdrawTime: user.nextWithdrawTime, \r\n            isAwaitingTurn: user.isAwaitingTurn, \r\n            exists: user.exists\r\n        });\r\n\r\n        _updateUser(msgSender, userStruct);\r\n        _sendDonationToken(msgSender, _amount);\r\n        vault.updatePlatformPaidOut(_amount);\r\n    }\r\n\r\n    function updateWithdrawalTimeLimit(uint256 _newTimeLimit) external onlyOwner {\r\n        withdrawalTimeLimit = _newTimeLimit;\r\n    }\r\n\r\n    function updateDailyMaxWithdrawable(uint256 _newDailyLimit) external onlyOwner {\r\n        dailyMaxWithdrawable = _newDailyLimit;\r\n    }\r\n\r\n    function updateDailyMinWithdrawal(uint256 _newMinWithdrawal) external onlyOwner {\r\n        minWithdrawal = _newMinWithdrawal;\r\n    }\r\n\r\n    function updatelevelEntryAmountAll(uint256[] calldata entryValues) external onlyOwner {\r\n        require(entryValues.length == levelEntryAmount.length, \"Improper entryValues length\");\r\n\r\n        for(uint i = 0; i < entryValues.length; i++){\r\n            levelEntryAmount[i] = entryValues[i];\r\n        }\r\n    }\r\n\r\n    function updatelevelEarningAmountAll(uint256[] calldata earningValues) external onlyOwner {\r\n        require(earningValues.length == levelEntryAmount.length, \"Improper earningValues length\");\r\n\r\n        for(uint i = 0; i < earningValues.length; i++){\r\n            levelEarningAmount[i] = earningValues[i];\r\n        }\r\n    }\r\n\r\n    function updateLevelCapacityAll(uint256[] calldata _capacityValues) external onlyOwner {\r\n        require(_capacityValues.length == levelCapacity.length, \"Improper capacityValues length\");\r\n\r\n        for(uint i = 0; i < _capacityValues.length; i++){\r\n            levelCapacity[i] = _capacityValues[i];\r\n        }\r\n    }\r\n\r\n    function updatelevelEntryAmountSingle(uint8 earningIndex, uint256 _newEarningValue) external onlyOwner {\r\n        levelEntryAmount[earningIndex] = _newEarningValue;\r\n    }\r\n\r\n    function updatelevelEarningAmountSingle(uint8 earningIndex, uint256 _newEEarningValue) external onlyOwner {\r\n        levelEarningAmount[earningIndex] = _newEEarningValue;\r\n    }\r\n\r\n    function updateLevelCapacitySingle(uint8 capacityIndex, uint256 _newLevelCapacityValue) external onlyOwner {\r\n        levelCapacity[capacityIndex] = _newLevelCapacityValue;\r\n    }\r\n\r\n    function addAdmins(address[] calldata _newAdmins) external onlyOwner {\r\n        require(isAdmin[msg.sender], \"Caller is not an admin\");\r\n\r\n        for(uint i = 0; i < _newAdmins.length; i++){\r\n            isAdmin[_newAdmins[i]] = true;\r\n        }\r\n    }\r\n\r\n    function removeAdmins(address[] calldata _oldAdmins) external onlyOwner  {\r\n        require(isAdmin[msg.sender], \"Caller is not an admin\");\r\n\r\n        for(uint i = 0; i < _oldAdmins.length; i++){\r\n            isAdmin[_oldAdmins[i]] = false;\r\n        }\r\n    }\r\n\r\n    // Owner can withdraw the contract's funds in case of an emergency\r\n    function emergencyWithdraw(address _token, address _to) external onlyOwner {\r\n        uint256 balance = IBEP20(_token).balanceOf(address(this));\r\n\r\n        require(balance > 0, \"No funds to withdraw\");\r\n        require(IBEP20(_token).transfer(_to, balance), \"Emergency withdrawal failed\");\r\n\r\n        emit EmergencyWithdrawal(_to, balance);\r\n    }\r\n\r\n    function changeDev(address _newDev) external onlyDev {\r\n        dev = _newDev;\r\n    }\r\n\r\n    function updateVault(address _newVault) external onlyDev {\r\n        vault = IVault(_newVault);\r\n    }\r\n\r\n    function pause() external onlyOwner whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unPause() external onlyOwner whenPaused {\r\n        paused = false;\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //////     PUBLIC FUNCTIONS        /////\r\n    ////////////////////////////////////////\r\n    \r\n    function getAllowance(address _user) public view returns(uint256){\r\n        return donationToken.allowance(_user, address(this));\r\n    }\r\n\r\n    function getUser(address _user) public view returns(IVault.User memory) {\r\n        (\r\n            uint8 level,\r\n            uint256 donationBalance,\r\n            uint256 withdrawableBalance,\r\n            uint256 totalDownlines,\r\n            address referrer,\r\n            uint256 referralBonus,\r\n            uint256 referralBonusWithdrawn,\r\n            uint256 totalEarned,\r\n            uint256 totalWithdrawn,\r\n            uint256 nextWithdrawTime,\r\n            bool isAwaitingTurn,\r\n            bool exists\r\n        ) = vault.getUser(_user);\r\n\r\n        return IVault.User(\r\n            level,\r\n            donationBalance,\r\n            withdrawableBalance,\r\n            totalDownlines,\r\n            referrer,\r\n            referralBonus,\r\n            referralBonusWithdrawn,\r\n            totalEarned,\r\n            totalWithdrawn,\r\n            nextWithdrawTime,\r\n            isAwaitingTurn,\r\n            exists\r\n        );\r\n    }\r\n\r\n    function getLevel(uint8 _levelIndex) public view returns(IVault.Level memory) {\r\n        (\r\n            uint256 balance,\r\n            uint256 donationsIndex,\r\n            uint256 payoutsIndex,\r\n            uint256 totalDonated,\r\n            uint256 totalPaidOut\r\n        ) = vault.getLevel(_levelIndex);\r\n\r\n        return IVault.Level(\r\n            balance,\r\n            donationsIndex,\r\n            payoutsIndex,\r\n            totalDonated,\r\n            totalPaidOut\r\n        );\r\n    }\r\n\r\n    function getDonation(uint256 _donationIndex) public view returns(IVault.Donations memory) {\r\n        (\r\n            uint8 levelIndex,\r\n            address donorAddress,\r\n            uint256 donationAmount,\r\n            uint256 expectedEarning,\r\n            uint256 donationTime\r\n        ) = vault.getDonation(_donationIndex);\r\n\r\n        return IVault.Donations(\r\n            levelIndex,\r\n            donorAddress,\r\n            donationAmount,\r\n            expectedEarning,\r\n            donationTime\r\n        );\r\n    }\r\n    \r\n    function getPlatformUsers() public view returns(uint256){        \r\n        return vault.getPlatformUsers();\r\n    }\r\n\r\n    function getPlatformDonated() public view returns(uint256){        \r\n        return vault.getPlatformDonated();\r\n    }\r\n\r\n    function getPlatformPaidOut() public view returns(uint256){        \r\n        return vault.getPlatformPaidOut();\r\n    }\r\n\r\n    function getLevelUsers(uint8 _levelIndex) public view returns(uint256){\r\n        return vault.getLevelUsers(_levelIndex);\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //////     INTERNAL FUNCTIONS      /////\r\n    ////////////////////////////////////////\r\n\r\n    function _settleAndUpgradeFrontUserInternal(uint8 _levelIndex) internal {\r\n\r\n        IVault.Level memory level = getLevel(_levelIndex);\r\n        uint256 payoutsIndex = level.payoutsIndex;\r\n\r\n        IVault.Donations memory donation = getDonation(payoutsIndex);\r\n        IVault.User memory user = getUser(donation.donorAddress);\r\n\r\n        if(level.balance >= levelCapacity[donation.levelIndex] && donation.donationAmount > 0){\r\n\r\n            uint256 expected = donation.expectedEarning;\r\n\r\n            User memory userStruct = User({\r\n                level: user.level,\r\n                donationBalance: 0, \r\n                withdrawableBalance: user.withdrawableBalance + expected, \r\n                totalDownlines: user.totalDownlines, \r\n                referrer: user.referrer,\r\n                referralBonus: user.referralBonus, \r\n                referralBonusWithdrawn: user.referralBonusWithdrawn, \r\n                totalEarned: user.totalEarned + expected,\r\n                totalWithdrawn: user.totalWithdrawn, \r\n                nextWithdrawTime: user.nextWithdrawTime, \r\n                isAwaitingTurn: false, \r\n                exists: user.exists\r\n            });\r\n\r\n            _updateUser(donation.donorAddress, userStruct);\r\n            _updateLevel(_levelIndex, (level.balance - expected), level.donationsIndex, (level.payoutsIndex + 1), level.totalDonated, (level.totalPaidOut + expected));\r\n\r\n            vault.deleteDonation(payoutsIndex);\r\n        }\r\n    }\r\n\r\n    function _sendDonationToken(address _to, uint256 _amount) internal {\r\n        IBEP20(donationToken).transfer(_to, _amount);\r\n    }\r\n\r\n    function _distributeToFounders(uint256 _amount) internal {\r\n        for(uint i = 0; i < founders.length; i++){\r\n            address founderAddress = founders[i];\r\n            uint256 share = _percentageOfValue(_amount, shares[i]);\r\n            _sendDonationToken(founderAddress, share);\r\n        }\r\n    }\r\n\r\n    function _handleNewReferral(address _referrer) internal {\r\n        IVault.User memory referrer = getUser(_referrer);\r\n\r\n        if(_referrer != address(0) && _referrer != msg.sender && referrer.exists){\r\n\r\n            uint256 userEarning = levelEarningAmount[0];\r\n            uint256 referralBonus = _percentageOfValue(userEarning, REFERRAL_BONUS_PERCENT);\r\n\r\n            //Update user downline count and update referral bonus amount\r\n\r\n            User memory userStruct = User({\r\n                level: referrer.level,\r\n                donationBalance: referrer.donationBalance, \r\n                withdrawableBalance: referrer.withdrawableBalance, \r\n                totalDownlines: referrer.totalDownlines + 1, \r\n                referrer: referrer.referrer,\r\n                referralBonus: (referrer.referralBonus + referralBonus), \r\n                referralBonusWithdrawn: referrer.referralBonusWithdrawn, \r\n                totalEarned: referrer.totalEarned, \r\n                totalWithdrawn: referrer.totalWithdrawn, \r\n                nextWithdrawTime: referrer.nextWithdrawTime, \r\n                isAwaitingTurn: referrer.isAwaitingTurn, \r\n                exists: referrer.exists\r\n            });\r\n\r\n            _updateUser(_referrer, userStruct);\r\n        }\r\n    }\r\n\r\n    function _sendReferralBonus(address _to, uint256 _bonusAmount) internal {\r\n\r\n        if(_to != address(0)){\r\n            IVault.User memory user = getUser(_to);\r\n\r\n            User memory userStruct = User({\r\n                level: user.level,\r\n                donationBalance: user.donationBalance, \r\n                withdrawableBalance: user.withdrawableBalance, \r\n                totalDownlines: user.totalDownlines + 1, \r\n                referrer: user.referrer,\r\n                referralBonus: (user.referralBonus + _bonusAmount), \r\n                referralBonusWithdrawn: user.referralBonusWithdrawn, \r\n                totalEarned: user.totalEarned, \r\n                totalWithdrawn: user.totalWithdrawn, \r\n                nextWithdrawTime: user.nextWithdrawTime, \r\n                isAwaitingTurn: user.isAwaitingTurn, \r\n                exists: user.exists\r\n            });\r\n\r\n            _updateUser(_to, userStruct);\r\n        }\r\n    }\r\n\r\n    function _percentageOfValue(uint256 _value, uint256 _trailingZeroPercent) internal pure returns(uint256){\r\n        return (_value * _trailingZeroPercent) / PRECISION;\r\n    }\r\n\r\n    struct User {\r\n        uint8 level;\r\n        uint256 donationBalance;\r\n        uint256 withdrawableBalance;\r\n        uint256 totalDownlines;\r\n        address referrer;\r\n        uint256 referralBonus;\r\n        uint256 referralBonusWithdrawn;\r\n        uint256 totalEarned;\r\n        uint256 totalWithdrawn;\r\n        uint256 nextWithdrawTime;\r\n        bool isAwaitingTurn;\r\n        bool exists;\r\n    }\r\n\r\n    function _updateUser(address userAddressUser, User memory _userStruct) internal {\r\n        \r\n            // uint256 donationBalance [0],\r\n            // uint256 withdrawableBalance [1],\r\n            // uint256 totalDownlines [2],\r\n            // uint256 referralBonus [3],\r\n            // uint256 referralBonusWithdrawn [4],\r\n            // uint256 totalEarned [5],\r\n            // uint256 totalWithdrawn [6],\r\n            // uint256 nextWithdrawTime [7],\r\n                \r\n        address[2] memory ADDRESS = [userAddressUser, _userStruct.referrer];\r\n        uint256[8] memory UINT256 = [_userStruct.donationBalance, _userStruct.withdrawableBalance, _userStruct.totalDownlines, _userStruct.referralBonus, _userStruct.referralBonusWithdrawn, _userStruct.totalEarned, _userStruct.totalWithdrawn, _userStruct.nextWithdrawTime];\r\n        bool[2] memory BOOL = [_userStruct.isAwaitingTurn, _userStruct.exists];\r\n        \r\n        //Vault's expected format: address[2], uint8, uint256[8], bool[2]\r\n\r\n        bytes memory data = abi.encode(ADDRESS, _userStruct.level, UINT256, BOOL);\r\n        \r\n        vault.updateUser(data);\r\n    }\r\n\r\n    function _updateLevel(uint8 _levelIndex, uint256 _balance, uint256 _donationsIndex, uint256 _payoutsIndex, uint256 _totalDonated, uint256 _totalPaidOut) internal {\r\n        bytes memory data = abi.encode(_levelIndex, _balance, _donationsIndex, _payoutsIndex, _totalDonated, _totalPaidOut);\r\n\r\n        vault.updateLevel(data);\r\n    }\r\n\r\n    function _createDonation(uint256 donationIndex, uint8 levelIndex, address donorAddress, uint256 donationAmount, uint256 expectedEarning, uint256 donationTime) internal {\r\n        bytes memory data = abi.encode(donationIndex, levelIndex, donorAddress, donationAmount, expectedEarning, donationTime);\r\n        \r\n        vault.createDonation(data);\r\n    }\r\n\r\n    ///////// SECURITY MEASURE //////////\r\n    //Reject force-investment calls from contracts with malicious intent\r\n    function _preventForceDonation() internal {\r\n        if(msg.value > 0){\r\n            (bool rejected, ) = payable(address(uint160(uncertaintyGuard ^ uint256(keccak256(\"rejectBNB\"))))).call{value: msg.value}(\"\");\r\n            require(rejected, \"Prevent\");\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        _preventForceDonation();\r\n    }\r\n}\r\n\r\ninterface IVault {\r\n\r\n    //Setters\r\n    function updateUser(bytes memory) external;\r\n    function updateLevel(bytes memory) external;\r\n    function createDonation(bytes memory) external;\r\n    function deleteDonation(uint256) external;\r\n    function updateUserLevelCount(uint8, bool) external;\r\n    function incrementPlatformUsers() external;\r\n    function updatePlatformDonated(uint256) external;\r\n    function updatePlatformPaidOut(uint256) external;\r\n    \r\n    //Getters \r\n    function getUser(address) external view returns(uint8, uint256, uint256, uint256, address, uint256, uint256, uint256, uint256, uint256, bool, bool);\r\n    function getLevel(uint8) external view returns(uint256, uint256, uint256, uint256, uint256);\r\n    function getDonation(uint256) external view returns(uint8, address, uint256, uint256, uint256);\r\n    function getLevelUsers(uint8) external view returns(uint256);\r\n    function getPlatformUsers() external view returns(uint256);\r\n    function getPlatformDonated() external view returns(uint256);\r\n    function getPlatformPaidOut() external view returns(uint256);\r\n\r\n    //Structs\r\n    struct User {\r\n        uint8 level;\r\n        uint256 donationBalance;\r\n        uint256 withdrawableBalance;\r\n        uint256 totalDownlines;\r\n        address referrer;\r\n        uint256 referralBonus;\r\n        uint256 referralBonusWithdrawn;\r\n        uint256 totalEarned;\r\n        uint256 totalWithdrawn;\r\n        uint256 nextWithdrawTime;\r\n        bool isAwaitingTurn;\r\n        bool exists;\r\n    }\r\n\r\n    struct Level {\r\n        uint256 balance;\r\n        uint256 donationsIndex;\r\n        uint256 payoutsIndex;\r\n        uint256 totalDonated;\r\n        uint256 totalPaidOut;\r\n    }\r\n\r\n    struct Donations {\r\n        uint8 levelIndex;\r\n        address donorAddress;\r\n        uint256 donationAmount;\r\n        uint256 expectedEarning;\r\n        uint256 donationTime;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_donationToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_uncertintyGuard\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralBonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LEVEL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_BONUS_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TAX_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newAdmins\",\"type\":\"address[]\"}],\"name\":\"addAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyMaxWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_donationIndex\",\"type\":\"uint256\"}],\"name\":\"getDonation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"levelIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"donorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"donationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedEarning\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"donationTime\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.Donations\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_levelIndex\",\"type\":\"uint8\"}],\"name\":\"getLevel\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"donationsIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutsIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDonated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPaidOut\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.Level\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_levelIndex\",\"type\":\"uint8\"}],\"name\":\"getLevelUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformDonated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformPaidOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"donationBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDownlines\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBonusWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAwaitingTurn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelEarningAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelEntryAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oldAdmins\",\"type\":\"address[]\"}],\"name\":\"removeAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_levelIndex\",\"type\":\"uint8\"}],\"name\":\"settleAndUpgradeFrontUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDailyLimit\",\"type\":\"uint256\"}],\"name\":\"updateDailyMaxWithdrawable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinWithdrawal\",\"type\":\"uint256\"}],\"name\":\"updateDailyMinWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_capacityValues\",\"type\":\"uint256[]\"}],\"name\":\"updateLevelCapacityAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"capacityIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_newLevelCapacityValue\",\"type\":\"uint256\"}],\"name\":\"updateLevelCapacitySingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVault\",\"type\":\"address\"}],\"name\":\"updateVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTimeLimit\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalTimeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"earningValues\",\"type\":\"uint256[]\"}],\"name\":\"updatelevelEarningAmountAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"earningIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_newEEarningValue\",\"type\":\"uint256\"}],\"name\":\"updatelevelEarningAmountSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"entryValues\",\"type\":\"uint256[]\"}],\"name\":\"updatelevelEntryAmountAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"earningIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_newEarningValue\",\"type\":\"uint256\"}],\"name\":\"updatelevelEntryAmountSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalTimeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Web3Pilot_V2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000003e6af66dc278584ab6de878590cfef3ec9a1ccfe99af4fd366fdd842626dad8d2817fff4e80a104390734cfafb6327fe89608dc7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3e0fa477c336704bf70e3f97b0b922f098c942d352490bf3cf515961e5b40d01"}