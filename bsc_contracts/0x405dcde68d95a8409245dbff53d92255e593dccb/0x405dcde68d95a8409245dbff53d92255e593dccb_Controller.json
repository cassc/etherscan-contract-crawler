{"SourceCode": "// File: contracts/IController.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\ninterface IController {\r\n    function getAssetData(uint256 _globalId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 nftPoolId,\r\n            uint256 currPoolId,\r\n            uint256 amount,\r\n            uint256 level,\r\n            uint256 rarity,\r\n            uint256 boostersMults\r\n        );\r\n\r\n    function transferBeacon(\r\n        uint256 _poolId,\r\n        address _poolAddr,\r\n        address _from,\r\n        address _to,\r\n        uint256 _globalId\r\n    ) external;\r\n\r\n    function getBaseURL () external view returns (string memory _baseURL);\r\n\r\n    function getBaseImgURL () external view returns (string memory _baseImgURL);\r\n}\r\n\r\n// File: contracts/IStaking.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\ninterface IStaking {\r\n    function deposit(\r\n        uint256 _currPoolId,\r\n        uint256 _globalId,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function claim(\r\n        uint256 _globalId,\r\n        address _owner,\r\n        uint256 _currPoolId\r\n    ) external returns (uint256 _reward);\r\n\r\n    function withdraw(\r\n        uint256 _globalId,\r\n        address _owner,\r\n        uint256 _currPoolId,\r\n        uint256 _amount\r\n    ) external returns (uint256 _reward);\r\n\r\n    function getInfo(\r\n        uint256 _globalId,\r\n        uint256 _currPoolId,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _reward,\r\n            uint256 _boosterReward,\r\n            uint256 _apr,\r\n            uint256 _timeToClaimFreeze,\r\n            uint256 _commonWeight,\r\n            uint256 _assetWeight\r\n        );\r\n\r\n    function addCurrency(\r\n        uint256 _currPoolId,\r\n        string memory _name,\r\n        uint256 _allocPoint\r\n    ) external;\r\n\r\n    function getPoolInfo(uint256 _currPoolId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            uint256 allocPoint,\r\n            uint256 commonAllocWeight,\r\n            uint256 commonSum\r\n        );\r\n\r\n    function getCurrPoolStats(uint256 _currPoolId)\r\n        external\r\n        view\r\n        returns (uint256 count, uint256 amount);\r\n\r\n    function activateBooster(\r\n        uint256 _globalId,\r\n        address _owner,\r\n        uint256 _currPoolId\r\n    ) external;\r\n\r\n    function setBoostersActiveInterval(uint256 _intervalInSeconds) external;\r\n\r\n    function getBoostersActiveInterval()\r\n        external\r\n        view\r\n        returns (uint256 interval);\r\n\r\n    function changeAllocPoint(uint256 _poolId, uint256 _newAllocPoint) external;\r\n\r\n    function weightCorrector(uint256 _globalId) external;\r\n\r\n    function boosterInfo(uint256 _assetId)\r\n        external\r\n        view\r\n        returns (bool isActive, uint256 activeMult, uint256 boostersTimer);\r\n\r\n    function emergencyBoosterClearer(uint256 _globalId) external;\r\n\r\n    function getYieldInterval () external view returns (uint256 yieldInterval);\r\n\r\n    function setYieldInterval (uint256 newYieldInterval) external;\r\n}\r\n\r\n// File: contracts/IRandom.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\ninterface IRandom {\r\n  event Request(bytes32 requestId, address user, uint256 poolId, uint256 globalAssetId);\r\n  event Response(bytes32 requestId);\r\n  function getRandomNumber(address user, uint256 poolId, uint256 globalAssetId) external returns (bytes32 requestId);\r\n  function addAllowedAddr(address _contract) external returns (bool);\r\n  function removeAllowedAddr(address _contract) external returns (bool);\r\n  function expandByRequest(bytes32 requestId, uint8 randomAmount) external view returns(uint256[] memory);\r\n}\r\n// File: contracts/IOracle.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\ninterface IOracle {\r\n  function getPrice(uint256 _currPoolId) external view returns (uint256 price);\r\n}\r\n// File: contracts/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/INFT.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\ninterface INFT is IERC721 {\r\n  function mint(address _to, uint256 _globalId) external;\r\n  function burn(uint256 _globalId) external;\r\n  function isExist (uint256 _globalId) external view returns (bool);\r\n  function getPoolInfo () external view returns (string memory name, string memory symbol);\r\n  function tokenURL(uint256 _globalId) external view returns (string memory);\r\n}\r\n// File: contracts/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/Controller.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Controller is IController, Ownable, ReentrancyGuard {\r\n    constructor() {\r\n        availableToReroll = 604800;\r\n        Managers[msg.sender] = true;\r\n        generationFee = 150000 * 10**9;\r\n        boostersFee = 150000 * 10**9;\r\n        levelsFee = 150000 * 10**9;\r\n    }\r\n\r\n    //***Variables***//\r\n    uint256 public NFTPoolCounter;\r\n    uint256 public assetCounter;\r\n    uint256 public currencyPoolCounter;\r\n\r\n    uint256 public availableToReroll;\r\n    uint256 public generationFee;\r\n    uint256 public boostersFee;\r\n    uint256 public levelsFee;\r\n    address public feeReceiver;\r\n    address public rerollFeeReceiver;\r\n    address public unstakeFeeReceiver;\r\n    string public baseURL;\r\n    string public baseImgURL;\r\n\r\n    address public generator;\r\n    IRandom internal Random;\r\n    address public staking;\r\n    IStaking internal Staking;\r\n    address public oracle;\r\n    IOracle internal Oracle;\r\n\r\n    //***Mappings***//\r\n    mapping(uint256 => INFT) NFTPoolsToIds;\r\n    mapping(uint256 => Asset) public AssetsToIds;\r\n    mapping(address => bool) internal Managers;\r\n    mapping(uint256 => Currency) public CurrencyPools;\r\n\r\n    //***Structs***//\r\n    struct Asset {\r\n        uint256 nftPoolId;\r\n        uint256 currPoolId;\r\n        uint256 amount;\r\n        uint256 level;\r\n        uint256 rarity;\r\n        uint256 createdAt;\r\n        uint256 boostersMults;\r\n        uint256 unsyncLevel;\r\n        uint256 unsyncBoostersMults;\r\n        uint256 boostersUpdateAmount;\r\n        uint256 levelsUpdateAmount;\r\n        bool isStaked;\r\n        bool isExist;\r\n    }\r\n\r\n    struct UpdateAssetStruct {\r\n        uint256 globalId;\r\n        uint256 value;\r\n    }\r\n\r\n    struct UpdateAssetBoosters {\r\n        uint256 globalId;\r\n        uint256 boostersMults;\r\n    }\r\n\r\n    struct Currency {\r\n        IERC20 token;\r\n        uint256 minimalAmount;\r\n        uint256 maximalAmount;\r\n        uint256 rerollPercent;\r\n        uint256 unstakePercent;\r\n    }\r\n\r\n    //***Modificators***//\r\n    modifier onlyManager() {\r\n        require(\r\n            Managers[msg.sender],\r\n            \"Only managers allow to execute this operation\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAssetOwner(uint256 _globalId) {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist??\");\r\n        uint256 poolId = AssetsToIds[_globalId].nftPoolId;\r\n        INFT currPool = NFTPoolsToIds[poolId];\r\n        // Maybe add to require \"|| Managers[msg.sender]\" ???\r\n        require(\r\n            currPool.ownerOf(_globalId) == msg.sender,\r\n            \"Available for asset owner only\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    //***Events***//\r\n    event AssetGenerated(\r\n        address ownerAddres,\r\n        bytes32 randomRequestId,\r\n        uint256 assetPoolId,\r\n        uint256 currencyPoolId,\r\n        uint256 assetGlobalId,\r\n        uint256 assetsCountInCurrencyPool,\r\n        uint256 currencyPoolSummaryStakeAmount,\r\n        uint256 assetStakedAmount,\r\n        string data\r\n    );\r\n    event AssetReroll(\r\n        address ownerAddress,\r\n        bytes32 randomRequestId,\r\n        uint256 assetGlobalId,\r\n        uint256 assetsCountInCurrencyPool,\r\n        uint256 currencyPoolSummaryStakeAmount\r\n    );\r\n    event AssetTransfer(\r\n        uint256 assetPoolId,\r\n        address assetPoolAddress,\r\n        address addressFrom,\r\n        address addressTo,\r\n        uint256 assetGlobalId\r\n    );\r\n    event AssetUnstake(uint256 assetGlobalId, uint256 rewardAmount);\r\n    event AssetUpdateLevel(uint256 assetGlobalId, uint256 level);\r\n    event AssetUpdateBoosters(\r\n        uint256 assetGlobalId,\r\n        uint256 boostersSummaryMultiplier\r\n    );\r\n    event BoostersActivated(\r\n        uint256 assetGlobalId,\r\n        uint256 boostersSummaryMultiplier,\r\n        uint256 startTimestamp,\r\n        uint256 intervalInSeconds\r\n    );\r\n    event Claim(uint256 assetGlobalId, uint256 rewardAmount);\r\n    event AddAssetPool(uint256 assetPoolId, address assetPoolContractAddress);\r\n    event AddCurrencyPool(\r\n        uint256 currencyPoolId,\r\n        string currenctName,\r\n        address currencyPoolTokenAddress,\r\n        uint256 currencyPoolAllocPoint,\r\n        uint256 minimalStakeAmount,\r\n        uint256 rerollFeePercent\r\n    );\r\n    event UpdateCurrencyPoolBaseAPY(uint256 currencyPoolId, uint256 newAPY);\r\n    event UpdateCurrencyPoolMultipliers(\r\n        uint256 currencyPoolId,\r\n        uint256 levelMultiplier,\r\n        uint256 rarityMultiplier\r\n    );\r\n\r\n    //***NFT Pool Functions***//\r\n    function addNFTPool(address _pool) external onlyManager {\r\n        NFTPoolCounter += 1;\r\n        INFT currPool = INFT(_pool);\r\n        NFTPoolsToIds[NFTPoolCounter] = currPool;\r\n        emit AddAssetPool(NFTPoolCounter, _pool);\r\n    }\r\n\r\n    function getNFTPool(uint256 _poolId)\r\n        external\r\n        view\r\n        returns (\r\n            address poolAddress,\r\n            string memory name,\r\n            string memory symbol\r\n        )\r\n    {\r\n        INFT currPool = NFTPoolsToIds[_poolId];\r\n        (string memory _name, string memory _symbol) = currPool.getPoolInfo();\r\n        return (address(currPool), _name, _symbol);\r\n    }\r\n\r\n    function getNFTPoolsAmount() external view returns (uint256) {\r\n        return (NFTPoolCounter);\r\n    }\r\n\r\n    //***Asset Functions***//\r\n    function generateAsset(\r\n        uint256 _poolId,\r\n        uint256 _currPoolId,\r\n        uint256 _amount,\r\n        string calldata data\r\n    ) external payable {\r\n        require(\r\n            _amount >= CurrencyPools[_currPoolId].minimalAmount,\r\n            \"Too low amount for generation\"\r\n        );\r\n        require(\r\n            _amount <= CurrencyPools[_currPoolId].maximalAmount,\r\n            \"Too big amount for generation\"\r\n        );\r\n        require(msg.value >= generationFee, \"Insufficient commission\");\r\n        payable(feeReceiver).transfer(generationFee);\r\n        require(\r\n            CurrencyPools[_currPoolId].token.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _amount\r\n            ),\r\n            \"Transfer error\"\r\n        );\r\n        assetCounter += 1;\r\n\r\n        INFT currPool = NFTPoolsToIds[_poolId];\r\n        currPool.mint(msg.sender, assetCounter);\r\n        AssetsToIds[assetCounter].nftPoolId = _poolId;\r\n        AssetsToIds[assetCounter].level = 1;\r\n        AssetsToIds[assetCounter].unsyncLevel = 1;\r\n        AssetsToIds[assetCounter].amount = _amount;\r\n        AssetsToIds[assetCounter].currPoolId = _currPoolId;\r\n        AssetsToIds[assetCounter].createdAt = block.timestamp;\r\n        AssetsToIds[assetCounter].isExist = true;\r\n\r\n        (uint256 count, uint256 amount) = Staking.getCurrPoolStats(_currPoolId);\r\n\r\n        bytes32 requestId = Random.getRandomNumber(msg.sender, _poolId, assetCounter);\r\n        emit AssetGenerated (msg.sender, requestId, _poolId, _currPoolId, assetCounter, count, amount, _amount, data);\r\n    }\r\n\r\n    function rerollAsset(uint256 _globalId)\r\n        external\r\n        payable\r\n        onlyAssetOwner(_globalId)\r\n    {\r\n        (bool _isAvailableToReroll, uint256 rerollAmount) = rerollHelper(\r\n            _globalId\r\n        );\r\n        require(_isAvailableToReroll, \"Time to reroll is over\");\r\n        require(msg.value >= rerollAmount, \"Insufficient commission\");\r\n        payable(feeReceiver).transfer(generationFee);\r\n        payable(rerollFeeReceiver).transfer(rerollAmount - generationFee);\r\n\r\n        (uint256 count, uint256 amount) = Staking.getCurrPoolStats(\r\n            AssetsToIds[_globalId].currPoolId\r\n        );\r\n        bytes32 requestId = Random.getRandomNumber(\r\n            msg.sender,\r\n            AssetsToIds[_globalId].currPoolId,\r\n            _globalId\r\n        );\r\n        emit AssetReroll(msg.sender, requestId, _globalId, count, amount);\r\n    }\r\n\r\n    function rerollHelper(uint256 _globalId)\r\n        public\r\n        view\r\n        returns (bool _isAvailableToReroll, uint256 rerollFee)\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        rerollFee =\r\n            (AssetsToIds[_globalId].amount *\r\n                CurrencyPools[AssetsToIds[_globalId].currPoolId]\r\n                    .rerollPercent) /\r\n            10000;\r\n        uint256 rerollAmount = (rerollFee *\r\n            Oracle.getPrice(AssetsToIds[_globalId].currPoolId)) /\r\n            Oracle.getPrice(0);\r\n        bool isAvailToReroll = AssetsToIds[_globalId].createdAt +\r\n            availableToReroll >\r\n            block.timestamp;\r\n        if (isAvailToReroll) {\r\n            rerollFee = generationFee + rerollAmount;\r\n        }\r\n        return (isAvailToReroll, rerollFee);\r\n    }\r\n\r\n    function fulfillAsset(uint256 _globalId, uint256 _rarity)\r\n        external\r\n        onlyManager\r\n        nonReentrant\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        AssetsToIds[_globalId].rarity = _rarity;\r\n        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;\r\n        uint256 _amount = AssetsToIds[_globalId].amount;\r\n        if (!AssetsToIds[_globalId].isStaked) {\r\n            Staking.deposit(_currPoolId, _globalId, _amount);\r\n            AssetsToIds[_globalId].isStaked = true;\r\n        } else {\r\n            Staking.weightCorrector(_globalId);\r\n        }\r\n    }\r\n\r\n    function getAssetData(uint256 _globalId)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256 nftPoolId,\r\n            uint256 currPoolId,\r\n            uint256 amount,\r\n            uint256 level,\r\n            uint256 rarity,\r\n            uint256 boostersMults\r\n        )\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        return (\r\n            AssetsToIds[_globalId].nftPoolId,\r\n            AssetsToIds[_globalId].currPoolId,\r\n            AssetsToIds[_globalId].amount,\r\n            AssetsToIds[_globalId].level,\r\n            AssetsToIds[_globalId].rarity,\r\n            AssetsToIds[_globalId].boostersMults\r\n        );\r\n    }\r\n\r\n    function getAssetUrl(uint256 _globalId)\r\n        external\r\n        view\r\n        returns (string memory tokenURL)\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        return (\r\n            NFTPoolsToIds[AssetsToIds[_globalId].nftPoolId].tokenURL(_globalId)\r\n        );\r\n    }\r\n\r\n    function syncAsset(uint256 _globalId)\r\n        external\r\n        payable\r\n        onlyAssetOwner(_globalId)\r\n        nonReentrant\r\n    {\r\n        require(\r\n            AssetsToIds[_globalId].boostersUpdateAmount > 0 ||\r\n                AssetsToIds[_globalId].levelsUpdateAmount > 0,\r\n            \"Asset is already synchronized\"\r\n        );\r\n        uint256 fee = AssetsToIds[_globalId].boostersUpdateAmount *\r\n            boostersFee +\r\n            AssetsToIds[_globalId].levelsUpdateAmount *\r\n            levelsFee;\r\n        require(msg.value >= fee, \"Insufficient commission\");\r\n        payable(feeReceiver).transfer(fee);\r\n        AssetsToIds[_globalId].level = AssetsToIds[_globalId].unsyncLevel;\r\n        AssetsToIds[_globalId].boostersMults = AssetsToIds[_globalId]\r\n            .unsyncBoostersMults;\r\n        AssetsToIds[_globalId].unsyncBoostersMults = 0;\r\n        AssetsToIds[_globalId].boostersUpdateAmount = 0;\r\n        AssetsToIds[_globalId].levelsUpdateAmount = 0;\r\n        if (AssetsToIds[_globalId].isStaked) {\r\n            Staking.weightCorrector(_globalId);\r\n        }\r\n    }\r\n\r\n    function syncHelper(uint256 _globalId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 levelUpdateFee,\r\n            uint256 levelUpdateAmount,\r\n            uint256 boosterUpdateFee,\r\n            uint256 boosterUpdateAmount,\r\n            uint256 summaryFee\r\n        )\r\n    {\r\n        uint256 fee = AssetsToIds[_globalId].boostersUpdateAmount *\r\n            boostersFee +\r\n            AssetsToIds[_globalId].levelsUpdateAmount *\r\n            levelsFee;\r\n        return (\r\n            levelsFee,\r\n            AssetsToIds[_globalId].levelsUpdateAmount,\r\n            boostersFee,\r\n            AssetsToIds[_globalId].boostersUpdateAmount,\r\n            fee\r\n        );\r\n    }\r\n\r\n    function updateAssetLevel(uint256 _globalId, uint256 _level)\r\n        public\r\n        onlyManager\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        AssetsToIds[_globalId].levelsUpdateAmount += 1;\r\n        AssetsToIds[_globalId].unsyncLevel = _level;\r\n        emit AssetUpdateLevel(_globalId, _level);\r\n    }\r\n\r\n    function bulkUpdateAssetLevel(bytes calldata data) external onlyManager {\r\n        UpdateAssetStruct[] memory assetsArr = abi.decode(\r\n            data,\r\n            (UpdateAssetStruct[])\r\n        );\r\n        uint256 arrLength = assetsArr.length;\r\n        require(arrLength > 0, \"Empty array\");\r\n        for (uint256 i = 0; i < arrLength; i++) {\r\n            updateAssetLevel(assetsArr[i].globalId, assetsArr[i].value);\r\n        }\r\n    }\r\n\r\n    function updateAssetBoosters(uint256 _globalId, uint256 _boostersMult)\r\n        public\r\n        onlyManager\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        AssetsToIds[_globalId].boostersUpdateAmount += 1;\r\n        AssetsToIds[_globalId].unsyncBoostersMults += _boostersMult;\r\n        emit AssetUpdateBoosters(_globalId, _boostersMult);\r\n    }\r\n\r\n    function bulkUpdateAssetBoosters(bytes calldata data) external onlyManager {\r\n        UpdateAssetStruct[] memory assetsArr = abi.decode(\r\n            data,\r\n            (UpdateAssetStruct[])\r\n        );\r\n        uint256 arrLength = assetsArr.length;\r\n        require(arrLength > 0, \"Empty array\");\r\n        for (uint256 i = 0; i < arrLength; i++) {\r\n            updateAssetBoosters(assetsArr[i].globalId, assetsArr[i].value);\r\n        }\r\n    }\r\n\r\n    function unstakeAsset(uint256 _globalId)\r\n        public\r\n        onlyAssetOwner(_globalId)\r\n        nonReentrant\r\n    {\r\n        require(\r\n            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&\r\n                AssetsToIds[_globalId].levelsUpdateAmount == 0,\r\n            \"Synchronize asset first\"\r\n        );\r\n        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;\r\n        uint256 _amount = AssetsToIds[_globalId].amount;\r\n        uint256 poolId = AssetsToIds[_globalId].nftPoolId;\r\n        INFT currPool = NFTPoolsToIds[poolId];\r\n        uint256 reward;\r\n        if (AssetsToIds[_globalId].isStaked) {\r\n            reward = Staking.withdraw(\r\n                _globalId,\r\n                currPool.ownerOf(_globalId),\r\n                _currPoolId,\r\n                _amount\r\n            );\r\n        }\r\n        currPool.burn(_globalId);\r\n        uint256 commission = (AssetsToIds[_globalId].amount * CurrencyPools[AssetsToIds[_globalId].currPoolId].unstakePercent) / 10000;\r\n        AssetsToIds[_globalId].amount -= commission;\r\n        require(\r\n            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(\r\n                msg.sender,\r\n                AssetsToIds[_globalId].amount\r\n            ),\r\n            \"Transfer error\"\r\n        );\r\n        if (commission > 0) {\r\n          require(\r\n            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(\r\n                unstakeFeeReceiver,\r\n                commission\r\n            ),\r\n            \"Transfer error\"\r\n        );  \r\n        }\r\n        AssetsToIds[_globalId].amount = 0;\r\n        AssetsToIds[_globalId].isExist = false;\r\n        emit AssetUnstake(_globalId, reward);\r\n    }\r\n\r\n    function bulkUnstakeAsset(uint256[] calldata _idsArray) external {\r\n        uint256 length = _idsArray.length;\r\n        require(length > 0, \"Empty array\");\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            unstakeAsset(_idsArray[i]);\r\n        }\r\n    }\r\n\r\n    function getUpdateAmount(uint256 _globalId)\r\n        external\r\n        view\r\n        returns (uint256 levels, uint256 boosters)\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        return (\r\n            AssetsToIds[_globalId].levelsUpdateAmount,\r\n            AssetsToIds[_globalId].boostersUpdateAmount\r\n        );\r\n    }\r\n\r\n    function activateBoosters(uint256 _globalId)\r\n        external\r\n        onlyAssetOwner(_globalId)\r\n        nonReentrant\r\n    {\r\n        require(\r\n            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&\r\n                AssetsToIds[_globalId].levelsUpdateAmount == 0,\r\n            \"Synchronize asset first\"\r\n        );\r\n        require(\r\n            AssetsToIds[_globalId].boostersMults > 0,\r\n            \"You don't have any boosters\"\r\n        );\r\n        require(AssetsToIds[_globalId].isStaked, \"Asset is not staked\");\r\n\r\n        uint256 mult = AssetsToIds[_globalId].boostersMults;\r\n        uint256 poolId = AssetsToIds[_globalId].nftPoolId;\r\n        INFT currPool = NFTPoolsToIds[poolId];\r\n        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;\r\n        Staking.activateBooster(\r\n            _globalId,\r\n            currPool.ownerOf(_globalId),\r\n            _currPoolId\r\n        );\r\n        AssetsToIds[_globalId].boostersMults = 0;\r\n        uint256 interval = Staking.getBoostersActiveInterval();\r\n\r\n        emit BoostersActivated(_globalId, mult, block.timestamp, interval);\r\n    }\r\n\r\n    function boosterInfo(uint256 _globalId)\r\n        external\r\n        view\r\n        returns (\r\n            bool _isBoosterActive,\r\n            uint256 activeMult,\r\n            uint256 boostersTimer,\r\n            bool isBoostersAvail,\r\n            uint256 availBoostersMult\r\n        )\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        (_isBoosterActive, activeMult, boostersTimer) = Staking.boosterInfo(\r\n            _globalId\r\n        );\r\n        if (!_isBoosterActive && AssetsToIds[_globalId].boostersMults > 0) {\r\n            isBoostersAvail = true;\r\n            availBoostersMult = AssetsToIds[_globalId].boostersMults;\r\n        }\r\n        return (\r\n            _isBoosterActive,\r\n            activeMult,\r\n            boostersTimer,\r\n            isBoostersAvail,\r\n            availBoostersMult\r\n        );\r\n    }\r\n\r\n    //***Staking Functions***//\r\n    function addCurrencyPool(\r\n        address _tokenAddress,\r\n        string calldata _name,\r\n        uint256 _allocPoint,\r\n        uint256 _minimalAmount,\r\n        uint256 _maximalAmount,\r\n        uint256 _rerollPercent,\r\n        uint256 _unstakePercent\r\n    ) external onlyOwner {\r\n        currencyPoolCounter += 1;\r\n        Staking.addCurrency(currencyPoolCounter, _name, _allocPoint);\r\n        CurrencyPools[currencyPoolCounter].token = IERC20(_tokenAddress);\r\n        CurrencyPools[currencyPoolCounter].minimalAmount = _minimalAmount;\r\n        CurrencyPools[currencyPoolCounter].maximalAmount = _maximalAmount;\r\n        CurrencyPools[currencyPoolCounter].rerollPercent = _rerollPercent;\r\n        CurrencyPools[currencyPoolCounter].unstakePercent = _unstakePercent;\r\n        emit AddCurrencyPool(\r\n            currencyPoolCounter,\r\n            _name,\r\n            _tokenAddress,\r\n            _allocPoint,\r\n            _minimalAmount,\r\n            _rerollPercent\r\n        );\r\n    }\r\n\r\n    function changeCurrencyPoolAllocPoint(\r\n        uint256 _currPoolId,\r\n        uint256 _newAllocPoint\r\n    ) external onlyOwner {\r\n        Staking.changeAllocPoint(_currPoolId, _newAllocPoint);\r\n    }\r\n\r\n    function changeRerollPercent(uint256 _currPoolId, uint256 _newRerollPercent)\r\n        external\r\n        onlyOwner\r\n    {\r\n        CurrencyPools[_currPoolId].rerollPercent = _newRerollPercent;\r\n    }\r\n\r\n    function changeMinMaxAmount(\r\n        uint256 _currPoolId,\r\n        uint256 _newMinAmount,\r\n        uint256 _newMaxAmount\r\n    ) external onlyOwner {\r\n        CurrencyPools[_currPoolId].minimalAmount = _newMinAmount;\r\n        CurrencyPools[_currPoolId].maximalAmount = _newMaxAmount;\r\n    }\r\n\r\n    function getCurrencyPoolInfo(uint256 _currPoolId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            address tokenAddress,\r\n            uint256 allocPoint,\r\n            uint256 commonAllocWeight,\r\n            uint256 minAmount,\r\n            uint256 maxAmount,\r\n            uint256 rerollPercent,\r\n            uint256 unstakePercent,\r\n            uint256 commonSum\r\n        )\r\n    {\r\n        (name, allocPoint, commonAllocWeight, commonSum) = Staking.getPoolInfo(\r\n            _currPoolId\r\n        );\r\n        tokenAddress = address(CurrencyPools[currencyPoolCounter].token);\r\n        minAmount = CurrencyPools[currencyPoolCounter].minimalAmount;\r\n        maxAmount = CurrencyPools[currencyPoolCounter].maximalAmount;\r\n        rerollPercent = CurrencyPools[currencyPoolCounter].rerollPercent;\r\n        unstakePercent = CurrencyPools[currencyPoolCounter].unstakePercent;\r\n\r\n        return (\r\n            name,\r\n            tokenAddress,\r\n            allocPoint,\r\n            commonAllocWeight,\r\n            minAmount,\r\n            maxAmount,\r\n            rerollPercent,\r\n            unstakePercent,\r\n            commonSum\r\n        );\r\n    }\r\n\r\n    function getStakingInfo(uint256 _globalId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 reward,\r\n            uint256 boosterReward,\r\n            uint256 apr,\r\n            uint256 amount,\r\n            uint256 timeToClaimFreeze,\r\n            uint256 commonWeight,\r\n            uint256 assetWeight\r\n        )\r\n    {\r\n        require(AssetsToIds[_globalId].isExist, \"Asset is not exist\");\r\n        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;\r\n        uint256 relativeAmount;\r\n        if (_currPoolId == 1) {\r\n            relativeAmount = AssetsToIds[_globalId].amount;\r\n        } else {\r\n            relativeAmount =\r\n                (AssetsToIds[_globalId].amount * Oracle.getPrice(_currPoolId)) /\r\n                Oracle.getPrice(1);\r\n        }\r\n        if (AssetsToIds[_globalId].isStaked) {\r\n            (reward, boosterReward, apr, timeToClaimFreeze, commonWeight, assetWeight) = Staking.getInfo(\r\n                _globalId,\r\n                _currPoolId,\r\n                relativeAmount\r\n            );\r\n        }\r\n        return (\r\n            reward,\r\n            boosterReward,\r\n            apr,\r\n            AssetsToIds[_globalId].amount,\r\n            timeToClaimFreeze,\r\n            commonWeight,\r\n            assetWeight\r\n        );\r\n    }\r\n\r\n    function claim(uint256 _globalId) public onlyAssetOwner(_globalId) {\r\n        require(\r\n            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&\r\n                AssetsToIds[_globalId].levelsUpdateAmount == 0,\r\n            \"Synchronize asset first\"\r\n        );\r\n        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;\r\n        uint256 poolId = AssetsToIds[_globalId].nftPoolId;\r\n        uint256 reward;\r\n        INFT currPool = NFTPoolsToIds[poolId];\r\n        if (AssetsToIds[_globalId].isStaked) {\r\n            reward = Staking.claim(\r\n                _globalId,\r\n                currPool.ownerOf(_globalId),\r\n                _currPoolId\r\n            );\r\n        }\r\n        emit Claim(_globalId, reward);\r\n    }\r\n\r\n    function bulkClaim(uint256[] calldata _idsArray) external {\r\n        uint256 length = _idsArray.length;\r\n        require(length > 0, \"Empty array\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            claim(_idsArray[i]);\r\n        }\r\n    }\r\n\r\n    //***Setting Functions***//\r\n    function changeGenerator(address _addr) external onlyOwner {\r\n        require(_addr != address(0), \"Zero address\");\r\n        generator = _addr;\r\n        Random = IRandom(_addr);\r\n    }\r\n\r\n    function changeOracle(address _addr) external onlyOwner {\r\n        require(_addr != address(0), \"Zero address\");\r\n        oracle = _addr;\r\n        Oracle = IOracle(_addr);\r\n    }\r\n\r\n    function changeStaking(address _addr) external onlyOwner {\r\n        require(_addr != address(0), \"Zero address\");\r\n        staking = _addr;\r\n        Staking = IStaking(_addr);\r\n    }\r\n\r\n    function setAvailableToReroll(uint256 _intervalInSeconds)\r\n        external\r\n        onlyOwner\r\n    {\r\n        availableToReroll = _intervalInSeconds;\r\n    }\r\n\r\n    function setBoostersActiveInterval(uint256 _intervalInSeconds)\r\n        external\r\n        onlyOwner\r\n    {\r\n        Staking.setBoostersActiveInterval(_intervalInSeconds);\r\n    }\r\n\r\n    function setYieldInterval(uint256 newYieldInterval) external onlyOwner {\r\n        Staking.setYieldInterval(newYieldInterval);\r\n    }\r\n\r\n    function getYieldInterval() external view returns (uint256) {\r\n        return (Staking.getYieldInterval());\r\n    }\r\n\r\n    function addManager(address _addr) external onlyOwner {\r\n        Managers[_addr] = true;\r\n    }\r\n\r\n    function removeManager(address _addr) external onlyOwner {\r\n        Managers[_addr] = false;\r\n    }\r\n\r\n    function isManager(address _addr)\r\n        external\r\n        view\r\n        onlyOwner\r\n        returns (bool _isManager)\r\n    {\r\n        return (Managers[_addr]);\r\n    }\r\n\r\n    function transferBeacon(\r\n        uint256 _poolId,\r\n        address _poolAddr,\r\n        address _from,\r\n        address _to,\r\n        uint256 _globalId\r\n    ) public override {\r\n        require(\r\n            address(NFTPoolsToIds[_poolId]) == _poolAddr,\r\n            \"Sender is not a NFT contract\"\r\n        );\r\n        emit AssetTransfer(_poolId, _poolAddr, _from, _to, _globalId);\r\n    }\r\n\r\n    function changeTrxFee(\r\n        uint256 _generationFeeInWei,\r\n        uint256 _updateLevelsFeeInWei,\r\n        uint256 _updateBoostersFeeOnWei\r\n    ) external onlyOwner {\r\n        generationFee = _generationFeeInWei;\r\n        levelsFee = _updateLevelsFeeInWei;\r\n        boostersFee = _updateBoostersFeeOnWei;\r\n    }\r\n\r\n    function changeFeeReciever(address _addr) external onlyOwner {\r\n        require(_addr != address(0), \"Zero address\");\r\n        feeReceiver = _addr;\r\n    }\r\n\r\n    function changeRerollFeeReceiver(address _addr) external onlyOwner {\r\n        require(_addr != address(0), \"Zero address\");\r\n        rerollFeeReceiver = _addr;\r\n    }\r\n\r\n    function changeUnstakeFeeReceiver(address _addr) external onlyOwner {\r\n        require(_addr != address(0), \"Zero address\");\r\n        unstakeFeeReceiver = _addr;\r\n    }\r\n\r\n    function getBaseURL()\r\n        external\r\n        view\r\n        override\r\n        returns (string memory _baseURL)\r\n    {\r\n        return baseURL;\r\n    }\r\n\r\n    function changeBaseURL(string memory _newBaseURL) external onlyOwner {\r\n        baseURL = _newBaseURL;\r\n    }\r\n\r\n    function getBaseImgURL()\r\n        external\r\n        view\r\n        override\r\n        returns (string memory _baseImgURL)\r\n    {\r\n        return baseImgURL;\r\n    }\r\n\r\n    function changeBaseImgURL(string memory _newBaseImgURL) external onlyOwner {\r\n        baseImgURL = _newBaseImgURL;\r\n    }\r\n\r\n    function tokensWithdraw(\r\n        address _token,\r\n        address _reciever,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        IERC20 token = IERC20(_token);\r\n        require(\r\n            token.balanceOf(address(this)) >= _amount,\r\n            \"Insufficient balance for transaction\"\r\n        );\r\n        require(token.transfer(_reciever, _amount), \"Transfer error\");\r\n    }\r\n\r\n    function emergencyWithdraw(uint256 _globalId)\r\n        external\r\n        onlyAssetOwner(_globalId)\r\n        nonReentrant\r\n    {\r\n        require(\r\n            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&\r\n                AssetsToIds[_globalId].levelsUpdateAmount == 0,\r\n            \"Synchronize asset first\"\r\n        );\r\n        uint256 poolId = AssetsToIds[_globalId].nftPoolId;\r\n        INFT currPool = NFTPoolsToIds[poolId];\r\n        currPool.burn(_globalId);\r\n        uint256 commission = (AssetsToIds[_globalId].amount * CurrencyPools[AssetsToIds[_globalId].currPoolId].unstakePercent) / 10000;\r\n        AssetsToIds[_globalId].amount -= commission;\r\n        require(\r\n            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(\r\n                msg.sender,\r\n                AssetsToIds[_globalId].amount\r\n            ),\r\n            \"Transfer error\"\r\n        );\r\n        if (commission > 0) {\r\n          require(\r\n            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(\r\n                unstakeFeeReceiver,\r\n                commission\r\n            ),\r\n            \"Transfer error\"\r\n        );  \r\n        }\r\n        AssetsToIds[_globalId].amount = 0;\r\n        if (AssetsToIds[_globalId].isStaked) {\r\n            Staking.weightCorrector(_globalId);\r\n            Staking.emergencyBoosterClearer(_globalId);\r\n        }\r\n        AssetsToIds[_globalId].isExist = false;\r\n        emit AssetUnstake(_globalId, 0);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetPoolContractAddress\",\"type\":\"address\"}],\"name\":\"AddAssetPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"currenctName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyPoolTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolAllocPoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimalStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rerollFeePercent\",\"type\":\"uint256\"}],\"name\":\"AddCurrencyPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ownerAddres\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"randomRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsCountInCurrencyPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolSummaryStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetStakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"AssetGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"randomRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsCountInCurrencyPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolSummaryStakeAmount\",\"type\":\"uint256\"}],\"name\":\"AssetReroll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetPoolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addressFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addressTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"}],\"name\":\"AssetTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"AssetUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostersSummaryMultiplier\",\"type\":\"uint256\"}],\"name\":\"AssetUpdateBoosters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"AssetUpdateLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostersSummaryMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalInSeconds\",\"type\":\"uint256\"}],\"name\":\"BoostersActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGlobalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAPY\",\"type\":\"uint256\"}],\"name\":\"UpdateCurrencyPoolBaseAPY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"levelMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rarityMultiplier\",\"type\":\"uint256\"}],\"name\":\"UpdateCurrencyPoolMultipliers\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AssetsToIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nftPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostersMults\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unsyncLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unsyncBoostersMults\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostersUpdateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelsUpdateAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CurrencyPools\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rerollPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakePercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTPoolCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"activateBoosters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rerollPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unstakePercent\",\"type\":\"uint256\"}],\"name\":\"addCurrencyPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"addNFTPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableToReroll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseImgURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"boosterInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBoosterActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"activeMult\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostersTimer\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBoostersAvail\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"availBoostersMult\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boostersFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_idsArray\",\"type\":\"uint256[]\"}],\"name\":\"bulkClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_idsArray\",\"type\":\"uint256[]\"}],\"name\":\"bulkUnstakeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bulkUpdateAssetBoosters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bulkUpdateAssetLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseImgURL\",\"type\":\"string\"}],\"name\":\"changeBaseImgURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseURL\",\"type\":\"string\"}],\"name\":\"changeBaseURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newAllocPoint\",\"type\":\"uint256\"}],\"name\":\"changeCurrencyPoolAllocPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeFeeReciever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMaxAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinMaxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeRerollFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newRerollPercent\",\"type\":\"uint256\"}],\"name\":\"changeRerollPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_generationFeeInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updateLevelsFeeInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updateBoostersFeeOnWei\",\"type\":\"uint256\"}],\"name\":\"changeTrxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeUnstakeFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyPoolCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rarity\",\"type\":\"uint256\"}],\"name\":\"fulfillAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"generateAsset\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"getAssetData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nftPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rarity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostersMults\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"getAssetUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenURL\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseImgURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_baseImgURL\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_baseURL\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currPoolId\",\"type\":\"uint256\"}],\"name\":\"getCurrencyPoolInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commonAllocWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rerollPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commonSum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"getNFTPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNFTPoolsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"getStakingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boosterReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToClaimFreeze\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commonWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetWeight\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"getUpdateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"levels\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boosters\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getYieldInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isManager\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levelsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"rerollAsset\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rerollFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"rerollHelper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isAvailableToReroll\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rerollFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_intervalInSeconds\",\"type\":\"uint256\"}],\"name\":\"setAvailableToReroll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_intervalInSeconds\",\"type\":\"uint256\"}],\"name\":\"setBoostersActiveInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newYieldInterval\",\"type\":\"uint256\"}],\"name\":\"setYieldInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"syncAsset\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"syncHelper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"levelUpdateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelUpdateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boosterUpdateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boosterUpdateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"summaryFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reciever\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokensWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"transferBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"}],\"name\":\"unstakeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_boostersMult\",\"type\":\"uint256\"}],\"name\":\"updateAssetBoosters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"updateAssetLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Controller", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b4a8c0ff852d2054b54208546f3fa184c19af8a068540c86782d21b5f06a39f8"}