{"SourceCode": "pragma solidity 0.5.1;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v\r\n     \r\n     11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID.\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][to] = approved;\r\n        emit ApprovalForAll(_msgSender(), to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner.\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the _msgSender() to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransferFrom(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\r\n        _transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists.\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID.\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use {_burn} instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * This function is deprecated.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID.\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name.\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol.\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID.\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token.\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to set its URI\r\n     * @param uri string URI to assign\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract MinterRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(_msgSender());\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721MetadataMintable\r\n * @dev ERC721 minting logic with metadata.\r\n */\r\ncontract ERC721MetadataMintable is ERC721, ERC721Metadata, MinterRole {\r\n    /**\r\n     * @dev Function to mint tokens.\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param tokenId The token id to mint.\r\n     * @param tokenURI The token URI of the minted token.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mintWithTokenURI(address to, uint256 tokenId, string memory tokenURI) public onlyMinter returns (bool) {\r\n        _mint(to, tokenId);\r\n        _setTokenURI(tokenId, tokenURI);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n*\r\nCertificado de Concess\u00e3o para Tokeniza\u00e7\u00e3o e Capta\u00e7\u00e3o de Investimento em\r\nBlockchain - Kla Invest\r\nEste Certificado de Concess\u00e3o (\"Contrato\") \u00e9 celebrado entre a empresa GSA\r\nPARTICIPA\u00c7\u00d5ES LTDA, (\u201cCNPJ/MF\u201d) sob o n\u00ba 48.446.853/0001-88, representado por\r\nRicardo Lu\u00eds dos Santos junior CPF 70361355068, com sede na cidade de S\u00e3o\r\nLeopoldo, Estado do Rio Grande do Sul, Avenida S\u00e3o Borja 286, Rio Branco, CEP\r\n93040-386, adiante denominada \"Concedente\", e a KLA Invest (\u201cCNPJ/MF\u201d) sob o n\u00ba\r\n37.468.811/0001-21, com sede na cidade de S\u00e3o Paulo, Estado de S\u00e3o Paulo, na Av\r\nnova independ\u00eancia 87, sala 103 10\u00ba andar, Brooklin, CEP 04570-000, Representado\r\npor Rodrigo Silva , brasileiro, solteiro, empres\u00e1rio, nascido aos 15/07/1980, inscrito no\r\nCPF sob n\u00ba291.465.048-50 Tokenizadora de Ativos, doravante denominada\r\n\"Concession\u00e1ria\", de acordo com os termos e condi\u00e7\u00f5es a seguir estabelecidos:\r\n1. Objeto da Concess\u00e3o\r\n1.1 A Concedente concede \u00e0 Concession\u00e1ria o direito exclusivo de tokenizar e captar\r\ninvestimentos por meio do modelo de crowdfunding, utilizando a tecnologia\r\nblockchain.\r\n1.2 A tokeniza\u00e7\u00e3o ser\u00e1 realizada por meio da emiss\u00e3o de tokens representativos de\r\nativos, que ser\u00e3o distribu\u00eddos aos investidores sob a forma de NFTs (tokens n\u00e3o\r\nfung\u00edveis), conforme especificado no presente Contrato.\r\n1.3 A plataforma da KLA Invest t\u00e9r\u00e1 exclusividade para a distribui\u00e7\u00e3o dos NFTs\r\nTokenizados relacionados ao Projeto do Concedente, bem como para a\r\nadministra\u00e7\u00e3o das transa\u00e7\u00f5es e registros em blockchain.\r\n2. NFTs e Smart Contracts\r\n2.1 Cada NFT emitido pela Concession\u00e1ria garantir\u00e1 ao investidor os benef\u00edcios\r\nespec\u00edficos relacionados ao projeto Tokenizado, conforme detalhado no Whitepaper\r\ndisponibilizado pela Concession\u00e1ria e definidos em conformidade com o projeto da\r\nconcedente.\r\n2.2 A Concession\u00e1ria \u00e9 apenas uma empresa intermediadora que apresenta Projetos\r\nde terceiros a potenciais clientes investidores. Dessa forma, as informa\u00e7\u00f5es indicadas\r\nno Projeto foram produzidas integralmente pela Concedente, que \u00e9 a exclusiva\r\nrespons\u00e1vel perante o cliente adquirente do token, assim como perante as\r\nautoridades governamentais.\r\n2.3 A Concedente deve garantir a exist\u00eancia do Projeto, a lisura na sua condu\u00e7\u00e3o,\r\ngovernan\u00e7a das atividades empresariais e gest\u00e3o com o denodo e zelo aplicado \u00e0\r\nesp\u00e9cie.\r\n2.4 A Concession\u00e1ria deve garantir a legalidade na capta\u00e7\u00e3o dos recursos e a\r\ndisponibiliza\u00e7\u00e3o dos recursos \u00e0 Concedente, t\u00e3o logo se encerre o per\u00edodo de\r\ncapta\u00e7\u00e3o e tenha sido alcan\u00e7ada a meta de capta\u00e7\u00e3o.DocuSign Envelope ID: 1EB2C95C-851D-461B-AD22-4E15EE3A2E67\r\n2.5 Os direitos, benef\u00edcios e obriga\u00e7\u00f5es vinculados aos NFTs ser\u00e3o automaticamente\r\ngarantidos por meio de smart contracts, os quais ser\u00e3o incorporados \u00e0 plataforma da\r\nKLA Invest.\r\n2.5 Os smart contracts garantir\u00e3o a seguran\u00e7a digital e jur\u00eddica das transa\u00e7\u00f5es\r\nrealizadas na plataforma, fornecendo um mecanismo de registro autom\u00e1tico e\r\ntransparente.\r\n3. Informa\u00e7\u00f5es sobre os Projetos\r\n3.1 A Concession\u00e1ria disponibilizar\u00e1 todas as informa\u00e7\u00f5es relevantes sobre cada\r\nprojeto Tokenizado no whitepaper correspondente, que descrever\u00e1 em detalhes os\r\nbenef\u00edcios espec\u00edficos oferecidos a cada investidor.\r\n3.2 O whitepaper \u00e9 produzido com base no Projeto que \u00e9 produzido integralmente\r\npela Concedente, a sua exclusiva responsabilidade. Dessa forma, caso o cliente\r\nadquirente do Token deseje esclarecimentos acerca do Projeto, a Concedente dever\u00e1\r\nrespond\u00ea-lo com todas as informa\u00e7\u00f5es t\u00e9cnicas, baseadas no estudo.\r\n3.3 A p\u00e1gina do projeto no site da KLA Invest tamb\u00e9m fornecer\u00e1 informa\u00e7\u00f5es\r\nadicionais, incluindo detalhes sobre as obriga\u00e7\u00f5es do investidor, prazos, termos e\r\ncondi\u00e7\u00f5es aplic\u00e1veis ao investimento.\r\n4. Confidencialidade e Prote\u00e7\u00e3o de Dados\r\n4.1 As partes concordam em tratar todas as informa\u00e7\u00f5es confidenciais obtidas no\r\n\u00e2mbito deste Contrato com estrita confidencialidade, de acordo com a legisla\u00e7\u00e3o\r\naplic\u00e1vel em mat\u00e9ria de prote\u00e7\u00e3o de dados.\r\n4.2 A Concession\u00e1ria ser\u00e1 respons\u00e1vel pela seguran\u00e7a e privacidade dos dados dos\r\ninvestidores, garantindo a conformidade com as leis e regulamentos aplic\u00e1veis em\r\nrela\u00e7\u00e3o \u00e0 prote\u00e7\u00e3o de dados.\r\n5. Vig\u00eancia e Rescis\u00e3o\r\n5.1 Este Contrato entrar\u00e1 em vigor na data de assinatura pelas partes e ter\u00e1 vig\u00eancia\r\nat\u00e9 o final do prazo estabelecido para a venda dos NFTs relacionados ao Projeto,,\r\ninadmitindo rescis\u00e3o sem justa causa.\r\n5.2 Poder\u00e1, entretanto, ser rescindido em caso de: (i) descumprimento de qualquer\r\ncl\u00e1usula do contrato; (ii) caso se verifique falhas no Projeto ou aus\u00eancia de substrato\r\nnas opera\u00e7\u00f5es da Concedente; (iii) caso a meta de capta\u00e7\u00e3o n\u00e3o seja alcan\u00e7ada ou\r\nrevista dentro do prazo; (iv) caso se verifique o crescimento do endividamento da\r\nConcedente que poder\u00e1 culminar com sua insolv\u00eancia.\r\n5.3 A rescis\u00e3o deste Contrato n\u00e3o afetar\u00e1 os direitos e obriga\u00e7\u00f5es decorrentes de\r\ntransa\u00e7\u00f5es conclu\u00eddas anteriormente \u00e0 rescis\u00e3o, inclusive perante os clientes\r\nadquirentes dos NFTs, cuja responsabilidade prec\u00edpua \u00e9 da Concedente.DocuSign Envelope ID: 1EB2C95C-851D-461B-AD22-4E15EE3A2E67\r\n\r\nCertificado de Concess\u00e3o para Tokeniza\u00e7\u00e3o e Capta\u00e7\u00e3o de Investimento em\r\nBlockchain - Kla Invest\r\nEste Certificado de Concess\u00e3o (\"Contrato\") \u00e9 celebrado entre a empresa GSA\r\nPARTICIPA\u00c7\u00d5ES LTDA, (\u201cCNPJ/MF\u201d) sob o n\u00ba 48.446.853/0001-88, representado por\r\nRicardo Lu\u00eds dos Santos junior CPF 70361355068, com sede na cidade de S\u00e3o\r\nLeopoldo, Estado do Rio Grande do Sul, Avenida S\u00e3o Borja 286, Rio Branco, CEP\r\n93040-386, adiante denominada \"Concedente\", e a KLA Invest (\u201cCNPJ/MF\u201d) sob o n\u00ba\r\n37.468.811/0001-21, com sede na cidade de S\u00e3o Paulo, Estado de S\u00e3o Paulo, na Av\r\nnova independ\u00eancia 87, sala 103 10\u00ba andar, Brooklin, CEP 04570-000, Representado\r\npor Rodrigo Silva , brasileiro, solteiro, empres\u00e1rio, nascido aos 15/07/1980, inscrito no\r\nCPF sob n\u00ba291.465.048-50 Tokenizadora de Ativos, doravante denominada\r\n\"Concession\u00e1ria\", de acordo com os termos e condi\u00e7\u00f5es a seguir estabelecidos:\r\n1. Objeto da Concess\u00e3o\r\n1.1 A Concedente concede \u00e0 Concession\u00e1ria o direito exclusivo de tokenizar e captar\r\ninvestimentos por meio do modelo de crowdfunding, utilizando a tecnologia\r\nblockchain.\r\n1.2 A tokeniza\u00e7\u00e3o ser\u00e1 realizada por meio da emiss\u00e3o de tokens representativos de\r\nativos, que ser\u00e3o distribu\u00eddos aos investidores sob a forma de NFTs (tokens n\u00e3o\r\nfung\u00edveis), conforme especificado no presente Contrato.\r\n1.3 A plataforma da KLA Invest t\u00e9r\u00e1 exclusividade para a distribui\u00e7\u00e3o dos NFTs\r\nTokenizados relacionados ao Projeto do Concedente, bem como para a\r\nadministra\u00e7\u00e3o das transa\u00e7\u00f5es e registros em blockchain.\r\n2. NFTs e Smart Contracts\r\n2.1 Cada NFT emitido pela Concession\u00e1ria garantir\u00e1 ao investidor os benef\u00edcios\r\nespec\u00edficos relacionados ao projeto Tokenizado, conforme detalhado no Whitepaper\r\ndisponibilizado pela Concession\u00e1ria e definidos em conformidade com o projeto da\r\nconcedente.\r\n2.2 A Concession\u00e1ria \u00e9 apenas uma empresa intermediadora que apresenta Projetos\r\nde terceiros a potenciais clientes investidores. Dessa forma, as informa\u00e7\u00f5es indicadas\r\nno Projeto foram produzidas integralmente pela Concedente, que \u00e9 a exclusiva\r\nrespons\u00e1vel perante o cliente adquirente do token, assim como perante as\r\nautoridades governamentais.\r\n2.3 A Concedente deve garantir a exist\u00eancia do Projeto, a lisura na sua condu\u00e7\u00e3o,\r\ngovernan\u00e7a das atividades empresariais e gest\u00e3o com o denodo e zelo aplicado \u00e0\r\nesp\u00e9cie.\r\n2.4 A Concession\u00e1ria deve garantir a legalidade na capta\u00e7\u00e3o dos recursos e a\r\ndisponibiliza\u00e7\u00e3o dos recursos \u00e0 Concedente, t\u00e3o logo se encerre o per\u00edodo de\r\ncapta\u00e7\u00e3o e tenha sido alcan\u00e7ada a meta de capta\u00e7\u00e3o.DocuSign Envelope ID: 1EB2C95C-851D-461B-AD22-4E15EE3A2E67\r\n2.5 Os direitos, benef\u00edcios e obriga\u00e7\u00f5es vinculados aos NFTs ser\u00e3o automaticamente\r\ngarantidos por meio de smart contracts, os quais ser\u00e3o incorporados \u00e0 plataforma da\r\nKLA Invest.\r\n2.5 Os smart contracts garantir\u00e3o a seguran\u00e7a digital e jur\u00eddica das transa\u00e7\u00f5es\r\nrealizadas na plataforma, fornecendo um mecanismo de registro autom\u00e1tico e\r\ntransparente.\r\n3. Informa\u00e7\u00f5es sobre os Projetos\r\n3.1 A Concession\u00e1ria disponibilizar\u00e1 todas as informa\u00e7\u00f5es relevantes sobre cada\r\nprojeto Tokenizado no whitepaper correspondente, que descrever\u00e1 em detalhes os\r\nbenef\u00edcios espec\u00edficos oferecidos a cada investidor.\r\n3.2 O whitepaper \u00e9 produzido com base no Projeto que \u00e9 produzido integralmente\r\npela Concedente, a sua exclusiva responsabilidade. Dessa forma, caso o cliente\r\nadquirente do Token deseje esclarecimentos acerca do Projeto, a Concedente dever\u00e1\r\nrespond\u00ea-lo com todas as informa\u00e7\u00f5es t\u00e9cnicas, baseadas no estudo.\r\n3.3 A p\u00e1gina do projeto no site da KLA Invest tamb\u00e9m fornecer\u00e1 informa\u00e7\u00f5es\r\nadicionais, incluindo detalhes sobre as obriga\u00e7\u00f5es do investidor, prazos, termos e\r\ncondi\u00e7\u00f5es aplic\u00e1veis ao investimento.\r\n4. Confidencialidade e Prote\u00e7\u00e3o de Dados\r\n4.1 As partes concordam em tratar todas as informa\u00e7\u00f5es confidenciais obtidas no\r\n\u00e2mbito deste Contrato com estrita confidencialidade, de acordo com a legisla\u00e7\u00e3o\r\naplic\u00e1vel em mat\u00e9ria de prote\u00e7\u00e3o de dados.\r\n4.2 A Concession\u00e1ria ser\u00e1 respons\u00e1vel pela seguran\u00e7a e privacidade dos dados dos\r\ninvestidores, garantindo a conformidade com as leis e regulamentos aplic\u00e1veis em\r\nrela\u00e7\u00e3o \u00e0 prote\u00e7\u00e3o de dados.\r\n5. Vig\u00eancia e Rescis\u00e3o\r\n5.1 Este Contrato entrar\u00e1 em vigor na data de assinatura pelas partes e ter\u00e1 vig\u00eancia\r\nat\u00e9 o final do prazo estabelecido para a venda dos NFTs relacionados ao Projeto,,\r\ninadmitindo rescis\u00e3o sem justa causa.\r\n5.2 Poder\u00e1, entretanto, ser rescindido em caso de: (i) descumprimento de qualquer\r\ncl\u00e1usula do contrato; (ii) caso se verifique falhas no Projeto ou aus\u00eancia de substrato\r\nnas opera\u00e7\u00f5es da Concedente; (iii) caso a meta de capta\u00e7\u00e3o n\u00e3o seja alcan\u00e7ada ou\r\nrevista dentro do prazo; (iv) caso se verifique o crescimento do endividamento da\r\nConcedente que poder\u00e1 culminar com sua insolv\u00eancia.\r\n5.3 A rescis\u00e3o deste Contrato n\u00e3o afetar\u00e1 os direitos e obriga\u00e7\u00f5es decorrentes de\r\ntransa\u00e7\u00f5es conclu\u00eddas anteriormente \u00e0 rescis\u00e3o, inclusive perante os clientes\r\nadquirentes dos NFTs, cuja responsabilidade prec\u00edpua \u00e9 da Concedente.DocuSign Envelope ID: 1EB2C95C-851D-461B-AD22-4E15EE3A2E67\r\n6. Disposi\u00e7\u00f5es Gerais\r\n6.1 Qualquer modifica\u00e7\u00e3o ou altera\u00e7\u00e3o deste Contrato somente ter\u00e1 validade se\r\nrealizada por escrito e assinada por ambas as partes.\r\n6.2 O presente Contrato ser\u00e1 regido pelas leis brasileiras e eventuais disputas ser\u00e3o\r\nsubmetidas \u00e0 jurisdi\u00e7\u00e3o exclusiva dos tribunais competentes da mesma.\r\n6.3 Qualquer notifica\u00e7\u00e3o ou comunica\u00e7\u00e3o entre as partes dever\u00e1 ser feita por escrito\r\ne entregue pessoalmente, por correio registrado ou por meios eletr\u00f4nicos\r\nespecificados pelas partes.\r\n7. Execu\u00e7\u00e3o dos Servi\u00e7os\r\n7.1 A Concedente se compromete a receber o investimento aportado pelos\r\ninvestidores e se responsabiliza pela aplica\u00e7\u00e3o adequada dos recursos com o\r\nobjetivo de gerar lucros para todos os s\u00f3cios investidores, de acordo com os termos\r\nestabelecidos neste Contrato.\r\n7.2 A Concedente realizar\u00e1 todos os esfor\u00e7os razo\u00e1veis para maximizar o retorno dos\r\ninvestimentos e buscar\u00e1 oportunidades de crescimento e rentabilidade, observando\r\nboas pr\u00e1ticas de gest\u00e3o financeira e considerando as necessidades e expectativas\r\ndos investidores.\r\n7.3 A Concedente se compromete a manter uma comunica\u00e7\u00e3o aberta e constante\r\ncom os investidores, fornecendo atualiza\u00e7\u00f5es regulares sobre o desempenho do\r\nprojeto Tokenizado e quaisquer outros assuntos relevantes.\r\n7.4 A Concedente se compromete a apresentar relat\u00f3rios peri\u00f3dicos, pelo menos a\r\ncada 3 meses, nos quais dever\u00e1 fornecer informa\u00e7\u00f5es detalhadas sobre a utiliza\u00e7\u00e3o\r\ndos recursos, o desempenho financeiro, bem como quaisquer eventos relevantes\r\nque possam impactar os investidores.\r\n7.5 A Concedente se compromete a realizar os pagamentos de dividendos, se houver,\r\nde acordo com as participa\u00e7\u00f5es de cada cliente investidor, de forma justa e\r\nproporcional aos investimentos realizados pelos investidores. A data e forma de\r\npagamento dos dividendos ser\u00e3o definidas pela Concedente e informada aos\r\nclientes adquirentes dos NFTs.\r\n7.6 A Concedente concorda em cumprir todas as obriga\u00e7\u00f5es legais e regulat\u00f3rias\r\nrelacionadas \u00e0 gest\u00e3o financeira, relat\u00f3rios cont\u00e1beis e pagamento de dividendos.\r\n7.7 Qualquer altera\u00e7\u00e3o substancial nas pol\u00edticas de investimento, na utiliza\u00e7\u00e3o dos\r\nrecursos ou na estrat\u00e9gia de gera\u00e7\u00e3o de lucros dever\u00e1 ser comunicada previamente\r\naos investidores, de forma a garantir a transpar\u00eancia e o entendimento m\u00fatuo das\r\npartes.DocuSign Envelope ID: 1EB2C95C-851D-461B-AD22-4E15EE3A2E67\r\n8. Valores e Detalhes do Projeto\r\n8.1 O Projeto SolarSim requer um investimento total de R$375.000,00 (Trezentos e\r\nsetenta e cinco mil reais) para cada micro usina a ser criada.\r\n8.2 O investimento ser\u00e1 dividido em cotas, que poder\u00e3o ser iguais ou proporcionais,\r\nde acordo com as especifica\u00e7\u00f5es definidas pela Concedente e aprovadas pela\r\nConcession\u00e1ria.\r\n8.3 A venda das cotas de investimento ser\u00e1 realizada exclusivamente por meio da\r\nplataforma da KLA Invest, utilizando a tecnologia blockchain para a tokeniza\u00e7\u00e3o dos\r\nativos e a distribui\u00e7\u00e3o dos NFTs correspondentes.\r\n8.4 Como padr\u00e3o, a KLA Invest incluir\u00e1 uma taxa administrativa no valor total do\r\ninvestimento de 12%. Essa taxa ser\u00e1 destinada a cobrir os custos operacionais,\r\ncomunica\u00e7\u00e3o e marketing, custos relacionados \u00e0 tecnologia e demais despesas\r\nnecess\u00e1rias para a execu\u00e7\u00e3o adequada do projeto, e poder\u00e3o ser retidas no\r\nmomento da disponibiliza\u00e7\u00e3o dos recursos para a Concedente.\r\n8.5 A distribui\u00e7\u00e3o dos recursos captados por meio do investimento ser\u00e1 realizada de\r\nacordo com a estrat\u00e9gia definida pela Concedente e comunicada aos investidores. A\r\naloca\u00e7\u00e3o dos recursos considerar\u00e1 as necessidades do projeto e buscar\u00e1 maximizar o\r\npotencial de retorno para os investidores.\r\n8.6 A Concession\u00e1ria e a Concedente concordam em manter registros precisos e\r\natualizados de todas as transa\u00e7\u00f5es e movimenta\u00e7\u00f5es financeiras relacionadas ao\r\nprojeto, a fim de garantir a transpar\u00eancia e presta\u00e7\u00e3o de contas aos investidores.\r\nAs partes declaram ter lido e compreendido o presente Contrato de Concess\u00e3o e\r\nconcordam em cumprir todas as suas disposi\u00e7\u00f5es.\r\nEmpresa GSA PARTICIPA\u00c7\u00d5ES (Concedente)\r\n*\r\n */\r\n\r\n/**\r\n * @dev ERC721 token with storage based token URI management.\r\n */\r\ncontract KlaussCollections is ERC721MetadataMintable {\r\n\r\n    constructor() public ERC721Metadata(\"KLAUSS Collections\", \"KLAUSS Collections\")\r\n    {\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"mintWithTokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "KlaussCollections", "CompilerVersion": "v0.5.1+commit.c8a2cb62", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://fecfb667038a9994cbadafc0f40e6d42368de022cc59b20982a6cf39a8f0b0e2"}