{"SourceCode": "{\"EIP20NonStandardInterface.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface EIP20NonStandardInterface {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"},\"ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title GammaTroller ErrorReporter \\n */\\ncontract GammatrollerErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        GAMMATROLLER_MISMATCH,\\n        INSUFFICIENT_SHORTFALL,\\n        INSUFFICIENT_LIQUIDITY,\\n        INVALID_CLOSE_FACTOR,\\n        INVALID_COLLATERAL_FACTOR,\\n        INVALID_LIQUIDATION_INCENTIVE,\\n        MARKET_NOT_ENTERED, // no longer possible\\n        MARKET_NOT_LISTED,\\n        MARKET_ALREADY_LISTED,\\n        MATH_ERROR,\\n        NONZERO_BORROW_BALANCE,\\n        PRICE_ERROR,\\n        REJECTION,\\n        SNAPSHOT_ERROR,\\n        TOO_MANY_ASSETS,\\n        TOO_MUCH_REPAY\\n    }\\n\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n        EXIT_MARKET_BALANCE_OWED,\\n        EXIT_MARKET_REJECTION,\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\n        SET_CLOSE_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\n        SUPPORT_MARKET_EXISTS,\\n        SUPPORT_MARKET_OWNER_CHECK,\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\n/**\\n * @title Token ErrorReporter\\n */\\ncontract TokenErrorReporter {\\n    uint public constant NO_ERROR = 0; // support legacy return codes\\n\\n    error TransferGammatrollerRejection(uint256 errorCode);\\n    error TransferNotAllowed();\\n    error TransferNotEnough();\\n    error TransferTooMuch();\\n\\n    error MintGammatrollerRejection(uint256 errorCode);\\n    error MintFreshnessCheck();\\n\\n    error RedeemGammatrollerRejection(uint256 errorCode);\\n    error RedeemFreshnessCheck();\\n    error RedeemTransferOutNotPossible();\\n\\n    error BorrowGammatrollerRejection(uint256 errorCode);\\n    error BorrowFreshnessCheck();\\n    error BorrowCashNotAvailable();\\n\\n    error RepayBorrowGammatrollerRejection(uint256 errorCode);\\n    error RepayBorrowFreshnessCheck();\\n\\n    error LiquidateGammatrollerRejection(uint256 errorCode);\\n    error LiquidateFreshnessCheck();\\n    error LiquidateCollateralFreshnessCheck();\\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\n    error LiquidateLiquidatorIsBorrower();\\n    error LiquidateCloseAmountIsZero();\\n    error LiquidateCloseAmountIsUintMax();\\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\\n\\n    error LiquidateSeizeGammatrollerRejection(uint256 errorCode);\\n    error LiquidateSeizeLiquidatorIsBorrower();\\n\\n    error AcceptAdminPendingAdminCheck();\\n\\n    error SetGammatrollerOwnerCheck();\\n    error SetPendingAdminOwnerCheck();\\n\\n    error SetReserveFactorAdminCheck();\\n    error SetReserveFactorFreshCheck();\\n    error SetReserveFactorBoundsCheck();\\n\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\n\\n    error ReduceReservesAdminCheck();\\n    error ReduceReservesFreshCheck();\\n    error ReduceReservesCashNotAvailable();\\n    error ReduceReservesCashValidation();\\n\\n    error SetInterestRateModelOwnerCheck();\\n    error SetInterestRateModelFreshCheck();\\n\\n    error SetDiscountLevelAdminCheck();\\n\\n    error SetWithdrawFeeFactorFreshCheck();\\n    error SetWithdrawFeeFactorBoundsCheck();\\n}\"},\"GammatrollerInterface.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\nimport \\\"./PriceOracleInterface.sol\\\";\\n\\n\\nabstract contract GammatrollerInterface {\\n    /// @notice Indicator that this is a Gammatroller contract (for inspection)\\n    bool public constant isGammatroller = true;\\n\\n    //PriceOracle public oracle; -- ------------------------\\n    function getOracle() virtual external view returns (PriceOracleInterface);\\n    \\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata gTokens) virtual external returns (uint[] memory);\\n    function exitMarket(address gToken) virtual external returns (uint);\\n\\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(address gToken, address minter, uint mintAmount) virtual external returns (uint);\\n\\n    function redeemAllowed(address gToken, address redeemer, uint redeemTokens) virtual external returns (uint);\\n    function redeemVerify(address gToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\\n\\n    function borrowAllowed(address gToken, address borrower, uint borrowAmount) virtual external returns (uint);\\n\\n    function repayBorrowAllowed(\\n        address gToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount) virtual external returns (uint);\\n\\n    function liquidateBorrowAllowed(\\n        address gTokenBorrowed,\\n        address gTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount) virtual external returns (uint);\\n\\n    function seizeAllowed(\\n        address gTokenCollateral,\\n        address gTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) virtual external returns (uint);\\n\\n    function transferAllowed(address gToken, address src, address dst, uint transferTokens) virtual external returns (uint);\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address gTokenBorrowed,\\n        address gTokenCollateral,\\n        uint repayAmount) virtual external view returns (uint, uint);\\n\\n    function updateFactor(address _user, uint256 _newiGammaBalance) virtual external;\\n    function getGammaSpeed(address market) virtual external view returns (uint);\\n    function getGammaBoostPercentage(address market) virtual external view returns (uint);\\n\\n\\n\\n    // delete later\\n\\n    function _supportMarket(GTokenInterface gToken) virtual external returns (uint);\\n    function _setCollateralFactor(GTokenInterface gToken, uint newCollateralFactorMantissa) virtual external returns (uint);\\n    function getAllMarkets() virtual external returns (GTokenInterface[] memory);\\n    \\n}\\n\"},\"GammatrollerStorage.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./PriceOracleInterface.sol\\\";\\nimport \\\"./GTokenInterface.sol\\\";\\n\\n\\ncontract UnitrollerAdminStorage {\\n    /**\\n    * @notice Administrator for this contract\\n    */\\n    address public admin;\\n\\n    /**\\n    * @notice Pending administrator for this contract\\n    */\\n    address public pendingAdmin;\\n\\n    /**\\n    * @notice Active brains of Unitroller\\n    */\\n    address public implementation;\\n\\n    /**\\n    * @notice Pending brains of Unitroller\\n    */\\n    address public pendingGammatrollerImplementation;\\n}\\n\\ncontract GammatrollerV1Storage is UnitrollerAdminStorage {\\n\\n    bool public transferGuardianPaused;\\n    bool public seizeGuardianPaused;\\n    bool public stakeGammaToVault;\\n\\n     /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint public closeFactorMantissa;\\n\\n     /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint public liquidationIncentiveMantissa;\\n\\n    address public gammaInfinityVaultAddress;\\n    address public reservoirAddress;\\n\\n    /**\\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\n     *  Actions which allow users to remove their own assets cannot be paused.\\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n     */\\n    address public pauseGuardian;\\n\\n      struct Market {\\n        /// @notice Whether or not this market is listed\\n        bool isListed;\\n\\n        /**\\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\\n         *  Must be between 0 and 1, and stored as a mantissa.\\n         */\\n        uint collateralFactorMantissa;\\n\\n        /// @notice Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address =\\u003e bool) accountMembership;\\n\\n\\n    }\\n\\n    struct GammaMarketState {\\n        /// @notice The market\\u0027s last updated gammaBorrowIndex or gammaSupplyIndex\\n        uint224 index;\\n\\n        /// @notice The market\\u0027s last updated gammaSupplyBoostIndex\\n        uint224 boostIndex;\\n\\n        /// @notice The block number the index was last updated at\\n        uint32 block;\\n    }\\n\\n    /**\\n     * @notice Per-account mapping of \\\"assets you are in\\\"\\n     */\\n    mapping(address =\\u003e GTokenInterface[]) public accountAssets;\\n  \\n    /**\\n     * @notice Official mapping of gTokens -\\u003e Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address =\\u003e Market) public markets;\\n    mapping(address =\\u003e bool) public mintGuardianPaused;\\n    mapping(address =\\u003e bool) public borrowGuardianPaused;\\n\\n\\n    /// @notice The portion of gammaRate that each market currently receives\\n    mapping(address =\\u003e uint) public gammaSpeeds;\\n\\n    /// @notice The gammaBoostPercentage of each market\\n    mapping(address =\\u003e uint) public gammaBoostPercentage;\\n\\n    /// @notice The GAMMAmarket supply state for each market\\n    mapping(address =\\u003e GammaMarketState) public gammaSupplyState;\\n\\n    /// @notice The GAMMAmarket borrow state for each market\\n    mapping(address =\\u003e GammaMarketState) public gammaBorrowState;\\n\\n    /// @notice The GAMMA supply index for each market for each supplier as of the last time they accrued GAMMA\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) public gammaSupplierIndex;\\n\\n    /// @notice The GAMMAborrow index for each market for each borrower as of the last time they accrued GAMMA\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) public gammaBorrowerIndex;\\n\\n    /// @notice The GAMMA supply boost index for each market for each supplier as of the last time they accrued GAMMA\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) public gammaSupplierBoostIndex;\\n\\n    /// @notice The GAMMA borrow boost index for each market for each borrower as of the last time they accrued GAMMA\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) public gammaBorrowerBoostIndex;\\n\\n    /// @notice The GAMMAaccrued but not yet transferred to each user\\n    mapping(address =\\u003e uint) public gammaAccrued;\\n\\n\\n    // @notice Borrow caps enforced by borrowAllowed for each gToken address. Defaults to zero which corresponds to unlimited borrowing.\\n    mapping(address =\\u003e uint) public borrowCaps;\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    PriceOracleInterface public oracle;\\n\\n    /// @notice A list of all markets\\n    GTokenInterface[] public allMarkets;\\n\\n    /// @notice A list of all Boosted markets\\n    GTokenInterface[] public allBoostedMarkets;\\n\\n    //@notice addresses authorized to withdraw claimed gamma directly into their account\\n    mapping(address =\\u003e bool) public authorizedToClaim;\\n  \\n\\n    \\n}\\n\\n\\n\"},\"GTokenInterface.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\nimport \\\"./GammatrollerInterface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./PlanetDiscountInterface.sol\\\";\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\n\\n/**\\n * @title Planet\\u0027s GTokenInterfaces Contract\\n * @notice GTokens interfaces \\n * @author astronaut\\n */\\n\\ncontract GTokenStorage {\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice Whether or not this market\\u0027s boost is permanently turned off\\n    */\\n    bool public isBoostDeprecated;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\\n     */\\n\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n    /**\\n     * @notice Maximum fraction of interest that can be set aside for reserves\\n     */\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\n    \\n    /**\\n     * @notice Administrator for this contract\\n     */\\n    address payable public admin;\\n\\n    /**\\n     * @notice Pending administrator for this contract\\n     */\\n    address payable public pendingAdmin;\\n\\n    /**\\n     * @notice Contract which oversees inter-gToken operations\\n     */\\n    GammatrollerInterface public gammatroller;\\n\\n    /**\\n     * @notice Contract which return current discount contract\\n     */\\n    PlanetDiscount public discountLevel;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    /**\\n     * @notice Initial exchange rate used when minting the first GTokens (used when totalSupply = 0)\\n     */\\n    uint internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint public totalSupply;\\n\\n    /**\\n     * @notice Sum of all user factors\\n     */\\n    uint public totalFactor;\\n\\n    /**\\n     *  @notice Infinity Gamma Address\\n     */\\n    address public iGamma;\\n\\n    /**\\n     * @notice Official record of token balances for each account\\n     */\\n    mapping (address =\\u003e uint) internal accountTokens;\\n\\n    /**\\n     * @notice Official record of user factors for each account\\n     */\\n    mapping (address =\\u003e uint) internal userFactors;\\n\\n    /**\\n     * @notice Approved token transfer amounts on behalf of others\\n     */\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) internal transferAllowances;\\n\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint principal;\\n        uint interestIndex;\\n    }\\n\\n    /**\\n     * @notice Mapping of account addresses to outstanding borrow balances\\n     */\\n    mapping(address =\\u003e BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Share of seized collateral that is added to reserves\\n     */\\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\\n\\n}\\n\\nabstract contract GTokenInterface is GTokenStorage {\\n    /**\\n     * @notice Indicator that this is a GToken contract (for inspection)\\n     */\\n    bool public constant isGToken = true;\\n\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address gTokenCollateral, uint seizeTokens);\\n\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is changed\\n     */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\n     */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /**\\n     * @notice Event emitted when gammatroller is changed\\n     */\\n    event NewGammatroller(GammatrollerInterface oldGammatroller, GammatrollerInterface newGammatroller);\\n\\n     /**\\n     * @notice Event emitted when discount level is changed\\n     */\\n    event NewDiscountLevel(PlanetDiscount oldDiscountLevel, PlanetDiscount newDiscountLevel);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\n    \\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /**\\n     * @notice Event emitted when the iGammaAddress is updated\\n     */\\n\\n    event iGammaAddressUpdated(address _newiGammaAddress);\\n\\n    /**\\n     * @notice Failure event\\n     */\\n\\n\\n    /*** User Interface ***/\\n\\n    function transfer(address dst, uint amount) virtual external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\\n    function approve(address spender, uint amount) virtual external returns (bool);\\n    function allowance(address owner, address spender) virtual external view returns (uint);\\n    function balanceOf(address owner) virtual external view returns (uint);\\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() virtual external view returns (uint);\\n    function supplyRatePerBlock() virtual external view returns (uint);\\n    function totalBorrowsCurrent() virtual external returns (uint);\\n    function borrowBalanceCurrent(address account) virtual external returns (uint);\\n    function borrowBalanceStored(address account) virtual external view returns (uint);\\n    function exchangeRateCurrent() virtual external returns (uint);\\n    function exchangeRateStored() virtual external view returns (uint);\\n    function getCash() virtual external view returns (uint);\\n    function accrueInterest() virtual external returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\\n    function getBoostDeprecatedStatus() virtual external view returns (bool);\\n    function getMarketData() virtual external view returns (uint256, uint256);\\n    function getUserData(address user) virtual external view returns (uint256, uint256);\\n    function updateUserAndTotalFactors(address user, uint256 iGammaBalanceOfUser) virtual external;\\n    function deprecateBoost() virtual external;  \\n\\n    /*** Admin Functions ***/\\n\\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\\n    function _acceptAdmin() virtual external returns (uint);\\n    function _setGammatroller(GammatrollerInterface newGammatroller) virtual public returns (uint);\\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);\\n    function _updateiGammaAddress(address _newiGammaAddress) virtual external;\\n}\\n\\ncontract GErc20Storage {\\n    /**\\n     * @notice Underlying asset for this GToken\\n     */\\n    address public underlying;\\n}\\n\\nabstract contract GErc20Interface is GErc20Storage {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) virtual external returns (uint);\\n    function redeem(uint redeemTokens) virtual external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\\n    function borrow(uint borrowAmount) virtual external returns (uint);\\n    function repayBorrow(uint repayAmount) virtual external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, GTokenInterface gTokenCollateral) virtual external returns (uint);\\n    function sweepToken(EIP20NonStandardInterface token) virtual external;\\n\\n\\n    /*** Admin Functions ***/\\n\\n    function _addReserves(uint addAmount) virtual external returns (uint);\\n}\\n\\ncontract GDelegationStorage {\\n    /**\\n     * @notice Implementation address for this contract\\n     */\\n    address public implementation;\\n}\\n\\nabstract contract GDelegatorInterface is GDelegationStorage {\\n    /**\\n     * @notice Emitted when implementation is changed\\n     */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) virtual external;\\n}\\n\\nabstract contract GDelegateInterface is GDelegationStorage {\\n    /**\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\n     * @param data The encoded bytes data for any initialization\\n     */\\n    function _becomeImplementation(bytes memory data) virtual external;\\n\\n    /**\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\n     */\\n    function _resignImplementation() virtual external;\\n}\"},\"InterestRateModel.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\n/**\\n  * @title Compound\\u0027s InterestRateModel Interface\\n  * @author Compound\\n  */\\nabstract contract InterestRateModel {\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n    bool public constant isInterestRateModel = true;\\n\\n    /**\\n      * @notice Calculates the current borrow interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\\n\\n    /**\\n      * @notice Calculates the current supply interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param reserveFactorMantissa The current reserve factor the market has\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\\n\\n}\\n\"},\"PlanetDiscountInterface.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\ninterface PlanetDiscount{\\n    \\n    function changeUserSupplyDiscount(address minter) external returns(uint _totalSupply,uint _accountTokens);\\n    \\n    function changeUserBorrowDiscount(address borrower) external returns(uint ,uint , uint, uint);\\n        \\n    function changeLastBorrowAmountDiscountGiven(address borrower,uint borrowAmount) external;\\n            \\n    function returnBorrowUserArr(address market) external view returns(address[] memory);\\n        \\n    function borrowDiscountSnap(address market,address user) external view returns(bool,uint,uint,uint,uint);\\n    \\n    function totalDiscountGiven(address market) external view returns(uint);\\n\\n    function listMarket(address market) external returns(bool);\\n\\n    //delete later\\n     function changeAddress(address _newgGammaAddress,address _newGammatroller,address _newOracle,address _newInfinityVault) external returns(bool);\\n}\"},\"PriceOracleInterface.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\nimport \\\"./GTokenInterface.sol\\\";\\n\\ninterface PriceOracleInterface {\\n  \\n    function getUnderlyingPrice(GTokenInterface gToken) external view returns (uint);\\n    function validate(address gToken) external returns(uint, bool);\\n\\n\\n}\"},\"Unitroller.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./GammatrollerStorage.sol\\\";\\n\\n/**\\n * @title GammatrollerCore\\n * @dev storage for the gammatroller will be at this address, and\\n * gTokens should reference this contract rather than a deployed implementation if\\n * Contracts to be included ErrorReporter, GammatrollerStorage, PriceOracleInterface, GTokenInterface, GammatrollerInterface, InterestRateModel,\\n * PlanetDiscountInterface, EIP20NonStandardInterface\\n */\\ncontract Unitroller is UnitrollerAdminStorage, GammatrollerErrorReporter {\\n\\n    /**\\n      * @notice Emitted when pendingGammatrollerImplementation is changed\\n      */\\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingGammatrollerImplementation is accepted, which means gammatroller implementation is updated\\n      */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is changed\\n      */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n      */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() {\\n        // Set admin to caller\\n        admin = msg.sender;\\n    }\\n\\n    /*** Admin Functions ***/\\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\\n\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\\n        }\\n\\n        address oldPendingImplementation = pendingGammatrollerImplementation;\\n\\n        pendingGammatrollerImplementation = newPendingImplementation;\\n\\n        emit NewPendingImplementation(oldPendingImplementation, pendingGammatrollerImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n    * @notice Accepts new implementation of gammatroller. msg.sender must be pendingImplementation\\n    * @dev Admin function for new implementation to accept it\\u0027s role as implementation\\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n    */\\n    function _acceptImplementation() public returns (uint) {\\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\\n        if (msg.sender != pendingGammatrollerImplementation || pendingGammatrollerImplementation == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldImplementation = implementation;\\n        address oldPendingImplementation = pendingGammatrollerImplementation;\\n\\n        implementation = pendingGammatrollerImplementation;\\n\\n        pendingGammatrollerImplementation = address(0);\\n\\n        emit NewImplementation(oldImplementation, implementation);\\n        emit NewPendingImplementation(oldPendingImplementation, pendingGammatrollerImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      *\\n      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() public returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    fallback () payable external {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = implementation.delegatecall(msg.data);\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n              let free_mem_ptr := mload(0x40)\\n              returndatacopy(free_mem_ptr, 0, returndatasize())\\n\\n              switch success\\n              case 0 { revert(free_mem_ptr, returndatasize()) }\\n              default { return(free_mem_ptr, returndatasize()) }\\n        }\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingImplementation\",\"type\":\"address\"}],\"name\":\"NewPendingImplementation\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_acceptImplementation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingImplementation\",\"type\":\"address\"}],\"name\":\"_setPendingImplementation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGammatrollerImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Unitroller", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x7153108655fbe0d2d687ffdc0956df142d874289", "SwarmSource": "ipfs://55575c54f47979e7e47ab6bb65d79fd8a7f5cdab907190593d72bcfb66308a88"}