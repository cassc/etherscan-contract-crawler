{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/PositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./interfaces/IRouter.sol\\\";\\r\\nimport \\\"./interfaces/IVault.sol\\\";\\r\\nimport \\\"./interfaces/IOrderBook.sol\\\";\\r\\n\\r\\nimport \\\"../peripherals/interfaces/ITimelock.sol\\\";\\r\\nimport \\\"./BasePositionManager.sol\\\";\\r\\n\\r\\ncontract PositionManager is BasePositionManager {\\r\\n    address public immutable orderBook;\\r\\n    bool public inLegacyMode;\\r\\n\\r\\n    bool public shouldValidateIncreaseOrder;\\r\\n\\r\\n    mapping(address => bool) public isOrderKeeper;\\r\\n    mapping(address => bool) public isPartner;\\r\\n    mapping(address => bool) public isLiquidator;\\r\\n\\r\\n    event SetOrderKeeper(address indexed account, bool isActive);\\r\\n    event SetLiquidator(address indexed account, bool isActive);\\r\\n    event SetPartner(address account, bool isActive);\\r\\n    event SetInLegacyMode(bool inLegacyMode);\\r\\n    event SetShouldValidateIncreaseOrder(bool shouldValidateIncreaseOrder);\\r\\n\\r\\n    modifier onlyOrderKeeper() {\\r\\n        require(isOrderKeeper[msg.sender], \\\"PositionManager: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyLiquidator() {\\r\\n        require(isLiquidator[msg.sender], \\\"PositionManager: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPartnersOrLegacyMode() {\\r\\n        require(\\r\\n            isPartner[msg.sender] || inLegacyMode,\\r\\n            \\\"PositionManager: forbidden\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _vault,\\r\\n        address _router,\\r\\n        address _shortsTracker,\\r\\n        address _weth,\\r\\n        uint256 _depositFee,\\r\\n        address _orderBook\\r\\n    )\\r\\n        public\\r\\n        BasePositionManager(_vault, _router, _shortsTracker, _weth, _depositFee)\\r\\n    {\\r\\n        orderBook = _orderBook;\\r\\n        shouldValidateIncreaseOrder = true;\\r\\n        inLegacyMode = true;\\r\\n    }\\r\\n\\r\\n    function setOrderKeeper(address _account, bool _isActive)\\r\\n        external\\r\\n        onlyAdmin\\r\\n    {\\r\\n        isOrderKeeper[_account] = _isActive;\\r\\n        emit SetOrderKeeper(_account, _isActive);\\r\\n    }\\r\\n\\r\\n    function setLiquidator(address _account, bool _isActive)\\r\\n        external\\r\\n        onlyAdmin\\r\\n    {\\r\\n        isLiquidator[_account] = _isActive;\\r\\n        emit SetLiquidator(_account, _isActive);\\r\\n    }\\r\\n\\r\\n    function setPartner(address _account, bool _isActive) external onlyAdmin {\\r\\n        isPartner[_account] = _isActive;\\r\\n        emit SetPartner(_account, _isActive);\\r\\n    }\\r\\n\\r\\n    function setInLegacyMode(bool _inLegacyMode) external onlyAdmin {\\r\\n        inLegacyMode = _inLegacyMode;\\r\\n        emit SetInLegacyMode(_inLegacyMode);\\r\\n    }\\r\\n\\r\\n    function setShouldValidateIncreaseOrder(bool _shouldValidateIncreaseOrder)\\r\\n        external\\r\\n        onlyAdmin\\r\\n    {\\r\\n        shouldValidateIncreaseOrder = _shouldValidateIncreaseOrder;\\r\\n        emit SetShouldValidateIncreaseOrder(_shouldValidateIncreaseOrder);\\r\\n    }\\r\\n\\r\\n    function increasePosition(\\r\\n        address[] memory _path,\\r\\n        address _indexToken,\\r\\n        uint256 _amountIn,\\r\\n        uint256 _minOut,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        uint256 _price,\\r\\n        bytes32 _referralCode\\r\\n    ) external nonReentrant onlyPartnersOrLegacyMode {\\r\\n        require(\\r\\n            _path.length == 1 || _path.length == 2,\\r\\n            \\\"PositionManager: invalid _path.length\\\"\\r\\n        );\\r\\n\\r\\n        _setTraderReferralCode(_referralCode);\\r\\n\\r\\n        if (_amountIn > 0) {\\r\\n            if (_path.length == 1) {\\r\\n                IRouter(router).pluginTransfer(\\r\\n                    _path[0],\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    _amountIn\\r\\n                );\\r\\n            } else {\\r\\n                IRouter(router).pluginTransfer(\\r\\n                    _path[0],\\r\\n                    msg.sender,\\r\\n                    vault,\\r\\n                    _amountIn\\r\\n                );\\r\\n                _amountIn = _swap(_path, _minOut, address(this));\\r\\n            }\\r\\n\\r\\n            uint256 afterFeeAmount = _collectFees(\\r\\n                msg.sender,\\r\\n                _path,\\r\\n                _amountIn,\\r\\n                _indexToken,\\r\\n                _isLong,\\r\\n                _sizeDelta\\r\\n            );\\r\\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\\r\\n        }\\r\\n\\r\\n        _increasePosition(\\r\\n            msg.sender,\\r\\n            _path[_path.length - 1],\\r\\n            _indexToken,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            _price\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function increasePositionETH(\\r\\n        address[] memory _path,\\r\\n        address _indexToken,\\r\\n        uint256 _minOut,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        uint256 _price,\\r\\n        bytes32 _referralCode\\r\\n    ) external payable nonReentrant onlyPartnersOrLegacyMode {\\r\\n        require(\\r\\n            _path.length == 1 || _path.length == 2,\\r\\n            \\\"PositionManager: invalid _path.length\\\"\\r\\n        );\\r\\n        require(_path[0] == weth, \\\"PositionManager: invalid _path\\\");\\r\\n\\r\\n        _setTraderReferralCode(_referralCode);\\r\\n\\r\\n        if (msg.value > 0) {\\r\\n            _transferInETH();\\r\\n            uint256 _amountIn = msg.value;\\r\\n\\r\\n            if (_path.length > 1) {\\r\\n                IERC20(weth).safeTransfer(vault, msg.value);\\r\\n                _amountIn = _swap(_path, _minOut, address(this));\\r\\n            }\\r\\n\\r\\n            uint256 afterFeeAmount = _collectFees(\\r\\n                msg.sender,\\r\\n                _path,\\r\\n                _amountIn,\\r\\n                _indexToken,\\r\\n                _isLong,\\r\\n                _sizeDelta\\r\\n            );\\r\\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\\r\\n        }\\r\\n\\r\\n        _increasePosition(\\r\\n            msg.sender,\\r\\n            _path[_path.length - 1],\\r\\n            _indexToken,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            _price\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function decreasePosition(\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address _receiver,\\r\\n        uint256 _price\\r\\n    ) external nonReentrant onlyPartnersOrLegacyMode returns (uint256) {\\r\\n        uint256 amountOut = _decreasePosition(\\r\\n            msg.sender,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _collateralDelta,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            _receiver,\\r\\n            _price\\r\\n        );\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function decreasePositionETH(\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address payable _receiver,\\r\\n        uint256 _price\\r\\n    ) external nonReentrant onlyPartnersOrLegacyMode {\\r\\n        require(\\r\\n            _collateralToken == weth,\\r\\n            \\\"PositionManager: invalid _collateralToken\\\"\\r\\n        );\\r\\n\\r\\n        uint256 amountOut = _decreasePosition(\\r\\n            msg.sender,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _collateralDelta,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            address(this),\\r\\n            _price\\r\\n        );\\r\\n        _transferOutETHWithGasLimitIgnoreFail(amountOut, _receiver);\\r\\n    }\\r\\n\\r\\n    function decreasePositionAndSwap(\\r\\n        address[] memory _path,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address _receiver,\\r\\n        uint256 _price,\\r\\n        uint256 _minOut\\r\\n    ) external nonReentrant onlyPartnersOrLegacyMode returns (uint256) {\\r\\n        require(_path.length == 2, \\\"PositionManager: invalid _path.length\\\");\\r\\n\\r\\n        uint256 amount = _decreasePosition(\\r\\n            msg.sender,\\r\\n            _path[0],\\r\\n            _indexToken,\\r\\n            _collateralDelta,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            address(this),\\r\\n            _price\\r\\n        );\\r\\n        IERC20(_path[0]).safeTransfer(vault, amount);\\r\\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function decreasePositionAndSwapETH(\\r\\n        address[] memory _path,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address payable _receiver,\\r\\n        uint256 _price,\\r\\n        uint256 _minOut\\r\\n    ) external nonReentrant onlyPartnersOrLegacyMode {\\r\\n        require(_path.length == 2, \\\"PositionManager: invalid _path.length\\\");\\r\\n        require(\\r\\n            _path[_path.length - 1] == weth,\\r\\n            \\\"PositionManager: invalid _path\\\"\\r\\n        );\\r\\n\\r\\n        uint256 amount = _decreasePosition(\\r\\n            msg.sender,\\r\\n            _path[0],\\r\\n            _indexToken,\\r\\n            _collateralDelta,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            address(this),\\r\\n            _price\\r\\n        );\\r\\n        IERC20(_path[0]).safeTransfer(vault, amount);\\r\\n        uint256 amountOut = _swap(_path, _minOut, address(this));\\r\\n        _transferOutETHWithGasLimitIgnoreFail(amountOut, _receiver);\\r\\n    }\\r\\n\\r\\n    function liquidatePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        address _feeReceiver\\r\\n    ) external nonReentrant onlyLiquidator {\\r\\n        address _vault = vault;\\r\\n        address timelock = IVault(_vault).gov();\\r\\n        (uint256 size, , , , , , , ) = IVault(vault).getPosition(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong\\r\\n        );\\r\\n\\r\\n        uint256 markPrice = _isLong\\r\\n            ? IVault(_vault).getMinPrice(_indexToken)\\r\\n            : IVault(_vault).getMaxPrice(_indexToken);\\r\\n        // should be called strictly before position is updated in Vault\\r\\n        IShortsTracker(shortsTracker).updateGlobalShortData(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong,\\r\\n            size,\\r\\n            markPrice,\\r\\n            false\\r\\n        );\\r\\n\\r\\n        ITimelock(timelock).enableLeverage(_vault);\\r\\n        IVault(_vault).liquidatePosition(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong,\\r\\n            _feeReceiver\\r\\n        );\\r\\n        ITimelock(timelock).disableLeverage(_vault);\\r\\n    }\\r\\n\\r\\n    function executeSwapOrder(bytes32 _orderKey, address payable _feeReceiver)\\r\\n        external\\r\\n        onlyOrderKeeper\\r\\n    {\\r\\n        IOrderBook(orderBook).executeSwapOrder(_orderKey, _feeReceiver);\\r\\n    }\\r\\n\\r\\n    function executeIncreaseOrder(\\r\\n        bytes32 _orderKey,\\r\\n        address payable _feeReceiver\\r\\n    ) external onlyOrderKeeper {\\r\\n        _validateIncreaseOrder(_orderKey);\\r\\n\\r\\n        address _vault = vault;\\r\\n        address timelock = IVault(_vault).gov();\\r\\n\\r\\n        (\\r\\n            address _account,\\r\\n            ,\\r\\n            ,\\r\\n            /*address purchaseToken*/\\r\\n            /*uint256 purchaseTokenAmount*/\\r\\n            address collateralToken,\\r\\n            address indexToken,\\r\\n            uint256 sizeDelta,\\r\\n            bool isLong, /*uint256 triggerPrice*/ /*bool triggerAboveThreshold*/ /*uint256 executionFee*/\\r\\n            ,\\r\\n            ,\\r\\n\\r\\n        ) = IOrderBook(orderBook).getIncreaseOrder(_orderKey);\\r\\n\\r\\n        uint256 markPrice = isLong\\r\\n            ? IVault(_vault).getMaxPrice(indexToken)\\r\\n            : IVault(_vault).getMinPrice(indexToken);\\r\\n        // should be called strictly before position is updated in Vault\\r\\n        IShortsTracker(shortsTracker).updateGlobalShortData(\\r\\n            _account,\\r\\n            collateralToken,\\r\\n            indexToken,\\r\\n            isLong,\\r\\n            sizeDelta,\\r\\n            markPrice,\\r\\n            true\\r\\n        );\\r\\n\\r\\n        ITimelock(timelock).enableLeverage(_vault);\\r\\n        IOrderBook(orderBook).executeIncreaseOrder(_orderKey, _feeReceiver);\\r\\n        ITimelock(timelock).disableLeverage(_vault);\\r\\n\\r\\n        _emitIncreasePositionReferral(_account, sizeDelta);\\r\\n    }\\r\\n\\r\\n    function executeDecreaseOrder(\\r\\n        bytes32 _orderKey,\\r\\n        address payable _feeReceiver\\r\\n    ) external onlyOrderKeeper {\\r\\n        address _vault = vault;\\r\\n        address timelock = IVault(_vault).gov();\\r\\n\\r\\n        (\\r\\n            address _account,\\r\\n            address collateralToken,\\r\\n            ,\\r\\n            /*uint256 collateralDelta*/\\r\\n            address indexToken,\\r\\n            uint256 sizeDelta,\\r\\n            bool isLong, /*uint256 triggerPrice*/ /*bool triggerAboveThreshold*/ /*uint256 executionFee*/\\r\\n            ,\\r\\n            ,\\r\\n\\r\\n        ) = IOrderBook(orderBook).getDecreaseOrder(_orderKey);\\r\\n\\r\\n        uint256 markPrice = isLong\\r\\n            ? IVault(_vault).getMinPrice(indexToken)\\r\\n            : IVault(_vault).getMaxPrice(indexToken);\\r\\n        // should be called strictly before position is updated in Vault\\r\\n        IShortsTracker(shortsTracker).updateGlobalShortData(\\r\\n            _account,\\r\\n            collateralToken,\\r\\n            indexToken,\\r\\n            isLong,\\r\\n            sizeDelta,\\r\\n            markPrice,\\r\\n            false\\r\\n        );\\r\\n\\r\\n        ITimelock(timelock).enableLeverage(_vault);\\r\\n        IOrderBook(orderBook).executeDecreaseOrder(_orderKey, _feeReceiver);\\r\\n        ITimelock(timelock).disableLeverage(_vault);\\r\\n\\r\\n        _emitDecreasePositionReferral(_account, sizeDelta);\\r\\n    }\\r\\n\\r\\n    function _validateIncreaseOrder(bytes32 _orderKey) internal view {\\r\\n        (\\r\\n            address _account,\\r\\n            address _purchaseToken,\\r\\n            uint256 _purchaseTokenAmount,\\r\\n            address _collateralToken,\\r\\n            address _indexToken,\\r\\n            uint256 _sizeDelta,\\r\\n            bool _isLong, // triggerPrice // triggerAboveThreshold // executionFee\\r\\n            ,\\r\\n            ,\\r\\n\\r\\n        ) = IOrderBook(orderBook).getIncreaseOrder(_orderKey);\\r\\n\\r\\n        _validateMaxGlobalSize(_indexToken, _isLong, _sizeDelta);\\r\\n\\r\\n        if (!shouldValidateIncreaseOrder) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // shorts are okay\\r\\n        if (!_isLong) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // if the position size is not increasing, this is a collateral deposit\\r\\n        require(_sizeDelta > 0, \\\"PositionManager: long deposit\\\");\\r\\n\\r\\n        IVault _vault = IVault(vault);\\r\\n        (uint256 size, uint256 collateral, , , , , , ) = _vault.getPosition(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong\\r\\n        );\\r\\n\\r\\n        // if there is no existing position, do not charge a fee\\r\\n        if (size == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 nextSize = size.add(_sizeDelta);\\r\\n        uint256 collateralDelta = _vault.tokenToUsdMin(\\r\\n            _purchaseToken,\\r\\n            _purchaseTokenAmount\\r\\n        );\\r\\n        uint256 nextCollateral = collateral.add(collateralDelta);\\r\\n\\r\\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\\r\\n        // allow for a maximum of a increasePositionBufferBps decrease since there might be some swap fees taken from the collateral\\r\\n        uint256 nextLeverageWithBuffer = nextSize\\r\\n            .mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps)\\r\\n            .div(nextCollateral);\\r\\n\\r\\n        require(\\r\\n            nextLeverageWithBuffer >= prevLeverage,\\r\\n            \\\"PositionManager: long leverage decrease\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _setTraderReferralCode(bytes32 _referralCode) internal {\\r\\n        if (_referralCode != bytes32(0) && referralStorage != address(0)) {\\r\\n            IReferralStorage(referralStorage).setTraderReferralCode(\\r\\n                msg.sender,\\r\\n                _referralCode\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IRouter {\\r\\n    function addPlugin(address _plugin) external;\\r\\n\\r\\n    function pluginTransfer(\\r\\n        address _token,\\r\\n        address _account,\\r\\n        address _receiver,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n\\r\\n    function pluginIncreasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong\\r\\n    ) external;\\r\\n\\r\\n    function pluginDecreasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address _receiver\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function swap(\\r\\n        address[] memory _path,\\r\\n        uint256 _amountIn,\\r\\n        uint256 _minOut,\\r\\n        address _receiver\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IOrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IOrderBook {\\r\\n    function getSwapOrder(bytes32 orderKey)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address path0,\\r\\n            address path1,\\r\\n            address path2,\\r\\n            uint256 amountIn,\\r\\n            uint256 minOut,\\r\\n            uint256 triggerRatio,\\r\\n            bool triggerAboveThreshold,\\r\\n            bool shouldUnwrap,\\r\\n            uint256 executionFee\\r\\n        );\\r\\n\\r\\n    function getIncreaseOrder(bytes32 orderKey)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address account,\\r\\n            address purchaseToken,\\r\\n            uint256 purchaseTokenAmount,\\r\\n            address collateralToken,\\r\\n            address indexToken,\\r\\n            uint256 sizeDelta,\\r\\n            bool isLong,\\r\\n            uint256 triggerPrice,\\r\\n            bool triggerAboveThreshold,\\r\\n            uint256 executionFee\\r\\n        );\\r\\n\\r\\n    function getDecreaseOrder(bytes32 orderKey)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address account,\\r\\n            address collateralToken,\\r\\n            uint256 collateralDelta,\\r\\n            address indexToken,\\r\\n            uint256 sizeDelta,\\r\\n            bool isLong,\\r\\n            uint256 triggerPrice,\\r\\n            bool triggerAboveThreshold,\\r\\n            uint256 executionFee\\r\\n        );\\r\\n\\r\\n    function executeSwapOrder(bytes32 orderKey, address payable feeReceiver)\\r\\n        external;\\r\\n\\r\\n    function executeDecreaseOrder(bytes32 orderKey, address payable feeReceiver)\\r\\n        external;\\r\\n\\r\\n    function executeIncreaseOrder(bytes32 orderKey, address payable feeReceiver)\\r\\n        external;\\r\\n\\r\\n    function cancelSwapOrder(bytes32 orderKey) external;\\r\\n\\r\\n    function cancelIncreaseOrder(bytes32 _orderKey) external;\\r\\n\\r\\n    function cancelDecreaseOrder(bytes32 orderKey) external;\\r\\n\\r\\n    function totalSwapOrders() external view returns (uint256);\\r\\n\\r\\n    function swapOrderAt(uint256 index) external view returns (bytes32);\\r\\n\\r\\n    function totalIncreaseOrders() external view returns (uint256);\\r\\n\\r\\n    function increaseOrderAt(uint256 index) external view returns (bytes32);\\r\\n\\r\\n    function totalDecreaseOrders() external view returns (uint256);\\r\\n\\r\\n    function decreaseOrderAt(uint256 index) external view returns (bytes32);\\r\\n\\r\\n    function validateSwapOrderPriceWithTriggerAboveThreshold(\\r\\n        address[] memory _path,\\r\\n        uint256 _triggerRatio\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function validatePositionOrderPrice(\\r\\n        bool _triggerAboveThreshold,\\r\\n        uint256 _triggerPrice,\\r\\n        address _indexToken,\\r\\n        bool _maximizePrice,\\r\\n        bool _raise\\r\\n    ) external view returns (uint256, bool);\\r\\n\\r\\n    function totalUserOrders(address _user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 swap,\\r\\n            uint256 increase,\\r\\n            uint256 decrease\\r\\n        );\\r\\n\\r\\n    function userSwapOrderAt(address _user, uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32);\\r\\n\\r\\n    function userIncreaseOrderAt(address _user, uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32);\\r\\n\\r\\n    function userDecreaseOrderAt(address _user, uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./IVaultUtils.sol\\\";\\r\\n\\r\\ninterface IVault {\\r\\n    function isInitialized() external view returns (bool);\\r\\n\\r\\n    function isSwapEnabled() external view returns (bool);\\r\\n\\r\\n    function isLeverageEnabled() external view returns (bool);\\r\\n\\r\\n    function setVaultUtils(IVaultUtils _vaultUtils) external;\\r\\n\\r\\n    function setError(uint256 _errorCode, string calldata _error) external;\\r\\n\\r\\n    function router() external view returns (address);\\r\\n\\r\\n    function usdj() external view returns (address);\\r\\n\\r\\n    function gov() external view returns (address);\\r\\n\\r\\n    function whitelistedTokenCount() external view returns (uint256);\\r\\n\\r\\n    function maxLeverage() external view returns (uint256);\\r\\n\\r\\n    function minProfitTime() external view returns (uint256);\\r\\n\\r\\n    function hasDynamicFees() external view returns (bool);\\r\\n\\r\\n    function fundingInterval() external view returns (uint256);\\r\\n\\r\\n    function totalTokenWeights() external view returns (uint256);\\r\\n\\r\\n    function getTargetUsdjAmount(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function inManagerMode() external view returns (bool);\\r\\n\\r\\n    function inPrivateLiquidationMode() external view returns (bool);\\r\\n\\r\\n    function maxGasPrice() external view returns (uint256);\\r\\n\\r\\n    function approvedRouters(address _account, address _router)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function isLiquidator(address _account) external view returns (bool);\\r\\n\\r\\n    function isManager(address _account) external view returns (bool);\\r\\n\\r\\n    function minProfitBasisPoints(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function tokenBalances(address _token) external view returns (uint256);\\r\\n\\r\\n    function lastFundingTimes(address _token) external view returns (uint256);\\r\\n\\r\\n    function setMaxLeverage(uint256 _maxLeverage) external;\\r\\n\\r\\n    function setInManagerMode(bool _inManagerMode) external;\\r\\n\\r\\n    function setManager(address _manager, bool _isManager) external;\\r\\n\\r\\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\\r\\n\\r\\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\\r\\n\\r\\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\\r\\n\\r\\n    function setUsdjAmount(address _token, uint256 _amount) external;\\r\\n\\r\\n    function setBufferAmount(address _token, uint256 _amount) external;\\r\\n\\r\\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external;\\r\\n\\r\\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode)\\r\\n        external;\\r\\n\\r\\n    function setLiquidator(address _liquidator, bool _isActive) external;\\r\\n\\r\\n    function setFundingRate(\\r\\n        uint256 _fundingInterval,\\r\\n        uint256 _fundingRateFactor,\\r\\n        uint256 _stableFundingRateFactor\\r\\n    ) external;\\r\\n\\r\\n    function setFees(\\r\\n        uint256 _taxBasisPoints,\\r\\n        uint256 _stableTaxBasisPoints,\\r\\n        uint256 _mintBurnFeeBasisPoints,\\r\\n        uint256 _swapFeeBasisPoints,\\r\\n        uint256 _stableSwapFeeBasisPoints,\\r\\n        uint256 _marginFeeBasisPoints,\\r\\n        uint256 _liquidationFeeUsd,\\r\\n        uint256 _minProfitTime,\\r\\n        bool _hasDynamicFees\\r\\n    ) external;\\r\\n\\r\\n    function setTokenConfig(\\r\\n        address _token,\\r\\n        uint256 _tokenDecimals,\\r\\n        uint256 _redemptionBps,\\r\\n        uint256 _minProfitBps,\\r\\n        uint256 _maxUsdjAmount,\\r\\n        bool _isStable,\\r\\n        bool _isShortable\\r\\n    ) external;\\r\\n\\r\\n    function setPriceFeed(address _priceFeed) external;\\r\\n\\r\\n    function withdrawFees(address _token, address _receiver)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function directPoolDeposit(address _token) external;\\r\\n\\r\\n    function buyUSDJ(address _token, address _receiver)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function sellUSDJ(address _token, address _receiver)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function swap(\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        address _receiver\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function increasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong\\r\\n    ) external;\\r\\n\\r\\n    function decreasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address _receiver\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function validateLiquidation(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        bool _raise\\r\\n    ) external view returns (uint256, uint256);\\r\\n\\r\\n    function liquidatePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        address _feeReceiver\\r\\n    ) external;\\r\\n\\r\\n    function tokenToUsdMin(address _token, uint256 _tokenAmount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function priceFeed() external view returns (address);\\r\\n\\r\\n    function fundingRateFactor() external view returns (uint256);\\r\\n\\r\\n    function stableFundingRateFactor() external view returns (uint256);\\r\\n\\r\\n    function cumulativeFundingRates(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function getNextFundingRate(address _token) external view returns (uint256);\\r\\n\\r\\n    function getFeeBasisPoints(\\r\\n        address _token,\\r\\n        uint256 _usdjDelta,\\r\\n        uint256 _feeBasisPoints,\\r\\n        uint256 _taxBasisPoints,\\r\\n        bool _increment\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function liquidationFeeUsd() external view returns (uint256);\\r\\n\\r\\n    function taxBasisPoints() external view returns (uint256);\\r\\n\\r\\n    function stableTaxBasisPoints() external view returns (uint256);\\r\\n\\r\\n    function mintBurnFeeBasisPoints() external view returns (uint256);\\r\\n\\r\\n    function swapFeeBasisPoints() external view returns (uint256);\\r\\n\\r\\n    function stableSwapFeeBasisPoints() external view returns (uint256);\\r\\n\\r\\n    function marginFeeBasisPoints() external view returns (uint256);\\r\\n\\r\\n    function allWhitelistedTokensLength() external view returns (uint256);\\r\\n\\r\\n    function allWhitelistedTokens(uint256) external view returns (address);\\r\\n\\r\\n    function whitelistedTokens(address _token) external view returns (bool);\\r\\n\\r\\n    function stableTokens(address _token) external view returns (bool);\\r\\n\\r\\n    function shortableTokens(address _token) external view returns (bool);\\r\\n\\r\\n    function feeReserves(address _token) external view returns (uint256);\\r\\n\\r\\n    function globalShortSizes(address _token) external view returns (uint256);\\r\\n\\r\\n    function globalShortAveragePrices(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function maxGlobalShortSizes(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function tokenDecimals(address _token) external view returns (uint256);\\r\\n\\r\\n    function tokenWeights(address _token) external view returns (uint256);\\r\\n\\r\\n    function guaranteedUsd(address _token) external view returns (uint256);\\r\\n\\r\\n    function poolAmounts(address _token) external view returns (uint256);\\r\\n\\r\\n    function bufferAmounts(address _token) external view returns (uint256);\\r\\n\\r\\n    function reservedAmounts(address _token) external view returns (uint256);\\r\\n\\r\\n    function usdjAmounts(address _token) external view returns (uint256);\\r\\n\\r\\n    function maxUsdjAmounts(address _token) external view returns (uint256);\\r\\n\\r\\n    function getRedemptionAmount(address _token, uint256 _usdjAmount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function getMaxPrice(address _token) external view returns (uint256);\\r\\n\\r\\n    function getMinPrice(address _token) external view returns (uint256);\\r\\n\\r\\n    function getDelta(\\r\\n        address _indexToken,\\r\\n        uint256 _size,\\r\\n        uint256 _averagePrice,\\r\\n        bool _isLong,\\r\\n        uint256 _lastIncreasedTime\\r\\n    ) external view returns (bool, uint256);\\r\\n\\r\\n    function getPosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            bool,\\r\\n            uint256\\r\\n        );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/peripherals/interfaces/ITimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface ITimelock {\\r\\n    function signalSetAdmin(address _admin) external;\\r\\n\\r\\n    function setAdmin(address _admin) external;\\r\\n\\r\\n    function enableLeverage(address _vault) external;\\r\\n\\r\\n    function disableLeverage(address _vault) external;\\r\\n\\r\\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled)\\r\\n        external;\\r\\n\\r\\n    function signalSetGov(address _target, address _gov) external;\\r\\n\\r\\n    function setBufferAmount(\\r\\n        address _vault,\\r\\n        address _token,\\r\\n        uint256 _bufferAmount\\r\\n    ) external;\\r\\n\\r\\n    function withdrawFees(\\r\\n        address _vault,\\r\\n        address _token,\\r\\n        address _receiver\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BasePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../libraries/math/SafeMath.sol\\\";\\r\\nimport \\\"../libraries/token/IERC20.sol\\\";\\r\\nimport \\\"../tokens/interfaces/IWETH.sol\\\";\\r\\nimport \\\"../libraries/token/SafeERC20.sol\\\";\\r\\nimport \\\"../libraries/utils/Address.sol\\\";\\r\\nimport \\\"../libraries/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IRouter.sol\\\";\\r\\nimport \\\"./interfaces/IVault.sol\\\";\\r\\nimport \\\"./interfaces/IShortsTracker.sol\\\";\\r\\nimport \\\"./interfaces/IOrderBook.sol\\\";\\r\\nimport \\\"./interfaces/IBasePositionManager.sol\\\";\\r\\n\\r\\nimport \\\"../access/Governable.sol\\\";\\r\\nimport \\\"../peripherals/interfaces/ITimelock.sol\\\";\\r\\n\\r\\nimport \\\"../referrals/interfaces/IReferralStorage.sol\\\";\\r\\n\\r\\ncontract BasePositionManager is\\r\\n    IBasePositionManager,\\r\\n    ReentrancyGuard,\\r\\n    Governable\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using Address for address payable;\\r\\n\\r\\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\\r\\n\\r\\n    address public admin;\\r\\n\\r\\n    address public vault;\\r\\n    address public shortsTracker;\\r\\n    address public router;\\r\\n    address public weth;\\r\\n\\r\\n    // to prevent using the deposit and withdrawal of collateral as a zero fee swap,\\r\\n    // there is a small depositFee charged if a collateral deposit results in the decrease\\r\\n    // of leverage for an existing position\\r\\n    // increasePositionBufferBps allows for a small amount of decrease of leverage\\r\\n    uint256 public depositFee;\\r\\n    uint256 public increasePositionBufferBps = 100;\\r\\n\\r\\n    address public referralStorage;\\r\\n\\r\\n    mapping(address => uint256) public feeReserves;\\r\\n\\r\\n    mapping(address => uint256) public override maxGlobalLongSizes;\\r\\n    mapping(address => uint256) public override maxGlobalShortSizes;\\r\\n\\r\\n    event SetDepositFee(uint256 depositFee);\\r\\n    event SetIncreasePositionBufferBps(uint256 increasePositionBufferBps);\\r\\n    event SetReferralStorage(address referralStorage);\\r\\n    event SetAdmin(address admin);\\r\\n    event WithdrawFees(address token, address receiver, uint256 amount);\\r\\n\\r\\n    event SetMaxGlobalSizes(\\r\\n        address[] tokens,\\r\\n        uint256[] longSizes,\\r\\n        uint256[] shortSizes\\r\\n    );\\r\\n\\r\\n    event IncreasePositionReferral(\\r\\n        address account,\\r\\n        uint256 sizeDelta,\\r\\n        uint256 marginFeeBasisPoints,\\r\\n        bytes32 referralCode,\\r\\n        address referrer\\r\\n    );\\r\\n\\r\\n    event DecreasePositionReferral(\\r\\n        address account,\\r\\n        uint256 sizeDelta,\\r\\n        uint256 marginFeeBasisPoints,\\r\\n        bytes32 referralCode,\\r\\n        address referrer\\r\\n    );\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"BPM: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _vault,\\r\\n        address _router,\\r\\n        address _shortsTracker,\\r\\n        address _weth,\\r\\n        uint256 _depositFee\\r\\n    ) public {\\r\\n        vault = _vault;\\r\\n        router = _router;\\r\\n        weth = _weth;\\r\\n        depositFee = _depositFee;\\r\\n        shortsTracker = _shortsTracker;\\r\\n\\r\\n        admin = msg.sender;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        require(msg.sender == weth, \\\"BPM: invalid sender\\\");\\r\\n    }\\r\\n\\r\\n    function setAdmin(address _admin) external onlyGov {\\r\\n        require(_admin != address(0));\\r\\n        admin = _admin;\\r\\n        emit SetAdmin(_admin);\\r\\n    }\\r\\n\\r\\n    function setDepositFee(uint256 _depositFee) external onlyAdmin {\\r\\n        depositFee = _depositFee;\\r\\n        emit SetDepositFee(_depositFee);\\r\\n    }\\r\\n\\r\\n    function setIncreasePositionBufferBps(uint256 _increasePositionBufferBps)\\r\\n        external\\r\\n        onlyAdmin\\r\\n    {\\r\\n        increasePositionBufferBps = _increasePositionBufferBps;\\r\\n        emit SetIncreasePositionBufferBps(_increasePositionBufferBps);\\r\\n    }\\r\\n\\r\\n    function setReferralStorage(address _referralStorage) external onlyAdmin {\\r\\n        referralStorage = _referralStorage;\\r\\n        emit SetReferralStorage(_referralStorage);\\r\\n    }\\r\\n\\r\\n    function setMaxGlobalSizes(\\r\\n        address[] memory _tokens,\\r\\n        uint256[] memory _longSizes,\\r\\n        uint256[] memory _shortSizes\\r\\n    ) external onlyAdmin {\\r\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\r\\n            address token = _tokens[i];\\r\\n            maxGlobalLongSizes[token] = _longSizes[i];\\r\\n            maxGlobalShortSizes[token] = _shortSizes[i];\\r\\n        }\\r\\n\\r\\n        emit SetMaxGlobalSizes(_tokens, _longSizes, _shortSizes);\\r\\n    }\\r\\n\\r\\n    function withdrawFees(address _token, address _receiver)\\r\\n        external\\r\\n        onlyAdmin\\r\\n    {\\r\\n        uint256 amount = feeReserves[_token];\\r\\n        if (amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        feeReserves[_token] = 0;\\r\\n        IERC20(_token).safeTransfer(_receiver, amount);\\r\\n\\r\\n        emit WithdrawFees(_token, _receiver, amount);\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address _token,\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    ) external onlyGov {\\r\\n        IERC20(_token).approve(_spender, _amount);\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable _receiver, uint256 _amount)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        _receiver.sendValue(_amount);\\r\\n    }\\r\\n\\r\\n    function _validateMaxGlobalSize(\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        uint256 _sizeDelta\\r\\n    ) internal view {\\r\\n        if (_sizeDelta == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (_isLong) {\\r\\n            uint256 maxGlobalLongSize = maxGlobalLongSizes[_indexToken];\\r\\n            if (\\r\\n                maxGlobalLongSize > 0 &&\\r\\n                IVault(vault).guaranteedUsd(_indexToken).add(_sizeDelta) >\\r\\n                maxGlobalLongSize\\r\\n            ) {\\r\\n                revert(\\\"BPM: max global longs exceeded\\\");\\r\\n            }\\r\\n        } else {\\r\\n            uint256 maxGlobalShortSize = maxGlobalShortSizes[_indexToken];\\r\\n            if (\\r\\n                maxGlobalShortSize > 0 &&\\r\\n                IVault(vault).globalShortSizes(_indexToken).add(_sizeDelta) >\\r\\n                maxGlobalShortSize\\r\\n            ) {\\r\\n                revert(\\\"BPM: max global shorts exceeded\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _increasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        uint256 _price\\r\\n    ) internal {\\r\\n        address _vault = vault;\\r\\n\\r\\n        uint256 markPrice = _isLong\\r\\n            ? IVault(_vault).getMaxPrice(_indexToken)\\r\\n            : IVault(_vault).getMinPrice(_indexToken);\\r\\n        if (_isLong) {\\r\\n            require(markPrice <= _price, \\\"BPM: mark > limit\\\");\\r\\n        } else {\\r\\n            require(markPrice >= _price, \\\"BPM: mark < limit\\\");\\r\\n        }\\r\\n\\r\\n        _validateMaxGlobalSize(_indexToken, _isLong, _sizeDelta);\\r\\n\\r\\n        address timelock = IVault(_vault).gov();\\r\\n\\r\\n        // should be called strictly before position is updated in Vault\\r\\n        IShortsTracker(shortsTracker).updateGlobalShortData(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong,\\r\\n            _sizeDelta,\\r\\n            markPrice,\\r\\n            true\\r\\n        );\\r\\n\\r\\n        ITimelock(timelock).enableLeverage(_vault);\\r\\n        IRouter(router).pluginIncreasePosition(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _sizeDelta,\\r\\n            _isLong\\r\\n        );\\r\\n        ITimelock(timelock).disableLeverage(_vault);\\r\\n\\r\\n        _emitIncreasePositionReferral(_account, _sizeDelta);\\r\\n    }\\r\\n\\r\\n    function _decreasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address _receiver,\\r\\n        uint256 _price\\r\\n    ) internal returns (uint256) {\\r\\n        address _vault = vault;\\r\\n\\r\\n        uint256 markPrice = _isLong\\r\\n            ? IVault(_vault).getMinPrice(_indexToken)\\r\\n            : IVault(_vault).getMaxPrice(_indexToken);\\r\\n        if (_isLong) {\\r\\n            require(markPrice >= _price, \\\"BPM: mark < limit\\\");\\r\\n        } else {\\r\\n            require(markPrice <= _price, \\\"BPM: mark > limit\\\");\\r\\n        }\\r\\n\\r\\n        address timelock = IVault(_vault).gov();\\r\\n\\r\\n        // should be called strictly before position is updated in Vault\\r\\n        IShortsTracker(shortsTracker).updateGlobalShortData(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong,\\r\\n            _sizeDelta,\\r\\n            markPrice,\\r\\n            false\\r\\n        );\\r\\n\\r\\n        ITimelock(timelock).enableLeverage(_vault);\\r\\n        uint256 amountOut = IRouter(router).pluginDecreasePosition(\\r\\n            _account,\\r\\n            _collateralToken,\\r\\n            _indexToken,\\r\\n            _collateralDelta,\\r\\n            _sizeDelta,\\r\\n            _isLong,\\r\\n            _receiver\\r\\n        );\\r\\n        ITimelock(timelock).disableLeverage(_vault);\\r\\n\\r\\n        _emitDecreasePositionReferral(_account, _sizeDelta);\\r\\n\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function _addReward(address _account, uint256 _sizeDelta) internal {\\r\\n        IReferralStorage(referralStorage).addReward(_account, _sizeDelta);\\r\\n    }\\r\\n\\r\\n    function _emitIncreasePositionReferral(address _account, uint256 _sizeDelta)\\r\\n        internal\\r\\n    {\\r\\n        address _referralStorage = referralStorage;\\r\\n        if (_referralStorage == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        (bytes32 referralCode, address referrer) = IReferralStorage(\\r\\n            _referralStorage\\r\\n        ).getTraderReferralInfo(_account);\\r\\n\\r\\n        _addReward(_account, _sizeDelta);\\r\\n\\r\\n        emit IncreasePositionReferral(\\r\\n            _account,\\r\\n            _sizeDelta,\\r\\n            IVault(vault).marginFeeBasisPoints(),\\r\\n            referralCode,\\r\\n            referrer\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _emitDecreasePositionReferral(address _account, uint256 _sizeDelta)\\r\\n        internal\\r\\n    {\\r\\n        address _referralStorage = referralStorage;\\r\\n        if (_referralStorage == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        (bytes32 referralCode, address referrer) = IReferralStorage(\\r\\n            _referralStorage\\r\\n        ).getTraderReferralInfo(_account);\\r\\n\\r\\n        _addReward(_account, _sizeDelta);\\r\\n\\r\\n        emit DecreasePositionReferral(\\r\\n            _account,\\r\\n            _sizeDelta,\\r\\n            IVault(vault).marginFeeBasisPoints(),\\r\\n            referralCode,\\r\\n            referrer\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _swap(\\r\\n        address[] memory _path,\\r\\n        uint256 _minOut,\\r\\n        address _receiver\\r\\n    ) internal returns (uint256) {\\r\\n        if (_path.length == 2) {\\r\\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\\r\\n        }\\r\\n        revert(\\\"BPM: invalid _path.length\\\");\\r\\n    }\\r\\n\\r\\n    function _vaultSwap(\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _minOut,\\r\\n        address _receiver\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\\r\\n        require(amountOut >= _minOut, \\\"BPM: insufficient amountOut\\\");\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function _transferInETH() internal {\\r\\n        if (msg.value != 0) {\\r\\n            IWETH(weth).deposit{value: msg.value}();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transferOutETHWithGasLimitIgnoreFail(\\r\\n        uint256 _amountOut,\\r\\n        address payable _receiver\\r\\n    ) internal {\\r\\n        IWETH(weth).withdraw(_amountOut);\\r\\n\\r\\n        // use `send` instead of `transfer` to not revert whole transaction in case ETH transfer was failed\\r\\n        // it has limit of 2300 gas\\r\\n        // this is to avoid front-running\\r\\n        _receiver.send(_amountOut);\\r\\n    }\\r\\n\\r\\n    function _collectFees(\\r\\n        address _account,\\r\\n        address[] memory _path,\\r\\n        uint256 _amountIn,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        uint256 _sizeDelta\\r\\n    ) internal returns (uint256) {\\r\\n        bool shouldDeductFee = _shouldDeductFee(\\r\\n            _account,\\r\\n            _path,\\r\\n            _amountIn,\\r\\n            _indexToken,\\r\\n            _isLong,\\r\\n            _sizeDelta\\r\\n        );\\r\\n\\r\\n        if (shouldDeductFee) {\\r\\n            uint256 afterFeeAmount = _amountIn\\r\\n                .mul(BASIS_POINTS_DIVISOR.sub(depositFee))\\r\\n                .div(BASIS_POINTS_DIVISOR);\\r\\n            uint256 feeAmount = _amountIn.sub(afterFeeAmount);\\r\\n            address feeToken = _path[_path.length - 1];\\r\\n            feeReserves[feeToken] = feeReserves[feeToken].add(feeAmount);\\r\\n            return afterFeeAmount;\\r\\n        }\\r\\n\\r\\n        return _amountIn;\\r\\n    }\\r\\n\\r\\n    function _shouldDeductFee(\\r\\n        address _account,\\r\\n        address[] memory _path,\\r\\n        uint256 _amountIn,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        uint256 _sizeDelta\\r\\n    ) internal view returns (bool) {\\r\\n        // if the position is a short, do not charge a fee\\r\\n        if (!_isLong) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // if the position size is not increasing, this is a collateral deposit\\r\\n        if (_sizeDelta == 0) {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        address collateralToken = _path[_path.length - 1];\\r\\n\\r\\n        IVault _vault = IVault(vault);\\r\\n        (uint256 size, uint256 collateral, , , , , , ) = _vault.getPosition(\\r\\n            _account,\\r\\n            collateralToken,\\r\\n            _indexToken,\\r\\n            _isLong\\r\\n        );\\r\\n\\r\\n        // if there is no existing position, do not charge a fee\\r\\n        if (size == 0) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        uint256 nextSize = size.add(_sizeDelta);\\r\\n        uint256 collateralDelta = _vault.tokenToUsdMin(\\r\\n            collateralToken,\\r\\n            _amountIn\\r\\n        );\\r\\n        uint256 nextCollateral = collateral.add(collateralDelta);\\r\\n\\r\\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\\r\\n        // allow for a maximum of a increasePositionBufferBps decrease since there might be some swap fees taken from the collateral\\r\\n        uint256 nextLeverage = nextSize\\r\\n            .mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps)\\r\\n            .div(nextCollateral);\\r\\n\\r\\n        // deduct a fee if the leverage is decreased\\r\\n        return nextLeverage < prevLeverage;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IVaultUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IVaultUtils {\\r\\n    function updateCumulativeFundingRate(\\r\\n        address _collateralToken,\\r\\n        address _indexToken\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function validateIncreasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong\\r\\n    ) external view;\\r\\n\\r\\n    function validateDecreasePosition(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _collateralDelta,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isLong,\\r\\n        address _receiver\\r\\n    ) external view;\\r\\n\\r\\n    function validateLiquidation(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        bool _raise\\r\\n    ) external view returns (uint256, uint256);\\r\\n\\r\\n    function getEntryFundingRate(\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function getPositionFee(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        uint256 _sizeDelta\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function getFundingFee(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        uint256 _size,\\r\\n        uint256 _entryFundingRate\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function getBuyUsdjFeeBasisPoints(address _token, uint256 _usdjAmount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function getSellUsdjFeeBasisPoints(address _token, uint256 _usdjAmount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function getSwapFeeBasisPoints(\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _usdjAmount\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function getFeeBasisPoints(\\r\\n        address _token,\\r\\n        uint256 _usdjDelta,\\r\\n        uint256 _feeBasisPoints,\\r\\n        uint256 _taxBasisPoints,\\r\\n        bool _increment\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/access/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ncontract Governable {\\r\\n    address public gov;\\r\\n\\r\\n    constructor() public {\\r\\n        gov = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyGov() {\\r\\n        require(msg.sender == gov, \\\"Governable: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setGov(address _gov) external onlyGov {\\r\\n        require(_gov != address(0));\\r\\n        gov = _gov;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/IWETH.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\ncontract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor () internal {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/token/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"../math/SafeMath.sol\\\";\\r\\nimport \\\"../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IBasePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\ninterface IBasePositionManager {\\r\\n    function maxGlobalLongSizes(address _token) external view returns (uint256);\\r\\n\\r\\n    function maxGlobalShortSizes(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.2;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IShortsTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IShortsTracker {\\r\\n    function isGlobalShortDataReady() external view returns (bool);\\r\\n\\r\\n    function globalShortAveragePrices(\\r\\n        address _token\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function getNextGlobalShortData(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        uint256 _nextPrice,\\r\\n        uint256 _sizeDelta,\\r\\n        bool _isIncrease\\r\\n    ) external view returns (uint256, uint256);\\r\\n\\r\\n    function updateGlobalShortData(\\r\\n        address _account,\\r\\n        address _collateralToken,\\r\\n        address _indexToken,\\r\\n        bool _isLong,\\r\\n        uint256 _sizeDelta,\\r\\n        uint256 _markPrice,\\r\\n        bool _isIncrease\\r\\n    ) external;\\r\\n\\r\\n    function setIsGlobalShortDataReady(bool value) external;\\r\\n\\r\\n    function setInitData(\\r\\n        address[] calldata _tokens,\\r\\n        uint256[] calldata _averagePrices\\r\\n    ) external;\\r\\n\\r\\n    function setHandler(address _handler, bool _isActive) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/referrals/interfaces/IReferralStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IReferralStorage {\\r\\n    function codeOwners(bytes32 _code) external view returns (address);\\r\\n\\r\\n    function getTraderReferralInfo(address _account)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32, address);\\r\\n\\r\\n    function setTraderReferralCode(address _account, bytes32 _code) external;\\r\\n\\r\\n    function setTier(\\r\\n        uint256 _tierId,\\r\\n        uint256 _totalRebate,\\r\\n        uint256 _discountShare\\r\\n    ) external;\\r\\n\\r\\n    function setReferrerTier(address _referrer, uint256 _tierId) external;\\r\\n\\r\\n    function govSetCodeOwner(bytes32 _code, address _newAccount) external;\\r\\n\\r\\n    function setMinReward(uint256 _min) external;\\r\\n\\r\\n    function setMarginFee(uint256 _fee) external;\\r\\n\\r\\n    function setTokenReward(address _token) external;\\r\\n\\r\\n    function withdrawnToken(address _token, address _to, uint256 _amount) external;\\r\\n\\r\\n    function removeRebate(address _user) external;\\r\\n\\r\\n    function addReward(address _account, uint256 _sizeDelta) external;\\r\\n\\r\\n    function getTokenReward() external view returns (address);\\r\\n\\r\\n    function depositPending() external view returns (uint256);\\r\\n\\r\\n    function deposit(uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shortsTracker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_orderBook\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sizeDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marginFeeBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"referralCode\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"DecreasePositionReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sizeDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marginFeeBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"referralCode\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"IncreasePositionReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"}],\"name\":\"SetDepositFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"inLegacyMode\",\"type\":\"bool\"}],\"name\":\"SetInLegacyMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasePositionBufferBps\",\"type\":\"uint256\"}],\"name\":\"SetIncreasePositionBufferBps\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"SetLiquidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"longSizes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"shortSizes\",\"type\":\"uint256[]\"}],\"name\":\"SetMaxGlobalSizes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"SetOrderKeeper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"SetPartner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referralStorage\",\"type\":\"address\"}],\"name\":\"SetReferralStorage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"shouldValidateIncreaseOrder\",\"type\":\"bool\"}],\"name\":\"SetShouldValidateIncreaseOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFees\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASIS_POINTS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"decreasePosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"}],\"name\":\"decreasePositionAndSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"}],\"name\":\"decreasePositionAndSwapETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"decreasePositionETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderKey\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"executeDecreaseOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderKey\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"executeIncreaseOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderKey\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"executeSwapOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inLegacyMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_referralCode\",\"type\":\"bytes32\"}],\"name\":\"increasePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increasePositionBufferBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sizeDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_referralCode\",\"type\":\"bytes32\"}],\"name\":\"increasePositionETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOrderKeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPartner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_indexToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"liquidatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxGlobalLongSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxGlobalShortSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderBook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositFee\",\"type\":\"uint256\"}],\"name\":\"setDepositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inLegacyMode\",\"type\":\"bool\"}],\"name\":\"setInLegacyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_increasePositionBufferBps\",\"type\":\"uint256\"}],\"name\":\"setIncreasePositionBufferBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_longSizes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shortSizes\",\"type\":\"uint256[]\"}],\"name\":\"setMaxGlobalSizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setOrderKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralStorage\",\"type\":\"address\"}],\"name\":\"setReferralStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_shouldValidateIncreaseOrder\",\"type\":\"bool\"}],\"name\":\"setShouldValidateIncreaseOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shortsTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldValidateIncreaseOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PositionManager", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "00000000000000000000000024ed2bf2c1e76c621164d93b73debd10cdc4bbd00000000000000000000000007811183455363c0fb26e70c1d3fc87719838666c00000000000000000000000034877999be648e327533a932cb7faafb6c682507000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000222b6df80ba65a6485a14b74065b00df807ccf7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}