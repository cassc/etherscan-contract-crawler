{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: Tmp.Projects/FunnyCoin/FunnyCoinPledgeContract.sol\r\n\r\n\r\npragma solidity >= 0.8.0 < 0.9.0;\r\n\r\n\r\n\r\ninterface ERC20Token  {\r\n    function transferFrom(address _from, address _to, uint _value) external;\r\n    function balanceOf(address tokenHolder) external  view returns (uint256);\r\n    function transfer(address to, uint256 amount) external;\r\n}\r\n\r\n\r\ncontract FunnyCoinPledgeContract is Pausable, ReentrancyGuard \r\n{\r\n     // pay token instance\r\n    ERC20Token private _PayToken;\r\n    // to Address\r\n    address public Official;\r\n    // max sale amount\r\n    uint256 public MaxSaleAmount;\r\n    // current in amount\r\n    uint256 public CurrentSaleAmount;\r\n    // admin address\r\n    address public Admin;\r\n    // total in amount\r\n    uint256 public TotalAmount;\r\n\r\n    struct UserRecord\r\n    {\r\n        address User;\r\n        uint256 Amount;\r\n        uint256 WithdrawnAmount;\r\n        uint64 Index;\r\n        uint64 InTime;\r\n        uint64 LastWithdrawn;\r\n        uint64 UserId;\r\n        bool Redeem;\r\n        uint8 Type;\r\n    }\r\n\r\n    struct RecordType\r\n    {\r\n        uint256 LockDay;\r\n        uint256 Rate;\r\n        uint256 Ratio;\r\n        bool Enabled;\r\n    }\r\n\r\n    mapping(address => uint64[]) private UserIndexs;\r\n    UserRecord[] private _Records;\r\n    mapping(uint8 => RecordType) public RecordTypes;\r\n\r\n    modifier notContract() \r\n    {\r\n        require(msg.sender == tx.origin, \"Contract not allowed\");\r\n\r\n        uint256 size;\r\n        address sender = msg.sender;\r\n        assembly \r\n        {\r\n            size := extcodesize(sender)\r\n        }\r\n        require(size == 0, \"Contract not allowed size\");\r\n\r\n        _;\r\n    }\r\n    modifier onlyAdmin()\r\n    {\r\n        require(msg.sender == Admin, \"only admin user opertions\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _token, address _official, uint256 _maxSales, address adminAddress)\r\n    {\r\n        Admin = adminAddress;\r\n        _PayToken = ERC20Token(_token);\r\n        SetOfficial(_official);\r\n        MaxSaleAmount = _maxSales;\r\n       \r\n\r\n        RecordTypes[0] = RecordType({ LockDay: 365,  Rate: 40, Ratio: 100 , Enabled : false});\r\n        RecordTypes[1] = RecordType({ LockDay: 365,  Rate:  6, Ratio: 100 , Enabled : false});\r\n        RecordTypes[2] = RecordType({ LockDay: 365,  Rate:  0, Ratio: 100, Enabled : false });\r\n    }\r\n\r\n    function BuyAmount(uint256 amount, uint64 userId, uint8 _type) public whenNotPaused notContract nonReentrant returns(uint64)\r\n    {\r\n        RecordType memory mRecordType = RecordTypes[_type];\r\n        require(mRecordType.Enabled == true, \"type not running!\");\r\n        require(amount > 0, \"amount is zero!\");\r\n        require((MaxSaleAmount - CurrentSaleAmount) >= amount, \"Not enough amount\");\r\n        require(_PayToken.balanceOf(msg.sender) >= amount , \"Not enough sent\");\r\n        _PayToken.transferFrom(msg.sender, Official , amount);\r\n\r\n        CurrentSaleAmount = CurrentSaleAmount + amount;\r\n        uint64 mIndex = InsertRecored(msg.sender, amount, userId, _type, uint64(block.timestamp), 0);\r\n         \r\n        return mIndex;\r\n    }\r\n\r\n    function InsertRecored(address user, uint256 amount, uint64 userId, uint8 _type, uint64 inTime, uint256 withdrawnAmount) internal returns(uint64)\r\n    {\r\n        uint64 mIndex = uint64(_Records.length);\r\n        UserRecord memory  mUserRecord = UserRecord(\r\n            {\r\n                User: user,\r\n                Amount: amount, \r\n                WithdrawnAmount : withdrawnAmount,\r\n                Index: mIndex,\r\n                InTime: inTime,\r\n                LastWithdrawn: 0, \r\n                UserId: userId,\r\n                Redeem: false,\r\n                Type: _type\r\n            });\r\n        // add record\r\n        _Records.push(mUserRecord);\r\n        UserIndexs[user].push(mIndex);\r\n       \r\n        TotalAmount = TotalAmount + amount;\r\n\r\n        return mIndex;\r\n    }\r\n\r\n    function GetRecordLength() public view returns(uint256)\r\n    {\r\n        return _Records.length;\r\n    }\r\n\r\n    function GetRecordInfo(uint256 index) public view returns(UserRecord memory)\r\n    {\r\n        return _Records[index];\r\n    }\r\n    // Mint Reward Amount\r\n    function Mint(uint64 index) public whenNotPaused notContract nonReentrant\r\n    {\r\n        UserRecord memory mUserRecord = _Records[index];\r\n        require(mUserRecord.Redeem == false, \"amount is redeem!\");\r\n        require(mUserRecord.Amount > 0, \"amount is zero!\");\r\n        require(mUserRecord.User == msg.sender, \"it is not this user!\");\r\n        uint256 mRewardAmount = CalcUserRewardAmount(mUserRecord);\r\n        require(mRewardAmount > 0, \"reward amount is zero!\");\r\n        require(_PayToken.balanceOf(address(this)) >= mRewardAmount , \"Not enough sent\");\r\n\r\n        _Records[mUserRecord.Index].WithdrawnAmount = _Records[mUserRecord.Index].WithdrawnAmount + mRewardAmount;\r\n        _Records[mUserRecord.Index].LastWithdrawn = uint64(block.timestamp);\r\n\r\n        _PayToken.transfer(mUserRecord.User, mRewardAmount);\r\n    }\r\n    // Redeem amount\r\n    function Redeem(uint64 index) public whenNotPaused notContract nonReentrant\r\n    {\r\n        UserRecord memory mUserRecord = _Records[index];\r\n        require(mUserRecord.Redeem == false, \"amount is redeem!\");\r\n        require(mUserRecord.User == msg.sender, \"it is not this user!\");\r\n\r\n        uint256 mDay =   (block.timestamp - mUserRecord.InTime) / 1 days;\r\n        RecordType memory mRecordType = RecordTypes[mUserRecord.Type];\r\n        require(mRecordType.LockDay > 0 || mRecordType.Ratio > 0, \"_type not find!\");\r\n\r\n        require(mDay >= mRecordType.LockDay, \"it's in locked day!\");\r\n        require(mUserRecord.Amount > 0, \"amount is zero!\");\r\n\r\n        uint256 mRewardAmount = CalcUserRewardAmount(mUserRecord);\r\n        uint256 mRedeemAmount = mRewardAmount + mUserRecord.Amount;\r\n\r\n        require(_PayToken.balanceOf(address(this)) >= mRedeemAmount , \"Not enough sent\");\r\n\r\n        if(mRewardAmount > 0)\r\n        {\r\n            _Records[mUserRecord.Index].WithdrawnAmount = _Records[mUserRecord.Index].WithdrawnAmount + mRewardAmount;\r\n            _Records[mUserRecord.Index].LastWithdrawn = uint64(block.timestamp);\r\n        }\r\n        _Records[mUserRecord.Index].Redeem = true;\r\n        _PayToken.transfer(mUserRecord.User, mRedeemAmount);\r\n    }\r\n    // Calc Reward Amount By Index\r\n    function CalcAddressRewardWithIndex(address userAddress, uint64 index) public view returns(uint256)\r\n    {\r\n        UserRecord memory mUserRecord = _Records[index];\r\n\r\n        if(mUserRecord.Redeem == true)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        if(mUserRecord.User != userAddress)\r\n        {\r\n            return 0;\r\n        }\r\n        uint256 mDay = (block.timestamp - mUserRecord.InTime) / 1 days;\r\n\r\n        if(mDay == 0)\r\n        {\r\n            return 0;\r\n        }\r\n        return CalcUserRewardAmount(mUserRecord);\r\n    }\r\n    // Calc Reward Amount\r\n    function CalcAddressReward(address userAddress) public view returns(UserRecord[] memory, uint256[] memory)\r\n    {\r\n        UserRecord[] memory mUserRecords = GetUserRecords(userAddress);\r\n        uint256 mUserRecordLen = mUserRecords.length;\r\n        uint256[] memory mAddressRewards = new uint256[](mUserRecordLen);\r\n\r\n        if(mUserRecordLen > 0)\r\n        {\r\n            for(uint256 i = 0 ; i < mUserRecordLen; i++)\r\n            {\r\n                mAddressRewards[i] = CalcAddressRewardWithIndex(userAddress, mUserRecords[i].Index);\r\n            }\r\n        }\r\n\r\n        return (mUserRecords, mAddressRewards);\r\n    }\r\n    // Calc Reward Amount\r\n    function CalcUserRewardAmount(UserRecord memory record) private view returns(uint256)\r\n    {\r\n        require(record.Redeem == false, \"amount is redeem!\");\r\n         // calc day\r\n        uint256 mDay =   (block.timestamp - record.InTime) / 1 days;\r\n        require(mDay > 0, \"day is zero!\");\r\n        RecordType memory mRecordType = RecordTypes[record.Type];\r\n        require(mRecordType.LockDay > 0 || mRecordType.Ratio > 0, \"_type not find!\");\r\n\r\n        if(mRecordType.Rate  == 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 mRewardAmount = record.Amount *  mDay * mRecordType.Rate / mRecordType.Ratio / 365;\r\n        mRewardAmount = mRewardAmount - record.WithdrawnAmount;\r\n        return mRewardAmount;\r\n    }\r\n\r\n    function GetUserRecords(address userAddress) public view returns(UserRecord[] memory)\r\n    {\r\n        uint64[] memory mUserIndexs = UserIndexs[userAddress];\r\n\r\n        UserRecord[] memory mUserRecords;\r\n\r\n        uint256 mUserRecordLen = mUserIndexs.length;\r\n\r\n        if(mUserRecordLen > 0)\r\n        {\r\n            mUserRecords = new UserRecord[](mUserRecordLen);\r\n\r\n            for(uint256 i = 0 ; i < mUserRecordLen; i++)\r\n            {\r\n               uint64 mIndex = mUserIndexs[i];\r\n               mUserRecords[i] = _Records[mIndex];\r\n            }\r\n        }\r\n\r\n        return mUserRecords;\r\n    }\r\n\r\n    // ==================ADMIN FUNCTIONS==================\r\n    \r\n    function pause() public onlyAdmin \r\n    {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyAdmin \r\n    {\r\n        _unpause();\r\n    }\r\n\r\n    function SetOfficial(address _official) public onlyAdmin \r\n    {\r\n        Official = _official;\r\n    }\r\n\r\n    function SetAdmin(address adminAddress) public onlyAdmin\r\n    {\r\n        Admin = adminAddress;\r\n    }\r\n\r\n    function SetMaxSaleAmount(uint256 _maxSales) public onlyAdmin\r\n    {\r\n        MaxSaleAmount = _maxSales;\r\n        CurrentSaleAmount = 0;\r\n    }\r\n\r\n    function AddUserRecord(address user, uint256 amount, uint64 userId, uint8 _type, uint64 inTime, uint256 withdrawnAmount) public onlyAdmin returns(uint64)\r\n    {\r\n        uint64 mIndex = InsertRecored(user, amount, userId, _type, inTime,withdrawnAmount);\r\n        return mIndex;\r\n    }\r\n\r\n    function AddRecordRate(uint8 _type, uint256 lockDay, uint256 rate, uint256 ratio, bool enabled)  public onlyAdmin \r\n    {\r\n        RecordType memory mRecordType = RecordTypes[_type];\r\n        require(mRecordType.LockDay == 0 && mRecordType.Ratio == 0 && mRecordType.Enabled == false &&  mRecordType.Rate == 0 , \"type is exist!\");\r\n        RecordTypes[_type] = RecordType({ LockDay: lockDay,  Rate: rate, Ratio: ratio, Enabled:enabled  });\r\n    }\r\n\r\n    function ChangeRecordEnabledStatus(uint8 _type, bool enabled)  public onlyAdmin \r\n    {\r\n        RecordType memory mRecordType = RecordTypes[_type];\r\n        require(mRecordType.LockDay > 0 || mRecordType.Ratio > 0, \"_type not find!\");\r\n        RecordTypes[_type].Enabled = enabled;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_official\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSales\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lockDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"AddRecordRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"inTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"name\":\"AddUserRecord\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"BuyAmount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"CalcAddressReward\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"Index\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"InTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"LastWithdrawn\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"UserId\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"Redeem\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"Type\",\"type\":\"uint8\"}],\"internalType\":\"struct FunnyCoinPledgeContract.UserRecord[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"}],\"name\":\"CalcAddressRewardWithIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ChangeRecordEnabledStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentSaleAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GetRecordInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"Index\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"InTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"LastWithdrawn\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"UserId\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"Redeem\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"Type\",\"type\":\"uint8\"}],\"internalType\":\"struct FunnyCoinPledgeContract.UserRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetRecordLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"GetUserRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"Index\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"InTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"LastWithdrawn\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"UserId\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"Redeem\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"Type\",\"type\":\"uint8\"}],\"internalType\":\"struct FunnyCoinPledgeContract.UserRecord[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxSaleAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"}],\"name\":\"Mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Official\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"RecordTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LockDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Ratio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"Enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"}],\"name\":\"Redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSales\",\"type\":\"uint256\"}],\"name\":\"SetMaxSaleAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_official\",\"type\":\"address\"}],\"name\":\"SetOfficial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FunnyCoinPledgeContract", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000f77dcb1d378ff8b83a1948f7982cb6a9802d1037000000000000000000000000b595558db5baa27b28321bd8992e8c254f8aaae10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b595558db5baa27b28321bd8992e8c254f8aaae1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b6fd3986b5cf62fbbfb35dca9c4b0faf4553640967143974b235757e824402d3"}