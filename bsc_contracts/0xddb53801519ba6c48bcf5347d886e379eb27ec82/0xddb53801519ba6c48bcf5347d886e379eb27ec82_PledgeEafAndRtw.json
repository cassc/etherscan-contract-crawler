{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function burn(uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary AddressStr{\r\n    \r\n    function toString(address account) internal pure returns(string memory) {\r\n        bytes memory data = abi.encodePacked(account);\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n    \r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint i = 0; i < data.length; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n}\r\n\r\nlibrary uintStr{\r\n    \r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + value % 10));\r\n            value /= 10;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n}\r\n\r\nlibrary StrLibrary{\r\n    \r\n    using uintStr for uint;\r\n    using AddressStr for address;\r\n\r\n    function listToString(string[] memory list)internal pure returns (string memory) {\r\n        uint256 len = 0;\r\n        uint256 k = 0;\r\n        for(uint256 i = 0; i < list.length; i++){\r\n            len += bytes(list[i]).length;\r\n        }\r\n        bytes memory bret = new bytes(len);\r\n        for(uint256 i = 0; i < list.length; i++){\r\n            bytes memory bi = bytes(list[i]);\r\n            for(uint256 j = 0; j < bi.length; j++)bret[k++] = bi[j];\r\n        }\r\n        return string(bret);\r\n    }\r\n    \r\n    function add(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n\r\n        bytes memory _bb = bytes(_b);\r\n\r\n        bytes memory bret = new bytes(_ba.length + _bb.length);\r\n\r\n        uint k = 0;\r\n\r\n        for (uint i = 0; i < _ba.length; i++) bret[k++] = _ba[i];\r\n\r\n        for (uint i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\r\n\r\n        return string(bret);\r\n    }\r\n    \r\n    function add(string memory _a, uint value) internal pure returns (string memory) {\r\n        return add(_a, value.toString());\r\n    }\r\n    \r\n    function add(string memory _a, address value) internal pure returns (string memory) {\r\n        return add(_a, value.toString());\r\n    }\r\n}\r\n\r\ninterface IPair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\n\r\ncontract PledgeEafAndRtw{\r\n\r\n    using StrLibrary for string;\r\n    \r\n    using AddressStr for address;\r\n    \r\n    using uintStr for uint;\r\n    using SafeMath for uint256;\r\n\r\n    address public _to = address(0xA07695AeDC77ca5D83963FbBBB0A3AA620412786);\r\n    address public _eaf = address(0x159e6296951F721885413ffc5F97cC208b2920CE);\r\n    address public _rtw = address(0xC6bf04FEE3F3D9d647818a82532b060CAdDCa8E8);\r\n    address public _usdt = address(0x55d398326f99059fF775485246999027B3197955);\r\n    IPair public _pairEaf = IPair(0x9D570B40beBbb684CBafF9f4cb01Be87C0B166a0);\r\n    IPair public _pairRtw = IPair(0x86069b994A862C661597334fE809fe844b9C1491);\r\n    address public _owner;\r\n    address public _signer;\r\n\r\n    mapping(uint256 => Record) public records;\r\n\r\n    event PledgeSend(uint256 indexed orderId, address indexed user, uint256 amount);\r\n\r\n    constructor(address owner, address signer) {\r\n        _owner = owner;\r\n        _signer = signer;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwner(address newOwner) external onlyOwner{\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function setSigner(address newSigner) external onlyOwner{\r\n        _signer = newSigner;\r\n    }\r\n\r\n    function setTo(address newTo) external onlyOwner{\r\n        _to = newTo;\r\n    }\r\n\r\n    struct Record{\r\n        uint256 orderId;\r\n        uint256 createTime;\r\n        address user;\r\n        uint256 amount;\r\n        uint256 eafAmount;\r\n        uint256 rtwAmount;\r\n    }\r\n\r\n    modifier onlyValidRecharge(uint256 orderId, uint256 amount, bytes calldata signature){\r\n        require(amount > 0, \"Recharge quantity must be greater than zero\");\r\n        address signer = findOrderSigner(orderId, amount, msg.sender, signature);\r\n        require(signer == _signer, \"The signature address is invalid\");\r\n        Record storage record = records[orderId];\r\n        require(record.createTime == 0, \"The signature has already been used\");\r\n        _;\r\n    }\r\n\r\n    function pledge(uint256 orderId, uint256 amount, bytes calldata signature) external onlyValidRecharge(orderId, amount, signature){\r\n        require(amount > 0, \"Recharge quantity must be greater than zero\");\r\n        uint256 rAmount = calcRtw(amount);\r\n        IBEP20(_rtw).transferFrom(msg.sender, _to, rAmount);\r\n        uint256 eAmount = calcEaf(amount);\r\n        IBEP20(_eaf).transferFrom(msg.sender, _to, eAmount);\r\n        Record storage record = records[orderId];\r\n        record.orderId = orderId;\r\n        record.createTime = block.timestamp;\r\n        record.user = msg.sender;\r\n        record.amount = amount;\r\n        record.rtwAmount = rAmount;\r\n        record.eafAmount = eAmount;\r\n        emit PledgeSend(orderId, msg.sender, amount);\r\n    }\r\n\r\n    function calcEaf(uint256 uAmount) public view returns(uint256){\r\n        (uint256 r0, uint256 r1, ) = _pairEaf.getReserves();\r\n        (uint256 ru, uint256 re) = _usdt == _pairEaf.token0() ? (r0, r1) : (r1, r0);\r\n        return uAmount.mul(re).div(ru);\r\n    }\r\n\r\n    function calcRtw(uint256 uAmount) public view returns(uint256){\r\n        (uint256 r0, uint256 r1, ) = _pairRtw.getReserves();\r\n        (uint256 ru, uint256 ro) = _usdt == _pairRtw.token0() ? (r0, r1) : (r1, r0);\r\n        return uAmount.mul(ro).div(ru);\r\n    }\r\n\r\n    function findSigner(bytes32 contents, bytes memory signature) internal pure returns (address) {\r\n        (bytes32 r,bytes32 s,uint8 v) = _signatureToRSV(signature);\r\n        address signer = ecrecover(contents, v, r, s);\r\n        return signer;\r\n    }\r\n\r\n    function findSigner(string memory content, bytes calldata signature) internal pure returns(address){\r\n        return findSigner(keccak256(abi.encodePacked(content)), signature);\r\n    }\r\n\r\n    function findOrderSigner(uint256 orderId, uint256 amount, address addr, bytes calldata signature)internal pure returns(address){\r\n        return findSigner(orderToMessage(orderId, amount, addr), signature);\r\n    }\r\n\r\n    function orderToMessage(uint256 orderId, uint256 amount, address addr) internal pure returns(string memory){\r\n        string[] memory list = new string[](7);\r\n        list[0] = orderId.toString();\r\n        list[1] = \"_\";\r\n        list[2] = amount.toString();\r\n        list[3] = \"_\";\r\n        list[4] = addr.toString();\r\n        return StrLibrary.listToString(list);\r\n    }\r\n\r\n    function _signatureToRSV(bytes memory signature) internal pure returns (bytes32 r,bytes32 s,uint8 v) {\r\n        require(signature.length == 65, 'signature length fail');\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := and(mload(add(signature, 65)), 255)\r\n        }\r\n        if (v < 27) v += 27;\r\n        require(v == 27 || v == 28, 'signature v fail');\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PledgeSend\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_eaf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pairEaf\",\"outputs\":[{\"internalType\":\"contract IPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pairRtw\",\"outputs\":[{\"internalType\":\"contract IPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rtw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_to\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"name\":\"calcEaf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"name\":\"calcRtw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"pledge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eafAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rtwAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTo\",\"type\":\"address\"}],\"name\":\"setTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PledgeEafAndRtw", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006c11d4983e51ca1682e5db431b347fc25f02b6600000000000000000000000006c11d4983e51ca1682e5db431b347fc25f02b660", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://15bbbcbeaa0c01e9c2c72d5d67365b9791716639d767827588dad9513202de7a"}