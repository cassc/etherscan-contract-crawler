{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.4;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Burn(\r\n        address indexed sender,\r\n        uint amount0,\r\n        uint amount1,\r\n        address indexed to\r\n    );\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping(address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;     \r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract PIXMonster is IBEP20, Auth {\r\n    using SafeMath for uint256;\r\n    address        WBNB                         = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public RESERVE                      = 0x55d398326f99059fF775485246999027B3197955;\r\n    address        DEAD                         = 0x000000000000000000000000000000000000dEaD;\r\n    address        ZERO                         = 0x0000000000000000000000000000000000000000;\r\n    address        ROUTER                       = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    uint256 public feeDenominator               = 10000;\r\n    uint256 public nixFeeNumeratorBNB           = 9000;\r\n    uint256 public nixFeeNumeratorTokenAmount   = 1000;\r\n    uint256 public slippageFactor               = 10000;\r\n    uint256 public slippageMultiplier           = 2000;\r\n    address public pixFeeReceiver               = 0x0AeEfC469847B1a53340ca79251582F174B7c37E;\r\n    address public safetyWitdrawReceiver        = 0x7FA0a7cAF42B3CB5c3f7e4B73eBb3c797b10e4A5;\r\n\r\n    //RESERVE SWAP\r\n    bool    public  reserveSwap                 = true;\r\n    uint256 public  bnbBalanceTooLow            = 5000000000000000000;\r\n    uint256 public  reserveSwapAmount           = 1000000000000000000000;\r\n    uint256 public  gasFee                      = 5200000000000000;\r\n    uint256 public  bnbEquivalent               = 1000000000000000000;\r\n\r\n    \r\n    // BUY BACK & REFERRAL SYSTEM    \r\n    uint256 private beforeBuyback               = 0;\r\n    uint256 private afterBuyback                = 0;\r\n    uint256 private beforeReferral              = 0;\r\n    uint256 private afterReferral               = 0;\r\n    uint256 private buybackAmount               = 0;\r\n    uint256 private referralAmount              = 0;\r\n\r\n    // GLOBAL TOKEN INFO\r\n    uint256 public  pixFee                      = 50;\r\n    uint256 public  contractFee                 = 0;\r\n    uint256 public  extraFee                    = 100;\r\n    uint256 public  overFee                     = 0;\r\n    uint256 public  buybackPercentage           = 1000;\r\n    address public  feeReceiver                 = 0x0AeEfC469847B1a53340ca79251582F174B7c37E;\r\n    address public  buyBackToken                = 0xBe96fcF736AD906b1821Ef74A0e4e346C74e6221;\r\n    bool    public  transferAfter               = false;\r\n    bool    public  buyBack                     = true;\r\n    bool    public  generalBuyBack              = true;\r\n\r\n    uint256 private MAXIMUM_OVER_FEE            = 10000;\r\n\r\n    uint256 private BNBToLiquify                = 0;\r\n    uint256 private BNBToLiquifyFeeAmount       = 0;\r\n    uint256 private BNBToLiquifyEXTRAFee        = 0;\r\n    uint256 private BNBToLiquifyOVERFee         = 0;\r\n    uint256 private feeAmount                   = 0;\r\n    uint256 private amountToBeSentAfterFees     = 0;\r\n\r\n    string _name                                = \"PIX Monster\";\r\n    string _symbol                              = \"PIX\";\r\n    uint8 _decimals                             = 0;\r\n\r\n    uint256 _totalSupply                        = 0;\r\n\r\n    // Info of each pool.\r\n    struct TokenInfo {\r\n        IBEP20 tokenAddress;\r\n        uint256 pixFee;\r\n        uint256 contractFee;\r\n        uint256 extraFee;\r\n        uint256 overFee;\r\n        uint256 totalFees;\r\n        address feeReceiver;\r\n        bool transferAfter;\r\n    }\r\n\r\n    struct PartnerInfo {\r\n        uint256 partnerFee;\r\n        uint256 totalTransfered;\r\n        address partnerAddress;\r\n        address partnerTokenPreference;\r\n        address partnerWorker;\r\n        bool isPartner;\r\n    }\r\n\r\n    mapping(address => PartnerInfo) public partnerInfo;\r\n    mapping(address => TokenInfo) public tokenInfo;\r\n    mapping(address => uint256) _balances;\r\n    mapping(address => bool) _isWorker;\r\n    mapping(address => mapping(address => uint256)) _allowances;\r\n    mapping(address => uint256) public totalFee;\r\n    mapping(address => bool) public isFeeExempt;\r\n    mapping(address => bool) public isBlacklisted;\r\n    mapping(address => bool) public haltIfNoBalance;\r\n\r\n    IDEXRouter public router;\r\n    IDEXRouter public mainRouter;\r\n    address public pair;\r\n\r\n    event AdminTokenRecovery(address tokenAddress, uint256 tokenAmount);\r\n\r\n    bool inSwap;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    constructor() Auth(msg.sender) {\r\n        //router = IDEXRouter(0xD99D1c33F9fC3444f8101754aBC46c52416550D1); // TESTNET ONLY\r\n        router = IDEXRouter(ROUTER); // MAINNET ONLY\r\n        mainRouter = IDEXRouter(ROUTER); // MAINNET ONLY\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = uint256(-1);\r\n        emit Transfer(ZERO, DEAD, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(\r\n        address holder,\r\n        address spender\r\n    ) external view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function addTokens(address[] calldata addresses) external onlyOwner {\r\n        for(uint i=0; i < addresses.length; i++){\r\n            setTokenInfo(\r\n                addresses[i],\r\n                pixFee,\r\n                contractFee,\r\n                extraFee,\r\n                overFee,\r\n                feeReceiver,\r\n                transferAfter\r\n            );\r\n        }\r\n    }\r\n\r\n    function addToken(address _token) external onlyOwner {\r\n        setTokenInfo(\r\n            _token,\r\n            pixFee,\r\n            contractFee,\r\n            extraFee,\r\n            overFee,\r\n            feeReceiver,\r\n            transferAfter\r\n        );\r\n    }\r\n\r\n    function setGeneralInfo(\r\n        uint256 _pixFee,\r\n        uint256 _contractFee,\r\n        uint256 _extraFee,\r\n        uint256 _overFee,\r\n        address _feeReceiver,\r\n        bool _transferAfter,\r\n        address _buyBackToken,\r\n        bool _generalBuyBack,\r\n        uint256 _buybackPercentage\r\n    ) external onlyOwner {\r\n        pixFee = _pixFee;\r\n        contractFee = _contractFee;\r\n        extraFee = _extraFee;\r\n        overFee = _overFee;\r\n        feeReceiver = _feeReceiver;\r\n        transferAfter = _transferAfter;\r\n        buyBackToken = _buyBackToken;\r\n        generalBuyBack = _generalBuyBack;\r\n        buybackPercentage = _buybackPercentage;\r\n    }\r\n\r\n    function setTokenInfo(\r\n        address _tokenAddress,\r\n        uint256 _pixFee,\r\n        uint256 _contractFee,\r\n        uint256 _extraFee,\r\n        uint256 _overFee,\r\n        address _feeReceiver,\r\n        bool _transferAfter\r\n    ) public {\r\n        require(\r\n            msg.sender == owner || msg.sender == address(this),\r\n            \"You are not authorized\"\r\n        );\r\n\r\n        TokenInfo storage token = tokenInfo[_tokenAddress];\r\n        token.tokenAddress = IBEP20(_tokenAddress);\r\n        token.pixFee = _pixFee;\r\n        token.contractFee = _contractFee;\r\n        token.extraFee = _extraFee;\r\n        token.overFee = _overFee;\r\n        token.feeReceiver = _feeReceiver;\r\n        token.transferAfter = _transferAfter;\r\n        totalFee[_tokenAddress] = _pixFee.add(_contractFee).add(_extraFee);\r\n        token.totalFees = totalFee[_tokenAddress];\r\n    }\r\n\r\n    function setPartnerInfo(\r\n        uint256 _partnerFee,\r\n        address _partnerAddress,\r\n        address _partnerWorker,\r\n        address _partnerTokenPreference,\r\n        bool _isPartner\r\n    ) external onlyOwner {\r\n        PartnerInfo storage partner = partnerInfo[_partnerAddress];\r\n        partner.partnerFee = _partnerFee;\r\n        partner.partnerAddress = _partnerAddress;\r\n        partner.partnerWorker = _partnerWorker;\r\n        partner.partnerTokenPreference = _partnerTokenPreference;\r\n        partner.isPartner = _isPartner;\r\n    }\r\n\r\n    function halt(address _address, bool _enabled) public onlyOwner {\r\n        require(_enabled != haltIfNoBalance[_address]);\r\n        haltIfNoBalance[_address] = _enabled;\r\n    }\r\n\r\n    function setPixFeeReceiver(\r\n        address _pixFeeReceiver,\r\n        uint256 _gasFee\r\n    ) external onlyOwner {\r\n        pixFeeReceiver = _pixFeeReceiver;\r\n        gasFee = _gasFee;\r\n    }\r\n\r\n    function setNixFees(\r\n        uint256 _nixFeeBNB,\r\n        uint256 _nixFeeToken\r\n    ) external onlyOwner {\r\n        nixFeeNumeratorBNB = _nixFeeBNB;\r\n        nixFeeNumeratorTokenAmount = _nixFeeToken;\r\n    }\r\n\r\n    function setWorker(\r\n        address _workerAddress,\r\n        bool _enabled\r\n    ) external onlyOwner {\r\n        require(_isWorker[_workerAddress] != _enabled);\r\n        _isWorker[_workerAddress] = _enabled;\r\n    }\r\n\r\n    function blacklist(address _token, bool _isBlacklisted) external onlyOwner {\r\n        require(isBlacklisted[_token] != _isBlacklisted);\r\n        isBlacklisted[_token] = _isBlacklisted;\r\n    }\r\n\r\n    function setReserveConfig(\r\n        bool _enabled,\r\n        address _reserveTokenAddress,\r\n        uint256 _minReserveBalance,\r\n        uint256 _minBNB\r\n    ) external onlyOwner {\r\n        reserveSwap = _enabled;\r\n        RESERVE = _reserveTokenAddress;\r\n        bnbBalanceTooLow = _minBNB;\r\n        reserveSwapAmount = _minReserveBalance;\r\n    }\r\n\r\n    function PIXTransfer(\r\n        address _token,\r\n        address _deliveryAddress,\r\n        uint256 _amount\r\n    ) public {        \r\n        require(_isWorker[msg.sender], \"MSG SENDER is not a worker\");\r\n        require(!isBlacklisted[_token], \"BLACKLISTED\");\r\n        uint256 amountToLiquify = _amount;\r\n        if (_token != WBNB) {\r\n            require(IBEP20(_token).balanceOf(address(this)) >= _amount);\r\n            IBEP20(_token).transfer(address(_deliveryAddress), _amount);\r\n        } else {\r\n            require(address(this).balance >= amountToLiquify);\r\n            (bool tmpSuccess, ) = payable(_deliveryAddress).call{\r\n                value: amountToLiquify,\r\n                gas: 30000\r\n            }(\"\");\r\n            tmpSuccess = false;\r\n        }\r\n    }\r\n\r\n    function process(\r\n        address _token,\r\n        address _referralToken,\r\n        address _deliveryAddress,\r\n        address _referrer,\r\n        uint256 _amountBNBToLiquify,\r\n        uint256 _mintokenAmount\r\n    ) internal swapping {\r\n        //CHECKS CONTRACT INFO\r\n        TokenInfo storage token = tokenInfo[_token];\r\n\r\n        //REQUIREMENTS\r\n        require(!isBlacklisted[_token], \"BLACKLISTED\");\r\n        require(\r\n            address(this).balance >= _amountBNBToLiquify,\r\n            \"INSUFFICIENT_BNB_BALANCE\"\r\n        );\r\n        require(\r\n            !haltIfNoBalance[_token] ||\r\n                IBEP20(_token).balanceOf(address(this)) >= _mintokenAmount,\r\n            \"HALT_IF_NO_BALANCE\"\r\n        );\r\n\r\n        //SET TRADING CONFIG\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = _token;\r\n\r\n        //CREATE LOCAL VARIABLES\r\n        bool swapHasBeenDone = false;\r\n        uint256 totalAmountSent = 0;\r\n        address deliveryAddress = _deliveryAddress;\r\n        address referrer = _referrer;\r\n\r\n        //RESET VARIABLES\r\n        BNBToLiquify = _amountBNBToLiquify;\r\n        BNBToLiquifyFeeAmount = 0;\r\n        BNBToLiquifyEXTRAFee = 0;\r\n        BNBToLiquifyOVERFee = 0;\r\n        feeAmount = 0;\r\n        amountToBeSentAfterFees = _mintokenAmount;\r\n\r\n        //UPDATES AMOUNT OF FEES TO BE CHARGED\r\n        if (token.totalFees > 0) {\r\n            BNBToLiquifyFeeAmount = BNBToLiquify\r\n                .mul(token.totalFees.sub(token.contractFee))\r\n                .div(feeDenominator);\r\n        }\r\n        if (token.extraFee > 0) {\r\n         \r\n            BNBToLiquifyEXTRAFee = BNBToLiquify.mul(token.extraFee).div(feeDenominator);\r\n\r\n            // CHECKS IF BUYBACK IS OFF. IF IT IS, ADDS BUYBACK FEE TO PIXFEE\r\n            if (!generalBuyBack) {\r\n                BNBToLiquifyFeeAmount = BNBToLiquifyFeeAmount.add(BNBToLiquifyEXTRAFee);\r\n                BNBToLiquifyEXTRAFee = 0;\r\n            }\r\n        }\r\n        if (\r\n            token.overFee > 0 &&\r\n            IBEP20(_token).balanceOf(address(this)) > _mintokenAmount\r\n        ) {\r\n            BNBToLiquifyOVERFee = BNBToLiquify.mul(token.overFee).div(feeDenominator);\r\n        }\r\n\r\n        //SEND FEES & BUY BACK TOKENS\r\n        if (BNBToLiquifyFeeAmount > 0 && !isFeeExempt[_deliveryAddress]) {\r\n            BNBToLiquify = BNBToLiquify.sub(BNBToLiquifyFeeAmount);\r\n            if (token.pixFee > 0) {\r\n                BNBToLiquifyFeeAmount = BNBToLiquifyFeeAmount.add(gasFee).add(\r\n                    BNBToLiquifyOVERFee\r\n                );\r\n                (bool tmpSuccess, ) = payable(pixFeeReceiver).call{\r\n                    value: BNBToLiquifyFeeAmount,\r\n                    gas: 30000\r\n                }(\"\");\r\n                tmpSuccess = false;\r\n            }\r\n            if (token.pixFee == 0) {\r\n                BNBToLiquifyOVERFee = BNBToLiquifyOVERFee.add(gasFee);\r\n                (bool tmpSuccess, ) = payable(pixFeeReceiver).call{\r\n                    value: BNBToLiquifyOVERFee,\r\n                    gas: 30000\r\n                }(\"\");\r\n                tmpSuccess = false;\r\n            }\r\n            if (BNBToLiquifyEXTRAFee > 0 && generalBuyBack && _referralToken == buyBackToken) {   \r\n                // RECORDS CURRENT BALANCE\r\n                beforeBuyback = IBEP20(buyBackToken).balanceOf(address(this));\r\n                // BUY TOKENS\r\n                mainRouterBuy(BNBToLiquifyEXTRAFee, buyBackToken, address(this), address(this));\r\n                // RECORDS NEW BALANCE\r\n                afterBuyback = IBEP20(buyBackToken).balanceOf(address(this));\r\n                // IDENTIFIES BOUGHT AMOUNT\r\n                buybackAmount = afterBuyback.sub(beforeBuyback);\r\n                // CHECKS IF THERE IS ANY BALANCE TO BE SENT OUT\r\n                if (buybackAmount > 0) {\r\n                    // SEND BUYBACK TOKENS TO DIFFERENT ADDRESSES\r\n                    if(referrer != deliveryAddress && buybackAmount > 1) {\r\n                        buybackAmount = buybackAmount.div(2);\r\n                        IBEP20(buyBackToken).transfer(address(deliveryAddress), buybackAmount);\r\n                        IBEP20(buyBackToken).transfer(address(referrer), buybackAmount);\r\n                        // SET BUYBACK AMOUNT VARIABLE TO ORIGINAL VALUE\r\n                        buybackAmount = buybackAmount.mul(2);\r\n                    } \r\n                    // SEND BUYBACK TOKENS TO SAME ADDRESS AS REFERRER\r\n                    if (referrer == deliveryAddress && buybackAmount > 1) { \r\n                        IBEP20(buyBackToken).transfer(address(deliveryAddress), buybackAmount);                    \r\n                    }\r\n                    // AUTO OVER BURN IF THERE IS ENOUGH BALANCE IN THE CONTRACT\r\n                    buybackAmount = buybackAmount.div(feeDenominator).mul(buybackPercentage);\r\n                    if (IBEP20(buyBackToken).balanceOf(address(this)) >= buybackAmount && buybackPercentage > 0) {\r\n                        IBEP20(buyBackToken).transfer(address(DEAD), buybackAmount);\r\n                    }\r\n                }\r\n            }\r\n            if (BNBToLiquifyEXTRAFee > 0 && generalBuyBack && _referralToken != buyBackToken) {   \r\n                // RECORDS CURRENT BALANCE\r\n                BNBToLiquifyEXTRAFee = BNBToLiquifyEXTRAFee.div(2);\r\n                beforeBuyback = IBEP20(buyBackToken).balanceOf(address(this));\r\n                beforeReferral = IBEP20(_referralToken).balanceOf(address(this));\r\n                // BUY TOKENS\r\n                buy(BNBToLiquifyEXTRAFee, buyBackToken, address(this), address(this));\r\n                buy(BNBToLiquifyEXTRAFee, _referralToken, address(this), address(this));\r\n                // RECORDS NEW BALANCE\r\n                afterBuyback = IBEP20(buyBackToken).balanceOf(address(this));\r\n                afterReferral = IBEP20(_referralToken).balanceOf(address(this));\r\n                // IDENTIFIES BOUGHT AMOUNT\r\n                buybackAmount = afterBuyback.sub(beforeBuyback);\r\n                referralAmount = afterReferral.sub(beforeReferral);\r\n                // CHECKS IF THERE IS ANY BALANCE TO BE SENT OUT\r\n                if (buybackAmount > 0) {\r\n                    IBEP20(buyBackToken).transfer(address(deliveryAddress), buybackAmount);\r\n                    // AUTO OVER BURN IF THERE IS ENOUGH BALANCE IN THE CONTRACT\r\n                    buybackAmount = buybackAmount.div(feeDenominator).mul(buybackPercentage);\r\n                    if (IBEP20(buyBackToken).balanceOf(address(this)) >= buybackAmount && buybackPercentage > 0) {\r\n                        IBEP20(buyBackToken).transfer(address(DEAD), buybackAmount);\r\n                    }\r\n                }\r\n                if (referralAmount > 0) {\r\n                    IBEP20(_referralToken).transfer(address(referrer), referralAmount);     \r\n                }\r\n            }\r\n        }\r\n\r\n        // DELIVERY PROCESS STARTS HERE IF IT'S NOT BNB\r\n        if (_token != WBNB) {\r\n            uint256 balanceBefore = IBEP20(_token).balanceOf(address(this));\r\n            if (token.transferAfter) {\r\n                deliveryAddress = address(this);\r\n            }\r\n            if (balanceBefore < _mintokenAmount || _mintokenAmount == 0) {\r\n                uint256 minAmount = _mintokenAmount;\r\n                if (minAmount >= 3) {\r\n                    minAmount =\r\n                        (minAmount / slippageFactor) *\r\n                        slippageMultiplier;\r\n                }\r\n                router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                    value: BNBToLiquify\r\n                }(minAmount, path, deliveryAddress, block.timestamp);\r\n                swapHasBeenDone = true;\r\n                if (deliveryAddress == _deliveryAddress) {\r\n                    totalAmountSent = _mintokenAmount;\r\n                }\r\n                uint256 balanceNow = IBEP20(_token).balanceOf(address(this));\r\n                uint256 amountToBeSent = balanceNow.sub(balanceBefore);\r\n                if (\r\n                    balanceNow > balanceBefore &&\r\n                    deliveryAddress != _deliveryAddress\r\n                ) {\r\n                    IBEP20(_token).transfer(\r\n                        address(_deliveryAddress),\r\n                        amountToBeSent\r\n                    );\r\n                    totalAmountSent = amountToBeSent;\r\n                }\r\n            } else if (\r\n                balanceBefore >= _mintokenAmount && _mintokenAmount > 0\r\n            ) {\r\n                feeAmount = _mintokenAmount.mul(token.totalFees).div(\r\n                    feeDenominator\r\n                );\r\n                amountToBeSentAfterFees = _mintokenAmount.sub(feeAmount);\r\n                IBEP20(_token).transfer(\r\n                    address(_deliveryAddress),\r\n                    amountToBeSentAfterFees\r\n                );\r\n                totalAmountSent = amountToBeSentAfterFees;\r\n            }\r\n\r\n            // IF IT'S BNB, THE DELIVERY WILL HAPPEN HERE\r\n        } else {\r\n            require(\r\n                address(this).balance >= BNBToLiquify,\r\n                \"Insufficient BNB Balance\"\r\n            );\r\n            (bool tmpSuccess, ) = payable(_deliveryAddress).call{\r\n                value: BNBToLiquify,\r\n                gas: 30000\r\n            }(\"\");\r\n            tmpSuccess = false;\r\n        }\r\n        beforeBuyback               = 0;\r\n        afterBuyback                = 0;\r\n        beforeReferral              = 0;\r\n        afterReferral               = 0;\r\n        buybackAmount               = 0;\r\n        referralAmount              = 0;\r\n    }\r\n\r\n    //HERE IS WHERE THE MAGIC HAPPENS\r\n    function criptoNoPix(\r\n        address _tokenAddress,\r\n        address _holder,\r\n        address _referral,\r\n        address _referralToken,\r\n        uint256 _amountInBNB,\r\n        uint256 _mintokenAmount,\r\n        address _router,\r\n        uint256 _slippage\r\n    ) external {\r\n        require(_slippage <= slippageFactor, \"Slippage too high\");\r\n        slippageMultiplier = slippageFactor.sub(_slippage);\r\n        require(_isWorker[msg.sender], \"MSG SENDER is not a worker\");\r\n        require(\r\n            _amountInBNB > 0 || _mintokenAmount > 0,\r\n            \"BOTH_AMOUNTS_CANNOT_BE_ZERO\"\r\n        );\r\n        \r\n        // ADJUST PROPER BNB BALANCE TO BE ABLE TO BUY TOKENS\r\n         if (\r\n            reserveSwap &&\r\n            IBEP20(RESERVE).balanceOf(address(this)) >= reserveSwapAmount &&\r\n            address(this).balance < _amountInBNB\r\n        ) {\r\n            adjustBalance(RESERVE, WBNB, reserveSwapAmount, 0, address(this));\r\n        }\r\n\r\n        // SETS UP ROUTER\r\n        router = IDEXRouter(_router);\r\n\r\n        require(_tokenAddress != _holder, \"DUPLICATED_ADDRESS\");\r\n        if (_tokenAddress == buyBackToken) {\r\n            uint256 amountBNBToBuy = _amountInBNB.mul(nixFeeNumeratorBNB).div(\r\n                feeDenominator\r\n            );\r\n            uint256 mintokenAmountToTransfer = _mintokenAmount\r\n                .mul(nixFeeNumeratorTokenAmount)\r\n                .div(feeDenominator);\r\n            uint256 minTokenAmountToBuy = _mintokenAmount.sub(\r\n                mintokenAmountToTransfer\r\n            );\r\n            if (\r\n                IBEP20(buyBackToken).balanceOf(address(this)) >= \r\n                mintokenAmountToTransfer\r\n            ) {\r\n                PIXTransfer(buyBackToken, _holder, mintokenAmountToTransfer);\r\n                process(\r\n                    buyBackToken,\r\n                    _referralToken,\r\n                    _holder,\r\n                    _referral,\r\n                    amountBNBToBuy,\r\n                    minTokenAmountToBuy\r\n                );\r\n            } else {\r\n                process(\r\n                    buyBackToken,\r\n                    _referralToken,\r\n                    _holder,\r\n                    _referral,\r\n                    _amountInBNB,\r\n                    _mintokenAmount\r\n                );\r\n            }\r\n        } else {\r\n            process(\r\n                _tokenAddress,\r\n                _referralToken,\r\n                _holder,\r\n                _referral,\r\n                _amountInBNB,\r\n                _mintokenAmount\r\n            );\r\n        }\r\n        if (\r\n            reserveSwap &&\r\n            IBEP20(RESERVE).balanceOf(address(this)) >= reserveSwapAmount &&\r\n            address(this).balance < bnbBalanceTooLow\r\n        ) {\r\n            adjustBalance(RESERVE, WBNB, reserveSwapAmount, 0, address(this));\r\n        }\r\n    }\r\n\r\n    function partnerNoPix(\r\n        address _partnerAddress,\r\n        uint256 _amountToTransfer\r\n    ) external {\r\n        require(_isWorker[msg.sender], \"Something is not right\");\r\n        require(_amountToTransfer > 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n        require(_partnerAddress != address(this), \"DUPLICATED_ADDRESS\");\r\n\r\n        PartnerInfo storage partner = partnerInfo[_partnerAddress];\r\n        require(partner.isPartner, \"NOT_A_PARTNER\");\r\n        require(msg.sender == partner.partnerWorker, \"NOT_A_WORKER\");\r\n        partner.totalTransfered = partner.totalTransfered.add(\r\n            _amountToTransfer\r\n        );\r\n        uint256 _amountToken = _amountToTransfer.mul(partner.partnerFee).div(\r\n            feeDenominator\r\n        );\r\n        uint256 _amountToPartner = _amountToTransfer.sub(_amountToken);\r\n        PIXTransfer(\r\n            partner.partnerTokenPreference,\r\n            _partnerAddress,\r\n            _amountToPartner\r\n        );\r\n\r\n        if (\r\n            reserveSwap &&\r\n            IBEP20(RESERVE).balanceOf(address(this)) >= reserveSwapAmount &&\r\n            address(this).balance < bnbBalanceTooLow\r\n        ) {\r\n            adjustBalance(RESERVE, WBNB, reserveSwapAmount, 0, address(this));\r\n        }\r\n    }\r\n\r\n    function buy(\r\n        uint256 _amountToLiquify,\r\n        address _tokenAddress,\r\n        address _feeReceiver,\r\n        address _refferral\r\n    ) internal swapping {\r\n        require(\r\n            address(this).balance >= _amountToLiquify,\r\n            \"INSUFFICIENT_BNB_BALANCE\"\r\n        );\r\n        //SET TRADING CONFIG\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = _tokenAddress;\r\n        if (_feeReceiver != _refferral){\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _feeReceiver, block.timestamp);\r\n        \r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _refferral, block.timestamp);\r\n        } else {\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _feeReceiver, block.timestamp);\r\n        }\r\n\r\n    }\r\n    function mainRouterBuy(\r\n        uint256 _amountToLiquify,\r\n        address _tokenAddress,\r\n        address _feeReceiver,\r\n        address _refferral\r\n    ) internal swapping {\r\n        require(\r\n            address(this).balance >= _amountToLiquify,\r\n            \"INSUFFICIENT_BNB_BALANCE\"\r\n        );\r\n        //SET TRADING CONFIG\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = _tokenAddress;\r\n        if (_feeReceiver != _refferral){\r\n        mainRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _feeReceiver, block.timestamp);\r\n        \r\n        mainRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _refferral, block.timestamp);\r\n        } else {\r\n            mainRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _feeReceiver, block.timestamp);\r\n        }\r\n\r\n    }\r\n\r\n    function updateBalance(uint256 _amount) external onlyOwner {\r\n        require(reserveSwap);\r\n        adjustBalance(RESERVE, WBNB, _amount, 0, address(this));\r\n    }\r\n\r\n    function cashback(uint256 _bnbAmount, address _referrer, address _deliveryAddress) external onlyOwner {\r\n        // RECORDS CURRENT BALANCE\r\n        beforeBuyback = IBEP20(buyBackToken).balanceOf(address(this));\r\n        // BUY TOKENS\r\n        mainRouterBuy(_bnbAmount, buyBackToken, address(this), address(this));\r\n        // RECORDS NEW BALANCE\r\n        afterBuyback = IBEP20(buyBackToken).balanceOf(address(this));\r\n        // IDENTIFIES BOUGHT AMOUNT\r\n        buybackAmount = afterBuyback.sub(beforeBuyback);\r\n        // CHECKS IF BUYBACK AMOUNT IS OK\r\n        if (buybackAmount > 0) {\r\n            // SEND BUYBACK TOKENS\r\n            if(_referrer != _deliveryAddress && buybackAmount > 1) {\r\n                buybackAmount = buybackAmount.div(2);\r\n                IBEP20(buyBackToken).transfer(address(_deliveryAddress), buybackAmount);\r\n                IBEP20(buyBackToken).transfer(address(_referrer), buybackAmount);\r\n            } else { \r\n                IBEP20(buyBackToken).transfer(address(_deliveryAddress), buybackAmount);                    \r\n            }\r\n        }\r\n        beforeBuyback               = 0;\r\n        afterBuyback                = 0;\r\n        beforeReferral              = 0;\r\n        afterReferral               = 0;\r\n        buybackAmount               = 0;\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function adjustBalance(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to\r\n    ) internal swapping {\r\n        //first we need to transfer the amount in tokens from the msg.sender to this contract\r\n        //this contract will have the amount of in tokens\r\n        // IERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn);\r\n\r\n        //next we need to allow the uniswapv2 router to spend the token we just sent to this contract\r\n        //by calling IERC20 approve you allow the uniswap contract to spend the tokens in this contract\r\n        if (IBEP20(_tokenIn).allowance(address(this), ROUTER) < _amountIn) {\r\n            require(\r\n                IBEP20(_tokenIn).approve(ROUTER, type(uint256).max),\r\n                \"TOKENSWAP::Approve failed\"\r\n            );\r\n        }\r\n\r\n        //path is an array of addresses.\r\n        //this path array will have 3 addresses [tokenIn, WETH, tokenOut]\r\n        //the if statement below takes into account if token in or token out is WETH.  then the path is only 2 addresses\r\n        address[] memory path;\r\n        if (_tokenIn == WBNB || _tokenOut == WBNB) {\r\n            path = new address[](2);\r\n            path[0] = _tokenIn;\r\n            path[1] = _tokenOut;\r\n        } else {\r\n            path = new address[](3);\r\n            path[0] = _tokenIn;\r\n            path[1] = WBNB;\r\n            path[2] = _tokenOut;\r\n        }\r\n        //then we will call swapExactTokensForTokens\r\n        //for the deadline we will pass in block.timestamp\r\n        //the deadline is the latest time the trade is valid for\r\n        mainRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            _amountIn,\r\n            _amountOutMin,\r\n            path,\r\n            _to,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, uint256(-1));\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != uint256(-1)) {\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\r\n                .sub(amount, \"Insufficient Allowance\");\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function withdrawBNB(uint256 amountPercentage) external onlyOwner {\r\n        uint256 amountBNB = address(this).balance;\r\n        payable(safetyWitdrawReceiver).transfer(\r\n            (amountBNB * amountPercentage) / 100\r\n        );\r\n    }\r\n\r\n    function withdrawTokens(address _tokenAddress) external onlyOwner {\r\n        uint256 tokenBalance = IBEP20(_tokenAddress).balanceOf(address(this));\r\n        IBEP20(_tokenAddress).transfer(\r\n            address(safetyWitdrawReceiver),\r\n            tokenBalance\r\n        );\r\n        emit AdminTokenRecovery(_tokenAddress, tokenBalance);\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_deliveryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PIXTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESERVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBlacklisted\",\"type\":\"bool\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbBalanceTooLow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnbAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_deliveryAddress\",\"type\":\"address\"}],\"name\":\"cashback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"criptoNoPix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generalBuyBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"halt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"haltIfNoBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainRouter\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nixFeeNumeratorBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nixFeeNumeratorTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"partnerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTransfered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"partnerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"partnerTokenPreference\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"partnerWorker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPartner\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partnerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToTransfer\",\"type\":\"uint256\"}],\"name\":\"partnerNoPix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pixFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pixFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safetyWitdrawReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pixFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_contractFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_extraFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_overFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_transferAfter\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_buyBackToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_generalBuyBack\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_buybackPercentage\",\"type\":\"uint256\"}],\"name\":\"setGeneralInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nixFeeBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nixFeeToken\",\"type\":\"uint256\"}],\"name\":\"setNixFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_partnerFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_partnerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_partnerWorker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_partnerTokenPreference\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isPartner\",\"type\":\"bool\"}],\"name\":\"setPartnerInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pixFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"setPixFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_reserveTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBNB\",\"type\":\"uint256\"}],\"name\":\"setReserveConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pixFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_contractFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_extraFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_overFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_transferAfter\",\"type\":\"bool\"}],\"name\":\"setTokenInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_workerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippageFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippageMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pixFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"transferAfter\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferAfter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PIXMonster", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://121bd3b9a12937b84fad5307941fcf93f1447e22ba61903e38f93aa1f7b68319"}