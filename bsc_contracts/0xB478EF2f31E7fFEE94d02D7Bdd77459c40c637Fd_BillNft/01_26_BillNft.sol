// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

/*
  ______                     ______                                 
 /      \                   /      \                                
|  ▓▓▓▓▓▓\ ______   ______ |  ▓▓▓▓▓▓\__   __   __  ______   ______  
| ▓▓__| ▓▓/      \ /      \| ▓▓___\▓▓  \ |  \ |  \|      \ /      \ 
| ▓▓    ▓▓  ▓▓▓▓▓▓\  ▓▓▓▓▓▓\\▓▓    \| ▓▓ | ▓▓ | ▓▓ \▓▓▓▓▓▓\  ▓▓▓▓▓▓\
| ▓▓▓▓▓▓▓▓ ▓▓  | ▓▓ ▓▓    ▓▓_\▓▓▓▓▓▓\ ▓▓ | ▓▓ | ▓▓/      ▓▓ ▓▓  | ▓▓
| ▓▓  | ▓▓ ▓▓__/ ▓▓ ▓▓▓▓▓▓▓▓  \__| ▓▓ ▓▓_/ ▓▓_/ ▓▓  ▓▓▓▓▓▓▓ ▓▓__/ ▓▓
| ▓▓  | ▓▓ ▓▓    ▓▓\▓▓     \\▓▓    ▓▓\▓▓   ▓▓   ▓▓\▓▓    ▓▓ ▓▓    ▓▓
 \▓▓   \▓▓ ▓▓▓▓▓▓▓  \▓▓▓▓▓▓▓ \▓▓▓▓▓▓  \▓▓▓▓▓\▓▓▓▓  \▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓ 
         | ▓▓                                             | ▓▓      
         | ▓▓                                             | ▓▓      
          \▓▓                                              \▓▓         
 * App:             https://ApeSwap.finance
 * Medium:          https://ape-swap.medium.com
 * Twitter:         https://twitter.com/ape_swap
 * Telegram:        https://t.me/ape_swap
 * Announcements:   https://t.me/ape_swap_news
 * Discord:         https://ApeSwap.click/discord
 * Reddit:          https://reddit.com/r/ApeSwap
 * Instagram:       https://instagram.com/ApeSwap.finance
 * GitHub:          https://github.com/ApeSwapFinance
 */

import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "./interfaces/IBillNft.sol";
import "./interfaces/ICustomBill.sol";

/**
 * @dev {ERC721} token, including:
 *  - a minter role that allows for token minting (creation)
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 */
contract BillNft is
    IBillNft,
    AccessControlEnumerableUpgradeable,
    ERC721EnumerableUpgradeable
{
    using CountersUpgradeable for CountersUpgradeable.Counter;
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant URI_SETTER_ROLE = keccak256("URI_SETTER_ROLE");
    bytes32 public constant FACTORY_ROLE = keccak256("FACTORY_ROLE");

    event BaseTokenUriChanged(string newUri);
    event UriLocked();

    CountersUpgradeable.Counter private _tokenIdTracker;
    mapping(uint256 => address) public billAddresses; // stores bill address for nfts

    string private _baseTokenURI;
    bool public uriLocked = false;
    // Optional mapping for token URIs
    mapping(uint256 => string) private _tokenURIs;

    /**
     * "Storage gaps are a convention for reserving storage slots in a base contract, allowing future 
     *  versions of that contract to use up those slots without affecting the storage layout of child contracts."
     *
     *  For more info, see "Storage Gaps" at https://docs.openzeppelin.com/ 
     */
    uint256[50] private __gap;

    modifier onlyAdmin() {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),
            "BillNft: Only admin role"
        );
        _;
    }

    modifier onlyMinter() {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            "BillNft: Only minter role"
        );
        _;
    }

    modifier onlyValidTokenId(uint256 tokenId) {
        require(_exists(tokenId), "Invalid tokenId");
        _;
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE` to the owner account.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address factory,
        address owner
    ) external initializer {
        __ERC721_init(name, symbol);
        __ERC721Enumerable_init();
        __AccessControlEnumerable_init();

        _baseTokenURI = baseTokenURI;

        require(factory != address(0), "factory cannot be address(0)");
        _setupRole(FACTORY_ROLE, factory);
        require(owner != address(0), "owner cannot be address(0)");
        _setupRole(DEFAULT_ADMIN_ROLE, owner);
        _setupRole(URI_SETTER_ROLE, owner);

        // Start BillNfts tokenIds at 1
        _tokenIdTracker.increment();
    }

    function _baseURI()
        internal
        view
        override(ERC721Upgradeable)
        returns (string memory)
    {
        return _baseTokenURI;
    }

    function setBaseURI(string memory baseTokenURI) external onlyAdmin {
        require(!uriLocked, "Not happening.");
        _baseTokenURI = baseTokenURI;
        emit BaseTokenUriChanged(_baseTokenURI);
    }

    function lockURI() external override(IBillNft) onlyAdmin {
        uriLocked = true;
        emit UriLocked();
    }

    /**
     * @dev Grant MINTER_ROLE for minting BillNFTs
     * @param minter Address to grant minter role to
     *
     * Requirements:
     *
     * - msg.sender MUST have DEFAULT_ADMIN_ROLE or FACTORY_ROLE
     */
    function addMinter(address minter) external override(IBillNft) {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()) ||
                hasRole(FACTORY_ROLE, _msgSender()),
            "Only admin or factory role"
        );

        _grantRole(MINTER_ROLE, minter);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller MUST have the `MINTER_ROLE`.
     */
    function mint(address to, address billAddress)
        external
        override(IBillNft)
        onlyMinter
        returns (uint256 newTokenId)
    {
        return _mintInternal(to, billAddress);
    }

    function mintMany(
        uint256 amount,
        address to,
        address billAddress
    ) external override(IBillNft) onlyMinter {
        for (uint256 i = 0; i < amount; i++) {
            _mintInternal(to, billAddress);
        }
    }

    function _mintInternal(address to, address billAddress)
        internal
        returns (uint256 newTokenId)
    {
        newTokenId = _tokenIdTracker.current();
        _mint(to, newTokenId);
        billAddresses[newTokenId] = billAddress;
        _tokenIdTracker.increment();
    }

    function allTokensDataOfOwner(address owner)
        external
        view
        override(IBillNft)
        returns (TokenData[] memory)
    {
        uint256 length = ERC721Upgradeable.balanceOf(owner);
        return getTokensOfOwnerByIndexes(owner, 0, length);
    }

    function getTokensOfOwnerByIndexes(
        address owner,
        uint256 start,
        uint256 end
    ) public view override(IBillNft) returns (TokenData[] memory) {
        TokenData[] memory result = new TokenData[](end - start);
        for (uint256 i = start; i < end; i++) {
            TokenData memory tokenData = tokenDataOfOwnerByIndex(owner, i);
            result[i - start] = tokenData;
        }
        return result;
    }

    function tokenDataOfOwnerByIndex(address owner, uint256 index)
        public
        view
        override(IBillNft)
        returns (TokenData memory tokenData)
    {
        uint256 tokenId = tokenOfOwnerByIndex(owner, index);
        address billAddress = billAddresses[tokenId];
        tokenData = TokenData({tokenId: tokenId, billAddress: billAddress});
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(
            IERC165Upgradeable,
            ERC721EnumerableUpgradeable,
            AccessControlEnumerableUpgradeable
        )
        returns (bool)
    {
        return
            interfaceId == type(IERC5725).interfaceId ||
            AccessControlEnumerableUpgradeable.supportsInterface(interfaceId) ||
            ERC721EnumerableUpgradeable.supportsInterface(interfaceId);
    }

    /**
     * @dev See {ERC721Upgradeable-tokenURI}.
     */
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override(ERC721Upgradeable)
        returns (string memory)
    {
        require(_exists(tokenId), "URI query for nonexistent token");

        string memory _tokenURI = _tokenURIs[tokenId];

        if (bytes(_tokenURI).length > 0) {
            return _tokenURI;
        }

        return super.tokenURI(tokenId);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function setTokenURI(uint256 tokenId, string memory _tokenURI)
        external
        virtual
        override(IBillNft)
    {
        require(!uriLocked, "Not happening.");
        require(
            hasRole(URI_SETTER_ROLE, _msgSender()),
            "BillNft: Only uri setter role"
        );
        _setTokenURI(tokenId, _tokenURI);
    }

    function _setTokenURI(uint256 tokenId, string memory _tokenURI)
        internal
        virtual
        onlyValidTokenId(tokenId)
    {
        _tokenURIs[tokenId] = _tokenURI;
    }

    /**
     * @dev See {IERC5725-claim}.
     *
     * Requirements:
     *
     * - MUST be owner or claim-approved for the tokenId passed
     */
    function claim(uint256 tokenId) public override(IERC5725) {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "Not approved");
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        uint256 claimAmount = bill.claim(tokenId);
        emit PayoutClaimed(tokenId, ownerOf(tokenId), claimAmount);
    }

    /**
     * @dev Batch claim multiple tokenIds
     * @param _tokenIds Array of token ids to claim
     */
    function claimMany(uint256[] calldata _tokenIds)
        external
        override(IBillNft)
    {
        uint256 length = _tokenIds.length;
        for (uint256 i = 0; i < length; i++) {
            claim(_tokenIds[i]);
        }
    }

    /**
     * @dev Returns the remaining vesting in seconds of the `tokenId` until the vestingEnd timestamp.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function pendingVesting(uint256 tokenId)
        external
        view
        override(IBillNft)
        onlyValidTokenId(tokenId)
        returns (uint256 pendingSeconds)
    {
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        pendingSeconds = bill.pendingVesting(tokenId);
    }

    /**
     * @dev Returns the remaining payout amount of the `tokenId` token 
     *  since last redeem action until the vestingEnd timestamp.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function pendingPayout(uint256 tokenId)
        external
        view
        override(IBillNft)
        onlyValidTokenId(tokenId)
        returns (uint256 pendingPayoutAmount)
    {
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        pendingPayoutAmount = bill.pendingPayout(tokenId);
    }

    /**
     * @dev See {IERC5725-vestedPayout}.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function vestedPayout(uint256 tokenId)
        public
        view
        override(IERC5725)
        onlyValidTokenId(tokenId)
        returns (uint256 payout)
    {
        return vestedPayoutAtTime(tokenId, block.timestamp);
    }

    /**
     * @dev See {IERC5725-vestedPayoutAtTime}.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function vestedPayoutAtTime(uint256 tokenId, uint256 timestamp)
        public
        view
        override(IERC5725)
        onlyValidTokenId(tokenId)
        returns (uint256 payout)
    {
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        payout = bill.vestedPayoutAtTime(tokenId, timestamp);
    }

    /**
     * @dev See {IERC5725-vestingPayout}.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function vestingPayout(uint256 tokenId)
        external
        view
        override(IERC5725)
        onlyValidTokenId(tokenId)
        returns (uint256 payout)
    {
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        payout = bill.vestingPayout(tokenId);
    }

    /**
     * @dev See {IERC5725-claimablePayout}.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function claimablePayout(uint256 tokenId)
        external
        view
        override(IERC5725)
        onlyValidTokenId(tokenId)
        returns (uint256 payout)
    {
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        payout = bill.claimablePayout(tokenId);
    }

    /**
     * @dev See {IERC5725-vestingPeriod}.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function vestingPeriod(uint256 tokenId)
        external
        view
        override(IERC5725)
        onlyValidTokenId(tokenId)
        returns (uint256 vestingStart, uint256 vestingEnd)
    {
        ICustomBill bill = ICustomBill(billAddresses[tokenId]);
        (vestingStart, vestingEnd) = bill.vestingPeriod(tokenId);
    }

    /**
     * @dev See {IERC5725-payoutToken}.
     *
     * Requirements:
     *
     * - `tokenId` MUST exist.
     */
    function payoutToken(uint256 tokenId)
        external
        view
        override(IERC5725)
        onlyValidTokenId(tokenId)
        returns (address token)
    {
        token = address(ICustomBill(billAddresses[tokenId]).payoutToken());
    }
}