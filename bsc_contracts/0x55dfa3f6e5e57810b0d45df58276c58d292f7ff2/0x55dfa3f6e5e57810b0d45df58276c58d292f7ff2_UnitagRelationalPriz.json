{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n \r\n interface IUnitagRelationRegistry {\r\n    /**\r\n     * @dev Set relationship through operators\r\n     * @param collectionId the id of the collection\r\n     * @param accounts  the accounts to set\r\n     * @param signature the signatures of the accounts\r\n     */\r\n    function setParent(uint256 collectionId, address[] calldata accounts, bytes calldata signature) external;\r\n\r\n    /**\r\n     * @dev check if the account account has ancestor\r\n     * @param collectionId the id of the collection\r\n     * @param account the account to query\r\n     */\r\n    function hasAncestor(uint256 collectionId, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Get direct ancestor of one account(parent)\r\n     * @param collectionId the id of the collection\r\n     * @param account the account to query\r\n     */\r\n    function ancestor(uint256 collectionId, address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Get multi level ancestor of one account\r\n     * @param collectionId the id of the collection\r\n     * @param account the account to query\r\n     * @param level the levels to query\r\n     */\r\n    function ancestors(uint256 collectionId, address account, uint256 level) external view returns (address[] memory _ancestors);\r\n}\r\n\r\n\r\ninterface IUnitagRefParamRegistry {\r\n    /**\r\n     * @dev emit when ref params set\r\n     * @param operator the operator to do the setup\r\n     * @param collectionId the collection to set\r\n     * @return levels the ref percentage of each level\r\n     */\r\n    event RefParamSet(address indexed operator, uint256 collectionId, uint256[] levels);\r\n\r\n    /**\r\n     * @dev get the ref params of a collection\r\n     * @param collectionId  the collection to query\r\n     * @param maxLevels maximum levels to query\r\n     * @return levels the ref percentage of each level\r\n     */\r\n    function refParams(uint256 collectionId, uint256 maxLevels) external view returns (uint256[] memory levels);\r\n    \r\n    /**\r\n     * @dev set the ref params of a collection\r\n     * @param collectionId  the collection to set\r\n     * @param levels the ref percentage of each level, maxium 16 levels\r\n     */\r\n    function setRefParams(uint256 collectionId, uint256[] memory levels) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n}\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n/// @title Multicall interface\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\ninterface IMulticall {\r\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\r\n    /// @param data The encoded function data for each of the calls to make to this contract\r\n    /// @return results The results from each of the calls passed in via data\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\r\n}\r\n\r\n\r\n/// @title Multicall\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall is IMulticall {\r\n    /// @inheritdoc IMulticall\r\n    function multicall(bytes[] calldata data) public override returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\r\n                if (result.length < 68) revert();\r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                revert(abi.decode(result, (string)));\r\n            } \r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\ncontract UnitagRelationalPrizeDispatcherV2 is Multicall {\r\n    event Dispatch(address indexed recipient, address payToken, uint256 amount);\r\n    event RefParamSet(address indexed operator, uint256 collectionId, uint256 feePercentage, uint256 level1, uint256 level2);\r\n    event Referral(address indexed source, address indexed recipient, uint256 level, address payToken, uint256 amount);\r\n    event Sweep(address indexed operator, address indexed recipient, address token, uint256 amount);\r\n\r\n    uint256 public constant PERCENTAGE_BASE = 10000;\r\n    address private constant zeroAddress = address(0x0);\r\n\r\n    mapping(uint256 => uint256) internal _collectionRefParam; // collectionId=>fee\r\n\r\n    IUnitagSimple public immutable unitag;\r\n    IUnitagRelationRegistry public immutable relationRegistry;\r\n    IUnitagRefParamRegistry public immutable refParamRegistry;\r\n    IWETH9 public immutable weth9;\r\n\r\n    constructor(address unitag_, address relationRegistry_, address refParamRegistry_, address weth9_) {\r\n        unitag = IUnitagSimple(unitag_);\r\n        weth9 = IWETH9(weth9_);\r\n        relationRegistry = IUnitagRelationRegistry(relationRegistry_);\r\n        refParamRegistry = IUnitagRefParamRegistry(refParamRegistry_);\r\n    }\r\n\r\n    /**\r\n     * @param collectionId the id of the collection\r\n     * @param accounts  the accounts to set\r\n     * @param signature the signatures of the accounts\r\n     */\r\n    function setParent(uint256 collectionId, address[] calldata accounts, bytes calldata signature) public {\r\n        relationRegistry.setParent(collectionId, accounts, signature);\r\n    }\r\n\r\n    function dispatch(string calldata collectionName, address recipient, address payToken, uint256 value) public {\r\n        (uint256 collectionId, , , ) = unitag.collectionByName(collectionName);\r\n        dispatch(collectionId, recipient, payToken, value);\r\n    }\r\n\r\n    function dispatch(uint256 collectionId, address recipient, address payToken, uint256 value) public {\r\n        (address[] memory accounts, uint256[] memory levels) = calculateTransfers(collectionId, recipient);\r\n        for (uint256 idxAccount = 0; idxAccount < accounts.length; ++idxAccount) {\r\n            uint256 outAmount = (value * levels[idxAccount]) / PERCENTAGE_BASE;\r\n            TransferHelper.safeTransfer(payToken, accounts[idxAccount], outAmount);\r\n            if (idxAccount == 0) emit Dispatch(recipient, payToken, outAmount);\r\n            else emit Referral(recipient, accounts[idxAccount], idxAccount, payToken, outAmount);\r\n        }\r\n    }\r\n\r\n    function dispatchBatch(uint256 collectionId, address recipient, address[] calldata payTokens, uint256[] calldata values) public {\r\n        require(payTokens.length == values.length, \"UnitagRelationalPrizeDispatcher: payTokens length != values length\");\r\n        (address[] memory accounts, uint256[] memory levels) = calculateTransfers(collectionId, recipient);\r\n        uint256 accountLength = accounts.length;\r\n        uint256 payTokensLength = payTokens.length;\r\n        for (uint256 idxToken = 0; idxToken < payTokensLength; ++idxToken) {\r\n            address payToken = payTokens[idxToken];\r\n            for (uint256 idxAccount = 0; idxAccount < accountLength; ++idxAccount) {\r\n                uint256 outAmount = (values[idxToken] * levels[idxAccount]) / PERCENTAGE_BASE;\r\n                TransferHelper.safeTransfer(payToken, accounts[idxAccount], outAmount);\r\n                if (idxAccount == 0) emit Dispatch(recipient, payToken, outAmount);\r\n                else emit Referral(recipient, accounts[idxAccount], idxAccount, payToken, outAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function dispatchFrom(string calldata collectionName, address spender, address recipient, address payToken, uint256 value) public {\r\n        (uint256 collectionId, , , ) = unitag.collectionByName(collectionName);\r\n        dispatchFrom(collectionId, spender, recipient, payToken, value);\r\n    }\r\n\r\n    function dispatchFrom(uint256 collectionId, address spender, address recipient, address payToken, uint256 value) public {\r\n        (address[] memory accounts, uint256[] memory levels) = calculateTransfers(collectionId, recipient);\r\n        for (uint256 idxAccount = 0; idxAccount < accounts.length; ++idxAccount) {\r\n            uint256 outAmount = (value * levels[idxAccount]) / PERCENTAGE_BASE;\r\n            TransferHelper.safeTransferFrom(payToken, spender, accounts[idxAccount], outAmount);\r\n            if (idxAccount == 0) emit Dispatch(recipient, payToken, outAmount);\r\n            else emit Referral(recipient, accounts[idxAccount], idxAccount, payToken, outAmount);\r\n        }\r\n    }\r\n\r\n    function dispatchFromBatch(uint256 collectionId, address spender, address recipient, address[] calldata payTokens, uint256[] calldata values) public {\r\n        require(payTokens.length == values.length, \"UnitagRelationalPrizeDispatcher: payTokens length != values length\");\r\n        (address[] memory accounts, uint256[] memory levels) = calculateTransfers(collectionId, recipient);\r\n        uint256 accountLength = accounts.length;\r\n        uint256 payTokensLength = payTokens.length;\r\n        for (uint256 idxToken = 0; idxToken < payTokensLength; ++idxToken) {\r\n            address payToken = payTokens[idxToken];\r\n            for (uint256 idxAccount = 0; idxAccount < accountLength; ++idxAccount) {\r\n                uint256 outAmount = (values[idxToken] * levels[idxAccount]) / PERCENTAGE_BASE;\r\n                TransferHelper.safeTransferFrom(payToken, spender, accounts[idxAccount], outAmount);\r\n                if (idxAccount == 0) emit Dispatch(recipient, payToken, outAmount);\r\n                else emit Referral(recipient, accounts[idxAccount], idxAccount, payToken, outAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateTransfers(uint256 collectionId, address recipient) public view returns (address[] memory accounts, uint256[] memory levels) {\r\n        accounts = new address[](3);\r\n        levels = new uint256[](3);\r\n        accounts[0] = recipient;\r\n        levels[0] = PERCENTAGE_BASE;\r\n        uint256[] memory refLevels = refParamRegistry.refParams(collectionId, 2);\r\n        {\r\n            address[] memory ancestors = relationRegistry.ancestors(collectionId, recipient, 2);\r\n            uint256 index = 0;\r\n            unchecked {\r\n                for (; index < ancestors.length; ) {\r\n                    address ancestor = ancestors[index];\r\n                    uint256 level = refLevels[index];\r\n                    if (ancestor != zeroAddress) {\r\n                        ++index;\r\n                        levels[0] -= level;\r\n                        levels[index] = level;\r\n                        accounts[index] = ancestor;\r\n                    } else break;\r\n                }\r\n            }\r\n            assembly {\r\n                index := add(index, 1)\r\n                mstore(accounts, index)\r\n                mstore(levels, index)\r\n            }\r\n        }\r\n    }\r\n\r\n    function sweep(address tokenAddress, address recipient) external {\r\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\r\n        if (balance > 0) {\r\n            TransferHelper.safeTransfer(tokenAddress, recipient, balance);\r\n            emit Sweep(msg.sender, recipient, tokenAddress, balance);\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        weth9.deposit{value: msg.value}();\r\n    }\r\n}\r\n\r\ninterface IUnitagSimple {\r\n    function collectionByName(string calldata collectionName) external view returns (uint256 collectionId, address owner, string memory name, string memory uri_);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unitag_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relationRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refParamRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth9_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Dispatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level2\",\"type\":\"uint256\"}],\"name\":\"RefParamSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Referral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sweep\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PERCENTAGE_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"calculateTransfers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"levels\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"dispatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"collectionName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"dispatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"payTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"dispatchBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"dispatchFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"collectionName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"dispatchFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"payTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"dispatchFromBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refParamRegistry\",\"outputs\":[{\"internalType\":\"contract IUnitagRefParamRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relationRegistry\",\"outputs\":[{\"internalType\":\"contract IUnitagRelationRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"setParent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unitag\",\"outputs\":[{\"internalType\":\"contract IUnitagSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth9\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UnitagRelationalPrizeDispatcherV2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000002e22b5cabfd8cd25e620c49863dae687877e93e20000000000000000000000008cf18f50cd3335fb9ee235d6d70b9548598219c500000000000000000000000059127d0229d56d47b297e5f83284c3ea67cc3922000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cf38ca3fe3aaa302540505fa7415bc69d9a75a63aabf36a39fc2db3537e7e892"}