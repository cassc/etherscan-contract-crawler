{"SourceCode": "//Original token: https://bscscan.com/address/0x1d9397551d053f4798b2dd8c5bd609fe13f61aab\r\n//Audit: https://github.com/AuditRateTech/Smart-Contract-Audits/blob/main/FlokiGainz_0x1D9397551d053F4798b2DD8C5bd609fE13F61aAb.pdf\r\n//Amendments: PCS router updated from 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F to 0x10ED43C718714eb63d5aA57B78B54704E256024E  \r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity =0.8.11;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function burn(uint256 amount) external returns (bool);\r\n    function burnFrom(address account, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface UNIV2Sync {\r\n    function sync() external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n    function factory() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function balanceOf(address _owner) external returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function withdraw(uint256 _amount) external;\r\n}\r\n\r\n\r\nlibrary SafeMath { // Not needed since 0.8 but keeping for backwards compatibility\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _teamWallet;\r\n    address private _lotteryWallet;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event LotteryWalletTransferred(address indexed previousLotteryWallet, address indexed newLotteryWallet);\r\n\r\n    constructor ()  {\r\n        address msgSender = _msgSender();\r\n        _teamWallet = msgSender;\r\n        _lotteryWallet = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n        emit LotteryWalletTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _teamWallet;\r\n    }\r\n\r\n    function teamWallet() public view returns (address) {\r\n        return _teamWallet;\r\n    }\r\n\r\n    function lotteryWallet() public view returns (address) {\r\n        return _lotteryWallet;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_teamWallet == _msgSender(), \"Ownable: caller is not the owner or team wallet\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newTeamWallet) public virtual onlyOwner {\r\n\t\t//don't allow burning except 0xdead\r\n        require(newTeamWallet != address(0), \"Ownable: new teamWallet is the zero address\");\r\n        emit OwnershipTransferred(_teamWallet, newTeamWallet);\r\n        _teamWallet = newTeamWallet;\r\n    }\r\n\r\n    function setLotteryWallet(address newLotteryWallet) public virtual onlyOwner {\r\n\t\t//don't allow burning except 0xdead\r\n        require(newLotteryWallet != address(0), \"Ownable: new lotteryWallet is the zero address\");\r\n        emit LotteryWalletTransferred(_lotteryWallet, newLotteryWallet);\r\n        _lotteryWallet = newLotteryWallet;\r\n    }\r\n\r\n}\r\n\r\n\r\n/*\r\n * An {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract DeflationaryERC20 is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool) private _isExcludedFromFee;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    // Transaction Fees\r\n    uint8 public txFeeBot = 50; // is one-time launch anti-sniper fee, collected tokens will go unsold to _teamWallet\r\n    uint8 public txFeeTeam = 6; // to _teamWallet for marketing purposes\r\n    uint8 public txFeeLottery = 4; // to _lotteryWallet for draws\r\n    uint8 public txFeeLimit = 10; // used as a limit when changing any particular fee\r\n\tbool public txFreeBuys = false; // transactions from the pool are feeless\r\n    address public uniswapPair; \r\n\taddress public uniswapV2RouterAddr;\r\n\taddress public uniswapV2wETHAddr;\r\n    bool private inSwapAndLiquify;\r\n    event Log (string action); \r\n    \r\n    constructor (string memory __name, string memory __symbol, uint8 __decimals)  {\r\n        _name = __name;\r\n        _symbol = __symbol;\r\n        _decimals = __decimals;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[msg.sender] = true; //disable for testing fees, enable in production for feeless liquidity add\r\n  \t\tuniswapV2RouterAddr = (getChainID() == 56 ? 0x10ED43C718714eb63d5aA57B78B54704E256024E : 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // BSC mainnet  = 56, else ETH \r\n        _isExcludedFromFee[uniswapV2RouterAddr] = true; //this will make liquidity removals less expensive\r\n\t\tuniswapV2wETHAddr = IUniswapV2Router(uniswapV2RouterAddr).WETH(); \r\n        uniswapPair = IUniswapV2Factory(IUniswapV2Router(uniswapV2RouterAddr).factory())\r\n            .createPair(address(this), uniswapV2wETHAddr);\r\n    }\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n\tfunction getChainID() public view returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n        id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n    // to caclulate the amounts for pool and collector after fees have been applied\r\n    function calculateAmountsAfterFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public view returns (uint256 transferToAmount, uint256 transferToTeamAmount, uint256 transferToLotteryAmount, bool p2p) {\r\n        // check if fees should apply to this transaction\r\n\t\tuint256 feeBot = amount.mul(txFeeBot).div(100); //50% then 0%\r\n\t\tuint256 feeTeam = amount.mul(txFeeTeam).div(100); //6%\r\n\t\tuint256 feeLottery = amount.mul(txFeeLottery).div(100); //4%\r\n\r\n        // calculate liquidity fees and amounts if any address is an active contract\r\n        if (sender.isContract() || recipient.isContract()) {\r\n\t\t\treturn (amount.sub(feeBot).sub(feeTeam).sub(feeLottery), feeBot.add(feeTeam),feeLottery,false);\r\n        } else { // p2p \r\n\t\t\treturn (amount, 0, 0, true);\t\t\t\r\n\t\t}\r\n    }\r\n\r\n    function burnFrom(address account,uint256 amount) external override returns (bool) {\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n        _burn(account, amount);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 amount) external override returns (bool) {\r\n        _burn(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal  {\r\n        if (amount == 0)\r\n            return;\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount >= 100, \"amount below 100 base units, avoiding underflows\");\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\t\tif (inSwapAndLiquify || isExcludedFromFee(sender) || isExcludedFromFee(recipient) || uniswapPair == address(0) || uniswapV2RouterAddr == address(0) || (txFreeBuys == true && sender == uniswapPair)) //feeless transfer before pool initialization and in liquify swap\r\n\t\t{\t//send full amount\r\n\t\t\tupdateBalances(sender, recipient, amount);\r\n\t\t} else { \r\n            // calculate fees:\r\n            (uint256 transferToAmount, uint256 transferToTeamAmount, uint256 transferToLotteryAmount, bool p2p) = calculateAmountsAfterFee(sender, recipient, amount);\r\n\t\t\t// 1: subtract net amount, keep amount for further fees to be subtracted later\r\n\t\t\tupdateBalances(sender, address(this), transferToTeamAmount.add(transferToLotteryAmount));\r\n\t\t\t//any sell/liquify must occur before main transfer, but avoid that on buys or liquidity removals\r\n\t\t\tif (sender != uniswapPair && sender != uniswapV2RouterAddr) // without this buying or removing liquidity to eth fails\r\n\t\t\t    swapBufferTokens();\r\n\t\t\t// 1: subtract net amount, keep amount for further fees to be subtracted later\r\n\t\t\tupdateBalances(sender, recipient, transferToAmount);\r\n        }\r\n    }\r\n\r\n    function batchTransfer(address payable[] calldata addrs, uint256[] calldata amounts) external returns(bool) {\r\n        require(amounts.length == addrs.length,\"amounts different length from addrs\");\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            _transfer(_msgSender(), addrs[i], amounts[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function batchTransferFrom(address payable[] calldata addrsFrom, address payable[] calldata addrsTo, uint256[] calldata amounts) external returns(bool) {\r\n        address _currentOwner = _msgSender();\r\n        require(addrsFrom.length == addrsTo.length,\"addrsFrom different length from addrsTo\");\r\n        require(amounts.length == addrsTo.length,\"amounts different length from addrsTo\");\r\n        for (uint256 i = 0; i < addrsFrom.length; i++) {\r\n           _currentOwner = addrsFrom[i];\r\n           if (_currentOwner != _msgSender()) {\r\n               _approve(_currentOwner, _msgSender(), _allowances[_currentOwner][_msgSender()].sub(amounts[i], \"ERC20: some transfer amount in batchTransferFrom exceeds allowance\"));\r\n           }\r\n           _transfer(_currentOwner, addrsTo[i], amounts[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //Allow excluding from fee certain contracts, usually lock or payment contracts, but not the pool.\r\n    function excludeFromFee(address account) public onlyOwner {\r\n        require(account != uniswapPair, 'Cannot exclude Uniswap pair');\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n    // Do not include back this contract.\r\n    function includeInFee(address account) public onlyOwner {\r\n        require(account != address(this),'Cannot enable fees to the token contract itself');\r\n        _isExcludedFromFee[account] = false;\r\n    }\r\n    \r\n    function isExcludedFromFee(address account) public view returns(bool) {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n    \r\n    function swapBufferTokens() private {\r\n \t\tif (inSwapAndLiquify) // prevent reentrancy\r\n\t\t\treturn;\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\t\tif (contractTokenBalance <= _totalSupply.div(1e9)) //only swap reasonable amounts\r\n\t\t\treturn;\r\n\t\tif (contractTokenBalance <= 100) //do not swap too small amounts\r\n\t\t\treturn;\r\n        // swap tokens for ETH to the contract\r\n        if (txFeeBot > txFeeLimit)\r\n        {\r\n            updateBalances(address(this), teamWallet(), contractTokenBalance);\r\n        }\r\n        else\r\n        {\r\n            inSwapAndLiquify = true;\r\n            swapTokensForEth(contractTokenBalance); // avoid reentrancy here\r\n            inSwapAndLiquify = false;\r\n            uint256 contractETHBalance = address(this).balance;\r\n            uint256 half = contractETHBalance.div(txFeeTeam+txFeeLottery).mul(txFeeTeam);\r\n            uint256 otherHalf = contractETHBalance.sub(half);\r\n            payable(teamWallet()).transfer(half);\r\n            payable(lotteryWallet()).transfer(otherHalf);\r\n        }\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2wETHAddr;\r\n\r\n        _approve(address(this), uniswapV2RouterAddr, tokenAmount);\r\n\r\n        // make the swap but never fail\r\n        try IUniswapV2Router(uniswapV2RouterAddr).swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        )  {}\r\n        catch Error(string memory reason) {emit Log(reason);}\r\n\r\n    }\r\n\r\n\tfunction updateBalances(address _from, address _to, uint256 _amount) internal {\r\n\t\t// do nothing on self transfers and zero transfers\r\n\t\tif (_from != _to && _amount > 0) {\r\n\t\t\t_balances[_from] = _balances[_from].sub(_amount, \"ERC20: transfer amount exceeds balance\");\r\n\t\t\t_balances[_to] = _balances[_to].add(_amount);\r\n\t\t\temit Transfer(_from, _to, _amount);\r\n\t\t}\r\n\t}\r\n\r\n    function setTxTeamFeePercent(uint8 _txFeeTeam) external onlyOwner() {\r\n\t\trequire(_txFeeTeam <= txFeeLimit,'txFeeTeam above limit');\r\n        txFeeTeam = _txFeeTeam;\r\n    }\r\n\r\n    function setTxLotteryFeePercent(uint8 _txFeeLottery) external onlyOwner() {\r\n\t\trequire(_txFeeLottery <= txFeeLimit,'txFeeLottery above limit');\r\n        txFeeLottery = _txFeeLottery;\r\n    }\r\n\r\n    function setTxFeeBotFeePercent(uint8 _txFeeBot) external onlyOwner() {\r\n\t\trequire(_txFeeBot == 0,'txFeeBot above zero');\r\n        swapBufferTokens();\r\n        txFeeBot = _txFeeBot;\r\n    }\r\n\r\n    function setTxFreeBuys(bool _txFreeBuys) external onlyOwner() {\r\n        txFreeBuys = _txFreeBuys;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(_totalSupply == 0, \"Mint: Not an initial supply mint\");\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        if(amount != 0) {\r\n            _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n            _totalSupply = _totalSupply.sub(amount);\r\n            emit Transfer(account, address(0), amount);\r\n        }\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * Hook that is called before any transfer of tokens. This includes minting and burning.\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    //sennding ether to this contract will succeed and the ether will later move to the collector\r\n    receive() external payable {\r\n       //revert();\r\n    }\r\n    function transferAnyTokens(address _tokenAddr, address _to, uint _amount) external onlyOwner {\r\n\t\t//the owner takes it anyway, sold or unsold\r\n        //require(_tokenAddr != address(this), \"Cannot transfer out from sell/liquify queue!\");\r\n        IERC20(_tokenAddr).transfer(_to, _amount);\r\n        uint256 amountETH = address(this).balance;\r\n        if (amountETH > 0) {\r\n            IWETH(uniswapV2wETHAddr).deposit{value : amountETH}();\r\n\t\t\t//send weth to collector, this is to avoid reverts if collector is a contract\r\n            IWETH(uniswapV2wETHAddr).transfer(owner(), amountETH);\r\n        }\r\n    }\r\n}\r\n\r\ncontract FlokiGainzToken is DeflationaryERC20 {\r\n    constructor()  DeflationaryERC20(\"FlokiGainz\", \"GAINZ\", 6) {\r\n        // maximum supply   = 500m with decimals = 6\r\n        _mint(msg.sender, 500e12);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousLotteryWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLotteryWallet\",\"type\":\"address\"}],\"name\":\"LotteryWalletTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"addrsFrom\",\"type\":\"address[]\"},{\"internalType\":\"address payable[]\",\"name\":\"addrsTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateAmountsAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transferToAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferToTeamAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferToLotteryAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"p2p\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLotteryWallet\",\"type\":\"address\"}],\"name\":\"setLotteryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_txFeeBot\",\"type\":\"uint8\"}],\"name\":\"setTxFeeBotFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_txFreeBuys\",\"type\":\"bool\"}],\"name\":\"setTxFreeBuys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_txFeeLottery\",\"type\":\"uint8\"}],\"name\":\"setTxLotteryFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_txFeeTeam\",\"type\":\"uint8\"}],\"name\":\"setTxTeamFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTeamWallet\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txFeeBot\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txFeeLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txFeeLottery\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txFeeTeam\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txFreeBuys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2RouterAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2wETHAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FlokiGainzToken", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9d6975390e6aa53d0c12a9dc841babdc5d5ffec49620c1759c0bc02bfb94c280"}