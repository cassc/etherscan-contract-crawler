{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Jay-Desktop-02282021/BSC-Mainnet/ApeTroop/Production/6262021/contracts/ApeTroop.sol\": {\r\n      \"content\": \"/**\\n                                                                                                                   \u2593\u2592\u2593\u2593\u2593\u2593\u2593\u2592\u2591\u2592\u2593\u2592\u2592\u2593\u2592\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2592                    \\n                                                                                                                \u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591           \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2593                 \\n                                                                                                              \u2593\u2593\u2593\u2593\u2593\u2592              \u2592\u2593\u2593\u2593\u2592     \u2592\u2593\u2593\u2593\u2593\u2592               \\n                                                                                                             \u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592           \u2591\u2593\u2593\u2593\u2593\u2591        \u2592\u2593\u2593\u2593\u2593\u2592             \\n                                                                                                           \u2591\u2593\u2593\u2593\u2592 \u2593\u2593\u2593\u2593\u2593\u2593\u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2592\u2593\u2593\u2593\u2593\u2593             \u2593\u2593\u2593\u2593\u2593           \\n                                                                                                          \u2591\u2593\u2593\u2593\u2593     \u2592\u2592\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591                \u2593\u2593\u2593\u2593\u2592          \\n                                                                                                          \u2592\u2593\u2593\u2593                                 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591         \\n         \u2593\u2593                                                \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593    \u2593             \u2593\u2593\u2593\u2592                     \u2593\u2592\u2593          \u2592\u2593\u2593\u2593\u2592\u2593\u2593\u2593\u2593\u2593        \\n        \u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593      \u2593\u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593     \u2593\u2593\u2593        \u2593\u2593\u2593        \u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593\u2593   \u2592\u2593\u2593\u2592               \u2592    \u2592\u2593\u2593\u2592          \u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593        \\n         \u2593\u2593\u2593   \u2593\u2593\u2593   \u2593\u2593\u2593    \u2593\u2593\u2593   \u2593\u2593\u2593    \u2593\u2593\u2593    \u2593\u2593\u2593        \u2593\u2593\u2593           \u2593\u2593\u2593         \u2593\u2593\u2593   \u2593\u2593\u2593    \u2593\u2593\u2593    \u2592\u2593\u2593\u2593              \u2593\u2593\u2593\u2593\u2593\u2592\u2593\u2593\u2593             \u2591\u2592\u2593\u2591 \u2591\u2593\u2593\u2592       \\n         \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593    \u2593\u2593\u2593   \u2593\u2593\u2593        \u2593\u2593\u2593        \u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593     \u2592\u2593\u2593\u2592    \u2593\u2592\u2593\u2592\u2593       \u2592\u2593\u2593\u2593\u2593\u2593\u2593                  \u2593\u2593\u2593\u2591       \\n         \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593     \u2593\u2593\u2593  \u2593\u2593\u2593        \u2593\u2593\u2593           \u2593\u2593\u2593         \u2593\u2593\u2593   \u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2592  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592     \u2593\u2593\u2593\u2593\u2591\u2593\u2593\u2593\u2593\u2591               \u2592\u2593\u2593\u2591       \\n     \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593      \u2593\u2593\u2593\u2593\u2593\u2593\u2593        \u2593\u2593\u2593           \u2593\u2593\u2593      \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593 \u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591   \u2592\u2593\u2593    \u2592\u2593\u2593\u2593\u2593  \u2592\u2592\u2591     \u2592\u2592\u2592        \u2593\u2593\u2593\u2593       \\n   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593  \u2593\u2593\u2593     \u2593\u2593\u2593     \u2593\u2593\u2593  \u2593\u2593\u2593        \u2593\u2593\u2593           \u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593        \u2592\u2593\u2593\u2593\u2592\u2593\u2593\u2592  \u2593\u2593\u2593\u2593              \u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593   \u2592\u2593\u2593\u2592        \\n  \u2593\u2593\u2593    \u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593      \u2593\u2593\u2593\u2593 \u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593    \u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593          \u2593\u2593\u2593\u2593\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593             \u2593\u2593\u2593\u2593\u2592\u2593    \u2593\u2593\u2593\u2593\u2591 \u2592\u2593\u2593\u2591         \\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593\u2593       \u2593\u2593\u2593\u2593\u2593\u2593        \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593                      \u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593           \u2593\u2593\u2593\u2593\u2591 \u2593\u2593               \u2592\u2593\u2593\u2591         \u2593\u2593\u2593\u2593\u2593\u2593\u2591          \\n                                                                                                              \u2591\u2593\u2593\u2593\u2593               \u2592\u2593\u2593\u2593        \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592           \\n                                                                                                               \u2591\u2592\u2593\u2593\u2593\u2593             \u2592\u2593\u2593\u2593     \u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591            \\n                                                                                                                 \u2591\u2593\u2593\u2593\u2593\u2591\u2593           \u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2593              \\n                                                                                                                    \u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2593\u2591        \u2593\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592                 \\n                                                                                                                       \u2592\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593                    \\n                                                                                                                            \u2591\u2593\u2591\u2592\u2591\u2593\u2593\u2593\u2591\u2592\u2591\u2591\u2591\\n \\nApe Troop - A Community-Powered Platform with a Heart\\nWe're on a moon mission to help save humanity through blockchain-based charity donations generated from every trade of $TROOP.\\n \\nIf you are reading this you are very early to one of the most legit #MEME based projects this side of mars! We are bananas about Ape Troop and you should be too!\\n \\nMISSION: Hit the Moon \\nWhen you HODL $TROOP you choose the charities we support while you earn passively with our reflective staking mechanism. We have also implemented Auto LP + Auto Burn + Charity/Marketing wallet. \\n  \\nROCKET FUEL: How we will hit the moon! \\n- Ape Troop governance portal  \\n- Charity donations \\n- NFT's + NFT Farming \\n- Marketing  \\n- Smart contract Pre-audit by RD Auditors - https://apetroop.io/ape-troop-smart-contract-security-report.pdf\\n- Plus more catalysts to make you #APE\\n \\nTAXES YOU'LL LIKE:\\n- 10% tax on each Buy/Sell transaction split in the following way;\\n- 4% Goes to the autogenerating liquidity pool, which creates a rising floor price.\\n- 3% of each transaction is split amongst all $TROOP holders in the form of static staking. So just HODL $TROOP and earn more automagically!\\n- 2% goes into a Charity/marketing wallet, this ensures we can pay for marketing and donate to charities fulfilling our main purpose to help humanity.\\n- 1% will be burned to a DEAD wallet creating a deflationary supply.\\n \\nIMPORTANT NOTES:\\n- Set slippage to 11% at a minimum\\n- For the first 30-60 minutes of trading anti-whale/anti-dump mechanisms will be implemented to prevent pesky bots from sniping and dumping, within this timeframe wallet to wallet transfers will also be limited\\n \\nSOCIALS:\\n- Website: https://apetroop.io/\\n- Telegram Group: https://t.me/ApeTroop\\n- Telegram Ann: https://t.me/ApeTroopAnn\\n- Twitter: https://twitter.com/ApeTroop\\n \\n*Please note Ape Troop and the native $TROOP token is a #MEME based cryptocurrency created to help build a community and donate to humanity through governance + blockchain, this project is for fun only and should not be considered financial advice, please ensure you understand the risks of buying the $TROOP tokens - DYOR\\n \\nMade with  by Team Ape Troop \\n*/\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\\n}\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked { require(b <= a, errorMessage); return a - b; }\\n    }\\n}\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > 0;}\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, \\\"Address: low-level call failed\\\");}\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");}\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) { return returndata; } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {revert(errorMessage);}\\n        }\\n    }\\n}\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    function getUnlockTime() public view returns (uint256) {\\n        return _lockTime;\\n    }\\n    function lock(uint256 time) public virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _owner = address(0);\\n        _lockTime = block.timestamp + time;\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n    function unlock() public virtual {\\n        require(_previousOwner == msg.sender, \\\"Only the previous owner can unlock onwership\\\");\\n        require(block.timestamp > _lockTime , \\\"The contract is still locked\\\");\\n        emit OwnershipTransferred(_owner, _previousOwner);\\n        _owner = _previousOwner;\\n    }\\n}\\nabstract contract Manageable is Context {\\n    address private _manager;\\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\\n    constructor(){\\n        address msgSender = _msgSender();\\n        _manager = msgSender;\\n        emit ManagementTransferred(address(0), msgSender);\\n    }\\n    function manager() public view returns(address){ return _manager; }\\n    modifier onlyManager(){\\n        require(_manager == _msgSender(), \\\"Manageable: caller is not the manager\\\");\\n        _;\\n    }\\n    function transferManagement(address newManager) external virtual onlyManager {\\n        emit ManagementTransferred(_manager, newManager);\\n        _manager = newManager;\\n    }\\n}\\ninterface IPancakeV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\ninterface IPancakeV2Router {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n \\npragma solidity ^0.8.4;\\n\\nabstract contract Tokenomics is Manageable{\\n    \\n    using SafeMath for uint256;\\n\\n    string internal constant NAME = \\\"ApeTroop\\\";\\n    string internal constant SYMBOL = \\\"TROOP\\\";\\n    \\n    uint16 internal constant FEES_DIVISOR = 10**3;\\n    uint8 internal constant DECIMALS = 6;\\n    uint256 internal constant ZEROES = 10**6;\\n    \\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 internal constant TOTAL_SUPPLY = 1000000000000000 * ZEROES;\\n    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\\n\\n    uint256 internal maxTransactionAmount = TOTAL_SUPPLY / 100;\\n    \\n    uint256 internal maxWalletBalance = TOTAL_SUPPLY / 500;\\n\\n    uint256 internal numberOfTokensToSwapToLiquidity = 1000;\\n\\n    address internal marketingAddress = 0x0589C449d8661B7310e741694688d1EFB7967d35;\\n    address internal burnAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n    enum FeeType { Antiwhale, Burn, Liquidity, Rfi, External, ExternalToETH }\\n    struct Fee {\\n        FeeType name;\\n        uint256 value;\\n        address recipient;\\n        uint256 total;\\n    }\\n\\n    Fee[] internal fees;\\n    uint256 internal sumOfFees;\\n\\n    constructor() {\\n        _addFees();\\n    }\\n\\n    function _addFee(FeeType name, uint256 value, address recipient) private {\\n        fees.push(Fee(name, value, recipient, 0 ));\\n        sumOfFees += value;\\n    }\\n\\n    function _addFees() private {\\n        _addFee(FeeType.Rfi, 30, address(this) ); \\n        _addFee(FeeType.Burn, 10, burnAddress);\\n        _addFee(FeeType.Liquidity, 40, address(this) );\\n        _addFee(FeeType.External, 20, marketingAddress);\\n    }\\n    \\n    function setMaxTransactionAmount(uint256 maxTxPercent) external onlyManager() {\\n        maxTransactionAmount = TOTAL_SUPPLY.mul(maxTxPercent).div(10 ** 3);\\n    }\\n    \\n    function _getFeesCount() internal view returns (uint256){ return fees.length; }\\n\\n    function _getFeeStruct(uint256 index) private view returns(Fee storage){\\n        require( index >= 0 && index < fees.length, \\\"FeesSettings._getFeeStruct: Fee index out of bounds\\\");\\n        return fees[index];\\n    }\\n    function _getFee(uint256 index) internal view returns (FeeType, uint256, address, uint256){\\n        Fee memory fee = _getFeeStruct(index);\\n        return ( fee.name, fee.value, fee.recipient, fee.total );\\n    }\\n    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\\n        Fee storage fee = _getFeeStruct(index);\\n        fee.total = fee.total.add(amount);\\n    }\\n\\n    function getCollectedFeeTotal(uint256 index) internal view returns (uint256){\\n        Fee memory fee = _getFeeStruct(index);\\n        return fee.total;\\n    }\\n}\\n\\nabstract contract Presaleable is Manageable {\\n    bool internal isInPresale;\\n    function setPreseableEnabled(bool value) external onlyManager {\\n        isInPresale = value;\\n    }\\n}\\n\\nabstract contract BaseRfiToken is IERC20, IERC20Metadata, Ownable, Presaleable, Tokenomics {\\n\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) internal _reflectedBalances;\\n    mapping (address => uint256) internal _balances;\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n    \\n    mapping (address => bool) internal _isExcludedFromFee;\\n    mapping (address => bool) internal _isExcludedFromRewards;\\n    address[] private _excluded;\\n    \\n    constructor(){\\n        _reflectedBalances[owner()] = _reflectedSupply;\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n        _exclude(owner());\\n        _exclude(address(this));\\n        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\\n        \\n    }\\n    \\n    function name() external pure override returns (string memory) { return NAME; }\\n    function symbol() external pure override returns (string memory) { return SYMBOL; }\\n    function decimals() external pure override returns (uint8) { return DECIMALS; }\\n    function totalSupply() external pure override returns (uint256) {\\n        return TOTAL_SUPPLY;\\n    }\\n    \\n    function balanceOf(address account) public view override returns (uint256){\\n        if (_isExcludedFromRewards[account]) return _balances[account];\\n        return tokenFromReflection(_reflectedBalances[account]);\\n    }\\n    \\n    function transfer(address recipient, uint256 amount) external override returns (bool){\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n    \\n    function allowance(address owner, address spender) external view override returns (uint256){\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n    \\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function burn(uint256 amount) external onlyManager {\\n        address sender = _msgSender();\\n        require(sender != address(0), \\\"BaseRfiToken: burn from the zero address\\\");\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: burn from the burn address\\\");\\n        uint256 balance = balanceOf(sender);\\n        require(balance >= amount, \\\"BaseRfiToken: burn amount exceeds balance\\\");\\n        uint256 reflectedAmount = amount.mul(_getCurrentRate());\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\\n        if (_isExcludedFromRewards[sender])\\n            _balances[sender] = _balances[sender].sub(amount);\\n        _burnTokens( sender, amount, reflectedAmount );\\n    }\\n    \\n  \\n    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal { \\n        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(rBurn);\\n        if (_isExcludedFromRewards[burnAddress])\\n            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\\n\\n        emit Transfer(sender, burnAddress, tBurn);\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n    \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n    \\n    function isExcludedFromReward(address account) external view returns (bool) {\\n        return _isExcludedFromRewards[account];\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= TOTAL_SUPPLY, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount,,,,) = _getValues(tAmount,0);\\n            return rAmount;\\n        } else {\\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount,_getSumOfFees(_msgSender(), tAmount));\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\\n        require(rAmount <= _reflectedSupply, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate = _getCurrentRate();\\n        return rAmount.div(currentRate);\\n    }\\n    \\n    function excludeFromReward(address account) external onlyOwner() {\\n        require(!_isExcludedFromRewards[account], \\\"Account is not included\\\");\\n        _exclude(account);\\n    }\\n    \\n    function _exclude(address account) internal {\\n        if(_reflectedBalances[account] > 0) {\\n            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\\n        }\\n        _isExcludedFromRewards[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner() {\\n        require(_isExcludedFromRewards[account], \\\"Account is not excluded\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _balances[account] = 0;\\n                _isExcludedFromRewards[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n    \\n    function setExcludedFromFee(address account, bool value) external onlyOwner { _isExcludedFromFee[account] = value; }\\n    function isExcludedFromFee(address account) public view returns(bool) { return _isExcludedFromFee[account]; }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"BaseRfiToken: approve from the zero address\\\");\\n        require(spender != address(0), \\\"BaseRfiToken: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n    \\n    function _isUnlimitedSender(address account) internal view returns(bool){\\n        return (account == owner());\\n    }\\n    \\n    function _isUnlimitedRecipient(address account) internal view returns(bool){\\n        return (account == owner() || account == burnAddress);\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\n        require(sender != address(0), \\\"BaseRfiToken: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BaseRfiToken: transfer to the zero address\\\");\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: transfer from the burn address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        bool takeFee = true;\\n        if ( isInPresale ){ takeFee = false; }\\n        else {\\n            if ( amount > maxTransactionAmount && !_isUnlimitedSender(sender) && !_isUnlimitedRecipient(recipient) ){\\n                revert(\\\"Transfer amount exceeds the maxTxAmount.\\\");\\n            }\\n        }\\n\\n        if(_isV2Pair(sender) || _isV2Pair(recipient)){\\n            takeFee = true;\\n        }else {\\n            takeFee = false;\\n        }\\n\\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){ takeFee = false; }\\n        _beforeTokenTransfer(sender, recipient, amount, takeFee);\\n        _transferTokens(sender, recipient, amount, takeFee);\\n        \\n    }\\n\\n    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\\n        uint256 sumOfFees = _getSumOfFees(sender, amount);\\n        if ( !takeFee ){ sumOfFees = 0; } \\n        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees); \\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\\n        if (_isExcludedFromRewards[sender]){ _balances[sender] = _balances[sender].sub(tAmount); }\\n        if (_isExcludedFromRewards[recipient] ){ _balances[recipient] = _balances[recipient].add(tTransferAmount); }   \\n        _takeFees( amount, currentRate, sumOfFees);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n    \\n    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees) private {\\n        if ( sumOfFees > 0 && !isInPresale){\\n            _takeTransactionFees(amount, currentRate);\\n        }\\n    }\\n    \\n    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {  \\n        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\\n        uint256 tTransferAmount = tAmount.sub(tTotalFees);\\n        uint256 currentRate = _getCurrentRate();\\n        uint256 rAmount = tAmount.mul(currentRate);\\n        uint256 rTotalFees = tTotalFees.mul(currentRate);\\n        uint256 rTransferAmount = rAmount.sub(rTotalFees); \\n        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\\n    }\\n    \\n    function _getCurrentRate() internal view returns(uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply.div(tSupply);\\n    }\\n    \\n    function _getCurrentSupply() internal view returns(uint256, uint256) {\\n        uint256 rSupply = _reflectedSupply;\\n        uint256 tSupply = TOTAL_SUPPLY;  \\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_reflectedBalances[_excluded[i]] > rSupply || _balances[_excluded[i]] > tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\\n            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\\n            tSupply = tSupply.sub(_balances[_excluded[i]]);\\n        }\\n        if (tSupply == 0 || rSupply < _reflectedSupply.div(TOTAL_SUPPLY)) return (_reflectedSupply, TOTAL_SUPPLY);\\n        return (rSupply, tSupply);\\n    }\\n    \\n   \\n    function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal virtual;\\n    \\n    function _getSumOfFees(address sender, uint256 amount) internal view virtual returns (uint256);\\n\\n    function _isV2Pair(address account) internal view virtual returns(bool);\\n\\n    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) internal {\\n        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\\n        uint256 rFee = tFee.mul(currentRate);\\n\\n        _reflectedSupply = _reflectedSupply.sub(rFee);\\n        _addFeeCollectedAmount(index, tFee);\\n    }\\n\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal virtual;\\n}\\n\\nabstract contract Liquifier is Ownable, Manageable {\\n\\n    using SafeMath for uint256;\\n\\n    uint256 private withdrawableBalance;\\n\\n    enum Env {Testnet, MainnetV1, MainnetV2}\\n    Env private _env;\\n    address private _mainnetRouterV1Address = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\\n    address private _mainnetRouterV2Address = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    address private _testnetRouterAddress = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\\n\\n    IPancakeV2Router internal _router;\\n    address internal _pair;\\n    \\n    bool private inSwapAndLiquify;\\n    bool private swapAndLiquifyEnabled = true;\\n\\n    uint256 private maxTransactionAmount;\\n    uint256 private numberOfTokensToSwapToLiquidity;\\n\\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    event RouterSet(address indexed router);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event LiquidityAdded(uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity);\\n\\n    receive() external payable {}\\n\\n    function initializeLiquiditySwapper(Env env, uint256 maxTx, uint256 liquifyAmount) internal {\\n        _env = env;\\n        if (_env == Env.MainnetV1){ _setRouterAddress(_mainnetRouterV1Address); }\\n        else if (_env == Env.MainnetV2){ _setRouterAddress(_mainnetRouterV2Address); }\\n        else /*(_env == Env.Testnet)*/{ _setRouterAddress(_testnetRouterAddress); }\\n        maxTransactionAmount = maxTx;\\n        numberOfTokensToSwapToLiquidity = liquifyAmount;\\n\\n    }\\n\\n    function liquify(uint256 contractTokenBalance, address sender) internal {\\n        if (contractTokenBalance >= maxTransactionAmount) contractTokenBalance = maxTransactionAmount;     \\n        bool isOverRequiredTokenBalance = ( contractTokenBalance >= numberOfTokensToSwapToLiquidity );\\n        if ( isOverRequiredTokenBalance && swapAndLiquifyEnabled && !inSwapAndLiquify && (sender != _pair) ){\\n            _swapAndLiquify(contractTokenBalance);            \\n        }\\n    }\\n\\n\\n    function _setRouterAddress(address router) private {\\n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(router);\\n        _pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(address(this), _newPancakeRouter.WETH());\\n        _router = _newPancakeRouter;\\n        emit RouterSet(router);\\n    }\\n    \\n    function _swapAndLiquify(uint256 amount) private lockTheSwap {\\n        uint256 half = amount.div(2);\\n        uint256 otherHalf = amount.sub(half);\\n        uint256 initialBalance = address(this).balance;\\n        _swapTokensForEth(half); \\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\n        _addLiquidity(otherHalf, newBalance);\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n    \\n    function _swapTokensForEth(uint256 tokenAmount) private { \\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _router.WETH();\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) = _router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0,\\n            0,\\n            owner(),\\n            block.timestamp\\n        );\\n        withdrawableBalance = address(this).balance;\\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\\n    }\\n\\n    function setRouterAddress(address router) external onlyManager() {\\n        _setRouterAddress(router);\\n    }\\n\\n\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyManager {\\n        swapAndLiquifyEnabled = enabled;\\n        emit SwapAndLiquifyEnabledUpdated(swapAndLiquifyEnabled);\\n    }\\n\\n    \\n    function withdrawLockedEth(address payable recipient) external onlyManager(){\\n        require(recipient != address(0), \\\"Cannot withdraw the ETH balance to the zero address\\\");\\n        require(withdrawableBalance > 0, \\\"The ETH balance must be greater than 0\\\");\\n        uint256 amount = withdrawableBalance;\\n        withdrawableBalance = 0;\\n        recipient.transfer(amount);\\n    }\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal virtual;\\n}\\n\\n\\nabstract contract Antiwhale is Tokenomics {\\n\\n    function _getAntiwhaleFees(uint256, uint256) internal view returns (uint256){\\n        return sumOfFees;\\n    }\\n}\\n\\nabstract contract SafeToken is BaseRfiToken, Liquifier, Antiwhale {\\n    \\n    using SafeMath for uint256;\\n\\n    constructor(Env _env){\\n        initializeLiquiditySwapper(_env, maxTransactionAmount, numberOfTokensToSwapToLiquidity);\\n        _exclude(_pair);\\n        _exclude(burnAddress);\\n    }\\n    \\n    function _isV2Pair(address account) internal view override returns(bool){\\n        return (account == _pair);\\n    }\\n\\n    function _getSumOfFees(address sender, uint256 amount) internal view override returns (uint256){ \\n        return _getAntiwhaleFees(balanceOf(sender), amount); \\n    }\\n    \\n   \\n    function _beforeTokenTransfer(address sender, address , uint256 , bool ) internal override {\\n        if ( !isInPresale ){\\n            uint256 contractTokenBalance = balanceOf(address(this));\\n            liquify( contractTokenBalance, sender );\\n        }\\n    }\\n\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal override {\\n       if( isInPresale ){ return; }\\n       uint256 feesCount = _getFeesCount();\\n        for (uint256 index = 0; index < feesCount; index++ ){\\n            (FeeType name, uint256 value, address recipient,) = _getFee(index);     \\n            if ( value == 0 ) continue;\\n            if ( name == FeeType.Rfi ){\\n                _redistribute( amount, currentRate, value, index );\\n            }\\n            else if ( name == FeeType.Burn ){\\n                _burn( amount, currentRate, value, index );\\n            }\\n            else if ( name == FeeType.Antiwhale){\\n            }\\n            else if ( name == FeeType.ExternalToETH){\\n                _takeFeeToETH( amount, currentRate, value, recipient, index );\\n            }\\n            else {\\n                _takeFee( amount, currentRate, value, recipient, index );\\n            }\\n        }\\n    }\\n\\n    function _burn(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) private {\\n        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\\n        uint256 rBurn = tBurn.mul(currentRate);\\n\\n        _burnTokens(address(this), tBurn, rBurn);\\n        _addFeeCollectedAmount(index, tBurn);\\n    }\\n\\n    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\n        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\\n        uint256 rAmount = tAmount.mul(currentRate);\\n       _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\\n        if(_isExcludedFromRewards[recipient])\\n            _balances[recipient] = _balances[recipient].add(tAmount);\\n       _addFeeCollectedAmount(index, tAmount);\\n    }\\n    \\n    function _takeFeeToETH(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\n        _takeFee(amount, currentRate, fee, recipient, index);        \\n    }\\n\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal override {\\n        _approve(owner, spender, amount);\\n    }\\n}\\n\\ncontract ApeTroop is SafeToken{\\n\\n    constructor() SafeToken(Env.MainnetV2){\\n        _approve(owner(),address(_router), ~uint256(0));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"RouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPreseableEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawLockedEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ApeTroop", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}