{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n    /*\r\n     * Minimum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n     * Maximum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromInt(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(x << 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n     * rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64-bit integer number\r\n     */\r\n    function toInt(int128 x) internal pure returns (int64) {\r\n        unchecked {\r\n            return int64(x >> 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromUInt(uint256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(int256(x << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return unsigned 64-bit integer number\r\n     */\r\n    function toUInt(int128 x) internal pure returns (uint64) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return uint64(uint128(x >> 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n     * number rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 128.128-bin fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function from128x128(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = x >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n     * number.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 128.128 fixed point number\r\n     */\r\n    function to128x128(int128 x) internal pure returns (int256) {\r\n        unchecked {\r\n            return int256(x) << 64;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function add(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) + y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x - y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sub(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) - y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function mul(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = (int256(x) * y) >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n     * number and y is signed 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 256-bit integer number\r\n     */\r\n    function muli(int128 x, int256 y) internal pure returns (int256) {\r\n        unchecked {\r\n            if (x == MIN_64x64) {\r\n                require(\r\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n                        y <= 0x1000000000000000000000000000000000000000000000000\r\n                );\r\n                return -y << 63;\r\n            } else {\r\n                bool negativeResult = false;\r\n                if (x < 0) {\r\n                    x = -x;\r\n                    negativeResult = true;\r\n                }\r\n                if (y < 0) {\r\n                    y = -y; // We rely on overflow behavior here\r\n                    negativeResult = !negativeResult;\r\n                }\r\n                uint256 absoluteResult = mulu(x, uint256(y));\r\n                if (negativeResult) {\r\n                    require(\r\n                        absoluteResult <=\r\n                            0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    );\r\n                    return -int256(absoluteResult); // We rely on overflow behavior here\r\n                } else {\r\n                    require(\r\n                        absoluteResult <=\r\n                            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                    );\r\n                    return int256(absoluteResult);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 256-bit integer number\r\n     */\r\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\r\n        unchecked {\r\n            if (y == 0) return 0;\r\n\r\n            require(x >= 0);\r\n\r\n            uint256 lo = (uint256(int256(x)) *\r\n                (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n            uint256 hi = uint256(int256(x)) * (y >> 128);\r\n\r\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            hi <<= 64;\r\n\r\n            require(\r\n                hi <=\r\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF -\r\n                        lo\r\n            );\r\n            return hi + lo;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function div(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            int256 result = (int256(x) << 64) / y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divi(int256 x, int256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            bool negativeResult = false;\r\n            if (x < 0) {\r\n                x = -x; // We rely on overflow behavior here\r\n                negativeResult = true;\r\n            }\r\n            if (y < 0) {\r\n                y = -y; // We rely on overflow behavior here\r\n                negativeResult = !negativeResult;\r\n            }\r\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\r\n            if (negativeResult) {\r\n                require(absoluteResult <= 0x80000000000000000000000000000000);\r\n                return -int128(absoluteResult); // We rely on overflow behavior here\r\n            } else {\r\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                return int128(absoluteResult); // We rely on overflow behavior here\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            uint128 result = divuu(x, y);\r\n            require(result <= uint128(MAX_64x64));\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate -x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function neg(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return -x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate |x|.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function abs(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return x < 0 ? -x : x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function inv(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != 0);\r\n            int256 result = int256(0x100000000000000000000000000000000) / x;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function avg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            return int128((int256(x) + int256(y)) >> 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n     * Revert on overflow or in case x * y is negative.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 m = int256(x) * int256(y);\r\n            require(m >= 0);\r\n            require(\r\n                m <\r\n                    0x4000000000000000000000000000000000000000000000000000000000000000\r\n            );\r\n            return int128(sqrtu(uint256(m)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y uint256 value\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            bool negative = x < 0 && y & 1 == 1;\r\n\r\n            uint256 absX = uint128(x < 0 ? -x : x);\r\n            uint256 absResult;\r\n            absResult = 0x100000000000000000000000000000000;\r\n\r\n            if (absX <= 0x10000000000000000) {\r\n                absX <<= 63;\r\n                while (y != 0) {\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x2 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x4 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x8 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    y >>= 4;\r\n                }\r\n\r\n                absResult >>= 64;\r\n            } else {\r\n                uint256 absXShift = 63;\r\n                if (absX < 0x1000000000000000000000000) {\r\n                    absX <<= 32;\r\n                    absXShift -= 32;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000) {\r\n                    absX <<= 16;\r\n                    absXShift -= 16;\r\n                }\r\n                if (absX < 0x1000000000000000000000000000000) {\r\n                    absX <<= 8;\r\n                    absXShift -= 8;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000000) {\r\n                    absX <<= 4;\r\n                    absXShift -= 4;\r\n                }\r\n                if (absX < 0x40000000000000000000000000000000) {\r\n                    absX <<= 2;\r\n                    absXShift -= 2;\r\n                }\r\n                if (absX < 0x80000000000000000000000000000000) {\r\n                    absX <<= 1;\r\n                    absXShift -= 1;\r\n                }\r\n\r\n                uint256 resultShift = 0;\r\n                while (y != 0) {\r\n                    require(absXShift < 64);\r\n\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                        resultShift += absXShift;\r\n                        if (absResult > 0x100000000000000000000000000000000) {\r\n                            absResult >>= 1;\r\n                            resultShift += 1;\r\n                        }\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n                    absXShift <<= 1;\r\n                    if (absX >= 0x100000000000000000000000000000000) {\r\n                        absX >>= 1;\r\n                        absXShift += 1;\r\n                    }\r\n\r\n                    y >>= 1;\r\n                }\r\n\r\n                require(resultShift < 64);\r\n                absResult >>= 64 - resultShift;\r\n            }\r\n            int256 result = negative ? -int256(absResult) : int256(absResult);\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sqrt(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return int128(sqrtu(uint256(int256(x)) << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function log_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            int256 msb = 0;\r\n            int256 xc = x;\r\n            if (xc >= 0x10000000000000000) {\r\n                xc >>= 64;\r\n                msb += 64;\r\n            }\r\n            if (xc >= 0x100000000) {\r\n                xc >>= 32;\r\n                msb += 32;\r\n            }\r\n            if (xc >= 0x10000) {\r\n                xc >>= 16;\r\n                msb += 16;\r\n            }\r\n            if (xc >= 0x100) {\r\n                xc >>= 8;\r\n                msb += 8;\r\n            }\r\n            if (xc >= 0x10) {\r\n                xc >>= 4;\r\n                msb += 4;\r\n            }\r\n            if (xc >= 0x4) {\r\n                xc >>= 2;\r\n                msb += 2;\r\n            }\r\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n            int256 result = (msb - 64) << 64;\r\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\r\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n                ux *= ux;\r\n                uint256 b = ux >> 255;\r\n                ux >>= 127 + b;\r\n                result += bit * int256(b);\r\n            }\r\n\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function ln(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            return\r\n                int128(\r\n                    int256(\r\n                        (uint256(int256(log_2(x))) *\r\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            uint256 result = 0x80000000000000000000000000000000;\r\n\r\n            if (x & 0x8000000000000000 > 0)\r\n                result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\r\n            if (x & 0x4000000000000000 > 0)\r\n                result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\r\n            if (x & 0x2000000000000000 > 0)\r\n                result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\r\n            if (x & 0x1000000000000000 > 0)\r\n                result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\r\n            if (x & 0x800000000000000 > 0)\r\n                result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\r\n            if (x & 0x400000000000000 > 0)\r\n                result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\r\n            if (x & 0x200000000000000 > 0)\r\n                result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\r\n            if (x & 0x100000000000000 > 0)\r\n                result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\r\n            if (x & 0x80000000000000 > 0)\r\n                result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\r\n            if (x & 0x40000000000000 > 0)\r\n                result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\r\n            if (x & 0x20000000000000 > 0)\r\n                result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\r\n            if (x & 0x10000000000000 > 0)\r\n                result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\r\n            if (x & 0x8000000000000 > 0)\r\n                result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\r\n            if (x & 0x4000000000000 > 0)\r\n                result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\r\n            if (x & 0x2000000000000 > 0)\r\n                result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\r\n            if (x & 0x1000000000000 > 0)\r\n                result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\r\n            if (x & 0x800000000000 > 0)\r\n                result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\r\n            if (x & 0x400000000000 > 0)\r\n                result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\r\n            if (x & 0x200000000000 > 0)\r\n                result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\r\n            if (x & 0x100000000000 > 0)\r\n                result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\r\n            if (x & 0x80000000000 > 0)\r\n                result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\r\n            if (x & 0x40000000000 > 0)\r\n                result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\r\n            if (x & 0x20000000000 > 0)\r\n                result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\r\n            if (x & 0x10000000000 > 0)\r\n                result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\r\n            if (x & 0x8000000000 > 0)\r\n                result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\r\n            if (x & 0x4000000000 > 0)\r\n                result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\r\n            if (x & 0x2000000000 > 0)\r\n                result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\r\n            if (x & 0x1000000000 > 0)\r\n                result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\r\n            if (x & 0x800000000 > 0)\r\n                result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\r\n            if (x & 0x400000000 > 0)\r\n                result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\r\n            if (x & 0x200000000 > 0)\r\n                result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\r\n            if (x & 0x100000000 > 0)\r\n                result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\r\n            if (x & 0x80000000 > 0)\r\n                result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\r\n            if (x & 0x40000000 > 0)\r\n                result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\r\n            if (x & 0x20000000 > 0)\r\n                result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\r\n            if (x & 0x10000000 > 0)\r\n                result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\r\n            if (x & 0x8000000 > 0)\r\n                result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\r\n            if (x & 0x4000000 > 0)\r\n                result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\r\n            if (x & 0x2000000 > 0)\r\n                result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\r\n            if (x & 0x1000000 > 0)\r\n                result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\r\n            if (x & 0x800000 > 0)\r\n                result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\r\n            if (x & 0x400000 > 0)\r\n                result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\r\n            if (x & 0x200000 > 0)\r\n                result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\r\n            if (x & 0x100000 > 0)\r\n                result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\r\n            if (x & 0x80000 > 0)\r\n                result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\r\n            if (x & 0x40000 > 0)\r\n                result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\r\n            if (x & 0x20000 > 0)\r\n                result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\r\n            if (x & 0x10000 > 0)\r\n                result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\r\n            if (x & 0x8000 > 0)\r\n                result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\r\n            if (x & 0x4000 > 0)\r\n                result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\r\n            if (x & 0x2000 > 0)\r\n                result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\r\n            if (x & 0x1000 > 0)\r\n                result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\r\n            if (x & 0x800 > 0)\r\n                result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\r\n            if (x & 0x400 > 0)\r\n                result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\r\n            if (x & 0x200 > 0)\r\n                result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\r\n            if (x & 0x100 > 0)\r\n                result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\r\n            if (x & 0x80 > 0)\r\n                result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\r\n            if (x & 0x40 > 0)\r\n                result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\r\n            if (x & 0x20 > 0)\r\n                result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\r\n            if (x & 0x10 > 0)\r\n                result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\r\n            if (x & 0x8 > 0)\r\n                result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\r\n            if (x & 0x4 > 0)\r\n                result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\r\n            if (x & 0x2 > 0)\r\n                result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\r\n            if (x & 0x1 > 0)\r\n                result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\r\n\r\n            result >>= uint256(int256(63 - (x >> 64)));\r\n            require(result <= uint256(int256(MAX_64x64)));\r\n\r\n            return int128(int256(result));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            return\r\n                exp_2(\r\n                    int128(\r\n                        (int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 64.64-bit fixed point number\r\n     */\r\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            uint256 result;\r\n\r\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                result = (x << 64) / y;\r\n            else {\r\n                uint256 msb = 192;\r\n                uint256 xc = x >> 192;\r\n                if (xc >= 0x100000000) {\r\n                    xc >>= 32;\r\n                    msb += 32;\r\n                }\r\n                if (xc >= 0x10000) {\r\n                    xc >>= 16;\r\n                    msb += 16;\r\n                }\r\n                if (xc >= 0x100) {\r\n                    xc >>= 8;\r\n                    msb += 8;\r\n                }\r\n                if (xc >= 0x10) {\r\n                    xc >>= 4;\r\n                    msb += 4;\r\n                }\r\n                if (xc >= 0x4) {\r\n                    xc >>= 2;\r\n                    msb += 2;\r\n                }\r\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n                result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\r\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 hi = result * (y >> 128);\r\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 xh = x >> 192;\r\n                uint256 xl = x << 64;\r\n\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n                lo = hi << 128;\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n\r\n                assert(xh == hi >> 128);\r\n\r\n                result += xl / y;\r\n            }\r\n\r\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n     * number.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return unsigned 128-bit integer number\r\n     */\r\n    function sqrtu(uint256 x) private pure returns (uint128) {\r\n        unchecked {\r\n            if (x == 0) return 0;\r\n            else {\r\n                uint256 xx = x;\r\n                uint256 r = 1;\r\n                if (xx >= 0x100000000000000000000000000000000) {\r\n                    xx >>= 128;\r\n                    r <<= 64;\r\n                }\r\n                if (xx >= 0x10000000000000000) {\r\n                    xx >>= 64;\r\n                    r <<= 32;\r\n                }\r\n                if (xx >= 0x100000000) {\r\n                    xx >>= 32;\r\n                    r <<= 16;\r\n                }\r\n                if (xx >= 0x10000) {\r\n                    xx >>= 16;\r\n                    r <<= 8;\r\n                }\r\n                if (xx >= 0x100) {\r\n                    xx >>= 8;\r\n                    r <<= 4;\r\n                }\r\n                if (xx >= 0x10) {\r\n                    xx >>= 4;\r\n                    r <<= 2;\r\n                }\r\n                if (xx >= 0x8) {\r\n                    r <<= 1;\r\n                }\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1; // Seven iterations should be enough\r\n                uint256 r1 = x / r;\r\n                return uint128(r < r1 ? r : r1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n        uint112 reserve0,\r\n        uint112 reserve1,\r\n        uint32 blockTimestampLast\r\n    );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n    external\r\n    returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract DBZ is IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    uint256 public _totalSupply;\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    mapping(address => bool) public pairList;\r\n    mapping(address => bool) public isDelivers;\r\n    address public uniswapV2Pair;\r\n\r\n    uint256 public distributorTime;\r\n    uint256 public distributorGas = 300000;\r\n    uint256 public minPeriod = 30 minutes;\r\n    uint256 public minAmount = 0.05 * 1e18;\r\n    uint256 public minBalance = 100 * 1e18;\r\n    address private fromAddress;\r\n    address private toAddress;\r\n    address[] shareholders;\r\n    bool private Tradeable = false;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping(address => bool) private _updated;\r\n    uint256 currentIndex;\r\n\r\n    uint256 public lastBlock;\r\n    mapping (address => uint256) public userLastBlocks;\r\n    uint256 public startBlock;\r\n    mapping(address => bool) public _blackList;\r\n\r\n    //BSC\r\n    IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address usdt = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public market = 0xc1cCDBa07B091693C94283768C5C2b58cA6950dB;\r\n    address public transferFeeAddress  = 0xc1cCDBa07B091693C94283768C5C2b58cA6950dB;\r\n    uint256 public transferFee = 6;\r\n    uint256 ratioNormal = 999975933 * 1e9; // 50% per day(86400/3 blocks)\r\n    uint256 ratioPool = 999990471 * 1e9; // 24% per day(86400/3 blocks)\r\n\r\n    constructor () {\r\n        startBlock = block.number.add(28800);\r\n\r\n        _name = 'DBZ';\r\n        _symbol = 'DBZ';\r\n        _mint(msg.sender, 100 * 1e4 * 1e8 * 1e18);\r\n\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\r\n            .createPair(address(this), address(usdt));\r\n        pairList[uniswapV2Pair] = true;\r\n    }\r\n    function setTradeable(bool _tradeable) public onlyOwner {\r\n        Tradeable = _tradeable;\r\n    }\r\n    function getTradeable() public view returns (bool) {\r\n        return Tradeable;\r\n    }\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(!_blackList[sender], \"blackList\");\r\n        //require(amount<balanceOf(sender), 'Can\\'t transfer all');\r\n        if (!Tradeable) {\r\n            require(sender != uniswapV2Pair&&sender != 0x10ED43C718714eb63d5aA57B78B54704E256024E, \"Trade is not open\");\r\n        }\r\n        uint256 ratioPoolTemp = ratioPool;\r\n        if(sender==uniswapV2Pair) ratioPool = 1e18;\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        _updateBalance(address(this));\r\n        _updateBalance(market);\r\n\r\n        if(isDelivers[sender] || isDelivers[recipient] || (!pairList[sender] && !pairList[recipient])){\r\n            //_basicTransfer(sender, recipient, amount);\r\n            _basicTransfer(sender, recipient, amount.sub(amount.mul(transferFee).div(100)));\r\n            _basicTransfer(sender, transferFeeAddress, amount.mul(transferFee).div(100));\r\n        }else{\r\n            uint256 toLPUser = amount.mul(4).div(100);\r\n            uint256 toLPPool = amount.mul(1).div(100);\r\n            uint256 toMarket = amount.mul(1).div(100);\r\n\r\n            _basicTransfer(sender, recipient, amount.sub(toLPUser).sub(toLPPool).sub(toMarket));\r\n            if(toLPUser>0) _basicTransfer(sender, address(this), toLPUser);\r\n            if(toLPPool>0) _basicTransfer(sender, uniswapV2Pair, toLPPool);\r\n            if(toMarket>0) _basicTransfer(sender, market, toMarket);\r\n        }\r\n\r\n        if(sender==uniswapV2Pair) ratioPool = ratioPoolTemp;\r\n\r\n        if(fromAddress == address(0)) fromAddress = sender;\r\n        if(toAddress == address(0)) toAddress = recipient;\r\n        setShare(fromAddress);\r\n        setShare(toAddress);\r\n        fromAddress = sender;\r\n        toAddress = recipient;\r\n\r\n        if(balanceOf(address(this))>=minBalance && sender!=address(this) && distributorTime.add(minPeriod)<=block.timestamp) {\r\n            process(distributorGas);\r\n            distributorTime = block.timestamp;\r\n        }\r\n    }\r\n    function setTransferFee(uint256 _transferFee) public onlyOwner(){\r\n        transferFee = _transferFee;\r\n    }\r\n    function setStartBlock(uint256 blocks) public onlyOwner(){\r\n        startBlock = block.number.add(blocks);\r\n    }\r\n     function setblackList(address[] memory addList,bool val) external onlyOwner{\r\n        for (uint i=0; i < addList.length; i++) {\r\n                _blackList[addList[i]] = val;\r\n        }\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\r\n        _totalSupply = totalSupply();\r\n        if(_totalSupply==0 || _totalSupply>1e5 * 1e18) lastBlock = block.number;\r\n\r\n        _updateBalance(from);\r\n        _updateBalance(to);\r\n        if(from!=uniswapV2Pair && to!=uniswapV2Pair){\r\n            _updateBalance(uniswapV2Pair);\r\n        }\r\n        amount;\r\n    }\r\n\r\n    function _updateBalance(address account) internal virtual {\r\n        if(block.number>userLastBlocks[account]){\r\n            _balances[account] = balanceOf(account);\r\n            userLastBlocks[account] = block.number;\r\n            if(account==uniswapV2Pair && _balances[uniswapV2Pair]>0){\r\n                try IUniswapV2Pair(uniswapV2Pair).sync() {} catch {}\r\n            }\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        uint256 latestBlock = block.number;\r\n        if(_totalSupply<=1e5 * 1e18) return _totalSupply;\r\n        \r\n        (,uint256 n) = latestBlock.trySub(lastBlock.max(startBlock));\r\n        if(n==0) return _totalSupply;\r\n\r\n        return balanceOf(uniswapV2Pair) + compound(_totalSupply - _balances[uniswapV2Pair], ratioNormal, n);\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        uint256 latestBlock = block.number;\r\n        if(_totalSupply<=1e5 * 1e18) latestBlock = lastBlock;\r\n\r\n        (,uint256 n) = latestBlock.trySub(userLastBlocks[account].max(startBlock));\r\n        if(n==0 || _balances[account]==0) return _balances[account];\r\n\r\n        uint256 ratio = account == uniswapV2Pair ? ratioPool : ratioNormal;\r\n        return compound(_balances[account], ratio, n);\r\n    }\r\n\r\n    function latestBlockNumber() public view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    function pow(int128 x, uint256 n) public pure returns (int128 r) {\r\n        r = ABDKMath64x64.fromUInt(1);\r\n        while (n > 0) {\r\n            if (n % 2 == 1) {\r\n                r = ABDKMath64x64.mul(r, x);\r\n                n -= 1;\r\n            } else {\r\n                x = ABDKMath64x64.mul(x, x);\r\n                n /= 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    function compound(uint256 principal, uint256 ratio, uint256 n) public pure returns (uint256) {\r\n        return\r\n            ABDKMath64x64.mulu(\r\n                pow(\r\n                    ABDKMath64x64.divu(ratio, 1e18),\r\n                    n\r\n                ),\r\n                principal\r\n            );\r\n    }\r\n\r\n    function process(uint256 gas) private {\r\n        uint256 shareholderCount = shareholders.length;\r\n        if(shareholderCount == 0) return;\r\n        uint256 nowbanance = balanceOf(address(this));\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n        uint256 pairTotalSupply = pair.totalSupply();\r\n        while(gasUsed < gas && iterations < shareholderCount) {\r\n            if(currentIndex >= shareholderCount){\r\n                currentIndex = 0;\r\n            }\r\n            address shareholder = shareholders[currentIndex];\r\n            uint256 amount = pair.balanceOf(shareholder).mul(nowbanance).div(pairTotalSupply);\r\n            if(amount < minAmount) {\r\n                currentIndex++;\r\n                iterations++;\r\n                continue;\r\n            }\r\n            if(balanceOf(address(this)) < amount ) return;\r\n\r\n            _updateBalance(shareholders[currentIndex]);\r\n            _basicTransfer(address(this), shareholders[currentIndex], amount);\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    function setShare(address shareholder) private {\r\n        bool shouldRemove = uniswapV2Pair==address(0) || IUniswapV2Pair(uniswapV2Pair).balanceOf(shareholder)==0;\r\n        if(_updated[shareholder] ){\r\n            if(shouldRemove) {\r\n                shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n                shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n                shareholders.pop();\r\n                _updated[shareholder] = false;\r\n            }\r\n            return;\r\n        }\r\n        if(shouldRemove) return;\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n        _updated[shareholder] = true;\r\n    }\r\n\r\n    function getShareholdersLength() public view returns(uint256){\r\n        return shareholders.length;\r\n    }\r\n\r\n    function getList(uint256 start, uint256 length) public view returns(address[] memory addrs, uint256[] memory bals){\r\n        address[] memory list = shareholders;\r\n        uint256 end = (start+length) < list.length ? (start+length) : list.length;\r\n        (,length) = end.trySub(start);\r\n        addrs = new address[](length);\r\n        bals = new uint256[](length);\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n        for(uint i=start; i<end; i++){\r\n            addrs[i-start] = list[i];\r\n            bals[i-start] = pair.balanceOf(list[i]);\r\n        }\r\n    }\r\n\r\n    function setPairList(address[] memory addrs, bool flag) public onlyOwner() {\r\n        for(uint i=0;i<addrs.length;i++){\r\n            pairList[addrs[i]] = flag;\r\n        }\r\n    }\r\n\r\n    function setDelivers(address[] memory addrs, bool flag) public onlyOwner() {\r\n        for(uint i=0;i<addrs.length;i++){\r\n            isDelivers[addrs[i]] = flag;\r\n        }\r\n    }\r\n\r\n    function changeMin(uint256 _distributorGas, uint256 _minPeriod, uint256 _minAmount, uint256 _minBalance) public onlyOwner{\r\n        distributorGas = _distributorGas;\r\n        minPeriod = _minPeriod;\r\n        minAmount = _minAmount;\r\n        minBalance = _minBalance;\r\n    }\r\n\r\n    function changeRouterAddress(address newRouter) public onlyOwner() {\r\n        uniswapV2Router = IUniswapV2Router02(newRouter);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), address(usdt));\r\n        pairList[uniswapV2Pair] = true;\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_distributorGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBalance\",\"type\":\"uint256\"}],\"name\":\"changeMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"changeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bals\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getShareholdersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDelivers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int128\",\"name\":\"x\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"pow\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"r\",\"type\":\"int128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setDelivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradeable\",\"type\":\"bool\"}],\"name\":\"setTradeable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"}],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setblackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLastBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DBZ", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://06b9e6f2197587d67a1f3d4b8f36ae37ee490a1384d9574f12104b0b43c26ba4"}