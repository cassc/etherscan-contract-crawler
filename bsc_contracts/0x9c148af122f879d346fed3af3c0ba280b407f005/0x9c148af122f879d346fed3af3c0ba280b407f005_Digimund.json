{"SourceCode": "{\"Authorized.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.15;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract Authorized is Ownable {\\r\\n  mapping(uint8 =\\u003e mapping(address =\\u003e bool)) internal permissions;\\r\\n\\r\\n  constructor() {\\r\\n    permissions[0][_msgSender()] = true; // admin\\r\\n    permissions[1][_msgSender()] = true; // controller\\r\\n  }\\r\\n\\r\\n  modifier isAuthorized(uint8 index) {\\r\\n    require(permissions[index][_msgSender()] == true, \\\"Account does not have permission\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    address token,\\r\\n    address spender,\\r\\n    uint amount\\r\\n  ) external isAuthorized(0) {\\r\\n    IERC20(token).approve(spender, amount);\\r\\n  }\\r\\n\\r\\n  function safeTransfer(\\r\\n    address token,\\r\\n    address receiver,\\r\\n    uint amount\\r\\n  ) external isAuthorized(0) {\\r\\n    IERC20(token).transfer(receiver, amount);\\r\\n  }\\r\\n\\r\\n  function grantPermission(address operator, uint8 typed) external isAuthorized(0) {\\r\\n    permissions[typed][operator] = true;\\r\\n  }\\r\\n\\r\\n  function revokePermission(address operator, uint8 typed) external isAuthorized(0) {\\r\\n    permissions[typed][operator] = false;\\r\\n  }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"ContractData.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.15;\\r\\nimport \\\"./Authorized.sol\\\";\\r\\ncontract ContractData is Authorized {\\r\\n  string public name = \\\"Digimund\\\";\\r\\n  string public url = \\\"www.digimund.one\\\";\\r\\n  struct AccountInfo {\\r\\n    address up;\\r\\n    uint unlockedLevel;\\r\\n    bool registered;\\r\\n    uint depositTime;\\r\\n    uint lastWithdraw;\\r\\n    uint depositMin;\\r\\n    uint depositTotal;\\r\\n    uint depositCounter;\\r\\n    uint bonusFidelidade;\\r\\n    uint saqueLib;\\r\\n  }\\r\\n  struct AccountEarnings {\\r\\n    uint receivedPassiveAmount;\\r\\n    uint receivedTotalAmount;\\r\\n    uint directBonusAmount;\\r\\n    uint directBonusAmountTotal;\\r\\n    uint levelBonusAmount;\\r\\n    uint levelBonusAmountTotal;\\r\\n  }\\r\\n  struct MoneyFlow {\\r\\n    uint passive;\\r\\n    uint direct;\\r\\n    uint bonus;\\r\\n  }\\r\\n  struct NetworkCheck {\\r\\n    uint count;\\r\\n    uint deposits;\\r\\n    uint depositTotal;\\r\\n    uint depositCounter;\\r\\n  }\\r\\n  mapping(address =\\u003e AccountInfo) public accountsInfo;\\r\\n  mapping(address =\\u003e AccountEarnings) public accountsEarnings;\\r\\n  mapping(address =\\u003e address[]) public accountsRefs;\\r\\n  mapping(address =\\u003e uint[]) public accountsFlow;\\r\\n  mapping(address =\\u003e address[]) public accountsShared;\\r\\n  mapping(address =\\u003e address[]) public accountsInShare;\\r\\n  uint16[] _passiveBonusLevel = new uint16[](10);\\r\\n  uint public minAllowedDeposit = 0.001 ether;\\r\\n  uint public minAmountToLvlUp = 0.05 ether;\\r\\n  uint public minAmountToGetBonus = 0.001 ether;\\r\\n  uint public constant timeFrame = 1 days;\\r\\n  uint public maxAllowedDeposit = 10.1 ether;\\r\\n  uint public constant timeToWithdraw = 1 days;\\r\\n  uint public constant dailyRentability = 13;\\r\\n  uint public constant directBonus = 10;\\r\\n  uint public constant maxWithdrawPercentPerTime = 40;\\r\\n  uint public constant maxWithdraw = 1.2 ether;\\r\\n  uint public constant networkFeePercent = 10;\\r\\n  uint public constant wpmFeePercent = 40;\\r\\n  uint public constant maxPercentToWithdraw = 215;\\r\\n  uint public constant maxPercentToReceive = 215;\\r\\n  uint public holdPassiveOnDrop = 85;\\r\\n  \\r\\n  \\r\\n  bool public distributePassiveNetwork = true;\\r\\n  uint public maxBalance;\\r\\n  uint public networkSize;\\r\\n  uint public networkDeposits;\\r\\n  uint public networkWithdraw;\\r\\n  address networkReceiver;\\r\\n  address wpmReceiver;\\r\\n  uint cumulativeNetworkFee;\\r\\n  uint cumulativeWPMFee;\\r\\n  uint composeDeposit;\\r\\n  address constant mainNode = 0x492c4f0c082ED79Ab5D6A1Ac8cB40144f2788DED;\\r\\n  address public networkReceiverA1=0xc34f9DCeD73A83Db0D931CB8f41422f4B2aADE7C;\\r\\n  address public networkReceiverB1=0x9e58b53760Da0b87a75A4eEEd175B116464e9A70;\\r\\n  address public networkReceiverB2=0xbE55E8Cc67e02B16c9A078ac2804B6e31C38C614;\\r\\n  address public networkReceiverB3=0x37204614C4534e7Deb680E17B837c7349721dfd5;\\r\\n  address public networkReceiverC1=0x492c4f0c082ED79Ab5D6A1Ac8cB40144f2788DED;\\r\\n  address public networkReceiverC2=0xdCC24bf2849D102600F4fB14242e175b5485b3fD;\\r\\n  address public networkReceiverD1=0xF2FCd221CD2314a9Ff91d51e5F101e4071b53dB6;\\r\\n  address public networkReceiverD2=0xA10e4B50d2F7b792F3eD79D3D6499263d0E42a07;\\r\\n \\r\\n  constructor() {\\r\\n    _passiveBonusLevel[0] = 100;\\r\\n    _passiveBonusLevel[1] = 70;\\r\\n    _passiveBonusLevel[2] = 50;\\r\\n    _passiveBonusLevel[3] = 10;\\r\\n    _passiveBonusLevel[4] = 10;\\r\\n    _passiveBonusLevel[5] = 10;\\r\\n    _passiveBonusLevel[6] = 10;\\r\\n    _passiveBonusLevel[7] = 10;\\r\\n    _passiveBonusLevel[8] = 10;\\r\\n    _passiveBonusLevel[9] = 10;\\r\\n  }\\r\\n  event WithdrawLimitReached(address indexed addr, uint amount);\\r\\n  event Withdraw(address indexed addr, uint amount);\\r\\n  event NewDeposit(address indexed addr, uint amount);\\r\\n  event NewUpgrade(address indexed addr, uint amount);\\r\\n  event DirectBonus(address indexed addr, address indexed from, uint amount);\\r\\n  event LevelBonus(address indexed addr, address indexed from, uint amount);\\r\\n  event ReferralRegistration(address indexed addr, address indexed referral);\\r\\n  event NewDonationDeposit(address indexed addr, uint amount, string message);\\r\\n  function setMinAllowedDeposit(uint minValue) external isAuthorized(1) {\\r\\n    minAllowedDeposit = minValue;\\r\\n  }\\r\\n  function setMaxAllowedDeposit(uint maxValue) external isAuthorized(1) {\\r\\n    maxAllowedDeposit = maxValue;\\r\\n  }\\r\\n  function setMinAmountToLvlUp(uint minValue) external isAuthorized(1) {\\r\\n    minAmountToLvlUp = minValue;\\r\\n  }\\r\\n  function setMinAmountToGetBonus(uint minValue) external isAuthorized(1) {\\r\\n    minAmountToGetBonus = minValue;\\r\\n  }\\r\\n  function setHoldPassiveOnDrop(uint value) external isAuthorized(1) {\\r\\n    holdPassiveOnDrop = value;\\r\\n  }\\r\\n  function setNetworkReceiver(address receiver) external isAuthorized(0) {\\r\\n    networkReceiver = receiver;\\r\\n  }\\r\\n  function setWpmReceiver(address receiver) external isAuthorized(0) {\\r\\n    wpmReceiver = receiver;\\r\\n  }\\r\\n  function buildOperation(uint8 opType, uint value) internal view returns (uint res) {\\r\\n    assembly {\\r\\n      let entry := mload(0x40)\\r\\n      mstore(entry, add(shl(200, opType), add(add(shl(160, timestamp()), shl(120, number())), value)))\\r\\n      res := mload(entry)\\r\\n    }\\r\\n  }\\r\\n  function getShares(address target) external view returns (address[] memory shared, address[] memory inShare) {\\r\\n    shared = accountsShared[target];\\r\\n    inShare = accountsInShare[target];\\r\\n  }\\r\\n  function getFlow(\\r\\n    address target,\\r\\n    uint limit,\\r\\n    bool asc\\r\\n  ) external view returns (uint[] memory flow) {\\r\\n    uint[] memory list = accountsFlow[target];\\r\\n    if (limit == 0) limit = list.length;\\r\\n    if (limit \\u003e list.length) limit = list.length;\\r\\n    flow = new uint[](limit);\\r\\n    if (asc) {\\r\\n      for (uint i = 0; i \\u003c limit; i++) flow[i] = list[i];\\r\\n    } else {\\r\\n      for (uint i = 0; i \\u003c limit; i++) flow[i] = list[(limit - 1) - i];\\r\\n    }\\r\\n  }\\r\\n  function getMaxLevel(address sender) public view returns (uint) {\\r\\n    uint currentUnlockedLevel = accountsInfo[sender].unlockedLevel;\\r\\n    uint lockLevel = accountsInfo[sender].depositMin \\u003e= minAmountToGetBonus ? 10 : 0;\\r\\n    if (lockLevel \\u003c currentUnlockedLevel) return lockLevel;\\r\\n    return currentUnlockedLevel;\\r\\n  }\\r\\n  function visualizar(address sender) private view returns (uint){\\r\\n    return accountsInfo[sender].bonusFidelidade;\\r\\n  }\\r\\n  //verificar se este \u00e9 o local que gera rendimento\\r\\n  function calculatePassive(\\r\\n    address sender,\\r\\n    uint depositTime,\\r\\n    uint depositMin,\\r\\n    uint receivedTotalAmount,\\r\\n    uint receivedPassiveAmount\\r\\n  ) public view returns (uint) {\\r\\n    if (depositTime == 0 || depositMin == 0) return 0;\\r\\n    uint passive = ((((depositMin * dailyRentability) / 1000) * (block.timestamp - depositTime)) / timeFrame) - receivedPassiveAmount;\\r\\n    uint remainingAllowed = ((depositMin * visualizar(sender)) / 100) - receivedTotalAmount; // MAX TO RECEIVE\\r\\n    return passive \\u003e= remainingAllowed ? remainingAllowed : passive;\\r\\n  }\\r\\n  function getAccountNetwork(\\r\\n    address sender,\\r\\n    uint minLevel,\\r\\n    uint maxLevel\\r\\n  ) public view returns (NetworkCheck[] memory) {\\r\\n    maxLevel = maxLevel \\u003e _passiveBonusLevel.length || maxLevel == 0 ? _passiveBonusLevel.length : maxLevel;\\r\\n    NetworkCheck[] memory network = new NetworkCheck[](maxLevel);\\r\\n    for (uint i = 0; i \\u003c accountsRefs[sender].length; i++) {\\r\\n      _getAccountNetworkInner(accountsRefs[sender][i], 0, minLevel, maxLevel, network);\\r\\n    }\\r\\n    return network;\\r\\n  }\\r\\n  function _getAccountNetworkInner(\\r\\n    address sender,\\r\\n    uint level,\\r\\n    uint minLevel,\\r\\n    uint maxLevel,\\r\\n    NetworkCheck[] memory network\\r\\n  ) internal view {\\r\\n    if (level \\u003e= minLevel) {\\r\\n      network[level].count += 1;\\r\\n      network[level].deposits += accountsInfo[sender].depositMin;\\r\\n      network[level].depositCounter += accountsInfo[sender].depositCounter;\\r\\n      network[level].depositTotal += accountsInfo[sender].depositTotal;\\r\\n    }\\r\\n    if (level + 1 \\u003e= maxLevel) return;\\r\\n    for (uint i = 0; i \\u003c accountsRefs[sender].length; i++) {\\r\\n      _getAccountNetworkInner(accountsRefs[sender][i], level + 1, minLevel, maxLevel, network);\\r\\n    }\\r\\n  }\\r\\n  function getMultiAccountNetwork(\\r\\n    address[] memory senders,\\r\\n    uint minLevel,\\r\\n    uint maxLevel\\r\\n  ) external view returns (NetworkCheck[] memory network) {\\r\\n    for (uint x = 0; x \\u003c senders.length; x++) {\\r\\n      NetworkCheck[] memory partialNetwork = getAccountNetwork(senders[x], minLevel, maxLevel);\\r\\n      for (uint i = 0; i \\u003c maxLevel; i++) {\\r\\n        network[i].count += partialNetwork[i].count;\\r\\n        network[i].deposits += partialNetwork[i].deposits;\\r\\n        network[i].depositTotal += partialNetwork[i].depositTotal;\\r\\n        network[i].depositCounter += partialNetwork[i].depositCounter;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  function getMultiLevelAccount(\\r\\n    address[] memory senders,\\r\\n    uint currentLevel,\\r\\n    uint maxLevel\\r\\n  ) public view returns (bytes memory results) {\\r\\n    for (uint x = 0; x \\u003c senders.length; x++) {\\r\\n      if (currentLevel == maxLevel) {\\r\\n        for (uint i = 0; i \\u003c accountsRefs[senders[x]].length; i++) {\\r\\n          results = abi.encodePacked(results, accountsRefs[senders[x]][i]);\\r\\n        }\\r\\n      } else {\\r\\n        results = abi.encodePacked(results, getMultiLevelAccount(accountsRefs[senders[x]], currentLevel + 1, maxLevel));\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  function getAccountEarnings(address sender)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      AccountInfo memory accountI,\\r\\n      AccountEarnings memory accountE,\\r\\n      MoneyFlow memory total,\\r\\n      MoneyFlow memory toWithdraw,\\r\\n      MoneyFlow memory toMaxEarning,\\r\\n      MoneyFlow memory toReceiveOverMax,\\r\\n      uint level,\\r\\n      uint directs,\\r\\n      uint time\\r\\n    )\\r\\n  {\\r\\n    accountI = accountsInfo[sender];\\r\\n    accountE = accountsEarnings[sender];\\r\\n    address localSender = sender;\\r\\n    uint depositMin = accountsInfo[localSender].depositMin;\\r\\n    uint directBonusAmount = accountsEarnings[localSender].directBonusAmount;\\r\\n    uint levelBonusAmount = accountsEarnings[localSender].levelBonusAmount;\\r\\n    uint receivedTotalAmount = accountsEarnings[localSender].receivedTotalAmount;\\r\\n    uint passive = calculatePassive(\\r\\n      localSender,\\r\\n      accountsInfo[localSender].depositTime,\\r\\n      depositMin,\\r\\n      receivedTotalAmount,\\r\\n      accountsEarnings[localSender].receivedPassiveAmount\\r\\n    );\\r\\n    total = MoneyFlow(passive, directBonusAmount, levelBonusAmount);\\r\\n    if (localSender == mainNode) depositMin = type(uint).max / 1e5;\\r\\n    uint remainingWithdraw = ((depositMin * visualizar(localSender)) / 100) - receivedTotalAmount;\\r\\n    uint toRegisterPassive = passive \\u003e= remainingWithdraw ? remainingWithdraw : passive;\\r\\n    remainingWithdraw = remainingWithdraw - toRegisterPassive;\\r\\n    uint toRegisterDirect = directBonusAmount \\u003e= remainingWithdraw ? remainingWithdraw : directBonusAmount;\\r\\n    remainingWithdraw = remainingWithdraw - toRegisterDirect;\\r\\n    uint toRegisterBonus = levelBonusAmount \\u003e= remainingWithdraw ? remainingWithdraw : levelBonusAmount;\\r\\n    passive -= toRegisterPassive;\\r\\n    directBonusAmount -= toRegisterDirect;\\r\\n    levelBonusAmount -= toRegisterBonus;\\r\\n    toWithdraw = MoneyFlow(toRegisterPassive, toRegisterDirect, toRegisterBonus);\\r\\n    remainingWithdraw = ((depositMin * visualizar(localSender)) / 100) - (receivedTotalAmount + toRegisterPassive + toRegisterDirect + toRegisterBonus); \\r\\n    toRegisterPassive = passive \\u003e= remainingWithdraw ? remainingWithdraw : passive;\\r\\n    remainingWithdraw = remainingWithdraw - toRegisterPassive;\\r\\n    toRegisterDirect = directBonusAmount \\u003e= remainingWithdraw ? remainingWithdraw : directBonusAmount;\\r\\n    remainingWithdraw = remainingWithdraw - toRegisterDirect;\\r\\n    toRegisterBonus = levelBonusAmount \\u003e= remainingWithdraw ? remainingWithdraw : levelBonusAmount;\\r\\n    passive -= toRegisterPassive;\\r\\n    directBonusAmount -= toRegisterDirect;\\r\\n    levelBonusAmount -= toRegisterBonus;\\r\\n    toMaxEarning = MoneyFlow(toRegisterPassive, toRegisterDirect, toRegisterBonus);\\r\\n    toReceiveOverMax = MoneyFlow(passive, directBonusAmount, levelBonusAmount);\\r\\n    level = getMaxLevel(localSender);\\r\\n    directs = accountsRefs[localSender].length;\\r\\n    time = block.timestamp;\\r\\n  }\\r\\n}\"},\"Digimund.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.15;\\r\\nimport \\\"./ContractData.sol\\\";\\r\\ncontract Digimund is ContractData {\\r\\n  constructor() {\\r\\n    accountsInfo[mainNode].up = owner();\\r\\n    accountsInfo[mainNode].unlockedLevel = 10;\\r\\n    accountsInfo[mainNode].registered = true;\\r\\n    accountsRefs[owner()].push(mainNode);\\r\\n    emit ReferralRegistration(mainNode, owner());\\r\\n    networkSize += 1;\\r\\n  }\\r\\n  receive() external payable {\\r\\n    makeDeposit();\\r\\n  }\\r\\n  function marketingPumpUp() external {}\\r\\n  function registerAccount(address ref) external payable {\\r\\n    address sender = msg.sender;\\r\\n    require(sender != ref \\u0026\\u0026 accountsInfo[sender].up == address(0) \\u0026\\u0026 accountsInfo[ref].registered == true, \\\"Invalid Referral\\\");\\r\\n    accountsInfo[sender].up = ref;\\r\\n    accountsInfo[sender].registered = true;\\r\\n    accountsRefs[ref].push(sender);\\r\\n    accountsInfo[sender].bonusFidelidade = 185;\\r\\n    accountsInfo[sender].saqueLib = 0;\\r\\n    emit ReferralRegistration(sender, ref);\\r\\n    accountsFlow[ref].push(buildOperation(1, accountsRefs[ref].length));\\r\\n    networkSize += 1;\\r\\n    _registerDeposit(sender, msg.value);\\r\\n    _payCumulativeFee();\\r\\n  }\\r\\n  function addShareWallet(address toBeShared) external {\\r\\n    address target = msg.sender;\\r\\n    require(accountsInfo[target].registered == true, \\\"Account not registered on platform\\\");\\r\\n    require(toBeShared != address(0) \\u0026\\u0026 toBeShared != target, \\\"Invalid account to be shared\\\");\\r\\n    address[] memory shared = accountsShared[target];\\r\\n    require(shared.length \\u003c 9, \\\"Max shared accounts reached\\\");\\r\\n    for (uint i = 0; i \\u003c shared.length; i++) {\\r\\n      if (shared[i] == toBeShared) revert(\\\"Already been shared with this wallet\\\");\\r\\n    }\\r\\n    accountsShared[target].push(toBeShared);\\r\\n    accountsInShare[toBeShared].push(target);\\r\\n  }\\r\\n  function makeDeposit() public payable {\\r\\n    _registerDeposit(msg.sender, msg.value);\\r\\n    _payCumulativeFee();\\r\\n  }\\r\\n  function withdrawAndDeposit(uint amount) public payable {\\r\\n    require(amount \\u003e= 0, \\\"Invalid amount\\\");\\r\\n    composeDeposit = amount;\\r\\n    _withdraw(0);\\r\\n    _registerDeposit(msg.sender, msg.value + composeDeposit);\\r\\n    _payCumulativeFee();\\r\\n    composeDeposit = 0;\\r\\n    uint networkFee = amount;\\r\\n    if (networkFee \\u003c= 0) return;\\r\\n  }\\r\\n  function directBonusDeposit(address receiver) public payable isAuthorized(1) {\\r\\n    uint amount = msg.value;\\r\\n    require(amount \\u003e 0, \\\"Invalid amount\\\");\\r\\n    require(accountsInfo[receiver].registered == true, \\\"Invalid receiver\\\");\\r\\n    networkDeposits += amount;\\r\\n    _payNetworkFee(amount, true, false);\\r\\n    _payCumulativeFee();\\r\\n    address up = accountsInfo[receiver].up;\\r\\n    address contractMainNome = mainNode;\\r\\n    uint minToGetBonus = minAmountToGetBonus;\\r\\n    for (uint8 i = 0; i \\u003c _passiveBonusLevel.length; i++) {\\r\\n      if (up == address(0)) break;\\r\\n      uint currentUnlockedLevel = accountsInfo[up].unlockedLevel;    \\r\\n      uint lockLevel = accountsInfo[up].depositMin \\u003e= minToGetBonus ? 10 : 0;\\r\\n      if (lockLevel \\u003c currentUnlockedLevel) currentUnlockedLevel = lockLevel;\\r\\n      if (currentUnlockedLevel \\u003e i || up == contractMainNome) {\\r\\n        uint bonus = (amount * _passiveBonusLevel[i]) / 1000;\\r\\n        accountsEarnings[up].levelBonusAmount += bonus;\\r\\n        accountsEarnings[up].levelBonusAmountTotal += bonus;\\r\\n\\r\\n        emit LevelBonus(up, receiver, bonus);\\r\\n      }\\r\\n      up = accountsInfo[up].up;\\r\\n    }\\r\\n  }\\r\\n  function makeDonation(string memory message) public payable {\\r\\n    uint amount = msg.value;\\r\\n    address sender = msg.sender;\\r\\n    require(amount \\u003e 0, \\\"Invalid amount\\\");\\r\\n    emit NewDonationDeposit(sender, amount, message);\\r\\n    accountsFlow[sender].push(buildOperation(2, amount));\\r\\n    networkDeposits += amount;\\r\\n    _payNetworkFee(amount, true, false);\\r\\n    _payCumulativeFee();\\r\\n  }\\r\\n  function withdraw() external {\\r\\n    _withdraw(0);\\r\\n    _payCumulativeFee();\\r\\n  }\\r\\n  function withdrawPartial(uint amount) external {\\r\\n    require(amount \\u003e 0, \\\"Invalid amount\\\");\\r\\n    _withdraw(amount);\\r\\n    _payCumulativeFee();\\r\\n  }\\r\\n  function _withdraw(uint amountOut) private {\\r\\n    address sender = msg.sender;\\r\\n    uint balance_t = address(this).balance;\\r\\n    uint maximoGanhoBB = accountsInfo[sender].bonusFidelidade;\\r\\n    uint amount = amountOut;\\r\\n    uint depositMin = accountsInfo[sender].depositMin;\\r\\n    uint receivedTotalAmount = accountsEarnings[sender].receivedTotalAmount;\\r\\n    uint depositTime = accountsInfo[sender].depositTime;\\r\\n    uint receivedPassiveAmount = accountsEarnings[sender].receivedPassiveAmount;\\r\\n    uint directBonusAmount = accountsEarnings[sender].directBonusAmount;\\r\\n    uint levelBonusAmount = accountsEarnings[sender].levelBonusAmount;\\r\\n    uint passive = calculatePassive(sender, depositTime, depositMin, receivedTotalAmount, receivedPassiveAmount);\\r\\n    uint remainingWithdraw = ((depositMin * maximoGanhoBB) / 100) - receivedTotalAmount; // MAX WITHDRAW\\r\\n    uint withdrawAmount = remainingWithdraw;\\r\\n    require(withdrawAmount \\u003e 0, \\\"No remaining withdraws\\\");\\r\\n    if(balance_t \\u003c ((maxBalance * 50) / 100)){\\r\\n    require(((depositMin * 70) / 100) \\u003e receivedTotalAmount, \\\"Baixa historica, tirou captau \\\");\\r\\n    require(levelBonusAmount \\u003e 900000000000000, \\\"Tem que ter indicado Direto!\\\");\\r\\n    }\\r\\n      \\r\\n    if (amount \\u003e 0) {\\r\\n      require(amount \\u003c= remainingWithdraw, \\\"Amount exceed remaining amount to be withdrawn\\\");\\r\\n      withdrawAmount = amount;\\r\\n    } else if (directBonusAmount + levelBonusAmount + passive \\u003c remainingWithdraw) {\\r\\n      if (composeDeposit \\u003e 0) {\\r\\n        withdrawAmount = composeDeposit;\\r\\n      } else {\\r\\n        withdrawAmount = ((directBonusAmount + levelBonusAmount + passive) * maxWithdrawPercentPerTime) / 100;\\r\\n      }\\r\\n    }\\r\\n    _withdrawCalculations(sender, withdrawAmount, passive, directBonusAmount, levelBonusAmount, amount, receivedTotalAmount, remainingWithdraw);\\r\\n  }\\r\\n\\r\\n  \\r\\n  function _withdrawCalculations(\\r\\n    address sender,\\r\\n    uint withdrawAmount,\\r\\n    uint passive,\\r\\n    uint directBonusAmount,\\r\\n    uint levelBonusAmount,\\r\\n    uint amount,\\r\\n    uint receivedTotalAmount,\\r\\n    uint remainingWithdraw\\r\\n  ) private {\\r\\n    uint summedBonus = directBonusAmount + levelBonusAmount;\\r\\n    uint toWithdrawPassive = passive \\u003e= withdrawAmount ? withdrawAmount : passive;\\r\\n    if (directBonusAmount \\u003e withdrawAmount - toWithdrawPassive) directBonusAmount = withdrawAmount - toWithdrawPassive;\\r\\n    if (levelBonusAmount \\u003e withdrawAmount - (toWithdrawPassive + directBonusAmount))\\r\\n      levelBonusAmount = withdrawAmount - (toWithdrawPassive + directBonusAmount);\\r\\n    uint totalToWithdraw = toWithdrawPassive + directBonusAmount + levelBonusAmount;\\r\\n    if (directBonusAmount \\u003e 0) accountsEarnings[sender].directBonusAmount -= directBonusAmount;\\r\\n    if (levelBonusAmount \\u003e 0) accountsEarnings[sender].levelBonusAmount -= levelBonusAmount;\\r\\n    accountsEarnings[sender].receivedPassiveAmount += toWithdrawPassive;\\r\\n    accountsEarnings[sender].receivedTotalAmount += totalToWithdraw;\\r\\n\\r\\n      if (accountsInfo[sender].lastWithdraw \\u003e (block.timestamp - 7 days)){\\r\\n      accountsInfo[sender].saqueLib += 1;\\r\\n      }\\r\\n      if (accountsInfo[sender].lastWithdraw \\u003c= (block.timestamp - 7 days)){\\r\\n      accountsInfo[sender].saqueLib = 0;\\r\\n      }\\r\\n\\r\\n    accountsInfo[sender].lastWithdraw = block.timestamp;\\r\\n\\r\\n    \\r\\n    if (totalToWithdraw \\u003e= remainingWithdraw) {\\r\\n      emit WithdrawLimitReached(sender, receivedTotalAmount + totalToWithdraw);\\r\\n    } else {\\r\\n      uint maxWithdraw = passive + summedBonus;\\r\\n      if (amount \\u003e 0 \\u0026\\u0026 maxWithdraw \\u003c remainingWithdraw) {\\r\\n        require(amount \\u003c= (maxWithdraw * maxWithdrawPercentPerTime) / 100, \\\"Max withdraw allowed per time is 40% of remaining available\\\");\\r\\n      }\\r\\n    }\\r\\n    uint feeAmount = _payNetworkFee(totalToWithdraw, false, true);\\r\\n    networkWithdraw += totalToWithdraw;\\r\\n    emit Withdraw(sender, totalToWithdraw);\\r\\n    accountsFlow[sender].push(buildOperation(3, totalToWithdraw));\\r\\n    uint totalToPay = totalToWithdraw - feeAmount;\\r\\n    if (composeDeposit \\u003e 0) {\\r\\n      if (totalToPay \\u003e= composeDeposit) {\\r\\n        totalToPay -= composeDeposit;\\r\\n      } else {\\r\\n        composeDeposit = totalToPay;\\r\\n        totalToPay = 0;\\r\\n      }\\r\\n    }\\r\\n    if (totalToPay \\u003e 0) _payWithdrawAmount(totalToPay);\\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\n  function _payWithdrawAmount(uint totalToWithdraw) private {\\r\\n    address sender = msg.sender;\\r\\n    uint shareCount = accountsShared[sender].length;\\r\\n    uint taxa1;\\r\\n    uint taxa2;\\r\\n    uint taxan1;\\r\\n    uint taxan2;\\r\\n    uint saquelibC = accountsInfo[sender].saqueLib;\\r\\n    uint balance_t = address(this).balance;\\r\\n    uint minimoDeposito = accountsInfo[sender].depositTotal;\\r\\n    uint totalRecebido = accountsEarnings[sender].receivedTotalAmount;\\r\\n    taxa1 = 45; \\r\\n    taxa2 = 5; \\r\\n    if (balance_t \\u003c ((maxBalance * 40) / 100)) {\\r\\n      taxa1 = 720; \\r\\n      taxa2 = 80; \\r\\n    } else if (balance_t \\u003c ((maxBalance * 60) / 100)) {\\r\\n      taxa1 = 360; \\r\\n      taxa2 = 40; \\r\\n    } else if (balance_t \\u003c ((maxBalance * 80) / 100)) {\\r\\n      taxa1 = 180; \\r\\n      taxa2 = 20; \\r\\n    }\\r\\n    if (saquelibC == 1){\\r\\n      taxan1 = 450;\\r\\n      taxan2 = 50;\\r\\n    } \\r\\n    if (saquelibC \\u003e 1){\\r\\n      taxan1 = 810;\\r\\n      taxan2 = 90;\\r\\n    }\\r\\n    if (taxan1 \\u003e taxa1){\\r\\n      taxa1 = taxan1;\\r\\n      taxa2 = taxan2;\\r\\n    }\\r\\n    if (minimoDeposito \\u003e 9999000000000000000 ){\\r\\n      taxa1 = taxa1 + 90;\\r\\n      taxa2 = taxa2 + 10;\\r\\n    }\\r\\n      totalToWithdraw = totalToWithdraw + (totalToWithdraw * 50) / 1000;\\r\\n      require(totalToWithdraw \\u003c 1200000000000000000, \\\"Valor maximo de saque = 1.2BNB\\\");\\r\\n      if (shareCount == 0) {\\r\\n      if (distributePassiveNetwork == false) {\\r\\n        require(totalRecebido \\u003c minimoDeposito \\u0026\\u0026 distributePassiveNetwork == false, \\\"Nao pode receber, esta baixo da alta historica\\\");\\r\\n        payable(sender).transfer(totalToWithdraw - (totalToWithdraw * taxa2) / 1000 - (totalToWithdraw * taxa1) / 1000);\\r\\n        payable(networkReceiverD2).transfer((totalToWithdraw * taxa2) / 1000);\\r\\n        payable(networkReceiverD1).transfer((totalToWithdraw * taxa1) / 1000);\\r\\n      } else {\\r\\n        payable(sender).transfer(totalToWithdraw - (totalToWithdraw * taxa2) / 1000 - (totalToWithdraw * taxa1) / 1000);\\r\\n        payable(networkReceiverD2).transfer((totalToWithdraw * taxa2) / 1000);\\r\\n        payable(networkReceiverD1).transfer((totalToWithdraw * taxa1) / 1000);\\r\\n      }\\r\\n        return;\\r\\n      }\\r\\n\\r\\n\\r\\n    uint partialValue = totalToWithdraw / (shareCount + 1);\\r\\n\\r\\n\\r\\n    \\r\\n    payable(sender).transfer(partialValue - (partialValue * taxa2) / 1000 - (partialValue * taxa1) / 1000);\\r\\n    payable(networkReceiverD2).transfer((partialValue * taxa2) / 1000 );\\r\\n    payable(networkReceiverD1).transfer((partialValue * taxa1) / 1000 );\\r\\n\\r\\n    for (uint i = 0; i \\u003c shareCount; i++) {\\r\\n\\r\\n      \\r\\n    payable(accountsShared[sender][i]).transfer(partialValue - (partialValue * taxa2) / 1000 - (partialValue * taxa1) / 1000);\\r\\n    payable(networkReceiverD2).transfer((partialValue * taxa2) / 1000 );\\r\\n    payable(networkReceiverD1).transfer((partialValue * taxa1) / 1000 );\\r\\n    }\\r\\n  }\\r\\n  function _registerDeposit(address sender, uint amount) private {\\r\\n    uint depositMin = accountsInfo[sender].depositMin;\\r\\n    uint depositCounter = accountsInfo[sender].depositCounter;\\r\\n    uint currentBalance = address(this).balance;\\r\\n    if (maxBalance \\u003c currentBalance) {\\r\\n      maxBalance = currentBalance;\\r\\n    }\\r\\n    if (depositCounter == 0) {\\r\\n      accountsFlow[sender].push(buildOperation(4, amount));\\r\\n    } else {\\r\\n      uint receivedTotalAmount = accountsEarnings[sender].receivedTotalAmount;\\r\\n      uint SaqueMax = accountsInfo[sender].bonusFidelidade;\\r\\n      uint maxToReceive = (depositMin * SaqueMax) / 100;\\r\\n      if (receivedTotalAmount \\u003c maxToReceive) {\\r\\n        if (composeDeposit \\u003e 0) {\\r\\n          accountsFlow[sender].push(buildOperation(8, amount));\\r\\n        } else {\\r\\n          accountsFlow[sender].push(buildOperation(7, amount));\\r\\n        }\\r\\n        return _registerLiveUpgrade(sender, amount, depositMin, receivedTotalAmount, maxToReceive);\\r\\n      } else {\\r\\n        if (depositMin == amount) {\\r\\n          accountsFlow[sender].push(buildOperation(5, amount));\\r\\n        } else {\\r\\n          accountsFlow[sender].push(buildOperation(6, amount));\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    address referral = accountsInfo[sender].up;\\r\\n    require(referral != address(0), \\\"Registration is required\\\");\\r\\n    require(amount \\u003e= minAllowedDeposit, \\\"Min amount not reached\\\");\\r\\n    require(amount \\u003c= maxAllowedDeposit, \\\"Max amount not reached\\\");\\r\\n    require(depositMin \\u003c= amount, \\\"Deposit lower than account value\\\");\\r\\n    if (depositMin \\u003c minAmountToLvlUp \\u0026\\u0026 amount \\u003e= minAmountToLvlUp) {\\r\\n      uint currentUnlockedLevel = accountsInfo[referral].unlockedLevel;\\r\\n      if (currentUnlockedLevel \\u003c _passiveBonusLevel.length) {\\r\\n        accountsInfo[referral].unlockedLevel = currentUnlockedLevel + 1;\\r\\n      }\\r\\n    }\\r\\n    accountsInfo[sender].depositMin = amount;\\r\\n    accountsInfo[sender].depositTotal += amount;\\r\\n    accountsInfo[sender].depositCounter = depositCounter + 1;\\r\\n    if (accountsInfo[sender].bonusFidelidade == 290){\\r\\n       accountsInfo[sender].bonusFidelidade = 300;\\r\\n    }\\r\\n    if (accountsInfo[sender].bonusFidelidade \\u003c 290){\\r\\n       accountsInfo[sender].bonusFidelidade += 15;\\r\\n    }\\r\\n    accountsInfo[sender].depositTime = block.timestamp;\\r\\n    accountsEarnings[sender].receivedTotalAmount = 0;\\r\\n    accountsEarnings[sender].receivedPassiveAmount = 0;\\r\\n    accountsEarnings[sender].directBonusAmount = 0;\\r\\n    accountsEarnings[sender].levelBonusAmount = 0;\\r\\n    accountsInfo[sender].saqueLib = 0;\\r\\n    \\r\\n    emit NewDeposit(sender, amount);\\r\\n    networkDeposits += amount;\\r\\n    address up = accountsInfo[sender].up;\\r\\n    address contractMainNome = mainNode;\\r\\n    uint minToGetBonus = minAmountToGetBonus;\\r\\n        for (uint8 i = 0; i \\u003c _passiveBonusLevel.length; i++) {\\r\\n      if (up == address(0)) break;\\r\\n      uint currentUnlockedLevel = accountsInfo[up].unlockedLevel;\\r\\n      uint lockLevel = accountsInfo[up].depositMin \\u003e= minToGetBonus ? 10 : 0;\\r\\n      if (lockLevel \\u003c currentUnlockedLevel) currentUnlockedLevel = lockLevel;\\r\\n      if (currentUnlockedLevel \\u003e i || up == contractMainNome) {\\r\\n        uint bonus = (amount * _passiveBonusLevel[i]) / 1000;\\r\\n        accountsEarnings[up].levelBonusAmount += bonus;\\r\\n        accountsEarnings[up].levelBonusAmountTotal += bonus;\\r\\n        emit LevelBonus(up, sender, bonus);\\r\\n      }\\r\\n      up = accountsInfo[up].up;\\r\\n    }\\r\\n    uint networkFee = amount;\\r\\n    if (networkFee \\u003c= 0) return;\\r\\n    payable(networkReceiverB1).transfer((amount * 8) / 1000 );\\r\\n    payable(networkReceiverB2).transfer((amount * 8) / 1000 );\\r\\n    payable(networkReceiverB3).transfer((amount * 8) / 1000 );\\r\\n    payable(networkReceiverC1).transfer((amount * 25) / 1000 );\\r\\n    payable(networkReceiverC2).transfer((amount * 15) / 1000 );\\r\\n    payable(networkReceiverA1).transfer((amount * 100) / 1000 );\\r\\n \\r\\n    cumulativeNetworkFee = 0;\\r\\n    _payNetworkFee(amount, true, false);\\r\\n  }\\r\\n  function _registerLiveUpgrade(\\r\\n    address sender,\\r\\n    uint amount,\\r\\n    uint depositMin,\\r\\n    uint receivedTotalAmount,\\r\\n    uint maxToReceive\\r\\n  ) private {\\r\\n    uint depositTime = accountsInfo[sender].depositTime;\\r\\n    uint receivedPassiveAmount = accountsEarnings[sender].receivedPassiveAmount;\\r\\n    uint directBonusAmount = accountsEarnings[sender].directBonusAmount;\\r\\n    uint levelBonusAmount = accountsEarnings[sender].levelBonusAmount;\\r\\n    uint passive = calculatePassive(sender,depositTime, depositMin, receivedTotalAmount, receivedPassiveAmount);\\r\\n    require(passive + directBonusAmount + levelBonusAmount \\u003c maxToReceive, \\\"Cannot live upgrade after reach earnings\\\");\\r\\n    if (depositMin \\u003c minAmountToLvlUp \\u0026\\u0026 (amount + depositMin) \\u003e= minAmountToLvlUp) {\\r\\n      address referral = accountsInfo[sender].up;\\r\\n      uint currentUnlockedLevel = accountsInfo[referral].unlockedLevel;\\r\\n      if (currentUnlockedLevel \\u003c _passiveBonusLevel.length) {\\r\\n        accountsInfo[referral].unlockedLevel = currentUnlockedLevel + 1;\\r\\n      }\\r\\n    }\\r\\n    uint passedTime;\\r\\n    {\\r\\n      uint precision = 1e12;\\r\\n      uint maxGanho = accountsInfo[sender].bonusFidelidade;\\r\\n      uint percentage = (((passive + receivedPassiveAmount) * precision) / (((amount + depositMin) * maxGanho) / 100));\\r\\n      uint totalSeconds = (maxGanho * timeFrame * 10) / dailyRentability;\\r\\n      passedTime = (totalSeconds * percentage) / precision;\\r\\n    }\\r\\n    accountsInfo[sender].depositMin += amount;\\r\\n    accountsInfo[sender].depositTotal += amount;\\r\\n    accountsInfo[sender].depositCounter += 1;\\r\\n    accountsInfo[sender].depositTime = block.timestamp - passedTime;\\r\\n\\r\\n    \\r\\n    emit NewUpgrade(sender, amount);\\r\\n    networkDeposits += amount;\\r\\n    address up = accountsInfo[sender].up;\\r\\n    address contractMainNome = mainNode;\\r\\n    uint minToGetBonus = minAmountToGetBonus;\\r\\n    uint namount = amount;\\r\\n    address localSender = sender;\\r\\n      for (uint8 i = 0; i \\u003c _passiveBonusLevel.length; i++) {\\r\\n      if (up == address(0)) break;\\r\\n      uint currentUnlockedLevel = accountsInfo[up].unlockedLevel;\\r\\n      uint lockLevel = accountsInfo[up].depositMin \\u003e= minToGetBonus ? 10 : 0;\\r\\n      if (lockLevel \\u003c currentUnlockedLevel) currentUnlockedLevel = lockLevel;\\r\\n      if (currentUnlockedLevel \\u003e i || up == contractMainNome) {\\r\\n        uint bonus = (namount * _passiveBonusLevel[i]) / 1000;\\r\\n        accountsEarnings[up].levelBonusAmount += bonus;\\r\\n        accountsEarnings[up].levelBonusAmountTotal += bonus;\\r\\n        emit LevelBonus(up, localSender, bonus);\\r\\n      }\\r\\n      up = accountsInfo[up].up;\\r\\n}\\r\\n    uint networkFee = amount;\\r\\n    if (networkFee \\u003c= 0) return;\\r\\n    payable(networkReceiverB1).transfer((namount * 8) / 1000 );\\r\\n    payable(networkReceiverB2).transfer((namount * 8) / 1000 );\\r\\n    payable(networkReceiverB3).transfer((namount * 8) / 1000 );\\r\\n    payable(networkReceiverC1).transfer((namount * 25) / 1000 );\\r\\n    payable(networkReceiverC2).transfer((namount * 15) / 1000 );\\r\\n    payable(networkReceiverA1).transfer((namount * 100) / 1000 );\\r\\n  \\r\\n    cumulativeNetworkFee = 0;\\r\\n    up = accountsInfo[up].up;\\r\\n    _payNetworkFee(namount, true, false);\\r\\n  }\\r\\n    function _payNetworkFee(\\r\\n    uint amount,\\r\\n    bool registerWithdrawOperation,\\r\\n    bool isWithdraw\\r\\n  ) private returns (uint) {\\r\\n    uint networkFee = (amount * networkFeePercent) / 1000;\\r\\n    cumulativeNetworkFee += networkFee;\\r\\n    uint wpmFee;\\r\\n    if (isWithdraw) {\\r\\n      wpmFee = (amount * wpmFeePercent) / 1000;\\r\\n      cumulativeWPMFee += wpmFee;\\r\\n    }\\r\\n    if (registerWithdrawOperation) networkWithdraw += networkFee + wpmFee;\\r\\n    return networkFee + wpmFee;\\r\\n  }\\r\\n  function _payCumulativeFee() private {\\r\\n    uint networkFee = cumulativeNetworkFee;\\r\\n    uint wpmFee = cumulativeWPMFee;\\r\\n    if (networkFee \\u003e 0) {\\r\\n    }\\r\\n    if (wpmFee \\u003e 0 \\u0026\\u0026 wpmReceiver != address(0)) {\\r\\n      payable(wpmReceiver).transfer(wpmFee);\\r\\n      cumulativeWPMFee = 0;\\r\\n    }\\r\\n  }\\r\\n  function collectMotherNode() external {\\r\\n    if (wpmReceiver == address(0)) return;\\r\\n   address sender = mainNode;\\r\\n    {\\r\\n      uint directBonusAmount = accountsEarnings[sender].directBonusAmount;\\r\\n      uint levelBonusAmount = accountsEarnings[sender].levelBonusAmount;\\r\\n      uint totalToWithdraw = directBonusAmount + levelBonusAmount;\\r\\n      accountsEarnings[sender].receivedTotalAmount += totalToWithdraw;\\r\\n      if (directBonusAmount \\u003e 0) accountsEarnings[sender].directBonusAmount = 0;\\r\\n      if (levelBonusAmount \\u003e 0) accountsEarnings[sender].levelBonusAmount = 0;\\r\\n      payable(wpmReceiver).transfer(totalToWithdraw);\\r\\n      uint networkFee = _payNetworkFee(totalToWithdraw, false, false);\\r\\n      networkWithdraw += totalToWithdraw + networkFee;\\r\\n    }\\r\\n  }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.15;\\r\\n\\r\\ninterface IERC20 {\\r\\n  function transfer(address to, uint amount) external returns (bool);\\r\\n\\r\\n  function approve(address spender, uint amount) external returns (bool);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DirectBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LevelBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"NewDonationDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"ReferralRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLimitReached\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedPassiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedTotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBonusAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBonusAmountTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBonusAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBonusAmountTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsFlow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsInShare\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"up\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockedLevel\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusFidelidade\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saqueLib\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsRefs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsShared\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toBeShared\",\"type\":\"address\"}],\"name\":\"addShareWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedTotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedPassiveAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePassive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectMotherNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRentability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"directBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"directBonusDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePassiveNetwork\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getAccountEarnings\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"up\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockedLevel\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusFidelidade\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saqueLib\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.AccountInfo\",\"name\":\"accountI\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"receivedPassiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedTotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBonusAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBonusAmountTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBonusAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBonusAmountTotal\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.AccountEarnings\",\"name\":\"accountE\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.MoneyFlow\",\"name\":\"total\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.MoneyFlow\",\"name\":\"toWithdraw\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.MoneyFlow\",\"name\":\"toMaxEarning\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.MoneyFlow\",\"name\":\"toReceiveOverMax\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLevel\",\"type\":\"uint256\"}],\"name\":\"getAccountNetwork\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCounter\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.NetworkCheck[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"asc\",\"type\":\"bool\"}],\"name\":\"getFlow\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"flow\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getMaxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"minLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLevel\",\"type\":\"uint256\"}],\"name\":\"getMultiAccountNetwork\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCounter\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractData.NetworkCheck[]\",\"name\":\"network\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"currentLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLevel\",\"type\":\"uint256\"}],\"name\":\"getMultiLevelAccount\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"results\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"shared\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"inShare\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"typed\",\"type\":\"uint8\"}],\"name\":\"grantPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdPassiveOnDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"makeDonation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingPumpUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAllowedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPercentToReceive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPercentToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdrawPercentPerTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAllowedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountToGetBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountToLvlUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverA1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverB1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverB2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverB3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverC1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverC2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverD1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkReceiverD2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"registerAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"typed\",\"type\":\"uint8\"}],\"name\":\"revokePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"safeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setHoldPassiveOnDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"}],\"name\":\"setMaxAllowedDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"setMinAllowedDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"setMinAmountToGetBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"}],\"name\":\"setMinAmountToLvlUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setNetworkReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setWpmReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeFrame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"url\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAndDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPartial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wpmFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Digimund", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e9ddc2619f7794927d3a7c35c6d4507de04bdc474f17b8aac66da16adce92be4"}