{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LCBridgev2Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nabstract contract Context {\\r\\n  function _msgSender() internal view virtual returns (address) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n  function _msgData() internal view virtual returns (bytes calldata) {\\r\\n    return msg.data;\\r\\n  }\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  constructor() {\\r\\n    _transferOwnership(_msgSender());\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    _checkOwner();\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function owner() public view virtual returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  function _checkOwner() internal view virtual {\\r\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() public virtual onlyOwner {\\r\\n    _transferOwnership(address(0));\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner) internal virtual {\\r\\n    address oldOwner = _owner;\\r\\n    _owner = newOwner;\\r\\n    emit OwnershipTransferred(oldOwner, newOwner);\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address to, uint256 amount) external returns (bool);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract LCBridgev2Token is Ownable {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  address public poolToken;\\r\\n  uint256 public chainId;\\r\\n  address public treasury;\\r\\n\\r\\n  mapping (address => bool) public noFeeWallets;\\r\\n  mapping (address => bool) public managers;\\r\\n\\r\\n  uint256 public swapFee = 5000;\\r\\n  uint256 public platformFee = 300000;\\r\\n  uint256 private constant coreDecimal = 1000000;\\r\\n  uint256 private constant MULTIPLIER = 1_0000_0000_0000_0000;\\r\\n\\r\\n  struct StakeInfo {\\r\\n    uint256 amount;   // Staked liquidity\\r\\n    uint256 debtReward;\\r\\n    uint256 rtr;\\r\\n    uint256 updatedAt;\\r\\n  }\\r\\n\\r\\n  struct SwapVoucher {\\r\\n    uint256 amount;\\r\\n    uint256 outChain;\\r\\n    address toAccount;\\r\\n    address refundAccount;\\r\\n  }\\r\\n\\r\\n  uint256 public totalReward = 0;\\r\\n  uint256 public prevReward = 0;\\r\\n  uint256 public rtr = 0;\\r\\n  uint256 public tvl;\\r\\n  mapping (address => StakeInfo) public userInfo;\\r\\n  uint256 private swapIndex = 1;\\r\\n  uint256 private unstakeDebtIndex = 1;\\r\\n  mapping (uint256 => SwapVoucher) public voucherLists;\\r\\n\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"LCBridgev2: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  event Swap(address operator, address receiver, address refund, uint256 amount, uint256 srcChainId, uint256 desChainId, uint256 swapIndex);\\r\\n  event Redeem(address operator, address account, uint256 amount, uint256 srcChainId, uint256 swapIndex);\\r\\n  event Stake(address account, uint256 amount);\\r\\n  event Unstake(address account, uint256 amount, bool force);\\r\\n  event UnstakeDebt(address account, uint256 amount, uint256 chainId, uint256 index);\\r\\n  event DebtUnstake(address account, uint256 amount, uint256 chainId, uint256 index);\\r\\n  event Claim(address acccount, uint256 amount);\\r\\n  event Refund(address operator, address account, uint256 index, uint256 amount);\\r\\n  event CutFee(uint256 fee, address treasury, uint256 treasuryFee, uint256 totalFee, uint256 tvl);\\r\\n\\r\\n  constructor(\\r\\n    address _poolToken,\\r\\n    uint256 _chainId,\\r\\n    address _treasury\\r\\n  )\\r\\n  {\\r\\n    require(_poolToken != address(0), \\\"LCBridgev2: Treasury\\\");\\r\\n    require(_treasury != address(0), \\\"LCBridgev2: Treasury\\\");\\r\\n    \\r\\n    poolToken = _poolToken;\\r\\n    chainId = _chainId;\\r\\n    treasury = _treasury;\\r\\n    managers[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  function swap(address _to, uint256 _amount, address _refund, uint256 _outChainID) public payable returns(uint256) {\\r\\n    uint256 amount = IERC20(poolToken).balanceOf(address(this));\\r\\n    IERC20(poolToken).safeTransferFrom(msg.sender, address(this), _amount);\\r\\n    amount = IERC20(poolToken).balanceOf(address(this)) - amount;\\r\\n    if (noFeeWallets[msg.sender] == false) {\\r\\n      amount = _cutFee(amount);\\r\\n    }\\r\\n    voucherLists[swapIndex] = SwapVoucher(amount, _outChainID, _to, _refund);\\r\\n    emit Swap(msg.sender, _to, _refund, amount, chainId, _outChainID, swapIndex);\\r\\n    swapIndex ++;\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function redeem(address account, uint256 amount, uint256 srcChainId, uint256 _swapIndex, uint256 operatorFee) public onlyManager returns(uint256) {\\r\\n    require(amount <= IERC20(poolToken).balanceOf(address(this)), \\\"LCBridgev2: Few redeem liquidity\\\");\\r\\n    require(amount >= operatorFee, \\\"LCBridgev2: Few redeem liquidity\\\");\\r\\n\\r\\n    amount -= operatorFee;\\r\\n    if (amount > 0) {\\r\\n      IERC20(poolToken).safeTransfer(account, amount);\\r\\n      emit Redeem(msg.sender, account, amount, srcChainId, _swapIndex);\\r\\n    }\\r\\n\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function refund(uint256 _index) public onlyManager returns(uint256) {\\r\\n    uint256 amount = voucherLists[_index].amount;\\r\\n    IERC20(poolToken).safeTransfer(voucherLists[_index].refundAccount, amount);\\r\\n    emit Refund(msg.sender, voucherLists[_index].refundAccount, _index, amount);\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function stake(address account, uint256 _amount) public payable returns(uint256) {\\r\\n    uint256 amount = IERC20(poolToken).balanceOf(address(this));\\r\\n    IERC20(poolToken).safeTransferFrom(msg.sender, address(this), _amount);\\r\\n    amount = IERC20(poolToken).balanceOf(address(this)) - amount;\\r\\n    userInfo[account].debtReward += getReward(account);\\r\\n\\r\\n    if (tvl > 0) {\\r\\n      rtr += (totalReward - prevReward) * MULTIPLIER / tvl;\\r\\n    }\\r\\n    else {\\r\\n      rtr = 0;\\r\\n    }\\r\\n    prevReward = totalReward;\\r\\n    tvl += amount;\\r\\n    \\r\\n    userInfo[account].amount += amount;\\r\\n    userInfo[account].rtr = rtr;\\r\\n    userInfo[account].updatedAt = block.timestamp;\\r\\n    emit Stake(account, amount);\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function unstake(address account, uint256 amount, bool force) public returns(uint256) {\\r\\n    require(account == msg.sender || managers[msg.sender] == true, \\\"LCBridgev2: wrong account\\\");\\r\\n    if (amount > userInfo[account].amount) {\\r\\n      amount = userInfo[account].amount;\\r\\n    }\\r\\n\\r\\n    uint256 reward = getReward(account);\\r\\n    if (reward > 0) {\\r\\n      claimReward(account);\\r\\n    }\\r\\n\\r\\n    if (amount > 0) {\\r\\n      uint256 liquidity = IERC20(poolToken).balanceOf(address(this));\\r\\n      uint256 unstakeAmount = amount;\\r\\n      if (liquidity < amount) {\\r\\n        unstakeAmount = liquidity;\\r\\n        if (force) {\\r\\n          emit UnstakeDebt(account, amount - liquidity, chainId, unstakeDebtIndex);\\r\\n          unstakeDebtIndex ++;\\r\\n        }\\r\\n        else {\\r\\n          amount = liquidity;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      IERC20(poolToken).safeTransfer(account, unstakeAmount);\\r\\n\\r\\n      tvl -= amount;\\r\\n      userInfo[account].amount -= amount;\\r\\n      emit Unstake(account, amount, force);\\r\\n    }\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function forceUnstake(address account, uint256 amount, uint256 _chainId, uint256 _debtIndex) public onlyManager {\\r\\n    IERC20(poolToken).safeTransfer(account, amount);\\r\\n    emit DebtUnstake(account, amount, _chainId, _debtIndex);\\r\\n  }\\r\\n\\r\\n  function getReward(address account) public view returns(uint256) {\\r\\n    uint256 reward = userInfo[account].debtReward;\\r\\n    if (userInfo[account].amount > 0) {\\r\\n      uint256 currentRtr = tvl > 0 ? (totalReward - prevReward) * MULTIPLIER / tvl : 0;\\r\\n      currentRtr += rtr;\\r\\n      if (currentRtr >= userInfo[account].rtr) {\\r\\n        reward += (currentRtr - userInfo[account].rtr) * userInfo[account].amount / MULTIPLIER;\\r\\n      }\\r\\n    }\\r\\n    return reward;\\r\\n  }\\r\\n\\r\\n  function claimReward(address account) public returns(uint256) {\\r\\n    uint256 reward = getReward(account);\\r\\n    uint256 debtReward = 0;\\r\\n    if (reward > 0) {\\r\\n      uint256 tmpTvl = IERC20(poolToken).balanceOf(address(this));\\r\\n      if (tmpTvl < reward) {\\r\\n        IERC20(poolToken).safeTransfer(account, tmpTvl);\\r\\n        debtReward = reward - tmpTvl;\\r\\n      }\\r\\n      else {\\r\\n        IERC20(poolToken).safeTransfer(account, reward);\\r\\n      }\\r\\n    }\\r\\n    uint256 currentRtr = tvl > 0 ? (totalReward - prevReward) * MULTIPLIER / tvl : 0;\\r\\n    rtr += currentRtr;\\r\\n    prevReward = totalReward;\\r\\n\\r\\n    userInfo[account].debtReward = debtReward;\\r\\n    userInfo[account].rtr = rtr;\\r\\n    userInfo[account].updatedAt = block.timestamp;\\r\\n    emit Claim(account, reward);\\r\\n    return reward;\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setNoFeeWallets(address account, bool access) public onlyManager {\\r\\n    noFeeWallets[account] = access;\\r\\n  }\\r\\n\\r\\n  function setSwapFee(uint256 _swapFee) public onlyManager {\\r\\n    swapFee = _swapFee;\\r\\n  }\\r\\n\\r\\n  function setPlatformFee(uint256 _platformFee) public onlyManager {\\r\\n    platformFee = _platformFee;\\r\\n  }\\r\\n\\r\\n  function setTreasury(address _treasury) public onlyManager {\\r\\n    treasury = _treasury;\\r\\n  }\\r\\n\\r\\n  function _cutFee(uint256 _amount) internal returns(uint256) {\\r\\n    if (_amount > 0) {\\r\\n      uint256 fee = _amount * swapFee / coreDecimal;\\r\\n      uint256 treasuryFee = fee * platformFee / coreDecimal;\\r\\n      if (treasuryFee > 0) {\\r\\n        IERC20(poolToken).safeTransfer(treasury, treasuryFee);\\r\\n      }\\r\\n      if (tvl > 0) {\\r\\n        totalReward += (fee - treasuryFee);\\r\\n      }\\r\\n      emit CutFee(fee, treasury, treasuryFee, totalReward, tvl);\\r\\n      return _amount - fee;\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasuryFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tvl\",\"type\":\"uint256\"}],\"name\":\"CutFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DebtUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapIndex\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"desChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapIndex\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"UnstakeDebt\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtIndex\",\"type\":\"uint256\"}],\"name\":\"forceUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noFeeWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prevReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operatorFee\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rtr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setNoFeeWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_platformFee\",\"type\":\"uint256\"}],\"name\":\"setPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_outChainID\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tvl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rtr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voucherLists\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outChain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundAccount\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LCBridgev2Token", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d0000000000000000000000000000000000000000000000000000000000000038000000000000000000000000b65f101f856b9036ec5e0521501d4d0c5146eaf4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}