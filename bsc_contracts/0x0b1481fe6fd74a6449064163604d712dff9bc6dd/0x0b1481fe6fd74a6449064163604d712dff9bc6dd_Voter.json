{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBribe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IBribe {\\n    function _deposit(uint amount, uint tokenId) external;\\n    function _withdraw(uint amount, uint tokenId) external;\\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function left(address token) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBribeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IBribeFactory {\\n    function createBribe() external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IGauge {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function getReward(address account, address[] memory tokens) external;\\n    function claimFees() external returns (uint claimed0, uint claimed1);\\n    function left(address token) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IGaugeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IGaugeFactory {\\n    function createGauge(address, address, address) external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IMinter {\\n    function update_period() external returns (uint);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IPair {\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function claimFees() external returns (uint, uint);\\n    function getAmountOut(uint amountIn, address tokenIn) external view returns (uint);\\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\\n    function mint(address to) external returns (uint liquidity);\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function stable() external view returns (bool);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function tokens() external returns (address, address);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPairFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IPairFactory {\\n    function admin() external view returns (address);\\n    function feeManagers(address feeManager) external view returns (bool);\\n    function allPairsLength() external view returns (uint);\\n    function isPair(address pair) external view returns (bool);\\n    function pairCodeHash() external pure returns (bytes32);\\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\\n    function getInitializable() external view returns (address, address, bool);\\n    function setPause(bool _state) external;\\n    function isPaused() external view returns (bool);\\n    function getFee(bool _stable) external view returns(uint256);\\n    function getRealFee(address _pair) external view returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\ninterface IVotingEscrow {\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n    }\\n\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\n    function epoch() external view returns (uint);\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\n    function point_history(uint loc) external view returns (Point memory);\\n    function checkpoint() external;\\n    function deposit_for(uint tokenId, uint value) external;\\n    function token() external view returns (address);\\n    function user_point_history__ts(uint tokenId, uint idx) external view returns (uint);\\n    function locked__end(uint _tokenId) external view returns (uint);\\n    function locked__amount(uint _tokenId) external view returns (uint);\\n    function approve(address spender, uint tokenId) external;\\n    function balanceOfNFT(uint) external view returns (uint);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function ownerOf(uint) external view returns (address);\\n    function transferFrom(address, address, uint) external;\\n    function totalSupply() external view returns (uint);\\n    function supply() external view returns (uint);\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n    function lockVote(uint tokenId) external;\\n    function isVoteExpired(uint tokenId) external view returns (bool);\\n    function voteExpiry(uint _tokenId) external view returns (uint);\\n    function attach(uint tokenId) external;\\n    function detach(uint tokenId) external;\\n    function voting(uint tokenId) external;\\n    function abstain(uint tokenId) external;\\n    function voted(uint tokenId) external view returns (bool);\\n    function withdraw(uint tokenId) external;\\n    function create_lock(uint value, uint duration) external returns (uint);\\n    function setVoter(address voter) external;\\n    function balanceOf(address owner) external view returns (uint);\\n    function safeTransferFrom(address from, address to, uint tokenId) external;\\n    function burn(uint _tokenId) external;\\n    function setAdmin(address _admin) external;\\n    function setArtProxy(address _proxy) external;\\n}\"\r\n    },\r\n    \"contracts/Voter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {IVotingEscrow} from \\\"./interfaces/IVotingEscrow.sol\\\";\\nimport {IPairFactory} from \\\"./interfaces/IPairFactory.sol\\\";\\nimport {IPair} from \\\"./interfaces/IPair.sol\\\";\\nimport {IGaugeFactory} from \\\"./interfaces/IGaugeFactory.sol\\\";\\nimport {IBribeFactory} from \\\"./interfaces/IBribeFactory.sol\\\";\\nimport {IGauge} from \\\"./interfaces/IGauge.sol\\\";\\nimport {IBribe} from \\\"./interfaces/IBribe.sol\\\";\\nimport {IMinter} from \\\"./interfaces/IMinter.sol\\\";\\n\\ncontract Voter {\\n\\n    address public immutable _ve; // the ve token that governs these contracts\\n    address public immutable factory; // the BaseV1Factory\\n    address internal immutable base;\\n    address public gaugeFactory;\\n    address public immutable bribeFactory;\\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\\n    address public minter;\\n    address public admin;\\n    address public pendingAdmin;\\n    uint256 public whitelistingFee;\\n    bool public permissionMode;\\n\\n    uint public totalWeight; // total voting weight\\n\\n    address[] public allGauges; // all gauges viable for incentives\\n    mapping(address => address) public gauges; // pair => maturity => gauge\\n    mapping(address => address) public poolForGauge; // gauge => pool\\n    mapping(address => address) public bribes; // gauge => bribe\\n    mapping(address => uint256) public weights; // gauge => weight\\n    mapping(uint => mapping(address => uint256)) public votes; // nft => gauge => votes\\n    mapping(uint => address[]) public gaugeVote; // nft => gauge\\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\\n    mapping(address => bool) public isGauge;\\n    mapping(address => bool) public isLive; // gauge => status (live or not)\\n    mapping(address => bool) public feeManagers;\\n\\n    mapping(address => bool) public isWhitelisted;\\n    mapping(address => mapping(address => bool)) public isReward;\\n    mapping(address => mapping(address => bool)) public isBribe;\\n\\n\\n    mapping(address => uint) public claimable;\\n    uint internal index;\\n    mapping(address => uint) internal supplyIndex;\\n\\n    event GaugeCreated(address indexed gauge, address creator, address indexed bribe, address indexed pair);\\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\\n    event Abstained(uint tokenId, uint256 weight);\\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\\n    event Whitelisted(address indexed whitelister, address indexed token);\\n    event Delisted(address indexed delister, address indexed token);\\n    event GaugeKilled(address indexed gauge);\\n    event GaugeRevived(address indexed gauge);\\n    event GaugeNotProcessed(address indexed gauge);\\n    event GaugeProcessed(address indexed gauge);\\n    event ErrorClaimingGaugeRewards(address indexed gauge, address[] tokens);\\n    event ErrorClaimingBribeRewards(address indexed bribe, address[] tokens);\\n    event ErrorClaimingGaugeFees(address indexed gauge);\\n    event ErrorClaimingBribeFees(address indexed bribe, uint tokenId, address[] tokens);\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Voter: only admin\\\");\\n        _;\\n    }\\n    \\n    /// @dev Only calls from the enabled fee managers are accepted.\\n    modifier onlyFeeManagers() \\n    {\\n        require(feeManagers[msg.sender], 'Voter: only fee manager');\\n        _;\\n    }\\n    \\n    modifier checkPermissionMode() {\\n        if(permissionMode) {\\n            require(msg.sender == admin, \\\"Permission Mode Is Active\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor(address __ve, address _factory, address  _gauges, address _bribes) {\\n        require(\\n            __ve != address(0) &&\\n            _factory != address(0) &&\\n            _gauges != address(0) &&\\n            _bribes != address(0),\\n            \\\"Voter: zero address provided in constructor\\\"\\n        );\\n        _ve = __ve;\\n        factory = _factory;\\n        base = IVotingEscrow(__ve).token();\\n        gaugeFactory = _gauges;\\n        bribeFactory = _bribes;\\n        minter = msg.sender;\\n        admin = msg.sender;\\n        permissionMode = false;\\n        whitelistingFee = 625000e18;\\n        \\n        feeManagers[msg.sender] = true;\\n        feeManagers[0x0c5D52630c982aE81b78AB2954Ddc9EC2797bB9c] = true;\\n        feeManagers[0x726461FA6e788bd8a79986D36F1992368A3e56eA] = true;\\n    }\\n\\n    // simple re-entrancy check\\n    uint internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function initialize(address[] memory _tokens, address _minter) external {\\n        require(msg.sender == minter);\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            _whitelist(_tokens[i]);\\n        }\\n        \\n        minter = _minter;\\n    }\\n\\n    function setAdmin(address _admin) external onlyAdmin {\\n        pendingAdmin = _admin;\\n    }\\n\\n    function acceptAdmin() external {\\n        require(msg.sender == pendingAdmin);\\n        admin = pendingAdmin;\\n    }\\n    \\n    function enablePermissionMode() external onlyAdmin {\\n        require(!permissionMode, \\\"Permission Mode Enabled\\\");\\n        permissionMode = true;\\n    }\\n\\n    function disablePermissionMode() external onlyAdmin {\\n        require(permissionMode, \\\"Permission Mode Disabled\\\");\\n        permissionMode = false;\\n    }\\n    \\n    function manageFeeManager(address feeManager, bool _value) external onlyAdmin\\n    {\\n        feeManagers[feeManager] = _value;\\n    }\\n\\n    function setReward(address _gauge, address _token, bool _status) external onlyAdmin {\\n        isReward[_gauge][_token] = _status;\\n    }\\n\\n    function setBribe(address _bribe, address _token, bool _status) external onlyAdmin {\\n        isBribe[_bribe][_token] = _status;\\n    }\\n    \\n    function setWhitelistingFee(uint256 _fee) external onlyFeeManagers {\\n        require(_fee > 0, 'Fee must be greater than zero');\\n        whitelistingFee = _fee;\\n    }\\n\\n    function killGauge(address _gauge) external onlyAdmin {\\n        require(isLive[_gauge], \\\"gauge is not live\\\");\\n        distribute(_gauge);\\n        isLive[_gauge] = false;\\n        claimable[_gauge] = 0;\\n        emit GaugeKilled(_gauge);\\n    }\\n\\n    function reviveGauge(address _gauge) external onlyAdmin {\\n        require(!isLive[_gauge], \\\"gauge is live\\\");\\n        isLive[_gauge] = true;\\n        emit GaugeRevived(_gauge);\\n    }\\n\\n    function reset(uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        _reset(_tokenId);\\n        IVotingEscrow(_ve).abstain(_tokenId);\\n    }\\n\\n    function _reset(uint _tokenId) internal {\\n        require(IVotingEscrow(_ve).isVoteExpired(_tokenId),\\\"Vote Locked!\\\");\\n        address[] storage _gaugeVote = gaugeVote[_tokenId];\\n        uint _gaugeVoteCnt = _gaugeVote.length;\\n        uint256 _totalWeight = 0;\\n\\n        for (uint i = 0; i < _gaugeVoteCnt; i++) {\\n            address _gauge = _gaugeVote[i];\\n            uint256 _votes = votes[_tokenId][_gauge];\\n            if (_votes != 0) {\\n                _updateFor(_gauge);\\n                weights[_gauge] -= _votes;\\n                votes[_tokenId][_gauge] -= _votes;\\n                IBribe(bribes[_gauge])._withdraw(uint256(_votes), _tokenId);\\n                _totalWeight += _votes;\\n                emit Abstained(_tokenId, _votes);\\n            }\\n        }\\n        totalWeight -= uint256(_totalWeight);\\n        usedWeights[_tokenId] = 0;\\n        delete gaugeVote[_tokenId];\\n    }\\n\\n    function poke(uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        address[] memory _gaugeVote = gaugeVote[_tokenId];\\n        uint _gaugeCnt = _gaugeVote.length;\\n        uint256[] memory _weights = new uint256[](_gaugeCnt);\\n\\n        for (uint i = 0; i < _gaugeCnt; i++) {\\n            _weights[i] = votes[_tokenId][_gaugeVote[i]];\\n        }\\n\\n        _vote(_tokenId, _gaugeVote, _weights);\\n    }\\n\\n    function _vote(uint _tokenId, address[] memory _gaugeVote, uint256[] memory _weights) internal {\\n        _reset(_tokenId);\\n        // Lock vote for 1 WEEK\\n        IVotingEscrow(_ve).lockVote(_tokenId);\\n        uint _gaugeCnt = _gaugeVote.length;\\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\\n        uint256 _totalVoteWeight = 0;\\n        uint256 _totalWeight = 0;\\n        uint256 _usedWeight = 0;\\n\\n        for (uint i = 0; i < _gaugeCnt; i++) {\\n            _totalVoteWeight += _weights[i];\\n        }\\n\\n        for (uint i = 0; i < _gaugeCnt; i++) {\\n            address _gauge = _gaugeVote[i];\\n            if (isGauge[_gauge]) {\\n                uint256 _gaugeWeight = _weights[i] * _weight / _totalVoteWeight;\\n                require(votes[_tokenId][_gauge] == 0);\\n                require(_gaugeWeight != 0);\\n                _updateFor(_gauge);\\n\\n                gaugeVote[_tokenId].push(_gauge);\\n\\n                weights[_gauge] += _gaugeWeight;\\n                votes[_tokenId][_gauge] += _gaugeWeight;\\n                IBribe(bribes[_gauge])._deposit(_gaugeWeight, _tokenId);\\n                _usedWeight += _gaugeWeight;\\n                _totalWeight += _gaugeWeight;\\n                emit Voted(msg.sender, _tokenId, _gaugeWeight);\\n            }\\n        }\\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\\n        totalWeight += _totalWeight;\\n        usedWeights[_tokenId] = _usedWeight;\\n    }\\n\\n    // @param _tokenId The id of the veNFT to vote with\\n    // @param _gaugeVote The list of gauges to vote for\\n    // @param _weights The list of weights to vote for each gauge\\n    // @notice the sum of weights is the total weight of the veNFT at max\\n    function vote(uint tokenId, address[] calldata _gaugeVote, uint256[] calldata _weights) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        require(_gaugeVote.length == _weights.length);\\n        uint _lockEnd = IVotingEscrow(_ve).locked__end(tokenId);\\n        require(_nextPeriod() <= _lockEnd, \\\"lock expires soon\\\");\\n        _vote(tokenId, _gaugeVote, _weights);\\n    }\\n\\n    function whitelist(address _token) public checkPermissionMode {\\n        _safeTransferFrom(base, msg.sender, address(0), whitelistingFee);\\n        _whitelist(_token);\\n    }\\n    \\n    function whitelistBatch(address[] memory _tokens) external onlyAdmin {\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            _whitelist(_tokens[i]);\\n        }\\n    }\\n\\n    function _whitelist(address _token) internal {\\n        require(!isWhitelisted[_token]);\\n        isWhitelisted[_token] = true;\\n        emit Whitelisted(msg.sender, _token);\\n    }\\n    \\n    function delist(address _token) public onlyAdmin {\\n        require(isWhitelisted[_token], \\\"!whitelisted\\\");\\n        isWhitelisted[_token] = false;\\n        emit Delisted(msg.sender, _token);\\n    }\\n\\n    function createGauge(address _pair) external returns (address) {\\n        require(gauges[_pair] == address(0x0), \\\"exists\\\");\\n        require(IPairFactory(factory).isPair(_pair), \\\"!pair\\\");\\n        (address _tokenA, address _tokenB) = IPair(_pair).tokens();\\n        require(isWhitelisted[_tokenA] && isWhitelisted[_tokenB], \\\"!whitelisted\\\");\\n        address _bribe = IBribeFactory(bribeFactory).createBribe();\\n        address _gauge = IGaugeFactory(gaugeFactory).createGauge(_pair, _bribe, _ve);\\n        IERC20(base).approve(_gauge, type(uint).max);\\n        bribes[_gauge] = _bribe;\\n        gauges[_pair] = _gauge;\\n        poolForGauge[_gauge] = _pair;\\n        isGauge[_gauge] = true;\\n        isLive[_gauge] = true;\\n        isReward[_gauge][_tokenA] = true;\\n        isReward[_gauge][_tokenB] = true;\\n        isReward[_gauge][base] = true;\\n        isBribe[_bribe][_tokenA] = true;\\n        isBribe[_bribe][_tokenB] = true;\\n        _updateFor(_gauge);\\n        allGauges.push(_gauge);\\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _pair);\\n        return _gauge;\\n    }\\n\\n    function attachTokenToGauge(uint tokenId, address account) external {\\n        require(isGauge[msg.sender]);\\n        if (tokenId > 0) IVotingEscrow(_ve).attach(tokenId);\\n        emit Attach(account, msg.sender, tokenId);\\n    }\\n\\n    function emitDeposit(uint tokenId, address account, uint amount) external {\\n        require(isGauge[msg.sender]);\\n        emit Deposit(account, msg.sender, tokenId, amount);\\n    }\\n\\n    function detachTokenFromGauge(uint tokenId, address account) external {\\n        require(isGauge[msg.sender]);\\n        if (tokenId > 0) IVotingEscrow(_ve).detach(tokenId);\\n        emit Detach(account, msg.sender, tokenId);\\n    }\\n\\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\\n        require(isGauge[msg.sender]);\\n        emit Withdraw(account, msg.sender, tokenId, amount);\\n    }\\n\\n    function length() external view returns (uint) {\\n        return allGauges.length;\\n    }\\n\\n    // @notice called by Minter contract to distribute weekly rewards\\n    // @param _amount the amount of tokens distributed\\n    function notifyRewardAmount(uint amount) external {\\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\\n        if (_ratio > 0) {\\n            index += _ratio;\\n        }\\n        emit NotifyReward(msg.sender, base, amount);\\n    }\\n\\n    function updateFor(address[] memory _gauges) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            _updateFor(_gauges[i]);\\n        }\\n    }\\n\\n    function updateForRange(uint start, uint end) public {\\n        for (uint i = start; i < end; i++) {\\n            _updateFor(allGauges[i]);\\n        }\\n    }\\n\\n    function updateAll() external {\\n        updateForRange(0, allGauges.length);\\n    }\\n\\n    // @notice update a gauge eligibility for rewards to the current index\\n    // @param _gauge the gauge to update\\n    function updateGauge(address _gauge) external {\\n        _updateFor(_gauge);\\n    }\\n\\n    function _updateFor(address _gauge) internal {\\n        uint256 _supplied = weights[_gauge];\\n        if (_supplied > 0) {\\n            uint _supplyIndex = supplyIndex[_gauge];\\n            uint _index = index; // get global index0 for accumulated distro\\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\\n            if (_delta > 0) {\\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\\n                if (isLive[_gauge]) {\\n                    claimable[_gauge] += _share;\\n                }\\n            }\\n        } else {\\n            supplyIndex[_gauge] = index; // new users are set to the default global state\\n        }\\n    }\\n\\n    // @notice allow a gauge depositor to claim earned rewards if any\\n    // @param _gauges list of gauges contracts to claim rewards on\\n    // @param _tokens list of  tokens to claim\\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            try IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]) {\\n                \\n            } catch {\\n                emit ErrorClaimingGaugeRewards(_gauges[i], _tokens[i]);\\n            }\\n        }\\n    }\\n\\n    // @notice allow a voter to claim earned bribes if any\\n    // @param _bribes list of bribes contracts to claims bribes on\\n    // @param _tokens list of the tokens to claim\\n    // @param _tokenId the ID of veNFT to claim bribes for\\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        for (uint i = 0; i < _bribes.length; i++) {\\n            try IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]) {\\n                \\n            } catch {\\n                emit ErrorClaimingBribeRewards(_bribes[i], _tokens[i]);\\n            }\\n        }\\n    }\\n\\n    // @notice allow voter to claim earned fees\\n    // @param _fees list of bribes contracts to claim fees on\\n    // @param _tokens list of the tokens to claim\\n    // @param _tokenId the ID of veNFT to claim fees for\\n    function claimFees(address[] memory _fees, address[][] memory _tokens, uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        for (uint i = 0; i < _fees.length; i++) {\\n            try IBribe(_fees[i]).getRewardForOwner(_tokenId, _tokens[i]) {\\n                \\n            } catch {\\n                emit ErrorClaimingBribeFees(_fees[i], _tokenId, _tokens[i]);\\n            }\\n        }\\n    }\\n\\n    // @notice distribute earned fees to the bribe contract for a given gauge\\n    // @param _gauges the gauges to distribute fees for\\n    function distributeFees(address[] memory _gauges) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            try IGauge(_gauges[i]).claimFees() {\\n                \\n            } catch {\\n                emit ErrorClaimingGaugeFees(_gauges[i]);\\n            }\\n        }\\n    }\\n\\n    // @notice distribute earned fees to the bribe contract for all gauges\\n    function distroFees() external {\\n        for (uint i = 0; i < allGauges.length; i++) {\\n            try IGauge(allGauges[i]).claimFees() {\\n                \\n            } catch {\\n                emit ErrorClaimingGaugeFees(allGauges[i]);\\n            }\\n        }\\n    }\\n\\n    // @notice distribute fair share of rewards to a gauge\\n    // @param _gauge the gauge to distribute rewards to\\n    function distribute(address _gauge) public lock {\\n        IMinter(minter).update_period();\\n        _updateFor(_gauge);\\n        uint _claimable = claimable[_gauge];\\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\\n            claimable[_gauge] = 0;\\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\\n            emit DistributeReward(msg.sender, _gauge, _claimable);\\n        }\\n    }\\n\\n    function distro() external {\\n        distributeRange(0, allGauges.length);\\n    }\\n\\n    function distributeRange(uint start, uint finish) public {\\n        for (uint x = start; x < finish; x++) {\\n            try this.distribute(allGauges[x]) {\\n                emit GaugeProcessed(allGauges[x]);\\n            } catch {\\n                emit GaugeNotProcessed(allGauges[x]);\\n            }\\n        }\\n    }\\n\\n    function distributeGauges(address[] memory _gauges) external {\\n        for (uint x = 0; x < _gauges.length; x++) {\\n            try this.distribute(_gauges[x]) {\\n                emit GaugeProcessed(allGauges[x]);\\n            } catch {\\n                emit GaugeNotProcessed(allGauges[x]);\\n            }\\n        }\\n    }\\n\\n    // @notice current active vote period\\n    // @return the UNIX timestamp of the beginning of the current vote period\\n    function _activePeriod() internal view returns (uint activePeriod) {\\n        activePeriod = block.timestamp / DURATION * DURATION;\\n    }\\n\\n    // @notice next vote period\\n    // @return the UNIX timestamp of the beginning of the next vote period\\n    function _nextPeriod() internal view returns(uint nextPeriod) {\\n        nextPeriod = (block.timestamp + DURATION) / DURATION * DURATION;\\n    }\\n\\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauges\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bribes\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Abstained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Attach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Delisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Detach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bribe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"ErrorClaimingBribeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bribe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"ErrorClaimingBribeRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"ErrorClaimingGaugeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"ErrorClaimingGaugeRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bribe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"GaugeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeNotProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeRevived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotifyReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allGauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"attachTokenToGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bribes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bribes\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimBribes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fees\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"createGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"delist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"detachTokenFromGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disablePermissionMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distributeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distributeGauges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"name\":\"distributeRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distro\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distroFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enablePermissionMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeManagers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBribe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGauge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"killGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"manageFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permissionMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolForGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"reviveGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bribe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setWhitelistingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"updateFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"updateForRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"updateGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_gaugeVote\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"whitelistBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Voter", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000006aca098fa93dad7a872f6dcb989f8b4a3afc334200000000000000000000000012508dd9108abab2c5fd8fc6e4984e46a3cf7824000000000000000000000000b33f66f27d8d8282ac1f55f98cd83503e90128e9000000000000000000000000c8c5172879f0b7e88cc03ca20835dbe9e283386e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}