{"SourceCode": "// File: contracts/intf/IERC20.sol\r\n\r\n// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @author LAVA\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author LAVA\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/InitializableOwnable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @author LAVA\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"LAVA_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/LAVAToken/iLAVAToken.sol\r\ninterface IGovernance {\r\n    function getLockediLAVA(address account) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface IAirdrop {\r\n    function deposit(address account, uint256 _amount) external;\r\n    function withdraw(address account, uint256 _amount) external; \r\n}\r\n\r\n\r\n// import \"@nomiclabs/buidler/console.sol\";\r\n\r\n\r\ncontract iLAVAToken is InitializableOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Storage(ERC20) ============\r\n\r\n    string public name = \"iLAVA Membership Token\";\r\n    string public symbol = \"iLAVA\";\r\n    uint8 public decimals = 18;\r\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\r\n\r\n    // ============ Storage ============\r\n\r\n    address public immutable _LAVA_TOKEN_;\r\n    address public immutable _LAVA_TEAM_;\r\n    address public _DOOD_GOV_;\r\n\r\n    bool public _CAN_TRANSFER_;\r\n\r\n    // staking reward parameters\r\n    uint256 public _LAVA_PER_BLOCK_;\r\n    uint256 public _SUPERIOR_RATIO_ = 0;\r\n    uint256 public constant _LAVA_RATIO_ = 100;\r\n    uint256 public _LAVA_FEE_BURN_RATIO_;\r\n    address public _LAVA_BURN_ADDRESS_;\r\n\r\n    uint256 public _FEE_RATIO = 5 * 10**16;\r\n    uint256 public _MAX_FEE_RATIO = 20 * 10**16;\r\n\r\n    // accounting\r\n    uint112 public alpha = 10**18; // 1\r\n    uint112 public _TOTAL_BLOCK_DISTRIBUTION_;\r\n    uint32 public _LAST_REWARD_BLOCK_;\r\n\r\n    uint256 public _TOTAL_BLOCK_REWARD_;\r\n    uint256 public _TOTAL_STAKING_POWER_;\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    uint256 public totalUsers;\r\n    mapping(address => bool) public isUser;\r\n\r\n    uint256 public totalWithdrawFee;\r\n    uint256 public totalBurnLAVA;\r\n\r\n    struct UserInfo {\r\n        uint128 stakingPower;\r\n        uint128 superiorSP;\r\n        address superior;\r\n        uint256 credit;\r\n        uint256 originAmount;\r\n    }\r\n\r\n    IAirdrop public airdropController;\r\n\r\n\r\n    // ============ Events ============\r\n\r\n    event MintILAVA(address user, address superior, uint256 mintLAVA);\r\n    event RedeemILAVA(address user, uint256 receiveLAVA, uint256 burnLAVA, uint256 feeLAVA);\r\n    event DonateLAVA(address user, uint256 donateLAVA);\r\n    event SetCantransfer(bool allowed);\r\n\r\n    event PreDeposit(uint256 lavaAmount);\r\n    event ChangePerReward(uint256 lavaPerBlock);\r\n    event UpdateLAVAFeeBurnRatio(uint256 lavaFeeBurnRatio);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier canTransfer() {\r\n        require(_CAN_TRANSFER_, \"iLAVAToken: not allowed transfer\");\r\n        _;\r\n    }\r\n\r\n    modifier balanceEnough(address account, uint256 amount) {\r\n        require(availableBalanceOf(account) >= amount, \"iLAVAToken: available amount not enough\");\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address lavaGov,\r\n        address lavaToken,\r\n        address lavaTeam\r\n    ) public {\r\n        _DOOD_GOV_ = lavaGov;\r\n        _LAVA_TOKEN_ = lavaToken;\r\n        _LAVA_TEAM_ = lavaTeam;\r\n    }\r\n\r\n    // ============ Ownable Functions ============`\r\n\r\n    function setAirdropController(address _controller) public onlyOwner {\r\n        airdropController = IAirdrop(_controller);\r\n    }\r\n\r\n    function setCantransfer(bool allowed) public onlyOwner {\r\n        _CAN_TRANSFER_ = allowed;\r\n        emit SetCantransfer(allowed);\r\n    }\r\n\r\n    function changePerReward(uint256 lavaPerBlock) public onlyOwner {\r\n        _updateAlpha();\r\n        _LAVA_PER_BLOCK_ = lavaPerBlock;\r\n        emit ChangePerReward(lavaPerBlock);\r\n    }\r\n\r\n    function updateLAVAFeeBurnRatio(uint256 lavaFeeBurnRatio) public onlyOwner {\r\n        _LAVA_FEE_BURN_RATIO_ = lavaFeeBurnRatio;\r\n        emit UpdateLAVAFeeBurnRatio(_LAVA_FEE_BURN_RATIO_);\r\n    }\r\n\r\n    function updateLAVAFeeBurnAddress(address addr) public onlyOwner{\r\n        _LAVA_BURN_ADDRESS_ = addr;\r\n    }\r\n\r\n    function updateGovernance(address governance) public onlyOwner {\r\n        _DOOD_GOV_ = governance;\r\n    }\r\n\r\n    function updateSuperiorRatio(uint256 superiorRatio) public onlyOwner {\r\n        _SUPERIOR_RATIO_ = superiorRatio;\r\n    }\r\n\r\n    function updateFeeRatio(uint256 feeRatio) public onlyOwner {\r\n        require(feeRatio <= _MAX_FEE_RATIO, \"_FEE_RATIO exceeded\");\r\n        _FEE_RATIO = feeRatio;\r\n    }\r\n\r\n    // ============ Mint & Redeem & Donate ============\r\n\r\n    function mint(uint256 lavaAmount, address superiorAddress) public {\r\n        require(\r\n            superiorAddress != address(0) && superiorAddress != msg.sender,\r\n            \"iLAVAToken: Superior INVALID\"\r\n        );\r\n        require(lavaAmount > 0, \"iLAVAToken: must mint greater than 0\");\r\n\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        if (user.superior == address(0)) {\r\n            require(\r\n                superiorAddress == _LAVA_TEAM_ || userInfo[superiorAddress].superior != address(0),\r\n                \"iLAVAToken: INVALID_SUPERIOR_ADDRESS\"\r\n            );\r\n            user.superior = superiorAddress;\r\n        }\r\n\r\n        _updateAlpha();\r\n\r\n        IERC20(_LAVA_TOKEN_).transferFrom(msg.sender, address(this), lavaAmount);\r\n\r\n        uint256 newStakingPower = DecimalMath.divFloor(lavaAmount, alpha);\r\n\r\n        _mint(user, newStakingPower);\r\n\r\n        user.originAmount = user.originAmount.add(lavaAmount);\r\n        \r\n        if(!isUser[msg.sender]){\r\n            isUser[msg.sender] = true;\r\n            totalUsers = totalUsers.add(1);\r\n        }\r\n\r\n        if(address(airdropController) != address(0)){\r\n            airdropController.deposit(msg.sender, newStakingPower);\r\n        }\r\n\r\n\r\n        emit MintILAVA(msg.sender, superiorAddress, lavaAmount);\r\n    }\r\n\r\n    function redeem(uint256 ilavaAmount, bool all) public balanceEnough(msg.sender, ilavaAmount) {\r\n\r\n        _updateAlpha();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        uint256 lavaAmount;\r\n        uint256 stakingPower;\r\n\r\n        if (all) {\r\n            stakingPower = uint256(user.stakingPower).sub(DecimalMath.divFloor(user.credit, alpha));\r\n            lavaAmount = DecimalMath.mulFloor(stakingPower, alpha);\r\n        } else {\r\n            lavaAmount = ilavaAmount.mul(_LAVA_RATIO_);\r\n            stakingPower = DecimalMath.divFloor(lavaAmount, alpha);\r\n        }\r\n\r\n        _redeem(user, stakingPower);\r\n\r\n        (uint256 lavaReceive, uint256 burnLAVAAmount, uint256 withdrawFeeLAVAAmount) = getWithdrawResult(lavaAmount);\r\n        \r\n        IERC20(_LAVA_TOKEN_).transfer(msg.sender, lavaReceive);\r\n        \r\n        if (burnLAVAAmount > 0) {\r\n            IERC20(_LAVA_TOKEN_).transfer(_LAVA_BURN_ADDRESS_, burnLAVAAmount);\r\n        }\r\n        \r\n        if (withdrawFeeLAVAAmount > 0) {\r\n            alpha = uint112(\r\n                uint256(alpha).add(\r\n                    DecimalMath.divFloor(withdrawFeeLAVAAmount, _TOTAL_STAKING_POWER_)\r\n                )\r\n            );\r\n        }\r\n\r\n        if (withdrawFeeLAVAAmount > 0) {\r\n            totalWithdrawFee = totalWithdrawFee.add(withdrawFeeLAVAAmount); \r\n        }\r\n\r\n        if(burnLAVAAmount > 0){\r\n            totalBurnLAVA = totalBurnLAVA.add(burnLAVAAmount);\r\n        }\r\n\r\n        if(user.originAmount <= lavaAmount){\r\n            user.originAmount = 0;\r\n        }\r\n        else{\r\n            user.originAmount = user.originAmount.sub(lavaAmount);\r\n        }\r\n\r\n        if(all){\r\n            if(isUser[msg.sender]){\r\n                isUser[msg.sender] = false;\r\n                if(totalUsers > 0){\r\n                    totalUsers = totalUsers.sub(1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(address(airdropController) != address(0)){\r\n            airdropController.withdraw(msg.sender, stakingPower);\r\n        }\r\n        \r\n        emit RedeemILAVA(msg.sender, lavaReceive, burnLAVAAmount, withdrawFeeLAVAAmount);\r\n    }\r\n\r\n    function donate(uint256 lavaAmount) public {\r\n        IERC20(_LAVA_TOKEN_).transferFrom(msg.sender, address(this), lavaAmount);\r\n\r\n        alpha = uint112(\r\n            uint256(alpha).add(DecimalMath.divFloor(lavaAmount, _TOTAL_STAKING_POWER_))\r\n        );\r\n        emit DonateLAVA(msg.sender, lavaAmount);\r\n    }\r\n\r\n    function preDepositedBlockReward(uint256 lavaAmount) public {\r\n        IERC20(_LAVA_TOKEN_).transferFrom(msg.sender, address(this), lavaAmount);\r\n        _TOTAL_BLOCK_REWARD_ = _TOTAL_BLOCK_REWARD_.add(lavaAmount);\r\n        emit PreDeposit(lavaAmount);\r\n    }\r\n\r\n    // ============ ERC20 Functions ============\r\n\r\n    function totalSupply() public view returns (uint256 iLAVASupply) {\r\n        uint256 totalLAVA = IERC20(_LAVA_TOKEN_).balanceOf(address(this));\r\n        (,uint256 curDistribution) = getLatestAlpha();\r\n        uint256 actualLAVA = totalLAVA.sub(_TOTAL_BLOCK_REWARD_.sub(curDistribution.add(_TOTAL_BLOCK_DISTRIBUTION_)));\r\n        iLAVASupply = actualLAVA / _LAVA_RATIO_;\r\n    }\r\n    \r\n    function balanceOf(address account) public view returns (uint256 iLAVAAmount) {\r\n        iLAVAAmount = lavaBalanceOf(account) / _LAVA_RATIO_;\r\n    }\r\n\r\n    function transfer(address to, uint256 iLAVAAmount) public returns (bool) {\r\n        _updateAlpha();\r\n        _transfer(msg.sender, to, iLAVAAmount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 iLAVAAmount) canTransfer public returns (bool) {\r\n        _ALLOWED_[msg.sender][spender] = iLAVAAmount;\r\n        emit Approval(msg.sender, spender, iLAVAAmount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 iLAVAAmount\r\n    ) public returns (bool) {\r\n        require(iLAVAAmount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n        _updateAlpha();\r\n        _transfer(from, to, iLAVAAmount);\r\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(iLAVAAmount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _ALLOWED_[owner][spender];\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getLatestAlpha() public view returns (uint256 newAlpha, uint256 curDistribution) {\r\n        if (_LAST_REWARD_BLOCK_ == 0) {\r\n            curDistribution = 0;\r\n        } else {\r\n            // curDistribution = _LAVA_PER_BLOCK_ * (block.number - _LAST_REWARD_BLOCK_);\r\n            if(_TOTAL_BLOCK_REWARD_ <= _TOTAL_BLOCK_DISTRIBUTION_){\r\n                curDistribution = 0;\r\n            }\r\n            else{\r\n                uint256 _curDistribution = _LAVA_PER_BLOCK_ * (block.number - _LAST_REWARD_BLOCK_);\r\n                uint256 diff = _TOTAL_BLOCK_REWARD_.sub(_TOTAL_BLOCK_DISTRIBUTION_);\r\n                curDistribution = diff < _curDistribution ? diff : _curDistribution;\r\n            }\r\n        }\r\n        if (_TOTAL_STAKING_POWER_ > 0) {\r\n            newAlpha = uint256(alpha).add(DecimalMath.divFloor(curDistribution, _TOTAL_STAKING_POWER_));\r\n        } else {\r\n            newAlpha = alpha;\r\n        }\r\n    }\r\n\r\n    function availableBalanceOf(address account) public view returns (uint256 iLAVAAmount) {\r\n        if (_DOOD_GOV_ == address(0)) {\r\n            iLAVAAmount = balanceOf(account);\r\n        } else {\r\n            uint256 lockediLAVAAmount = IGovernance(_DOOD_GOV_).getLockediLAVA(account);\r\n            iLAVAAmount = balanceOf(account).sub(lockediLAVAAmount);\r\n        }\r\n    }\r\n\r\n    function lavaBalanceOf(address account) public view returns (uint256 lavaAmount) {\r\n        UserInfo memory user = userInfo[account];\r\n        (uint256 newAlpha,) = getLatestAlpha();\r\n        uint256 nominalLAVA =  DecimalMath.mulFloor(uint256(user.stakingPower), newAlpha);\r\n        if(nominalLAVA > user.credit) {\r\n            lavaAmount = nominalLAVA - user.credit;\r\n        }else {\r\n            lavaAmount = 0;\r\n        }\r\n    }\r\n\r\n    function getWithdrawResult(uint256 lavaAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 lavaReceive,\r\n            uint256 burnLAVAAmount,\r\n            uint256 withdrawFeeLAVAAmount\r\n        )\r\n    {\r\n        uint256 feeRatio = _FEE_RATIO;\r\n\r\n        withdrawFeeLAVAAmount = DecimalMath.mulFloor(lavaAmount, feeRatio);\r\n        lavaReceive = lavaAmount.sub(withdrawFeeLAVAAmount);\r\n\r\n        burnLAVAAmount = DecimalMath.mulFloor(withdrawFeeLAVAAmount, _LAVA_FEE_BURN_RATIO_);\r\n        withdrawFeeLAVAAmount = withdrawFeeLAVAAmount.sub(burnLAVAAmount);\r\n    }\r\n\r\n    function getLAVAWithdrawFeeRatio() public view returns (uint256) {\r\n        return _FEE_RATIO;\r\n    }\r\n\r\n    function getSuperior(address account) public view returns (address superior) {\r\n        return userInfo[account].superior;\r\n    }\r\n\r\n    function getUserStakingPower(address account) public view returns (uint256){\r\n        return userInfo[account].stakingPower;\r\n    }\r\n\r\n    // ============ Internal Functions ============\r\n\r\n    function _updateAlpha() internal {\r\n        (uint256 newAlpha, uint256 curDistribution) = getLatestAlpha();\r\n        uint256 newTotalDistribution = curDistribution.add(_TOTAL_BLOCK_DISTRIBUTION_);\r\n        require(newAlpha <= uint112(-1) && newTotalDistribution <= uint112(-1), \"OVERFLOW\");\r\n        alpha = uint112(newAlpha);\r\n        _TOTAL_BLOCK_DISTRIBUTION_ = uint112(newTotalDistribution);\r\n        _LAST_REWARD_BLOCK_ = uint32(block.number);\r\n    }\r\n\r\n    function _mint(UserInfo storage to, uint256 stakingPower) internal {\r\n        require(stakingPower <= uint128(-1), \"OVERFLOW\");\r\n        UserInfo storage superior = userInfo[to.superior];\r\n        uint256 superiorIncreSP = DecimalMath.mulFloor(stakingPower, _SUPERIOR_RATIO_);\r\n        uint256 superiorIncreCredit = DecimalMath.mulFloor(superiorIncreSP, alpha);\r\n\r\n        to.stakingPower = uint128(uint256(to.stakingPower).add(stakingPower));\r\n        to.superiorSP = uint128(uint256(to.superiorSP).add(superiorIncreSP));\r\n\r\n        superior.stakingPower = uint128(uint256(superior.stakingPower).add(superiorIncreSP));\r\n        superior.credit = uint128(uint256(superior.credit).add(superiorIncreCredit));\r\n\r\n        _TOTAL_STAKING_POWER_ = _TOTAL_STAKING_POWER_.add(stakingPower).add(superiorIncreSP);\r\n    }\r\n\r\n    function _redeem(UserInfo storage from, uint256 stakingPower) internal {\r\n        from.stakingPower = uint128(uint256(from.stakingPower).sub(stakingPower));\r\n\r\n        // superior decrease sp = min(stakingPower*0.1, from.superiorSP)\r\n        uint256 superiorDecreSP = DecimalMath.mulFloor(stakingPower, _SUPERIOR_RATIO_);\r\n        superiorDecreSP = from.superiorSP <= superiorDecreSP ? from.superiorSP : superiorDecreSP;\r\n        from.superiorSP = uint128(uint256(from.superiorSP).sub(superiorDecreSP));\r\n\r\n        UserInfo storage superior = userInfo[from.superior];\r\n        uint256 creditSP = DecimalMath.divFloor(superior.credit, alpha);\r\n\r\n        if (superiorDecreSP >= creditSP) {\r\n            superior.credit = 0;\r\n            superior.stakingPower = uint128(uint256(superior.stakingPower).sub(creditSP));\r\n        } else {\r\n            superior.credit = uint128(\r\n                uint256(superior.credit).sub(DecimalMath.mulFloor(superiorDecreSP, alpha))\r\n            );\r\n            superior.stakingPower = uint128(uint256(superior.stakingPower).sub(superiorDecreSP));\r\n        }\r\n\r\n        _TOTAL_STAKING_POWER_ = _TOTAL_STAKING_POWER_.sub(stakingPower).sub(superiorDecreSP);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 iLAVAAmount\r\n    ) internal canTransfer balanceEnough(from, iLAVAAmount) {\r\n        require(from != address(0), \"transfer from the zero address\");\r\n        require(to != address(0), \"transfer to the zero address\");\r\n        require(from != to, \"transfer from same with to\");\r\n\r\n        uint256 stakingPower = DecimalMath.divFloor(iLAVAAmount * _LAVA_RATIO_, alpha);\r\n\r\n        UserInfo storage fromUser = userInfo[from];\r\n        UserInfo storage toUser = userInfo[to];\r\n\r\n        _redeem(fromUser, stakingPower);\r\n        _mint(toUser, stakingPower);\r\n\r\n        emit Transfer(from, to, iLAVAAmount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lavaGov\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lavaToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lavaTeam\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lavaPerBlock\",\"type\":\"uint256\"}],\"name\":\"ChangePerReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donateLAVA\",\"type\":\"uint256\"}],\"name\":\"DonateLAVA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superior\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintLAVA\",\"type\":\"uint256\"}],\"name\":\"MintILAVA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lavaAmount\",\"type\":\"uint256\"}],\"name\":\"PreDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveLAVA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnLAVA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeLAVA\",\"type\":\"uint256\"}],\"name\":\"RedeemILAVA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"SetCantransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lavaFeeBurnRatio\",\"type\":\"uint256\"}],\"name\":\"UpdateLAVAFeeBurnRatio\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_CAN_TRANSFER_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DOOD_GOV_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_FEE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAST_REWARD_BLOCK_\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAVA_BURN_ADDRESS_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAVA_FEE_BURN_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAVA_PER_BLOCK_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAVA_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAVA_TEAM_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAVA_TOKEN_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_FEE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_SUPERIOR_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_BLOCK_DISTRIBUTION_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_BLOCK_REWARD_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_STAKING_POWER_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropController\",\"outputs\":[{\"internalType\":\"contract IAirdrop\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alpha\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iLAVAAmount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iLAVAAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iLAVAAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaPerBlock\",\"type\":\"uint256\"}],\"name\":\"changePerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaAmount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLAVAWithdrawFeeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestAlpha\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newAlpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curDistribution\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSuperior\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"superior\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserStakingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaAmount\",\"type\":\"uint256\"}],\"name\":\"getWithdrawResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaReceive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnLAVAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFeeLAVAAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lavaBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"superiorAddress\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaAmount\",\"type\":\"uint256\"}],\"name\":\"preDepositedBlockReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ilavaAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"all\",\"type\":\"bool\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setAirdropController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setCantransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnLAVA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iLAVASupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iLAVAAmount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iLAVAAmount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeRatio\",\"type\":\"uint256\"}],\"name\":\"updateFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"updateGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"updateLAVAFeeBurnAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lavaFeeBurnRatio\",\"type\":\"uint256\"}],\"name\":\"updateLAVAFeeBurnRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"superiorRatio\",\"type\":\"uint256\"}],\"name\":\"updateSuperiorRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"stakingPower\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"superiorSP\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"superior\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "iLAVAToken", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000006e59913074cd836c2904ddd5b81e85ec11bd0e0200000000000000000000000020548279799d59a5da64a1b6347d0bc1263b9e95", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cb20330ec1d910b99c7b77cdbb3c92deb8544cf1cbfdeafe8fe5d591ab0800f1"}