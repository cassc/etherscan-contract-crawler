{"SourceCode": "// \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588                   \r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588     \u2588\u2588  \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588                  \r\n// \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588                   \r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588       \u2588\u2588  \u2588\u2588  \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588  \u2588\u2588     \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588                   \r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588     \r\n\r\n// CONTRACT DEVELOPED BY REVOLUZION\r\n\r\n//Revoluzion Ecosystem\r\n//WEB: https://revoluzion.io\r\n//DAPP: https://revoluzion.app\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.18;\r\n\r\n/* LIBRARY */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        require(\r\n            returndata.length == 0 || abi.decode(returndata, (bool)),\r\n            \"SafeERC20: ERC20 operation did not succeed\"\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract WDYM is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"WDYM: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"WDYM: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/* INTERFACE */\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n/* LOTTERY */\r\n\r\ninterface IRandomNumberGenerator {\r\n    /**\r\n     * Requests randomness from a user-provided seed\r\n     */\r\n    function getRandomNumber(uint256 theSeed) external;\r\n\r\n    /**\r\n     * View latest lotteryId numbers\r\n     */\r\n    function viewLatestLotteryId() external view returns (uint256);\r\n\r\n    /**\r\n     * Views random result\r\n     */\r\n    function viewRandomResult() external view returns (uint32);\r\n}\r\n\r\ninterface ILottery {\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param idLottery: lotteryId\r\n     * @param ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(\r\n        uint256 idLottery,\r\n        uint32[] calldata ticketNumbers\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param idLottery: lottery id\r\n     * @param idsTicket: array of ticket ids\r\n     * @param brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256 idLottery,\r\n        uint256[] calldata idsTicket,\r\n        uint32[] calldata brackets\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param idLottery: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(uint256 idLottery) external;\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in TOKEN per group, and make lottery claimable\r\n     * @param idLottery: lottery id\r\n     * @param autoInjection: reinjects funds into next lottery (vs. withdrawing all)\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(\r\n        uint256 idLottery,\r\n        bool autoInjection\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Inject funds\r\n     * @param idLottery: lottery id\r\n     * @param _amount: amount to inject in TOKEN token\r\n     * @dev Callable by operator\r\n     */\r\n    function injectFunds(uint256 idLottery, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param timeEnd: endTime of the lottery\r\n     * @param ticketPriceInToken: price of a ticket in TOKEN\r\n     * @param divisorForDiscount: the divisor to calculate the discount magnitude for bulks\r\n     * @param breakdownRewards: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @param feeTreasury: treasury fee (10,000 = 100%, 100 = 1%)\r\n     */\r\n    function startLottery(\r\n        uint256 timeEnd,\r\n        uint256 ticketPriceInToken,\r\n        uint256 divisorForDiscount,\r\n        uint256[6] calldata breakdownRewards,\r\n        uint256 feeTreasury\r\n    ) external;\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external returns (uint256);\r\n}\r\n\r\n/** @title Lottery.\r\n * @notice It is a contract for a lottery system using\r\n * randomness provided externally.\r\n */\r\ncontract WDYMRaffle is ReentrancyGuard, ILottery, WDYM {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public injectorAddress = address(0);\r\n    address public operatorAddress = address(0);\r\n    address public treasuryAddress = address(0);\r\n\r\n    uint256 public currentLotteryId = 0;\r\n    uint256 public currentTicketId = 0;\r\n    uint256 public pendingInjectionNextLottery = 0;\r\n    uint256 public totalInjectedAmount = 0;\r\n\r\n    uint256 public maxNumberTicketsPerBuyOrClaim = 100;\r\n\r\n    uint256 public maximumTicketPrice = 500 ether; // Max ticket for WDYM token is 500\r\n    uint256 public minimumTicketPrice = 1 ether; // Min ticket for WDYM token is 1\r\n\r\n    uint256 public lotteryDuration;\r\n    uint256 public defaultTicketPriceInToken;\r\n    uint256 public defaultDivisorForDiscount;\r\n    uint256 public defaultFeeTreasury;\r\n    uint256[6] public defaultBreakdownRewards;\r\n\r\n    uint256 public constant MIN_DISCOUNT_DIVISOR = 100; // Min divisor discount for bulk ticket purchase\r\n    uint256 public constant MIN_LENGTH_LOTTERY = 1 minutes + 1 minutes; // Min length of the lottery is 30 mins\r\n    uint256 public constant MAX_LENGTH_LOTTERY = 7 days + 5 minutes; // Max length of the lottery is 7 days\r\n    uint256 public constant MAX_TREASURY_FEE = 1000; // Max treasury fee can be set to 10%\r\n\r\n    IERC20 public immutable lotteryToken;\r\n    IRandomNumberGenerator public randomGenerator;\r\n\r\n    enum Status {\r\n        Pending,\r\n        Open,\r\n        Close,\r\n        Claimable\r\n    }\r\n\r\n    struct Lottery {\r\n        Status status;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 priceTicketInToken;\r\n        uint256 discountDivisor;\r\n        uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers\r\n        uint256 treasuryFee; // 1000: 10% // 500: 5% // 50: 0.5%\r\n        uint256[6] tokenPerBracket;\r\n        uint256[6] countWinnersPerBracket;\r\n        uint256 firstTicketId;\r\n        uint256 firstTicketIdNextLottery;\r\n        uint256 amountCollectedInToken;\r\n        uint32 finalNumber;\r\n    }\r\n\r\n    struct Ticket {\r\n        uint32 number;\r\n        address owner;\r\n    }\r\n\r\n    // Mapping are cheaper than arrays\r\n    mapping(uint256 => Lottery) private _lotteries;\r\n    mapping(uint256 => Ticket) private _tickets;\r\n\r\n    // Bracket calculator is used for verifying claims for ticket prizes\r\n    mapping(uint32 => uint32) private _bracketCalculator;\r\n\r\n    // Keeps track of number of ticket per unique combination for each lotteryId\r\n    mapping(uint256 => mapping(uint32 => uint256))\r\n        private _numberTicketsPerLotteryId;\r\n\r\n    // Keep track of user ticket ids for a given lotteryId\r\n    mapping(address => mapping(uint256 => uint256[]))\r\n        private _userTicketIdsPerLotteryId;\r\n\r\n    modifier notContract() {\r\n        require(!_isContract(msg.sender), \"Contract not allowed\");\r\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operatorAddress, \"Not operator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrInjector() {\r\n        require(\r\n            (msg.sender == owner()) || (msg.sender == injectorAddress),\r\n            \"Not WDYM owner or injector\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event AdminTokenRecovery(address token, uint256 amount);\r\n    event LotteryClose(\r\n        uint256 indexed lotteryId,\r\n        uint256 firstTicketIdNextLottery\r\n    );\r\n    event LotteryInjection(\r\n        uint256 indexed lotteryId,\r\n        uint256 injectedAmount\r\n    );\r\n    event LotteryOpen(\r\n        uint256 indexed lotteryId,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 priceTicketInToken,\r\n        uint256 firstTicketId,\r\n        uint256 injectedAmount\r\n    );\r\n    event LotteryNumberDrawn(\r\n        uint256 indexed lotteryId,\r\n        uint256 finalNumber,\r\n        uint256 countWinningTickets\r\n    );\r\n    event NewOperatorAndTreasuryAndInjectorAddresses(\r\n        address operator,\r\n        address treasury,\r\n        address injector\r\n    );\r\n    event NewRandomGenerator(\r\n        address indexed randomGenerator,\r\n        uint32 finalNumber\r\n    );\r\n    event TicketsPurchase(\r\n        address indexed buyer,\r\n        uint256 indexed lotteryId,\r\n        uint256 numberTickets\r\n    );\r\n    event TicketsClaim(\r\n        address indexed claimer,\r\n        uint256 amount,\r\n        uint256 indexed lotteryId,\r\n        uint256 numberTickets\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @dev RandomNumberGenerator must be deployed prior to this contract\r\n     * @param _lotteryTokenAddress: address of the TOKEN token\r\n     */\r\n    constructor(\r\n        address _lotteryTokenAddress,\r\n        uint256 initLotteryDuration,\r\n        uint256 initDefaultTicketPriceInToken,\r\n        uint256 initDefaultDivisorForDiscount,\r\n        uint256 initDefaultFeeTreasury,\r\n        uint256[6] memory initDefaultBreakdownRewards\r\n    ) {\r\n        require(\r\n            (initLotteryDuration > MIN_LENGTH_LOTTERY) &&\r\n                (initLotteryDuration < MAX_LENGTH_LOTTERY),\r\n            \"Raffle length outside of range\"\r\n        );\r\n\r\n        require(\r\n            (initDefaultTicketPriceInToken >= minimumTicketPrice) &&\r\n                (initDefaultTicketPriceInToken <= maximumTicketPrice),\r\n            \"Raffle Ticket Price is outside of limits\"\r\n        );\r\n\r\n        require(\r\n            initDefaultDivisorForDiscount >= MIN_DISCOUNT_DIVISOR,\r\n            \"Discount divisor is too low\"\r\n        );\r\n        require(\r\n            initDefaultFeeTreasury <= MAX_TREASURY_FEE,\r\n            \"Treasury fee is too high\"\r\n        );\r\n\r\n        require(\r\n            (initDefaultBreakdownRewards[0] +\r\n                initDefaultBreakdownRewards[1] +\r\n                initDefaultBreakdownRewards[2] +\r\n                initDefaultBreakdownRewards[3] +\r\n                initDefaultBreakdownRewards[4] +\r\n                initDefaultBreakdownRewards[5]) == 10000,\r\n            \"Rewards must equal to 10000\"\r\n        );\r\n\r\n        lotteryToken = IERC20(_lotteryTokenAddress);\r\n        randomGenerator = new RandomNumberGenerator(\r\n            address(this),\r\n            _msgSender()\r\n        );\r\n\r\n        lotteryDuration = initLotteryDuration;\r\n        defaultTicketPriceInToken = initDefaultTicketPriceInToken;\r\n        defaultDivisorForDiscount = initDefaultDivisorForDiscount;\r\n        defaultFeeTreasury = initDefaultFeeTreasury;\r\n        defaultBreakdownRewards = initDefaultBreakdownRewards;\r\n\r\n        // Initializes a mapping\r\n        _bracketCalculator[0] = 1;\r\n        _bracketCalculator[1] = 11;\r\n        _bracketCalculator[2] = 111;\r\n        _bracketCalculator[3] = 1111;\r\n        _bracketCalculator[4] = 11111;\r\n        _bracketCalculator[5] = 111111;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice getTotalRewardsDistributed\r\n     * @dev Callable by anyone\r\n     */\r\n    function getTotalRewardsDistributed() public view returns (uint256) {\r\n        uint256 totalRewardsDistributed = 0;\r\n\r\n        for (uint256 lotteryId = 0; lotteryId <= currentLotteryId; lotteryId++) {\r\n            Lottery storage lottery = _lotteries[lotteryId];\r\n            \r\n            for (uint8 i = 0; i < 6; i++) {\r\n                totalRewardsDistributed += lottery.tokenPerBracket[i] * lottery.countWinnersPerBracket[i];\r\n            }\r\n        }\r\n\r\n        return totalRewardsDistributed;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice getTotalTicketsSoldForCurrentLottery\r\n     * @dev Callable by anyone\r\n     */\r\n    function getTotalTicketsSoldForCurrentLottery() public view returns (uint256) {\r\n        uint256 firstTicketId = _lotteries[currentLotteryId].firstTicketId;\r\n        uint256 latestTicketId = currentTicketId;\r\n\r\n        if (latestTicketId <= firstTicketId) {\r\n            return 0;\r\n        }\r\n\r\n        return latestTicketId - firstTicketId;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Get the total amount of injected tokens so far\r\n     * @return The total amount of injected tokens\r\n     */\r\n    function getTotalInjectedAmount() public view returns (uint256) {\r\n        return totalInjectedAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Get the total amount of tickets bought by a user so far\r\n     * @return The total amount of tickets bought by the user\r\n     */\r\n    function getUserTicketCount(address user) public view returns (uint256) {\r\n        uint256 totalTickets = 0;\r\n        \r\n        for (uint256 i = 0; i <= currentLotteryId; i++) {\r\n            totalTickets += _userTicketIdsPerLotteryId[user][i].length;\r\n        }\r\n        \r\n        return totalTickets;\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Get the total rewards received by a user from all lottery IDs combined\r\n    * @param user The address of the user\r\n    * @return The total rewards received by the user\r\n    */\r\n    function getUserRewardsReceived(address user) public view returns (uint256) {\r\n        uint256 totalRewards = 0;\r\n\r\n        for (uint256 lotteryId = 0; lotteryId <= currentLotteryId; lotteryId++) {\r\n            uint256[] storage ticketIds = _userTicketIdsPerLotteryId[user][lotteryId];\r\n\r\n            for (uint256 j = 0; j < ticketIds.length; j++) {\r\n                uint256 ticketId = ticketIds[j];\r\n                uint256 rewardForTicket = _calculateRewardsForTicketId(lotteryId, ticketId, 0);\r\n                totalRewards += rewardForTicket;\r\n            }\r\n        }\r\n\r\n        return totalRewards;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Update lottery duration\r\n     * @param initLotteryDuration: duration of the lottery\r\n     * @dev Callable by owner\r\n     */\r\n    function updateLotteryDuration(\r\n        uint256 initLotteryDuration\r\n    ) external onlyOwner {\r\n        require(\r\n            (initLotteryDuration > MIN_LENGTH_LOTTERY) &&\r\n                (initLotteryDuration < MAX_LENGTH_LOTTERY),\r\n            \"Raffle duration length is outside of range\"\r\n        );\r\n        require(\r\n            initLotteryDuration != lotteryDuration,\r\n            \"This is the current value\"\r\n        );\r\n\r\n        lotteryDuration = initLotteryDuration;\r\n    }\r\n\r\n    /**\r\n     * @notice Update default ticket price in token\r\n     * @param initDefaultTicketPriceInToken: price of a ticket in TOKEN\r\n     * @dev Callable by owner\r\n     */\r\n    function updateDefaultTicketPriceInToken(\r\n        uint256 initDefaultTicketPriceInToken\r\n    ) external onlyOwner {\r\n        require(\r\n            (initDefaultTicketPriceInToken >= minimumTicketPrice) &&\r\n                (initDefaultTicketPriceInToken <= maximumTicketPrice),\r\n            \"Raffle Ticket Price is outside of limits\"\r\n        );\r\n        require(\r\n            initDefaultTicketPriceInToken != defaultTicketPriceInToken,\r\n            \"This is the current value\"\r\n        );\r\n        defaultTicketPriceInToken = initDefaultTicketPriceInToken;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Update default divisor for discount\r\n     * @param initDefaultDivisorForDiscount: the divisor to calculate the discount magnitude for bulks\r\n     * @dev Callable by owner\r\n     */\r\n    function updateDefaultDivisorForDiscount(\r\n        uint256 initDefaultDivisorForDiscount\r\n    ) external onlyOwner {\r\n        require(\r\n            initDefaultDivisorForDiscount >= MIN_DISCOUNT_DIVISOR,\r\n            \"Discount divisor too low\"\r\n        );\r\n        require(\r\n            initDefaultDivisorForDiscount != defaultDivisorForDiscount,\r\n            \"This is the current value\"\r\n        );\r\n\r\n        defaultDivisorForDiscount = initDefaultDivisorForDiscount;\r\n    }\r\n\r\n    /**\r\n     * @notice Update default fee treasury\r\n     * @param initDefaultFeeTreasury: treasury fee (10,000 = 100%, 100 = 1%)\r\n     * @dev Callable by owner\r\n     */\r\n    function updateDefaultFeeTreasury(\r\n        uint256 initDefaultFeeTreasury\r\n    ) external onlyOwner {\r\n        require(\r\n            initDefaultFeeTreasury <= MAX_TREASURY_FEE,\r\n            \"Treasury fee is too high\"\r\n        );\r\n        require(\r\n            initDefaultFeeTreasury != defaultFeeTreasury,\r\n            \"This is the current value\"\r\n        );\r\n\r\n        defaultFeeTreasury = initDefaultFeeTreasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Update default breakdown rewards\r\n     * @param initDefaultBreakdownRewards: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @dev Callable by owner\r\n     */\r\n    function updateDefaultBreakdownRewards(\r\n        uint256[6] memory initDefaultBreakdownRewards\r\n    ) external onlyOwner {\r\n        require(\r\n            (initDefaultBreakdownRewards[0] +\r\n                initDefaultBreakdownRewards[1] +\r\n                initDefaultBreakdownRewards[2] +\r\n                initDefaultBreakdownRewards[3] +\r\n                initDefaultBreakdownRewards[4] +\r\n                initDefaultBreakdownRewards[5]) == 10000,\r\n            \"Rewards must equal to 10000\"\r\n        );\r\n\r\n        defaultBreakdownRewards = initDefaultBreakdownRewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param idLottery: lotteryId\r\n     * @param ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(\r\n        uint256 idLottery,\r\n        uint32[] calldata ticketNumbers\r\n    ) external override notContract nonReentrant {\r\n        require(ticketNumbers.length != 0, \"No ticket specified\");\r\n        require(\r\n            ticketNumbers.length <= maxNumberTicketsPerBuyOrClaim,\r\n            \"Tickets purchased cannot exceed 100\"\r\n        );\r\n\r\n        require(\r\n            _lotteries[idLottery].status == Status.Open,\r\n            \"Raffle is currently not open\"\r\n        );\r\n        require(\r\n            block.timestamp < _lotteries[idLottery].endTime,\r\n            \"Raffle has over\"\r\n        );\r\n\r\n        // Calculate number of TOKEN to this contract\r\n        uint256 amountTokenToTransfer = _calculateTotalPriceForBulkTickets(\r\n            _lotteries[idLottery].discountDivisor,\r\n            _lotteries[idLottery].priceTicketInToken,\r\n            ticketNumbers.length\r\n        );\r\n\r\n        // Increment the total amount collected for the lottery round\r\n        _lotteries[idLottery].amountCollectedInToken += amountTokenToTransfer;\r\n\r\n        for (uint256 i = 0; i < ticketNumbers.length; i++) {\r\n            uint32 thisTicketNumber = ticketNumbers[i];\r\n\r\n            require(\r\n                (thisTicketNumber >= 0.001 gwei) &&\r\n                    (thisTicketNumber <= 1999999),\r\n                \"Ticket Number is outside range\"\r\n            );\r\n\r\n            _numberTicketsPerLotteryId[idLottery][\r\n                1 + (thisTicketNumber % 10)\r\n            ]++;\r\n            _numberTicketsPerLotteryId[idLottery][\r\n                11 + (thisTicketNumber % 100)\r\n            ]++;\r\n            _numberTicketsPerLotteryId[idLottery][\r\n                111 + (thisTicketNumber % 1000)\r\n            ]++;\r\n            _numberTicketsPerLotteryId[idLottery][\r\n                1111 + (thisTicketNumber % 10000)\r\n            ]++;\r\n            _numberTicketsPerLotteryId[idLottery][\r\n                11111 + (thisTicketNumber % 0.0001 gwei)\r\n            ]++;\r\n            _numberTicketsPerLotteryId[idLottery][\r\n                111111 + (thisTicketNumber % 0.001 gwei)\r\n            ]++;\r\n\r\n            _userTicketIdsPerLotteryId[msg.sender][idLottery].push(\r\n                currentTicketId\r\n            );\r\n\r\n            _tickets[currentTicketId] = Ticket({\r\n                number: thisTicketNumber,\r\n                owner: msg.sender\r\n            });\r\n\r\n            // Increase lottery ticket number\r\n            currentTicketId++;\r\n        }\r\n\r\n        // Transfer token tokens to this contract\r\n        lotteryToken.safeTransferFrom(\r\n            address(msg.sender),\r\n            address(this),\r\n            amountTokenToTransfer\r\n        );\r\n\r\n        emit TicketsPurchase(msg.sender, idLottery, ticketNumbers.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param idLottery: lottery id\r\n     * @param idsTicket: array of ticket ids\r\n     * @param brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256 idLottery,\r\n        uint256[] calldata idsTicket,\r\n        uint32[] calldata brackets\r\n    ) external override notContract nonReentrant {\r\n        require(idsTicket.length == brackets.length, \"Not same length\");\r\n        require(idsTicket.length != 0, \"Length must be >0\");\r\n        require(\r\n            idsTicket.length <= maxNumberTicketsPerBuyOrClaim,\r\n            \"Too many tickets to claim\"\r\n        );\r\n        require(\r\n            _lotteries[idLottery].status == Status.Claimable,\r\n            \"Raffle not claimable\"\r\n        );\r\n\r\n        // Initializes the rewardInTokenToTransfer\r\n        uint256 rewardInTokenToTransfer;\r\n\r\n        for (uint256 i = 0; i < idsTicket.length; i++) {\r\n            require(brackets[i] < 6, \"Bracket out of range\"); // Must be between 0 and 5\r\n\r\n            uint256 thisTicketId = idsTicket[i];\r\n\r\n            bool high = _lotteries[idLottery].firstTicketIdNextLottery >\r\n                thisTicketId;\r\n            bool low = _lotteries[idLottery].firstTicketId <= thisTicketId;\r\n\r\n            require(high, \"TicketId too high\");\r\n            require(low, \"TicketId too low\");\r\n            require(\r\n                msg.sender == _tickets[thisTicketId].owner,\r\n                \"Not the owner\"\r\n            );\r\n\r\n            // Update the lottery ticket owner to 0x address\r\n            _tickets[thisTicketId].owner = address(0);\r\n\r\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(\r\n                idLottery,\r\n                thisTicketId,\r\n                brackets[i]\r\n            );\r\n\r\n            // Check user is claiming the correct bracket\r\n            require(rewardForTicketId != 0, \"No prize for this bracket\");\r\n\r\n            if (brackets[i] != 5) {\r\n                require(\r\n                    _calculateRewardsForTicketId(\r\n                        idLottery,\r\n                        thisTicketId,\r\n                        brackets[i] + 1\r\n                    ) < 1,\r\n                    \"Bracket must be higher\"\r\n                );\r\n            }\r\n\r\n            // Increment the reward to transfer\r\n            rewardInTokenToTransfer += rewardForTicketId;\r\n        }\r\n\r\n        emit TicketsClaim(\r\n            msg.sender,\r\n            rewardInTokenToTransfer,\r\n            idLottery,\r\n            idsTicket.length\r\n        );\r\n\r\n        // Transfer money to msg.sender\r\n        lotteryToken.safeTransfer(msg.sender, rewardInTokenToTransfer);\r\n    }\r\n\r\n    /**\r\n     * @notice Public user can use this function to finalize lottery.\r\n     * @param idLottery: lottery id\r\n     * @dev Callable by anyone\r\n     */\r\n    function userInitiateLotteryFinalize(uint256 idLottery) external {\r\n        _closeLottery(idLottery);\r\n        _drawFinalNumberAndMakeLotteryClaimable(idLottery, true);\r\n        uint256 endTime = block.timestamp + lotteryDuration;\r\n        _startLottery(\r\n            endTime,\r\n            defaultTicketPriceInToken,\r\n            defaultDivisorForDiscount,\r\n            defaultBreakdownRewards,\r\n            defaultFeeTreasury\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param idLottery: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(\r\n        uint256 idLottery\r\n    ) external override onlyOperator nonReentrant {\r\n        _closeLottery(idLottery);\r\n    }\r\n\r\n    function _closeLottery(uint256 idLottery) internal {\r\n        require(\r\n            _lotteries[idLottery].status == Status.Open,\r\n            \"Raffle not open\"\r\n        );\r\n        require(\r\n            block.timestamp > _lotteries[idLottery].endTime,\r\n            \"Raffle not over\"\r\n        );\r\n        _lotteries[idLottery].firstTicketIdNextLottery = currentTicketId;\r\n\r\n        _lotteries[idLottery].status = Status.Close;\r\n\r\n        // Request a random number from the generator based on a seed\r\n        randomGenerator.getRandomNumber(\r\n            uint256(keccak256(abi.encodePacked(idLottery, currentTicketId)))\r\n        );\r\n\r\n        emit LotteryClose(idLottery, currentTicketId);\r\n    }\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in TOKEN per group, and make lottery claimable\r\n     * @param idLottery: lottery id\r\n     * @param autoInjection: reinjects funds into next lottery (vs. withdrawing all)\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(\r\n        uint256 idLottery,\r\n        bool autoInjection\r\n    ) external override onlyOperator nonReentrant {\r\n        _drawFinalNumberAndMakeLotteryClaimable(idLottery, autoInjection);\r\n    }\r\n\r\n    function _drawFinalNumberAndMakeLotteryClaimable(\r\n        uint256 idLottery,\r\n        bool autoInjection\r\n    ) internal {\r\n        bool close = _lotteries[idLottery].status == Status.Close;\r\n        require(close, \"Raffle not close \");\r\n        require(\r\n            idLottery == randomGenerator.viewLatestLotteryId(),\r\n            \"Numbers are not yet drawn\"\r\n        );\r\n\r\n        // Calculate the finalNumber based on the randomResult generated by ChainLink's fallback\r\n        uint32 finalNumber = randomGenerator.viewRandomResult();\r\n\r\n        // Initialize a number to count addresses in the previous bracket\r\n        uint256 numberAddressesInPreviousBracket = 0;\r\n\r\n        // Calculate the amount to share post-treasury fee\r\n        uint256 totalAmountToShareToWinners = (\r\n            _lotteries[idLottery].amountCollectedInToken\r\n        ) * (10000 - _lotteries[idLottery].treasuryFee);\r\n        uint256 amountToShareToWinners = totalAmountToShareToWinners / 10000;\r\n\r\n        // Initializes the amount to withdraw to treasury\r\n        uint256 amountToWithdrawToTreasury = 0;\r\n\r\n        uint256 idLotteryVal = idLottery;\r\n        // Calculate prizes in TOKEN for each bracket by starting from the highest one\r\n        for (uint32 i = 0; i < 6; i++) {\r\n            uint32 j = 5 - i;\r\n            uint32 transformedWinningNumber = _bracketCalculator[j] +\r\n                (finalNumber % (uint32(10) ** (j + 1)));\r\n\r\n            _lotteries[idLotteryVal].countWinnersPerBracket[j] =\r\n                _numberTicketsPerLotteryId[idLotteryVal][\r\n                    transformedWinningNumber\r\n                ] -\r\n                numberAddressesInPreviousBracket;\r\n\r\n            // A. If number of users for this bracket number is superior to 0\r\n            if (\r\n                (_numberTicketsPerLotteryId[idLotteryVal][\r\n                    transformedWinningNumber\r\n                ] - numberAddressesInPreviousBracket) != 0\r\n            ) {\r\n                // B. If rewards at this bracket are > 0, calculate, else, report the numberAddresses from previous bracket\r\n                if (_lotteries[idLotteryVal].rewardsBreakdown[j] != 0) {\r\n                    _lotteries[idLotteryVal].tokenPerBracket[j] =\r\n                        (((_lotteries[idLotteryVal].rewardsBreakdown[j] *\r\n                            totalAmountToShareToWinners) / 10000) /\r\n                            (_numberTicketsPerLotteryId[idLotteryVal][\r\n                                transformedWinningNumber\r\n                            ] - numberAddressesInPreviousBracket)) /\r\n                        10000;\r\n\r\n                    // Update numberAddressesInPreviousBracket\r\n                    numberAddressesInPreviousBracket = _numberTicketsPerLotteryId[\r\n                        idLotteryVal\r\n                    ][transformedWinningNumber];\r\n                }\r\n                // A. No TOKEN to distribute, they are added to the amount to withdraw to treasury address\r\n            } else {\r\n                _lotteries[idLotteryVal].tokenPerBracket[j] = 0;\r\n\r\n                amountToWithdrawToTreasury +=\r\n                    ((_lotteries[idLotteryVal].rewardsBreakdown[j] *\r\n                        totalAmountToShareToWinners) / 10000) /\r\n                    10000;\r\n            }\r\n        }\r\n\r\n        // Update internal statuses for lottery\r\n        _lotteries[idLotteryVal].finalNumber = finalNumber;\r\n        _lotteries[idLotteryVal].status = Status.Claimable;\r\n\r\n        if (autoInjection) {\r\n            pendingInjectionNextLottery = amountToWithdrawToTreasury;\r\n            amountToWithdrawToTreasury = 0;\r\n        }\r\n\r\n        amountToWithdrawToTreasury += (_lotteries[idLotteryVal]\r\n            .amountCollectedInToken - amountToShareToWinners);\r\n\r\n        // Transfer TOKEN to treasury address\r\n        lotteryToken.safeTransfer(treasuryAddress, amountToWithdrawToTreasury);\r\n\r\n        emit LotteryNumberDrawn(\r\n            currentLotteryId,\r\n            finalNumber,\r\n            numberAddressesInPreviousBracket\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Change the random generator\r\n     * @dev The calls to functions are used to verify the new generator implements them properly.\r\n     * It is necessary to wait for the VRF response before starting a round.\r\n     * Callable only by the contract owner\r\n     * @param randomGeneratorAddress: address of the random generator\r\n     */\r\n    function changeRandomGenerator(\r\n        address randomGeneratorAddress\r\n    ) external onlyOwner {\r\n        require(\r\n            _lotteries[currentLotteryId].status == Status.Claimable,\r\n            \"Raffle not in claimable\"\r\n        );\r\n\r\n        randomGenerator = IRandomNumberGenerator(randomGeneratorAddress);\r\n\r\n        // Request a random number from the generator based on a seed\r\n        IRandomNumberGenerator(randomGeneratorAddress).getRandomNumber(\r\n            uint256(\r\n                keccak256(abi.encodePacked(currentLotteryId, currentTicketId))\r\n            )\r\n        );\r\n\r\n        // Calculate the finalNumber based on the randomResult generated by ChainLink's fallback\r\n        uint32 finalNumber = IRandomNumberGenerator(randomGeneratorAddress)\r\n            .viewRandomResult();\r\n\r\n        emit NewRandomGenerator(randomGeneratorAddress, finalNumber);\r\n    }\r\n\r\n    /**\r\n    * @notice Inject funds\r\n    * @param idLottery: lottery id\r\n    * @param amount: amount to inject in TOKEN token\r\n    * @dev Callable by owner or injector address\r\n    */\r\n    function injectFunds(uint256 idLottery, uint256 amount) external override onlyOwnerOrInjector {\r\n        require(_lotteries[idLottery].status == Status.Open, \"Raffle not open\");\r\n\r\n        _lotteries[idLottery].amountCollectedInToken += amount;\r\n        totalInjectedAmount += amount; // Increment the total injected amount\r\n        emit LotteryInjection(idLottery, amount);\r\n\r\n        lotteryToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param timeEnd: endTime of the lottery\r\n     * @param ticketPriceInToken: price of a ticket in TOKEN\r\n     * @param divisorForDiscount: the divisor to calculate the discount magnitude for bulks\r\n     * @param breakdownRewards: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @param feeTreasury: treasury fee (10,000 = 100%, 100 = 1%)\r\n     */\r\n    function startLottery(\r\n        uint256 timeEnd,\r\n        uint256 ticketPriceInToken,\r\n        uint256 divisorForDiscount,\r\n        uint256[6] memory breakdownRewards,\r\n        uint256 feeTreasury\r\n    ) external override onlyOperator {\r\n        _startLottery(\r\n            timeEnd,\r\n            ticketPriceInToken,\r\n            divisorForDiscount,\r\n            breakdownRewards,\r\n            feeTreasury\r\n        );\r\n    }\r\n\r\n    function _startLottery(\r\n        uint256 timeEnd,\r\n        uint256 ticketPriceInToken,\r\n        uint256 divisorForDiscount,\r\n        uint256[6] memory breakdownRewards,\r\n        uint256 feeTreasury\r\n    ) internal {\r\n        require(\r\n            (currentLotteryId == 0) ||\r\n                (_lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Not time to start Raffle\"\r\n        );\r\n\r\n        require(\r\n            ((timeEnd - block.timestamp) > MIN_LENGTH_LOTTERY) &&\r\n                ((timeEnd - block.timestamp) < MAX_LENGTH_LOTTERY),\r\n            \"Raffle time length outside of range\"\r\n        );\r\n\r\n        require(\r\n            (ticketPriceInToken >= minimumTicketPrice) &&\r\n                (ticketPriceInToken <= maximumTicketPrice),\r\n            \"Ticket Price is outside of limits\"\r\n        );\r\n\r\n        require(\r\n            divisorForDiscount >= MIN_DISCOUNT_DIVISOR,\r\n            \"Discount divisor too low\"\r\n        );\r\n        require(feeTreasury <= MAX_TREASURY_FEE, \"Treasury fee too high\");\r\n\r\n        require(\r\n            (breakdownRewards[0] +\r\n                breakdownRewards[1] +\r\n                breakdownRewards[2] +\r\n                breakdownRewards[3] +\r\n                breakdownRewards[4] +\r\n                breakdownRewards[5]) == 10000,\r\n            \"Rewards must equal 10000\"\r\n        );\r\n\r\n        currentLotteryId++;\r\n\r\n        _lotteries[currentLotteryId] = Lottery({\r\n            status: Status.Open,\r\n            startTime: block.timestamp,\r\n            endTime: timeEnd,\r\n            priceTicketInToken: ticketPriceInToken,\r\n            discountDivisor: divisorForDiscount,\r\n            rewardsBreakdown: breakdownRewards,\r\n            treasuryFee: feeTreasury,\r\n            tokenPerBracket: [\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0)\r\n            ],\r\n            countWinnersPerBracket: [\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0),\r\n                uint256(0)\r\n            ],\r\n            firstTicketId: currentTicketId,\r\n            firstTicketIdNextLottery: currentTicketId,\r\n            amountCollectedInToken: pendingInjectionNextLottery,\r\n            finalNumber: 0\r\n        });\r\n\r\n        emit LotteryOpen(\r\n            currentLotteryId,\r\n            block.timestamp,\r\n            timeEnd,\r\n            ticketPriceInToken,\r\n            currentTicketId,\r\n            pendingInjectionNextLottery\r\n        );\r\n\r\n        pendingInjectionNextLottery = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice It allows the admin to recover wrong tokens sent to the contract\r\n     * @param tokenAddress: the address of the token to withdraw\r\n     * @param tokenAmount: the number of token amount to withdraw\r\n     * @dev Only callable by owner.\r\n     */\r\n    function recoverWrongTokens(\r\n        address tokenAddress,\r\n        uint256 tokenAmount\r\n    ) external onlyOwner {\r\n        require(tokenAddress != address(lotteryToken), \"Cannot be BUSD token\");\r\n\r\n        emit AdminTokenRecovery(tokenAddress, tokenAmount);\r\n\r\n        IERC20(tokenAddress).safeTransfer(address(msg.sender), tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set TOKEN price ticket upper/lower limit\r\n     * @dev Only callable by owner\r\n     * @param minimumPrice: minimum price of a ticket in TOKEN\r\n     * @param maximumPrice: maximum price of a ticket in TOKEN\r\n     */\r\n    function setMinAndMaxTicketPriceInToken(\r\n        uint256 minimumPrice,\r\n        uint256 maximumPrice\r\n    ) external onlyOwner {\r\n        require(minimumPrice <= maximumPrice, \"minPrice must be < maxPrice\");\r\n\r\n        minimumTicketPrice = minimumPrice;\r\n        maximumTicketPrice = maximumPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Set max number of tickets\r\n     * @dev Only callable by owner\r\n     */\r\n    function setMaxNumberTicketsPerBuy(\r\n        uint256 maxNumberTicketsPerBuy\r\n    ) external onlyOwner {\r\n        require(maxNumberTicketsPerBuy != 0, \"Must be > 0\");\r\n        maxNumberTicketsPerBuyOrClaim = maxNumberTicketsPerBuy;\r\n    }\r\n\r\n    /**\r\n     * @notice Set operator, treasury, and injector addresses\r\n     * @dev Only callable by owner\r\n     * @param addressOperator: address of the operator\r\n     * @param addressTreasury: address of the treasury\r\n     * @param addressInjector: address of the injector\r\n     */\r\n    function setOperatorAndTreasuryAndInjectorAddresses(\r\n        address addressOperator,\r\n        address addressTreasury,\r\n        address addressInjector\r\n    ) external onlyOwner {\r\n        require(addressOperator != address(0), \"Cannot be zero address\");\r\n        require(addressTreasury != address(0), \"Cannot be zero address\");\r\n        require(addressInjector != address(0), \"Cannot be zero address\");\r\n\r\n        operatorAddress = addressOperator;\r\n        treasuryAddress = addressTreasury;\r\n        injectorAddress = addressInjector;\r\n\r\n        emit NewOperatorAndTreasuryAndInjectorAddresses(\r\n            addressOperator,\r\n            addressTreasury,\r\n            addressInjector\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate price of a set of tickets\r\n     * @param divisorForDiscount: divisor for the discount\r\n     * @param priceTicket price of a ticket (in TOKEN)\r\n     * @param numberTickets number of tickets to buy\r\n     */\r\n    function calculateTotalPriceForBulkTickets(\r\n        uint256 divisorForDiscount,\r\n        uint256 priceTicket,\r\n        uint256 numberTickets\r\n    ) external pure returns (uint256) {\r\n        require(\r\n            divisorForDiscount >= MIN_DISCOUNT_DIVISOR,\r\n            \"Must be >= MIN_DISCOUNT_DIVISOR\"\r\n        );\r\n        require(numberTickets != 0, \"Number of tickets must be > 0\");\r\n\r\n        return\r\n            _calculateTotalPriceForBulkTickets(\r\n                divisorForDiscount,\r\n                priceTicket,\r\n                numberTickets\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external view override returns (uint256) {\r\n        return currentLotteryId;\r\n    }\r\n\r\n    /**\r\n     * @notice View lottery information\r\n     * @param idLottery: lottery id\r\n     */\r\n    function viewLottery(\r\n        uint256 idLottery\r\n    ) external view returns (Lottery memory) {\r\n        return _lotteries[idLottery];\r\n    }\r\n\r\n    /**\r\n     * @notice View ticker statuses and numbers for an array of ticket ids\r\n     * @param idsTicket: array of idTicket\r\n     */\r\n    function viewNumbersAndStatusesForTicketIds(\r\n        uint256[] calldata idsTicket\r\n    ) external view returns (uint32[] memory, bool[] memory) {\r\n        uint256 length = idsTicket.length;\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            ticketNumbers[i] = _tickets[idsTicket[i]].number;\r\n            if (_tickets[idsTicket[i]].owner == address(0)) {\r\n                ticketStatuses[i] = true;\r\n            } else {\r\n                ticketStatuses[i] = false;\r\n            }\r\n        }\r\n\r\n        return (ticketNumbers, ticketStatuses);\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards for a given ticket, providing a bracket, and lottery id\r\n     * @dev Computations are mostly offchain. This is used to verify a ticket!\r\n     * @param idLottery: lottery id\r\n     * @param idTicket: ticket id\r\n     * @param bracket: bracket for the idTicket to verify the claim and calculate rewards\r\n     */\r\n    function viewRewardsForTicketId(\r\n        uint256 idLottery,\r\n        uint256 idTicket,\r\n        uint32 bracket\r\n    ) external view returns (uint256) {\r\n        // Check lottery is in claimable status\r\n        if (_lotteries[idLottery].status != Status.Claimable) {\r\n            return 0;\r\n        }\r\n\r\n        // Check idTicket is within range\r\n        if (\r\n            (_lotteries[idLottery].firstTicketIdNextLottery < idTicket) &&\r\n            (_lotteries[idLottery].firstTicketId >= idTicket)\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        return _calculateRewardsForTicketId(idLottery, idTicket, bracket);\r\n    }\r\n\r\n    /**\r\n     * @notice View user ticket ids, numbers, and statuses of user for a given lottery\r\n     * @param user: user address\r\n     * @param idLottery: lottery id\r\n     * @param cursor: cursor to start where to retrieve the tickets\r\n     * @param size: the number of tickets to retrieve\r\n     */\r\n    function viewUserInfoForLotteryId(\r\n        address user,\r\n        uint256 idLottery,\r\n        uint256 cursor,\r\n        uint256 size\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint32[] memory, uint32[] memory, bool[] memory, bool[] memory, uint256)\r\n    {\r\n        uint256 length = size;\r\n        uint256 numberTicketsBoughtAtLotteryId = _userTicketIdsPerLotteryId[\r\n            user\r\n        ][idLottery].length;\r\n\r\n        if (length > (numberTicketsBoughtAtLotteryId - cursor)) {\r\n            length = numberTicketsBoughtAtLotteryId - cursor;\r\n        }\r\n\r\n        address lotteryUser = user;\r\n        uint256 lotteryID = idLottery;\r\n        uint256 currentCursor = cursor;\r\n\r\n        uint256[] memory lotteryTicketIds = new uint256[](length);\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n        uint32[] memory ticketHighestBracket = new uint32[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n        bool[] memory ticketWinnings = new bool[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            lotteryTicketIds[i] = _userTicketIdsPerLotteryId[lotteryUser][lotteryID][\r\n                i + currentCursor\r\n            ];\r\n            ticketNumbers[i] = _tickets[lotteryTicketIds[i]].number;\r\n\r\n            // True = ticket claimed\r\n            if (_tickets[lotteryTicketIds[i]].owner == address(0)) {\r\n                ticketStatuses[i] = true;\r\n            } else {\r\n                // ticket not claimed (includes the ones that cannot be claimed)\r\n                ticketStatuses[i] = false;\r\n            }\r\n\r\n            (bool won, uint32 bracketToClaim) = _checkTicketHighestBracket(lotteryID, lotteryTicketIds[i]);\r\n            ticketWinnings[i] = won;\r\n            ticketHighestBracket[i] = bracketToClaim;\r\n        }\r\n\r\n        return (\r\n            lotteryTicketIds,\r\n            ticketNumbers,\r\n            ticketHighestBracket,\r\n            ticketStatuses,\r\n            ticketWinnings,\r\n            currentCursor + length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate rewards for a given ticket\r\n     * @param idLottery: lottery id\r\n     * @param idTicket: ticket id\r\n     * @param bracket: bracket for the idTicket to verify the claim and calculate rewards\r\n     */\r\n    function _calculateRewardsForTicketId(\r\n        uint256 idLottery,\r\n        uint256 idTicket,\r\n        uint32 bracket\r\n    ) internal view returns (uint256) {\r\n        // Retrieve the winning number combination\r\n        uint32 userNumber = _lotteries[idLottery].finalNumber;\r\n\r\n        // Retrieve the user number combination from the idTicket\r\n        uint32 winningTicketNumber = _tickets[idTicket].number;\r\n\r\n        // Apply transformation to verify the claim provided by the user is true\r\n        uint32 transformedWinningNumber = _bracketCalculator[bracket] +\r\n            (winningTicketNumber % (uint32(10) ** (bracket + 1)));\r\n\r\n        uint32 transformedUserNumber = _bracketCalculator[bracket] +\r\n            (userNumber % (uint32(10) ** (bracket + 1)));\r\n\r\n        // Confirm that the two transformed numbers are the same, if not throw\r\n        if (transformedWinningNumber != transformedUserNumber) {\r\n            return 0;\r\n        } else {\r\n            return _lotteries[idLottery].tokenPerBracket[bracket];\r\n        }\r\n    }\r\n\r\n    function _checkTicketHighestBracket(\r\n        uint256 idLottery,\r\n        uint256 idTicket\r\n    ) internal view returns (bool, uint32) {\r\n        // Retrieve the winning number combination\r\n        uint32 userNumber = _lotteries[idLottery].finalNumber;\r\n\r\n        // Retrieve the user number combination from the idTicket\r\n        uint32 winningTicketNumber = _tickets[idTicket].number;\r\n\r\n        uint32 bracket = 0;\r\n        uint32 bracketToClaim = 0;\r\n        bool highest = false;\r\n        bool won = false;\r\n        \r\n        while (bracket < 6 && !highest) {\r\n            // Apply transformation to verify the claim provided by the user is true\r\n            uint32 transformedWinningNumber = _bracketCalculator[bracket] +\r\n                (winningTicketNumber % (uint32(10) ** (bracket + 1)));\r\n\r\n            uint32 transformedUserNumber = _bracketCalculator[bracket] +\r\n                (userNumber % (uint32(10) ** (bracket + 1)));\r\n\r\n            // Confirm that the two transformed numbers are the same, if not throw\r\n            if (transformedWinningNumber != transformedUserNumber) {\r\n                highest = true;\r\n                bracket += 1;\r\n            } else {\r\n                bracketToClaim = bracket;\r\n                won = true;\r\n                bracket += 1;\r\n            }\r\n        }\r\n\r\n        return (won, bracketToClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate final price for bulk of tickets\r\n     * @param divisorForDiscount: divisor for the discount (the smaller it is, the greater the discount is)\r\n     * @param _priceTicket: price of a ticket\r\n     * @param _numberTickets: number of tickets purchased\r\n     */\r\n    function _calculateTotalPriceForBulkTickets(\r\n        uint256 divisorForDiscount,\r\n        uint256 _priceTicket,\r\n        uint256 _numberTickets\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            (_priceTicket *\r\n                _numberTickets *\r\n                (divisorForDiscount + 1 - _numberTickets)) / divisorForDiscount;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a contract\r\n     */\r\n    function _isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/* RANDOM NUMBER GENERATOR */\r\n\r\ncontract RandomNumberGenerator is IRandomNumberGenerator, WDYM {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public lottery;\r\n    bytes32 public keyHash;\r\n    bytes32 public latestRequestId;\r\n    uint32 public randomResult;\r\n    uint256 public latestLotteryId;\r\n\r\n    constructor(address lotteryAddress, address newOwner) {\r\n        lottery = lotteryAddress;\r\n        transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Request randomness from a user-provided seed\r\n     * @param theSeed: seed provided by the lottery\r\n     */\r\n    function getRandomNumber(uint256 theSeed) external {\r\n        latestRequestId = keccak256(abi.encodePacked(keyHash, theSeed));\r\n        randomResult = uint32(\r\n            0.001 gwei + (uint256(latestRequestId) % 0.001 gwei)\r\n        );\r\n        latestLotteryId = ILottery(lottery).viewCurrentLotteryId();\r\n    }\r\n\r\n    /**\r\n     * @notice Change the keyHash\r\n     * @param hashKey: new keyHash\r\n     */\r\n    function setKeyHash(bytes32 hashKey) external onlyOwner {\r\n        keyHash = hashKey;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address for the lottery\r\n     * @param lotteryAddress: address of the lottery\r\n     */\r\n    function setLotteryAddress(address lotteryAddress) external onlyOwner {\r\n        require(\r\n            lotteryAddress != address(0),\r\n            \"Cannot set Raffle address as null address\"\r\n        );\r\n        lottery = lotteryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice It allows the admin to withdraw tokens sent to the contract\r\n     * @param addressToken: the address of the token to withdraw\r\n     * @param amountToken: the number of token amount to withdraw\r\n     * @dev Only callable by owner.\r\n     */\r\n    function withdrawTokens(\r\n        address addressToken,\r\n        uint256 amountToken\r\n    ) external onlyOwner {\r\n        IERC20(addressToken).safeTransfer(address(msg.sender), amountToken);\r\n    }\r\n\r\n    /**\r\n     * @notice View latestLotteryId\r\n     */\r\n    function viewLatestLotteryId() external view returns (uint256) {\r\n        return latestLotteryId;\r\n    }\r\n\r\n    /**\r\n     * @notice View random result\r\n     */\r\n    function viewRandomResult() external view returns (uint32) {\r\n        return randomResult;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lotteryTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initLotteryDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initDefaultTicketPriceInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initDefaultDivisorForDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initDefaultFeeTreasury\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"initDefaultBreakdownRewards\",\"type\":\"uint256[6]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTicketIdNextLottery\",\"type\":\"uint256\"}],\"name\":\"LotteryClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"injectedAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryInjection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"countWinningTickets\",\"type\":\"uint256\"}],\"name\":\"LotteryNumberDrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceTicketInToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTicketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"injectedAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"injector\",\"type\":\"address\"}],\"name\":\"NewOperatorAndTreasuryAndInjectorAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"randomGenerator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"finalNumber\",\"type\":\"uint32\"}],\"name\":\"NewRandomGenerator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"TicketsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"TicketsPurchase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LENGTH_LOTTERY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TREASURY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DISCOUNT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LENGTH_LOTTERY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"ticketNumbers\",\"type\":\"uint32[]\"}],\"name\":\"buyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"divisorForDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTicket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"calculateTotalPriceForBulkTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"randomGeneratorAddress\",\"type\":\"address\"}],\"name\":\"changeRandomGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"idsTicket\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32[]\",\"name\":\"brackets\",\"type\":\"uint32[]\"}],\"name\":\"claimTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"}],\"name\":\"closeLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTicketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defaultBreakdownRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultDivisorForDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeeTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTicketPriceInToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"autoInjection\",\"type\":\"bool\"}],\"name\":\"drawFinalNumberAndMakeLotteryClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalInjectedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewardsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTicketsSoldForCurrentLottery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRewardsReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTicketCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"injectFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"injectorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNumberTicketsPerBuyOrClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumTicketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTicketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingInjectionNextLottery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomGenerator\",\"outputs\":[{\"internalType\":\"contract IRandomNumberGenerator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNumberTicketsPerBuy\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberTicketsPerBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumPrice\",\"type\":\"uint256\"}],\"name\":\"setMinAndMaxTicketPriceInToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressInjector\",\"type\":\"address\"}],\"name\":\"setOperatorAndTreasuryAndInjectorAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketPriceInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisorForDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"breakdownRewards\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"feeTreasury\",\"type\":\"uint256\"}],\"name\":\"startLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInjectedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"initDefaultBreakdownRewards\",\"type\":\"uint256[6]\"}],\"name\":\"updateDefaultBreakdownRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initDefaultDivisorForDiscount\",\"type\":\"uint256\"}],\"name\":\"updateDefaultDivisorForDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initDefaultFeeTreasury\",\"type\":\"uint256\"}],\"name\":\"updateDefaultFeeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initDefaultTicketPriceInToken\",\"type\":\"uint256\"}],\"name\":\"updateDefaultTicketPriceInToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initLotteryDuration\",\"type\":\"uint256\"}],\"name\":\"updateLotteryDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"}],\"name\":\"userInitiateLotteryFinalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewCurrentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"}],\"name\":\"viewLottery\",\"outputs\":[{\"components\":[{\"internalType\":\"enum WDYMRaffle.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTicketInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"rewardsBreakdown\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"tokenPerBracket\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256[6]\",\"name\":\"countWinnersPerBracket\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"firstTicketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstTicketIdNextLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollectedInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"finalNumber\",\"type\":\"uint32\"}],\"internalType\":\"struct WDYMRaffle.Lottery\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"idsTicket\",\"type\":\"uint256[]\"}],\"name\":\"viewNumbersAndStatusesForTicketIds\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idTicket\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"bracket\",\"type\":\"uint32\"}],\"name\":\"viewRewardsForTicketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewUserInfoForLotteryId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WDYMRaffle", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000769c6f0c5c2bcd1b76638bd58e5350f5c94128f300000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000056bc75e2d63100000000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000038400000000000000000000000000000000000000000000000000000000000005dc00000000000000000000000000000000000000000000000000000000000009c40000000000000000000000000000000000000000000000000000000000001194", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a80d3ff8c8ad9d9ed4534d9c698d34855878a72b5276bae263dcbfc2ddbd5b99"}