{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Agora/IAgoraERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Powered by Agora\\r\\n\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport {IAgoraERC20Config} from \\\"./IAgoraERC20Config.sol\\\";\\r\\n\\r\\ninterface IAgoraERC20 is IAgoraERC20Config, IERC20, IERC20Metadata {\\r\\n    function addLiquidity() external payable returns (address);\\r\\n\\r\\n    event LiquidityLocked(uint256 lpTokens, uint256 daysLocked);\\r\\n    event TaxesLowered(\\r\\n        uint256 previousBuyTax,\\r\\n        uint256 previousSellTax,\\r\\n        uint256 newBuyTax,\\r\\n        uint256 newSellTax\\r\\n    );\\r\\n    event LPTaxLowered(\\r\\n        uint256 previousBuyTax,\\r\\n        uint256 previousSellTax,\\r\\n        uint256 newBuyTax,\\r\\n        uint256 newSellTax\\r\\n    );\\r\\n    event LiquidityAdded(\\r\\n        uint256 tokensSupplied,\\r\\n        uint256 ethSupplied,\\r\\n        uint256 lpTokensIssued\\r\\n    );\\r\\n    event LimitsRaised(\\r\\n        uint128 oldBuyLimit,\\r\\n        uint128 oldSellLimit,\\r\\n        uint128 oldMaxWallet,\\r\\n        uint128 newBuyLimit,\\r\\n        uint128 newSellLimit,\\r\\n        uint128 newMaxWallet\\r\\n    );\\r\\n    event LiquidityBurned(uint256 liquidityBurned);\\r\\n    event LiquiditySupplied(uint256 tokens, uint256 eth);\\r\\n    event ExternalCallError(uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Agora/IAgoraERC20Config.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Powered by Agora\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IAgoraERC20Config {\\r\\n\\r\\n    /**\\r\\n     * @dev information used to construct the token.\\r\\n     */\\r\\n    struct TokenConstructorParameters {\\r\\n        bytes baseParameters;\\r\\n        bytes taxParameters;\\r\\n        bytes tokenLPInfo;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Basic info of the token\\r\\n     */\\r\\n    struct TokenInfoParameters {\\r\\n        string name;\\r\\n        string symbol;\\r\\n        bool autoCreateLiquidity;\\r\\n        uint256 maxSupply;\\r\\n        address tokensRecepient;\\r\\n        uint256 maxTokensWallet;\\r\\n        bool payInTax;\\r\\n        bool protectLiquidity;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @dev This struct express the taxes on per 1000, to allow percetanges between 0 and 1. \\r\\n     */\\r\\n    struct TaxParameters {\\r\\n        uint256 buyTax;\\r\\n        uint256 sellTax;\\r\\n        uint256 lpBuyTax;\\r\\n        uint256 lpSellTax;\\r\\n        uint256 maxTxBuy;\\r\\n        uint256 maxTxSell;\\r\\n        address taxSwapRecepient;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Liquidity pool supply information\\r\\n     */\\r\\n    struct TokenLpInfo {\\r\\n        uint256 lpTokensupply;\\r\\n        uint256 ethForSupply;\\r\\n        bool burnLP;\\r\\n        uint256 lockFee;\\r\\n        uint256 lpLockUpInDays;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Agora/Security/Authoritative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.21;\\r\\n\\r\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\r\\nimport {IAuthErrors} from \\\"./Errors.sol\\\";\\r\\nimport {Revertible} from \\\"../Utils/Revertible.sol\\\";\\r\\n\\r\\ncontract Authoritative is IAuthErrors, Revertible {\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\r\\n    EnumerableSet.AddressSet private Admins;\\r\\n    address public SuperAdmin;\\r\\n\\r\\n    event SuperAdminTransferred(address oldSuperAdmin, address newSuperAdmin);\\r\\n    event PlatformAdminAdded(address platformAdmin);\\r\\n    event PlatformAdminRevoked(address platformAdmin);\\r\\n\\r\\n    modifier onlySuperAdmin() {\\r\\n        if (!IsSuperAdmin(msg.sender)) {\\r\\n            revert CallerIsNotSuperAdmin(msg.sender);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPlatformAdmin() {\\r\\n        if (!IsPlatformAdmin(msg.sender))\\r\\n            revert CallerIsNotPlatformAdmin(msg.sender);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function IsSuperAdmin(address addressToCheck) public view returns (bool) {\\r\\n        return (SuperAdmin == addressToCheck);\\r\\n    }\\r\\n\\r\\n    function IsPlatformAdmin(\\r\\n        address addressToCheck\\r\\n    ) public view returns (bool) {\\r\\n        return (Admins.contains(addressToCheck));\\r\\n    }\\r\\n\\r\\n    function GrantPlatformAdmin(\\r\\n        address newPlatformAdmin_\\r\\n    ) public onlySuperAdmin {\\r\\n        if (newPlatformAdmin_ == address(0)) {\\r\\n            Revert(PlatformAdminCannotBeAddressZero.selector);\\r\\n        }\\r\\n        // Add this to the enumerated list:\\r\\n        Admins.add(newPlatformAdmin_);\\r\\n        emit PlatformAdminAdded(newPlatformAdmin_);\\r\\n    }\\r\\n\\r\\n    function RevokePlatformAdmin(address oldAdmin) public onlySuperAdmin {\\r\\n        Admins.remove(oldAdmin);\\r\\n        emit PlatformAdminRevoked(oldAdmin);\\r\\n    }\\r\\n\\r\\n    function TransferSuperAdmin(address newSuperAdmin) public onlySuperAdmin {\\r\\n        address oldSuperAdmin = SuperAdmin;\\r\\n        SuperAdmin = newSuperAdmin;\\r\\n        emit SuperAdminTransferred(oldSuperAdmin, newSuperAdmin);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Agora/Security/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.21;\\r\\n\\r\\ninterface IAuthErrors {\\r\\n    error CallerIsNotSuperAdmin(address caller);\\r\\n    error CallerIsNotPlatformAdmin(address caller);\\r\\n    error PlatformAdminCannotBeAddressZero();\\r\\n}\"\r\n    },\r\n    \"contracts/Agora/Security/Nukable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// Starship Contract Factory\\r\\n// Powered by Agora\\r\\n\\r\\npragma solidity 0.8.21;\\r\\n\\r\\ncontract Nukable {\\r\\n\\r\\n    bool internal IsNuked;\\r\\n    event Nuked();\\r\\n\\r\\n    modifier IfNotNuked() {\\r\\n        if(IsNuked) {\\r\\n            revert(\\\"This contract has been nuked and it is not operational\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function Nuke() internal {\\r\\n        IsNuked = true;\\r\\n        emit Nuked();\\r\\n    }\\r\\n    \\r\\n}\"\r\n    },\r\n    \"contracts/Agora/Utils/Revertible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Powered by Agora\\r\\n\\r\\npragma solidity 0.8.21;\\r\\n\\r\\nabstract contract Revertible {\\r\\n    function Revert(bytes4 errorSelector) internal pure {\\r\\n        assembly {\\r\\n            mstore(0x00, errorSelector)\\r\\n            revert(0x00, 0x04)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/StarShip/IFactoryErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.21;\\r\\n\\r\\ninterface IFactoryErrors {\\r\\n    error TreasuryAddressCanNotBeNull();\\r\\n    error RouterAddressCanNotBeNull();\\r\\n    error TransactionUnderpriced();\\r\\n}\"\r\n    },\r\n    \"contracts/StarShip/Interfaces/IStarShipDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Powered by Agora\\r\\n\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\n\\r\\ninterface IStarShipDeployer {\\r\\n    error DeploymentError();\\r\\n    error InvalidID();\\r\\n\\r\\n    function DeployNewToken(\\r\\n        bytes32 salt,\\r\\n        bytes32 hash,\\r\\n        bytes memory arguments\\r\\n    ) external payable returns (address erc20Address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/StarShip/Interfaces/IStarShipFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Powered by Agora\\r\\n\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\nimport {IAgoraERC20Config} from \\\"../../Agora/IAgoraERC20Config.sol\\\";\\r\\n\\r\\ninterface IStarShipFactory  is IAgoraERC20Config {\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/StarShip/StarShipFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Starship Contract Factory\\r\\n// Powered by Agora\\r\\n\\r\\npragma solidity 0.8.21;\\r\\n\\r\\nimport {IAgoraERC20} from \\\"../Agora/IAgoraERC20.sol\\\";\\r\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport {IStarShipDeployer} from \\\"./Interfaces/IStarShipDeployer.sol\\\";\\r\\nimport {IStarShipFactory} from \\\"./Interfaces/IStarShipFactory.sol\\\";\\r\\nimport {IFactoryErrors} from \\\"./IFactoryErrors.sol\\\";\\r\\nimport {Nukable} from \\\"../Agora/Security/Nukable.sol\\\";\\r\\nimport {Authoritative} from \\\"../Agora/Security/Authoritative.sol\\\";\\r\\nimport {Revertible} from \\\"../Agora/Utils/Revertible.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Starship contract factory\\r\\n */\\r\\ncontract StarShipFactory is\\r\\n    Context,\\r\\n    Nukable,\\r\\n    Authoritative,\\r\\n    IStarShipFactory,\\r\\n    IFactoryErrors\\r\\n{\\r\\n    uint256 internal constant CALL_GAS_LIMIT = 50000;\\r\\n\\r\\n    // The contract implementing UniswapV2 protocol\\r\\n    address public immutable uniswapRouterV2InterfaceAddress;\\r\\n\\r\\n    mapping(address => address) _lastTokens;\\r\\n\\r\\n    // Contract to deploy tokens\\r\\n    address payable public deployerAddress;\\r\\n\\r\\n    // The address where all the eth collected by the service will end up in.\\r\\n    address public treasuryAddress;\\r\\n\\r\\n    // LP locker\\r\\n    address public locker;\\r\\n\\r\\n    // The cost in ether to deploy a token\\r\\n    uint256 public deploymentFee = 0.1 ether;\\r\\n\\r\\n    uint256 public lockFee = 0.01 ether;\\r\\n\\r\\n    /**\\r\\n     *\\r\\n     * @param superAdmin The supreme ruler of the factory, can do everything\\r\\n     * @param admins The list of wallets that can perofrm operations with elevated privileges\\r\\n     * @param treasury Where the collection of taxes will go\\r\\n     */\\r\\n    constructor(\\r\\n        address superAdmin,\\r\\n        address[] memory admins,\\r\\n        address treasury,\\r\\n        address tokenLocker,\\r\\n        address uniswapRouter\\r\\n    ) {\\r\\n        SuperAdmin = superAdmin;\\r\\n        GrantPlatformAdmin(superAdmin);\\r\\n        for (uint256 i = 0; i < admins.length; ) {\\r\\n            GrantPlatformAdmin(admins[i]);\\r\\n            unchecked {\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (treasury == address(0)) {\\r\\n            Revert(TreasuryAddressCanNotBeNull.selector);\\r\\n        }\\r\\n\\r\\n        if (uniswapRouter == address(0)) {\\r\\n            Revert(RouterAddressCanNotBeNull.selector);\\r\\n        }\\r\\n        uniswapRouterV2InterfaceAddress = uniswapRouter;\\r\\n        treasuryAddress = treasury;\\r\\n        locker = tokenLocker;\\r\\n    }\\r\\n\\r\\n    function setTreasury(address newAddress) external onlySuperAdmin{\\r\\n        treasuryAddress = newAddress;\\r\\n    }\\r\\n\\r\\n    function changeFee(uint256 newFee) external onlySuperAdmin {\\r\\n        deploymentFee = newFee;\\r\\n    }\\r\\n\\r\\n    function withdrawEth() external onlySuperAdmin {\\r\\n        uint256 gas = (CALL_GAS_LIMIT == 0 || CALL_GAS_LIMIT > gasleft())\\r\\n            ? gasleft()\\r\\n            : CALL_GAS_LIMIT;\\r\\n\\r\\n        bool success;\\r\\n        // We limit the gas passed so that a called address cannot cause a block out of gas error:\\r\\n        (success, ) = SuperAdmin.call{value: address(this).balance, gas: gas}(\\r\\n            \\\"\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function SetDeployerAddress(\\r\\n        address newDeployerAddress\\r\\n    ) external onlySuperAdmin {\\r\\n        deployerAddress = payable(newDeployerAddress);\\r\\n    }\\r\\n\\r\\n    function GetLastCreatedToken() public view returns (address) {\\r\\n        return _lastTokens[_msgSender()];\\r\\n    }\\r\\n\\r\\n    function NukeFactory() external onlySuperAdmin {\\r\\n        Nuke();\\r\\n    }\\r\\n\\r\\n    function CreateNewERC20(\\r\\n        bytes32 salt,\\r\\n        string calldata deploymentID,\\r\\n        TokenConstructorParameters calldata tokenConfig\\r\\n    ) external payable IfNotNuked returns (address erc20Address) {\\r\\n        address[5] memory integrationAddresses = [\\r\\n            _msgSender(),\\r\\n            uniswapRouterV2InterfaceAddress,\\r\\n            locker,\\r\\n            address(this),\\r\\n            treasuryAddress\\r\\n        ];\\r\\n\\r\\n        TokenLpInfo memory tokenLpInfo = abi.decode(\\r\\n            tokenConfig.tokenLPInfo,\\r\\n            (TokenLpInfo)\\r\\n        );\\r\\n        tokenLpInfo.lockFee = lockFee;\\r\\n\\r\\n        bytes memory args = abi.encode(\\r\\n            integrationAddresses,\\r\\n            tokenConfig.baseParameters,\\r\\n            tokenConfig.taxParameters,\\r\\n            abi.encode(tokenLpInfo)\\r\\n        );\\r\\n\\r\\n        address tokenAddress = IStarShipDeployer(deployerAddress)\\r\\n            .DeployNewToken(\\r\\n                salt,\\r\\n                keccak256(abi.encodePacked(deploymentID)),\\r\\n                args\\r\\n            );\\r\\n        _lastTokens[_msgSender()] = tokenAddress;\\r\\n\\r\\n        // Decoding paramets\\r\\n        TokenInfoParameters memory tokenInfo = abi.decode(\\r\\n            tokenConfig.baseParameters,\\r\\n            (TokenInfoParameters)\\r\\n        );\\r\\n\\r\\n        if (tokenInfo.autoCreateLiquidity) {\\r\\n            TokenLpInfo memory lpInfo = abi.decode(\\r\\n                tokenConfig.tokenLPInfo,\\r\\n                (TokenLpInfo)\\r\\n            );\\r\\n            _processLiquidityParams(tokenAddress, lpInfo, tokenInfo);\\r\\n        }\\r\\n\\r\\n        return tokenAddress;\\r\\n    }\\r\\n\\r\\n    function _processLiquidityParams(\\r\\n        address tokenAddress,\\r\\n        TokenLpInfo memory params,\\r\\n        TokenInfoParameters memory configParams\\r\\n    ) internal {\\r\\n        uint256 totalFee = params.ethForSupply;\\r\\n        uint256 totalLiquidityFee = totalFee;\\r\\n        if (!configParams.payInTax) {\\r\\n            totalFee += deploymentFee;\\r\\n        }\\r\\n\\r\\n        if (!params.burnLP) {\\r\\n            totalFee += lockFee;\\r\\n            totalLiquidityFee += lockFee;\\r\\n        }\\r\\n\\r\\n        if (msg.value < totalFee) {\\r\\n            Revert(TransactionUnderpriced.selector);\\r\\n        }\\r\\n\\r\\n        IAgoraERC20(tokenAddress).addLiquidity{value: totalLiquidityFee}();\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superAdmin\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenLocker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotPlatformAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotSuperAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RouterAddressCanNotBeNull\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransactionUnderpriced\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TreasuryAddressCanNotBeNull\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Nuked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"platformAdmin\",\"type\":\"address\"}],\"name\":\"PlatformAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"platformAdmin\",\"type\":\"address\"}],\"name\":\"PlatformAdminRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldSuperAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSuperAdmin\",\"type\":\"address\"}],\"name\":\"SuperAdminTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"deploymentID\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"baseParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"taxParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"tokenLPInfo\",\"type\":\"bytes\"}],\"internalType\":\"struct IAgoraERC20Config.TokenConstructorParameters\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"name\":\"CreateNewERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetLastCreatedToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPlatformAdmin_\",\"type\":\"address\"}],\"name\":\"GrantPlatformAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"IsPlatformAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"IsSuperAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NukeFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"RevokePlatformAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployerAddress\",\"type\":\"address\"}],\"name\":\"SetDeployerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SuperAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSuperAdmin\",\"type\":\"address\"}],\"name\":\"TransferSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployerAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouterV2InterfaceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StarShipFactory", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002a384fd9e2f27621a0b80d12974dd2aceb250e2e00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000002a384fd9e2f27621a0b80d12974dd2aceb250e2e0000000000000000000000002a384fd9e2f27621a0b80d12974dd2aceb250e2e00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000002a384fd9e2f27621a0b80d12974dd2aceb250e2e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}