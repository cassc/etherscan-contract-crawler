{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides a function to batch together multiple calls in a single external call.\r\n *\r\n * _Available since v4.1._\r\n */\r\nabstract contract Multicall {\r\n    /**\r\n     * @dev Receives and executes a batch of function calls on this contract.\r\n     */\r\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/** ****************************************************************************\r\n * @notice Interface for contracts using VRF randomness\r\n * *****************************************************************************\r\n * @dev PURPOSE\r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n * @dev Reggie, he gives back a value which is computed completely\r\n * @dev deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n * @dev the output is indistinguishable to her from a uniform random sample\r\n * @dev from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\r\n * @dev 1. The fulfillment came from the VRFCoordinator\r\n * @dev 2. The consumer contract implements fulfillRandomWords.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\r\n * @dev initialize VRFConsumerBase's attributes in their constructor as\r\n * @dev shown:\r\n *\r\n * @dev   contract VRFConsumer {\r\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\r\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\r\n * @dev         <initialization with other arguments goes here>\r\n * @dev       }\r\n * @dev   }\r\n *\r\n * @dev The oracle will have given you an ID for the VRF keypair they have\r\n * @dev committed to (let's call it keyHash). Create subscription, fund it\r\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\r\n * @dev subscription management functions).\r\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\r\n * @dev callbackGasLimit, numWords),\r\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\r\n *\r\n * @dev Once the VRFCoordinator has received and validated the oracle's response\r\n * @dev to your request, it will call your contract's fulfillRandomWords method.\r\n *\r\n * @dev The randomness argument to fulfillRandomWords is a set of random words\r\n * @dev generated from your requestId and the blockHash of the request.\r\n *\r\n * @dev If your contract could have concurrent requests open, you can use the\r\n * @dev requestId returned from requestRandomWords to track which response is associated\r\n * @dev with which randomness request.\r\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n * @dev if your contract could have multiple requests in flight simultaneously.\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * @dev differ.\r\n *\r\n * *****************************************************************************\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev A method with the ability to call your fulfillRandomness method directly\r\n * @dev could spoof a VRF response with any random value, so it's critical that\r\n * @dev it cannot be directly called by anything other than this base contract\r\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\r\n *\r\n * @dev For your users to trust that your contract's random behavior is free\r\n * @dev from malicious interference, it's best if you can write it so that all\r\n * @dev behaviors implied by a VRF response are executed *during* your\r\n * @dev fulfillRandomness method. If your contract must store the response (or\r\n * @dev anything derived from it) and use it later, you must ensure that any\r\n * @dev user-significant behavior which depends on that stored value cannot be\r\n * @dev manipulated by a subsequent VRF request.\r\n *\r\n * @dev Similarly, both miners and the VRF oracle itself have some influence\r\n * @dev over the order in which VRF responses appear on the blockchain, so if\r\n * @dev your contract could have multiple VRF requests in flight simultaneously,\r\n * @dev you must ensure that the order in which the VRF responses arrive cannot\r\n * @dev be used to manipulate your contract's user-significant behavior.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness\r\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n * @dev miner could, in principle, fork the blockchain to evict the block\r\n * @dev containing the request, forcing the request to be included in a\r\n * @dev different block with a different hash, and therefore a different input\r\n * @dev to the VRF. However, such an attack would incur a substantial economic\r\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n * @dev until it calls responds to a request. It is for this reason that\r\n * @dev that you can signal to an oracle you'd like them to wait longer before\r\n * @dev responding to the request (however this is not enforced in the contract\r\n * @dev and so remains effective only in the case of unmodified oracle software).\r\n */\r\nabstract contract VRFConsumerBaseV2 {\r\n  error OnlyCoordinatorCanFulfill(address have, address want);\r\n  address private immutable vrfCoordinator;\r\n\r\n  /**\r\n   * @param _vrfCoordinator address of VRFCoordinator contract\r\n   */\r\n  constructor(address _vrfCoordinator) {\r\n    vrfCoordinator = _vrfCoordinator;\r\n  }\r\n\r\n  /**\r\n   * @notice fulfillRandomness handles the VRF response. Your contract must\r\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n   * @notice principles to keep in mind when implementing your fulfillRandomness\r\n   * @notice method.\r\n   *\r\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\r\n   * @dev signature, and will call it once it has verified the proof\r\n   * @dev associated with the randomness. (It is triggered via a call to\r\n   * @dev rawFulfillRandomness, below.)\r\n   *\r\n   * @param requestId The Id initially returned by requestRandomness\r\n   * @param randomWords the VRF output expanded to the requested number of words\r\n   */\r\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\r\n\r\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n  // the origin of the call\r\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\r\n    if (msg.sender != vrfCoordinator) {\r\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\r\n    }\r\n    fulfillRandomWords(requestId, randomWords);\r\n  }\r\n}\r\n\r\ninterface VRFCoordinatorV2Interface {\r\n  /**\r\n   * @notice Get configuration relevant for making requests\r\n   * @return minimumRequestConfirmations global min for request confirmations\r\n   * @return maxGasLimit global max for request gas limit\r\n   * @return s_provingKeyHashes list of registered key hashes\r\n   */\r\n  function getRequestConfig()\r\n    external\r\n    view\r\n    returns (\r\n      uint16,\r\n      uint32,\r\n      bytes32[] memory\r\n    );\r\n\r\n  /**\r\n   * @notice Request a set of random words.\r\n   * @param keyHash - Corresponds to a particular oracle job which uses\r\n   * that key for generating the VRF proof. Different keyHash's have different gas price\r\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\r\n   * @param subId  - The ID of the VRF subscription. Must be funded\r\n   * with the minimum subscription balance required for the selected keyHash.\r\n   * @param minimumRequestConfirmations - How many blocks you'd like the\r\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\r\n   * for why you may want to request more. The acceptable range is\r\n   * [minimumRequestBlockConfirmations, 200].\r\n   * @param callbackGasLimit - How much gas you'd like to receive in your\r\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\r\n   * may be slightly less than this amount because of gas used calling the function\r\n   * (argument decoding etc.), so you may need to request slightly more than you expect\r\n   * to have inside fulfillRandomWords. The acceptable range is\r\n   * [0, maxGasLimit]\r\n   * @param numWords - The number of uint256 random values you'd like to receive\r\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\r\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\r\n   * @return requestId - A unique identifier of the request. Can be used to match\r\n   * a request to a response in fulfillRandomWords.\r\n   */\r\n  function requestRandomWords(\r\n    bytes32 keyHash,\r\n    uint64 subId,\r\n    uint16 minimumRequestConfirmations,\r\n    uint32 callbackGasLimit,\r\n    uint32 numWords\r\n  ) external returns (uint256 requestId);\r\n\r\n  /**\r\n   * @notice Create a VRF subscription.\r\n   * @return subId - A unique subscription id.\r\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\r\n   * @dev Note to fund the subscription, use transferAndCall. For example\r\n   * @dev  LINKTOKEN.transferAndCall(\r\n   * @dev    address(COORDINATOR),\r\n   * @dev    amount,\r\n   * @dev    abi.encode(subId));\r\n   */\r\n  function createSubscription() external returns (uint64 subId);\r\n\r\n  /**\r\n   * @notice Get a VRF subscription.\r\n   * @param subId - ID of the subscription\r\n   * @return balance - LINK balance of the subscription in juels.\r\n   * @return reqCount - number of requests for this subscription, determines fee tier.\r\n   * @return owner - owner of the subscription.\r\n   * @return consumers - list of consumer address which are able to use this subscription.\r\n   */\r\n  function getSubscription(uint64 subId)\r\n    external\r\n    view\r\n    returns (\r\n      uint96 balance,\r\n      uint64 reqCount,\r\n      address owner,\r\n      address[] memory consumers\r\n    );\r\n\r\n  /**\r\n   * @notice Request subscription owner transfer.\r\n   * @param subId - ID of the subscription\r\n   * @param newOwner - proposed new owner of the subscription\r\n   */\r\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\r\n\r\n  /**\r\n   * @notice Request subscription owner transfer.\r\n   * @param subId - ID of the subscription\r\n   * @dev will revert if original owner of subId has\r\n   * not requested that msg.sender become the new owner.\r\n   */\r\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\r\n\r\n  /**\r\n   * @notice Add a consumer to a VRF subscription.\r\n   * @param subId - ID of the subscription\r\n   * @param consumer - New consumer which can use the subscription\r\n   */\r\n  function addConsumer(uint64 subId, address consumer) external;\r\n\r\n  /**\r\n   * @notice Remove a consumer from a VRF subscription.\r\n   * @param subId - ID of the subscription\r\n   * @param consumer - Consumer to remove from the subscription\r\n   */\r\n  function removeConsumer(uint64 subId, address consumer) external;\r\n\r\n  /**\r\n   * @notice Cancel a subscription\r\n   * @param subId - ID of the subscription\r\n   * @param to - Where to send the remaining LINK to\r\n   */\r\n  function cancelSubscription(uint64 subId, address to) external;\r\n\r\n  /*\r\n   * @notice Check to see if there exists a request commitment consumers\r\n   * for all consumers and keyhashes for a given sub.\r\n   * @param subId - ID of the subscription\r\n   * @return true if there exists at least one unfulfilled request for the subscription, false\r\n   * otherwise.\r\n   */\r\n  function pendingRequestExists(uint64 subId) external view returns (bool);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\n/// @notice Minimal interface for Bank.\r\n/// @author Romuald Hog.\r\ninterface IBank {\r\n    /// @notice Gets the token's allow status used on the games smart contracts.\r\n    /// @param token Address of the token.\r\n    /// @return Whether the token is enabled for bets.\r\n    function isAllowedToken(address token) external view returns (bool);\r\n\r\n    /// @notice Payouts a winning bet, and allocate the house edge fee.\r\n    /// @param user Address of the gamer.\r\n    /// @param token Address of the token.\r\n    /// @param profit Number of tokens to be sent to the gamer.\r\n    /// @param fees Bet amount and bet profit fees amount.\r\n    function payout(\r\n        address user,\r\n        address token,\r\n        uint256 profit,\r\n        uint256 fees\r\n    ) external payable;\r\n\r\n    /// @notice Accounts a loss bet.\r\n    /// @dev In case of an ERC20, the bet amount should be transfered prior to this tx.\r\n    /// @dev In case of the gas token, the bet amount is sent along with this tx.\r\n    /// @param tokenAddress Address of the token.\r\n    /// @param amount Loss bet amount.\r\n    /// @param fees Bet amount and bet profit fees amount.\r\n    function cashIn(\r\n        address tokenAddress,\r\n        uint256 amount,\r\n        uint256 fees\r\n    ) external payable;\r\n\r\n    /// @notice Calculates the max bet amount based on the token balance, the balance risk, and the game multiplier.\r\n    /// @param token Address of the token.\r\n    /// @param multiplier The bet amount leverage determines the user's profit amount. 10000 = 100% = no profit.\r\n    /// @return Maximum bet amount for the token.\r\n    /// @dev The multiplier should be at least 10000.\r\n    function getMaxBetAmount(address token, uint256 multiplier)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getVRFSubId(address token) external view returns (uint64);\r\n\r\n    function getTokenOwner(address token) external view returns (address);\r\n\r\n    function getMinBetAmount(address token) external view returns (uint256);\r\n}\r\n\r\ninterface IVRFCoordinatorV2 is VRFCoordinatorV2Interface {\r\n    function getFeeConfig()\r\n        external\r\n        view\r\n        returns (\r\n            uint32 fulfillmentFlatFeeLinkPPMTier1,\r\n            uint32 fulfillmentFlatFeeLinkPPMTier2,\r\n            uint32 fulfillmentFlatFeeLinkPPMTier3,\r\n            uint32 fulfillmentFlatFeeLinkPPMTier4,\r\n            uint32 fulfillmentFlatFeeLinkPPMTier5,\r\n            uint24 reqsForTier2,\r\n            uint24 reqsForTier3,\r\n            uint24 reqsForTier4,\r\n            uint24 reqsForTier5\r\n        );\r\n}\r\n\r\n/// @title Game base contract\r\n/// @author Romuald Hog\r\n/// @notice This should be parent contract of each games.\r\n/// It defines all the games common functions and state variables.\r\n/// @dev All rates are in basis point. Chainlink VRF v2 is used.\r\nabstract contract Game is\r\n    Ownable,\r\n    Pausable,\r\n    Multicall,\r\n    VRFConsumerBaseV2,\r\n    ReentrancyGuard\r\n{\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice Bet information struct.\r\n    /// @param resolved Whether the bet has been resolved.\r\n    /// @param user Address of the gamer.\r\n    /// @param token Address of the token.\r\n    /// @param id Bet ID generated by Chainlink VRF.\r\n    /// @param amount The bet amount.\r\n    /// @param blockNumber Block number of the bet used to refund in case Chainlink's callback fail.\r\n    /// @param payout The payout amount.\r\n    /// @param vrfCost The Chainlink VRF cost paid by player.\r\n    struct Bet {\r\n        bool resolved;\r\n        address user;\r\n        address token;\r\n        uint256 id;\r\n        uint256 amount;\r\n        uint256 blockNumber;\r\n        uint256 payout;\r\n        uint256 vrfCost;\r\n    }\r\n\r\n    /// @notice Token struct.\r\n    /// @param houseEdge House edge rate.\r\n    /// @param pendingCount Number of pending bets.\r\n    /// @param VRFCallbackGasLimit How much gas is needed in the Chainlink VRF callback.\r\n    /// @param VRFFees Chainlink's VRF collected fees amount.\r\n    struct Token {\r\n        uint16 houseEdge;\r\n        uint64 pendingCount;\r\n        uint32 VRFCallbackGasLimit;\r\n        uint256 VRFFees;\r\n    }\r\n\r\n    /// @notice Chainlink VRF configuration struct.\r\n    /// @param requestConfirmations How many confirmations the Chainlink node should wait before responding.\r\n    /// @param numRandomWords How many random words is needed to resolve a game's bet.\r\n    /// @param keyHash Hash of the public key used to verify the VRF proof.\r\n    /// @param chainlinkCoordinator Reference to the VRFCoordinatorV2 deployed contract.\r\n    /// @param gasAfterCalculation Gas to be added for VRF cost refund.\r\n    struct ChainlinkConfig {\r\n        uint16 requestConfirmations;\r\n        uint16 numRandomWords;\r\n        bytes32 keyHash;\r\n        IVRFCoordinatorV2 chainlinkCoordinator;\r\n        uint256 gasAfterCalculation;\r\n    }\r\n\r\n    /// @notice Chainlink VRF configuration state.\r\n    ChainlinkConfig private _chainlinkConfig;\r\n\r\n    /// @notice Chainlink price feed.\r\n    AggregatorV3Interface private immutable _LINK_ETH_feed;\r\n\r\n    /// @notice Maps bets IDs to Bet information.\r\n    mapping(uint256 => Bet) public bets;\r\n\r\n    /// @notice Maps users addresses to bets IDs\r\n    mapping(address => uint256[]) internal _userBets;\r\n\r\n    /// @notice Maps tokens addresses to token configuration.\r\n    mapping(address => Token) public tokens;\r\n\r\n    /// @notice Maps user addresses to VRF overcharged cost.\r\n    mapping(address => uint256) public userOverchargedVRFCost;\r\n\r\n    /// @notice The bank that manage to payout a won bet and collect a loss bet.\r\n    IBank public immutable bank;\r\n\r\n    /// @notice Emitted after the house edge is set for a token.\r\n    /// @param token Address of the token.\r\n    /// @param houseEdge House edge rate.\r\n    event SetHouseEdge(address indexed token, uint16 houseEdge);\r\n\r\n    /// @notice Emitted after the Chainlink callback gas limit is set for a token.\r\n    /// @param token Address of the token.\r\n    /// @param callbackGasLimit New Chainlink VRF callback gas limit.\r\n    event SetVRFCallbackGasLimit(\r\n        address indexed token,\r\n        uint32 callbackGasLimit\r\n    );\r\n\r\n    /// @notice Emitted after the Chainlink config is set.\r\n    /// @param requestConfirmations How many confirmations the Chainlink node should wait before responding.\r\n    /// @param keyHash Hash of the public key used to verify the VRF proof.\r\n    /// @param gasAfterCalculation Gas to be added for VRF cost refund.\r\n    event SetChainlinkConfig(\r\n        uint16 requestConfirmations,\r\n        bytes32 keyHash,\r\n        uint256 gasAfterCalculation\r\n    );\r\n\r\n    /// @notice Emitted after the bet amount is transfered to the user.\r\n    /// @param id The bet ID.\r\n    /// @param user Address of the gamer.\r\n    /// @param amount Number of tokens refunded.\r\n    /// @param chainlinkVRFCost The Chainlink VRF cost refunded to player.\r\n    event BetRefunded(\r\n        uint256 id,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 chainlinkVRFCost\r\n    );\r\n\r\n    /// @notice Emitted after the token's VRF fees amount is transfered to the user.\r\n    /// @param token Address of the token.\r\n    /// @param amount Number of tokens refunded.\r\n    event DistributeTokenVRFFees(address indexed token, uint256 amount);\r\n\r\n    /// @notice Emitted after the user's overcharged VRF cost amount is transfered.\r\n    /// @param user Address of the user.\r\n    /// @param overchargedVRFCost Number of tokens refunded.\r\n    event DistributeOverchargedVRFCost(\r\n        address indexed user,\r\n        uint256 overchargedVRFCost\r\n    );\r\n\r\n    /// @notice Emitted after the overcharged VRF cost amount is accounted.\r\n    /// @param user Address of the user.\r\n    /// @param overchargedVRFCost Number of tokens overcharged.\r\n    event AccountOverchargedVRFCost(\r\n        address indexed user,\r\n        uint256 overchargedVRFCost\r\n    );\r\n\r\n    /// @notice No user's overcharged Chainlink fee.\r\n    error NoOverchargedVRFCost();\r\n\r\n    /// @notice Insufficient bet amount.\r\n    /// @param minBetAmount Bet amount.\r\n    error UnderMinBetAmount(uint256 minBetAmount);\r\n\r\n    /// @notice Bet provided doesn't exist or was already resolved.\r\n    error NotPendingBet();\r\n\r\n    /// @notice Bet isn't resolved yet.\r\n    error NotFulfilled();\r\n\r\n    /// @notice House edge is capped at 4%.\r\n    error ExcessiveHouseEdge();\r\n\r\n    /// @notice Token is not allowed.\r\n    error ForbiddenToken();\r\n\r\n    /// @notice Chainlink price feed not working\r\n    /// @param linkWei LINK/ETH price returned.\r\n    error InvalidLinkWeiPrice(int256 linkWei);\r\n\r\n    /// @notice The msg.value is not enough to cover Chainlink's fee.\r\n    error WrongGasValueToCoverFee();\r\n\r\n    /// @notice Reverting error when sender isn't allowed.\r\n    error AccessDenied();\r\n\r\n    /// @notice Reverting error when provided address isn't valid.\r\n    error InvalidAddress();\r\n\r\n    /// @notice Reverting error when token has pending bets.\r\n    error TokenHasPendingBets();\r\n\r\n    /// @notice Initialize contract's state variables and VRF Consumer.\r\n    /// @param bankAddress The address of the bank.\r\n    /// @param chainlinkCoordinatorAddress Address of the Chainlink VRF Coordinator.\r\n    /// @param numRandomWords How many random words is needed to resolve a game's bet.\r\n    /// @param LINK_ETH_feedAddress Address of the Chainlink LINK/ETH price feed.\r\n    constructor(\r\n        address bankAddress,\r\n        address chainlinkCoordinatorAddress,\r\n        uint16 numRandomWords,\r\n        address LINK_ETH_feedAddress\r\n    ) VRFConsumerBaseV2(chainlinkCoordinatorAddress) {\r\n        if (\r\n            LINK_ETH_feedAddress == address(0) ||\r\n            chainlinkCoordinatorAddress == address(0) ||\r\n            bankAddress == address(0)\r\n        ) {\r\n            revert InvalidAddress();\r\n        }\r\n        require(\r\n            numRandomWords != 0 && numRandomWords <= 500,\r\n            \"Wrong Chainlink NumRandomWords\"\r\n        );\r\n\r\n        bank = IBank(bankAddress);\r\n        _chainlinkConfig.chainlinkCoordinator = IVRFCoordinatorV2(\r\n            chainlinkCoordinatorAddress\r\n        );\r\n        _chainlinkConfig.numRandomWords = numRandomWords;\r\n        _LINK_ETH_feed = AggregatorV3Interface(LINK_ETH_feedAddress);\r\n    }\r\n\r\n    /// @notice Calculates the amount's fee based on the house edge.\r\n    /// @param token Address of the token.\r\n    /// @param amount From which the fee amount will be calculated.\r\n    /// @return The fee amount.\r\n    function _getFees(address token, uint256 amount)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (tokens[token].houseEdge * amount) / 10000;\r\n    }\r\n\r\n    /// @notice Creates a new bet and request randomness to Chainlink,\r\n    /// transfer the ERC20 tokens to the contract or refund the bet amount overflow if the bet amount exceed the maxBetAmount.\r\n    /// @param tokenAddress Address of the token.\r\n    /// @param tokenAmount The number of tokens bet.\r\n    /// @param multiplier The bet amount leverage determines the user's profit amount. 10000 = 100% = no profit.\r\n    /// @return A new Bet struct information.\r\n    function _newBet(\r\n        address tokenAddress,\r\n        uint256 tokenAmount,\r\n        uint256 multiplier\r\n    ) internal whenNotPaused nonReentrant returns (Bet memory) {\r\n        Token storage token = tokens[tokenAddress];\r\n        if (\r\n            bank.isAllowedToken(tokenAddress) == false || token.houseEdge == 0\r\n        ) {\r\n            revert ForbiddenToken();\r\n        }\r\n\r\n        address user = msg.sender;\r\n        bool isGasToken = tokenAddress == address(0);\r\n        uint256 fee = isGasToken ? (msg.value - tokenAmount) : msg.value;\r\n        uint256 betAmount = isGasToken ? msg.value - fee : tokenAmount;\r\n\r\n        // Charge user for Chainlink VRF fee.\r\n        {\r\n            uint256 chainlinkVRFCost = getChainlinkVRFCost(tokenAddress);\r\n            if (fee < (chainlinkVRFCost - ((10 * chainlinkVRFCost) / 100))) {\r\n                // 10% slippage.\r\n                revert WrongGasValueToCoverFee();\r\n            }\r\n        }\r\n\r\n        // Bet amount is capped.\r\n        {\r\n            uint256 minBetAmount = bank.getMinBetAmount(tokenAddress);\r\n            if (betAmount < minBetAmount) {\r\n                revert UnderMinBetAmount(minBetAmount);\r\n            }\r\n\r\n            uint256 maxBetAmount = bank.getMaxBetAmount(\r\n                tokenAddress,\r\n                multiplier\r\n            );\r\n            if (betAmount > maxBetAmount) {\r\n                if (isGasToken) {\r\n                    Address.sendValue(payable(user), betAmount - maxBetAmount);\r\n                }\r\n                betAmount = maxBetAmount;\r\n            }\r\n        }\r\n\r\n        // Create bet\r\n        uint256 id = _chainlinkConfig.chainlinkCoordinator.requestRandomWords(\r\n            _chainlinkConfig.keyHash,\r\n            bank.getVRFSubId(tokenAddress),\r\n            _chainlinkConfig.requestConfirmations,\r\n            token.VRFCallbackGasLimit,\r\n            _chainlinkConfig.numRandomWords\r\n        );\r\n        Bet memory newBet = Bet(\r\n            false,\r\n            user,\r\n            tokenAddress,\r\n            id,\r\n            betAmount,\r\n            block.number,\r\n            0,\r\n            fee\r\n        );\r\n        _userBets[user].push(id);\r\n        bets[id] = newBet;\r\n        token.pendingCount++;\r\n\r\n        // If ERC20, transfer the tokens\r\n        if (!isGasToken) {\r\n            IERC20(tokenAddress).safeTransferFrom(\r\n                user,\r\n                address(this),\r\n                betAmount\r\n            );\r\n        }\r\n\r\n        return newBet;\r\n    }\r\n\r\n    /// @notice Calculates the overcharged VRF cost based on the gas consumed.\r\n    /// @param bet The Bet struct information.\r\n    /// @param startGas Gas amount at start.\r\n    function _accountVRFCost(Bet storage bet, uint256 startGas) internal {\r\n        (, int256 weiPerUnitLink, , , ) = _LINK_ETH_feed.latestRoundData();\r\n        if (weiPerUnitLink < 0) {\r\n            weiPerUnitLink = 0;\r\n        }\r\n        // Get Chainlink VRF v2 fee amount.\r\n        (\r\n            uint32 fulfillmentFlatFeeLinkPPMTier1,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = _chainlinkConfig.chainlinkCoordinator.getFeeConfig();\r\n        // Calculates the VRF premium fee in ETH\r\n        uint256 chainlinkPremium = ((1e12 *\r\n            uint256(fulfillmentFlatFeeLinkPPMTier1) *\r\n            uint256(weiPerUnitLink)) / 1e18);\r\n            \r\n        // Calculate the gas fee (adding the estimated gas spent after this calculation) + premium\r\n        uint256 actualVRFCost = (tx.gasprice *\r\n            (startGas - gasleft() + _chainlinkConfig.gasAfterCalculation)) +\r\n            chainlinkPremium;\r\n\r\n        // If the actual VRF cost is higher than what the player paid.\r\n        if (actualVRFCost > bet.vrfCost) {\r\n            actualVRFCost = bet.vrfCost;\r\n        } else {\r\n            // Otherwise credits it to his account.\r\n            uint256 overchargedVRFCost = bet.vrfCost - actualVRFCost;\r\n            userOverchargedVRFCost[bet.user] += overchargedVRFCost;\r\n            bet.vrfCost = actualVRFCost;\r\n            emit AccountOverchargedVRFCost(bet.user, overchargedVRFCost);\r\n        }\r\n\r\n        // Credits the actual VRF cost to fund the VRF subscription.\r\n        tokens[bet.token].VRFFees += actualVRFCost;\r\n    }\r\n\r\n    /// @notice Resolves the bet based on the game child contract result.\r\n    /// In case bet is won, the bet amount minus the house edge is transfered to user from the game contract, and the profit is transfered to the user from the Bank.\r\n    /// In case bet is lost, the bet amount is transfered to the Bank from the game contract.\r\n    /// @param bet The Bet struct information.\r\n    /// @param payout What should be sent to the user in case of a won bet. Payout = bet amount + profit amount.\r\n    /// @return The payout amount.\r\n    /// @dev Should not revert as it resolves the bet with the randomness.\r\n    function _resolveBet(Bet storage bet, uint256 payout)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (bet.resolved == true || bet.id == 0) {\r\n            revert NotPendingBet();\r\n        }\r\n        bet.resolved = true;\r\n\r\n        address token = bet.token;\r\n        tokens[token].pendingCount--;\r\n\r\n        uint256 betAmount = bet.amount;\r\n        bool isGasToken = bet.token == address(0);\r\n\r\n        if (payout > betAmount) {\r\n            // The user has won more than his bet\r\n            address user = bet.user;\r\n\r\n            uint256 profit = payout - betAmount;\r\n            uint256 betAmountFee = _getFees(token, betAmount);\r\n            uint256 profitFee = _getFees(token, profit);\r\n            uint256 fee = betAmountFee + profitFee;\r\n\r\n            payout -= fee;\r\n\r\n            uint256 betAmountPayout = betAmount - betAmountFee;\r\n            uint256 profitPayout = profit - profitFee;\r\n            // Transfer the bet amount payout to the player\r\n            if (isGasToken) {\r\n                Address.sendValue(payable(user), betAmountPayout);\r\n            } else {\r\n                IERC20(token).safeTransfer(user, betAmountPayout);\r\n                // Transfer the bet amount fee to the bank.\r\n                IERC20(token).safeTransfer(address(bank), betAmountFee);\r\n            }\r\n\r\n            // Transfer the payout from the bank, the bet amount fee to the bank, and account fees.\r\n            bank.payout{value: isGasToken ? betAmountFee : 0}(\r\n                user,\r\n                token,\r\n                profitPayout,\r\n                fee\r\n            );\r\n        } else if (payout > 0) {\r\n            // The user has won something smaller than his bet\r\n            address user = bet.user;\r\n\r\n            uint256 fee = _getFees(token, payout);\r\n            payout -= fee;\r\n            uint256 bankCashIn = betAmount - payout;\r\n\r\n            // Transfer the bet amount payout to the player\r\n            if (isGasToken) {\r\n                Address.sendValue(payable(user), payout);\r\n            } else {\r\n                IERC20(token).safeTransfer(user, payout);\r\n                // Transfer the lost bet amount and fee to the bank\r\n                IERC20(token).safeTransfer(address(bank), bankCashIn);\r\n            }\r\n\r\n            bank.cashIn{value: isGasToken ? bankCashIn : 0}(\r\n                token,\r\n                bankCashIn,\r\n                fee\r\n            );\r\n        } else {\r\n            // The user did not win anything\r\n            if (!isGasToken) {\r\n                IERC20(token).safeTransfer(address(bank), betAmount);\r\n            }\r\n            bank.cashIn{value: isGasToken ? betAmount : 0}(token, betAmount, 0);\r\n        }\r\n\r\n        bet.payout = payout;\r\n        return payout;\r\n    }\r\n\r\n    /// @notice Gets the list of the last user bets.\r\n    /// @param user Address of the gamer.\r\n    /// @param dataLength The amount of bets to return.\r\n    /// @return A list of Bet.\r\n    function _getLastUserBets(address user, uint256 dataLength)\r\n        internal\r\n        view\r\n        returns (Bet[] memory)\r\n    {\r\n        uint256[] memory userBetsIds = _userBets[user];\r\n        uint256 betsLength = userBetsIds.length;\r\n\r\n        if (betsLength < dataLength) {\r\n            dataLength = betsLength;\r\n        }\r\n\r\n        Bet[] memory userBets = new Bet[](dataLength);\r\n        if (dataLength != 0) {\r\n            uint256 userBetsIndex;\r\n            for (uint256 i = betsLength; i > betsLength - dataLength; i--) {\r\n                userBets[userBetsIndex] = bets[userBetsIds[i - 1]];\r\n                userBetsIndex++;\r\n            }\r\n        }\r\n\r\n        return userBets;\r\n    }\r\n\r\n    /// @notice Sets the game house edge rate for a specific token.\r\n    /// @param token Address of the token.\r\n    /// @param houseEdge House edge rate.\r\n    /// @dev The house edge rate couldn't exceed 4%.\r\n    function setHouseEdge(address token, uint16 houseEdge) external onlyOwner {\r\n        if (houseEdge > 400) {\r\n            revert ExcessiveHouseEdge();\r\n        }\r\n        if (hasPendingBets(token)) {\r\n            revert TokenHasPendingBets();\r\n        }\r\n        tokens[token].houseEdge = houseEdge;\r\n        emit SetHouseEdge(token, houseEdge);\r\n    }\r\n\r\n    /// @notice Pauses the contract to disable new bets.\r\n    function pause() external onlyOwner {\r\n        if (paused()) {\r\n            _unpause();\r\n        } else {\r\n            _pause();\r\n        }\r\n    }\r\n\r\n    /// @notice Sets the Chainlink VRF V2 configuration.\r\n    /// @param requestConfirmations How many confirmations the Chainlink node should wait before responding.\r\n    /// @param keyHash Hash of the public key used to verify the VRF proof.\r\n    /// @param gasAfterCalculation Gas to be added for VRF cost refund.\r\n    function setChainlinkConfig(\r\n        uint16 requestConfirmations,\r\n        bytes32 keyHash,\r\n        uint256 gasAfterCalculation\r\n    ) external onlyOwner {\r\n        _chainlinkConfig.requestConfirmations = requestConfirmations;\r\n        _chainlinkConfig.keyHash = keyHash;\r\n        _chainlinkConfig.gasAfterCalculation = gasAfterCalculation;\r\n        emit SetChainlinkConfig(\r\n            requestConfirmations,\r\n            keyHash,\r\n            gasAfterCalculation\r\n        );\r\n    }\r\n\r\n    /// @notice Sets the Chainlink VRF V2 configuration.\r\n    /// @param callbackGasLimit How much gas is needed in the Chainlink VRF callback.\r\n    function setVRFCallbackGasLimit(address token, uint32 callbackGasLimit)\r\n        external\r\n        onlyOwner\r\n    {\r\n        tokens[token].VRFCallbackGasLimit = callbackGasLimit;\r\n        emit SetVRFCallbackGasLimit(token, callbackGasLimit);\r\n    }\r\n\r\n    /// @notice Distributes the token's collected Chainlink fees.\r\n    /// @param token Address of the token.\r\n    function withdrawTokensVRFFees(address token) external {\r\n        uint256 tokenChainlinkFees = tokens[token].VRFFees;\r\n        if (tokenChainlinkFees != 0) {\r\n            delete tokens[token].VRFFees;\r\n            Address.sendValue(\r\n                payable(bank.getTokenOwner(token)),\r\n                tokenChainlinkFees\r\n            );\r\n            emit DistributeTokenVRFFees(token, tokenChainlinkFees);\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw user's overcharged Chainlink fees.\r\n    function withdrawOverchargedVRFCost(address user) external {\r\n        uint256 overchargedVRFCost = userOverchargedVRFCost[user];\r\n        if (overchargedVRFCost == 0) {\r\n            revert NoOverchargedVRFCost();\r\n        }\r\n\r\n        delete userOverchargedVRFCost[user];\r\n        Address.sendValue(payable(user), overchargedVRFCost);\r\n        emit DistributeOverchargedVRFCost(user, overchargedVRFCost);\r\n    }\r\n\r\n    /// @notice Refunds the bet to the user if the Chainlink VRF callback failed.\r\n    /// @param id The Bet ID.\r\n    function refundBet(uint256 id) external {\r\n        Bet storage bet = bets[id];\r\n        if (bet.resolved == true || bet.id == 0) {\r\n            revert NotPendingBet();\r\n        } else if (block.number < bet.blockNumber + 30) {\r\n            revert NotFulfilled();\r\n        }\r\n\r\n        Token storage token = tokens[bet.token];\r\n        token.pendingCount--;\r\n\r\n        bet.resolved = true;\r\n        bet.payout = bet.amount;\r\n\r\n        uint256 chainlinkVRFCost = bet.vrfCost;\r\n        if (bet.token == address(0)) {\r\n            Address.sendValue(payable(bet.user), bet.amount + chainlinkVRFCost);\r\n        } else {\r\n            IERC20(bet.token).safeTransfer(bet.user, bet.amount);\r\n            Address.sendValue(payable(bet.user), chainlinkVRFCost);\r\n        }\r\n\r\n        emit BetRefunded(id, bet.user, bet.amount, chainlinkVRFCost);\r\n    }\r\n\r\n    /// @notice Returns the Chainlink VRF config.\r\n    /// @param requestConfirmations How many confirmations the Chainlink node should wait before responding.\r\n    /// @param keyHash Hash of the public key used to verify the VRF proof.\r\n    /// @param chainlinkCoordinator Reference to the VRFCoordinatorV2 deployed contract.\r\n    /// @param gasAfterCalculation Gas to be added for VRF cost refund.\r\n    function getChainlinkConfig()\r\n        external\r\n        view\r\n        returns (\r\n            uint16 requestConfirmations,\r\n            bytes32 keyHash,\r\n            IVRFCoordinatorV2 chainlinkCoordinator,\r\n            uint256 gasAfterCalculation\r\n        )\r\n    {\r\n        return (\r\n            _chainlinkConfig.requestConfirmations,\r\n            _chainlinkConfig.keyHash,\r\n            _chainlinkConfig.chainlinkCoordinator,\r\n            _chainlinkConfig.gasAfterCalculation\r\n        );\r\n    }\r\n\r\n    /// @notice Returns whether the token has pending bets.\r\n    /// @return Whether the token has pending bets.\r\n    function hasPendingBets(address token) public view returns (bool) {\r\n        return tokens[token].pendingCount != 0;\r\n    }\r\n\r\n    /// @notice Returns the amount of ETH that should be passed to the wager transaction.\r\n    /// to cover Chainlink VRF fee.\r\n    /// @return The bet resolution cost amount.\r\n    function getChainlinkVRFCost(address token) public view returns (uint256) {\r\n        (, int256 weiPerUnitLink, , , ) = _LINK_ETH_feed.latestRoundData();\r\n        if (weiPerUnitLink <= 0) {\r\n            revert InvalidLinkWeiPrice(weiPerUnitLink);\r\n        }\r\n        // Get Chainlink VRF v2 fee amount.\r\n        (\r\n            uint32 fulfillmentFlatFeeLinkPPMTier1,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = _chainlinkConfig.chainlinkCoordinator.getFeeConfig();\r\n        // 115000 gas is the average Verification gas of Chainlink VRF.\r\n        return\r\n            (tx.gasprice * (115000 + tokens[token].VRFCallbackGasLimit)) +\r\n            ((1e12 *\r\n                uint256(fulfillmentFlatFeeLinkPPMTier1) *\r\n                uint256(weiPerUnitLink)) / 1e18);\r\n    }\r\n}\r\n\r\n/// @title SMBSwap's Coin Toss game\r\n/// @notice The game is played with a two-sided coin. The game's goal is to guess whether the lucky coin face will be Heads or Tails.\r\n/// @author Romuald Hog (based on Yakitori's Coin Toss)\r\ncontract CoinToss is Game {\r\n    /// @notice Full coin toss bet information struct.\r\n    /// @param bet The Bet struct information.\r\n    /// @param diceBet The Coin Toss bet struct information.\r\n    /// @dev Used to package bet information for the front-end.\r\n    struct FullCoinTossBet {\r\n        Bet bet;\r\n        CoinTossBet coinTossBet;\r\n    }\r\n\r\n    /// @notice Coin Toss bet information struct.\r\n    /// @param face The chosen coin face.\r\n    /// @param rolled The rolled coin face.\r\n    struct CoinTossBet {\r\n        bool face;\r\n        bool rolled;\r\n    }\r\n\r\n    /// @notice Maps bets IDs to chosen and rolled coin faces.\r\n    /// @dev Coin faces: true = Tails, false = Heads.\r\n    mapping(uint256 => CoinTossBet) public coinTossBets;\r\n\r\n    /// @notice Emitted after a bet is placed.\r\n    /// @param id The bet ID.\r\n    /// @param user Address of the gamer.\r\n    /// @param token Address of the token.\r\n    /// @param amount The bet amount.\r\n    /// @param vrfCost The Chainlink VRF cost paid by player.\r\n    /// @param face The chosen coin face.\r\n    event PlaceBet(\r\n        uint256 id,\r\n        address indexed user,\r\n        address indexed token,\r\n        uint256 amount,\r\n        uint256 vrfCost,\r\n        bool face\r\n    );\r\n\r\n    /// @notice Emitted after a bet is rolled.\r\n    /// @param id The bet ID.\r\n    /// @param user Address of the gamer.\r\n    /// @param token Address of the token.\r\n    /// @param amount The bet amount.\r\n    /// @param face The chosen coin face.\r\n    /// @param rolled The rolled coin face.\r\n    /// @param payout The payout amount.\r\n    event Roll(\r\n        uint256 id,\r\n        address indexed user,\r\n        address indexed token,\r\n        uint256 amount,\r\n        bool face,\r\n        bool rolled,\r\n        uint256 payout\r\n    );\r\n\r\n    /// @notice Initialize the game base contract.\r\n    /// @param bankAddress The address of the bank.\r\n    /// @param chainlinkCoordinatorAddress Address of the Chainlink VRF Coordinator.\r\n    /// @param LINK_ETH_feedAddress Address of the Chainlink LINK/ETH price feed.\r\n    constructor(\r\n        address bankAddress,\r\n        address chainlinkCoordinatorAddress,\r\n        address LINK_ETH_feedAddress\r\n    ) Game(bankAddress, chainlinkCoordinatorAddress, 1, LINK_ETH_feedAddress) {}\r\n\r\n    /// @notice Calculates the target payout amount.\r\n    /// @param betAmount Bet amount.\r\n    /// @return The target payout amount.\r\n    function _getPayout(uint256 betAmount) private pure returns (uint256) {\r\n        return betAmount * 2;\r\n    }\r\n\r\n    /// @notice Creates a new bet and stores the chosen coin face.\r\n    /// @param face The chosen coin face.\r\n    /// @param token Address of the token.\r\n    /// @param tokenAmount The number of tokens bet.\r\n    function wager(\r\n        bool face,\r\n        address token,\r\n        uint256 tokenAmount\r\n    ) external payable whenNotPaused {\r\n        Bet memory bet = _newBet(token, tokenAmount, _getPayout(10000));\r\n\r\n        coinTossBets[bet.id].face = face;\r\n\r\n        emit PlaceBet(\r\n            bet.id,\r\n            bet.user,\r\n            bet.token,\r\n            bet.amount,\r\n            bet.vrfCost,\r\n            face\r\n        );\r\n    }\r\n\r\n    /// @notice Resolves the bet using the Chainlink randomness.\r\n    /// @param id The bet ID.\r\n    /// @param randomWords Random words list. Contains only one for this game.\r\n    // solhint-disable-next-line private-vars-leading-underscore\r\n    function fulfillRandomWords(uint256 id, uint256[] memory randomWords)\r\n        internal\r\n        override\r\n    {\r\n        uint256 startGas = gasleft();\r\n\r\n        CoinTossBet storage coinTossBet = coinTossBets[id];\r\n        Bet storage bet = bets[id];\r\n\r\n        uint256 rolled = randomWords[0] % 2;\r\n\r\n        bool[2] memory coinSides = [false, true];\r\n        bool rolledCoinSide = coinSides[rolled];\r\n        coinTossBet.rolled = rolledCoinSide;\r\n        uint256 payout = _resolveBet(\r\n            bet,\r\n            rolledCoinSide == coinTossBet.face ?\r\n                _getPayout(bet.amount) : 0\r\n        );\r\n\r\n        emit Roll(\r\n            bet.id,\r\n            bet.user,\r\n            bet.token,\r\n            bet.amount,\r\n            coinTossBet.face,\r\n            rolledCoinSide,\r\n            payout\r\n        );\r\n\r\n        _accountVRFCost(bet, startGas);\r\n    }\r\n\r\n    /// @notice Gets the list of the last user bets.\r\n    /// @param user Address of the gamer.\r\n    /// @param dataLength The amount of bets to return.\r\n    /// @return A list of Coin Toss bet.\r\n    function getLastUserBets(address user, uint256 dataLength)\r\n        external\r\n        view\r\n        returns (FullCoinTossBet[] memory)\r\n    {\r\n        Bet[] memory lastBets = _getLastUserBets(user, dataLength);\r\n        FullCoinTossBet[] memory lastCoinTossBets = new FullCoinTossBet[](\r\n            lastBets.length\r\n        );\r\n        for (uint256 i; i < lastBets.length; i++) {\r\n            lastCoinTossBets[i] = FullCoinTossBet(\r\n                lastBets[i],\r\n                coinTossBets[lastBets[i].id]\r\n            );\r\n        }\r\n        return lastCoinTossBets;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bankAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chainlinkCoordinatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"LINK_ETH_feedAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExcessiveHouseEdge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForbiddenToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"linkWei\",\"type\":\"int256\"}],\"name\":\"InvalidLinkWeiPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOverchargedVRFCost\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFulfilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPendingBet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenHasPendingBets\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minBetAmount\",\"type\":\"uint256\"}],\"name\":\"UnderMinBetAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongGasValueToCoverFee\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"overchargedVRFCost\",\"type\":\"uint256\"}],\"name\":\"AccountOverchargedVRFCost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainlinkVRFCost\",\"type\":\"uint256\"}],\"name\":\"BetRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"overchargedVRFCost\",\"type\":\"uint256\"}],\"name\":\"DistributeOverchargedVRFCost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeTokenVRFFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vrfCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"face\",\"type\":\"bool\"}],\"name\":\"PlaceBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"face\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rolled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"Roll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasAfterCalculation\",\"type\":\"uint256\"}],\"name\":\"SetChainlinkConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"houseEdge\",\"type\":\"uint16\"}],\"name\":\"SetHouseEdge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"SetVRFCallbackGasLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"internalType\":\"contract IBank\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vrfCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coinTossBets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"face\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rolled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkConfig\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"contract IVRFCoordinatorV2\",\"name\":\"chainlinkCoordinator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasAfterCalculation\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getChainlinkVRFCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"}],\"name\":\"getLastUserBets\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vrfCost\",\"type\":\"uint256\"}],\"internalType\":\"struct Game.Bet\",\"name\":\"bet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"face\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rolled\",\"type\":\"bool\"}],\"internalType\":\"struct CoinToss.CoinTossBet\",\"name\":\"coinTossBet\",\"type\":\"tuple\"}],\"internalType\":\"struct CoinToss.FullCoinTossBet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"hasPendingBets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"gasAfterCalculation\",\"type\":\"uint256\"}],\"name\":\"setChainlinkConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"houseEdge\",\"type\":\"uint16\"}],\"name\":\"setHouseEdge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"setVRFCallbackGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"houseEdge\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"pendingCount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"VRFCallbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"VRFFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOverchargedVRFCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"face\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"wager\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawOverchargedVRFCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTokensVRFFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoinToss", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bae371ae538fbe56a36f0190f5a57e5aad9d4cf8000000000000000000000000c587d9053cd1118f25f645f9e08bb98c9712a4ee000000000000000000000000b38722f6a608646a538e882ee9972d15c86fc597", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bac613bbf992844217f8ec976c470793a7a3a7583c6f8184482dd1a35bf986d0"}