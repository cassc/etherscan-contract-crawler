{"SourceCode": "pragma solidity ^0.8.1;\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\ninterface ISwapPair {\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint256);\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n    function price0CumulativeLast() external view returns (uint256);\r\n    function price1CumulativeLast() external view returns (uint256);\r\n    function kLast() external view returns (uint256);\r\n    function mint(address to) external returns (uint256 liquidity);\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ncontract HBMStake is Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    struct UserInfo {\r\n        bool isExist;\r\n        bool isValid;\r\n        uint256 balance;\r\n        uint256 level;\r\n        uint256 userForce;\r\n        uint256 teamForce;\r\n        uint256 mining;\r\n        uint256 inviteReward;\r\n        uint256 teams;\r\n        uint256 invites;\r\n        uint256 v2;\r\n        uint256 v3;\r\n        uint256 v4;\r\n        uint256 v5;\r\n    }\r\n    struct OrderInfo {\r\n        bool isValid;\r\n        uint256 total;\r\n        uint256 surplus;\r\n        uint256 startTime;\r\n        uint256 startBlock;\r\n        uint256 endBlock;\r\n        uint256 lastBlock;\r\n        uint256 perBlock;\r\n        uint256 bp;\r\n        uint256 hbm;\r\n    }\r\n    mapping(address => mapping(uint256 => OrderInfo)) public userOrders;\r\n    mapping(address => uint256) public userOrderNum;\r\n    mapping(address => uint256) public userOrderValidNum;\r\n    mapping(address => UserInfo) public users;\r\n    mapping(uint256 => address) public userAdds;\r\n    mapping(address => address) public userRefers;\r\n    mapping(address => uint256) public userBP;\r\n    mapping(address => mapping(uint256 => address)) public userInvites;\r\n    mapping(address => uint256) public userInviteTotals;\r\n    uint256 public userTotal;\r\n    uint256 public totalForce;\r\n    uint256 public achievementV1;\r\n    uint256 public achievementV2;\r\n    uint256 public validBP = 1000 * 1e18;\r\n    address private _dead = 0x000000000000000000000000000000000000dEaD;\r\n    address private _swapPair;\r\n    ISwapRouter private _swapRouter;\r\n    IERC20 private _USDT;\r\n    IERC20 private _HBM;\r\n    IERC20 private _BP;\r\n    function withdrawToken(\r\n        IERC20 token,\r\n        address account,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        token.transfer(account, amount);\r\n    }\r\n    function setAchievement(\r\n        uint256 v1,\r\n        uint256 v2,\r\n        uint256 valid\r\n    ) public onlyOwner {\r\n        achievementV1 = v1;\r\n        achievementV2 = v2;\r\n        validBP = valid;\r\n    }\r\n    constructor() {\r\n        _HBM = IERC20(0x80C660B935F35d223480aE85E44aEc8eD2CC2F83);\r\n        _BP = IERC20(0x36c11ca004cf31F5c5E9184a182a44D85786cbec);\r\n        _USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        _swapRouter = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        _swapPair = 0x5F81aEe8A1C9d48ff28D38f303011b6465f1DD50;\r\n        achievementV1 = 1_0000 * 1e18;\r\n        achievementV2 = 15_0000 * 1e18;\r\n    }\r\n    event DepositHP(address account, uint256 hp, uint256 usdt, address refer);\r\n    event DepositBP(address account, uint256 bp, uint256 usdt, address refer);\r\n    event Withdraw(address account, uint256 amount);\r\n    function setToken(\r\n        address usdt,\r\n        address hbm,\r\n        address bp,\r\n        address pair\r\n    ) public onlyOwner {\r\n        _USDT = IERC20(usdt);\r\n        _HBM = IERC20(hbm);\r\n        _BP = IERC20(bp);\r\n        _swapPair = pair;\r\n    }\r\n    function getPriceHBM() public view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(_HBM);\r\n        path[1] = address(_USDT);\r\n        return _swapRouter.getAmountsOut(1 * 10**18, path)[1];\r\n    }\r\n    function getOrders(address account)\r\n        public\r\n        view\r\n        returns (OrderInfo[] memory ordes)\r\n    {\r\n        ordes = new OrderInfo[](userOrderNum[account]);\r\n        for (uint256 i = userOrderNum[account]; i > 0; i--) {\r\n            ordes[userOrderNum[account] - i] = userOrders[account][i - 1];\r\n        }\r\n    }\r\n    function getInvites(address account)\r\n        public\r\n        view\r\n        returns (address[] memory invites)\r\n    {\r\n        invites = new address[](userInviteTotals[account]);\r\n        for (uint256 i = 0; i < userInviteTotals[account]; i++) {\r\n            invites[i] = userInvites[account][i + 1];\r\n        }\r\n    }\r\n    function getInvitesInfo(address account)\r\n        public\r\n        view\r\n        returns (address[] memory invites, UserInfo[] memory infos)\r\n    {\r\n        invites = new address[](userInviteTotals[account]);\r\n        infos = new UserInfo[](userInviteTotals[account]);\r\n        for (uint256 i = 0; i < userInviteTotals[account]; i++) {\r\n            invites[i] = userInvites[account][i + 1];\r\n            infos[i] = users[invites[i]];\r\n        }\r\n    }\r\n    function depositBP(\r\n        uint256 bp,\r\n        uint256 usdt,\r\n        address refer\r\n    ) public {\r\n        address account = msg.sender;\r\n        require(bp % (20 * 1e18) == 0, \"Multiple Error BP\");\r\n        require(usdt % (3 * 1e18) == 0, \"Multiple Error HBM\");\r\n        require(usdt == (bp / (20 * 1e18)) * 3 * 1e18, \"HBM Match BP\");\r\n        require(_BP.balanceOf(account) >= bp, \"Insufficient BP\");\r\n        uint256 priceHBM = getPriceHBM();\r\n        uint256 hbm = (usdt * 1e18) / priceHBM;\r\n        require(_HBM.balanceOf(account) >= hbm, \"Insufficient HBM\");\r\n        _BP.transferFrom(msg.sender, _dead, bp);\r\n        _HBM.transferFrom(msg.sender, _dead, hbm);\r\n        _handleUserAndRefer(msg.sender, refer);\r\n        userOrders[account][userOrderNum[account]] = OrderInfo({\r\n            isValid: true,\r\n            total: hbm * 3,\r\n            surplus: hbm * 3,\r\n            startTime: block.timestamp,\r\n            startBlock: block.number,\r\n            endBlock: block.number + 180 * 28800,\r\n            lastBlock: block.number,\r\n            perBlock: (hbm * 3) / (180 * 28800),\r\n            bp: bp,\r\n            hbm: hbm\r\n        });\r\n        userOrderNum[account]++;\r\n        users[msg.sender].userForce += hbm * 3;\r\n        userBP[msg.sender] += bp;\r\n        if (\r\n            !users[msg.sender].isValid &&\r\n            userRefers[msg.sender] != address(0) &&\r\n            userBP[msg.sender] >= validBP\r\n        ) {\r\n            users[msg.sender].isValid = true;\r\n            users[userRefers[msg.sender]].invites += 1;\r\n        }\r\n        _handleTeam(account, hbm * 3, true);\r\n        totalForce += hbm * 3;\r\n        emit DepositBP(msg.sender, bp, usdt, refer);\r\n    }\r\n    function withdraw() public {\r\n        address account = msg.sender;\r\n        UserInfo storage user = users[account];\r\n        uint256 total;\r\n        for (\r\n            uint256 i = userOrderValidNum[account];\r\n            i < userOrderNum[account];\r\n            i++\r\n        ) {\r\n            OrderInfo storage order = userOrders[account][i];\r\n            if (block.number < order.endBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (block.number - order.lastBlock);\r\n                total += reward;\r\n                order.lastBlock = block.number;\r\n                if (order.surplus > reward) order.surplus -= reward;\r\n                else order.surplus = 0;\r\n            } else if (order.endBlock > order.lastBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - order.lastBlock);\r\n                total += reward;\r\n                order.lastBlock = order.endBlock;\r\n                order.isValid = false;\r\n                order.surplus = 0;\r\n                userOrderValidNum[account]++;\r\n            }\r\n        }\r\n        if (total > 0) {\r\n            user.balance += total;\r\n            user.mining += total;\r\n        }\r\n        if (user.balance > 0) {\r\n            _handleInviteReward(account, user.balance);\r\n            _handleTeam(account, user.balance, false);\r\n            _HBM.transfer(account, user.balance);\r\n            emit Withdraw(account, user.balance);\r\n            if (user.userForce > user.balance) {\r\n                user.userForce -= user.balance;\r\n            } else {\r\n                user.userForce = 0;\r\n            }\r\n            if (totalForce > user.balance) {\r\n                totalForce -= user.balance;\r\n            } else {\r\n                totalForce = 0;\r\n            }\r\n            user.balance = 0;\r\n        }\r\n    }\r\n    function getPending(address account) public view returns (uint256 total) {\r\n        for (\r\n            uint256 i = userOrderValidNum[account];\r\n            i < userOrderNum[account];\r\n            i++\r\n        ) {\r\n            OrderInfo memory order = userOrders[account][i];\r\n            if (block.number < order.endBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (block.number - order.lastBlock);\r\n                total += reward;\r\n            } else if (order.endBlock > order.lastBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - order.lastBlock);\r\n                total += reward;\r\n            }\r\n        }\r\n        total += users[account].balance;\r\n    }\r\n    function _handleUserAndRefer(address account, address refer) private {\r\n        if (refer != address(0) && !users[refer].isExist) {\r\n            UserInfo storage parent = users[refer];\r\n            parent.isExist = true;\r\n            userTotal = userTotal.add(1);\r\n            userAdds[userTotal] = refer;\r\n        }\r\n        UserInfo storage user = users[account];\r\n        if (!user.isExist) {\r\n            user.isExist = true;\r\n            userTotal = userTotal.add(1);\r\n            userAdds[userTotal] = account;\r\n        }\r\n        if (refer != address(0) && userRefers[account] == address(0)) {\r\n            userRefers[account] = refer;\r\n            userInviteTotals[refer] = userInviteTotals[refer].add(1);\r\n            userInvites[refer][userInviteTotals[refer]] = account;\r\n        }\r\n    }\r\n    function _handleTeam(\r\n        address account,\r\n        uint256 amount,\r\n        bool isAdd\r\n    ) private {\r\n        uint256 index;\r\n        uint256 v1;\r\n        uint256 v2;\r\n        uint256 v3;\r\n        uint256 v4;\r\n        uint256 v5;\r\n        address refer = userRefers[account];\r\n        address[] memory refers = new address[](11);\r\n        refers[index] = refer;\r\n        while (refer != address(0) && index < 10) {\r\n            UserInfo storage user = users[refer];\r\n            if (isAdd) {\r\n                user.teams += amount;\r\n                if (v5 > 0) {\r\n                    user.v5 += v5;\r\n                    if (user.level < 6 && user.v5 >= 2 && user.invites >= 12)\r\n                        user.level = 6;\r\n                }\r\n                if (v4 > 0) {\r\n                    user.v4 += v4;\r\n                    if (user.level < 5 && user.v4 >= 2 && user.invites >= 9) {\r\n                        user.level = 5;\r\n                        v5++;\r\n                    }\r\n                }\r\n                if (v3 > 0) {\r\n                    user.v3 += v3;\r\n                    if (user.level < 4 && user.v3 >= 2 && user.invites >= 7) {\r\n                        user.level = 4;\r\n                        v4++;\r\n                    }\r\n                }\r\n                if (v2 > 0) {\r\n                    user.v2 += v2;\r\n                    if (user.level < 3 && user.v2 >= 2 && user.invites >= 5) {\r\n                        user.level = 3;\r\n                        v3++;\r\n                    }\r\n                }\r\n                if (\r\n                    user.level < 2 &&\r\n                    user.teams >= achievementV2 &&\r\n                    user.invites >= 3\r\n                ) {\r\n                    user.level = 2;\r\n                    v2++;\r\n                }\r\n                if (\r\n                    user.level == 0 &&\r\n                    user.teams >= achievementV1 &&\r\n                    user.invites >= 1\r\n                ) {\r\n                    user.level = 1;\r\n                    v1++;\r\n                }\r\n                user.teamForce += amount;\r\n            } else {\r\n                if (user.teamForce > amount) {\r\n                    user.teamForce -= amount;\r\n                } else {\r\n                    user.teamForce = 0;\r\n                }\r\n            }\r\n            index++;\r\n            bool isExist;\r\n            for (uint256 i = 0; i < refers.length; i++) {\r\n                if (userRefers[refer] == refers[i]) {\r\n                    isExist = true;\r\n                    break;\r\n                }\r\n            }\r\n            refer = userRefers[refer];\r\n            if (isExist) {\r\n                break;\r\n            }\r\n            refers[index] = refer;\r\n        }\r\n    }\r\n    function _handleInviteReward(address account, uint256 amount) private {\r\n        address refer = userRefers[account];\r\n        uint256 index;\r\n        uint256 level;\r\n        uint256 times;\r\n        uint8[6] memory rates = [5, 10, 15, 20, 25, 30];\r\n        while (refer != address(0) && index < 10) {\r\n            UserInfo memory parent = users[refer];\r\n            if (level > 0 && parent.level > level) {\r\n                _updateOrder(\r\n                    refer,\r\n                    (amount * (rates[parent.level - 1] - rates[level - 1])) /\r\n                        100\r\n                );\r\n                level = parent.level;\r\n            } else if (level == 0 && parent.level > level) {\r\n                _updateOrder(refer, (amount * rates[parent.level - 1]) / 100);\r\n                level = parent.level;\r\n            } else if (level == 6 && parent.level == 6 && times < 1) {\r\n                _updateOrder(refer, (amount * 3) / 100);\r\n                times++;\r\n            }\r\n            refer = userRefers[refer];\r\n            index++;\r\n        }\r\n    }\r\n    function _updateOrder(address account, uint256 amount) private {\r\n        UserInfo storage user = users[account];\r\n        uint256 total = amount;\r\n        uint256 rewardTotal;\r\n        uint256 rewardMining;\r\n        for (\r\n            uint256 i = userOrderValidNum[account];\r\n            i < userOrderNum[account];\r\n            i++\r\n        ) {\r\n            OrderInfo storage order = userOrders[account][i];\r\n            if (block.number < order.endBlock) {\r\n                uint256 pending = order.perBlock *\r\n                    (block.number - order.lastBlock);\r\n                rewardMining += pending;\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - block.number);\r\n                bool isEnd;\r\n                if (reward > total) {\r\n                    reward = order.perBlock * (total / order.perBlock);\r\n                    total = 0;\r\n                } else {\r\n                    isEnd = true;\r\n                    total -= reward;\r\n                }\r\n                rewardTotal += (reward + pending);\r\n                order.endBlock = order.endBlock - reward / order.perBlock;\r\n                order.lastBlock = block.number;\r\n                if (order.surplus > (reward + pending) && !isEnd) {\r\n                    order.surplus -= (reward + pending);\r\n                } else {\r\n                    order.surplus = 0;\r\n                    order.isValid = false;\r\n                    userOrderValidNum[account]++;\r\n                }\r\n            } else if (order.endBlock > order.lastBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - order.lastBlock);\r\n                rewardTotal += reward;\r\n                rewardMining += reward;\r\n                order.lastBlock = order.endBlock;\r\n                order.isValid = false;\r\n                order.surplus = 0;\r\n                userOrderValidNum[account]++;\r\n            }\r\n            if (total == 0) {\r\n                break;\r\n            }\r\n        }\r\n        if (rewardTotal > 0) {\r\n            user.balance += rewardTotal;\r\n            user.mining += rewardMining;\r\n            user.inviteReward += rewardTotal - rewardMining;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"DepositBP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"DepositHP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"achievementV1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"achievementV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"depositBP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInvites\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"invites\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInvitesInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"invites\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teams\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invites\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v5\",\"type\":\"uint256\"}],\"internalType\":\"struct HBMStake.UserInfo[]\",\"name\":\"infos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hbm\",\"type\":\"uint256\"}],\"internalType\":\"struct HBMStake.OrderInfo[]\",\"name\":\"ordes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceHBM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valid\",\"type\":\"uint256\"}],\"name\":\"setAchievement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hbm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalForce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAdds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInviteTotals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvites\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOrderNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOrderValidNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hbm\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRefers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teams\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invites\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v5\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validBP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HBMStake", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://212ff7ffb5cca0dbd5dcc467a8730ab4ed42321bdc71b0365d2ce962113a04a6"}