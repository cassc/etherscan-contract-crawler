{"SourceCode": "// File: interfaces/IOpenPeerDeployer.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IOpenPeerDeployer {\r\n  function partnerFeeBps(address _partner) external view returns (uint256);\r\n}\r\n// File: libs/ERC2771Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Context variant with ERC2771 support.\r\n */\r\nabstract contract ERC2771Context is Context {\r\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\r\n    address internal _trustedForwarder;\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor(address trustedForwarder) {\r\n        _trustedForwarder = trustedForwarder;\r\n    }\r\n\r\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\r\n        return forwarder == _trustedForwarder;\r\n    }\r\n\r\n    function _msgSender() internal view virtual override returns (address sender) {\r\n        if (isTrustedForwarder(msg.sender)) {\r\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\r\n            assembly {\r\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\r\n            }\r\n        } else {\r\n            return super._msgSender();\r\n        }\r\n    }\r\n\r\n    function _msgData() internal view virtual override returns (bytes calldata) {\r\n        if (isTrustedForwarder(msg.sender)) {\r\n            return msg.data[:msg.data.length - 20];\r\n        } else {\r\n            return super._msgData();\r\n        }\r\n    }\r\n}\r\n// File: libs/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is ERC2771Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n// File: @openzeppelin/contracts@4.9.3/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.9.3/token/ERC20/extensions/IERC20Permit.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable@4.9.3/utils/AddressUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable@4.9.3/proxy/utils/Initializable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.9.3/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.9.3/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.9.3/interfaces/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// File: @openzeppelin/contracts@4.9.3/proxy/Clones.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create2(0, 0x09, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(add(ptr, 0x38), deployer)\r\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\r\n            mstore(add(ptr, 0x14), implementation)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\r\n            mstore(add(ptr, 0x58), salt)\r\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\r\n            predicted := keccak256(add(ptr, 0x43), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt\r\n    ) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\n// File: OpenPeerEscrow.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OpenPeerEscrow is ERC2771Context, Initializable {\r\n    using SafeERC20 for IERC20;\r\n    mapping(bytes32 => Escrow) public escrows;\r\n\r\n    address payable public seller;\r\n    address public deployer;\r\n    address public arbitrator;\r\n    address payable public feeRecipient;\r\n    address public feeDiscountNFT;\r\n    uint256 public feeBps;\r\n    uint256 public disputeFee;\r\n    mapping(bytes32 => mapping(address => bool)) public disputePayments;\r\n    mapping(address => uint256) public balancesInUse;\r\n\r\n    /**********************\r\n    +   Events            +\r\n    ***********************/\r\n    event EscrowCreated(bytes32 indexed _orderHash);\r\n    event Released(bytes32 indexed _orderHash);\r\n    event CancelledByBuyer(bytes32 indexed _orderHash);\r\n    event SellerCancelDisabled(bytes32 indexed _orderHash);\r\n    event CancelledBySeller(bytes32 indexed _orderHash);\r\n    event DisputeOpened(bytes32 indexed _orderHash, address indexed _sender);\r\n    event DisputeResolved(bytes32 indexed _orderHash, address indexed _winner);\r\n\r\n    struct Escrow {\r\n        // So we know the escrow exists\r\n        bool exists;\r\n        // This is the timestamp in which the seller can cancel the escrow after.\r\n        // It has a special value:\r\n        // 1 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)\r\n        uint32 sellerCanCancelAfter;\r\n        uint256 fee;\r\n        bool dispute;\r\n        address payable partner;\r\n        uint256 openPeerFee;\r\n        bool automaticEscrow;\r\n    }\r\n\r\n    /// @param _trustedForwarder Forwarder address\r\n    constructor(address _trustedForwarder) ERC2771Context(_trustedForwarder) {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /// @param _seller Seller address\r\n    /// @param _feeBps OP fee (bps) ex: 30 == 0.3%\r\n    /// @param _arbitrator Address of the arbitrator (currently OP staff)\r\n    /// @param _feeRecipient Address to receive the fees\r\n    /// @param trustedForwarder Forwarder address\r\n    /// @param _feeDiscountNFT NFT contract for fee discounts\r\n    /// @param _disputeFee Fee to open a dispute\r\n    function initialize(\r\n        address payable _seller,\r\n        uint256 _feeBps,\r\n        address _arbitrator,\r\n        address payable _feeRecipient,\r\n        address trustedForwarder,\r\n        address _feeDiscountNFT,\r\n        uint256 _disputeFee\r\n    ) external virtual initializer {\r\n        require(_seller != address(0), \"Invalid seller\");\r\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\r\n        require(_arbitrator != address(0), \"Invalid arbitrator\");\r\n        require(trustedForwarder != address(0), \"Invalid trust forwarder\");\r\n\r\n        seller = _seller;\r\n        feeBps = _feeBps;\r\n        arbitrator = _arbitrator;\r\n        feeRecipient = _feeRecipient;\r\n        _trustedForwarder = trustedForwarder;\r\n        feeDiscountNFT = _feeDiscountNFT;\r\n        disputeFee = _disputeFee;\r\n        deployer = _msgSender();\r\n    }\r\n\r\n    // Modifiers\r\n    modifier onlySeller() {\r\n        require(_msgSender() == seller, \"Must be seller\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbitrator() {\r\n        require(_msgSender() == arbitrator, \"Must be arbitrator\");\r\n        _;\r\n    }\r\n\r\n    // Errors\r\n    error EscrowNotFound();\r\n\r\n    function createNativeEscrow(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        uint256 _amount,\r\n        address payable _partner,\r\n        uint32 _sellerWaitingTime,\r\n        bool _automaticEscrow\r\n    ) external payable {\r\n        create(\r\n            _orderID,\r\n            _buyer,\r\n            address(0),\r\n            _amount,\r\n            _partner,\r\n            _sellerWaitingTime,\r\n            _automaticEscrow\r\n        );\r\n    }\r\n\r\n    function createERC20Escrow(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount,\r\n        address payable _partner,\r\n        uint32 _sellerWaitingTime,\r\n        bool _automaticEscrow\r\n    ) external {\r\n        create(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount,\r\n            _partner,\r\n            _sellerWaitingTime,\r\n            _automaticEscrow\r\n        );\r\n    }\r\n\r\n    function create(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount,\r\n        address payable _partner,\r\n        uint32 _sellerWaitingTime,\r\n        bool _automaticEscrow\r\n    ) private {\r\n        require(_amount > 0, \"Invalid amount\");\r\n        require(_buyer != address(0), \"Invalid buyer\");\r\n        require(_buyer != seller, \"Seller and buyer must be different\");\r\n        require(\r\n            _sellerWaitingTime >= 15 minutes && _sellerWaitingTime <= 1 days,\r\n            \"Invalid seller waiting time\"\r\n        );\r\n        if (_automaticEscrow) {\r\n            require(msg.value == 0, \"Cannot send tokens with automatic escrow\");\r\n        }\r\n\r\n        bytes32 _orderHash = keccak256(\r\n            abi.encodePacked(_orderID, seller, _buyer, _token, _amount)\r\n        );\r\n        require(!escrows[_orderHash].exists, \"Order already exists\");\r\n\r\n        uint256 opFee = ((_amount * openPeerFee()) / 10_000);\r\n        uint256 orderFee = ((_amount * sellerFee(_partner)) / 10_000);\r\n        uint256 amount = orderFee + _amount;\r\n\r\n        validateAndPullTokens(_token, amount, _automaticEscrow);\r\n\r\n        Escrow memory escrow = Escrow(\r\n            true,\r\n            uint32(block.timestamp) + _sellerWaitingTime,\r\n            orderFee,\r\n            false,\r\n            _partner,\r\n            opFee,\r\n            _automaticEscrow\r\n        );\r\n        escrows[_orderHash] = escrow;\r\n        emit EscrowCreated(_orderHash);\r\n    }\r\n\r\n    function validateAndPullTokens(\r\n        address _token,\r\n        uint256 _amount,\r\n        bool _automaticEscrow\r\n    ) internal {\r\n        if (_automaticEscrow) {\r\n            require(balances(_token) >= _amount, \"Not enough tokens in escrow\");\r\n            balancesInUse[_token] += _amount;\r\n        } else {\r\n            if (_token == address(0)) {\r\n                require(msg.value == _amount, \"Incorrect amount sent\");\r\n            } else {\r\n                uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\r\n                IERC20(_token).safeTransferFrom(\r\n                    _msgSender(),\r\n                    address(this),\r\n                    _amount\r\n                );\r\n                uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\r\n                require(\r\n                    (balanceAfter - balanceBefore) == _amount,\r\n                    \"Wrong ERC20 amount\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Disable the seller from cancelling\r\n    /// @return bool\r\n    function markAsPaid(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external returns (bool) {\r\n        require(_msgSender() == _buyer, \"Must be buyer\");\r\n\r\n        Escrow memory _escrow;\r\n        bytes32 _orderHash;\r\n        (_escrow, _orderHash) = getEscrowAndHash(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount\r\n        );\r\n        if (!_escrow.exists) {\r\n            revert EscrowNotFound();\r\n        }\r\n        if (_escrow.sellerCanCancelAfter == 1) return false;\r\n\r\n        escrows[_orderHash].sellerCanCancelAfter = 1;\r\n        emit SellerCancelDisabled(_orderHash);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Release ether or token in escrow to the buyer.\r\n    /// @return bool\r\n    function release(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external onlySeller returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _orderHash;\r\n        (_escrow, _orderHash) = getEscrowAndHash(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount\r\n        );\r\n        if (!_escrow.exists) {\r\n            revert EscrowNotFound();\r\n        }\r\n\r\n        transferEscrowAndFees(\r\n            _orderHash,\r\n            _buyer,\r\n            _token,\r\n            _buyer,\r\n            _amount,\r\n            _escrow.fee,\r\n            _escrow.partner,\r\n            _escrow.openPeerFee,\r\n            false,\r\n            _escrow.automaticEscrow\r\n        );\r\n        emit Released(_orderHash);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a buyer with 0 fees\r\n    /// @return bool\r\n    function buyerCancel(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external returns (bool) {\r\n        require(_msgSender() == _buyer, \"Must be buyer\");\r\n\r\n        Escrow memory _escrow;\r\n        bytes32 _orderHash;\r\n        (_escrow, _orderHash) = getEscrowAndHash(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount\r\n        );\r\n        if (!_escrow.exists) {\r\n            revert EscrowNotFound();\r\n        }\r\n\r\n        transferEscrowAndFees(\r\n            _orderHash,\r\n            _buyer,\r\n            _token,\r\n            seller,\r\n            _amount + _escrow.fee,\r\n            0,\r\n            _escrow.partner,\r\n            0,\r\n            false,\r\n            _escrow.automaticEscrow\r\n        );\r\n        emit CancelledByBuyer(_orderHash);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a seller\r\n    /// @return bool\r\n    function sellerCancel(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external onlySeller returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _orderHash;\r\n        (_escrow, _orderHash) = getEscrowAndHash(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount\r\n        );\r\n        if (!_escrow.exists) {\r\n            revert EscrowNotFound();\r\n        }\r\n\r\n        if (\r\n            _escrow.sellerCanCancelAfter <= 1 ||\r\n            _escrow.sellerCanCancelAfter > block.timestamp\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        transferEscrowAndFees(\r\n            _orderHash,\r\n            _buyer,\r\n            _token,\r\n            seller,\r\n            _amount + _escrow.fee,\r\n            0,\r\n            _escrow.partner,\r\n            0,\r\n            false,\r\n            _escrow.automaticEscrow\r\n        );\r\n        emit CancelledBySeller(_orderHash);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allow seller or buyer to open a dispute\r\n    function openDispute(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external payable returns (bool) {\r\n        require(\r\n            _msgSender() == seller || _msgSender() == _buyer,\r\n            \"Must be seller or buyer\"\r\n        );\r\n        Escrow memory _escrow;\r\n        bytes32 _orderHash;\r\n        (_escrow, _orderHash) = getEscrowAndHash(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount\r\n        );\r\n        if (!_escrow.exists) {\r\n            revert EscrowNotFound();\r\n        }\r\n\r\n        require(_escrow.sellerCanCancelAfter == 1, \"Cannot open a dispute yet\");\r\n        require(\r\n            msg.value == disputeFee,\r\n            \"To open a dispute, you must pay 1 MATIC\"\r\n        );\r\n        require(\r\n            !disputePayments[_orderHash][_msgSender()],\r\n            \"This address already paid for the dispute\"\r\n        );\r\n\r\n        escrows[_orderHash].dispute = true;\r\n        disputePayments[_orderHash][_msgSender()] = true;\r\n        emit DisputeOpened(_orderHash, _msgSender());\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allow arbitrator to resolve a dispute\r\n    /// @param _winner Address to receive the escrowed values - fees\r\n    function resolveDispute(\r\n        bytes32 _orderID,\r\n        address payable _buyer,\r\n        address _token,\r\n        uint256 _amount,\r\n        address payable _winner\r\n    ) external onlyArbitrator returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _orderHash;\r\n        (_escrow, _orderHash) = getEscrowAndHash(\r\n            _orderID,\r\n            _buyer,\r\n            _token,\r\n            _amount\r\n        );\r\n        if (!_escrow.exists) {\r\n            revert EscrowNotFound();\r\n        }\r\n\r\n        require(_escrow.dispute, \"Dispute is not open\");\r\n        require(\r\n            _winner == seller || _winner == _buyer,\r\n            \"Winner must be seller or buyer\"\r\n        );\r\n\r\n        emit DisputeResolved(_orderHash, _winner);\r\n\r\n        uint256 _fee = _winner == _buyer ? _escrow.fee : 0; // no fees if the trade is not done\r\n        uint256 _openPeerFee = _winner == _buyer ? _escrow.openPeerFee : 0;\r\n\r\n        transferEscrowAndFees(\r\n            _orderHash,\r\n            _buyer,\r\n            _token,\r\n            _winner,\r\n            _winner == _buyer ? _amount : _amount + _escrow.fee,\r\n            _fee,\r\n            _escrow.partner,\r\n            _openPeerFee,\r\n            true,\r\n            _escrow.automaticEscrow\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfer the value of an escrow\r\n    /// @param _to Recipient address\r\n    /// @param _amount Amount to be transfered\r\n    /// @param _fee Fee to be transfered\r\n    /// @param _disputeResolution Is a dispute being resolved?\r\n    /// @param _automaticEscrow The escrow was done automatically\r\n    function transferEscrowAndFees(\r\n        bytes32 _orderHash,\r\n        address payable _buyer,\r\n        address _token,\r\n        address payable _to,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        address payable _partner,\r\n        uint256 _openPeerFee,\r\n        bool _disputeResolution,\r\n        bool _automaticEscrow\r\n    ) private {\r\n        delete escrows[_orderHash];\r\n        bool sellerPaid = disputePayments[_orderHash][seller];\r\n        bool buyerPaid = disputePayments[_orderHash][_buyer];\r\n        delete disputePayments[_orderHash][seller];\r\n        delete disputePayments[_orderHash][_buyer];\r\n\r\n        // transfers the amount to the seller | buyer | this contract\r\n        withdraw(_token, _to, _amount, _automaticEscrow);\r\n        if (_openPeerFee > 0) {\r\n            // transfers the OP fee to the fee recipient\r\n            withdraw(_token, feeRecipient, _openPeerFee, false);\r\n        }\r\n\r\n        if (_fee - _openPeerFee > 0) {\r\n            // transfers the OP fee to the fee recipient\r\n            withdraw(_token, _partner, _fee - _openPeerFee, false);\r\n        }\r\n\r\n        if (_disputeResolution) {\r\n            (bool sentToWinner, ) = _to.call{value: disputeFee}(\"\");\r\n            require(sentToWinner, \"Failed to send the fee MATIC to the winner\");\r\n\r\n            if (sellerPaid && buyerPaid) {\r\n                (bool sent, ) = feeRecipient.call{value: disputeFee}(\"\");\r\n                require(\r\n                    sent,\r\n                    \"Failed to send the fee MATIC to the fee recipient\"\r\n                );\r\n            }\r\n        } else if (sellerPaid && !buyerPaid) {\r\n            // only the seller paid for the dispute, returns the fee to the seller\r\n            (bool sent, ) = seller.call{value: disputeFee}(\"\");\r\n            require(sent, \"Failed to send the fee MATIC to the seller\");\r\n        } else if (buyerPaid && !sellerPaid) {\r\n            // only the buyer paid for the dispute, returns the fee to the buyer\r\n            (bool sent, ) = _buyer.call{value: disputeFee}(\"\");\r\n            require(sent, \"Failed to send the fee MATIC to the buyer\");\r\n        } else if (buyerPaid && sellerPaid) {\r\n            // seller and buyer paid for the dispute, split the fee between the winner and the fee recipient\r\n            (bool sentToWinner, ) = _to.call{value: disputeFee}(\"\");\r\n            require(sentToWinner, \"Failed to send the fee MATIC to winner\");\r\n\r\n            (bool sent, ) = feeRecipient.call{value: disputeFee}(\"\");\r\n            require(sent, \"Failed to send the fee MATIC to the fee recipient\");\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw values in the contract\r\n    /// @param _token Address of the token to withdraw fees in to\r\n    /// @param _to Address to withdraw fees in to\r\n    /// @param _amount Amount to withdraw\r\n    /// @param _updateBalancesOnly Update internal balances\r\n    function withdraw(\r\n        address _token,\r\n        address payable _to,\r\n        uint256 _amount,\r\n        bool _updateBalancesOnly\r\n    ) private {\r\n        if (_updateBalancesOnly && _to == seller) {\r\n            balancesInUse[_token] -= _amount;\r\n        } else {\r\n            if (_token == address(0)) {\r\n                (bool sent, ) = _to.call{value: _amount}(\"\");\r\n                require(sent, \"Failed to send tokens\");\r\n            } else {\r\n                require(\r\n                    IERC20(_token).transfer(_to, _amount),\r\n                    \"Failed to send tokens\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Version recipient\r\n    function versionRecipient() external pure returns (string memory) {\r\n        return \"1.0\";\r\n    }\r\n\r\n    /// @notice Hashes the values and returns the matching escrow object and trade hash.\r\n    /// @dev Returns an empty escrow struct and 0 _orderHash if not found.\r\n    /// @param _orderID Escrow \"_orderID\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _token Escrow \"token\" parameter\r\n    /// @param _amount Escrow \"amount\" parameter\r\n    /// @return Escrow\r\n    function getEscrowAndHash(\r\n        bytes32 _orderID,\r\n        address _buyer,\r\n        address _token,\r\n        uint256 _amount\r\n    ) private view returns (Escrow memory, bytes32) {\r\n        bytes32 _orderHash = keccak256(\r\n            abi.encodePacked(_orderID, seller, _buyer, _token, _amount)\r\n        );\r\n        return (escrows[_orderHash], _orderHash);\r\n    }\r\n\r\n    /***********************\r\n    +   Getters           +\r\n    ***********************/\r\n\r\n    function openPeerFee() public view returns (uint256) {\r\n        IERC721 discountNFT = IERC721(feeDiscountNFT);\r\n\r\n        if (\r\n            feeDiscountNFT != address(0) &&\r\n            discountNFT.balanceOf(_msgSender()) > 0\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        return feeBps;\r\n    }\r\n\r\n    function sellerFee(address _partner) public view returns (uint256) {\r\n        return\r\n            openPeerFee() + IOpenPeerDeployer(deployer).partnerFeeBps(_partner);\r\n    }\r\n\r\n    /***********************************\r\n    +   Deposit and withdraw           +\r\n    ***********************************/\r\n\r\n    // accept ETH deposits\r\n    receive() external payable {}\r\n\r\n    function withdrawBalance(address _token, uint256 _amount) external {\r\n        require(balances(_token) >= _amount, \"Not enough tokens in escrow\");\r\n\r\n        withdraw(_token, seller, _amount, false);\r\n    }\r\n\r\n    function balances(address _token) public view returns (uint256) {\r\n        uint256 balance;\r\n        if (_token == address(0)) {\r\n            balance = address(this).balance;\r\n        } else {\r\n            balance = IERC20(_token).balanceOf(address(this));\r\n        }\r\n\r\n        return balance - balancesInUse[_token];\r\n    }\r\n}\r\n\r\n// File: OpenPeerEscrowsDeployer.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OpenPeerEscrowsDeployer is ERC2771Context, Ownable {\r\n    mapping(address => address) public sellerContracts;\r\n    mapping(address => uint256) public partnerFeeBps;\r\n\r\n    /***********************\r\n    +   Global settings   +\r\n    ***********************/\r\n    address public arbitrator;\r\n    address payable public feeRecipient;\r\n    uint256 private fee;\r\n    uint256 public disputeFee;\r\n\r\n    bool public stopped;\r\n\r\n    address public implementation;\r\n\r\n    // NFT contract for fee discounts\r\n    address public feeDiscountNFT;\r\n\r\n    /**********************\r\n    +   Events            +\r\n    ***********************/\r\n    event ContractCreated(address _seller, address _deployment);\r\n\r\n    /// @notice Settings\r\n    /// @param _arbitrator Address of the arbitrator (currently OP staff)\r\n    /// @param _feeRecipient Address to receive the fees\r\n    /// @param _fee OP fee (bps) ex: 30 == 0.3%\r\n    /// @param _trustedForwarder Forwarder address\r\n    /// @param _feeDiscountNFT NFT contract for fee discounts\r\n    /// @param _disputeFee Dispute fee\r\n    constructor(\r\n        address _arbitrator,\r\n        address payable _feeRecipient,\r\n        uint256 _fee,\r\n        address _trustedForwarder,\r\n        address _feeDiscountNFT,\r\n        uint256 _disputeFee\r\n    ) ERC2771Context(_trustedForwarder) {\r\n        arbitrator = _arbitrator;\r\n        feeRecipient = _feeRecipient;\r\n        fee = _fee;\r\n        feeDiscountNFT = _feeDiscountNFT;\r\n        disputeFee = _disputeFee;\r\n        implementation = address(new OpenPeerEscrow(_trustedForwarder));\r\n    }\r\n\r\n    /***********************\r\n    +   Modifiers          +\r\n    ***********************/\r\n\r\n    // circuit breaker modifiers\r\n    modifier stopInEmergency() {\r\n        if (stopped) {\r\n            revert(\"Paused\");\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function deploy() external returns (address) {\r\n        address deployment = Clones.clone(implementation);\r\n        OpenPeerEscrow(payable(deployment)).initialize(\r\n            payable(_msgSender()),\r\n            fee,\r\n            arbitrator,\r\n            feeRecipient,\r\n            _trustedForwarder,\r\n            feeDiscountNFT,\r\n            disputeFee\r\n        );\r\n        sellerContracts[_msgSender()] = deployment;\r\n        emit ContractCreated(_msgSender(), deployment);\r\n\r\n        return deployment;\r\n    }\r\n\r\n    /***********************\r\n    +   Setters           +\r\n    ***********************/\r\n\r\n    /// @notice Updates the arbitrator\r\n    /// @param _arbitrator Address of the arbitrator\r\n    function setArbitrator(address _arbitrator) public onlyOwner {\r\n        require(_arbitrator != address(0), \"Invalid arbitrator\");\r\n        arbitrator = _arbitrator;\r\n    }\r\n\r\n    /// @notice Updates the fee recipient\r\n    /// @param _feeRecipient Address of the arbitrator\r\n    function setFeeRecipient(address payable _feeRecipient) public onlyOwner {\r\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\r\n        feeRecipient = _feeRecipient;\r\n    }\r\n\r\n    /// @notice Updates the fee\r\n    /// @param _fee fee amount (bps)\r\n    function setFee(uint256 _fee) public onlyOwner {\r\n        require(_fee <= 100);\r\n\r\n        fee = _fee;\r\n    }\r\n\r\n    /// @notice Updates the forwarder\r\n    /// @param trustedForwarder biconomy forwarder\r\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\r\n        require(trustedForwarder != address(0), \"Invalid trust forwarder\");\r\n        _trustedForwarder = trustedForwarder;\r\n    }\r\n\r\n    /// @notice Updates the implementation\r\n    /// @param _implementation Address of the implementation\r\n    function setImplementation(\r\n        address payable _implementation\r\n    ) public onlyOwner {\r\n        require(_implementation != address(0), \"Invalid implementation\");\r\n        implementation = _implementation;\r\n    }\r\n\r\n    /// @notice Pauses and activate the contract\r\n    function toggleContractActive() public onlyOwner {\r\n        stopped = !stopped;\r\n    }\r\n\r\n    /// @notice Version recipient\r\n    function versionRecipient() external pure returns (string memory) {\r\n        return \"1.0\";\r\n    }\r\n\r\n    /// @notice Updates the NFT contract for fee discounts\r\n    function setFeeDiscountNFT(address _feeDiscountNFT) external onlyOwner {\r\n        feeDiscountNFT = _feeDiscountNFT;\r\n    }\r\n\r\n    function updatePartnerFeeBps(\r\n        address[] calldata _partners,\r\n        uint256[] calldata _fees\r\n    ) external onlyOwner {\r\n        require(_partners.length == _fees.length, \"Invalid input\");\r\n\r\n        for (uint256 i = 0; i < _partners.length; i++) {\r\n            require(_fees[i] <= 100, \"Invalid fee bps\");\r\n            require(_partners[i] != address(0), \"Invalid partner address\");\r\n\r\n            partnerFeeBps[_partners[i]] = _fees[i];\r\n        }\r\n    }\r\n\r\n    /***********************\r\n    +   Getters           +\r\n    ***********************/\r\n\r\n    function openPeerFee() public view returns (uint256) {\r\n        IERC721 discountNFT = IERC721(feeDiscountNFT);\r\n\r\n        if (\r\n            feeDiscountNFT != address(0) &&\r\n            discountNFT.balanceOf(_msgSender()) > 0\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        return fee;\r\n    }\r\n\r\n    function sellerFee(address _partner) public view returns (uint256) {\r\n        return openPeerFee() + partnerFeeBps[_partner];\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbitrator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeDiscountNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_disputeFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_deployment\",\"type\":\"address\"}],\"name\":\"ContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDiscountNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openPeerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnerFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellerContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"sellerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDiscountNFT\",\"type\":\"address\"}],\"name\":\"setFeeDiscountNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"name\":\"setTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleContractActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_partners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fees\",\"type\":\"uint256[]\"}],\"name\":\"updatePartnerFeeBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionRecipient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "OpenPeerEscrowsDeployer", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000630220d00cf136270f553c8577af18300f7b812c000000000000000000000000e872e7e3664f6ae78b62b360aca667877bfef088000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000086c80a8aa58e0a4fa09a69624c31ab2a6cad56b800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011c37937e08000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x183606b9dd0241219b127e841050a8e0c4bed9ce", "SwarmSource": "ipfs://a01e58acd5b5fbc904dc1a8285b5a87b7860267fc638b40b3d078f15c84e81d9"}