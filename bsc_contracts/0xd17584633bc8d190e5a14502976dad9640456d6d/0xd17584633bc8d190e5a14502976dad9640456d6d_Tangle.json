{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.9;\r\n\r\n/// @title Tangle, a token implementation using EIP-2535: Multi-Facet Proxy\r\n/// @author Brad Brown\r\n/// @notice Pieces of this contract can be updated without needing to redeploy\r\n/// the entire contract\r\n/// @dev implements IDiamondCut and IDiamondLoupe\r\ncontract Tangle {\r\n\r\n    mapping(bytes4 => address) private selectorToAddress;\r\n    /// @notice The owner of this contract\r\n    address public owner;\r\n\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    address[] private addresses;\r\n    mapping(address => uint) private addressIndex;\r\n    mapping(address => bytes4[]) private addressToSelectors;\r\n    mapping(bytes4 => uint) private selectorIndex;\r\n\r\n    /// @notice Records all functions added, replaced, or removed from this\r\n    /// contract\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    /// @notice set owner to deployer\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice payable fallback, does nothing\r\n    receive() external payable {}\r\n\r\n    /// @notice executes calldata via delegatecall to address if\r\n    /// calldata's selector is assigned\r\n    /// @dev Input is calldata\r\n    /// @return bytes response from delegatecall\r\n    fallback (bytes calldata) external payable returns (bytes memory) {\r\n        address address_ = selectorToAddress[msg.sig];\r\n        require(address_ != address(0), \"zero facet\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(\r\n                gas(),\r\n                address_,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n                case 0 { revert(0, returndatasize()) }\r\n                default { return (0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /// @notice checks if an address is in use as a facet\r\n    /// @param address_ an address to a facet\r\n    /// @return bool whether the address is in use or not\r\n    function facetAddressExists(address address_)\r\n        internal\r\n        view\r\n        returns\r\n        (bool)\r\n    {\r\n        if (addresses.length == 0)\r\n            return false;\r\n        if (addresses[0] != address_ && addressIndex[address_] == 0)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /// @notice assigns a selector to an address, revert if selector already\r\n    /// assigned\r\n    /// @param selector an 8 byte function selector\r\n    /// @param facetAddress_ an address to a facet\r\n    function addSelector(\r\n        bytes4 selector,\r\n        address facetAddress_\r\n    ) internal {\r\n        address currentFacetAddress = selectorToAddress[selector];\r\n        require(currentFacetAddress == address(0), \"selector add\");\r\n        selectorToAddress[selector] = facetAddress_;\r\n        selectorIndex[selector] = addressToSelectors[facetAddress_].length;\r\n        addressToSelectors[facetAddress_].push(selector);\r\n    }\r\n\r\n    /// @notice removes a selector from an address, revert if selector isn't\r\n    /// assigned\r\n    /// @param selector an 8 byte function selector\r\n    /// @param facetAddress_ an address to a facet\r\n    function removeSelector(\r\n        bytes4 selector,\r\n        address facetAddress_\r\n    ) internal {\r\n        address currentFacetAddress = selectorToAddress[selector];\r\n        require(currentFacetAddress != address(0), \"selector remove\");\r\n        bytes4[] memory selectors = addressToSelectors[facetAddress_];\r\n        bytes4 lastSelector = selectors[selectors.length - 1];\r\n        if (lastSelector != selector) {\r\n            selectorIndex[lastSelector] = selectorIndex[selector];\r\n            selectors[selectorIndex[selector]] = lastSelector;\r\n        }\r\n        if (selectors.length > 0) {\r\n            assembly {\r\n                mstore(selectors, sub(mload(selectors), 1))\r\n            }\r\n            addressToSelectors[facetAddress_] = selectors;\r\n        }\r\n        if (selectors.length == 0) {\r\n            address lastAddress = addresses[addresses.length - 1];\r\n            if (lastAddress != facetAddress_) {\r\n                addressIndex[lastAddress] = addressIndex[facetAddress_];\r\n                addresses[addressIndex[facetAddress_]] = lastAddress;\r\n            }\r\n            addresses.pop();\r\n            addressIndex[facetAddress_] = 0;\r\n        }\r\n        selectorToAddress[selector] = address(0);\r\n    }\r\n\r\n    /// @notice reassigns a selector to an address, revert if no change in\r\n    /// selector address\r\n    /// @param selector an 8 byte function selector\r\n    /// @param facetAddress_ an address to a facet\r\n    function replaceSelector(\r\n        bytes4 selector,\r\n        address facetAddress_\r\n    ) internal {\r\n        address currentFacetAddress = selectorToAddress[selector];\r\n        require(currentFacetAddress != facetAddress_, \"selector replace\");\r\n        bytes4[] memory selectors = addressToSelectors[currentFacetAddress];\r\n        bytes4 lastSelector = selectors[selectors.length - 1];\r\n        if (lastSelector != selector) {\r\n            selectorIndex[lastSelector] = selectorIndex[selector];\r\n            selectors[selectorIndex[selector]] = lastSelector;\r\n        }\r\n        if (selectors.length > 0) {\r\n            assembly {\r\n                mstore(selectors, sub(mload(selectors), 1))\r\n            }\r\n            addressToSelectors[currentFacetAddress] = selectors;\r\n        }\r\n        if (selectors.length == 0) {\r\n            address lastAddress = addresses[addresses.length - 1];\r\n            if (lastAddress != currentFacetAddress) {\r\n                addressIndex[lastAddress] = addressIndex[currentFacetAddress];\r\n                addresses[addressIndex[currentFacetAddress]] = lastAddress;\r\n            }\r\n            addresses.pop();\r\n            addressIndex[currentFacetAddress] = 0;\r\n        }\r\n        selectorToAddress[selector] = facetAddress_;\r\n        selectorIndex[selector] = addressToSelectors[facetAddress_].length;\r\n        addressToSelectors[facetAddress_].push(selector);\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally\r\n    /// execute a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and\r\n    /// arguments _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external {\r\n        require(msg.sender == owner, \"not owner\");\r\n        bool changesMade = false;\r\n        for (uint i = 0; i < _diamondCut.length; i++) {\r\n            FacetCut memory facetCut = _diamondCut[i];\r\n            address facetAddress_ = _diamondCut[i].facetAddress;\r\n            if (!facetAddressExists(facetAddress_)) {\r\n                addressIndex[facetAddress_] = addresses.length;\r\n                addresses.push(facetCut.facetAddress);\r\n            }\r\n            for (uint j = 0; j < facetCut.functionSelectors.length; j++) {\r\n                bytes4 selector = facetCut.functionSelectors[j];\r\n                if (facetCut.action == FacetCutAction.Add) {\r\n                    addSelector(selector, facetAddress_);\r\n                    if (!changesMade) changesMade = true;\r\n                }\r\n                if (facetCut.action == FacetCutAction.Replace) {\r\n                    replaceSelector(selector, facetAddress_);\r\n                    if (!changesMade) changesMade = true;\r\n                }\r\n                if (facetCut.action == FacetCutAction.Remove) {\r\n                    removeSelector(selector, facetAddress_);\r\n                    if (!changesMade) changesMade = true;\r\n                }\r\n            }\r\n        }\r\n        if (_init != address(0)) {\r\n            require(_calldata.length > 0, \"empty calldata\");\r\n            (bool success,) = _init.delegatecall(_calldata);\r\n            require(success, \"call unsuccessful\");\r\n        }\r\n        if (changesMade) emit DiamondCut(_diamondCut, _init, _calldata);\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function\r\n    /// selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory) {\r\n        Facet[] memory facets_ = new Facet[](addresses.length);\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            Facet memory facet;\r\n            facet.facetAddress = addresses[i];\r\n            facet.functionSelectors = addressToSelectors[addresses[i]];\r\n            facets_[i] = facet;\r\n        }\r\n        return facets_;\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(\r\n        address _facet\r\n    )\r\n        external\r\n        view\r\n        returns\r\n        (bytes4[] memory)\r\n    {\r\n        return addressToSelectors[_facet];\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns\r\n        (address[] memory)\r\n    {\r\n        return addresses;\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector)\r\n        external\r\n        view\r\n        returns\r\n        (address)\r\n    {\r\n        return selectorToAddress[_functionSelector];\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum Tangle.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct Tangle.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum Tangle.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Tangle.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Tangle.Facet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Tangle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x59e8ed593a60df8b91cdf6b38b55cfb55b4715b6", "SwarmSource": "ipfs://e190d58917657ec164555ee79e2d27f14c3d2a5eb44bf030b58589d170cadd8e"}