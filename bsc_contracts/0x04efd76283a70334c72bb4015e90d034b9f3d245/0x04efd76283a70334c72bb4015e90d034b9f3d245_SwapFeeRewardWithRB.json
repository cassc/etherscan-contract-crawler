{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SwapFeeRewardWithRB.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/EnumerableSet.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\n\\ninterface IBSWFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function INIT_CODE_HASH() external pure returns (bytes32);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n\\n    function setDevFee(address pair, uint8 _devFee) external;\\n\\n    function setSwapFee(address pair, uint32 swapFee) external;\\n}\\n\\ninterface IBSWPair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint);\\n\\n    function price1CumulativeLast() external view returns (uint);\\n\\n    function kLast() external view returns (uint);\\n\\n    function swapFee() external view returns (uint32);\\n\\n    function devFee() external view returns (uint32);\\n\\n    function mint(address to) external returns (uint liquidity);\\n\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n\\n    function setSwapFee(uint32) external;\\n\\n    function setDevFee(uint32) external;\\n}\\n\\ninterface IBswToken is IERC20 {\\n    function mint(address to, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external override returns (bool);\\n}\\n\\ninterface IBiswapNFT {\\n    function accrueRB(address user, uint amount) external;\\n    function tokenFreeze(uint tokenId) external;\\n    function tokenUnfreeze(uint tokenId) external;\\n    function getRB(uint tokenId) external view returns(uint);\\n    function getInfoForStaking(uint tokenId) external view returns(address tokenOwner, bool stakeFreeze, uint robiBoost);\\n}\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() public {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n\\ncontract SwapFeeRewardWithRB is Ownable, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    EnumerableSet.AddressSet private _whitelist;\\n\\n    address public factory;\\n    address public router;\\n    address public market;\\n    address public auction;\\n    bytes32 public INIT_CODE_HASH;\\n    uint256 public maxMiningAmount = 100000000 ether;\\n    uint256 public maxMiningInPhase = 5000 ether;\\n    uint public maxAccruedRBInPhase = 5000 ether;\\n\\n    uint public currentPhase = 1;\\n    uint public currentPhaseRB = 1;\\n    uint256 public totalMined = 0;\\n    uint public totalAccruedRB = 0;\\n    uint public rbWagerOnSwap = 1500; //Wager of RB\\n    uint public rbPercentMarket = 10000; // (div 10000)\\n    uint public rbPercentAuction = 10000; // (div 10000)\\n    IBswToken public bswToken;\\n    IOracle public oracle;\\n    IBiswapNFT public biswapNFT;\\n    address public targetToken;\\n    address public targetRBToken;\\n    uint public defaultFeeDistribution = 90;\\n\\n    mapping(address => uint) public nonces;\\n    mapping(address => uint256) private _balances;\\n    mapping(address => uint256) public pairOfPid;\\n\\n    //percent of distribution between feeReward and robiBoost [0, 90] 0 => 90% feeReward and 10% robiBoost; 90 => 100% robiBoost\\n    //calculate: defaultFeeDistribution (90) - feeDistibution = feeReward\\n    mapping(address => uint) public feeDistribution;\\n\\n    struct PairsList {\\n        address pair;\\n        uint256 percentReward;\\n        bool enabled;\\n    }\\n\\n    PairsList[] public pairsList;\\n\\n    event Withdraw(address userAddress, uint256 amount);\\n    event Rewarded(address account, address input, address output, uint256 amount, uint256 quantity);\\n    //BNF-01, SFR-01\\n    event NewRouter(address);\\n    event NewFactory(address);\\n    event NewMarket(address);\\n    event NewPhase(uint);\\n    event NewPhaseRB(uint);\\n    event NewAuction(address);\\n    event NewBiswapNFT(IBiswapNFT);\\n    event NewOracle(IOracle);\\n\\n    modifier onlyRouter() {\\n        require(msg.sender == router, \\\"SwapFeeReward: caller is not the router\\\");\\n        _;\\n    }\\n\\n    modifier onlyMarket() {\\n        require(msg.sender == market, \\\"SwapFeeReward: caller is not the market\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuction() {\\n        require(msg.sender == auction, \\\"SwapFeeReward: caller is not the auction\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _factory,\\n        address _router,\\n        bytes32 _INIT_CODE_HASH,\\n        IBswToken _bswToken,\\n        IOracle _Oracle,\\n        IBiswapNFT _biswapNFT,\\n        address _targetToken,\\n        address _targetRBToken\\n\\n    ) public {\\n        //SFR-03\\n        require(\\n            _factory != address(0)\\n            && _router != address(0)\\n            && _targetToken != address(0)\\n            && _targetRBToken != address(0),\\n            \\\"Address can not be zero\\\"\\n        );\\n        factory = _factory;\\n        router = _router;\\n        INIT_CODE_HASH = _INIT_CODE_HASH;\\n        bswToken = _bswToken;\\n        oracle = _Oracle;\\n        targetToken = _targetToken;\\n        biswapNFT = _biswapNFT;\\n        targetRBToken = _targetRBToken;\\n    }\\n\\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\\"BSWSwapFactory: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"BSWSwapFactory: ZERO_ADDRESS\\\");\\n    }\\n\\n    function pairFor(address tokenA, address tokenB) public view returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                INIT_CODE_HASH\\n            ))));\\n    }\\n\\n    function getSwapFee(address tokenA, address tokenB) internal view returns (uint swapFee) {\\n        //SFR-05\\n        swapFee = uint(1000).sub(IBSWPair(pairFor(tokenA, tokenB)).swapFee());\\n    }\\n\\n    function setPhase(uint _newPhase) public onlyOwner returns (bool){\\n        currentPhase = _newPhase;\\n        //BNF-01, SFR-01\\n        emit NewPhase(_newPhase);\\n        return true;\\n    }\\n\\n    function setPhaseRB(uint _newPhase) public onlyOwner returns (bool){\\n        currentPhaseRB = _newPhase;\\n        //BNF-01, SFR-01\\n        emit NewPhaseRB(_newPhase);\\n        return true;\\n    }\\n\\n    function checkPairExist(address tokenA, address tokenB) public view returns (bool) {\\n        address pair = pairFor(tokenA, tokenB);\\n        PairsList storage pool = pairsList[pairOfPid[pair]];\\n        if (pool.pair != pair) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function feeCalculate(address account, address input, address output, uint256 amount)\\n    public\\n    view\\n    returns(\\n        uint feeReturnInBSW,\\n        uint feeReturnInUSD,\\n        uint robiBoostAccrue\\n    )\\n    {\\n\\n        uint256 pairFee = getSwapFee(input, output);\\n        address pair = pairFor(input, output);\\n        PairsList memory pool = pairsList[pairOfPid[pair]];\\n        if (pool.pair != pair || pool.enabled == false || !isWhitelist(input) || !isWhitelist(output)) {\\n            feeReturnInBSW = 0;\\n            feeReturnInUSD = 0;\\n            robiBoostAccrue = 0;\\n        } else {\\n            (uint feeAmount, uint rbAmount) = calcAmounts(amount, account);\\n            uint256 fee = feeAmount.div(pairFee);\\n            uint256 quantity = getQuantity(output, fee, targetToken);\\n            feeReturnInBSW = quantity.mul(pool.percentReward).div(100);\\n            robiBoostAccrue = getQuantity(output, rbAmount.div(rbWagerOnSwap), targetRBToken);\\n            feeReturnInUSD = getQuantity(targetToken, feeReturnInBSW, targetRBToken);\\n        }\\n    }\\n\\n    function swap(address account, address input, address output, uint256 amount) public onlyRouter returns (bool) {\\n        if (!isWhitelist(input) || !isWhitelist(output)) {\\n            return false;\\n        }\\n        address pair = pairFor(input, output);\\n        PairsList memory pool = pairsList[pairOfPid[pair]];\\n        if (pool.pair != pair || pool.enabled == false) {\\n            return false;\\n        }\\n        uint256 pairFee = getSwapFee(input, output);\\n        (uint feeAmount, uint rbAmount) = calcAmounts(amount, account);\\n        uint256 fee = feeAmount.div(pairFee);\\n        rbAmount = rbAmount.div(rbWagerOnSwap);\\n        //SFR-05\\n        _accrueRB(account, output, rbAmount);\\n\\n        uint256 quantity = getQuantity(output, fee, targetToken);\\n        quantity = quantity.mul(pool.percentReward).div(100);\\n        if (maxMiningAmount >= totalMined.add(quantity)) {\\n            if (totalMined.add(quantity) <= currentPhase.mul(maxMiningInPhase)) {\\n                _balances[account] = _balances[account].add(quantity);\\n                emit Rewarded(account, input, output, amount, quantity);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function calcAmounts(uint amount, address account) internal view returns(uint feeAmount, uint rbAmount){\\n        feeAmount = amount.mul(defaultFeeDistribution.sub(feeDistribution[account])).div(100);\\n        rbAmount = amount.sub(feeAmount);\\n    }\\n\\n    function accrueRBFromMarket(address account, address fromToken, uint amount) public onlyMarket {\\n        //SFR-05\\n        amount = amount.mul(rbPercentMarket).div(10000);\\n        _accrueRB(account, fromToken, amount);\\n    }\\n\\n    function accrueRBFromAuction(address account, address fromToken, uint amount) public onlyAuction {\\n        //SFR-05\\n        amount = amount.mul(rbPercentAuction).div(10000);\\n        _accrueRB(account, fromToken, amount);\\n    }\\n\\n    //SFR-05\\n    function _accrueRB(address account, address output, uint amount) private {\\n        uint quantity = getQuantity(output, amount, targetRBToken);\\n        if (quantity > 0) {\\n            //SFR-06\\n            totalAccruedRB = totalAccruedRB.add(quantity);\\n            if(totalAccruedRB <= currentPhaseRB.mul(maxAccruedRBInPhase)){\\n                biswapNFT.accrueRB(account, quantity);\\n            }\\n        }\\n    }\\n\\n    function rewardBalance(address account) public view returns (uint256){\\n        return _balances[account];\\n    }\\n\\n    function permit(address spender, uint value, uint8 v, bytes32 r, bytes32 s) private {\\n        bytes32 message = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encodePacked(spender, value, nonces[spender]++))));\\n        address recoveredAddress = ecrecover(message, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == spender, \\\"SwapFeeReward: INVALID_SIGNATURE\\\");\\n    }\\n\\n    //BNF-02, SCN-01, SFR-02\\n    function withdraw(uint8 v, bytes32 r, bytes32 s) public nonReentrant returns (bool){\\n        require(maxMiningAmount > totalMined, \\\"SwapFeeReward: Mined all tokens\\\");\\n        uint256 balance = _balances[msg.sender];\\n        require(totalMined.add(balance) <= currentPhase.mul(maxMiningInPhase), \\\"SwapFeeReward: Mined all tokens in this phase\\\");\\n        permit(msg.sender, balance, v, r, s);\\n        if (balance > 0) {\\n            _balances[msg.sender] = _balances[msg.sender].sub(balance);\\n            totalMined = totalMined.add(balance);\\n            //SFR-04\\n            if(bswToken.transfer(msg.sender, balance)){\\n                emit Withdraw(msg.sender, balance);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function getQuantity(address outputToken, uint256 outputAmount, address anchorToken) public view returns (uint256) {\\n        uint256 quantity = 0;\\n        if (outputToken == anchorToken) {\\n            quantity = outputAmount;\\n        } else if (IBSWFactory(factory).getPair(outputToken, anchorToken) != address(0) && checkPairExist(outputToken, anchorToken)) {\\n            quantity = IOracle(oracle).consult(outputToken, outputAmount, anchorToken);\\n        } else {\\n            uint256 length = getWhitelistLength();\\n            for (uint256 index = 0; index < length; index++) {\\n                address intermediate = getWhitelist(index);\\n                if (IBSWFactory(factory).getPair(outputToken, intermediate) != address(0) && IBSWFactory(factory).getPair(intermediate, anchorToken) != address(0) && checkPairExist(intermediate, anchorToken)) {\\n                    uint256 interQuantity = IOracle(oracle).consult(outputToken, outputAmount, intermediate);\\n                    quantity = IOracle(oracle).consult(intermediate, interQuantity, anchorToken);\\n                    break;\\n                }\\n            }\\n        }\\n        return quantity;\\n    }\\n\\n    function addWhitelist(address _addToken) public onlyOwner returns (bool) {\\n        require(_addToken != address(0), \\\"SwapMining: token is the zero address\\\");\\n        return EnumerableSet.add(_whitelist, _addToken);\\n    }\\n\\n    function delWhitelist(address _delToken) public onlyOwner returns (bool) {\\n        require(_delToken != address(0), \\\"SwapMining: token is the zero address\\\");\\n        return EnumerableSet.remove(_whitelist, _delToken);\\n    }\\n\\n    function getWhitelistLength() public view returns (uint256) {\\n        return EnumerableSet.length(_whitelist);\\n    }\\n\\n    function isWhitelist(address _token) public view returns (bool) {\\n        return EnumerableSet.contains(_whitelist, _token);\\n    }\\n\\n    function getWhitelist(uint256 _index) public view returns (address){\\n        //SFR-06\\n        require(_index <= getWhitelistLength().sub(1), \\\"SwapMining: index out of bounds\\\");\\n        return EnumerableSet.at(_whitelist, _index);\\n    }\\n\\n    function setRouter(address newRouter) public onlyOwner {\\n        require(newRouter != address(0), \\\"SwapMining: new router is the zero address\\\");\\n        router = newRouter;\\n        //BNF-01, SFR-01\\n        emit NewRouter(newRouter);\\n    }\\n\\n    function setMarket(address _market) public onlyOwner {\\n        require(_market != address(0), \\\"SwapMining: new market is the zero address\\\");\\n        market = _market;\\n        //BNF-01, SFR-01\\n        emit NewMarket(_market);\\n    }\\n\\n    function setAuction(address _auction) public onlyOwner {\\n        require(_auction != address(0), \\\"SwapMining: new auction is the zero address\\\");\\n        auction = _auction;\\n        //BNF-01, SFR-01\\n        emit NewAuction(_auction);\\n    }\\n\\n    function setBiswapNFT(IBiswapNFT _biswapNFT) public onlyOwner {\\n        require(address(_biswapNFT) != address(0), \\\"SwapMining: new biswapNFT is the zero address\\\");\\n        biswapNFT = _biswapNFT;\\n        //BNF-01, SFR-01\\n        emit NewBiswapNFT(_biswapNFT);\\n    }\\n\\n    function setOracle(IOracle _oracle) public onlyOwner {\\n        require(address(_oracle) != address(0), \\\"SwapMining: new oracle is the zero address\\\");\\n        oracle = _oracle;\\n        //BNF-01, SFR-01\\n        emit NewOracle(_oracle);\\n    }\\n\\n    function setFactory(address _factory) public onlyOwner {\\n        require(_factory != address(0), \\\"SwapMining: new factory is the zero address\\\");\\n        factory = _factory;\\n        //BNF-01, SFR-01\\n        emit NewFactory(_factory);\\n    }\\n\\n    function setInitCodeHash(bytes32 _INIT_CODE_HASH) public onlyOwner {\\n        INIT_CODE_HASH = _INIT_CODE_HASH;\\n    }\\n\\n    function pairsListLength() public view returns (uint256) {\\n        return pairsList.length;\\n    }\\n\\n    function addPair(uint256 _percentReward, address _pair) public onlyOwner {\\n        require(_pair != address(0), \\\"_pair is the zero address\\\");\\n        pairsList.push(\\n            PairsList({\\n        pair : _pair,\\n        percentReward : _percentReward,\\n        enabled : true\\n        })\\n        );\\n        //SFR-06\\n        pairOfPid[_pair] = pairsListLength().sub(1);\\n\\n    }\\n\\n    function setPair(uint256 _pid, uint256 _percentReward) public onlyOwner {\\n        pairsList[_pid].percentReward = _percentReward;\\n    }\\n\\n    function setPairEnabled(uint256 _pid, bool _enabled) public onlyOwner {\\n        pairsList[_pid].enabled = _enabled;\\n    }\\n\\n    function setRobiBoostReward(uint _rbWagerOnSwap, uint _percentMarket, uint _percentAuction) public onlyOwner {\\n        rbWagerOnSwap = _rbWagerOnSwap;\\n        rbPercentMarket = _percentMarket;\\n        rbPercentAuction = _percentAuction;\\n    }\\n\\n    function setFeeDistribution(uint newDistribution) public {\\n        require(newDistribution <= defaultFeeDistribution, \\\"Wrong fee distribution\\\");\\n        feeDistribution[msg.sender] = newDistribution;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\ncontract Ownable {\\n    address private _owner;\\n\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function isOwner(address account) public view returns (bool) {\\n        return account == _owner;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n}\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\nlibrary SafeMath {\\n    uint256 constant WAD = 10 ** 18;\\n    uint256 constant RAY = 10 ** 27;\\n\\n    function wad() public pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    function ray() public pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\\n        if (a > 3) {\\n            b = a;\\n            uint256 x = a / 2 + 1;\\n            while (x < b) {\\n                b = x;\\n                x = (a / x + x) / 2;\\n            }\\n        } else if (a != 0) {\\n            b = 1;\\n        }\\n    }\\n\\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul(a, b) / WAD;\\n    }\\n\\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, b), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul(a, b) / RAY;\\n    }\\n\\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, b), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(mul(a, WAD), b);\\n    }\\n\\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, WAD), b / 2) / b;\\n    }\\n\\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(mul(a, RAY), b);\\n    }\\n\\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, RAY), b / 2) / b;\\n    }\\n\\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 result = WAD;\\n        while (n > 0) {\\n            if (n % 2 != 0) {\\n                result = wmul(result, x);\\n            }\\n            x = wmul(x, x);\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 result = RAY;\\n        while (n > 0) {\\n            if (n % 2 != 0) {\\n                result = rmul(result, x);\\n            }\\n            x = rmul(x, x);\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libs/EnumerableSet.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {// Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1;\\n            // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\ninterface IOracle {\\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_INIT_CODE_HASH\",\"type\":\"bytes32\"},{\"internalType\":\"contract IBswToken\",\"name\":\"_bswToken\",\"type\":\"address\"},{\"internalType\":\"contract IOracle\",\"name\":\"_Oracle\",\"type\":\"address\"},{\"internalType\":\"contract IBiswapNFT\",\"name\":\"_biswapNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_targetRBToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IBiswapNFT\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewBiswapNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewFactory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NewPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NewPhaseRB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NewRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"Rewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INIT_CODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"accrueRBFromAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"accrueRBFromMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentReward\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addToken\",\"type\":\"address\"}],\"name\":\"addWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"biswapNFT\",\"outputs\":[{\"internalType\":\"contract IBiswapNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bswToken\",\"outputs\":[{\"internalType\":\"contract IBswToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"checkPairExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPhaseRB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeeDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delToken\",\"type\":\"address\"}],\"name\":\"delWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeCalculate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeReturnInBSW\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeReturnInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"robiBoostAccrue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"anchorToken\",\"type\":\"address\"}],\"name\":\"getQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getWhitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAccruedRBInPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMiningAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMiningInPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairOfPid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairsList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentReward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairsListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rbPercentAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rbPercentMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rbWagerOnSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auction\",\"type\":\"address\"}],\"name\":\"setAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBiswapNFT\",\"name\":\"_biswapNFT\",\"type\":\"address\"}],\"name\":\"setBiswapNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDistribution\",\"type\":\"uint256\"}],\"name\":\"setFeeDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_INIT_CODE_HASH\",\"type\":\"bytes32\"}],\"name\":\"setInitCodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"setMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentReward\",\"type\":\"uint256\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setPairEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPhase\",\"type\":\"uint256\"}],\"name\":\"setPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPhase\",\"type\":\"uint256\"}],\"name\":\"setPhaseRB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rbWagerOnSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentMarket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentAuction\",\"type\":\"uint256\"}],\"name\":\"setRobiBoostReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"sortTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRBToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccruedRB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SwapFeeRewardWithRB", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000858e3312ed3a876947ea49d572a7c42de08af7ee0000000000000000000000003a6d8ca21d1cf76f653a67577fa0d27453350dd8fea293c909d87cd4153593f077b76bb7e94340200f4ee84211ae8e4f9bd7ffdf000000000000000000000000965f527d9159dce6288a2219db51fc6eef120dd10000000000000000000000002f48cde4cfd0fb4f5c873291d5cf2dc9e61f2db0000000000000000000000000d4220b0b196824c2f548a34c47d81737b0f6b5d6000000000000000000000000965f527d9159dce6288a2219db51fc6eef120dd100000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}