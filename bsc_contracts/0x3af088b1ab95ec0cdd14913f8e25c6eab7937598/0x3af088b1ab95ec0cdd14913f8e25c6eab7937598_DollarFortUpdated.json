{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/DollarFortUpdated.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport \\\"./Tether.sol\\\";\\n\\ncontract DollarFortUpdated {\\n    IBEP20 public _usdtToken;\\n    uint256 public immutable CONST_MIN_INVESTMENT = toWei(100);\\n    uint256 public immutable CONST_MIN_WITHDRAWAL = toWei(12);\\n    address public immutable CONST_SYSTEM_ADDRESS;\\n    uint32[] public CONST_REWARDS = [3000, 9000, 27000, 81000, 243000, 729000];\\n    uint256 public immutable CONST_REWARD_FLUSHED_TIMESTAMP = 4102444800;\\n    uint8 public immutable CONST_REWARD_PERCENTAGE = 10; // 10% of the achieved business volume\\n    uint8 public immutable CONST_ROI_PER_DAY = 5; // 0.5% daily\\n    uint8 public immutable CONST_DIRECT_LEVEL_OPENED_PER_REFERRAL = 1;\\n    uint8 public immutable CONST_GENERATION_LEVEL_OPENED_PER_REFERRAL = 3;\\n    uint16 public immutable CONST_WORKING_LIMIT = 3000;\\n    uint16 public immutable CONST_NONWORKING_LIMIT = 1825;\\n    uint8[] public CONST_DIRECT_INCOME_PERCENTAGES = [\\n        15,\\n        5,\\n        5,\\n        5,\\n        5,\\n        5,\\n        5,\\n        5,\\n        5,\\n        5\\n    ]; // 1.5% for 1st level & 0.5% for 2nd to 10th level\\n\\n    // Level 1 to 10 = 3%; Level 11 to 20 = 6%; Level 21 to 30 = 9%;\\n    uint256[] public CONST_GENERATION_INCOME_PERCENTAGES = [\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90\\n    ];\\n\\n    address public immutable CONST_PROJECT_ADDRESS;\\n    address public immutable CONST_MARKETING_ADDRESS;\\n    address public immutable CONST_FEES_ADDRESS;\\n\\n    enum UserIncome {\\n        AP,\\n        RR,\\n        NN\\n    }\\n\\n    event UserRegistered(\\n        address indexed user,\\n        address indexed sponsor,\\n        uint256 investment,\\n        uint256 timestamp\\n    );\\n\\n    event WithdrawalHappened(\\n        address indexed user,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    struct UserInvestment {\\n        uint256 id;\\n        uint256 amount;\\n        uint256 timestamp;\\n        uint256 endedTimestamp;\\n        UserIncome incomeType;\\n    }\\n\\n    // some stat fields for the contract\\n    uint256 totalInvestments;\\n    uint256 totalWithdrawal;\\n\\n    struct User {\\n        address addr;\\n        mapping(uint8 => uint256) usersAtEachLevel;\\n        mapping(uint8 => uint256) achievedRewards; // index to reward timestamp\\n        mapping(uint8 => uint256) businessAtEachLevel;\\n        mapping(uint8 => address[]) usersAtEachLevelArray;\\n        UserDetails details;\\n    }\\n\\n    struct UserDetails {\\n        uint256 directIncome;\\n        uint256 generationIncome;\\n        uint256 totalSelfRoiIncome;\\n        uint256 totalDirectIncome;\\n        uint256 totalGenerationIncome;\\n        uint256 lastRetopupTimestamp;\\n        uint256 lastWithdrawalTimestamp;\\n        uint256[] withdrawalAmounts; // timestamp to amount\\n        uint256[] withdrawalTimestamps;\\n        uint256 totalInvestmentTillDate;\\n        uint256 activeInvestmentAmount;\\n        uint256 totalWithdrawal;\\n        uint256 directBusiness;\\n        uint256 levelBusiness;\\n        uint256 pendingFromMaxLimit;\\n        uint256 rewardCarryForwardAmount;\\n        uint8 directLevelsOpened;\\n        uint8 generationLevelsOpened;\\n        uint256 registrationTimestamp;\\n        UserInvestment[] investments;\\n        address[] referrals;\\n        address sponsor;\\n        UserIncome userIncome;\\n    }\\n\\n    uint256 public _investmentIndex = 1;\\n\\n    mapping(address => User) public users;\\n\\n    constructor(\\n        address usdtAddress,\\n        address _projectAddress,\\n        address _marketingAddress,\\n        address _feesAddress\\n    ) {\\n        CONST_SYSTEM_ADDRESS = msg.sender;\\n        _usdtToken = IBEP20(usdtAddress);\\n        CONST_PROJECT_ADDRESS = _projectAddress;\\n        CONST_MARKETING_ADDRESS = _marketingAddress;\\n        CONST_FEES_ADDRESS = _feesAddress;\\n\\n        uint256 _systemInvestment = toWei(1000);\\n        User storage _systemUser = users[CONST_SYSTEM_ADDRESS];\\n        _systemUser.addr = CONST_SYSTEM_ADDRESS;\\n        _systemUser.details.pendingFromMaxLimit = _systemInvestment * 30000;\\n        _systemUser.details.directLevelsOpened = uint8(\\n            CONST_DIRECT_INCOME_PERCENTAGES.length\\n        );\\n        _systemUser.details.generationLevelsOpened = uint8(\\n            CONST_GENERATION_INCOME_PERCENTAGES.length\\n        );\\n        _systemUser.details.registrationTimestamp = block.timestamp;\\n        _systemUser.details.investments.push(\\n            UserInvestment({\\n                id: _investmentIndex++,\\n                amount: _systemInvestment,\\n                timestamp: block.timestamp,\\n                endedTimestamp: 0,\\n                incomeType: UserIncome.AP\\n            })\\n        );\\n        _systemUser.details.userIncome = UserIncome.AP;\\n    }\\n\\n    modifier onlySystem() {\\n        require(\\n            msg.sender == CONST_SYSTEM_ADDRESS,\\n            \\\"Only system can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    function toWei(uint256 _n) public pure returns (uint256) {\\n        return _n * 10 ** 18;\\n    }\\n\\n    function getUserDownlineAtLevel(\\n        address _addr,\\n        uint8 _level\\n    ) public view returns (address[] memory) {\\n        return users[_addr].usersAtEachLevelArray[_level];\\n    }\\n\\n    function getSelfRoiPerSecond(address _addr) public view returns (uint256) {\\n        User storage _user = users[_addr];\\n\\n        if (_user.details.userIncome != UserIncome.NN) return 0;\\n\\n        uint256 _selfRoiPerSecond = ((CONST_ROI_PER_DAY) *\\n            _user.details.activeInvestmentAmount) / 1000;\\n        _selfRoiPerSecond /= 86400;\\n\\n        return _selfRoiPerSecond;\\n    }\\n\\n    function getGenerationPerSecond(\\n        address _addr\\n    ) public view returns (uint256) {\\n        User storage _user = users[_addr];\\n\\n        uint256 _generationPerSecond = 0;\\n\\n        uint256[] memory roiAmountAtLevels = getAllLevelsDownlineRoi(_addr);\\n\\n        for (uint8 i = 0; i < CONST_GENERATION_INCOME_PERCENTAGES.length; i++) {\\n            // _generationPerSecond += 5 * 10 ** 18;\\n            if (_user.details.generationLevelsOpened >= (i == 0 ? 0 : i + 1)) {\\n                uint256 _roi = roiAmountAtLevels[i];\\n\\n                _generationPerSecond +=\\n                    (CONST_GENERATION_INCOME_PERCENTAGES[i] * 10 ** 18) *\\n                    (_roi);\\n                // _generationPerSecond +=\\n                //     (CONST_GENERATION_INCOME_PERCENTAGES[i] / 1000) *\\n                //     _roi;\\n                // _generationPerSecond += 10 * 10 ** 18;\\n            }\\n        }\\n\\n        return (_generationPerSecond / 10 ** 21);\\n    }\\n\\n    function getAllLevelsDownlineRoi(\\n        address _addr\\n    ) public view returns (uint256[] memory) {\\n        User storage _user = users[_addr];\\n        uint256[] memory roiAmountAtLevels = new uint256[](\\n            CONST_GENERATION_INCOME_PERCENTAGES.length\\n        );\\n\\n        for (uint8 i = 0; i < CONST_GENERATION_INCOME_PERCENTAGES.length; i++) {\\n            uint256 _roi = 0;\\n\\n            for (\\n                uint256 j = 0;\\n                j < _user.usersAtEachLevelArray[i].length;\\n                j++\\n            ) {\\n                _roi += getSelfRoiPerSecond(_user.usersAtEachLevelArray[i][j]);\\n            }\\n\\n            roiAmountAtLevels[i] += _roi;\\n        }\\n\\n        return roiAmountAtLevels;\\n    }\\n\\n    function getUserDetails(\\n        address _addr\\n    ) external view returns (UserDetails memory) {\\n        return users[_addr].details;\\n    }\\n\\n    function getUserInvestments(\\n        address _address\\n    ) external view returns (UserInvestment[] memory) {\\n        return users[_address].details.investments;\\n    }\\n\\n    function getRewards() external view returns (uint32[] memory) {\\n        return CONST_REWARDS;\\n    }\\n\\n    function getUserAchievedRewards(\\n        address _addr\\n    ) external view returns (uint256[] memory) {\\n        uint256[] memory _rewards = new uint256[](CONST_REWARDS.length);\\n\\n        for (uint8 i = 0; i < CONST_REWARDS.length; i++) {\\n            _rewards[i] = users[_addr].achievedRewards[i];\\n        }\\n\\n        return _rewards;\\n    }\\n\\n    function _getUserReferralCount(\\n        address _address\\n    ) external view returns (uint256) {\\n        uint256 _count = 0;\\n        address[] memory referrals = users[_address].details.referrals;\\n\\n        for (uint256 i = 0; i < referrals.length; i++) {\\n            if (users[referrals[i]].details.userIncome == UserIncome.NN) {\\n                _count++;\\n            }\\n        }\\n\\n        return _count;\\n    }\\n\\n    function userExists(address _address) public view returns (bool) {\\n        return users[_address].addr != address(0);\\n    }\\n\\n    function getUserLatestInvestment(\\n        address _address\\n    ) private view returns (UserInvestment memory) {\\n        User storage _user = users[_address];\\n        return _user.details.investments[_user.details.investments.length - 1];\\n    }\\n\\n    function getUserStructure(\\n        address _addr\\n    )\\n        external\\n        view\\n        returns (uint16[] memory usersList, uint256[] memory business)\\n    {\\n        User storage _user = users[_addr];\\n        uint16[] memory _usersList = new uint16[](\\n            CONST_GENERATION_INCOME_PERCENTAGES.length\\n        );\\n        uint256[] memory _business = new uint256[](\\n            CONST_GENERATION_INCOME_PERCENTAGES.length\\n        );\\n\\n        for (uint8 i = 0; i < CONST_GENERATION_INCOME_PERCENTAGES.length; i++) {\\n            _usersList[i] = uint16(_user.usersAtEachLevel[i]);\\n            _business[i] = _user.businessAtEachLevel[i];\\n        }\\n\\n        return (_usersList, _business);\\n    }\\n\\n    function getUserBalance(\\n        address addr,\\n        uint256 timestamp\\n    ) external view returns (uint256) {\\n        User storage _user = users[addr];\\n\\n        return\\n            _user.details.directIncome +\\n            _user.details.generationIncome +\\n            getUserAvailableSelfRoi(addr, timestamp);\\n    }\\n\\n    function getUserAvailableSelfRoi(\\n        address _addr,\\n        uint256 timestamp\\n    ) public view returns (uint256) {\\n        timestamp /= 10 ** 18;\\n        User storage _user = users[_addr];\\n        uint256 _selfRoiIncome = 0;\\n\\n        if (_user.details.userIncome == UserIncome.NN) {\\n            // we will calculate this based upon time\\n\\n            for (uint256 i = 0; i < _user.details.investments.length; i++) {\\n                UserInvestment storage _investment = _user.details.investments[\\n                    i\\n                ];\\n\\n                if (_investment.endedTimestamp != 0) {\\n                    continue;\\n                }\\n\\n                uint256 checkpoint = _user.details.lastWithdrawalTimestamp == 0\\n                    ? timestamp\\n                    : _user.details.lastWithdrawalTimestamp;\\n\\n                if (_investment.timestamp > checkpoint) {\\n                    checkpoint = timestamp;\\n                }\\n\\n                // adison migration is pending 7:33 PM 22 dec 2023\\n\\n                uint256 _seconds = (checkpoint - _investment.timestamp);\\n\\n                // _selfRoiIncome += toWei(block.timestamp);\\n\\n                // if (_seconds > 0) {\\n                uint256 _roi = ((_investment.amount *\\n                    _seconds *\\n                    CONST_ROI_PER_DAY) / 1000) / 86400;\\n                _selfRoiIncome += _roi;\\n            }\\n        }\\n        // }\\n\\n        return _selfRoiIncome;\\n    }\\n\\n    function getUserAvailableGenerationIncome(\\n        address _addr,\\n        uint256 timestamp\\n    ) external view returns (uint256) {\\n        timestamp /= 10 ** 18;\\n        User storage _user = users[_addr];\\n        uint256 generationPerSecond = getGenerationPerSecond(_addr);\\n\\n        uint256 checkpoint = _user.details.lastWithdrawalTimestamp == 0\\n            ? _user.details.registrationTimestamp\\n            : _user.details.lastWithdrawalTimestamp;\\n\\n        uint256 _seconds = (timestamp - checkpoint);\\n\\n        return (generationPerSecond * _seconds);\\n    }\\n\\n    function safeFromLimit(\\n        address _address,\\n        uint256 _amount\\n    ) private returns (uint256) {\\n        if (users[_address].details.userIncome == UserIncome.AP) return _amount;\\n\\n        if (users[_address].details.pendingFromMaxLimit > _amount) {\\n            users[_address].details.pendingFromMaxLimit -= _amount;\\n            return _amount;\\n        } else {\\n            uint256 _amountToReturn = users[_address]\\n                .details\\n                .pendingFromMaxLimit;\\n            users[_address].details.pendingFromMaxLimit = 0;\\n            UserInvestment storage _investment = users[_address]\\n                .details\\n                .investments[users[_address].details.investments.length - 1];\\n\\n            if (_investment.endedTimestamp == 0) {\\n                _investment.endedTimestamp = block.timestamp;\\n            }\\n            return _amountToReturn;\\n        }\\n    }\\n\\n    function getContractBalance() public view returns (uint256) {\\n        return _usdtToken.balanceOf(address(this));\\n    }\\n\\n    function invest(\\n        address _sponsor,\\n        uint256 _investment,\\n        UserIncome userIncome,\\n        address _userAddress\\n    ) external {\\n        _investment = toWei(_investment);\\n        address senderInCase = msg.sender == CONST_SYSTEM_ADDRESS ||\\n            msg.sender == CONST_FEES_ADDRESS\\n            ? _userAddress\\n            : msg.sender;\\n        require(_sponsor != address(0), \\\"Invalid sponsor address\\\");\\n        require(\\n            _investment >= CONST_MIN_INVESTMENT,\\n            \\\"Invalid investment amount\\\"\\n        );\\n        require(senderInCase != _sponsor, \\\"Same sponsor and user address\\\");\\n\\n        if (userIncome != UserIncome.NN && msg.sender != CONST_SYSTEM_ADDRESS) {\\n            revert(\\\"Invalid User Income\\\");\\n        }\\n\\n        if (userIncome != UserIncome.NN && userExists(senderInCase)) {\\n            revert(\\\"Invalid Income for existing user\\\");\\n        }\\n\\n        if (userIncome == UserIncome.NN && msg.sender != CONST_FEES_ADDRESS) {\\n            require(\\n                _usdtToken.transferFrom(\\n                    senderInCase,\\n                    address(this),\\n                    (_investment)\\n                ),\\n                \\\"Transfer failed\\\"\\n            );\\n        }\\n\\n        bool isNewUser = !userExists(senderInCase);\\n        User storage _user = users[senderInCase];\\n\\n        if (isNewUser) {\\n            _user.addr = senderInCase;\\n            _user.details.sponsor = _sponsor;\\n            _user.details.registrationTimestamp = block.timestamp;\\n            _user.details.investments.push(\\n                UserInvestment({\\n                    id: _investmentIndex++,\\n                    amount: _investment,\\n                    timestamp: block.timestamp,\\n                    incomeType: userIncome,\\n                    endedTimestamp: 0\\n                })\\n            );\\n            _user.details.userIncome = userIncome;\\n\\n            if (userIncome == UserIncome.AP) {\\n                _user.details.pendingFromMaxLimit = _investment * 3000;\\n                _user.details.generationLevelsOpened = 30;\\n                _user.details.directLevelsOpened = 10;\\n            }\\n\\n            if (userIncome == UserIncome.NN) {\\n                address currentUpline = _sponsor;\\n\\n                for (\\n                    uint8 i = 0;\\n                    i < CONST_GENERATION_INCOME_PERCENTAGES.length;\\n                    i++\\n                ) {\\n                    User storage _currentUpline = users[currentUpline];\\n                    bool isCurrentlyInactive = _currentUpline\\n                        .details\\n                        .pendingFromMaxLimit == 0;\\n                    _currentUpline.usersAtEachLevel[i] += 1;\\n                    if (!isCurrentlyInactive) {\\n                        _currentUpline.details.levelBusiness += _investment;\\n                        _currentUpline.businessAtEachLevel[i] += _investment;\\n                    }\\n                    _currentUpline.usersAtEachLevelArray[i].push(senderInCase);\\n\\n                    // if it is under the first 10 levels, then give the direct income\\n                    uint8 _levelCondition = i == 0 ? 0 : i + 1; // add 1 because we are starting from 0\\n                    if (\\n                        userIncome == UserIncome.NN &&\\n                        i < 10 &&\\n                        _currentUpline.details.directLevelsOpened >=\\n                        _levelCondition\\n                    ) {\\n                        if (!isCurrentlyInactive) {\\n                            uint256 _directIncome = safeFromLimit(\\n                                currentUpline,\\n                                (_investment *\\n                                    CONST_DIRECT_INCOME_PERCENTAGES[i]) / 1000\\n                            );\\n                            _currentUpline\\n                                .details\\n                                .directIncome += _directIncome;\\n                            _currentUpline\\n                                .details\\n                                .totalDirectIncome += _directIncome;\\n                        }\\n                    }\\n\\n                    currentUpline = _currentUpline.details.sponsor;\\n                    if (currentUpline == address(0)) break;\\n                }\\n            }\\n        } else {\\n            if (\\n                _user.details.pendingFromMaxLimit == 0 &&\\n                _user\\n                    .details\\n                    .investments[_user.details.investments.length - 1]\\n                    .endedTimestamp ==\\n                0\\n            ) {\\n                _user\\n                    .details\\n                    .investments[_user.details.investments.length - 1]\\n                    .endedTimestamp = block.timestamp;\\n\\n                // _user.details.activeInvestmentAmount -= _user\\n                //     .details\\n                //     .investments[_user.details.investments.length - 1]\\n                //     .amount;\\n\\n                if (\\n                    _user.details.activeInvestmentAmount >=\\n                    _user\\n                        .details\\n                        .investments[_user.details.investments.length - 1]\\n                        .amount\\n                ) {\\n                    _user.details.activeInvestmentAmount -= _user\\n                        .details\\n                        .investments[_user.details.investments.length - 1]\\n                        .amount;\\n                }\\n            }\\n\\n            // add a new investment for the user\\n            _user.details.investments.push(\\n                UserInvestment({\\n                    id: _investmentIndex++,\\n                    amount: _investment,\\n                    timestamp: block.timestamp,\\n                    endedTimestamp: 0,\\n                    incomeType: UserIncome.NN\\n                })\\n            );\\n\\n            _user.details.userIncome = UserIncome.NN;\\n\\n            // since this is an existing user we will not increment the user count\\n            address currentUpline = _sponsor;\\n\\n            for (\\n                uint8 i = 0;\\n                i < CONST_GENERATION_INCOME_PERCENTAGES.length;\\n                i++\\n            ) {\\n                User storage _currentUpline = users[currentUpline];\\n                bool isCurrentlyInactive = _currentUpline\\n                    .details\\n                    .pendingFromMaxLimit == 0;\\n                if (!isCurrentlyInactive) {\\n                    _currentUpline.details.levelBusiness += _investment;\\n                    _currentUpline.businessAtEachLevel[i] += _investment;\\n                }\\n                uint8 _levelCondition = i == 0 ? 0 : i + 1;\\n\\n                if (\\n                    i < 10 &&\\n                    _currentUpline.details.directLevelsOpened >= _levelCondition\\n                ) {\\n                    if (!isCurrentlyInactive) {\\n                        uint256 _directIncome = safeFromLimit(\\n                            currentUpline,\\n                            (_investment * CONST_DIRECT_INCOME_PERCENTAGES[i]) /\\n                                1000\\n                        );\\n                        _currentUpline.details.directIncome += _directIncome;\\n                        _currentUpline\\n                            .details\\n                            .totalDirectIncome += _directIncome;\\n                    }\\n                }\\n\\n                currentUpline = _currentUpline.details.sponsor;\\n                if (currentUpline == address(0)) break;\\n            }\\n        }\\n\\n        // add the pending limit for the user\\n        if (userIncome != UserIncome.AP) {\\n            if (_user.details.userIncome == UserIncome.AP) {\\n                _user.details.pendingFromMaxLimit = 0;\\n            }\\n            if (_user.details.referrals.length > 0) {\\n                _user.details.pendingFromMaxLimit +=\\n                    (_investment * CONST_WORKING_LIMIT) /\\n                    1000;\\n            } else {\\n                _user.details.pendingFromMaxLimit +=\\n                    (_investment * CONST_NONWORKING_LIMIT) /\\n                    1000;\\n            }\\n        }\\n\\n        // update the global stat\\n        totalInvestments += _investment;\\n\\n        // update user investment amounts\\n        User storage _sponsorUser = users[_sponsor];\\n\\n        if (userIncome == UserIncome.NN) {\\n            _user.details.activeInvestmentAmount += _investment;\\n            _user.details.totalInvestmentTillDate += _investment;\\n            // increment the direct business of the sponsor & open levels\\n            if (_sponsorUser.details.pendingFromMaxLimit > 0) {\\n                _sponsorUser.details.directBusiness += _investment;\\n            }\\n        }\\n\\n        if (isNewUser) {\\n            _sponsorUser.details.referrals.push(senderInCase);\\n            if (\\n                _sponsorUser.details.directLevelsOpened <\\n                CONST_DIRECT_INCOME_PERCENTAGES.length\\n            ) {\\n                _sponsorUser\\n                    .details\\n                    .directLevelsOpened += CONST_DIRECT_LEVEL_OPENED_PER_REFERRAL;\\n            }\\n\\n            if (\\n                _sponsorUser.details.generationLevelsOpened <\\n                CONST_GENERATION_INCOME_PERCENTAGES.length\\n            ) {\\n                _sponsorUser\\n                    .details\\n                    .generationLevelsOpened += CONST_GENERATION_LEVEL_OPENED_PER_REFERRAL;\\n            }\\n\\n            if (_sponsorUser.details.referrals.length == 1) {\\n                // this is the first referral of the sponsor\\n                if (\\n                    _sponsorUser.details.userIncome == UserIncome.NN &&\\n                    _sponsorUser.details.pendingFromMaxLimit > 0\\n                ) {\\n                    UserInvestment memory _sponsorInvestment = _sponsorUser\\n                        .details\\n                        .investments[\\n                            _sponsorUser.details.investments.length - 1\\n                        ];\\n                    uint256 maxLimit = (_sponsorInvestment.amount *\\n                        CONST_NONWORKING_LIMIT) / 1000;\\n                    uint256 earnedLimit = maxLimit -\\n                        _sponsorUser.details.pendingFromMaxLimit;\\n                    uint256 newLimit = (_sponsorInvestment.amount *\\n                        CONST_WORKING_LIMIT) / 1000;\\n                    newLimit -= earnedLimit;\\n                    _sponsorUser.details.pendingFromMaxLimit = newLimit;\\n                }\\n            }\\n        }\\n\\n        uint256 _fees = (_investment * 10) / 100;\\n        if (userIncome == UserIncome.NN && getContractBalance() >= _fees) {\\n            _usdtToken.transfer(CONST_PROJECT_ADDRESS, _fees);\\n        }\\n\\n        distributeRewards(_sponsor);\\n\\n        if (isNewUser) {\\n            emit UserRegistered(\\n                senderInCase,\\n                _sponsor,\\n                _investment,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function getUserPendingLimit(address _addr) public view returns (uint256) {\\n        return users[_addr].details.pendingFromMaxLimit;\\n    }\\n\\n    function isUserActive(address _addr) public view returns (bool) {\\n        return getUserPendingLimit(_addr) != 0;\\n    }\\n\\n    function distributeRewards(address _user) private {\\n        User storage _currentUser = users[_user];\\n\\n        // if (_currentUser.details.pendingFromMaxLimit == 0) {\\n        //     return;\\n        // }\\n\\n        for (uint8 i = 0; i < CONST_REWARDS.length; i++) {\\n            uint256 rewardAmount = toWei(CONST_REWARDS[i]);\\n            bool hasAchievedReward = _currentUser.achievedRewards[i] > 0 &&\\n                _currentUser.achievedRewards[i] !=\\n                CONST_REWARD_FLUSHED_TIMESTAMP;\\n\\n            if (\\n                hasAchievedReward ||\\n                _currentUser.achievedRewards[i] ==\\n                CONST_REWARD_FLUSHED_TIMESTAMP\\n            ) {\\n                continue;\\n            }\\n\\n            uint256 _maxBusinessFromEachLeg = (30 * rewardAmount) / 100;\\n            uint256 _totalBusiness = 0;\\n            uint256 _totalPendingBusiness = 0;\\n\\n            for (uint8 j = 0; j < _currentUser.details.referrals.length; j++) {\\n                User storage _referral = users[\\n                    _currentUser.details.referrals[j]\\n                ];\\n                uint256 _referralBusiness = _referral.details.levelBusiness +\\n                    _referral.details.totalInvestmentTillDate;\\n\\n                if (_referralBusiness > _maxBusinessFromEachLeg) {\\n                    _totalBusiness += _maxBusinessFromEachLeg;\\n                    uint256 _pendingBusiness = _referralBusiness -\\n                        _maxBusinessFromEachLeg;\\n                    _totalPendingBusiness += _pendingBusiness > 0\\n                        ? _pendingBusiness\\n                        : 0;\\n                } else {\\n                    _totalBusiness += _referralBusiness;\\n                }\\n            }\\n\\n            uint256 _usedRewardCarryForwardAmount = 0;\\n\\n            if (_totalBusiness < rewardAmount) {\\n                _usedRewardCarryForwardAmount = rewardAmount - _totalBusiness;\\n\\n                if (\\n                    _currentUser.details.rewardCarryForwardAmount >=\\n                    _usedRewardCarryForwardAmount\\n                ) {\\n                    _currentUser\\n                        .details\\n                        .rewardCarryForwardAmount -= _usedRewardCarryForwardAmount;\\n                    _totalBusiness += _usedRewardCarryForwardAmount;\\n                }\\n            }\\n\\n            if (_totalBusiness >= rewardAmount) {\\n                if (_currentUser.details.pendingFromMaxLimit > 0) {\\n                    _currentUser.achievedRewards[i] = block.timestamp;\\n\\n                    _currentUser\\n                        .details\\n                        .rewardCarryForwardAmount += _totalPendingBusiness;\\n                    _usdtToken.transfer(\\n                        _currentUser.addr,\\n                        (rewardAmount * CONST_REWARD_PERCENTAGE) / 100\\n                    );\\n                } else {\\n                    _currentUser.achievedRewards[\\n                            i\\n                        ] = CONST_REWARD_FLUSHED_TIMESTAMP;\\n                    _currentUser\\n                        .details\\n                        .rewardCarryForwardAmount += _usedRewardCarryForwardAmount;\\n                }\\n            }\\n        }\\n    }\\n\\n    function userHasBeenRegisteredForLessThan24Hours(\\n        address _addr,\\n        uint256 _predefined\\n    ) public view returns (bool) {\\n        if (_predefined == 0) {\\n            return\\n                block.timestamp - getUserLatestInvestment(_addr).timestamp <\\n                86400;\\n        } else if (_predefined == 1) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function sendGenerationIncome(address _user, uint256 _amount) private {\\n        address currentUpline = users[_user].details.sponsor;\\n\\n        for (uint8 i = 0; i < CONST_GENERATION_INCOME_PERCENTAGES.length; i++) {\\n            uint8 _levelCondition = i == 0 ? 0 : i + 1;\\n            if (\\n                !(users[currentUpline].details.generationLevelsOpened >=\\n                    _levelCondition) ||\\n                users[currentUpline].details.pendingFromMaxLimit == 0 ||\\n                userHasBeenRegisteredForLessThan24Hours(currentUpline, 2)\\n            ) {\\n                currentUpline = users[currentUpline].details.sponsor;\\n                continue;\\n            }\\n\\n            uint256 _generationIncome = safeFromLimit(\\n                currentUpline,\\n                (_amount * CONST_GENERATION_INCOME_PERCENTAGES[i]) / 1000\\n            );\\n            users[currentUpline].details.generationIncome += _generationIncome;\\n            users[currentUpline]\\n                .details\\n                .totalGenerationIncome += _generationIncome;\\n\\n            currentUpline = users[currentUpline].details.sponsor;\\n            if (currentUpline == address(0)) break;\\n        }\\n    }\\n\\n    function withdraw() external {\\n        User storage _user = users[msg.sender];\\n\\n        require(_user.details.pendingFromMaxLimit != 0, \\\"User is inactive\\\");\\n        // check if the user has already withdrawn in last 24 hours\\n        require(\\n            block.timestamp - _user.details.lastWithdrawalTimestamp > 86400,\\n            \\\"Already withdrawn in last 24 hours\\\"\\n        );\\n\\n        uint256 _selfRoiIncome;\\n\\n        if (_user.details.userIncome == UserIncome.NN) {\\n            // we will calculate this based upon time\\n\\n            for (uint256 i = 0; i < _user.details.investments.length; i++) {\\n                UserInvestment storage _investment = _user.details.investments[\\n                    i\\n                ];\\n\\n                if (_investment.endedTimestamp != 0) {\\n                    continue;\\n                }\\n\\n                uint256 checkpoint = _user.details.lastWithdrawalTimestamp == 0\\n                    ? block.timestamp\\n                    : _user.details.lastWithdrawalTimestamp;\\n\\n                if (_investment.timestamp > checkpoint) {\\n                    checkpoint = block.timestamp;\\n                }\\n\\n                uint256 _seconds = (checkpoint - _investment.timestamp);\\n\\n                // _selfRoiIncome += toWei(block.timestamp);\\n\\n                // if (_seconds > 0) {\\n                uint256 _roi = ((_investment.amount *\\n                    _seconds *\\n                    CONST_ROI_PER_DAY) / 1000) / 86400;\\n                _selfRoiIncome += _roi;\\n\\n                // if it has been 365 days since the investment, it should be ended\\n\\n                if (\\n                    (checkpoint - _investment.timestamp > 365 * 86400 ||\\n                        _seconds > 365 * 86400 ||\\n                        _user.details.pendingFromMaxLimit == 0) &&\\n                    _investment.endedTimestamp == 0\\n                ) {\\n                    _investment.endedTimestamp = block.timestamp;\\n                    if (\\n                        _user.details.activeInvestmentAmount >=\\n                        _investment.amount\\n                    ) {\\n                        _user.details.activeInvestmentAmount -= _investment\\n                            .amount;\\n                    }\\n                }\\n            }\\n        }\\n\\n        _selfRoiIncome = safeFromLimit(msg.sender, _selfRoiIncome);\\n\\n        uint256 balance = _selfRoiIncome +\\n            _user.details.directIncome +\\n            _user.details.generationIncome;\\n\\n        require(\\n            balance >= CONST_MIN_WITHDRAWAL,\\n            \\\"Minimum withdrawal amount not reached\\\"\\n        );\\n\\n        sendGenerationIncome(msg.sender, _selfRoiIncome);\\n\\n        uint256 _fees = (balance * 6) / 100;\\n\\n        _usdtToken.transfer(CONST_MARKETING_ADDRESS, _fees);\\n\\n        _usdtToken.transfer(msg.sender, balance - _fees);\\n\\n        _user.details.lastWithdrawalTimestamp = block.timestamp;\\n\\n        _user.details.totalSelfRoiIncome += _selfRoiIncome;\\n\\n        _user.details.withdrawalAmounts.push(balance);\\n        _user.details.withdrawalTimestamps.push(block.timestamp);\\n\\n        _user.details.directIncome = 0;\\n        _user.details.generationIncome = 0;\\n        _user.details.totalWithdrawal += balance;\\n\\n        totalWithdrawal += balance;\\n\\n        emit WithdrawalHappened(msg.sender, balance, block.timestamp);\\n\\n        distributeRewards(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Tether.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address _owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() {}\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract BEP20USDT is Context, IBEP20, Ownable {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n    uint8 public _decimals;\\n    string public _symbol;\\n    string public _name;\\n\\n    constructor() {\\n        _name = \\\"Tether USD\\\";\\n        _symbol = \\\"USDT\\\";\\n        _decimals = 18;\\n        _totalSupply = 30000000000000000000000000;\\n        _balances[msg.sender] = _totalSupply;\\n\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n    }\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-totalSupply}.\\n     */\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-balanceOf}.\\n     */\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {BEP20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-allowance}.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {BEP20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {BEP20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"BEP20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {BEP20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {BEP20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"BEP20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\\n     * the total supply.\\n     *\\n     * Requirements\\n     *\\n     * - `msg.sender` must be the token owner\\n     */\\n    function mint(uint256 amount) public onlyOwner returns (bool) {\\n        _mint(_msgSender(), amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burn `amount` tokens and decreasing the total supply.\\n     */\\n    function burn(uint256 amount) public returns (bool) {\\n        _burn(_msgSender(), amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"BEP20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(\\n            amount,\\n            \\\"BEP20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(\\n                amount,\\n                \\\"BEP20: burn amount exceeds allowance\\\"\\n            )\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feesAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrawalHappened\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CONST_DIRECT_INCOME_PERCENTAGES\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_DIRECT_LEVEL_OPENED_PER_REFERRAL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_FEES_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CONST_GENERATION_INCOME_PERCENTAGES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_GENERATION_LEVEL_OPENED_PER_REFERRAL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_MARKETING_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_MIN_INVESTMENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_MIN_WITHDRAWAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_NONWORKING_LIMIT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_PROJECT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CONST_REWARDS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_REWARD_FLUSHED_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_REWARD_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_ROI_PER_DAY\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_SYSTEM_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONST_WORKING_LIMIT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserReferralCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_investmentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdtToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAllLevelsDownlineRoi\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getGenerationPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getSelfRoiPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserAchievedRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getUserAvailableGenerationIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getUserAvailableSelfRoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"directIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSelfRoiIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDirectIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGenerationIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRetopupTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawalTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalTimestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestmentTillDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeInvestmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingFromMaxLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"directLevelsOpened\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"generationLevelsOpened\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum DollarFortUpdated.UserIncome\",\"name\":\"incomeType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFortUpdated.UserInvestment[]\",\"name\":\"investments\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"enum DollarFortUpdated.UserIncome\",\"name\":\"userIncome\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFortUpdated.UserDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"getUserDownlineAtLevel\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum DollarFortUpdated.UserIncome\",\"name\":\"incomeType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFortUpdated.UserInvestment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserPendingLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserStructure\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"usersList\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"business\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"},{\"internalType\":\"enum DollarFortUpdated.UserIncome\",\"name\":\"userIncome\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isUserActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"toWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"userExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_predefined\",\"type\":\"uint256\"}],\"name\":\"userHasBeenRegisteredForLessThan24Hours\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"directIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSelfRoiIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDirectIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGenerationIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRetopupTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawalTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalTimestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestmentTillDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeInvestmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingFromMaxLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"directLevelsOpened\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"generationLevelsOpened\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"enum DollarFortUpdated.UserIncome\",\"name\":\"incomeType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFortUpdated.UserInvestment[]\",\"name\":\"investments\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"enum DollarFortUpdated.UserIncome\",\"name\":\"userIncome\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFortUpdated.UserDetails\",\"name\":\"details\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DollarFortUpdated", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000006b6b83cea7088734cfe8265ef90a48c956848d26000000000000000000000000ea9761466a71c320adc665e32ed244b2edbb9c29000000000000000000000000b7bbb37f42c4aa3afb680c04853a6127aedc55a3", "EVMVersion": "berlin", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}