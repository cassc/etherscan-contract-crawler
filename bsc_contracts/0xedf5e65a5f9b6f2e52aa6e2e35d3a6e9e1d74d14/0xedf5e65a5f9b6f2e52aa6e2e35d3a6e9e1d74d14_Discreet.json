{"SourceCode": "pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nlibrary Address {\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n\t\t// for accounts without code, i.e. `keccak256('')`\r\n\t\tbytes32 codehash;\r\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\tassembly { codehash := extcodehash(account) }\r\n\t\treturn (codehash != accountHash && codehash != 0x0);\r\n\t}\r\n\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n \r\n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\treturn _functionCallWithValue(target, data, value, errorMessage);\r\n\t}\r\n\r\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t// solhint-disable-next-line avoid-low-level-calls\r\n\t\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes memory) {\r\n\t\tthis; // silence state mutability warning without generating bytecode - issue 2691\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\taddress private _previousOwner;\r\n\taddress private _lockTime;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tconstructor () internal {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a, \"SafeMath: subtraction overflow\");\r\n\t\tuint256 c = a - b;\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n \r\n        return c;\r\n    }\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b > 0, \"SafeMath: division by zero\");\r\n\t\tuint256 c = a / b;\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n \r\n        return c;\r\n    }\r\n\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0, \"SafeMath: modulo by zero\");\r\n\t\tuint256 c = a % b;\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract Discreet is Context, IERC20, Ownable {\r\n\tusing SafeMath for uint256;\r\n\tusing Address for address;\r\n\r\n\tmapping (address => uint256) private _balances;\r\n\tmapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n\tmapping (address => bool) private _functionWhitelist;\r\n\tmapping (address => bool) private _transferWhitelist;\r\n\r\n\taddress public devlock;\r\n\tuint256 public _devlockdate;\r\n\t\r\n\tuint256 private _total = 90 * 10**6 * 10**18; // 90 million\r\n\r\n\tstring private _name = \"Discreet\";\r\n\tstring private _symbol = \"BDIS\";\r\n\tuint8 private _decimals = 18;\r\n\r\n\tuint256 public preseedTokenSupply = 20 * 10**6 * 10**18;\r\n\tuint256 public seedTokenSupply = 20 * 10**6 * 10**18;\r\n\tuint256 public publicTokenSupply = 30 * 10**6 * 10**18;\r\n\tuint256 public teamTokenSupply = 5 * 10**6 * 10**18;\r\n\tuint256 public projectTokenSupply = 10 * 10**6 * 10**18;\r\n\tuint256 public lockedTokenSupply = 5 * 10**6 * 10**18;\r\n\r\n\tbool public _seedTokensReleased = false;\r\n\tbool public _publicTokensReleased = false;\r\n\tbool public _lockedTokensReleased = false;\r\n\tbool public _preseedTokensReleased = false;\r\n\r\n\taddress public _preseedContract;\t// pressed round contract; facilitate purchases\r\n\taddress public _seedContract;\r\n\taddress public _publicContract;\t\t// public round contract\r\n\r\n\tuint256 public _maxTxAmount = 10**6 * 10**18;\r\n\r\n\tmodifier onlyWhitelist() {\r\n\t\trequire(_functionWhitelist[_msgSender()] == true, \"Address must be whitelisted to perform this\");\r\n\t\t_;\r\n\t}\r\n\r\n\tevent Airdrop(address indexed from, uint256 numReceived, uint256 numTokens);\r\n\r\n\tconstructor (address _DEVLOCK_, address _TEAM_) public {\r\n\t\trequire (teamTokenSupply.add(projectTokenSupply.add(lockedTokenSupply.add(preseedTokenSupply.add(seedTokenSupply.add(publicTokenSupply))))) == _total, \"Total tokens doesn't match!\");\r\n\t\t_balances[_DEVLOCK_] = lockedTokenSupply;\r\n\t\t_balances[_TEAM_] = teamTokenSupply.add(projectTokenSupply);\r\n\t\t_balances[address(this)] = preseedTokenSupply.add(seedTokenSupply.add(publicTokenSupply));\r\n\r\n\t\tdevlock = _DEVLOCK_;\r\n\t\t_transferWhitelist[_msgSender()] = true;\r\n\t\t_functionWhitelist[_msgSender()] = true;\r\n\r\n\t\temit Transfer(address(0), address(this), _balances[address(this)]);\r\n\t\temit Transfer(address(0), _DEVLOCK_, lockedTokenSupply);\r\n\t\temit Transfer(address(0), _TEAM_, teamTokenSupply.add(projectTokenSupply));\r\n\r\n\t\t_devlockdate = now + 267 days;\r\n\t}\r\n\r\n\tfunction seedTokensReleased() public view returns (bool) {\r\n\t\treturn _seedTokensReleased;\r\n\t}\r\n\r\n\tfunction publicTokensReleased() public view returns (bool) {\r\n\t\treturn _publicTokensReleased;\r\n\t}\r\n\r\n\tfunction lockedTokensReleased() public view returns (bool) {\r\n\t\treturn _lockedTokensReleased;\r\n\t}\r\n\r\n\tfunction preseedTokensReleased() public view returns (bool) {\r\n\t\treturn _preseedTokensReleased;\r\n\t}\r\n\r\n\tfunction getPreseedTokenSupply() public view returns (uint256) {\r\n\t\treturn preseedTokenSupply;\r\n\t}\r\n\r\n\tfunction getSeedTokenSupply() public view returns (uint256) {\r\n\t\treturn seedTokenSupply;\r\n\t}\r\n\r\n\tfunction getPublicTokenSupply() public view returns (uint256) {\r\n\t\treturn publicTokenSupply;\r\n\t}\r\n\r\n\tfunction name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n \r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n \r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n \r\n    function totalSupply() public view override returns (uint256) {\r\n        return _total;\r\n    }\r\n \r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n \r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n \r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n \r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n\tfunction _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n \r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\tfunction addTransferWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_transferWhitelist[addressToWhitelist] = true;\r\n\t}\r\n\r\n\tfunction removeTransferWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_transferWhitelist[addressToWhitelist] = false;\r\n\t}\r\n\r\n\tfunction isTransferWhitelisted(address addr) public view returns (bool) {\r\n\t\treturn _transferWhitelist[addr];\r\n\t}\r\n\r\n\tfunction addFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = true;\r\n\t}\r\n\r\n\tfunction removeFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = false;\r\n\t}\r\n\r\n\tfunction isFunctionWhitelisted(address addr) public view returns (bool) {\r\n\t\treturn _functionWhitelist[addr];\r\n\t}\r\n \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if(from != owner() && to != owner() && from != address(this) && !_transferWhitelist[from])\r\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n \r\n        if(from == devlock) \r\n            require(now >= _devlockdate && _lockedTokensReleased, \"This wallet has not been unlocked.\");\r\n        \r\n\t      _balances[from] = _balances[from].sub(amount);\r\n\t      _balances[to] = _balances[to].add(amount);\r\n \r\n\t      emit Transfer(from, to, amount);\r\n    }\r\n \r\n    function launchPreseed(address preseedContract) public onlyOwner() {\r\n\t\trequire(_preseedTokensReleased == false, \"Preseed already launched\");\r\n\t\t_preseedContract = preseedContract;\r\n\t\t_preseedTokensReleased = true;\r\n\t\t_transferWhitelist[preseedContract] = true;\r\n\t\t_transfer(address(this), _preseedContract, preseedTokenSupply);\r\n\t}\r\n\r\n\tfunction launchSeed(address seedContract) public onlyOwner() {\r\n\t\trequire(_seedTokensReleased == false, \"Seed already launched\");\r\n\t\t_seedContract = seedContract;\r\n\t\t_seedTokensReleased = true;\r\n\t\t_transferWhitelist[seedContract] = true;\r\n\t\t_transfer(address(this), _seedContract, seedTokenSupply);\r\n\t}\r\n\r\n\tfunction launchPublic(address publicContract) public onlyOwner() {\r\n\t\trequire(_publicTokensReleased == false, \"Public already launched\");\r\n\t\t_publicContract = publicContract;\r\n\t\t_publicTokensReleased = true;\r\n\t\t_transferWhitelist[publicContract] = true;\r\n\t\t_transfer(address(this), _publicContract, publicTokenSupply);\r\n\t}\r\n\r\n\tfunction airdropTokens(address[] memory addresses, uint256 tokenLimit) public onlyWhitelist() {\r\n\t\trequire(_balances[_msgSender()] >= tokenLimit, \"not enough allocated tokens for airdrop\");\r\n\t\tuint256 accumulator;\r\n\t\tfor (uint256 i = 0; i < addresses.length; i++) {\r\n\t\t\taccumulator = accumulator.add(_balances[addresses[i]]);\r\n\t\t}\r\n\r\n\t\tuint256 tokensLeft = tokenLimit;\r\n\t\tfor (uint256 i = 0; i < addresses.length; i++) {\r\n\t\t\tuint256 rcvamt = _balances[addresses[i]].mul(tokenLimit).div(accumulator);\r\n\t\t\tif (rcvamt > tokensLeft) {\r\n\t\t\t\trcvamt = tokensLeft;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (rcvamt == 0) continue;\r\n\r\n\t\t\ttransfer(addresses[i], rcvamt);\r\n\t\t\ttokensLeft = tokensLeft.sub(rcvamt);\r\n\t\t}\r\n\r\n\t\temit Airdrop(_msgSender(), addresses.length, tokenLimit.sub(tokensLeft));\r\n\t}\r\n\r\n\tfunction addToPublic(uint256 numTokens) public onlyWhitelist() {\r\n\t\trequire(_balances[_msgSender()] >= numTokens, \"insufficient balance\");\r\n\t\trequire(_publicTokensReleased == false, \"public round has not began\");\r\n\r\n\t\ttransfer(address(this), numTokens);\r\n\t\tpublicTokenSupply = publicTokenSupply.add(numTokens);\r\n\t}\r\n\r\n\tfunction drainTokens() public onlyOwner() {\r\n\t\t// to prevent any possible issues with token locks\r\n\t\tif (_balances[address(this)] > 0) {\r\n\t\t\ttransfer(address(this), _balances[address(this)]);\r\n\t\t}\r\n\t\t// just in case there are tokens in this contract\r\n\t\tif (address(this).balance > 0) {\r\n\t\t\tpayable(owner()).transfer(address(this).balance);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\ncontract DiscreetPreseed is Context, Ownable {\r\n\tusing SafeMath for uint256;\r\n\tusing Address for address;\r\n\tmapping (address => uint256) private _purchases;\r\n\tmapping (address => bool) private _functionWhitelist;\r\n\r\n\tuint256 public totalPreseedTokensToSell = 0;\r\n\tDiscreet _Discreet;\r\n\r\n\tuint256 private _preseedRate;\r\n\tuint256 public _minTokenBuy = 5 * 10**16;\r\n\tuint256 public _maxTokenBuy = 100 * 10**18;\r\n\r\n\tuint256 public preseedStartDate = 0;\r\n\tuint256 public preseedEndDate = 0;\r\n\tbool public preseedLaunched = false;\r\n\r\n\tbool public _replicateState = false;\r\n\r\n\tevent TokenSaleBuy(address indexed buyer, uint256 amount);\r\n\r\n\tmodifier onlyWhitelist() {\r\n\t\trequire(_functionWhitelist[_msgSender()] == true, \"Address must be whitelisted to perform this\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (address _discreet) public {\r\n\t\t_Discreet = Discreet(_discreet);\r\n\t\ttotalPreseedTokensToSell = _Discreet.getPreseedTokenSupply();\r\n\t\t_functionWhitelist[_msgSender()] = true;\r\n\t}\r\n\r\n\tfunction addFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = true;\r\n\t}\r\n\r\n\tfunction removeFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = false;\r\n\t}\r\n\r\n\tfunction isFunctionWhitelisted(address addr) public view returns (bool) {\r\n\t\treturn _functionWhitelist[addr];\r\n\t}\r\n\r\n\tfunction initReplicateState() public onlyOwner() {\r\n\t\t_replicateState = true;\r\n\t}\r\n\r\n\tfunction endReplicateState() public onlyOwner() {\r\n\t\t_replicateState = false;\r\n\t}\r\n\r\n\tfunction batchReplicateState(address[] memory to, uint256[] memory amount) public onlyWhitelist() {\r\n\t\trequire(preseedLaunched == false, \"Cannot replicate state after preseed launch\");\r\n\t\trequire(_replicateState == true, \"Cannot replicate state without init\");\r\n\t\trequire (to.length == amount.length, \"array length mismatch\");\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < to.length; i++) {\r\n\t\t\trequire(_Discreet.balanceOf(to[i]) == 0, \"State for this address has been replicated\"); \r\n\t\t\t_Discreet.transfer(to[i], amount[i]);\r\n\t\t\ttotalPreseedTokensToSell = totalPreseedTokensToSell.sub(amount[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction beginPreseed(uint256 numDays, uint256 _rate) public onlyOwner() {\r\n\t\trequire(preseedLaunched == false, \"Preseed already began\");\r\n\t\trequire(_replicateState == false, \"Still replicating state\");\r\n\t\tpreseedStartDate = now;\r\n\t\tpreseedEndDate = now + numDays * 1 days;\r\n\t\t_preseedRate = _rate;\r\n\t\tpreseedLaunched = true;\r\n\t}\r\n\r\n\tfunction extendPreseed(uint256 numDays) public onlyWhitelist() {\r\n\t\tpreseedEndDate += numDays * 1 days;\r\n\t}\r\n\r\n\tfunction changePreseedRate(uint256 _rate) public onlyWhitelist() {\r\n\t\t_preseedRate = _rate;\r\n\t}\r\n\r\n\tfunction preseedRate() public view returns (uint256) {\r\n\t\treturn _preseedRate;\r\n\t}\r\n\r\n\tfunction minTokenBuy() public view returns (uint256) {\r\n\t\treturn _minTokenBuy;\r\n\t}\r\n\r\n\tfunction maxTokenBuy() public view returns (uint256) {\r\n\t\treturn _maxTokenBuy;\r\n\t}\r\n\r\n\tfunction changeMinTokenBuy(uint256 newMin) public onlyWhitelist() {\r\n\t\t_minTokenBuy = newMin;\r\n\t}\r\n\r\n\tfunction changeMaxTokenBuy(uint256 newMax) public onlyWhitelist() {\r\n\t\t_maxTokenBuy = newMax;\r\n\t}\r\n\r\n\tfunction tokenSaleBuy() public payable {\r\n\t\trequire(now >= preseedStartDate);\r\n\t\trequire(now < preseedEndDate);\r\n\t\trequire(msg.value >= _minTokenBuy, \"TokenSaleBuy: Value must be at least minimum amount\");\r\n\t\trequire(msg.value <= _maxTokenBuy, \"TokenSaleBuy: Value must be no more than maximum amount\");\r\n\t\trequire(_purchases[_msgSender()] <= _maxTokenBuy, \"TokenSaleBuy: Value and total purchased thus far exceeds maximum\");\r\n\t\t\r\n\t\tuint256 tokensToGive = _preseedRate * msg.value;\r\n\t\tuint256 _val = msg.value;\r\n\r\n\t\tif (_purchases[_msgSender()] + msg.value > _maxTokenBuy) {\r\n\t\t\t_val = _maxTokenBuy - _purchases[_msgSender()];\r\n\t\t\t_msgSender().transfer(msg.value.sub(_val));\r\n\t\t\ttokensToGive = _preseedRate * _val;\r\n\t\t}\r\n\r\n\t\tbool isSoldOut = false;\r\n\r\n\t\tif (tokensToGive > totalPreseedTokensToSell) {\r\n\t\t\t_val = totalPreseedTokensToSell.sub(totalPreseedTokensToSell % _preseedRate).div(_preseedRate);\r\n\t\t\t_msgSender().transfer(msg.value.sub(_val));\r\n\t\t\ttokensToGive = totalPreseedTokensToSell;\r\n\t\t\tisSoldOut = true;\r\n\t\t}\r\n\r\n\t\t_Discreet.transfer(_msgSender(), tokensToGive);\r\n\t\temit TokenSaleBuy(_msgSender(), tokensToGive);\r\n\r\n\t\ttotalPreseedTokensToSell = totalPreseedTokensToSell.sub(tokensToGive);\r\n\r\n\t\tpayable(owner()).transfer(_val);\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t\ttokenSaleBuy();\r\n\t}\r\n\r\n\tfunction drainTokens() public onlyOwner() {\r\n\t\tif (_Discreet.balanceOf(address(this)) > 0) {\r\n\t\t\t_Discreet.transfer(_msgSender(), _Discreet.balanceOf(address(this)));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction endPreseed() public onlyOwner() {\r\n\t\trequire(preseedLaunched == true, \"Preseed hasn't been launched yet\");\r\n\t\trequire(now > preseedEndDate, \"Preseed hasn't reached end date\");\r\n\t\tdrainTokens(); // return tokens to owner\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DEVLOCK_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_TEAM_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_devlockdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lockedTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_preseedContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_preseedTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_publicContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_publicTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_seedContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_seedTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToWhitelist\",\"type\":\"address\"}],\"name\":\"addFunctionWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"addToPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToWhitelist\",\"type\":\"address\"}],\"name\":\"addTransferWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenLimit\",\"type\":\"uint256\"}],\"name\":\"airdropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devlock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drainTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPreseedTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSeedTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isFunctionWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isTransferWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"preseedContract\",\"type\":\"address\"}],\"name\":\"launchPreseed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"publicContract\",\"type\":\"address\"}],\"name\":\"launchPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seedContract\",\"type\":\"address\"}],\"name\":\"launchSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preseedTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preseedTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToWhitelist\",\"type\":\"address\"}],\"name\":\"removeFunctionWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToWhitelist\",\"type\":\"address\"}],\"name\":\"removeTransferWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedTokensReleased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Discreet", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b297431839fa3d9d8162084b9791a9cfd160f4bd000000000000000000000000927d2bdca8e61434d3241801e64d699dc69f6667", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1777543a93bc512e5ff6ad5835d8b51b2f9aff0ba42ec755becc89ef1b090dab"}