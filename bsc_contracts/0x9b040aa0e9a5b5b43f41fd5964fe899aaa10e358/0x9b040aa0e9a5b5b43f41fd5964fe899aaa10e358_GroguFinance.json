{"SourceCode": "// SPDX-License-Identifier: Creative Commons Attribution License 4.0\r\n\r\n/**\r\n * RE-DEPLOYMENT TO CONFORM WITH COINSCOPE.CO'S AUDIT RECOMMENDATIONS, 20/09/21* \r\n * https://testnet.bscscan.com/address/0xb03a20FcDE3eFA632E8A2d970b41A42DCC769461#code\r\n *\r\n * Attribution license because this \"highly secure\" token can be easily modified to\r\n * do exceptionally evil things, such as capture and divert individual address' balances.\r\n *\r\n * Only complile with solc >=0.8.0, mathmatics now rely on the compiler's built in overflow checks.\r\n * Overflows now revert automatically: https://docs.soliditylang.org/en/v0.8.6/080-breaking-changes.html\r\n * If using these as invidividual files, use a static solc (ie not ^0.8.0), newer the better.\r\n *\r\n * ADMIRE's core team is welcoming, positive and inclusive: If you clone our token or\r\n * code, do drop in on social media and say \"hello\"! Regardless, best of luck!\r\n * \r\n * BYTECODE SIZE AND GAS ISSUES: Strings are <=32 bytes. TODO: Try and better explain \r\n * require/reverts in comments. Coinscope.co caught a dozen extraneous lines, cheers\r\n * to them! REMOVED: Unrolled all loops and removed all arrays -- the EVM is resource constrained,\r\n * gas requirements go up an order of magnitude parsing lists/arrays. GraphQL them.\r\n * Do not add gas to the listing modifiers. These are straight storage lookups, not arrays.\r\n * There is no theoretical limit to storage lookups, but there is a limit to array parsing.\r\n * Thus the modifiers should never require more gas. This is a feature, not a flaw.\r\n *\r\n * Solidity is odd: multiple smaller functions costs require more bytecode, but\r\n * use less gas. Peoples' money is involved, pay more to deploy for every TX\r\n * using less funds.\r\n *\r\n * uint256 uses less gas than uint8. Odd. So be it.\r\n * \r\n * Inlining internal functions takes bytecode but is supposed to save gas over public,\r\n * which are read into memory and passed to the function. MultiSig functions need to be\r\n * public, not much can be done...\r\n */\r\n\r\npragma solidity 0.8.7;\r\n// pragma experimental ABIEncoderV2; // placeholder: enabled by default ^0.8.0\r\n\r\n// AND PDX-License-Identifier: MIT\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. \r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * Modified from: https://soliditydeveloper.com/extcodehash\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        // Coinscope.co audit suggested moving this to a declaration to save bytecode, which\r\n        // isn't possible as this library is pulled into all our contracts (and flattened here \r\n        // for audit readability). It'd have to be a struct and re-declared in the library.\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\n\r\ncontract OwnableMultiSig is Context {\r\n    using Address for address;\r\n    address public _owner;\r\n    address public _multisig;\r\n    address public _operator;\r\n\r\n    // @dev Inherited logic:\r\n    // @dev Initializes the contract with MultiSig _mint_wrappers_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _change_operator_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _rate_change_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _blacklist_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _antiwhale_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _owner_privileges_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _approve__addresses_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _nocontracts_stopped state control off.\r\n    // @dev Initializes the contract with MultiSig _multisig_stopped state.\r\n\r\n    constructor() {\r\n        // Explicitly and safely declare our own msgSender variable. Upgrading to solc 0.8.6 \r\n        // caused odd issues with _msgSender(), not sure why, don't care, just declare:\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        _multisig = msgSender;\r\n        _operator = msgSender;\r\n        // emit notices on deployment for clarity's sake reading the TX\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n        emit MultiSigTransferred(address(0), msgSender);\r\n        emit OperatorTransferred(address(0), msgSender);\r\n        _mint_wrappers_stopped = false;\r\n        _change_operator_stopped = false;\r\n        _rate_change_stopped = false;\r\n        _blacklist_stopped = false;\r\n        _antiwhale_stopped = false;\r\n        _owner_privileges_stopped = false;\r\n        _approve_spendable_address_stopped = false;\r\n        _nocontracts_stopped = false;\r\n        _multisig_stopped = false;\r\n    }\r\n\r\n    // @dev **************** Ownership Events   ***********************\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event MultiSigTransferred(\r\n        address indexed previousMultiSig,\r\n        address indexed newMultiSig\r\n    );\r\n    event OperatorTransferred(\r\n        address indexed previousOperator,\r\n        address indexed newOperator\r\n    );\r\n\r\n    // @dev ____________________Functions__________________________\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current operator.\r\n     */\r\n    function operator() public view virtual returns (address) {\r\n        return _operator;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function multisig() public view virtual returns (address) {\r\n        return _multisig;\r\n    }\r\n\r\n    // @dev ____________________Modifiers__________________________\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     * Gas: mind the byte count on require messages.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(\r\n            owner() == _msgSender(), \r\n            \"Ownable::not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOperator() {\r\n        require(\r\n            operator() == _msgSender(),\r\n            \"Ownable::caller is not operator\"\r\n        );\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyMultiSig() {\r\n        require(\r\n            multisig() == _msgSender(),\r\n            \"Ownable::caller is not multisig\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev ____________________Renunciations__________________________\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership()\r\n        public\r\n        virtual\r\n        onlyOwner\r\n        whenOwnerPrivilegesOn\r\n    {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    // @dev __________________Transfer Functions________________________\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     * Gas: mind the byte count on require messages.\r\n     * NOTE: owner, operator and multisig all start as deployer, so all functions are\r\n     * available and must be explicitly transfered away to secure this token.\r\n     */\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        virtual\r\n        onlyOwner\r\n        whenOwnerPrivilegesOn\r\n    {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is 0 address\"\r\n        );\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function transferOperator(address newOperator)\r\n        public\r\n        virtual\r\n        onlyOperator\r\n        whenChangeByOperatorOn\r\n    {\r\n        require(\r\n            newOperator != address(0),\r\n            \"Ownable:new operator is 0 address\"\r\n        );\r\n        _setOperator(newOperator);\r\n    }\r\n\r\n    function transferMultiSig(address newMultiSig)\r\n        public\r\n        virtual\r\n        onlyOperator\r\n        whenMultiSigOn\r\n    {\r\n        require(\r\n            newMultiSig != address(0),\r\n            \"Ownable:new multisig is 0 address\"\r\n        );\r\n        _setMultiSig(newMultiSig);\r\n    }\r\n\r\n    // @dev __________________Transfer Address Functions________________________\r\n    // fixes coinscope.co reduntant code\r\n    function _setOwner(address newOwner) private {\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n\r\n    }\r\n\r\n    function _setOperator(address newOperator) private {\r\n        emit OwnershipTransferred(_operator, newOperator);\r\n        _operator = newOperator;\r\n\r\n    }\r\n\r\n    function _setMultiSig(address newMultiSig) private {\r\n        emit MultiSigTransferred(_multisig, newMultiSig);\r\n        _multisig = newMultiSig;\r\n\r\n    }\r\n\r\n    // @dev **************** Lock the Mint_Wrappers   ***********************\r\n    // @dev Emitted when Minting is paused by Operator.\r\n    event Mint_Wrappers_Stopped(address account);\r\n\r\n    // @dev Emitted when the Minting is allowed by Operator.\r\n    event Started_Mint_Wrappers(address account);\r\n\r\n    bool internal _mint_wrappers_stopped;\r\n\r\n    // @dev Returns true if the contract is _mint_wrappers_stopped, and false otherwise.\r\n    function mint_wrappers_stopped() public view returns (bool) {\r\n        return _mint_wrappers_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _mint_wrappers_stopped.\r\n    modifier whenMintWrappersOn() {\r\n        require(!_mint_wrappers_stopped, \"MultiSig::Mint Allowed\");\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _mint_wrappers_stopped.\r\n    modifier whenMintWrappersOff() {\r\n        require(\r\n            _mint_wrappers_stopped,\r\n            \"Multisig::Declined _mint_wrappers\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function mint:\r\n    // function mint(address _to, uint256 _amount) public onlyOwner whenMintWrappersOn {\r\n    function _stop_mint_wrappers() internal virtual whenMintWrappersOn {\r\n        _mint_wrappers_stopped = true;\r\n        emit Mint_Wrappers_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_mint_wrappers() internal virtual whenMintWrappersOff {\r\n        _mint_wrappers_stopped = false;\r\n        emit Started_Mint_Wrappers(_msgSender());\r\n    }\r\n\r\n    // @dev **************** Lock the Operator   ***********************\r\n    // @dev Emitted when Changing The Operator is paused by Operator.\r\n    event Change_Operator_Stopped(address account);\r\n\r\n    // @dev Emitted when the Changing The Operator is allowed by Operator.\r\n    event Started_Change_Operator(address account);\r\n\r\n    bool private _change_operator_stopped;\r\n\r\n    // @dev Returns true if the contract is _change_operator_stopped, and false otherwise.\r\n    function change_operator_stopped() public view returns (bool) {\r\n        return _change_operator_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _change_operator_stopped.\r\n    modifier whenChangeByOperatorOn() {\r\n        require(\r\n            !_change_operator_stopped,\r\n            \"MultiSig::Changes by Operator On\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _change_operator_stopped.\r\n    modifier whenChangeByOperatorOff() {\r\n        require(\r\n            _change_operator_stopped,\r\n            \"Multisig::Changes by Operator Off\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function D3_transferOperator:\r\n    // function D3_transferOperator(address newOperator) public onlyOwner whenChangeByOperatorOn {\r\n    function _stop_change_operator() internal virtual whenChangeByOperatorOn {\r\n        _change_operator_stopped = true;\r\n        emit Change_Operator_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_change_operator() internal virtual whenChangeByOperatorOff {\r\n        _change_operator_stopped = false;\r\n        emit Started_Change_Operator(_msgSender());\r\n    }\r\n\r\n    // @dev **************** Lock the Rates   ***********************\r\n    // @dev Emitted when RateChanging is paused by Operator.\r\n    event Rate_Change_Stopped(address account);\r\n\r\n    // @dev Emitted when the RateChanging is allowed by Operator.\r\n    event Started_Rate_Change(address account);\r\n\r\n    bool private _rate_change_stopped;\r\n\r\n    // @dev Returns true if the contract is _rate_change_stopped, and false otherwise.\r\n    function rate_change_stopped() public view returns (bool) {\r\n        return _rate_change_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _rate_change_stopped.\r\n    modifier whenRateChangeOn() {\r\n        require(!_rate_change_stopped, \"MultiSig::RateChanges On\");\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _rate_change_stopped.\r\n    modifier whenRateChangeOff() {\r\n        require(\r\n            _rate_change_stopped,\r\n            \"Multisig::RateChange Perm Off\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function updateRate:\r\n    //function updateRate(uint16 _charityRate) public onlypOwner whenRateChangeOn {\r\n    function _stop_rate_change() internal virtual whenRateChangeOn {\r\n        _rate_change_stopped = true;\r\n        emit Rate_Change_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_rate_change() internal virtual whenRateChangeOff {\r\n        _rate_change_stopped = false;\r\n        emit Started_Rate_Change(_msgSender());\r\n    }\r\n\r\n    // @dev **************** Lock the Blacklist   ***********************\r\n    // @dev Emitted when Minting is paused by Operator.\r\n    event Blacklist_Stopped(address account);\r\n\r\n    // @dev Emitted when the Minting is allowed by Operator.\r\n    event Started_Blacklist(address account);\r\n\r\n    bool private _blacklist_stopped;\r\n\r\n    // @dev Returns true if the contract is _blacklist_stopped, and false otherwise.\r\n    function blacklist_stopped() public view returns (bool) {\r\n        return _blacklist_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _blacklist_stopped.\r\n    modifier whenBlacklistOn() {\r\n        require(!_blacklist_stopped, \"MultiSig::Mint To Allowed\");\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _blacklist_stopped.\r\n    modifier whenBlacklistOff() {\r\n        require(\r\n            _blacklist_stopped,\r\n            \"Multisig::Mint To Denied\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function blacklistUpdate:\r\n    // function blacklistUpdate(address user, bool value) public virtual onlyOwner whenBlacklistOn {\r\n    function _stop_blacklist() internal virtual whenBlacklistOn {\r\n        _blacklist_stopped = true;\r\n        emit Blacklist_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_blacklist() internal virtual whenBlacklistOff {\r\n        _blacklist_stopped = false;\r\n        emit Started_Blacklist(_msgSender());\r\n    }\r\n\r\n    // @dev **************** Lock the AntiWhale   ***********************\r\n    // @dev Emitted when Minting is paused by Operator.\r\n    event AntiWhale_Stopped(address account);\r\n\r\n    // @dev Emitted when the Minting is allowed by Operator.\r\n    event Started_AntiWhale(address account);\r\n\r\n    bool private _antiwhale_stopped;\r\n\r\n    // @dev Returns true if the contract is _antiwhale_stopped, and false otherwise.\r\n    function antiwhale_stopped() public view returns (bool) {\r\n        return _antiwhale_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _antiwhale_stopped.\r\n    modifier whenAntiWhaleOn() {\r\n        require(!_antiwhale_stopped, \"MultiSig::AntiWhale On\");\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _antiwhale_stopped.\r\n    modifier whenAntiWhaleOff() {\r\n        require(\r\n            _antiwhale_stopped,\r\n            \"Multisig::AntiWhale Off\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function antiwhaleUpdate:\r\n    // function G5_setExcludedFromAntiWhale(address _account, bool _excluded) public onlyOwner whenAntiWhaleOn {\r\n    function _stop_antiwhale() internal virtual whenAntiWhaleOn {\r\n        _antiwhale_stopped = true;\r\n        emit AntiWhale_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_antiwhale() internal virtual whenAntiWhaleOff {\r\n        _antiwhale_stopped = false;\r\n        emit Started_AntiWhale(_msgSender());\r\n    }\r\n\r\n    /* @dev **************** Lock the OwnerPrivileges_To   ***********************\r\n     * This breaks almost everything, only for serious emergencies!\r\n     */\r\n    // @dev Emitted when OwnerPrivileges is paused by Operator.\r\n    event OwnerPrivileges_Stopped(address account);\r\n\r\n    // @dev Emitted when the OwnerPrivileges is allowed by Operator.\r\n    event Started_OwnerPrivileges(address account);\r\n\r\n    bool private _owner_privileges_stopped;\r\n\r\n    // @dev Returns true if the contract is _owner_privileges_stopped, and false otherwise.\r\n    function owner_privileges_stopped() public view returns (bool) {\r\n        return _owner_privileges_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _owner_privileges_stopped.\r\n    modifier whenOwnerPrivilegesOn() {\r\n        require(\r\n            !_owner_privileges_stopped,\r\n            \"MultiSig::OwnerPrivileges Allowed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _owner_privileges_stopped.\r\n    modifier whenOwnerPrivilegesOff() {\r\n        require(\r\n            _owner_privileges_stopped,\r\n            \"MultiSig::OwnerPrivileges Revoked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function mintUpdate:\r\n    // function mint(uint256 amount) public onlyOwner  whenOwnerPrivilegesOff returns (bool) {\r\n    function _stop_owner_privileges() internal virtual whenOwnerPrivilegesOn {\r\n        _owner_privileges_stopped = true;\r\n        emit OwnerPrivileges_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_owner_privileges() internal virtual whenOwnerPrivilegesOff {\r\n        _owner_privileges_stopped = false;\r\n        emit Started_OwnerPrivileges(_msgSender());\r\n    }\r\n\r\n    // @dev **************** Locking Approving Access by address can BREAKS THINGS   ***********************\r\n    // @dev Emitted when ApproveSpendableAddress is paused by Operator.\r\n    event Approve_Spendable_Address_Stopped(address account);\r\n\r\n    // @dev Emitted when the ApproveSpendableAddress is allowed by Operator.\r\n    event Started_Approve_Spendable_Address(address account);\r\n\r\n    bool private _approve_spendable_address_stopped;\r\n\r\n    // @dev Returns true if the contract is _approve_spendable_address_stopped, and false otherwise.\r\n    function approve_spendable_address_stopped() public view returns (bool) {\r\n        return _approve_spendable_address_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _approve_spendable_address_stopped.\r\n    modifier whenApproveSpendableAddressOn() {\r\n        require(\r\n            !_approve_spendable_address_stopped,\r\n            \"ApproveSpendableAddress Allowed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _approve_spendable_address_stopped.\r\n    modifier whenApproveSpendableAddressOff() {\r\n        require(\r\n            _approve_spendable_address_stopped,\r\n            \"ApproveSpendableAddress Denied\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function whenApproveSpendableAddressOn\r\n    function _stop_approve_spendable_address()\r\n        internal\r\n        virtual\r\n        whenApproveSpendableAddressOn\r\n    {\r\n        _approve_spendable_address_stopped = true;\r\n        emit Approve_Spendable_Address_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_approve_spendable_address()\r\n        internal\r\n        virtual\r\n        whenApproveSpendableAddressOff\r\n    {\r\n        _approve_spendable_address_stopped = false;\r\n        emit Started_Approve_Spendable_Address(_msgSender());\r\n    }\r\n\r\n    /* @dev ************ Locking Out Access by Contracts BREAKS THINGS   ********************\r\n     * First whitelist all contracts that interact with GROGU, turn this on.\r\n     */\r\n\r\n    // @dev Emitted when Changing Contract Interaction is paused by Operator.\r\n    event NoContracts_Stopped(address account);\r\n\r\n    // @dev Emitted when the Changing Contract Interaction is allowed by Operator.\r\n    event Started_NoContracts(address account);\r\n\r\n    bool internal _nocontracts_stopped;\r\n\r\n    // @dev Returns true if the contract is _nocontracts_stopped, and false otherwise.\r\n    function nocontracts_stopped() public view returns (bool) {\r\n        return _nocontracts_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _nocontracts_stopped.\r\n    modifier whenNoContractsOn() {\r\n        require(!_nocontracts_stopped, \"MultiSig::NoContracts Allow\");\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _nocontracts_stopped.\r\n    modifier whenNoContractsOff() {\r\n        require(\r\n            _nocontracts_stopped,\r\n            \"Multisig::NoContracts Revoked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function E5_updateCharityRate:\r\n    function _stop_nocontracts() internal virtual whenNoContractsOn {\r\n        _nocontracts_stopped = true;\r\n        emit NoContracts_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_nocontracts() internal virtual whenNoContractsOff {\r\n        _nocontracts_stopped = false;\r\n         emit Started_NoContracts(_msgSender());\r\n    }\r\n\r\n    // @dev ************** Operator Hands Off MultiSig Controls  *********************\r\n\r\n    // @dev Emitted when MultiSiging is paused by Operator.\r\n    event MultiSig_Stopped(address account);\r\n\r\n    // @dev Emitted when the MultiSiging is allowed by Operator.\r\n    event Started_MultiSig(address account);\r\n\r\n    bool private _multisig_stopped;\r\n\r\n    // @dev Returns true if the contract is _multisig_stopped, and false otherwise.\r\n    function multisig_stopped() public view returns (bool) {\r\n        return _multisig_stopped;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is not _multisig_stopped.\r\n    modifier whenMultiSigOn() {\r\n        require(!_multisig_stopped, \"MultiSig::MultiSig Allowed\");\r\n        _;\r\n    }\r\n\r\n    // @dev Modifier to make a function callable only when the contract is _multisig_stopped.\r\n    modifier whenMultiSigOff() {\r\n        require(\r\n            _multisig_stopped,\r\n            \"MultiSig::Permission Revoked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // @dev Triggers stopped state. Call in function mintUpdate:\r\n    function _stop_multisig() internal virtual whenMultiSigOn {\r\n        _multisig_stopped = true;\r\n        emit MultiSig_Stopped(_msgSender());\r\n    }\r\n\r\n    // @dev Returns to normal state.\r\n    function _start_multisig() internal virtual whenMultiSigOff {\r\n        _multisig_stopped = false;\r\n        emit Started_MultiSig(_msgSender());\r\n    }\r\n    \r\n    // @dev A1 and A2 are in Pausable.sol, which is still separate\r\n\r\n    // @dev Here begins the Public MultiSig Controls\r\n    function B1_MintWrappers_EnableProtection()\r\n        public\r\n        onlyOperator\r\n        whenMintWrappersOn\r\n    {\r\n        _stop_mint_wrappers();\r\n    }\r\n\r\n    function B2_MintWrappers_DisableProtection()\r\n        public\r\n        onlyOperator\r\n        whenMintWrappersOff\r\n    {\r\n        _start_mint_wrappers();\r\n    }\r\n\r\n    function C1_OwnerPrivileges_Revoke()\r\n        public\r\n        onlyOperator\r\n        whenOwnerPrivilegesOn\r\n    {\r\n        _stop_owner_privileges();\r\n    }\r\n\r\n    function C2_OwnerPrivileges_Allow()\r\n        public\r\n        onlyMultiSig\r\n        whenOwnerPrivilegesOff\r\n    {\r\n        _start_owner_privileges();\r\n    }\r\n\r\n    function D1_Revoke_Changes_By_The_Operator()\r\n        public\r\n        onlyMultiSig\r\n        whenChangeByOperatorOn\r\n    {\r\n        _stop_change_operator();\r\n    }\r\n\r\n    function D2_Allow_Changes_By_The_Operator()\r\n        public\r\n        onlyMultiSig\r\n        whenChangeByOperatorOff\r\n    {\r\n        _start_change_operator();\r\n    }\r\n\r\n    function E1_Revoke_Changing_Rates() \r\n        public \r\n        onlyMultiSig \r\n        whenRateChangeOn \r\n    {\r\n        _stop_rate_change();\r\n    }\r\n\r\n    function E2_Allow_Changing_Rates() \r\n        public \r\n        onlyMultiSig \r\n        whenRateChangeOff \r\n    {\r\n        _start_rate_change();\r\n    }\r\n\r\n    /* @dev E5_updateCharityRate, E6_updateMaxTransferAmountRate, \r\n     * E7_updateTransferTaxRate, E7_updateMinAmountToLiquify\r\n     * remain in main contract\r\n     */\r\n\r\n    function F1_BlacklistingAddresses_TurnOff()\r\n        public\r\n        onlyMultiSig\r\n        whenBlacklistOn\r\n    {\r\n        _stop_blacklist();\r\n    }\r\n\r\n    function F2_BlacklistingAdresses_TurnOn()\r\n        public\r\n        onlyMultiSig\r\n        whenBlacklistOff\r\n    {\r\n        _start_blacklist();\r\n    }\r\n\r\n    // @dev F3_blacklistUpdate, F4_isBlacklisted in main contract\r\n\r\n    function G1_Revoke_AntiWhale() public onlyMultiSig whenAntiWhaleOn {\r\n        _stop_antiwhale();\r\n    }\r\n\r\n    function G2_Allow_AntiWhale() public onlyMultiSig whenAntiWhaleOff {\r\n        _start_antiwhale();\r\n    }\r\n\r\n    // @dev G3_setExcludedFromAntiWhale, G4_isExcludedFromAntiWhale in main contract\r\n    // @dev WARNING! This will absolutely break things! Whitelist every known contract first!\r\n    function H1_ContractWrapperProtection_TurnOn()\r\n        public\r\n        onlyOperator\r\n        whenNoContractsOn\r\n    {\r\n        _stop_nocontracts();\r\n    }\r\n\r\n    function H2_ContractWrapperProtection_TurnOff()\r\n        public\r\n        onlyOperator\r\n        whenNoContractsOff\r\n    {\r\n        _start_nocontracts();\r\n    }\r\n\r\n    // @dev WARNING! Things will break! The devs need to be able to increase allowances.\r\n    function I1_OperatorCanAddSpendableAddresses_TurnOff()\r\n        public\r\n        onlyMultiSig\r\n        whenApproveSpendableAddressOn\r\n    {\r\n        _stop_approve_spendable_address();\r\n    }\r\n\r\n    function I2_OperatorCanAddSpendableAddresses_TurnOn()\r\n        public\r\n        onlyMultiSig\r\n        whenApproveSpendableAddressOff\r\n    {\r\n        _start_approve_spendable_address();\r\n    }\r\n\r\n    // @dev I3_contractwhitelistUpdate, I4_minterRoleUpdate\r\n\r\n    function J1_MultiSig_Enable() public onlyMultiSig whenMultiSigOn {\r\n        _stop_multisig();\r\n    }\r\n\r\n    function J2_MultiSig_TurnOff() public onlyMultiSig whenMultiSigOff {\r\n        _start_multisig();\r\n    }\r\n\r\n    // @dev K1_withdrawTokensSentHere in main contract\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n\r\n// @dev This is munged together from:\r\n// File: @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\r\n// File: @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\n\r\ncontract Pausable is Context, OwnableMultiSig {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n\r\n    // @dev begins MultiSig enforcement\r\n    function A1_PauseTheChain_Pause() public onlyOperator whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    function A2_PauseTheChain_Unpause() public onlyOperator whenPaused {\r\n        _unpause();\r\n    }\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\ncontract BEP20 is Context, IBEP20, OwnableMultiSig, Pausable {\r\n    using Address for address;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        whenNotPaused\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        whenNotPaused\r\n        whenApproveSpendableAddressOn\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {BEP20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) \r\n        public \r\n        virtual \r\n        override \r\n        whenNotPaused\r\n        returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n            uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n            require(currentAllowance >= amount, \"amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        whenNotPaused\r\n        whenApproveSpendableAddressOn\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        whenNotPaused\r\n        whenApproveSpendableAddressOn\r\n        returns (bool)\r\n    {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"decreased below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\r\n     * the total supply.\r\n     * JUST GET RID OF THIS, REDUNDANT WITH _mint AND TOO MUCH FUD/DRAMA\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `msg.sender` must be the token owner\r\n     */\r\n    // function mint(uint256 amount)\r\n    //     public\r\n    //     onlyOwner\r\n    //     whenOwnerPrivilegesOn\r\n    //     returns (bool)\r\n    // {\r\n    //     _mint(_msgSender(), amount);\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * This is virtual and overriden with multisig checks in main contract\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"transfer from the 0 address\");\r\n        require(recipient != address(0), \"transfer to the 0 address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"transfer amount exceeds bal\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * WARNING! Grogu MUST USE solc ^0.8.0 and the built-in overflow protection, otherwise\r\n     * SafeMath.sol must be re-introduced. https://soliditydeveloper.com/solidity-0.8\r\n     * That documentation isn't clear on this, but calling unchecked reverts to the old way\r\n     * requiring SafeMath wrapping: https://blog.soliditylang.org/2020/10/28/solidity-0.8.x-preview/\r\n     * notes: \"The main change for 0.8.x is the switch to checked arithmetic operations by default. \r\n     * This means that x + y will throw an exception on overflow. In other words: You will not need \r\n     * SafeMath anymore!\"\r\n     * \r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"mint to zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(owner != address(0), \"approve from the 0 address\");\r\n        require(spender != address(0), \"approve to the 0 address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n}\r\n\r\n// AND PDX-License-Identifier: MIT\r\n\r\n// @dev For consistency, decimals are hard-coded to 18 in BEP20PausablemultiSig.sol\r\ncontract GroguFinance is BEP20(\"Grogu.Finance\", \"BabyYoda\") {\r\n    using Address for address;\r\n\r\n    // Transfer tax rate in basis points. (default 5% which would be 500)\r\n    uint16 public transferTaxRate = 0;\r\n    // Charity rate % of transfer tax. (default 20% which is 20 below x 5% = 1% of total amount).\r\n    uint16 public charityRate = 0;\r\n    // Max transfer tax rate: 10% which is 1000 below\r\n    uint16 public constant MAXIMUM_TRANSFER_TAX_RATE = 1000;\r\n    // Charity address\r\n    address public CHARITY_ADDRESS = 0x5d484FbAa477D3bB73D94D89F17E6F5858B85dc0;\r\n    // Tax Address\r\n    address public TAX_ADDRESS = 0x73cb224189F6b33aB841B946EcE553c07EBdF1A0;\r\n    // address public TREASURY_ADDRESS = 0xB32a4f632BCA850bCe8609b8894857D6f1BAd578;\r\n\r\n    // Max transfer amount rate in basis points. (default is 0.5% of total supply, which is 50 below)\r\n    uint16 public maxTransferAmountRate = 50;\r\n    // Addresses that excluded from antiWhale\r\n    mapping(address => bool) public _excludedFromAntiWhale;\r\n    // Address that are blacklisted\r\n    mapping(address => bool) public _blacklist;\r\n    // Contract address that are whitelisted\r\n    mapping(address => bool) public _contractwhitelist;\r\n    // Address that have the Minter Role\r\n    mapping(address => bool) public _minter_role_address;\r\n    // Automatic swap and liquify enabled\r\n    bool public swapAndLiquifyEnabled = false;\r\n    // Min amount to liquify. (default 500 GROGUs)\r\n    uint256 public minAmountToLiquify = 500 ether;\r\n    // The swap router, modifiable. Will be changed to Grogu's router when our own AMM release\r\n    IUniswapV2Router02 public groguSwapRouter;\r\n    // The trading pair\r\n    address public groguSwapPair;\r\n    // In swap and liquify\r\n    bool private _inSwapAndLiquify;\r\n\r\n    // Events\r\n    event ContractAddressTransferred(\r\n        address indexed previosContractAddress,\r\n        address indexed newContractAddress\r\n    );\r\n    event CharityAddressTransferred(\r\n        address indexed previosCharityAddress,\r\n        address indexed newCharityAddress\r\n    );\r\n    event TaxAddressTransferred(\r\n        address indexed previosTaxAddress,\r\n        address indexed newTaxAddress\r\n    );\r\n    event TransferTaxRateUpdated(\r\n        address indexed _operator, \r\n        uint256 previousRate, \r\n        uint256 newRate\r\n    );\r\n    event CharityRateUpdated(\r\n        address indexed _operator, \r\n        uint256 previousRate, \r\n        uint256 newRate\r\n    );\r\n    event MaxTransferAmountRateUpdated(\r\n        address indexed _operator, \r\n        uint256 previousRate, \r\n        uint256 newRate\r\n    );\r\n    event SwapAndLiquifyEnabledUpdated(\r\n        address indexed _operator, \r\n        bool enabled\r\n    );\r\n    event MinAmountToLiquifyUpdated(\r\n        address indexed _operator, \r\n        uint256 previousAmount, \r\n        uint256 newAmount\r\n    );\r\n    event GroguRouterUpdated(\r\n        address indexed _operator, \r\n        address indexed router, \r\n        address indexed pair\r\n    );\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped, \r\n        uint256 ethReceived, \r\n        uint256 tokensIntoLiqudity\r\n    );\r\n    event BlacklistUpdated(\r\n        address indexed _operator, \r\n        bool value\r\n    );\r\n    event ContractWhitelistUpdated(\r\n        address indexed _operator, \r\n        bool value\r\n    );\r\n    event MinterRoleUpdated(\r\n        address indexed _operator, \r\n        bool value\r\n    );\r\n    event ExcludedFromAntiWhale(\r\n        address indexed _operator, \r\n        bool value\r\n    );\r\n    event WithdrawTokensSentHere(\r\n        address token, \r\n        address _operator, \r\n        uint256 amount\r\n    );\r\n\r\n    modifier antiWhale(address sender, address recipient, uint256 amount) {\r\n        if (maxTransferAmount() > 0) {\r\n            if (\r\n                _excludedFromAntiWhale[sender] == false &&\r\n                _excludedFromAntiWhale[recipient] == false\r\n            ) {\r\n                require(\r\n                    amount <= maxTransferAmount(),\r\n                    \"antiWhale::exceeds maxTXAmount\"\r\n                );\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier blacklisted(address sender, address recipient) {\r\n        if (_blacklist[sender] == true || _blacklist[recipient] == true) {\r\n            // @dev WARNING! If this is doing anything other than revert, it's an evil contract\r\n            // @dev should be similar to: revert(\"GROGU::blacklisted: Transfer declined\");\r\n            revert(\"GROGU::blacklisted addr\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier NoContractsOn(address sender, address recipient) {\r\n        if (_nocontracts_stopped == true) {\r\n            if (\r\n                (sender.isContract() && _contractwhitelist[sender] == false) \r\n                  ||\r\n                (recipient.isContract() && _contractwhitelist[recipient] == false)\r\n            ) {\r\n                revert(\r\n                    \"MultiSig::non-whitelist contract\"\r\n                );\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier MintWrappersOn(address recipient) {\r\n        if (_mint_wrappers_stopped == true) {\r\n            if (\r\n                (_minter_role_address[recipient] == false || _minter_role_address[msg.sender] == false) \r\n                  ||\r\n                (recipient.isContract() && _contractwhitelist[recipient] == false)\r\n            ) {\r\n                revert(\r\n                    \"MultiSig::Minting declined\"\r\n                );\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier lockTheSwap {\r\n        _inSwapAndLiquify = true;\r\n        _;\r\n        _inSwapAndLiquify = false;\r\n    }\r\n\r\n    modifier transferTaxFree {\r\n        uint16 _transferTaxRate = transferTaxRate;\r\n        transferTaxRate = 0;\r\n        _;\r\n        transferTaxRate = _transferTaxRate;\r\n    }\r\n\r\n    constructor() {\r\n        emit CharityAddressTransferred(address(0), CHARITY_ADDRESS);\r\n        emit TaxAddressTransferred(address(0), TAX_ADDRESS);\r\n        _excludedFromAntiWhale[msg.sender] = true;\r\n        _excludedFromAntiWhale[address(0)] = true;\r\n        _excludedFromAntiWhale[address(this)] = true;\r\n        _excludedFromAntiWhale[CHARITY_ADDRESS] = true;\r\n        _excludedFromAntiWhale[TAX_ADDRESS] = true;\r\n        _contractwhitelist[address(this)] = true;\r\n        _minter_role_address[msg.sender] = true;\r\n        _minter_role_address[address(this)] = true;\r\n    }\r\n\r\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\r\n    function mint(address recipient, uint256 _amount)\r\n        public\r\n        whenNotPaused\r\n        onlyOperator\r\n        MintWrappersOn(recipient)\r\n    {\r\n        // require(_minter_role_address[user] == false, \"Blacklisted\");\r\n        _mint(recipient, _amount);\r\n        _moveDelegates(address(0), _delegates[recipient], _amount);\r\n    }\r\n\r\n    // @dev begins MultiSig enforcement\r\n    // The A functions are in PausableMultiSig.sol, only here as a placeholder \r\n    // A1_PauseTheChain_Pause() public onlyOperator whenNotPaused {\r\n    // A2_PauseTheChain_Unpause() public onlyOperator whenPaused {\r\n\r\n    // function B1_MintWrappers_EnableProtection() public onlyOperator whenMintWrappersOn\r\n    // function B2_MintWrappers_DisableProtection() public onlyOperator whenMintWrappersOff\r\n\r\n    // @dev Disables the owner from interacting with enabled functions\r\n    // function C1_OwnerPrivileges_Revoke() public onlyOperator whenOwnerPrivilegesOn\r\n    // function C2_OwnerPrivileges_Allow() public  onlyMultiSig  whenOwnerPrivilegesOff\r\n\r\n    // function D1_Revoke_Changes_By_The_Operator() public onlyMultiSig whenChangeByOperatorOn\r\n    // function D2_Allow_Changes_By_The_Operator() public onlyMultiSig whenChangeByOperatorOff\r\n\r\n    // function E1_Revoke_Changing_Rates() public onlyMultiSig whenRateChangeOn {\r\n    // function E2_Allow_Changing_Rates() public onlyMultiSig whenRateChangeOff {\r\n    //     _start_rate_change();\r\n    // }\r\n\r\n    /**\r\n     * @dev Change the charity address, two levels of control:\r\n     * 1) Only the operator can change the address and only when:\r\n     * 2) The multisig authorizer has set whenRateChangeOn to true.\r\n     * Comment out this function if you want CHARITY_ADDRESS to be static\r\n     */\r\n    function E3_transferCharitytAddress(address newCharityAddress)\r\n        public\r\n        virtual\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        require(\r\n            newCharityAddress != address(0),\r\n            \"transferCharityAddr:not to 0 addr\"\r\n        );\r\n        emit CharityAddressTransferred(CHARITY_ADDRESS, newCharityAddress);\r\n        CHARITY_ADDRESS = newCharityAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the charity address, only allowed when multisig auth to change tax rate is true\r\n     * Comment out this function if you want CHARITY_ADDRESS to be static\r\n     */\r\n    function E4_transferTaxAddress(address newTaxAddress)\r\n        public\r\n        virtual\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        require(\r\n            newTaxAddress != address(0),\r\n            \"transferTaxAddr:not to 0 address\"\r\n        );\r\n        emit TaxAddressTransferred(TAX_ADDRESS, newTaxAddress);\r\n        TAX_ADDRESS = newTaxAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the charity rate.\r\n     * Can only be called by the current operator.\r\n     */\r\n    function E5_updateCharityRate(uint16 _charityRate)\r\n        public\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        require(\r\n            _charityRate <= 10000,\r\n            \"CharityRate: must > max rate.\"\r\n        );\r\n        emit CharityRateUpdated(msg.sender, charityRate, _charityRate);\r\n        charityRate = _charityRate;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the max transfer amount rate.\r\n     * Can only be called by the current operator.\r\n     */\r\n    function E6_updateMaxTransferAmountRate(uint16 _maxTransferAmountRate)\r\n        public\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        require(\r\n            _maxTransferAmountRate <= 10000,\r\n            \"MaxTransferRate: Max < max rate.\"\r\n        );\r\n        emit MaxTransferAmountRateUpdated(\r\n            msg.sender,\r\n            maxTransferAmountRate,\r\n            _maxTransferAmountRate\r\n        );\r\n        maxTransferAmountRate = _maxTransferAmountRate;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the transfer tax rate.\r\n     * Can only be called by the current operator.\r\n     */\r\n    function E7_updateTransferTaxRate(uint16 _transferTaxRate)\r\n        public\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        require(\r\n            _transferTaxRate <= MAXIMUM_TRANSFER_TAX_RATE,\r\n            \"TransferTaxRate: !< max rate.\"\r\n        );\r\n        emit TransferTaxRateUpdated(\r\n            msg.sender,\r\n            transferTaxRate,\r\n            _transferTaxRate\r\n        );\r\n        transferTaxRate = _transferTaxRate;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the min amount to liquify.\r\n     * Can only be called by the current operator.\r\n     */\r\n    function E7_updateMinAmountToLiquify(uint256 _minAmount)\r\n        public\r\n        onlyOperator\r\n    {\r\n        emit MinAmountToLiquifyUpdated(\r\n            msg.sender,\r\n            minAmountToLiquify,\r\n            _minAmount\r\n        );\r\n        minAmountToLiquify = _minAmount;\r\n    }\r\n\r\n    // @dev function F1_BlacklistingAddresses_TurnOff()\r\n    // @dev function F2_BlacklistingAdresses_TurnOn()\r\n\r\n\r\n    function F3_blacklistUpdate(address user, bool value)\r\n        public\r\n        virtual\r\n        onlyOperator\r\n        whenBlacklistOn\r\n    {\r\n        // require(user == _msgSender(), \"Only owner is allowed to modify blacklist.\");\r\n        _blacklist[user] = value;\r\n        emit BlacklistUpdated(user, value);\r\n    }\r\n\r\n   function F4_isBlacklisted(address _account) public view returns (bool) {\r\n        return _blacklist[_account];\r\n    }\r\n    // function G1_Revoke_AntiWhale() public onlyMultiSig whenAntiWhaleOn {\r\n    // function G2_Allow_AntiWhale() public onlyMultiSig whenAntiWhaleOff {\r\n\r\n\r\n    function G3_setExcludedFromAntiWhale(address _account, bool _excluded)\r\n        public\r\n        onlyOperator\r\n        whenAntiWhaleOn\r\n    {\r\n        _excludedFromAntiWhale[_account] = _excluded;\r\n        emit ExcludedFromAntiWhale(_account, _excluded);\r\n    }\r\n\r\n    function G4_isExcludedFromAntiWhale(address _account) public view returns (bool) {\r\n        return _excludedFromAntiWhale[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev G1_Revoke_AntiWhale, G2_Allow_AntiWhale, H1_ContractWrapperProtection_TurnOn,\r\n     * H2_ContractWrapperProtection_TurnOff, I1_OperatorCanAddSpendableAddresses_TurnOff\r\n     * I2_OperatorCanAddSpendableAddresses_TurnOn In OwnableMultiSig.sol\r\n     */\r\n\r\n    function I3_contractwhitelistUpdate(address _account, bool _excluded)\r\n        public\r\n        onlyOperator\r\n        whenApproveSpendableAddressOn\r\n    {\r\n        _contractwhitelist[_account] = _excluded;\r\n        emit ContractWhitelistUpdated(_account, _excluded);\r\n    }\r\n\r\n    function I4_minterRoleUpdate(address _account, bool _excluded)\r\n        public\r\n        onlyOperator\r\n        whenApproveSpendableAddressOn\r\n    {\r\n        _minter_role_address[_account] = _excluded;\r\n        emit MinterRoleUpdated(_account, _excluded);\r\n    }\r\n\r\n    // @ dev J1_MultiSig_Enable, J2_MultiSig_TurnOff in OwnableMultiSig.sol\r\n\r\n    // @dev owner can drain tokens that are sent here by mistake\r\n    function K1_withdrawTokensSentHere(BEP20 token, uint256 amount)\r\n        public\r\n        onlyOperator\r\n    {\r\n        emit WithdrawTokensSentHere(address(token), operator(), amount);\r\n        token.transfer(owner(), amount);\r\n    }\r\n\r\n    // @dev overrides transfer function to meet tokenomics of GROGU\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        blacklisted(sender, recipient)\r\n        antiWhale(sender, recipient, amount)\r\n        NoContractsOn(sender, recipient)\r\n    {\r\n        // swap and liquify\r\n        if (\r\n            swapAndLiquifyEnabled == true &&\r\n            _inSwapAndLiquify == false &&\r\n            address(groguSwapRouter) != address(0) &&\r\n            groguSwapPair != address(0) &&\r\n            sender != groguSwapPair &&\r\n            sender != owner()\r\n        ) {\r\n            swapAndLiquify();\r\n        }\r\n        //} else if (recipient == CHARITY_ADDRESS || transferTaxRate == 0) {\r\n        if (charityRate > 0 && transferTaxRate == 0) {\r\n            uint256 charityAmount = amount*(charityRate)/(10000);\r\n            uint256 sendAmount = amount-(charityAmount);\r\n            super._transfer(sender, CHARITY_ADDRESS, charityAmount);\r\n            super._transfer(sender, recipient, sendAmount);\r\n            amount = sendAmount;\r\n        } else if (charityRate == 0 || transferTaxRate == 0) {\r\n            super._transfer(sender, recipient, amount);\r\n        } else {\r\n            // default tax is 0% of every transfer\r\n            uint256 taxAmount = amount*(transferTaxRate)/(10000);\r\n            uint256 charityAmount = taxAmount*(charityRate)/(10000);\r\n            uint256 liquidityAmount = taxAmount-(charityAmount);\r\n            require(\r\n                taxAmount == charityAmount + liquidityAmount,\r\n                \"transfer: Charity val invalid\"\r\n            );\r\n\r\n            // default 95% of transfer sent to recipient\r\n            uint256 sendAmount = amount-(taxAmount);\r\n            require(\r\n                amount == sendAmount + taxAmount,\r\n                \"transfer: Tax val invalid\"\r\n            );\r\n\r\n            super._transfer(sender, CHARITY_ADDRESS, charityAmount);\r\n            //super._transfer(sender, address(this), liquidityAmount);\r\n            super._transfer(sender, TAX_ADDRESS, liquidityAmount);\r\n            super._transfer(sender, recipient, sendAmount);\r\n            amount = sendAmount;\r\n        }\r\n    }\r\n\r\n    /// @dev Swap and liquify\r\n    function swapAndLiquify() private lockTheSwap transferTaxFree {\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        uint256 _maxTransferAmount = maxTransferAmount();\r\n        contractTokenBalance = contractTokenBalance > _maxTransferAmount\r\n            ? _maxTransferAmount\r\n            : contractTokenBalance;\r\n\r\n        if (contractTokenBalance >= minAmountToLiquify) {\r\n            // only min amount to liquify\r\n            uint256 liquifyAmount = minAmountToLiquify;\r\n\r\n            // split the liquify amount into halves\r\n            uint256 half = liquifyAmount/(2);\r\n            uint256 otherHalf = liquifyAmount-(half);\r\n\r\n            // capture the contract's current ETH balance.\r\n            // this is so that we can capture exactly the amount of ETH that the\r\n            // swap creates, and not make the liquidity event include any ETH that\r\n            // has been manually sent to the contract\r\n            uint256 initialBalance = address(this).balance;\r\n\r\n            // swap tokens for ETH\r\n            swapTokensForEth(half);\r\n\r\n            // how much ETH did we just swap into?\r\n            uint256 newBalance = address(this).balance-(initialBalance);\r\n\r\n            // add liquidity\r\n            addLiquidity(otherHalf, newBalance);\r\n\r\n            emit SwapAndLiquify(half, newBalance, otherHalf);\r\n        }\r\n    }\r\n\r\n    /// @dev Swap tokens for eth\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        // generate the groguSwap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = groguSwapRouter.WETH();\r\n\r\n        _approve(address(this), address(groguSwapRouter), tokenAmount);\r\n\r\n        // make the swap\r\n        groguSwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /// @dev Add liquidity\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(groguSwapRouter), tokenAmount);\r\n\r\n        // add the liquidity\r\n        groguSwapRouter.addLiquidityETH{value: ethAmount} (\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            operator(),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n     /**\r\n     * @dev Returns the max transfer amount.\r\n     */\r\n    function maxTransferAmount() public view returns (uint256) {\r\n        return totalSupply()*(maxTransferAmountRate)/(10000);\r\n    }\r\n\r\n    // To receive BNB from groguSwapRouter when swapping\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Update the swapAndLiquifyEnabled.\r\n     * Can only be called by the current operator.\r\n     */\r\n    function updateSwapAndLiquifyEnabled(bool _enabled)\r\n        public\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        emit SwapAndLiquifyEnabledUpdated(msg.sender, _enabled);\r\n        swapAndLiquifyEnabled = _enabled;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the swap router.\r\n     * Can only be called by the current operator.\r\n     */\r\n    function updateGroguRouter(address _router)\r\n        public\r\n        onlyOperator\r\n        whenRateChangeOn\r\n    {\r\n        groguSwapRouter = IUniswapV2Router02(_router);\r\n        groguSwapPair = IUniswapV2Factory(groguSwapRouter.factory()).getPair(\r\n            address(this),\r\n            groguSwapRouter.WETH()\r\n        );\r\n        require(\r\n            groguSwapPair != address(0),\r\n            \"Router: Invalid pair address.\"\r\n        );\r\n        emit GroguRouterUpdated(\r\n            msg.sender,\r\n            address(groguSwapRouter),\r\n            groguSwapPair\r\n        );\r\n    }\r\n\r\n    // Copied and modified from YAM code:\r\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\r\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\r\n    // Which is copied and modified from COMPOUND:\r\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\r\n\r\n    /// @dev A record of each accounts delegate\r\n    mapping(address => address) internal _delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping(address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH =\r\n        keccak256(\r\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\r\n        );\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH =\r\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(\r\n        address indexed delegator,\r\n        address indexed fromDelegate,\r\n        address indexed toDelegate\r\n    );\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(\r\n        address indexed delegate,\r\n        uint256 previousBalance,\r\n        uint256 newBalance\r\n    );\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegator The address to get delegatee for\r\n     */\r\n    function delegates(address delegator) external view returns (address) {\r\n        return _delegates[delegator];\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint256) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return\r\n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint256 blockNumber)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            blockNumber < block.number,\r\n            \"getPriorVotes:not yet determined\"\r\n        );\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying GROGUs (not scaled);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(\r\n        address srcRep,\r\n        address dstRep,\r\n        uint256 amount\r\n    ) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                // decrease old representative\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0\r\n                    ? checkpoints[srcRep][srcRepNum - 1].votes\r\n                    : 0;\r\n                uint256 srcRepNew = srcRepOld-(amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                // increase new representative\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0\r\n                    ? checkpoints[dstRep][dstRepNum - 1].votes\r\n                    : 0;\r\n                uint256 dstRepNew = dstRepOld+(amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address delegatee,\r\n        uint32 nCheckpoints,\r\n        uint256 oldVotes,\r\n        uint256 newVotes\r\n    ) internal {\r\n        uint32 blockNumber = safe32(\r\n            block.number,\r\n            \"_writeCheckpoint: num > 32 bits\"\r\n        );\r\n\r\n        if (\r\n            nCheckpoints > 0 &&\r\n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\r\n        ) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(\r\n                blockNumber,\r\n                newVotes\r\n            );\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint256 n, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function getChainId() internal view returns (uint256) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AntiWhale_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Approve_Spendable_Address_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"BlacklistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Blacklist_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Change_Operator_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previosCharityAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCharityAddress\",\"type\":\"address\"}],\"name\":\"CharityAddressTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"CharityRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previosContractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"}],\"name\":\"ContractAddressTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"ContractWhitelistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"ExcludedFromAntiWhale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"GroguRouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"MaxTransferAmountRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"MinAmountToLiquifyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Mint_Wrappers_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"MinterRoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousMultiSig\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"MultiSigTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MultiSig_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContracts_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerPrivileges_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Rate_Change_Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_AntiWhale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_Approve_Spendable_Address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_Blacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_Change_Operator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_Mint_Wrappers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_MultiSig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_NoContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_OwnerPrivileges\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started_Rate_Change\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previosTaxAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTaxAddress\",\"type\":\"address\"}],\"name\":\"TaxAddressTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"TransferTaxRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokensSentHere\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"A1_PauseTheChain_Pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"A2_PauseTheChain_Unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"B1_MintWrappers_EnableProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"B2_MintWrappers_DisableProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"C1_OwnerPrivileges_Revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"C2_OwnerPrivileges_Allow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHARITY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"D1_Revoke_Changes_By_The_Operator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"D2_Allow_Changes_By_The_Operator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"E1_Revoke_Changing_Rates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"E2_Allow_Changing_Rates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCharityAddress\",\"type\":\"address\"}],\"name\":\"E3_transferCharitytAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTaxAddress\",\"type\":\"address\"}],\"name\":\"E4_transferTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_charityRate\",\"type\":\"uint16\"}],\"name\":\"E5_updateCharityRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_maxTransferAmountRate\",\"type\":\"uint16\"}],\"name\":\"E6_updateMaxTransferAmountRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"name\":\"E7_updateMinAmountToLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_transferTaxRate\",\"type\":\"uint16\"}],\"name\":\"E7_updateTransferTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"F1_BlacklistingAddresses_TurnOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"F2_BlacklistingAdresses_TurnOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"F3_blacklistUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"F4_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"G1_Revoke_AntiWhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"G2_Allow_AntiWhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excluded\",\"type\":\"bool\"}],\"name\":\"G3_setExcludedFromAntiWhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"G4_isExcludedFromAntiWhale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"H1_ContractWrapperProtection_TurnOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"H2_ContractWrapperProtection_TurnOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"I1_OperatorCanAddSpendableAddresses_TurnOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"I2_OperatorCanAddSpendableAddresses_TurnOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excluded\",\"type\":\"bool\"}],\"name\":\"I3_contractwhitelistUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excluded\",\"type\":\"bool\"}],\"name\":\"I4_minterRoleUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"J1_MultiSig_Enable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"J2_MultiSig_TurnOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BEP20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"K1_withdrawTokensSentHere\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_TRANSFER_TAX_RATE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TAX_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractwhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_excludedFromAntiWhale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_minter_role_address\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiwhale_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approve_spendable_address_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklist_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"change_operator_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"groguSwapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"groguSwapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferAmountRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountToLiquify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint_wrappers_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nocontracts_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner_privileges_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate_change_stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"transferMultiSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTaxRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"updateGroguRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GroguFinance", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1111", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f697e41110f35b48be7ad991e02954e87211d6d912c27dfcff6c2439ceb04372"}