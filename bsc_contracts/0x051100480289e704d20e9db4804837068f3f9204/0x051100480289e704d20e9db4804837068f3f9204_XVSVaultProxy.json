{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/XVSVault/XVSVault.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Utils/ECDSA.sol\\\";\\nimport \\\"../Utils/SafeBEP20.sol\\\";\\nimport \\\"../Utils/IBEP20.sol\\\";\\nimport \\\"./XVSVaultProxy.sol\\\";\\nimport \\\"./XVSVaultStorage.sol\\\";\\nimport \\\"./XVSVaultErrorReporter.sol\\\";\\n\\ninterface IXVSStore {\\n    function safeRewardTransfer(address _token, address _to, uint256 _amount) external;\\n    function setRewardToken(address _tokenAddress, bool status) external;\\n}\\n\\ncontract XVSVault is XVSVaultStorage, ECDSA {\\n    using SafeMath for uint256;\\n    using SafeBEP20 for IBEP20;\\n\\n    /// @notice Event emitted when deposit\\n    event Deposit(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\\n\\n    /// @notice Event emitted when execute withrawal\\n    event ExecutedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\\n\\n    /// @notice Event emitted when request withrawal\\n    event ReqestedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\\n\\n    /// @notice Event emitted when admin changed\\n    event AdminTransferred(address indexed oldAdmin, address indexed newAdmin);\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /// @notice An event emitted when the reward store address is updated\\n    event StoreUpdated(address oldXvs, address oldStore, address newXvs, address newStore);\\n\\n    /// @notice An event emitted when the withdrawal locking period is updated for a pool\\n    event WithdrawalLockingPeriodUpdated(\\n        address indexed rewardToken,\\n        uint indexed pid,\\n        uint oldPeriod,\\n        uint newPeriod\\n    );\\n\\n    /// @notice An event emitted when the reward amount per block is modified for a pool\\n    event RewardAmountUpdated(address indexed rewardToken, uint oldReward, uint newReward);\\n\\n    /// @notice An event emitted when a new pool is added\\n    event PoolAdded(\\n        address indexed rewardToken,\\n        uint indexed pid,\\n        address indexed token,\\n        uint allocPoints,\\n        uint rewardPerBlock,\\n        uint lockPeriod\\n    );\\n\\n    /// @notice An event emitted when a pool allocation points are updated\\n    event PoolUpdated(\\n        address indexed rewardToken,\\n        uint indexed pid,\\n        uint oldAllocPoints,\\n        uint newAllocPoints\\n    );\\n\\n    constructor() public {\\n        admin = msg.sender;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin can\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n\\n    function poolLength(address rewardToken) external view returns (uint256) {\\n        return poolInfos[rewardToken].length;\\n    }\\n\\n    /**\\n     * @notice Add a new token pool. Can only be called by the admin.\\n     * @dev This vault DOES NOT support deflationary tokens \u2014 it expects that\\n     *   the amount of transferred tokens would equal the actually deposited\\n     *   amount. In practice this means that this vault DOES NOT support USDT\\n     *   and similar tokens (that do not provide these guarantees).\\n     */\\n    function add(\\n        address _rewardToken,\\n        uint256 _allocPoint,\\n        IBEP20 _token,\\n        uint256 _rewardPerBlock,\\n        uint256 _lockPeriod\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(address(xvsStore) != address(0), \\\"Store contract addres is empty\\\");\\n\\n        massUpdatePools(_rewardToken);\\n\\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\\n\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            require(poolInfo[pid].token != _token, \\\"Error pool already added\\\");\\n        }\\n\\n        totalAllocPoints[_rewardToken] = totalAllocPoints[_rewardToken].add(_allocPoint);\\n\\n        rewardTokenAmountsPerBlock[_rewardToken] = _rewardPerBlock;\\n\\n        poolInfo.push(\\n            PoolInfo({\\n                token: _token,\\n                allocPoint: _allocPoint,\\n                lastRewardBlock: block.number,\\n                accRewardPerShare: 0,\\n                lockPeriod: _lockPeriod\\n            })\\n        );\\n\\n        IXVSStore(xvsStore).setRewardToken(_rewardToken, true);\\n\\n        emit PoolAdded(\\n            _rewardToken,\\n            poolInfo.length - 1,\\n            address(_token),\\n            _allocPoint,\\n            _rewardPerBlock,\\n            _lockPeriod\\n        );\\n    }\\n\\n    // Update the given pool's reward allocation point. Can only be called by the admin.\\n    function set(\\n        address _rewardToken,\\n        uint256 _pid,\\n        uint256 _allocPoint\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        massUpdatePools(_rewardToken);\\n\\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\\n        totalAllocPoints[_rewardToken] = totalAllocPoints[_rewardToken].sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        uint256 oldAllocPoints = poolInfo[_pid].allocPoint;\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n\\n        emit PoolUpdated(_rewardToken, _pid, oldAllocPoints, _allocPoint);\\n    }\\n\\n    // Update the given reward token's amount per block\\n    function setRewardAmountPerBlock(\\n        address _rewardToken,\\n        uint256 _rewardAmount\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        massUpdatePools(_rewardToken);\\n        uint256 oldReward = rewardTokenAmountsPerBlock[_rewardToken];\\n        rewardTokenAmountsPerBlock[_rewardToken] = _rewardAmount;\\n\\n        emit RewardAmountUpdated(_rewardToken, oldReward, _rewardAmount);\\n    }\\n\\n    // Update the given reward token's amount per block\\n    function setWithdrawalLockingPeriod(\\n        address _rewardToken,\\n        uint256 _pid,\\n        uint256 _newPeriod\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        require(_newPeriod > 0, \\\"Invalid new locking period\\\");\\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\\n        uint256 oldPeriod = pool.lockPeriod;\\n        pool.lockPeriod = _newPeriod;\\n\\n        emit WithdrawalLockingPeriodUpdated(_rewardToken, _pid, oldPeriod, _newPeriod);\\n    }\\n\\n    /**\\n     * @notice Deposit XVSVault for XVS allocation\\n     * @param _rewardToken The Reward Token Address\\n     * @param _pid The Pool Index\\n     * @param _amount The amount to deposit to vault\\n     */\\n    function deposit(address _rewardToken, uint256 _pid, uint256 _amount)\\n        external\\n        nonReentrant\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\\n        _updatePool(_rewardToken, _pid);\\n        if (user.amount > 0) {\\n            uint256 pending =\\n                user.amount.mul(pool.accRewardPerShare).div(1e12).sub(\\n                    user.rewardDebt\\n                );\\n            IXVSStore(xvsStore).safeRewardTransfer(_rewardToken, msg.sender, pending);\\n        }\\n        pool.token.safeTransferFrom(\\n            address(msg.sender),\\n            address(this),\\n            _amount\\n        );\\n        user.amount = user.amount.add(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\\n\\n        // Update Delegate Amount\\n        if (address(pool.token) == address(xvsAddress)) {\\n            uint256 updatedAmount = user.amount.sub(user.pendingWithdrawals);\\n            _updateDelegate(address(msg.sender), uint96(updatedAmount));\\n        }\\n\\n        emit Deposit(msg.sender, _rewardToken, _pid, _amount);\\n    }\\n\\n    /**\\n     * @notice Pushes withdrawal request to the requests array and updates\\n     *   the pending withdrawals amount. The requests are always sorted\\n     *   by unlock time (descending) so that the earliest to execute requests\\n     *   are always at the end of the array.\\n     * @param _user The user struct storage pointer\\n     * @param _requests The user's requests array storage pointer\\n     * @param _amount The amount being requested\\n     */\\n    function pushWithdrawalRequest(\\n        UserInfo storage _user,\\n        WithdrawalRequest[] storage _requests,\\n        uint _amount,\\n        uint _lockedUntil\\n    )\\n        internal\\n    {\\n        uint i = _requests.length;\\n        _requests.push(WithdrawalRequest(0, 0));\\n        // Keep it sorted so that the first to get unlocked request is always at the end\\n        for (; i > 0 && _requests[i - 1].lockedUntil <= _lockedUntil; --i) {\\n            _requests[i] = _requests[i - 1];\\n        }\\n        _requests[i] = WithdrawalRequest(_amount, _lockedUntil);\\n        _user.pendingWithdrawals = _user.pendingWithdrawals.add(_amount);\\n    }\\n\\n    /**\\n     * @notice Pops the requests with unlock time < now from the requests\\n     *   array and deducts the computed amount from the user's pending\\n     *   withdrawals counter. Assumes that the requests array is sorted\\n     *   by unclock time (descending).\\n     * @dev This function **removes** the eligible requests from the requests\\n     *   array. If this function is called, the withdrawal should actually\\n     *   happen (or the transaction should be reverted).\\n     * @param _user The user struct storage pointer\\n     * @param _requests The user's requests array storage pointer\\n     * @return The amount eligible for withdrawal (this amount should be\\n     *   sent to the user, otherwise the state would be inconsistent).\\n     */\\n    function popEligibleWithdrawalRequests(\\n        UserInfo storage _user,\\n        WithdrawalRequest[] storage _requests\\n    )\\n        internal\\n        returns (uint withdrawalAmount)\\n    {\\n        // Since the requests are sorted by their unlock time, we can just\\n        // pop them from the array and stop at the first not-yet-eligible one\\n        for (uint i = _requests.length; i > 0 && isUnlocked(_requests[i - 1]); --i) {\\n            withdrawalAmount = withdrawalAmount.add(_requests[i - 1].amount);\\n            _requests.pop();\\n        }\\n        _user.pendingWithdrawals = _user.pendingWithdrawals.sub(withdrawalAmount);\\n        return withdrawalAmount;\\n    }\\n\\n    /**\\n     * @notice Checks if the request is eligible for withdrawal.\\n     * @param _request The request struct storage pointer\\n     * @return True if the request is eligible for withdrawal, false otherwise\\n     */\\n    function isUnlocked(WithdrawalRequest storage _request) private view returns (bool) {\\n        return _request.lockedUntil <= block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Execute withdrawal to XVSVault for XVS allocation\\n     * @param _rewardToken The Reward Token Address\\n     * @param _pid The Pool Index\\n     */\\n    function executeWithdrawal(address _rewardToken, uint256 _pid)\\n        external\\n        nonReentrant\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\\n\\n        uint256 _amount = popEligibleWithdrawalRequests(user, requests);\\n        require(_amount > 0, \\\"nothing to withdraw\\\");\\n\\n        _updatePool(_rewardToken, _pid);\\n        uint256 pending =\\n            user.amount.mul(pool.accRewardPerShare).div(1e12).sub(\\n                user.rewardDebt\\n            );\\n        IXVSStore(xvsStore).safeRewardTransfer(_rewardToken, msg.sender, pending);\\n        user.amount = user.amount.sub(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\\n        pool.token.safeTransfer(address(msg.sender), _amount);\\n\\n        emit ExecutedWithdrawal(msg.sender, _rewardToken, _pid, _amount);\\n    }\\n\\n    /**\\n     * @notice Request withdrawal to XVSVault for XVS allocation\\n     * @param _rewardToken The Reward Token Address\\n     * @param _pid The Pool Index\\n     * @param _amount The amount to withdraw to vault\\n     */\\n    function requestWithdrawal(address _rewardToken, uint256 _pid, uint256 _amount)\\n        external\\n        nonReentrant\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        require(_amount > 0, \\\"requested amount cannot be zero\\\");\\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\\n        require(user.amount >= user.pendingWithdrawals.add(_amount), \\\"requested amount is invalid\\\");\\n\\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\\n        uint lockedUntil = pool.lockPeriod.add(block.timestamp);\\n\\n        pushWithdrawalRequest(user, requests, _amount, lockedUntil);\\n\\n        // Update Delegate Amount\\n        if (_rewardToken == address(xvsAddress)) {\\n            uint256 updatedAmount = user.amount.sub(user.pendingWithdrawals);\\n            _updateDelegate(address(msg.sender), uint96(updatedAmount));\\n        }\\n\\n        emit ReqestedWithdrawal(msg.sender, _rewardToken, _pid, _amount);\\n    }\\n\\n    /**\\n     * @notice Get unlocked withdrawal amount\\n     * @param _rewardToken The Reward Token Address\\n     * @param _pid The Pool Index\\n     * @param _user The User Address\\n     */\\n    function getEligibleWithdrawalAmount(address _rewardToken, uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint withdrawalAmount)\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\\n        // Since the requests are sorted by their unlock time, we can take\\n        // the entries from the end of the array and stop at the first\\n        // not-yet-eligible one\\n        for (uint i = requests.length; i > 0 && isUnlocked(requests[i - 1]); --i) {\\n            withdrawalAmount = withdrawalAmount.add(requests[i - 1].amount);\\n        }\\n        return withdrawalAmount;\\n    }\\n\\n    /**\\n     * @notice Get requested amount\\n     * @param _rewardToken The Reward Token Address\\n     * @param _pid The Pool Index\\n     * @param _user The User Address\\n     */\\n    function getRequestedAmount(address _rewardToken, uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\\n        return user.pendingWithdrawals;\\n    }\\n\\n    /**\\n     * @notice Returns the array of withdrawal requests that have not been executed yet\\n     * @param _rewardToken The Reward Token Address\\n     * @param _pid The Pool Index\\n     * @param _user The User Address\\n     */\\n    function getWithdrawalRequests(address _rewardToken, uint256 _pid, address _user)\\n        external\\n        view\\n        returns (WithdrawalRequest[] memory)\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        return withdrawalRequests[_rewardToken][_pid][_user];\\n    }\\n\\n    // View function to see pending XVSs on frontend.\\n    function pendingReward(address _rewardToken, uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\\n        uint256 accRewardPerShare = pool.accRewardPerShare;\\n        uint256 supply = pool.token.balanceOf(address(this));\\n        uint256 curBlockNumber = block.number;\\n        uint256 rewardTokenPerBlock = rewardTokenAmountsPerBlock[_rewardToken];\\n        if (curBlockNumber > pool.lastRewardBlock && supply != 0) {\\n            uint256 multiplier = curBlockNumber.sub(pool.lastRewardBlock);\\n            uint256 reward =\\n                multiplier.mul(rewardTokenPerBlock).mul(pool.allocPoint).div(\\n                    totalAllocPoints[_rewardToken]\\n                );\\n            accRewardPerShare = accRewardPerShare.add(\\n                reward.mul(1e12).div(supply)\\n            );\\n        }\\n        return user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward vairables for all pools. Be careful of gas spending!\\n    function massUpdatePools(address _rewardToken) public {\\n        uint256 length = poolInfos[_rewardToken].length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            _updatePool(_rewardToken, pid);\\n        }\\n    }\\n\\n    function updatePool(address _rewardToken, uint256 _pid)\\n        external\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        _updatePool(_rewardToken, _pid);\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function _updatePool(address _rewardToken, uint256 _pid)\\n        internal\\n    {\\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 supply = pool.token.balanceOf(address(this));\\n        if (supply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 curBlockNumber = block.number;\\n        uint256 multiplier = curBlockNumber.sub(pool.lastRewardBlock);\\n        uint256 reward =\\n            multiplier.mul(rewardTokenAmountsPerBlock[_rewardToken]).mul(pool.allocPoint).div(\\n                totalAllocPoints[_rewardToken]\\n            );\\n        pool.accRewardPerShare = pool.accRewardPerShare.add(\\n            reward.mul(1e12).div(supply)\\n        );\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    function _ensureValidPool(address rewardToken, uint256 pid) internal view {\\n        require(pid < poolInfos[rewardToken].length , \\\"vault: pool exists?\\\");\\n    }\\n\\n    // Get user info with reward token address and pid\\n    function getUserInfo(\\n        address _rewardToken,\\n        uint256 _pid,\\n        address _user\\n    )\\n        external\\n        view\\n        returns (uint256 amount, uint256 rewardDebt, uint256 pendingWithdrawals)\\n    {\\n        _ensureValidPool(_rewardToken, _pid);\\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\\n        amount = user.amount;\\n        rewardDebt = user.rewardDebt;\\n        pendingWithdrawals = user.pendingWithdrawals;\\n    }\\n\\n    /**\\n     * @notice Get the XVS stake balance of an account (excluding the pending withdrawals)\\n     * @param account The address of the account to check\\n     * @return The balance that user staked\\n     */\\n    function getStakeAmount(address account) internal view returns (uint96) {\\n        require(xvsAddress != address(0), \\\"XVSVault::getStakeAmount: xvs address is not set\\\");\\n\\n        PoolInfo[] storage poolInfo = poolInfos[xvsAddress];\\n\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            if (address(poolInfo[pid].token) == address(xvsAddress)) {\\n                UserInfo storage user = userInfos[xvsAddress][pid][account];\\n                return uint96(user.amount.sub(user.pendingWithdrawals));\\n            }\\n        }\\n        return uint96(0);\\n    }\\n\\n    /**\\n     * @notice Update Delegates - voting power\\n     * @param delegator The address of Delegator\\n     * @param amount Updated delegate amount\\n     */\\n    function _updateDelegate(address delegator, uint96 amount) internal {\\n        address currentDelegate = delegates[delegator];\\n\\n        if (currentDelegate != address(0)) {\\n            uint32 delegateRepNum = numCheckpoints[currentDelegate];\\n            uint96 delegateRepOld = delegateRepNum > 0 ? checkpoints[currentDelegate][delegateRepNum - 1].votes : 0;\\n            _writeCheckpoint(currentDelegate, delegateRepNum, delegateRepOld, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s)\\n        external\\n    {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"XVSVault\\\")), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ECDSA.recover(digest, v, r, s);\\n        require(nonce == nonces[signatory]++, \\\"XVSVault::delegateBySig: invalid nonce\\\");\\n        require(block.timestamp <= expiry, \\\"XVSVault::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        address currentDelegate = delegates[delegator];\\n        uint96 delegatorBalance = getStakeAmount(delegator);\\n        delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"XVSVault::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"XVSVault::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n        uint32 blockNumber = safe32(block.number, \\\"XVSVault::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n\\n    /**\\n     * @notice Determine the xvs stake balance for an account\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The balance that user staked\\n     */\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\\n        require(blockNumber < block.number, \\\"XVSVault::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current admin\\n     */\\n    function getAdmin() external view returns (address) {\\n        return admin;\\n    }\\n\\n    /**\\n     * @dev Burn the current admin\\n     */\\n    function burnAdmin() external onlyAdmin {\\n        emit AdminTransferred(admin, address(0));\\n        admin = address(0);\\n    }\\n\\n    /*** Admin Functions ***/\\n\\n    function _become(XVSVaultProxy xvsVaultProxy) external {\\n        require(msg.sender == xvsVaultProxy.admin(), \\\"only proxy admin can change brains\\\");\\n        require(xvsVaultProxy._acceptImplementation() == 0, \\\"change not authorized\\\");\\n    }\\n\\n    function setXvsStore(address _xvs, address _xvsStore) external onlyAdmin {\\n        address oldXvsContract = xvsAddress;\\n        address oldStore = xvsStore;\\n        xvsAddress = _xvs;\\n        xvsStore = _xvsStore;\\n\\n        _notEntered = true;\\n\\n        emit StoreUpdated(oldXvsContract, oldStore, _xvs, _xvsStore);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/XVSVault/XVSVaultErrorReporter.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ncontract XVSVaultErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED\\n    }\\n\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/XVSVault/XVSVaultStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\nimport \\\"../Utils/SafeMath.sol\\\";\\nimport \\\"../Utils/IBEP20.sol\\\";\\n\\ncontract XVSVaultAdminStorage {\\n    /**\\n    * @notice Administrator for this contract\\n    */\\n    address public admin;\\n\\n    /**\\n    * @notice Pending administrator for this contract\\n    */\\n    address public pendingAdmin;\\n\\n    /**\\n    * @notice Active brains of XVS Vault\\n    */\\n    address public implementation;\\n\\n    /**\\n    * @notice Pending brains of XVS Vault\\n    */\\n    address public pendingXVSVaultImplementation;\\n}\\n\\ncontract XVSVaultStorage is XVSVaultAdminStorage {\\n    /// @notice Guard variable for re-entrancy checks\\n    bool internal _notEntered;\\n\\n    /// @notice The reward token store\\n    address public xvsStore;\\n\\n    /// @notice The xvs token address\\n    address public xvsAddress;\\n\\n    // Reward tokens created per block indentified by reward token address.\\n    mapping(address => uint256) public rewardTokenAmountsPerBlock;\\n\\n    /// @notice Info of each user.\\n    struct UserInfo {\\n        uint256 amount;\\n        uint256 rewardDebt;\\n        uint256 pendingWithdrawals;\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IBEP20 token;               // Address of token contract to stake.\\n        uint256 allocPoint;         // How many allocation points assigned to this pool.\\n        uint256 lastRewardBlock;    // Last block number that reward tokens distribution occurs.\\n        uint256 accRewardPerShare;  // Accumulated per share, times 1e12. See below.\\n        uint256 lockPeriod;         // Min time between withdrawal request and its execution.\\n    }\\n\\n    // Infomation about a withdrawal request\\n    struct WithdrawalRequest {\\n        uint256 amount;\\n        uint256 lockedUntil;\\n    }\\n\\n    // Info of each user that stakes tokens.\\n    mapping(address => mapping(uint256 => mapping(address => UserInfo))) userInfos;\\n\\n    // Info of each pool.\\n    mapping(address => PoolInfo[]) public poolInfos;\\n\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    mapping(address => uint256) public totalAllocPoints;\\n\\n    // Info of requested but not yet executed withdrawals\\n    mapping(address => mapping(uint256 => mapping(address => WithdrawalRequest[]))) withdrawalRequests;\\n\\n    /// @notice A record of each accounts delegate\\n    mapping (address => address) public delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n}\\n\"\r\n    },\r\n    \"contracts/XVSVault/XVSVaultProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./XVSVaultStorage.sol\\\";\\nimport \\\"./XVSVaultErrorReporter.sol\\\";\\n\\ncontract XVSVaultProxy is XVSVaultAdminStorage, XVSVaultErrorReporter {\\n\\n    /**\\n      * @notice Emitted when pendingXVSVaultImplementation is changed\\n      */\\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingXVSVaultImplementation is accepted, which means XVS Vault implementation is updated\\n      */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is changed\\n      */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n      */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() public {\\n        // Set admin to caller\\n        admin = msg.sender;\\n    }\\n\\n    /*** Admin Functions ***/\\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\\n\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\\n        }\\n\\n        address oldPendingImplementation = pendingXVSVaultImplementation;\\n\\n        pendingXVSVaultImplementation = newPendingImplementation;\\n\\n        emit NewPendingImplementation(oldPendingImplementation, pendingXVSVaultImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n    * @notice Accepts new implementation of XVS Vault. msg.sender must be pendingImplementation\\n    * @dev Admin function for new implementation to accept it's role as implementation\\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n    */\\n    function _acceptImplementation() public returns (uint) {\\n        // Check caller is pendingImplementation\\n        if (msg.sender != pendingXVSVaultImplementation) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldImplementation = implementation;\\n        address oldPendingImplementation = pendingXVSVaultImplementation;\\n\\n        implementation = pendingXVSVaultImplementation;\\n\\n        pendingXVSVaultImplementation = address(0);\\n\\n        emit NewImplementation(oldImplementation, implementation);\\n        emit NewPendingImplementation(oldPendingImplementation, pendingXVSVaultImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() public returns (uint) {\\n        // Check caller is pendingAdmin\\n        if (msg.sender != pendingAdmin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    function () external payable {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = implementation.delegatecall(msg.data);\\n\\n        assembly {\\n              let free_mem_ptr := mload(0x40)\\n              returndatacopy(free_mem_ptr, 0, returndatasize)\\n\\n              switch success\\n              case 0 { revert(free_mem_ptr, returndatasize) }\\n              default { return(free_mem_ptr, returndatasize) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/IBEP20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the BEP20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {BEP20Detailed}.\\n */\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/SafeBEP20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeBEP20\\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeBEP20 for BEP20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeBEP20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeBEP20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeBEP20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IBEP20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeBEP20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeBEP20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeBEP20: BEP20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Adapted from OpenZeppelin Contracts v4.3.2 (utils/cryptography/ECDSA.sol)\\n\\n// SPDX-Copyright-Text: OpenZeppelin, 2021\\n// SPDX-Copyright-Text: Venus, 2021\\n\\npragma solidity ^0.5.16;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\ncontract ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingImplementation\",\"type\":\"address\"}],\"name\":\"NewPendingImplementation\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptImplementation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingImplementation\",\"type\":\"address\"}],\"name\":\"_setPendingImplementation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingXVSVaultImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XVSVaultProxy", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xea456c6a52c36ae021d93cf69812260149ec39c2", "SwarmSource": ""}