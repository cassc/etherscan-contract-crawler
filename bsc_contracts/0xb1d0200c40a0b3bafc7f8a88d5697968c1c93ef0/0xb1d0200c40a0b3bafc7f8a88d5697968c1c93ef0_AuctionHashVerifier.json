{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\\n\\nimport \\\"./ERC20Permit.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../../../utils/cryptography/EIP712.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    /**\\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\\n     * to reserve a slot.\\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        _balances[account] += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../ShortStrings.sol\\\";\\nimport \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * _Available since v3.4._\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {EIP-5267}.\\n     *\\n     * _Available since v4.9._\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _name.toStringWithFallback(_nameFallback),\\n            _version.toStringWithFallback(_versionFallback),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ShortStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(_FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/ContractRegistryHashesV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\n/// @title ContractRegistryHashesV4\\n/// @author MetFi\\n/// @notice Collection of precomputed keccak256 hashes of all contracts names, used in ContractRegistry\\nabstract contract ContractRegistryHashesV4 {\\n    // Token hashes\\n    bytes32 internal constant MFI_HASH = 0xab12ee3d83a34822ca77656b4007d61405e0029c8476890a3303aabb7a0a3d26; // keccak256(abi.encodePacked('mfi'))\\n    bytes32 internal constant METFI_HASH = 0xc30505a9c296d74a341270378602ace8341352e684fc4f8fbf4bf9aa16ddffca; // keccak256(abi.encodePacked('metfi'))\\n\\n    // Core contract hashes\\n    bytes32 internal constant ROUTER_HASH = 0x5f6d4e9bb70c9d2aa50e18560b4cdd1b23b30d62b60873d5f23b103e5d7d0185; // keccak256(abi.encodePacked('router'))\\n    bytes32 internal constant TREASURY_HASH = 0xcbd818ad4dd6f1ff9338c2bb62480241424dd9a65f9f3284101a01cd099ad8ac; // keccak256(abi.encodePacked('treasury'))\\n    bytes32 internal constant METFI_VAULT_HASH = 0xacb5ae4bf471c8110adaac4702c4177629bf32af63ad6f68f546ac2fcd039e77; // keccak256(abi.encodePacked('metfi_vault'))\\n    bytes32 internal constant USER_CONFIG_HASH = 0x5e1885a4b18649f87409858a77d00e281ce6dd4507e43dc706a2d703d71aeb71; // keccak256(abi.encodePacked('user_config'))\\n    bytes32 internal constant ACCOUNT_TOKEN_HASH = 0xc5d51c4d622df5dca71195c62129359a2e761a24b2789b5a40667736c682f30f; // keccak256(abi.encodePacked('account_token'))\\n    bytes32 internal constant PLATFORM_VIEW_HASH = 0xd58c1d29f4951cf40818a252966d0f0711896e43c86ba803ffa9841180d7bca1; // keccak256(abi.encodePacked('platform_view'))\\n    bytes32 internal constant UNSTAKED_NFTS_HASH = 0x2d006620d1c948b883dc3097193eb76c239d12828bb85beea39994af1ecefb65; // keccak256(abi.encodePacked('unstaked_nfts'))\\n    bytes32 internal constant STAKING_MANAGER_HASH = 0x9518d9bd94df3303f323b9a5b2289cf4e06524a698aef176fcc9590318226540; // keccak256(abi.encodePacked('staking_manager'))\\n    bytes32 internal constant TOKEN_COLLECTOR_HASH = 0x66c4b93ccf2bde8d7ba39826420a87af960e88acb070c754e53aba0b8e51c02c; // keccak256(abi.encodePacked('token_collector'))\\n    bytes32 internal constant BURN_CONTROLLER_HASH = 0xa4636fb16cea2aa5153c9be70618a6afb5cefe7a593eeee2cfab523b8c195a73; // keccak256(abi.encodePacked('burn_controller'))\\n    bytes32 internal constant REWARD_CONVERTER_HASH = 0xb7e5e8f89e319d42882d379ecafd17e93606cf39a2079af36730958267667728; // keccak256(abi.encodePacked('reward_converter'))\\n    bytes32 internal constant METFI_STAKING_POOL_HASH =\\n        0x3d9cfbe20d3d50006bd02e057e662d569da593b764b8b8f923d3d313f2422b10; // keccak256(abi.encodePacked('metfi_staking_pool'))\\n    bytes32 internal constant REWARD_DISTRIBUTOR_HASH =\\n        0x8d3e9afdbbce76f0b889c4bff442796e82871c8eccf3c648a01e55e080d66a49; // keccak256(abi.encodePacked('reward_distributor'))\\n    bytes32 internal constant PRIMARY_STABLECOIN_HASH =\\n        0x0876039741972003251072838c80c5b1e815c7b3ed2e3b01411c485fec477ecc; // keccak256(abi.encodePacked('primary_stablecoin'))\\n    bytes32 internal constant ACTION_FUNCTIONS_HASH = 0x1d935ae848b4177a1626ed64187ea7d45d543a12af26efff12c21ab57a0366b0; // keccak256(abi.encodePacked('multisig_action_functions'))\\n    bytes32 internal constant NFT_TRANSFER_PROXY_HASH =\\n        0xbd165d9953042246fb908ee4e3ee644fbe1e3fe22c7d6830d417bdcece5d273b; // keccak256(abi.encodePacked('nft_transfer_proxy'))\\n    bytes32 internal constant STAR_ACHIEVERS_HASH = 0x22a6d61b8441b8b48421128668229a04c572ac6018e721043359db05f33c151b; // keccak256(abi.encodePacked('star_achievers'))\\n\\n    // Lending system hashes\\n    bytes32 internal constant LENDING_HASH = 0x16573015d5a4b6fc6913a13e8c047a772cc654c00c338536ccaa33e7fe263be9; // keccak256(abi.encodePacked('lending'))\\n    bytes32 internal constant LENDING_VIEW_HASH = 0xc74a7251498f700c757f7d9bedf70846e0808d0cfd266d18ff796d603e58ef42; // keccak256(abi.encodePacked('lending_view'))\\n    bytes32 internal constant LOAN_LIMITER_HASH = 0x840de5598c4c00225a8bc33abacc176aa8dc32e156f7069560dd186d8c08e83e; // keccak256(abi.encodePacked('loan_limiter'))\\n    bytes32 internal constant LENDING_AUCTION_HASH = 0x315a584ec231dc4ba7bfc5a8f8efed9f1d7f61fe4c54746decfc19ddd199a7c8; // keccak256(abi.encodePacked('lending_auction'))\\n    bytes32 internal constant LENDING_CHECKER_HASH = 0xd0beb74e409a61d00092877bb21f2e1b99afa0fb5b69fded573ce9d20f6426ee; // keccak256(abi.encodePacked('lending_checker'))\\n    bytes32 internal constant LENDING_CALCULATOR_HASH =\\n        0xc8f991caa4a50f2a548f7cb4ae682c6276c4479baa4474b270262f1cf7ef0d13; // keccak256(abi.encodePacked('lending_calculator'))\\n    bytes32 internal constant LENDING_EXTENSION_CONTROLLER_HASH =\\n        0x575b99354279563b4b104af43b2bd3663850df86e34a2a754269a4a55a0c1afd; // keccak256(abi.encodePacked('lending_extension_controller'))\\n\\n    // Pancake hashes\\n    bytes32 internal constant PANCAKE_ROUTER_HASH = 0xd8ed703341074e5699af5f26d9f38498fb901a7519f08174cfb1baf7b5ecbff9; // keccak256(abi.encodePacked('pancake_router'))\\n    bytes32 internal constant PANCAKE_ROUTER_V3_HASH =\\n        0x118a350e784009af10cdc15a17e2e07a9bb714748b9a7961de0ae19510f30f54; // keccak256(abi.encodePacked('pancake_router_v3'))\\n\\n    // Quiz hashes\\n    bytes32 internal constant METFI_QUIZ_HASH = 0x3305b013213dd4fd6bfd7016dfd813f8e0228288906e640c47865bdfc3477de5; // keccak256(abi.encodePacked('metfi_quiz'))\\n    bytes32 internal constant METFI_QUIZ_FUNCTIONS_HASH =\\n        0x5b49ed809043b2398bed90abf5eff9f0e49fd6884d9152a6bb31effc1e4a5a02; // keccak256(abi.encodePacked('metfi_quiz_functions'))\\n\\n    // Miscellaneous  hashes\\n    bytes32 internal constant COMMUNITY_MANAGER_PAYOUT_CONTROLLER_HASH =\\n        0x8e4bf4954dca9b537539c95d84bafae4fccf02da2ae09493581b7e530f914a17; // keccak256(abi.encodePacked('community_manager_payout_controller'))\\n\\n    // Reward distribution strategy hashes\\n    bytes32 internal constant DEFAULT_REWARD_DISTRIBUTION_STRATEGY =\\n        0x20625272295bc2a8bdba73698e0a2481060d84108552925cabea772fd0c704cc; // keccak256(abi.encodePacked('default_reward_distribution_strategy'))\\n    bytes32 internal constant META_QUIZ_DISTRIBUTION_STRATEGY_HASH =\\n        0xc536ac458dca70be9eb167d49d20757ce673ce66774371986a7f2a98476a83e3; // keccak256(abi.encodePacked('meta_quiz_distribution_strategy'))\\n    bytes32 internal constant SPLIT_REWARD_DISTRIBUTION_STRATEGY_HASH =\\n        0xe7b102a816a945984f8df5a69989e5478fb7b4bbb4d2736b6286bc4b9daae765; // keccak256(abi.encodePacked('split_reward_distribution_strategy'))\\n    bytes32 internal constant CLASSIC_REWARD_DISTRIBUTION_STRATEGY_HASH =\\n        0x83a4e6f3aa6d5fac2d6f4e927c0f7b2f317e1ebd330e5cc1cf8cf38d4f7f82f9; // keccak256(abi.encodePacked('classic_reward_distribution_strategy'))\\n    bytes32 internal constant METABID_REWARD_DISTRIBUTION_STRATEGY_HASH =\\n        0x66edc47c31f968c3f7040b583853768128998e4d0f65c70c6a3ceb64d1bbf1bb; // keccak256(abi.encodePacked('metabid_reward_distribution_strategy'))\\n    bytes32 internal constant SUPERCHARGER_REWARD_DISTRIBUTION_STRATEGY_HASH =\\n        0x293faea372a91185ea31d701038f05ef77e185e1ca12e7a9b01f26bd2b08c3c7; // keccak256(abi.encodePacked('supercharger_reward_distribution_strategy'))\\n\\n    // Metabid\\n    bytes32 internal constant METABID_AUCTION_PAYMENT_CONTRACT_HASH =\\n        0xec88f7eb8748b770a4e6d2d2e154e7bd11784027bb2dcde2ddca561219ae6428; // keccak256(abi.encodePacked('metabid_auction_payment_contract'))\\n    bytes32 internal constant METABID_APPROVED_PRIZE_ADDER =\\n        0x8760d36b20be35c7ce6f261b94d6da70bd1a3103427597fb452c13e74599cd3b; // keccak256(abi.encodePacked('metabid_approved_prize_adder'))\\n    bytes32 internal constant METABID_APPROVED_AUCTION_ADDER =\\n        0xf6ee9fba113eb48b509e2ce6d018f0ce6a08ac9fc24a2837e14c186d50a0468d; // keccak256(abi.encodePacked('metabid_approved_auction_adder'))\\n    bytes32 internal constant METABID_AUCTION_DATA_CONTRACT =\\n        0xf0591e6f47bc779c86a8c0eceb6c742f0bd37443f1fb9c8ab7fe1a9105e90613; // keccak256(abi.encodePacked('metabid_auction_data_contract'))\\n    bytes32 internal constant METABID_AUCTION_PRIZE_HOLDER =\\n        0x0db49d48dbfb3c01c200932ed3dcfc1abe3d7f2e5010670f29d87ed2bb7a76a4; // keccak256(abi.encodePacked('metabid_auction_prize_holder'))\\n    bytes32 internal constant METABID_SUPERCHARGER_CONTRACT =\\n        0x4f19427102a8d9afc9f5be437472f0ede6fd75527eb42d80bb7f0285129ba8cd; // keccak256(abi.encodePacked('metabid_supercharger_contract'))\\n    bytes32 internal constant METABID_BID_PURCHASE_RECEIVER =\\n        0xfb7748741b4abd9368b708d5d4fe733706423bdc0a0e0c6315b054eeae29f85d; // keccak256(abi.encodePacked('metabid_bid_purchase_receiver'))\\n    bytes32 internal constant METABID_BID_PURCHASE = 0x19d15c0db68944fc0ba59a899e02cd67e2f055cb190bfffb40cc6a25fdb42b4c; // keccak256(abi.encodePacked('metabid_bid_purchase'))\\n    bytes32 internal constant METABID_AUCTION_PAYMENT_RECEIVER =\\n        0xd8e7f486e3bcc715267005ab4e26dc6f4d5875c7790b118a2e99185cc96472f1; // keccak256(abi.encodePacked('metabid_auction_payment_receiver'))\\n    bytes32 internal constant METABID_BOUGHT_BONUS = 0x0c6da52ba84204c65f01df126558246f934c70f40bc60d716d0d3e9e3bc5ef5e; // keccak256(abi.encodePacked('metabid_bought_bonus'))\\n}\\n\"\r\n    },\r\n    \"contracts/base/ContractRegistryUserV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {IContractRegistry} from \\\"contracts/interfaces/core/IContractRegistry.sol\\\";\\n\\nimport {MetFiErrorsV3} from \\\"contracts/base/MetFiErrorsV3.sol\\\";\\nimport {ContractRegistryHashesV4} from \\\"contracts/base/ContractRegistryHashesV4.sol\\\";\\n\\nimport {WBNB} from \\\"contracts/side_utils/WBNB.sol\\\";\\n\\nimport {IMETFI} from \\\"contracts/interfaces/metfi/IMETFI.sol\\\";\\nimport {IRouterV4} from \\\"contracts/interfaces/router/IRouterV4.sol\\\";\\nimport {IMetFiQuiz} from \\\"contracts/interfaces/quiz/IMetFiQuiz.sol\\\";\\nimport {IMETFIVault} from \\\"contracts/interfaces/metfi/IMETFIVault.sol\\\";\\nimport {IUserConfig} from \\\"contracts/interfaces/config/IUserConfig.sol\\\";\\nimport {IMetFiQuizV2} from \\\"contracts/interfaces/quiz/IMetFiQuizV2.sol\\\";\\nimport {ILendingV2} from \\\"contracts/interfaces/lending/v2/ILendingV2.sol\\\";\\nimport {ITreasuryV2} from \\\"contracts/interfaces/treasury/ITreasuryV2.sol\\\";\\nimport {IAccountToken} from \\\"contracts/interfaces/core/IAccountToken.sol\\\";\\nimport {ISecurityProxy} from \\\"contracts/interfaces/metfi/ISecurityProxy.sol\\\";\\nimport {ILendingAuction} from \\\"contracts/interfaces/lending/ILendingAuction.sol\\\";\\nimport {ILendingViewV2} from \\\"contracts/interfaces/lending/v2/ILendingViewV2.sol\\\";\\nimport {ILoanLimiterV2} from \\\"contracts/interfaces/lending/v2/ILoanLimiterV2.sol\\\";\\nimport {ITokenCollectorV2} from \\\"contracts/interfaces/core/ITokenCollectorV2.sol\\\";\\nimport {IPlatformView} from \\\"contracts/interfaces/platform_view/IPlatformView.sol\\\";\\nimport {IPancakeRouter02} from \\\"contracts/interfaces/pancake/IPancakeRouter02.sol\\\";\\nimport {IMETFIStakingPool} from \\\"contracts/interfaces/metfi/IMETFIStakingPool.sol\\\";\\nimport {IPriceCalculator} from \\\"contracts/interfaces/treasury/IPriceCalculator.sol\\\";\\nimport {IValueCalculator} from \\\"contracts/interfaces/treasury/IValueCalculator.sol\\\";\\nimport {IRewardDistributor} from \\\"contracts/interfaces/core/IRewardDistributor.sol\\\";\\nimport {IStakingManagerV3} from \\\"contracts/interfaces/staking/IStakingManagerV3.sol\\\";\\nimport {IBurnControllerV2} from \\\"contracts/interfaces/treasury/IBurnControllerV2.sol\\\";\\nimport {IPlatformViewV2} from \\\"contracts/interfaces/platform_view/IPlatformViewV2.sol\\\";\\nimport {ILendingCheckerV2} from \\\"contracts/interfaces/lending/v2/ILendingCheckerV2.sol\\\";\\nimport {IManageableTreasury} from \\\"contracts/interfaces/treasury/IManageableTreasury.sol\\\";\\nimport {ILiquidityController} from \\\"contracts/interfaces/treasury/ILiquidityController.sol\\\";\\nimport {ILendingCalculatorV2} from \\\"contracts/interfaces/lending/v2/ILendingCalculatorV2.sol\\\";\\nimport {IBoughtBonusInfo} from \\\"contracts/interfaces/reward_distributor/IBoughtBonusInfo.sol\\\";\\nimport {ILendingPlatformViewV2} from \\\"contracts/interfaces/lending/v2/ILendingPlatformViewV2.sol\\\";\\nimport {IRewardDistributorV2} from \\\"contracts/interfaces/reward_distributor/IRewardDistributorV2.sol\\\";\\nimport {ILendingLoanExtensionControllerV2} from \\\"contracts/interfaces/lending/v2/ILendingLoanExtensionControllerV2.sol\\\";\\n\\n/// @title ContractRegistryUserV4\\n/// @author MetFi\\n/// @notice ContractRegistryUserV4 is a base contract that provides utility function for getting instances of contracts from the registry\\nabstract contract ContractRegistryUserV4 is ContractRegistryHashesV4, MetFiErrorsV3 {\\n    IContractRegistry internal immutable contractRegistry;\\n    WBNB internal constant WBNB_CONTRACT = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\\n\\n    constructor(IContractRegistry _contractRegistry) {\\n        if (address(_contractRegistry) == address(0)) {\\n            revert NullAddress();\\n        }\\n        contractRegistry = _contractRegistry;\\n    }\\n\\n    //-------------------------------------------------------------------------\\n\\n    function onlyRouter() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(ROUTER_HASH)) {\\n            revert OnlyRouter();\\n        }\\n    }\\n\\n    function onlyTreasury() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(TREASURY_HASH)) {\\n            revert OnlyTreasury();\\n        }\\n    }\\n\\n    function onlyRealmGuardian() internal view {\\n        if (!contractRegistry.isRealmGuardian(msg.sender)) {\\n            revert OnlyRealmGuardian();\\n        }\\n    }\\n\\n    function onlyStakingManager() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(STAKING_MANAGER_HASH)) {\\n            revert OnlyStakingManager();\\n        }\\n    }\\n\\n    function onlyStakingManagerOrTokenCollector() internal view {\\n        if (\\n            msg.sender != contractRegistry.getContractAddress(STAKING_MANAGER_HASH)\\n                && msg.sender != contractRegistry.getContractAddress(TOKEN_COLLECTOR_HASH)\\n        ) {\\n            revert OnlyStakingManagerOrTokenCollector();\\n        }\\n    }\\n\\n    function onlyRewardDistributor() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(REWARD_DISTRIBUTOR_HASH)) {\\n            revert OnlyRewardDistributor();\\n        }\\n    }\\n\\n    function onlyCoinMaster() internal view {\\n        if (!contractRegistry.isCoinMaster(msg.sender)) {\\n            revert OnlyCoinMaster();\\n        }\\n    }\\n\\n    function onlyTokenCollector() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(TOKEN_COLLECTOR_HASH)) {\\n            revert OnlyTokenCollector();\\n        }\\n    }\\n\\n    //-------------------------------------------------------------------------\\n\\n    function getUserConfigAddressValue(uint256 nftId, string memory key) internal view returns (address) {\\n        return address(uint160(getUserConfig().getUserConfigUintValue(nftId, key)));\\n    }\\n\\n    function getMETFI() internal view returns (IMETFI) {\\n        return IMETFI(contractRegistry.getContractAddress(METFI_HASH));\\n    }\\n\\n    function getMETFIERC20() internal view returns (IERC20) {\\n        return IERC20(contractRegistry.getContractAddress(METFI_HASH));\\n    }\\n\\n    function getRouter() internal view returns (IRouterV4) {\\n        return IRouterV4(contractRegistry.getContractAddress(ROUTER_HASH));\\n    }\\n\\n    function getLending() internal view returns (ILendingV2) {\\n        return ILendingV2(contractRegistry.getContractAddress(LENDING_HASH));\\n    }\\n\\n    function getTreasury() internal view returns (ITreasuryV2) {\\n        return ITreasuryV2(contractRegistry.getContractAddress(TREASURY_HASH));\\n    }\\n\\n    function getMETFIVault() internal view returns (IMETFIVault) {\\n        return IMETFIVault(contractRegistry.getContractAddress(METFI_VAULT_HASH));\\n    }\\n\\n    function getUserConfig() internal view returns (IUserConfig) {\\n        return IUserConfig(contractRegistry.getContractAddress(USER_CONFIG_HASH));\\n    }\\n\\n    function getLendingView() internal view returns (ILendingViewV2) {\\n        return ILendingViewV2(contractRegistry.getContractAddress(LENDING_VIEW_HASH));\\n    }\\n\\n    function getLoanLimiter() internal view returns (ILoanLimiterV2) {\\n        return ILoanLimiterV2(contractRegistry.getContractAddress(LOAN_LIMITER_HASH));\\n    }\\n\\n    function getAccountToken() internal view returns (IAccountToken) {\\n        return IAccountToken(contractRegistry.getContractAddress(ACCOUNT_TOKEN_HASH));\\n    }\\n\\n    function getAccountTokenIERC721() internal view returns (IERC721) {\\n        return IERC721(contractRegistry.getContractAddress(ACCOUNT_TOKEN_HASH));\\n    }\\n\\n    function getBurnController() internal view returns (IBurnControllerV2) {\\n        return IBurnControllerV2(contractRegistry.getContractAddress(BURN_CONTROLLER_HASH));\\n    }\\n\\n    function getStakingManager() internal view returns (IStakingManagerV3) {\\n        return IStakingManagerV3(contractRegistry.getContractAddress(STAKING_MANAGER_HASH));\\n    }\\n\\n    function getTokenCollector() internal view returns (ITokenCollectorV2) {\\n        return ITokenCollectorV2(contractRegistry.getContractAddress(TOKEN_COLLECTOR_HASH));\\n    }\\n\\n    function getLendingAuction() internal view returns (ILendingAuction) {\\n        return ILendingAuction(contractRegistry.getContractAddress(LENDING_AUCTION_HASH));\\n    }\\n\\n    function getLendingChecker() internal view returns (ILendingCheckerV2) {\\n        return ILendingCheckerV2(contractRegistry.getContractAddress(LENDING_CHECKER_HASH));\\n    }\\n\\n    function getMETFIStakingPool() internal view returns (IMETFIStakingPool) {\\n        return IMETFIStakingPool(contractRegistry.getContractAddress(METFI_STAKING_POOL_HASH));\\n    }\\n\\n    function getRewardDistributor() internal view returns (IRewardDistributor) {\\n        return IRewardDistributor(contractRegistry.getContractAddress(REWARD_DISTRIBUTOR_HASH));\\n    }\\n\\n    function getRewardDistributorV2() internal view returns (IRewardDistributorV2) {\\n        return IRewardDistributorV2(contractRegistry.getContractAddress(REWARD_DISTRIBUTOR_HASH));\\n    }\\n\\n    function getLendingCalculator() internal view returns (ILendingCalculatorV2) {\\n        return ILendingCalculatorV2(contractRegistry.getContractAddress(LENDING_CALCULATOR_HASH));\\n    }\\n\\n    function getLendingExtensionController() internal view returns (ILendingLoanExtensionControllerV2) {\\n        return ILendingLoanExtensionControllerV2(contractRegistry.getContractAddress(LENDING_EXTENSION_CONTROLLER_HASH));\\n    }\\n\\n    function getPlatformView() internal view returns (IPlatformView) {\\n        return IPlatformView(contractRegistry.getContractAddress(PLATFORM_VIEW_HASH));\\n    }\\n\\n    function getPriceCalculator(address token) internal view returns (IPriceCalculator) {\\n        return IPriceCalculator(contractRegistry.getPriceCalculator(token));\\n    }\\n\\n    function getPancakeRouter() internal view returns (IPancakeRouter02) {\\n        return IPancakeRouter02(contractRegistry.getContractAddress(PANCAKE_ROUTER_HASH));\\n    }\\n\\n    function getPrimaryStableCoin() internal view returns (IERC20) {\\n        return IERC20(contractRegistry.getContractAddress(PRIMARY_STABLECOIN_HASH));\\n    }\\n\\n    function getPrimaryStableCoinMetadata() internal view returns (IERC20Metadata) {\\n        return IERC20Metadata(contractRegistry.getContractAddress(PRIMARY_STABLECOIN_HASH));\\n    }\\n\\n    function getLendingPlatformView() internal view returns (ILendingPlatformViewV2) {\\n        return ILendingPlatformViewV2(contractRegistry.getContractAddress(LENDING_HASH));\\n    }\\n\\n    function getPlatformViewV2() internal view returns (IPlatformViewV2) {\\n        return IPlatformViewV2(contractRegistry.getContractAddress(PLATFORM_VIEW_HASH));\\n    }\\n\\n    function getMetFiQuiz() internal view returns (IMetFiQuiz) {\\n        return IMetFiQuiz(contractRegistry.getContractAddress(METFI_QUIZ_HASH));\\n    }\\n\\n    function getMetFiQuizV2() internal view returns (IMetFiQuizV2) {\\n        return IMetFiQuizV2(contractRegistry.getContractAddress(METFI_QUIZ_HASH));\\n    }\\n\\n    function getBoughtBonusInfo() internal view returns (IBoughtBonusInfo) {\\n        return IBoughtBonusInfo(contractRegistry.getContractAddress(METABID_BOUGHT_BONUS));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/MetFiContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport {IContractRegistry} from \\\"contracts/interfaces/core/IContractRegistry.sol\\\";\\n\\nimport {ContractRegistryUserV4} from \\\"contracts/base/ContractRegistryUserV4.sol\\\";\\nimport {ILostTokenProviderV2} from \\\"contracts/interfaces/utils/ILostTokenProviderV2.sol\\\";\\n\\n/// @title MetFiContract\\n/// @author MetFi\\n/// @notice Base contract for all MetFi contracts\\nabstract contract MetFiContractV3 is ContractRegistryUserV4, ILostTokenProviderV2 {\\n    using SafeERC20 for IERC20;\\n    using Address for address payable;\\n\\n    //-------------------------------------------------------------------------\\n\\n    constructor(IContractRegistry _contractRegistry) ContractRegistryUserV4(_contractRegistry) {}\\n\\n    //-------------------------------------------------------------------------\\n\\n    /// @param token - address of the token to be transferred\\n    /// @param amount - amount of the token to be transferred\\n    /// @param receiver - address of the receiver\\n    /// @notice This function is used to transfer tokens that were accidentally sent to the contract\\n    /// @notice Checks are not needed, because only the treasury can call this function\\n    /// @dev Must be overridden, if the contract has any tokens that are locked\\n    function getLostERC20Tokens(IERC20 token, uint256 amount, address receiver) external virtual override {\\n        onlyCoinMaster();\\n\\n        token.safeTransfer(receiver, amount);\\n    }\\n\\n    /// @param amount - amount of the native token to be transferred\\n    /// @param receiver - address of the receiver\\n    /// @notice This function is used to transfer native tokens that were accidentally sent to the contract\\n    /// @notice Checks are not needed, because only the treasury can call this function\\n    /// @dev Must be overridden, if the contract has any tokens that are locked\\n    function getLostNativeTokens(uint256 amount, address payable receiver) external virtual override {\\n        onlyCoinMaster();\\n\\n        receiver.sendValue(amount);\\n    }\\n\\n    /// @param nft - address of the nft to be transferred\\n    /// @param tokenId - id of the nft to be transferred\\n    /// @param receiver - address of the receiver\\n    /// @notice This function is used to transfer NFTs that were accidentally sent to the contract\\n    /// @notice Checks are not needed, because only the treasury can call this function\\n    /// @dev Must be overridden, if the contract has any NFTs that are locked\\n    function getLostERC721Tokens(IERC721 nft, uint256 tokenId, address receiver) external virtual override {\\n        onlyCoinMaster();\\n\\n        nft.safeTransferFrom(address(this), receiver, tokenId);\\n    }\\n\\n    //-------------------------------------------------------------------------\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) internal pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/MetFiErrorsV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\n/// @title MetFiErrorsV3\\n/// @author MetFi\\n/// @notice Common errors for MetFi contracts\\nabstract contract MetFiErrorsV3 {\\n    // Access control errors\\n    error BlacklistedAddress(address blacklisted);\\n    error FailsafeEnabled();\\n    error OnlyCoinMaster();\\n    error OnlyMetFiNFT();\\n    error OnlyRealmGuardian();\\n    error OnlyRewardDistributor();\\n    error OnlyRouter();\\n    error OnlyStakingManager();\\n    error OnlyStakingManagerOrTokenCollector();\\n    error OnlyTokenCollector();\\n    error OnlyTreasury();\\n    error NotEOA();\\n    error FunctionDisabled();\\n    error NotOwnerOfNFT(uint256 nftId, address expectedOwner, address actualOwner);\\n\\n    error AmountTooLow(uint256 have, uint256 want);\\n    error InsufficientAllowance(uint256 have, uint256 want);\\n    error InsufficientBalance(uint256 have, uint256 want);\\n    error InsufficientBNBFee(uint256 have, uint256 want);\\n    error InvalidAmount();\\n    error InvalidTokenId();\\n\\n    error InvalidArrayLength(uint256 have, uint256 want);\\n\\n    error NullAddress();\\n    error InvalidAddress();\\n    error InvalidAddressWithParams(address have, address want);\\n    error InvalidContractAddress(address have, address want);\\n    error InvalidSender(address have, address want);\\n    error InvalidToken(address have, address want);\\n\\n    error METFINotWithdrawable();\\n\\n    error NFTLiquidated();\\n    error NFTInLiquidation();\\n\\n    error NotInitialized();\\n    error NotTokenOwner(uint256 nftId, address have, address want);\\n    error NotApproved();\\n\\n    error FailedInnerCall();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/config/IUserConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IUserConfig {\\n    event UserConfigUintValueUpdated(address indexed user, string indexed key, uint256 old_value, uint256 new_value);\\n    event UserConfigStringValueUpdated(address indexed user, string indexed key, string old_value, string new_value);\\n    event AllowedStringKeyAdded(string key);\\n    event AllowedUintKeyAdded(string key);\\n\\n    struct UserConfigUintValue {\\n        string key;\\n        uint256 value;\\n    }\\n\\n    struct UserConfigStringValue {\\n        string key;\\n        string value;\\n    }\\n\\n    struct UserConfigValues {\\n        UserConfigUintValue[] uintValues;\\n        UserConfigStringValue[] stringValues;\\n    }\\n\\n    function getAllUserConfigValues(uint256 nftId) external view returns (UserConfigValues memory values);\\n    function getUserConfigUintValue(uint256 nftId, string memory key) external view returns (uint256 value);\\n    function getUserConfigStringValue(uint256 nftId, string memory key) external view returns (string memory value);\\n\\n    function setUserConfigUintValue(uint256 nftId, string memory key, uint256 value) external;\\n    function setUserConfigStringValue(uint256 nftId, string memory key, string memory value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/IAccountToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IAccountToken {\\n    enum LiquidationStatus {\\n        NOT_REQUESTED,\\n        IN_PROGRESS,\\n        AVAILABLE\\n    }\\n\\n    struct LiquidationInfo {\\n        LiquidationStatus status;\\n        uint256 requestTime;\\n        uint256 availableTime;\\n        uint256 expirationTime;\\n    }\\n\\n    event AccountCreated(\\n        address indexed to, uint256 indexed tokenId, uint256 indexed directUplink, uint256 apy, string referralLink\\n    );\\n    event ReferralLinkChanged(uint256 indexed tokenId, string oldLink, string newLink);\\n    event AccountLiquidated(uint256 indexed nftId);\\n    event AccountLiquidationStarted(uint256 indexed nftId);\\n    event AccountLiquidationCanceled(uint256 indexed nftId);\\n    event AccountUpgraded(uint256 indexed nftId, uint256 indexed level, uint256 apy);\\n\\n    function createAccount(address to, uint256 directUplink, uint256 level, string calldata newReferralLink)\\n        external\\n        returns (uint256);\\n\\n    function setReferralLink(uint256 tokenId, string calldata referralLink) external;\\n\\n    function accountLiquidated(uint256 tokenId) external view returns (bool);\\n\\n    function getAddressNFTs(address userAddress)\\n        external\\n        view\\n        returns (uint256[] memory NFTs, uint256 numberOfActive);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    function upgradeAccountToLevel(uint256 tokenId, uint256 level) external;\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function getAccountLevel(uint256 tokenId) external view returns (uint256);\\n\\n    function getAccountDirectlyEnrolledMembers(uint256 tokenId) external view returns (uint256);\\n\\n    function getAccountReferralLink(uint256 tokenId) external view returns (string memory);\\n\\n    function getAccountByReferral(string calldata referralLink) external view returns (uint256);\\n\\n    function referralLinkExists(string calldata referralCode) external view returns (bool);\\n\\n    function getLevelMatrixParent(uint256, uint256)\\n        external\\n        view\\n        returns (uint256 newParent, uint256[] memory overtakenUsers);\\n\\n    function getDirectUplink(uint256) external view returns (uint256);\\n\\n    function getAverageAPY() external view returns (uint256);\\n\\n    function totalMembers() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getLiquidationInfo(uint256 tokenId) external view returns (LiquidationInfo memory);\\n\\n    function requestLiquidation(uint256 tokenId) external returns (bool);\\n\\n    function liquidateAccount(uint256 tokenId) external;\\n\\n    function cancelLiquidation(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/IContractRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"contracts/interfaces/core/IMatrix.sol\\\";\\nimport \\\"contracts/interfaces/treasury/ILiquidityController.sol\\\";\\nimport \\\"contracts/interfaces/treasury/IBuybackController.sol\\\";\\n\\ninterface IContractRegistry {\\n    function contractAddressExists(bytes32 nameHash) external view returns (bool);\\n    function matrixExists(uint256 level) external view returns (bool);\\n    function liquidityControllerExists(string calldata name) external view returns (bool);\\n    function buybackControllerExists(string calldata name) external view returns (bool);\\n    function priceCalculatorExists(address currency) external view returns (bool);\\n\\n    function getContractAddress(bytes32 nameHash) external view returns (address);\\n    function getMatrix(uint256 level) external view returns (IMatrix);\\n    function getLiquidityController(string calldata name) external view returns (ILiquidityController);\\n    function getBuybackController(string calldata name) external view returns (IBuybackController);\\n    function getPriceCalculator(address currency) external view returns (address);\\n    function isRealmGuardian(address guardianAddress) external view returns (bool);\\n    function isCoinMaster(address masterAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/IMatrix.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IMatrix {\\n    event NodeAdded(uint256 indexed nftId, uint256 indexed parentId, uint256 indexed parentLeg);\\n    event SubtreeNodeAdded(uint256 indexed nftId, uint256 indexed offset, uint256 indexed level);\\n\\n    struct Node {\\n        uint256 ID;\\n        uint256 ParentID;\\n        uint256 L0;\\n        uint256 L1;\\n        uint256 L2;\\n        uint256 parentLeg;\\n    }\\n\\n    function addNode(uint256 nodeId, uint256 parentId) external;\\n    function getDistributionNodes(uint256 nodeId) external view returns (uint256[] memory distributionNodes);\\n    function getUsersInLevels(uint256 nodeId, uint256 numberOfLevels)\\n        external\\n        view\\n        returns (uint256[] memory levels, uint256 totalUsers);\\n    function getSubNodesToLevel(uint256 nodeId, uint256 toDepthLevel)\\n        external\\n        view\\n        returns (Node memory parentNode, Node[] memory subNodes);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/IRewardDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMatrix.sol\\\";\\n\\ninterface IRewardDistributor {\\n    event AccountCreated(uint256 indexed nftId, uint256 indexed parentId);\\n    event AccountUpgraded(uint256 indexed nftId, uint256 indexed level);\\n    event BonusActivated(uint256 indexed nftId);\\n    event AccountLiquidated(uint256 indexed nftId);\\n\\n    event RewardSent(\\n        uint256 indexed nftId,\\n        uint256 indexed from,\\n        uint256 indexed rewardType,\\n        uint256 level,\\n        uint256 matrixLevel,\\n        uint256 amount\\n    );\\n    event MatchingBonusSent(uint256 indexed nftId, uint256 indexed from, uint256 amount);\\n    event FastStartBonusReceived(uint256 indexed nftId, uint256 indexed from, uint256 amount, bool autoClaimed);\\n\\n    struct RewardAccountInfo {\\n        uint256 ID;\\n        uint256 directUplink;\\n        uint256 fastStartBonus;\\n        uint256 receivedMatchingBonus;\\n        uint256 receivedMatrixBonus;\\n        uint64 bonusDeadline;\\n        uint64 activeBonusUsers;\\n        bool bonusActive;\\n        bool accountLiquidated;\\n    }\\n\\n    function getAccountInfo(uint256 nftId) external view returns (RewardAccountInfo memory);\\n    function createAccount(uint256 nftId, uint256 parentId) external;\\n    function accountUpgraded(uint256 nftId, uint256 level) external;\\n    function liquidateAccount(uint256 nftId) external;\\n    function distributeRewards(uint256 distributionValue, uint256 rewardType, uint256 nftId, uint256 level) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/ITokenCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface ITokenCollector {\\n    event CollectedBonusTokens(uint256 busdPrice, uint256 numberOfTokens);\\n    event CollectedTokens(\\n        uint256 busdPrice, uint256 numberOfTokens, uint256 collectionType, uint256 slippageCalculationType\\n    );\\n    event CollectionTypeChanged(uint256 collectionType);\\n    event PriceCalculationTypeChanged(uint256 priceCalculationType);\\n\\n    enum CollectionType {\\n        MINTING,\\n        SWAP\\n    }\\n\\n    enum PriceCalculationType {\\n        TOKEN_PRICE_BASED,\\n        POOL_BASED\\n    }\\n\\n    function getBonusTokens(uint256 busdPrice) external returns (uint256);\\n    function getTokens(uint256 busdPrice, uint256 minTokensOut) external returns (uint256);\\n    function getCollectionType() external view returns (CollectionType);\\n    function getPriceCalculationType() external view returns (PriceCalculationType);\\n    function getAdditionalTokensPercentage() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/ITokenCollectorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ITokenCollector.sol\\\";\\n\\ninterface ITokenCollectorV2 {\\n    event CollectedBonusTokens(uint256 stableCoinPrice, uint256 numberOfTokens);\\n    event CollectedTokens(\\n        uint256 stableCoinPrice, uint256 numberOfTokens, uint256 collectionType, uint256 slippageCalculationType\\n    );\\n    event CollectionTypeChanged(uint256 collectionType);\\n    event PriceCalculationTypeChanged(uint256 priceCalculationType);\\n    event AdditionalTokensPercentageChanged(uint256 additionalTokensPercentage);\\n    event BonusTokenPercentageFromSwapChanged(uint256 bonusTokenPercentageFromSwap);\\n    event BoolValuesChanged(bool fullFromSwap, bool usePool);\\n\\n    enum CollectionType {\\n        SWAP,\\n        POOL\\n    }\\n\\n    enum PriceCalculationType {\\n        TOKEN_PRICE_BASED,\\n        POOL_BASED\\n    }\\n\\n    function getBonusTokens(uint256 stableCoinPrice, uint256 minBonusTokens) external returns (uint256);\\n    function getTokens(uint256 stableCoinPrice, uint256 minTokensOut) external returns (uint256);\\n    function getCollectionType() external view returns (CollectionType);\\n    function getPriceCalculationType() external view returns (PriceCalculationType);\\n    function getAdditionalTokensPercentage() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/ILending.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending contract\\n// @author MetFi\\n// @notice This contract is responsible for managing loans\\ninterface ILending is ILendingStructs {\\n    //----------------- Getters -------------------------------------------------\\n\\n    function getLendingConfiguration() external view returns (LendingConfiguration memory);\\n\\n    function getLoanById(uint256 loanId) external view returns (LoanInfo memory);\\n\\n    //----------------- User functions -------------------------------------------\\n\\n    function createLoan(CreateLoanRequest calldata request) external;\\n\\n    function cancelLoan(uint256 loanId) external;\\n\\n    function fundLoan(FundLoanRequest calldata request) external;\\n\\n    function repayLoan(RepayLoanRequest memory request) external;\\n\\n    function requestLoanExtension(ExtendLoanRequest calldata request) external payable;\\n\\n    function removeFunding(uint256 loanId) external;\\n\\n    function addCollateral(AddCollateralRequest memory request) external;\\n\\n    function liquidateLoanByDeadline(uint256 loanId) external;\\n\\n    //----------------- System functions ------------------------------------------\\n\\n    function extendLoan(ExtendLoanRequest calldata request) external;\\n\\n    function liquidateLoans(uint256[] calldata loanId) external;\\n\\n    function invalidateLoans(uint256[] calldata loanId) external;\\n\\n    function migrateToNewLendingContract(uint256 maxLoansToProcess, address recipient)\\n        external\\n        returns (uint256[] memory);\\n\\n    //----------------- Manager functions ------------------------------------------\\n    function setLendingConfiguration(LendingConfiguration calldata newConfiguration) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/ILendingAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\n// @title MetFi Lending Calculator contract\\n// @author MetFi\\n// @notice This contract is responsible for auctioning liquidated loans\\ninterface ILendingAuction is IERC721Receiver {\\n    //----------------- Events -------------------------------------------------\\n\\n    event AuctionCreated(uint256 indexed auctionId, uint256 indexed tokenId);\\n\\n    event AuctionBid(\\n        uint256 indexed auctionId,\\n        uint256 indexed tokenId,\\n        uint256 oldBid,\\n        address oldBidder,\\n        uint256 newBid,\\n        address newBidder\\n    );\\n\\n    event AuctionClaimed(uint256 indexed auctionId, uint256 indexed tokenId);\\n\\n    event AuctionLiquidated(uint256 indexed auctionId, uint256 indexed tokenId);\\n\\n    event AuctionConfigurationChanged(AuctionConfiguration oldConfiguration, AuctionConfiguration newConfiguration);\\n\\n    //----------------- Structs -------------------------------------------------\\n\\n    struct AuctionInfo {\\n        uint256 auctionId;\\n        uint256 tokenId;\\n        uint256 currentBid;\\n        address currentBidder;\\n        uint256 liquidationDeadline;\\n        uint256 biddingDeadline;\\n        AuctionStage stage;\\n    }\\n\\n    struct AuctionConfiguration {\\n        uint256 minBidIncrement;\\n        uint256 startingPricePercentageOfFullPrice; // 1_000_000 = 100%\\n    }\\n\\n    enum AuctionStage {\\n        CREATED,\\n        CLAIMED,\\n        LIQUIDATED,\\n        MIGRATED\\n    }\\n\\n    //----------------- Getters -------------------------------------------------\\n\\n    function getAuctionInfo(uint256 auctionId) external view returns (AuctionInfo memory);\\n\\n    function getActiveAuctions() external view returns (AuctionInfo[] memory);\\n\\n    function getAuctionsForLiquidation() external view returns (uint256[] memory);\\n\\n    function getAuctionConfiguration() external view returns (AuctionConfiguration memory);\\n\\n    //----------------- User functions -------------------------------------------\\n\\n    function bidOnAuction(uint256 auctionId, uint256 amount) external;\\n\\n    function claimAuction(uint256 auctionId) external;\\n\\n    //----------------- System functions ------------------------------------------\\n\\n    function liquidateAuctions(uint256[] calldata auctionId) external;\\n\\n    function migrateToNewAuctionContract(uint256 maxAuctionsToProcess, address recipient)\\n        external\\n        returns (uint256[] memory);\\n\\n    //----------------- Errors ----------------------------------------------------\\n\\n    error OnlyAuctionManager();\\n    error BidOnOwnBid();\\n    error OnlyLending();\\n    error AuctionDoesNotExist();\\n    error BlacklistedAddress();\\n    error InvalidAddress();\\n    error AuctionNotFinished();\\n    error AuctionFinished();\\n    error NoBids();\\n    error BidTooLow();\\n    error AuctionAlreadyClaimed();\\n    error FailsafeEnabled();\\n    error AuctionNotDisabledBeforeMigration();\\n    error MigrationAlreadyFinished();\\n    error OnlyMetFiNFT();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/ILendingChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending checker contract\\n// @author MetFi\\n// @notice This contract is responsible for checking loans and lending configuration values\\ninterface ILendingChecker is ILendingStructs {\\n    function checkLendingConfig(LendingConfiguration calldata config) external pure;\\n\\n    function checkLoan(CreateLoanRequest calldata request, address msgSender) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/ILendingStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\n// @title MetFi Lending Structs\\n// @author MetFi\\n// @notice This contract is a base for all lending contracts\\ninterface ILendingStructs {\\n    event LoanCreated(uint256 indexed loanId);\\n    event LoanLiquidated(uint256 indexed loanId);\\n    event LoanInvalidated(uint256 indexed loanId);\\n    event LoanFunded(uint256 indexed loanId, address indexed lender, uint256 amount);\\n    event LoanFullyFunded(uint256 indexed loanId);\\n    event LoanFundingRemoved(uint256 indexed loanId, address indexed lender, uint256 amount);\\n    event LoanRepaymentMade(uint256 indexed loanId);\\n    event LoanFullyRepaid(uint256 indexed loanId);\\n    event LoanExtensionRequested(uint256 indexed loanId);\\n    event LoanExtended(uint256 indexed loanId);\\n    event CollateralAdded(uint256 indexed loanId, address indexed currency, uint256 amount);\\n    event LoanMigrated(uint256 indexed loanId);\\n\\n    struct LendingConfiguration {\\n        uint256 maxLoanDuration; // in number of seconds\\n        uint256 minLoanDuration; // in number of seconds\\n        uint256 minLoanAmount; // in SelectedStablecoin\\n        uint256 minFundAmount; // in SelectedStablecoin\\n        uint256 treasuryInterestPercentage; // 10000 = 100%\\n        uint256 foreignCurrencyExchangeFeePercentage; // 1_000_000 = 100%\\n        uint256 fundGracePeriod; // number of seconds, after which lender can remove funds from loan\\n        uint256 liquidationLoanPercentageOfStakedValue; // 1_000_000 = 100%\\n        uint256 warningLoanPercentageOfStakedValue; // 1_000_000 = 100%\\n        uint256 creationLoanPercentageOfStakedValue; // 1_000_000 = 100%\\n        uint256 liquidationGracePeriod; // number of seconds before loan can be liquidated\\n        uint256 maxLiquidationGracePeriod; // number of seconds after which loan can no longer be liquidated\\n        uint256 maxFundingWaitTime; // number of seconds after which not fully funded loan will be invalidated\\n        uint256 repaymentGracePeriod; // number of seconds after loan deadline, when loan can still be repaid without liquidation\\n        uint256 loanExtensionFeeInBNB; // Sent to loanExtensionFeeReceiver\\n        address payable loanExtensionFeeReceiver; // Address that receives loan extension fees\\n        uint256 loanLiquidationFeeInSelectedStablecoin; // Sent to loanLiquidationFeeReceiver as BNB\\n        address loanLiquidationFeeReceiver; // Address that receives loan liquidation fees\\n        uint256[] liquidationFeePayoutCurve; // in percentage points (1000 = 100%) example that follows curve (x*x)/100 : [0,0,0,0,1,2,3,4,6,8,10,12,14,16,19,22,25,28,32,36,40,44,48,52,57,62,67,72,78,84,90,96,102,108,115,122,129,136,144,152,160,168,176,184,193,202,211,220,230,240,250,260,270,280,291,302,313,324,336,348,360,372,384,396,409,422,435,448,462,476,490,504,518,532,547,562,577,592,608,624,640,656,672,688,705,722,739,756,774,792,810,828,846,864,883,902,921,940,960,980,1000]\\n    }\\n\\n    struct CreateLoanRequest {\\n        uint256 duration; // in seconds\\n        uint256 apyPercentage; // 10000 = 100%\\n        uint256 tokenId;\\n        uint256 amount;\\n    }\\n\\n    struct RepayLoanRequest {\\n        uint256 loanId;\\n        uint256 amount; // Max amount to repay\\n    }\\n\\n    struct FundLoanRequest {\\n        uint256 loanId;\\n        uint256 amount; // Max amount to fund\\n    }\\n\\n    struct ExtendLoanRequest {\\n        uint256 oldDeadline;\\n        uint256 newDeadline;\\n        uint256 newInterestRate;\\n        uint256 loanId;\\n        bytes[] lenderSignatures;\\n    }\\n\\n    struct AddCollateralRequest {\\n        uint256 loanId;\\n        address currency;\\n        uint256 amount;\\n    }\\n\\n    struct ExtendLoanLenderApproval {\\n        uint256 oldDeadline;\\n        uint256 newDeadline;\\n        uint256 newInterestRate;\\n        uint256 loanId;\\n    }\\n\\n    struct EarlyLoanRepaymentClaimRequest {\\n        uint256 loanId;\\n        uint256 lenderIndex; // To avoid gas fees\\n    }\\n\\n    struct LoanInfo {\\n        uint256 loanId;\\n        uint256 tokenId;\\n        uint256 apy;\\n        uint256 amount;\\n        address borrower;\\n        uint256 duration;\\n        uint256 deadline;\\n        uint256 amountFunded; // Amount funded by lenders\\n        uint256 repaidAmount; // Amount repaid by borrower\\n        uint256 totalInterest;\\n        uint256 creationTimestamp;\\n        uint256 liquidationTimestamp;\\n        uint256 fundedTimestamp;\\n        uint256 repaidTimestamp;\\n        uint256 totalRewardsAtLastRepaymentTime; // Or at funded time if no repayment has been made\\n        LoanStage stage;\\n        LenderInfo[] lenderInfo;\\n        address[] additionalCollateralAddresses; // additional collateral for loan\\n        uint256[] additionalCollateralAmounts; // additional collateral for loan\\n    }\\n\\n    struct LenderInfo {\\n        address lender;\\n        uint256 shareOfLoan; // Percentage of loan funded by lender 100 % = 100_000_000\\n        uint256 lastFundingTimestamp;\\n    }\\n\\n    struct LiquidationData {\\n        uint256 totalMETFIInLiquidation;\\n        uint256 METFIIn;\\n        uint256 SelectedStablecoinFromMETFI;\\n        uint256[] collateralIn;\\n        uint256[] collateralForTreasury;\\n        uint256[] SelectedStablecoinFromCollateralLiquidation;\\n        uint256[] lenderPayouts;\\n    }\\n\\n    enum LoanStage {\\n        Created, // Create by borrower\\n        Funded, // Completely funded by lenders\\n        Repaid, // Repaid by borrower. All lenders have been repaid and received their interest\\n        Liquidated, // Liquidated by the protocol. All lenders have been repaid and received their interest in proportion to the start time of the loan\\n        Invalidated, // Invalidated by the lender\\n        Migrated // Migrated to a new contract\\n    }\\n\\n    // Access Control\\n    error OnlyLendingManager();\\n    error BlacklistedAddress();\\n    error OnlyLender();\\n    error OnlyMetFiNFT();\\n\\n    // Extend\\n    error NotBorrower();\\n    error InvalidLenderSignatureCount();\\n    error LoanExtensionNotRequested();\\n    error InvalidLoanExtensionRequest();\\n\\n    // Create\\n    error NotTokenOwner();\\n    error LoanAmountTooLow();\\n    error LoanDurationTooLong();\\n    error NotEnoughCollateral();\\n    error LoanDurationTooShort();\\n    error LoanCreationNotAllowed();\\n    error NFTInLiquidation();\\n    error NFTInLiquidated();\\n    error OnlyOneActiveLoanPerNFT();\\n\\n    // Common\\n    error NotApproved();\\n    error InsufficientBalance();\\n    error LoanNotInFundedStage();\\n    error InsufficientAllowance();\\n    error LoanDoesNotExist();\\n    error FailsafeEnabled();\\n    error NotInitialized();\\n    error AlreadyInitialized();\\n    error MoreThanNeededAlreadyRepaid();\\n\\n    // Migration\\n    error LendingNotDisabledBeforeMigration();\\n    error MigrationAlreadyFinished();\\n\\n    // Fund\\n    error AmountTooLow();\\n    error LenderNotFound();\\n    error FundAmountTooLow();\\n    error LoanNotInCreatedStage();\\n    error CannotFundOwnLoan();\\n    error FundingTimeExpired();\\n    error CannotRemoveFundingBeforeGracePeriod(uint256 timestamp);\\n    error LoanExtensionFeeTooLow();\\n\\n    // Collateral\\n    error CollateralCurrencyNotApproved();\\n\\n    // Lending Configuration\\n    error InvalidAddress();\\n    error InvalidLoanDurationConfig();\\n    error InvalidLiquidationGracePeriod();\\n    error InvalidLiquidationFeePayoutCurve();\\n    error InvalidLoanPercentageOfStakedValue();\\n\\n    // Migration\\n    error InvalidToken();\\n    error LoanAlreadyExists();\\n    error InvalidSender();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingCalculatorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructsV2.sol\\\";\\n\\n// @title MetFi Lending Calculator contract\\n// @author MetFi\\n// @notice This contract is responsible for calculating loan values\\ninterface ILendingCalculatorV2 is ILendingStructsV2 {\\n    function calculateLoanPercentageOfCollateralValue(\\n        uint256 tokenId,\\n        uint256 outstandingAmountSelectedStablecoin,\\n        address[] calldata additionalCollateralAddresses,\\n        uint256[] calldata additionalCollateralAmounts\\n    ) external view returns (uint256);\\n\\n    function calculateLoanPercentageOfStakedMETFIValue(uint256 outstandingLoanAmount, uint256 tokenId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function calculateInterest(uint256 amount, uint256 apy, uint256 duration) external pure returns (uint256);\\n\\n    function checkLoanForInvalidation(LoanInfoV2 calldata loanInfo) external view returns (bool);\\n\\n    function checkLoanForLiquidationByCollateral(LoanInfoV2 calldata loanInfo) external view returns (bool);\\n\\n    function checkLoanForLiquidationByDeadline(LoanInfoV2 calldata loanInfo) external view returns (bool);\\n\\n    function calculateLiquidationData(LoanInfoV2 calldata loanInfo)\\n        external\\n        view\\n        returns (LiquidationDataV2 memory, bool);\\n\\n    function calculateCurrentTotalNFTRewards(uint256 tokenId) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForMETFI(uint256 mfiAmount) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForToken(uint256 tokenId) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForLoan(uint256 loanId) external view returns (uint256);\\n\\n    function calculateSelectedStablecoinValueOf(address currency, uint256 amount) external view returns (uint256);\\n\\n    function calculateMETFIValueOf(address currency, uint256 amount) external view returns (uint256);\\n\\n    function calculateNewLeverageIndexForLoanAndCollateral(LoanInfoV2 calldata loan, address currency, uint256 amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function calculateMaxLoanAmountForMETFIAndCollateral(\\n        uint256 mfiAmount,\\n        address[] calldata additionalCollateralAddresses,\\n        uint256[] calldata additionalCollateralAmounts,\\n        address newCollateralAddress,\\n        uint256 newCollateralAmount\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingCheckerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"../ILendingStructs.sol\\\";\\nimport \\\"../ILendingChecker.sol\\\";\\n\\n// @title MetFi Lending checker contract\\n// @author MetFi\\n// @notice This contract is responsible for checking loans and lending configuration values\\ninterface ILendingCheckerV2 is ILendingChecker {\\n    error InvalidTreasuryInterestPercentage();\\n    error InvalidForeignCurrencyExchangeFeePercentage();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingLoanExtensionControllerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructsV2.sol\\\";\\n\\n// @title MetFi Lending Extension contract V2\\n// @author MetFi\\n// @notice This contract is responsible for EIP712 signatures for loan extensions\\ninterface ILendingLoanExtensionControllerV2 is ILendingStructsV2 {\\n    function checkLenderSignatures(ExtendLoanRequestV2 calldata request, LenderInfo[] calldata lenders) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingPlatformViewV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructsV2.sol\\\";\\n\\n// @title MetFi Lending contract\\n// @author MetFi\\n// @notice This contract is responsible for managing loans\\ninterface ILendingPlatformViewV2 is ILendingStructsV2 {\\n    function borrowersLoans(address borrower, uint256 index) external view returns (uint256);\\n\\n    function getLoanById(uint256 loanId) external view returns (LoanInfoV2 memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingStructsV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"../ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending Structs\\n// @author MetFi\\n// @notice This contract is a base for all lending contracts\\ninterface ILendingStructsV2 is ILendingStructs {\\n    error InvalidOldDeadline();\\n\\n    struct LiquidationDataV2 {\\n        uint256 totalMETFIInLiquidation;\\n        uint256 METFIIn;\\n        uint256 SelectedStablecoinFromMETFI;\\n        uint256 loanLiquidationFeeInSelectedStablecoin;\\n        uint256[] collateralIn;\\n        uint256[] collateralForTreasury;\\n        uint256[] SelectedStablecoinFromCollateralLiquidation;\\n        uint256[] lenderPayouts;\\n    }\\n\\n    struct LoanInfoV2 {\\n        uint256 loanId;\\n        uint256 tokenId;\\n        uint256 apy;\\n        uint256 amount;\\n        address borrower;\\n        uint256 duration;\\n        uint256 deadline;\\n        uint256 amountFunded; // Amount funded by lenders\\n        uint256 repaidAmount; // Amount repaid by borrower\\n        uint256 totalInterest;\\n        uint256 creationTimestamp;\\n        uint256 liquidationTimestamp;\\n        uint256 fundedTimestamp;\\n        uint256 repaidTimestamp;\\n        uint256 totalRewardsAtLastRepaymentTime; // Or at funded time if no repayment has been made\\n        uint256 lowestShareOfLoan;\\n        LoanStage stage;\\n        LenderInfo[] lenderInfo;\\n        address[] additionalCollateralAddresses; // additional collateral for loan\\n        uint256[] additionalCollateralAmounts; // additional collateral for loan\\n    }\\n\\n    struct ExtendLoanRequestV2 {\\n        uint256 oldDeadline;\\n        uint256 newDeadline;\\n        uint256 newInterestRate;\\n        uint256 loanId;\\n        uint256 nonce;\\n        bytes[] lenderSignatures;\\n    }\\n\\n    struct ExtendLoanLenderApprovalV2 {\\n        uint256 oldDeadline;\\n        uint256 newDeadline;\\n        uint256 newInterestRate;\\n        uint256 nonce;\\n        uint256 loanId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"contracts/interfaces/lending/ILending.sol\\\";\\nimport \\\"./ILendingStructsV2.sol\\\";\\n\\n// @title MetFi Lending contract\\n// @author MetFi\\n// @notice This contract is responsible for managing loans\\ninterface ILendingV2 is ILendingStructsV2 {\\n    error RepaymentAmountTooLow();\\n    error InvalidNonce();\\n\\n    //----------------- Getters -------------------------------------------------\\n\\n    function getLendingConfiguration() external view returns (LendingConfiguration memory);\\n\\n    function getLoanById(uint256 loanId) external view returns (LoanInfoV2 memory);\\n\\n    //----------------- User functions -------------------------------------------\\n\\n    function createLoan(CreateLoanRequest calldata request) external;\\n\\n    function cancelLoan(uint256 loanId) external;\\n\\n    function fundLoan(FundLoanRequest calldata request) external;\\n\\n    function repayLoan(RepayLoanRequest memory request) external;\\n\\n    function requestLoanExtension(ExtendLoanRequest calldata request) external payable;\\n\\n    function removeFunding(uint256 loanId) external;\\n\\n    function addCollateral(AddCollateralRequest memory request) external;\\n\\n    function liquidateLoanByDeadline(uint256 loanId) external;\\n\\n    //----------------- System functions ------------------------------------------\\n\\n    function extendLoan(ExtendLoanRequestV2 calldata request) external;\\n\\n    function liquidateLoans(uint256[] calldata loanId) external;\\n\\n    function invalidateLoans(uint256[] calldata loanId) external;\\n\\n    function migrateToNewLendingContract(uint256 maxLoansToProcess, address recipient)\\n        external\\n        returns (uint256[] memory);\\n\\n    //----------------- Manager functions ------------------------------------------\\n    function setLendingConfiguration(LendingConfiguration calldata newConfiguration) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILendingViewV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructsV2.sol\\\";\\n\\n// @title MetFi Lending View contract\\n// @author MetFi\\n// @notice This contract is a central point for getting information about loans\\ninterface ILendingViewV2 is ILendingStructsV2 {\\n    function getLoanInfo(uint256 loanId) external view returns (LoanInfoV2 memory);\\n\\n    function getLoansByBorrower(address borrower) external view returns (LoanInfoV2[] memory);\\n\\n    function getLoansByLender(address lender) external view returns (LoanInfoV2[] memory);\\n\\n    function getLoanCollateralization(uint256 loanId) external view returns (uint256);\\n\\n    function getActiveLoans() external view returns (LoanInfoV2[] memory);\\n\\n    function getLoanExtensionRequest(uint256 loanId) external view returns (ExtendLoanRequestV2 memory);\\n\\n    function getLoansForLiquidationByCollateralRatio() external view returns (uint256[] memory);\\n\\n    function getLoansForInvalidation() external view returns (uint256[] memory);\\n\\n    function canLoanBeLiquidatedByCollateralRatio(uint256 loanId) external view returns (bool);\\n\\n    function canLoanBeLiquidatedByDeadline(uint256 loanId) external view returns (bool);\\n\\n    function getMaxLoanValueForToken(uint256 tokenId) external view returns (uint256);\\n\\n    function getMaxLoanValueForLoan(uint256 loanId) external view returns (uint256);\\n\\n    function getMaxLoanValueForMETFI(uint256 metfiAmount) external view returns (uint256);\\n\\n    function getNewLeverageIndexForLoanAndCollateral(uint256 loanId, address currency, uint256 amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getSelectedStablecoinValueOf(address currency, uint256 amount) external view returns (uint256);\\n\\n    function getMETFIValueOf(address currency, uint256 amount) external view returns (uint256);\\n\\n    function getRemainingMaxLoanAmount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/lending/v2/ILoanLimiterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ILendingStructsV2.sol\\\";\\n\\n// @title MetFi Lending Limiter contract\\n// @author MetFi\\n// @notice This contract is responsible for limiting loans\\ninterface ILoanLimiterV2 is ILendingStructsV2 {\\n    function canLoanBeCreated(CreateLoanRequest memory loanRequest) external view returns (bool);\\n\\n    function onLoanCreated(uint256 loanId, CreateLoanRequest memory loanRequest) external;\\n\\n    function onLoanFunded(uint256 loanId, uint256 fundedAmount) external;\\n\\n    function onLoanRepaid(uint256 loanId, uint256 repaidAmount) external;\\n\\n    function onLoanExtended(uint256 loanId, ExtendLoanRequestV2 memory extendLoanRequest) external;\\n\\n    function onLoanLiquidated(uint256 loanId) external;\\n\\n    function onLoanInvalidated(uint256 loanId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/metabid/IAuctionDataContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nenum AuctionState {\\n    UNUSED,\\n    ADDED,\\n    FINISHED_NOT_SOLD,\\n    FINISHED_SOLD,\\n    CLAIMED,\\n    CLAIM_EXPIRED\\n}\\n\\ninterface IAuctionDataContract {\\n    event AuctionAdded(string indexed auctionIdExternal, bytes32 indexed auctionHash);\\n    event AuctionFinished(string indexed auctionIdExternal);\\n    event AuctionClaimed(string indexed auctionIdExternal);\\n    event AuctionClaimExpired(string indexed auctionIdExternal);\\n\\n    error NotAuthorizedAdder(address sender);\\n    error InvalidAuctionData();\\n    error ClaimExpired();\\n    error ClaimNotExpired();\\n    error AuctionDoesNotExist();\\n    error AuctionAlreadyAdded();\\n    error AuctionWrongState(AuctionState expectedState, AuctionState actualState);\\n\\n    struct AuctionData {\\n        uint256 prizeId;\\n        uint256 price;\\n        uint256 reservePrice;\\n        uint256 maxBids;\\n        uint256 winner;\\n        uint256 claimExpiration;\\n        bytes32 nonce;\\n        AuctionState state;\\n        string auctionIdExternal;\\n    }\\n\\n    struct AuctionDataHashedFields {\\n        uint256 reservePrice;\\n        uint256 maxBids;\\n        bytes32 nonce;\\n        string auctionIdExternal;\\n        uint256 prizeId;\\n    }\\n\\n    struct AddAuctionData {\\n        string auctionIdExternal;\\n        uint256 prizeId;\\n        bytes32 auctionHash;\\n    }\\n\\n    function addAuction(AddAuctionData calldata addAuctionData) external;\\n\\n    function finishAuction(AuctionData memory auctionData) external;\\n\\n    function claimAuctionReward(string memory auctionIdExternal) external;\\n\\n    function getAuctionById(string memory auctionIdExternal) external view returns (AuctionData memory);\\n\\n    function verifyAuctionHash(AuctionData memory auctionData) external view returns (bool);\\n\\n    function calculateHash(AuctionDataHashedFields memory auctionDataHashedFields) external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/metfi/IMETFI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\n\\nimport \\\"contracts/interfaces/utils/ILostTokenProvider.sol\\\";\\n\\ninterface IMETFI is IERC20, ILostTokenProvider, IERC20Permit {\\n    function burn(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/metfi/IMETFIStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IMETFIStakingPool {\\n    event METFIWithdrawn(address indexed user, uint256 amount);\\n    event METFIWithdrawnForNextStakingPeriod(address indexed user, uint256 amount);\\n    event METFIPercentageForPeriodChanged(uint256 percentage);\\n    event METFIBurnedFromPool(uint256 amount);\\n    event METFIStakingPoolMigrated(address indexed to, uint256 amount);\\n\\n    function withdrawMETFI(address to, uint256 METFIAmount) external;\\n    function withdrawMETFIForNextStakingPeriod() external returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/metfi/IMETFIVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IMETFIVault {\\n    event METFIWithdrawn(address indexed to, uint256 amount);\\n\\n    function withdrawMETFI(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/metfi/ISecurityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface ISecurityProxy {\\n    function validateTransfer(address from, address to, uint256 amount) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pancake/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountOut);\\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountIn);\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pancake/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IPancakeRouter01.sol\\\";\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/platform_view/IPlatformView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"contracts/interfaces/core/ITokenCollector.sol\\\";\\nimport \\\"contracts/interfaces/core/IMatrix.sol\\\";\\nimport \\\"contracts/interfaces/core/IRewardDistributor.sol\\\";\\nimport \\\"contracts/interfaces/config/IUserConfig.sol\\\";\\n\\ninterface IPlatformView {\\n    struct NFTData {\\n        uint256 ID;\\n        uint256 level;\\n        string referralLink;\\n        uint256 directUplink;\\n        uint256 stakedTokens;\\n        IRewardDistributor.RewardAccountInfo rewardingInfo;\\n        uint256[][] usersInLevel;\\n        uint256[] totalUsersInMatrix;\\n        uint256 directlyEnrolledMembers;\\n        uint256 liquidationRequestTime;\\n        uint256 liquidationAvailableTime;\\n        uint256 liquidationExpiredTime;\\n        bool liquidated;\\n        bool stakingPaused;\\n        bool readOnly;\\n        IUserConfig.UserConfigValues userConfigValues;\\n    }\\n\\n    struct TreeNodeData {\\n        NFTData nftData;\\n        IMatrix.Node node;\\n    }\\n\\n    struct PlatformData {\\n        uint256 MFIPrice;\\n        uint256 totalMembers;\\n        uint256 averageAPY;\\n        uint256 treasuryValue;\\n        uint256 treasuryRiskFreeValue;\\n        uint256 stakedTokens;\\n        uint256 valuePerToken;\\n        uint256 backingPerToken;\\n        uint256 nextRebaseAt;\\n        uint256 totalRewardsPaid;\\n        ITokenCollector.CollectionType tokenCollectionType;\\n        ITokenCollector.PriceCalculationType priceCalculationType;\\n        uint256 tokenCollectionPercentage;\\n        uint256 mfiLiquidityReserve;\\n        uint256 stableCoinLiquidityReserve;\\n    }\\n\\n    function getWalletData(address wallet) external view returns (NFTData[] memory);\\n    function getNFTData(uint256 nftId) external view returns (NFTData memory NFT);\\n    function getReferralCodeData(string calldata referralCode) external view returns (NFTData memory);\\n    function referralLinkExists(string calldata referralCode) external view returns (bool);\\n\\n    function getAddressActiveLoanNFTs(address borrower) external view returns (uint256[] memory);\\n\\n    function getMFIPrice() external view returns (uint256);\\n    function getPlatformData() external view returns (PlatformData memory);\\n\\n    function getTreeData(uint256 nftId, uint256 matrixLevel, uint256 toDepthLevel)\\n        external\\n        view\\n        returns (TreeNodeData memory selectedNFT, TreeNodeData[] memory subNFTs);\\n\\n    function stakedTokens(uint256 nftId) external view returns (uint256);\\n    function stakingPaused(uint256 nftId) external view returns (bool);\\n    function stakedTokensForAddress(address wallet) external view returns (uint256);\\n    function getUsersInLevels(uint256 nodeId, uint256 level)\\n        external\\n        view\\n        returns (uint256[] memory levels, uint256 totalUsers);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/platform_view/IPlatformViewV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"contracts/interfaces/core/ITokenCollectorV2.sol\\\";\\nimport \\\"contracts/interfaces/core/IMatrix.sol\\\";\\nimport \\\"contracts/interfaces/core/IRewardDistributor.sol\\\";\\nimport \\\"contracts/interfaces/config/IUserConfig.sol\\\";\\n\\ninterface IPlatformViewV2 {\\n    struct NFTData {\\n        uint256 ID;\\n        uint256 level;\\n        string referralLink;\\n        uint256 directUplink;\\n        uint256 stakedTokens;\\n        IRewardDistributor.RewardAccountInfo rewardingInfo;\\n        uint256[][] usersInLevel;\\n        uint256[] totalUsersInMatrix;\\n        uint256 directlyEnrolledMembers;\\n        uint256 liquidationRequestTime;\\n        uint256 liquidationAvailableTime;\\n        uint256 liquidationExpiredTime;\\n        bool liquidated;\\n        bool stakingPaused;\\n        bool readOnly;\\n        IUserConfig.UserConfigValues userConfigValues;\\n    }\\n\\n    struct TreeNodeData {\\n        NFTData nftData;\\n        IMatrix.Node node;\\n    }\\n\\n    struct PlatformData {\\n        uint256 METFIPrice;\\n        uint256 totalMembers;\\n        uint256 averageAPY;\\n        uint256 treasuryValue;\\n        uint256 treasuryRiskFreeValue;\\n        uint256 stakedTokens;\\n        uint256 valuePerToken;\\n        uint256 backingPerToken;\\n        uint256 nextRebaseAt;\\n        uint256 totalRewardsPaid;\\n        ITokenCollectorV2.CollectionType tokenCollectionType;\\n        ITokenCollectorV2.PriceCalculationType priceCalculationType;\\n        uint256 tokenCollectionPercentage;\\n        uint256 metfiLiquidityReserve;\\n        uint256 stableCoinLiquidityReserve;\\n        bool dynamicStaking;\\n        uint256[] currentStakingMultipliers;\\n        uint256 rebasesUntilNextHalvingOrDistribution;\\n    }\\n\\n    function getWalletData(address wallet) external view returns (NFTData[] memory);\\n    function getNFTData(uint256 nftId) external view returns (NFTData memory NFT);\\n    function getReferralCodeData(string calldata referralCode) external view returns (NFTData memory);\\n    function referralLinkExists(string calldata referralCode) external view returns (bool);\\n\\n    function getAddressActiveLoanNFTs(address borrower) external view returns (uint256[] memory);\\n\\n    function getMETFIPrice() external view returns (uint256);\\n    function getPlatformData() external view returns (PlatformData memory);\\n\\n    function getTreeData(uint256 nftId, uint256 matrixLevel, uint256 toDepthLevel)\\n        external\\n        view\\n        returns (TreeNodeData memory selectedNFT, TreeNodeData[] memory subNFTs);\\n\\n    function stakedTokens(uint256 nftId) external view returns (uint256);\\n    function stakingPaused(uint256 nftId) external view returns (bool);\\n    function stakedTokensForAddress(address wallet) external view returns (uint256);\\n    function getUsersInLevels(uint256 nodeId, uint256 level)\\n        external\\n        view\\n        returns (uint256[] memory levels, uint256 totalUsers);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/quiz/IMetFiQuiz.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\ninterface IMetFiQuiz {\\n    error TicketsExpired();\\n    error NoTicketsBought();\\n    error ContractDisabled();\\n    error RoundStillRunning();\\n    error TicketsNotAnswered();\\n    error RoundInFinalization();\\n    error TicketsAlreadyCorrect();\\n    error RoundCanNotBeFinalized();\\n    error PotSizeCanNotBeRecorded();\\n    error TicketsAlreadyConfirmed();\\n    error RandomNumbersNotReceived();\\n\\n    error RandomNumbersNotRequested();\\n    error AlreadyRequestedRandomNumber();\\n    error OnlyAnswerOracle(address have);\\n    error ReceiverNFTLiquidated(uint256 nftId);\\n    error NotNFTOwner(address have, address want);\\n    error InsufficientInputAmount(uint256 have, uint256 want);\\n    error NotEnoughMETFIInStaking(uint256 have, uint256 want);\\n    error SlippageToleranceTooHigh(uint256 have, uint256 want);\\n    error useMETFIPercentageTooHigh(uint256 have, uint256 want);\\n    error WrongRandomNumbersRequestId(uint256 have, uint256 want);\\n    error LeftOverPotPercentagesTooHigh(uint256 have, uint256 want);\\n    error NotWinnerDiscountPercentageTooHigh(uint256 have, uint256 want);\\n    error METFIAmountTooHigh(uint256 metfiAmount, uint256 maxMETFIAmount);\\n    error DiscountPercentageTooHigh(uint256 index, uint256 have, uint256 want);\\n    error RoundEndingPeriodNotOver(uint256 currentTimestamp, uint256 canRetryAtTimestamp);\\n    error DiscountThresholdsAndDiscountPercentagesLengthMismatch(uint256 tresholdsLength, uint256 percentagesLength);\\n    error DiscountThresholdsNotInIncreasingOrder(\\n        uint256 firstIndex, uint256 firstValue, uint256 secondIndex, uint256 secondValue\\n    );\\n    error DiscountPercentagesNotInIncreasingOrder(\\n        uint256 firstIndex, uint256 firstValue, uint256 secondIndex, uint256 secondValue\\n    );\\n\\n    event PotSizeCalculated(uint256 index, uint256 sizeOfPot);\\n\\n    event TicketsBought(\\n        uint256 indexed nftId,\\n        uint256 indexed roundId,\\n        uint256 indexed batchId,\\n        uint256 numberOfTickets,\\n        uint256 reciever,\\n        uint256 totalPrice\\n    );\\n\\n    event MatrixDistribution(uint256 indexed from, uint256 indexed to, uint256 amount);\\n    event MatchingDistribution(uint256 indexed fromBuyer, uint256 indexed fromUser, uint256 indexed to, uint256 amount);\\n\\n    event TicketsConfirmed(\\n        uint256 indexed nftId,\\n        uint256 indexed roundId,\\n        uint256 indexed batchId,\\n        uint256 numberOfTickets,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    );\\n\\n    event RoundEnded(uint256 indexed roundId);\\n    event RoundEndingRetried(uint256 indexed roundId);\\n    event RoundFinalized(uint256 indexed roundId);\\n    event RandomNumbersReceived(uint256 indexed roundId);\\n\\n    event WinnerSelected(uint256 indexed roundId, uint256 indexed batchId, WinnerInfo winnerInfo);\\n\\n    struct MetFiQuizConfig {\\n        uint256 TicketPrice;\\n        uint256 BNBFeeForSystemOperation;\\n        uint256 LeftOverPotRecyclePercentage; // 1e9 = 100%\\n        uint256 LeftOverPotTreasuryPercentage; // 1e9 = 100%\\n        uint256 SlippageTolerance; // 1e9 = 100%\\n        uint256 NotWinnerDiscountPercentage; // 1e9 = 100%\\n        uint256[] DiscountThresholds;\\n        uint256[] DiscountPercentages; // 1e9 = 100%\\n    }\\n\\n    struct BoughtTicketsInfo {\\n        uint256 batchId;\\n        uint256 nftId;\\n        uint256 roundId;\\n        uint256 batchIdInRound;\\n        uint256 numberOfTickets;\\n        uint256 initialNumberOfTickets;\\n        uint256 startIndex; // Inclusive\\n        uint256 endIndex; // Inclusive\\n        uint256 boughtAtTimestamp;\\n        uint256 spentStablecoin;\\n        uint256 spentMETFI;\\n        uint256 boughtBy;\\n        uint256 usedMETFIPercentage; // 1e9 = 100%\\n        uint256[] positions;\\n        uint256 achievedDiscountPercentage; // 1e9 = 100%\\n        bool answered;\\n        bool correct;\\n    }\\n\\n    struct BoughtTicketsInfoMinimal {\\n        uint256 batchId;\\n        uint256 nftId;\\n        uint256 startIndex; // Inclusive\\n        uint256 endIndex; // Inclusive\\n    }\\n\\n    struct RoundInfo {\\n        uint256 roundId;\\n        uint256 potSizeStableCoin;\\n        uint256 potSizeMETFI;\\n        uint256 paidOutPercentage; // 1e9 = 100%\\n        uint256 numberOfTickets;\\n        uint256 numberOfValidTickets;\\n        WinnerInfo[11] winners;\\n    }\\n\\n    struct WinnerInfo {\\n        uint256 ticketNumber;\\n        uint256 nftId;\\n        uint256 amount;\\n        uint256 stableCoinAmount;\\n        uint256 batchId;\\n        uint256 level;\\n        address owner;\\n        uint96 position;\\n    }\\n\\n    struct BuyTicketsStruct {\\n        uint256 nftId;\\n        uint256 numberOfTickets;\\n        uint256 maxMETFIAmount;\\n        uint256 maxInputAmount;\\n        uint256 receiver;\\n        address paymentCurrency;\\n        uint256 useMETFIPercentage; /* 1e5 = 100% */\\n    }\\n\\n    struct RewardInfo {\\n        uint256[10] receivedMatchingBonusInMatrixLevel;\\n        uint256[10][10] receivedMatrixBonusInNFTLevelPerMatrixLevel;\\n    }\\n\\n    function canRoundBeEnded() external view returns (bool);\\n\\n    function canTicketsBeBought() external view returns (bool);\\n\\n    function canPotSizeBeRecorded() external view returns (bool);\\n\\n    function getRoundInfo(uint256 roundId) external view returns (RoundInfo memory);\\n\\n    function getCurrentRoundInfo() external view returns (RoundInfo memory);\\n\\n    function getConfig() external view returns (MetFiQuizConfig memory);\\n\\n    function canRoundBeFinalized() external view returns (bool);\\n\\n    function getBatchesForNFT(uint256 nftId) external view returns (BoughtTicketsInfo[] memory);\\n\\n    function getTicketsInfo(uint256 batchId) external view returns (BoughtTicketsInfo memory);\\n\\n    function calculateTicketsPrice(\\n        uint256 nftId,\\n        uint256 numberOfTickets,\\n        uint256 useMETFIPercentage,\\n        address selectedCurrency\\n    ) external view returns (uint256 selectedCurrencyAmount, uint256 metfiAmount, uint256 reachedDiscount);\\n\\n    function getRewardInfoForNFT(uint256 nftId) external view returns (RewardInfo memory);\\n    function buyTickets(BuyTicketsStruct memory buyTicketsStruct) external payable;\\n\\n    function retryTicketBatchAnswer(uint256 batchId) external;\\n\\n    function recordAnswer(uint256 batchId, bool correct) external payable;\\n\\n    function endRound() external payable;\\n\\n    function recordMinPotSizeCalculation() external payable;\\n\\n    function finalizeRound() external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/quiz/IMetFiQuizV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport {IMetFiQuizV2Structs} from \\\"contracts/interfaces/quiz/IMetFiQuizV2Structs.sol\\\";\\n\\ninterface IMetFiQuizV2 is IMetFiQuizV2Structs {\\n    function buyTickets(BuyTicketsWithOptions memory buyTicketsStruct) external payable;\\n\\n    function getConfigV2() external view returns (MetFiQuizConfigV2 memory);\\n\\n    function canRoundBeEnded() external view returns (bool);\\n\\n    function canTicketsBeBought() external view returns (bool);\\n\\n    function canRandomNumbersBeRequested() external view returns (bool);\\n\\n    function canPotSizeBeRecorded() external view returns (bool);\\n\\n    function getRoundInfo(uint256 roundId) external view returns (RoundInfo memory);\\n\\n    function getCurrentRoundInfo() external view returns (RoundInfo memory);\\n\\n    function getConfig() external view returns (MetFiQuizConfig memory);\\n\\n    function canRoundBeFinalized() external view returns (bool);\\n\\n    function getBatchesForNFT(uint256 nftId) external view returns (BoughtTicketsInfo[] memory);\\n\\n    function getTicketsInfo(uint256 batchId) external view returns (BoughtTicketsInfo memory);\\n\\n    function calculateTicketsPrice(\\n        uint256 nftId,\\n        uint256 numberOfTickets,\\n        uint256 useMETFIPercentage,\\n        address selectedCurrency\\n    ) external view returns (uint256 selectedCurrencyAmount, uint256 metfiAmount, uint256 reachedDiscount);\\n\\n    function getRewardInfoForNFT(uint256 nftId) external view returns (RewardInfo memory);\\n    function buyTickets(BuyTicketsStruct memory buyTicketsStruct) external payable;\\n\\n    function retryTicketBatchAnswer(uint256 batchId) external;\\n\\n    function recordAnswer(uint256 batchId, bool correct) external payable;\\n\\n    function endRound() external payable;\\n\\n    function recordMinPotSizeCalculation() external payable;\\n\\n    function finalizeRound() external payable;\\n\\n    function requestRandomNumbers() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/quiz/IMetFiQuizV2Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\ninterface IMetFiQuizV2Structs {\\n    error InvalidNFTId();\\n    error TicketsExpired();\\n    error NoTicketsBought();\\n    error ContractDisabled();\\n    error RoundStillRunning();\\n    error TicketsNotAnswered();\\n    error RoundInFinalization();\\n    error InvalidReceiverInfo();\\n    error TicketsAlreadyCorrect();\\n    error RoundCanNotBeFinalized();\\n    error PotSizeCanNotBeRecorded();\\n    error TicketsAlreadyConfirmed();\\n    error RandomNumbersNotReceived();\\n    error RandomNumbersNotRequested();\\n    error AlreadyReceivedRandomNumber();\\n    error AlreadyRequestedRandomNumber();\\n    error OnlyAnswerOracle(address have);\\n    error JackpotRandomNumberNotReceived();\\n    error ReceiverNFTLiquidated(uint256 nftId);\\n    error NotNFTOwner(address have, address want);\\n    error InsufficientInputAmount(uint256 have, uint256 want);\\n    error NotEnoughMETFIInStaking(uint256 have, uint256 want);\\n    error SlippageToleranceTooHigh(uint256 have, uint256 want);\\n    error useMETFIPercentageTooHigh(uint256 have, uint256 want);\\n    error WrongRandomNumbersRequestId(uint256 have, uint256 want);\\n    error LeftOverPotPercentagesTooHigh(uint256 have, uint256 want);\\n    error NotWinnerDiscountPercentageTooHigh(uint256 have, uint256 want);\\n    error NextRoundPercentageTooHigh(uint256 have, uint256 want);\\n    error METFIAmountTooHigh(uint256 metfiAmount, uint256 maxMETFIAmount);\\n    error DiscountPercentageTooHigh(uint256 index, uint256 have, uint256 want);\\n    error RetryDelayNotOver(uint256 currentTimestamp, uint256 availableTimestamp);\\n    error WrongRandomNumbersRequestIdV2(uint256 have, uint256 want1, uint256 want2);\\n    error RoundEndingPeriodNotOver(uint256 currentTimestamp, uint256 canRetryAtTimestamp);\\n    error NotEnoughTicketsForCreatedPlankton(uint256 createdPlanktons, uint256 numberOfTickets);\\n    error DiscountThresholdsAndDiscountPercentagesLengthMismatch(uint256 tresholdsLength, uint256 percentagesLength);\\n    error DiscountThresholdsNotInIncreasingOrder(\\n        uint256 firstIndex, uint256 firstValue, uint256 secondIndex, uint256 secondValue\\n    );\\n    error DiscountPercentagesNotInIncreasingOrder(\\n        uint256 firstIndex, uint256 firstValue, uint256 secondIndex, uint256 secondValue\\n    );\\n\\n    event PotSizeCalculated(uint256 index, uint256 sizeOfPot);\\n\\n    event JackpotRandomNumberReceived(uint256 indexed roundId);\\n    event JackpotRandomNumberRequested(uint256 indexed roundId, uint256 requestId);\\n    event RandomNumbersRequested(uint256 indexed roundId, uint256 requestId);\\n\\n    event TicketsBought(\\n        uint256 indexed nftId,\\n        uint256 indexed roundId,\\n        uint256 indexed batchId,\\n        uint256 numberOfTickets,\\n        uint256 reciever,\\n        uint256 totalPrice\\n    );\\n\\n    event MatrixDistribution(uint256 indexed from, uint256 indexed to, uint256 amount);\\n    event MatchingDistribution(uint256 indexed fromBuyer, uint256 indexed fromUser, uint256 indexed to, uint256 amount);\\n\\n    event TicketsConfirmed(\\n        uint256 indexed nftId,\\n        uint256 indexed roundId,\\n        uint256 indexed batchId,\\n        uint256 numberOfTickets,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    );\\n\\n    event RoundEnded(uint256 indexed roundId);\\n    event RoundEndingRetried(uint256 indexed roundId);\\n    event RoundFinalized(uint256 indexed roundId);\\n    event RandomNumbersReceived(uint256 indexed roundId);\\n\\n    event WinnerSelected(uint256 indexed roundId, uint256 indexed batchId, WinnerInfo winnerInfo);\\n\\n    struct MetFiQuizConfig {\\n        uint256 TicketPrice;\\n        uint256 BNBFeeForSystemOperation;\\n        uint256 LeftOverPotRecyclePercentage; // 1e9 = 100%\\n        uint256 LeftOverPotTreasuryPercentage; // 1e9 = 100%\\n        uint256 SlippageTolerance; // 1e9 = 100%\\n        uint256 NotWinnerDiscountPercentage; // 1e9 = 100%\\n        uint256[] DiscountThresholds;\\n        uint256[] DiscountPercentages; // 1e9 = 100%\\n    }\\n\\n    struct BoughtTicketsInfo {\\n        uint256 batchId;\\n        uint256 nftId;\\n        uint256 roundId;\\n        uint256 batchIdInRound;\\n        uint256 numberOfTickets;\\n        uint256 initialNumberOfTickets;\\n        uint256 startIndex; // Inclusive\\n        uint256 endIndex; // Inclusive\\n        uint256 boughtAtTimestamp;\\n        uint256 spentStablecoin;\\n        uint256 spentMETFI;\\n        uint256 boughtBy;\\n        uint256 usedMETFIPercentage; // 1e9 = 100%\\n        uint256[] positions;\\n        uint256 achievedDiscountPercentage; // 1e9 = 100%\\n        bool answered;\\n        bool correct;\\n    }\\n\\n    struct BoughtTicketsInfoMinimal {\\n        uint256 batchId;\\n        uint256 nftId;\\n        uint256 startIndex; // Inclusive\\n        uint256 endIndex; // Inclusive\\n    }\\n\\n    struct RoundInfo {\\n        uint256 roundId;\\n        uint256 potSizeStableCoin;\\n        uint256 potSizeMETFI;\\n        uint256 paidOutPercentage; // 1e9 = 100%\\n        uint256 numberOfTickets;\\n        uint256 numberOfValidTickets;\\n        WinnerInfo[11] winners;\\n    }\\n\\n    struct WinnerInfo {\\n        uint256 ticketNumber;\\n        uint256 nftId;\\n        uint256 amount;\\n        uint256 stableCoinAmount;\\n        uint256 batchId;\\n        uint256 level;\\n        address owner;\\n        uint96 position;\\n    }\\n\\n    struct BuyTicketsStruct {\\n        uint256 nftId;\\n        uint256 numberOfTickets;\\n        uint256 maxMETFIAmount;\\n        uint256 maxInputAmount;\\n        uint256 receiver;\\n        address paymentCurrency;\\n        uint256 useMETFIPercentage; /* 1e5 = 100% */\\n    }\\n\\n    struct RewardInfo {\\n        uint256[10] receivedMatchingBonusInMatrixLevel;\\n        uint256[10][10] receivedMatrixBonusInNFTLevelPerMatrixLevel;\\n        uint256 receivedDirectUplinkBonus;\\n    }\\n\\n    struct BuyTicketsWithOptions {\\n        uint256 nftId;\\n        uint256 numberOfTickets;\\n        uint256 maxMETFIAmount;\\n        uint256 maxInputAmount;\\n        uint256 useMETFIPercentage; /* 1e5 = 100% */\\n        uint256 bnbGiftAmount;\\n        address paymentCurrency;\\n        ReceiverInfo receiverInfo;\\n        string newReferralLink;\\n        string referralLink;\\n    }\\n\\n    struct BuyTicketsWithOptionsInternal {\\n        uint256 nftId;\\n        uint256 numberOfTickets;\\n        uint256 maxMETFIAmount;\\n        uint256 maxInputAmount;\\n        uint256 receiver;\\n        uint256 useMETFIPercentage; /* 1e5 = 100% */\\n        uint256 bnbGiftAmount;\\n        address paymentCurrency;\\n    }\\n\\n    struct ReceiverInfo {\\n        uint256 receiverId;\\n        address receiverAddress;\\n        string receiverReferralLink;\\n    }\\n\\n    struct MetFiQuizConfigV2 {\\n        uint256 TicketPrice;\\n        uint256 BNBFeeForSystemOperation;\\n        uint256 LeftOverPotRecyclePercentage; // 1e9 = 100%\\n        uint256 LeftOverPotTreasuryPercentage; // 1e9 = 100%\\n        uint256 SlippageTolerance; // 1e9 = 100%\\n        uint256 NotWinnerDiscountPercentage; // 1e9 = 100%\\n        uint256 MinPotSize;\\n        uint256 CurrencyConversionFee; // 1e9 = 100%\\n        uint256 NextRoundPercentage; // 1e9 = 100%\\n        uint256[] DiscountThresholds;\\n        uint256[] DiscountPercentages; // 1e9 = 100%\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reward_distributor/IBoughtBonusInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\ninterface IBoughtBonusInfo {\\n    event AddedAllowedContract(string contractName);\\n    event RemovedAllowedContract(string contractName);\\n    event SetMatchingBonus(uint256 indexed nftId, uint256 activeUntilTimestamp);\\n    event SetUnstakedBonus(uint256 indexed nftId, uint256 activeUntilTimestamp);\\n\\n    function setMatchingBonusActive(uint256 nftId, uint256 activeUntilTimestamp) external;\\n\\n    function setUnstakedBonusActive(uint256 nftId, uint256 activeUntilTimestamp) external;\\n\\n    function getMatchingBonusActive(uint256 nftId) external view returns (bool);\\n\\n    function getUnstakedBonusActive(uint256 nftId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reward_distributor/IRewardDistributorStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nabstract contract IRewardDistributorStructs {\\n    event AddedAllowedDistributionImplementation(string indexed implementation);\\n    event RemovedAllowedDistributionImplementation(string indexed implementation);\\n    event AddedAllowedPaidInAmountAdderContract(string indexed contractName);\\n    event RemovedAllowedPaidInAmountAdderContract(string indexed contractName);\\n\\n    event AccountCreated(uint256 indexed nftId, uint256 indexed parentId);\\n    event AccountUpgraded(uint256 indexed nftId, uint256 indexed level);\\n    event BonusActivated(uint256 indexed nftId);\\n    event AccountLiquidated(uint256 indexed nftId);\\n\\n    event RewardSent(\\n        uint256 indexed nftId,\\n        uint256 indexed from,\\n        uint256 indexed rewardType,\\n        uint256 level,\\n        uint256 matrixLevel,\\n        uint256 amount\\n    );\\n    event MatchingBonusSent(uint256 indexed nftId, uint256 indexed from, uint256 amount);\\n    event FastStartBonusReceived(uint256 indexed nftId, uint256 indexed from, uint256 amount, bool autoClaimed);\\n\\n    error InvalidPercentage();\\n    error UnknownRewardType(uint256 rewardType);\\n\\n    error BonusTimerAlreadyStarted();\\n\\n    error NotApprovedPaidInAmountAdderContract();\\n    error NotApprovedDistributionImplementation();\\n    error StrategyExecutionFailed(\\n        uint256 distributionValue,\\n        uint256 rewardType,\\n        uint256 nftId,\\n        uint256 level,\\n        bool needsToBeQualified,\\n        address strategyImplementation\\n    );\\n\\n    struct RewardAccountInfo {\\n        uint256 ID;\\n        uint256 directUplink;\\n        uint256 fastStartBonus;\\n        uint256 receivedMatchingBonus;\\n        uint256 receivedMatrixBonus;\\n        uint64 bonusDeadline;\\n        uint64 activeBonusUsers;\\n        bool bonusActive;\\n        bool accountLiquidated;\\n    }\\n\\n    struct RewardAccountInfoV2 {\\n        uint256 ID;\\n        uint256 directUplink;\\n        uint256 fastStartBonus;\\n        uint256 receivedMatchingBonus;\\n        uint256 receivedMatrixBonus;\\n        uint256 lastCheckInTime;\\n        uint64 bonusDeadline;\\n        uint64 activeBonusUsers;\\n        bool bonusActive;\\n        bool accountLiquidated;\\n    }\\n\\n    struct RewardsReceivedInfo {\\n        uint256[10][10] receivedMatchingBonusPerMatrixLevelPerLevel;\\n        uint256[10][10] receivedMatrixBonusPerMatrixLevelPerLevel;\\n        uint256 receivedDirectUplinkBonus;\\n    }\\n\\n    mapping(uint256 => RewardAccountInfoV2) public accounts;\\n    mapping(uint256 => bool) public isPlankton;\\n    uint256 public bonusActivationTimeout;\\n    uint256 public lastCheckedFastStartBonusAccount;\\n    uint256 public activatedFastStartBonusTimerIDCounter;\\n    mapping(uint256 activatedFastStartBonusTimerID => uint256 nftId) public activatedFastStartBonusTimerID;\\n\\n    uint256 public distributionPeriodDuration = 4 weeks;\\n    uint256 public distributionPeriodStart;\\n    uint256 public periodStartId;\\n\\n    mapping(uint256 period => mapping(uint256 nftId => uint256 paidIn)) public paidInAmount;\\n    mapping(uint256 period => mapping(uint256 nftId => uint256 missedAmount)) public missedRewardAmount;\\n\\n    uint256 public nextPeriodRewardThreshold = 100e18;\\n\\n    bytes32[] public allowedDistributionImplementations;\\n    bytes32[] public allowedPaidInAmountAdderContracts;\\n\\n    mapping(bytes32 sourceOfFunds => mapping(uint256 nftId => RewardsReceivedInfo receivedAmounts)) internal\\n        receivedAmounts;\\n\\n    mapping(bytes32 implementationHash => mapping(bytes32 keyHash => bytes value)) public implementationSpecificData;\\n    mapping(bytes32 implementationHash => mapping(bytes32 keyHash => uint256 value)) public\\n        implementationSpecificDataUint;\\n    mapping(bytes32 implementationHash => mapping(bytes32 keyHash => bytes32 value)) public\\n        implementationSpecificDataBytes32;\\n    mapping(bytes32 implementationHash => mapping(uint256 nftId => bytes value)) public implementationNFTSpecificData;\\n    mapping(bytes32 implementationHash => mapping(bytes32 keyHash => mapping(uint256 nftId => bytes value))) public\\n        implementationNFTSpecificKeyedData;\\n    mapping(bytes32 implementationHash => mapping(bytes32 keyHash => mapping(uint256 nftId => uint256 value))) public\\n        implementationNFTSpecificKeyedDataUint;\\n\\n    function _distributionPeriodCounter() internal view returns (uint256) {\\n        if (block.timestamp < distributionPeriodStart) return periodStartId;\\n        else return ((block.timestamp - distributionPeriodStart) / distributionPeriodDuration) + periodStartId + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reward_distributor/IRewardDistributorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport {IRewardDistributorStructs} from \\\"./IRewardDistributorStructs.sol\\\";\\n\\nabstract contract IRewardDistributorV2 is IRewardDistributorStructs {\\n    function getAccountInfo(uint256 nftId) external view virtual returns (RewardAccountInfo memory);\\n    function getAccountInfoV2(uint256 nftId) external view virtual returns (RewardAccountInfoV2 memory);\\n    function createAccount(uint256 nftId, uint256 parentId) external virtual;\\n    function createAccountPlankton(uint256 nftId, uint256 parentId) external virtual;\\n    function accountUpgraded(uint256 nftId, uint256 level) external virtual;\\n    function liquidateAccount(uint256 nftId) external virtual;\\n    function distributeRewards(uint256 distributionValue, uint256 rewardType, uint256 nftId, uint256 level)\\n        external\\n        virtual;\\n\\n    function distributeRewards(\\n        uint256 distributionValue,\\n        uint256 rewardType,\\n        uint256 nftId,\\n        uint256 level,\\n        bool needsToBeQualified\\n    ) external virtual;\\n\\n    function distributeRewardsWithData(\\n        uint256 distributionValue,\\n        uint256 rewardType,\\n        uint256 nftId,\\n        uint256 level,\\n        bool needsToBeQualified,\\n        bytes memory data\\n    ) external virtual;\\n\\n    function distributeRewardsWithCustomStrategy(\\n        uint256 distributionValue,\\n        uint256 rewardType,\\n        uint256 nftId,\\n        uint256 level,\\n        bool needsToBeQualified,\\n        address strategyImplementation\\n    ) external virtual;\\n\\n    function distributeRewardsWithCustomStrategy(\\n        uint256 distributionValue,\\n        uint256 rewardType,\\n        uint256 nftId,\\n        uint256 level,\\n        bool needsToBeQualified,\\n        bytes32 strategyImplementation\\n    ) external virtual;\\n\\n    function distributeRewardsWithCustomStrategy(\\n        uint256 distributionValue,\\n        uint256 rewardType,\\n        uint256 nftId,\\n        uint256 level,\\n        bool needsToBeQualified,\\n        string memory strategyImplementation\\n    ) external virtual;\\n\\n    function addPaidInAmount(uint256 nftId, uint256 amount) external virtual;\\n\\n    function checkIn(uint256 nftId) external virtual;\\n\\n    function isEligibleForRewardsInThisPeriod(uint256 tokenId) external virtual returns (bool);\\n    function distributionPeriodCounter() public view virtual returns (uint256);\\n\\n    function setAccount(uint256 nftId, RewardAccountInfoV2 memory accountInfo) external virtual;\\n\\n    function getReceivedAmountsForSourceAndNftId(bytes32 source, uint256 nftId)\\n        external\\n        view\\n        virtual\\n        returns (RewardsReceivedInfo memory);\\n\\n    function checkFastStartBonusExpiry() external view virtual returns (bool, uint256);\\n    function handleFastStartBonusExpiry(uint256 batchSize) external virtual;\\n    function setLastCheckedFastStartBonusAccount(uint256 newLastCheckedFastStartBonusAccount) external virtual;\\n\\n    function startBonusTimer(uint256 nftId) external virtual;\\n    function setMissedRewardAmount(uint256 nftId, uint256 period, uint256 amount) external virtual;\\n    function setReceivedAmountsForSourceAndNftId(bytes32 source, uint256 nftId, RewardsReceivedInfo memory receivedInfo)\\n        external\\n        virtual;\\n    function setPlankton(uint256 nftId, bool isPlankton) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/router/IRouterV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"contracts/interfaces/core/IRewardDistributor.sol\\\";\\nimport \\\"contracts/interfaces/core/ITokenCollector.sol\\\";\\nimport \\\"contracts/interfaces/core/IMatrix.sol\\\";\\nimport \\\"contracts/interfaces/lending/ILendingStructs.sol\\\";\\n\\ninterface IRouterV3 {\\n    event AccountCreated(\\n        uint256 indexed nftId,\\n        uint256 indexed parentId,\\n        uint256 indexed level,\\n        uint256 additionalTokensPrice,\\n        string referralLink,\\n        uint256 freeMFITokensReceived\\n    );\\n    event AccountLiquidationStarted(uint256 indexed nftId);\\n    event AccountLiquidationCanceled(uint256 indexed nftId);\\n    event AccountLiquidated(uint256 indexed nftId);\\n    event AccountUpgraded(\\n        uint256 indexed nftId, uint256 indexed level, uint256 additionalTokensPrice, uint256 freeMFITokensReceived\\n    );\\n    event TokensStaked(uint256 indexed nftId, uint256 numberOfTokens);\\n    event TokensBought(uint256 indexed nftId, uint256 usdtPrice, uint256 numberOfTokens, uint256 accountLevel);\\n    event AccountOvertaken(uint256 indexed overtakenAccount, uint256 indexed overtakenBy, uint256 indexed level);\\n    event StakingResumed(uint256 indexed nftId);\\n\\n    function resumeStaking(uint256 nftId) external;\\n\\n    function createAccount(\\n        address newOwner,\\n        uint256 level,\\n        uint256 minTokensOut,\\n        uint256 minBonusTokens,\\n        string calldata newReferralLink,\\n        uint256 additionalTokensValue,\\n        bool isCrypto,\\n        address paymentCurrency,\\n        uint256 maxTokensIn\\n    ) external payable returns (uint256);\\n    function createAccountWithReferral(\\n        address newOwner,\\n        string calldata referralId,\\n        uint256 level,\\n        uint256 minTokensOut,\\n        uint256 minBonusTokens,\\n        string calldata newReferralLink,\\n        uint256 additionalTokensValue,\\n        bool isCrypto,\\n        address paymentCurrency,\\n        uint256 maxTokensIn\\n    ) external payable returns (uint256);\\n    function upgradeNFTToLevel(\\n        uint256 nftId,\\n        uint256 minTokensOut,\\n        uint256 minBonusTokens,\\n        uint256 finalLevel,\\n        uint256 additionalTokensValue,\\n        address paymentCurrency,\\n        uint256 maxTokensIn\\n    ) external payable;\\n\\n    function setReferralLink(uint256 nftId, string calldata newReferralLink) external;\\n\\n    function liquidateAccount(uint256 nftId) external;\\n    function cancelLiquidation(uint256 nftId) external;\\n\\n    function stakeTokens(uint256 nftId, uint256 numberOfTokens) external;\\n\\n    function setUserConfigUintValue(uint256 nftId, string memory key, uint256 value) external;\\n    function setUserConfigStringValue(uint256 nftId, string memory key, string memory value) external;\\n\\n    function buyTokens(uint256 nftId, uint256 primaryStableCoinPrice, uint256 minTokensOut, IERC20 paymentCurrency)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/router/IRouterV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport {IRouterV3} from \\\"contracts/interfaces/router/IRouterV3.sol\\\";\\n\\ninterface IRouterV4 is IRouterV3 {\\n    event AddedAllowedComplimentaryPlanktonMintingContract(string indexed mintingContract);\\n    event RemovedAllowedComplimentaryPlanktonMintingContract(string indexed mintingContract);\\n\\n    error OnlyPlankton();\\n    error NotPlankton();\\n    error InvalidNFTId();\\n    error InvalidLevel(uint256 have);\\n    error ValueTooLowForPlankton(uint256 have, uint256 need);\\n    error UserAlreadyOwnPosition();\\n    error InvalidUpgrade(uint256 currentLevel, uint256 finalLevel);\\n\\n    struct LevelCreationAndUpgradesStruct {\\n        uint256 nftId;\\n        uint256 initialLevel;\\n        uint256 levelsPrice;\\n        uint256 finalLevel;\\n        uint256 additionalTokensValue;\\n        uint256 minTokensOut;\\n        uint256 minBonusTokens;\\n        uint256 maxTokensIn;\\n        address paymentCurrency;\\n        bool wasPlankton;\\n    }\\n\\n    struct createAccountStruct {\\n        address newOwner;\\n        uint256 parentId;\\n        uint256 level;\\n        uint256 minTokensOut;\\n        uint256 minBonusTokens;\\n        string newReferralLink;\\n        uint256 additionalTokensValue;\\n        bool isCrypto;\\n        address paymentCurrency;\\n        uint256 maxTokensIn;\\n    }\\n\\n    function createPlanktonAccount(\\n        uint256 nftId,\\n        address newOwner,\\n        string calldata referralId,\\n        string calldata newReferralLink,\\n        address paymentCurrency,\\n        uint256 maxTokensIn,\\n        uint256 additionalTokensValue,\\n        uint256 minTokensOut\\n    ) external payable returns (uint256 newTokenID);\\n\\n    function upgradePlanktonToHigherLevel(\\n        uint256 nftId,\\n        uint256 minTokensOut,\\n        uint256 minBonusTokens,\\n        uint256 finalLevel,\\n        uint256 additionalTokensValue,\\n        address paymentCurrency,\\n        uint256 maxTokensIn\\n    ) external payable;\\n\\n    function createComplimentaryPlanktonAccount(\\n        address newOwner,\\n        string calldata referralId,\\n        string calldata newReferralLink\\n    ) external returns (uint256 newTokenID);\\n\\n    function buyTokens(\\n        uint256 nftId,\\n        uint256 primaryStableCoinPrice,\\n        uint256 minTokensOut,\\n        uint256 maxTokensIn,\\n        address paymentCurrency\\n    ) external payable;\\n\\n    function buyTokens(\\n        uint256 nftId,\\n        uint256 primaryStableCoinPrice,\\n        uint256 minTokensOut,\\n        uint256 maxTokensIn,\\n        address paymentCurrency,\\n        string calldata referralLink,\\n        string calldata newReferralLink\\n    ) external payable;\\n\\n    function stakeTokens(\\n        uint256 nftId,\\n        uint256 numberOfTokens,\\n        string calldata referralLink,\\n        string calldata newReferralLink\\n    ) external;\\n\\n    function checkIn(uint256 nftId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IStakingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IStakingManager {\\n    event StakingAccountCreated(uint256 indexed nftId, uint256 indexed level, uint256 numberOfTokens);\\n    event StakingAccountLiquidated(uint256 indexed nftId, uint256 unstakedTokens);\\n    event TokensAddedToStaking(uint256 indexed nftId, uint256 numberOfTokens);\\n    event StakingAccountUpgraded(uint256 indexed nftId, uint256 indexed level, uint256 numberOfTokens);\\n    event StakingLevelRebased(uint256 indexed level, uint256 lockedTokens);\\n    event StakingRebased(uint256 totalTokens);\\n\\n    function getAccountTokens(uint256 tokenId) external view returns (uint256);\\n    function createStakingAccount(uint256 tokenId, uint256 tokenAmount, uint256 level) external;\\n    function liquidateAccount(uint256 tokenId, address owner) external;\\n    function addTokensToStaking(uint256 tokenId, uint256 numberOfTokens) external;\\n    function upgradeStakingAccountToLevel(uint256 tokenId, uint256 level) external;\\n    function timeToNextRebase() external view returns (uint256);\\n    function nextRebaseAt() external view returns (uint256);\\n    function rebase() external;\\n\\n    function enterLiquidation() external returns (uint256 totalMFIStaked);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IStakingManagerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IStakingManager.sol\\\";\\n\\ninterface IStakingManagerV2 is IStakingManager {\\n    event StakingPaused(uint256 indexed tokenId, uint256 MFIAmount);\\n    event StakingResumed(uint256 indexed tokenId, uint256 MFIAmount);\\n    event ClaimedTokensFromAccount(uint256 indexed tokenId, uint256 MFIAmount);\\n\\n    function isAccountPaused(uint256 tokenId) external view returns (bool);\\n    function pauseStaking(uint256 tokenId) external;\\n    function resumeStaking(uint256 tokenId) external;\\n    function claimTokensFromAccount(uint256 tokenId, uint256 numberOfTokens, address destinationAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IStakingManagerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IStakingManagerV2.sol\\\";\\n\\ninterface IStakingManagerV3 is IStakingManagerV2 {\\n    event StakingPeriodLengthChanged(uint256 oldLength, uint256 newLength);\\n    event AddedAllowedMETFITakingContract(string indexed takingContract);\\n    event RemovedAllowedMETFITakingContract(string indexed takingContract);\\n\\n    function isInDynamicStaking() external view returns (bool);\\n    function rebasesUntilNextHalvingOrDistribution() external view returns (uint256);\\n    function currentStakingMultipliersOrNewTokensPerLevelPerMETFI() external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/IBurnControllerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IBurnControllerV2 {\\n    function burnExisting() external;\\n    function burnWithTransfer(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/IBuybackController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IBuybackController {\\n    event BoughtBackMFI(address indexed token, uint256 tokenAmount, uint256 mfiReceived);\\n\\n    function buyBackMFI(address token, uint256 tokenAmount, uint256 minMFIOut) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/ILiquidityController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface ILiquidityController {\\n    event LiquidityProvided(\\n        address indexed tokenUsed, uint256 mfiProvided, uint256 liquidityTokensProvided, uint256 lpTokensReceived\\n    );\\n    event LiquidityRemoved(\\n        address indexed tokenUsed, uint256 lpTokensRedeemed, uint256 mfiReceived, uint256 liquidityTokensReceived\\n    );\\n\\n    function getLPTokenAddress(address tokenToUse) external view returns (address);\\n    function claimableTokensFromTreasuryLPTokens(address tokenToUse) external view returns (uint256);\\n    function mfiRequiredForProvidingLiquidity(address tokenToUse, uint256 amount, uint256 MFIMin)\\n        external\\n        view\\n        returns (uint256);\\n    function provideLiquidity(address tokenToUse, uint256 amount, uint256 MFIMin) external;\\n    function removeLiquidity(address tokenToUse, uint256 lpTokenAmount, uint256 tokenMin) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/IManageableTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IManageableTreasury {\\n    function manage(address to, address token, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/IPriceCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IPriceCalculator {\\n    function exchangePairSet() external view returns (bool);\\n    function getReserves() external view returns (uint256 calculatedTokenReserve, uint256 reserveTokenReserve);\\n    function getPriceInUSD() external view returns (uint256);\\n    function tokensForPrice(uint256 reserveTokenAmount) external view returns (uint256);\\n    function priceForTokens(uint256 numberOfTokens) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/ITreasuryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface ITreasuryV2 {\\n    enum TokenType {\\n        RESERVE_TOKEN,\\n        LP_TOKEN,\\n        LIQUIDITY_TOKEN\\n    }\\n\\n    event StakingRewardsDistributed(uint256 indexed amount);\\n    event RewardsSent(uint256 nftId, uint256 amount);\\n\\n    function sendReward(uint256 nftId, uint256 amount) external;\\n\\n    function getTotalRewardsPaid() external view returns (uint256);\\n\\n    function getValue() external view returns (uint256 totalValue, uint256 riskFreeValue);\\n\\n    function getTokensForCollector(address token, uint256 amount, address to) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/treasury/IValueCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface IValueCalculator {\\n    function calculateValue() external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/utils/ILostTokenProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\ninterface ILostTokenProvider {\\n    function getLostTokens(address tokenAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/utils/ILostTokenProviderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ILostTokenProviderV2 {\\n    function getLostERC20Tokens(IERC20 token, uint256 amount, address receiver) external;\\n    function getLostERC721Tokens(IERC721 nft, uint256 tokenId, address receiver) external;\\n    function getLostNativeTokens(uint256 amount, address payable receiver) external;\\n}\\n\"\r\n    },\r\n    \"contracts/metabid_verification/AuctionHashVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport {MetFiContractV3} from \\\"contracts/base/MetFiContractV3.sol\\\";\\nimport {IContractRegistry} from \\\"contracts/interfaces/core/IContractRegistry.sol\\\";\\nimport {IAuctionDataContract} from \\\"contracts/interfaces/metabid/IAuctionDataContract.sol\\\";\\n\\ncontract AuctionHashVerifier is MetFiContractV3 {\\n\\n    constructor(IContractRegistry _contractRegistry) MetFiContractV3(_contractRegistry) {}\\n\\n    function getAuctionHash(string memory auctionIdExternal, uint256 reservePrice, uint256 maxBids, bytes32 nonce, uint256 prizeId) public view returns (bytes32) {\\n\\n        IAuctionDataContract.AuctionDataHashedFields memory auctionData;\\n        auctionData.auctionIdExternal = auctionIdExternal;\\n        auctionData.reservePrice = reservePrice;\\n        auctionData.maxBids = maxBids;\\n        auctionData.nonce = nonce;\\n        auctionData.prizeId = prizeId;\\n\\n        return IAuctionDataContract(contractRegistry.getContractAddress(METABID_AUCTION_DATA_CONTRACT)).calculateHash(auctionData);\\n    }\\n\\n    function verifyAuctionHash(string memory auctionIdExternal, uint256 reservePrice, uint256 maxBids, bytes32 nonce, uint256 prizeId, bytes32 hash) external view returns (bool) {\\n\\n        return getAuctionHash(auctionIdExternal, reservePrice, maxBids, nonce, prizeId) == hash;\\n    }\\n}\"\r\n    },\r\n    \"contracts/side_utils/WBNB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.5.0;\\n\\ninterface WBNB {\\n    function deposit() external payable;\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"AmountTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blacklisted\",\"type\":\"address\"}],\"name\":\"BlacklistedAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailsafeEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionDisabled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"InsufficientBNBFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"InvalidAddressWithParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"have\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"want\",\"type\":\"uint256\"}],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"InvalidContractAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"METFINotWithdrawable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTInLiquidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTLiquidated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEOA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"expectedOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actualOwner\",\"type\":\"address\"}],\"name\":\"NotOwnerOfNFT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"NotTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCoinMaster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyMetFiNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRealmGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRewardDistributor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingManagerOrTokenCollector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTokenCollector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTreasury\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"auctionIdExternal\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBids\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prizeId\",\"type\":\"uint256\"}],\"name\":\"getAuctionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getLostERC20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getLostERC721Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getLostNativeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"auctionIdExternal\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBids\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prizeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"verifyAuctionHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AuctionHashVerifier", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000578e948ec7f0fd1182aae4b2480e761b2f765825", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}