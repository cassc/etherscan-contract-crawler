{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/StakeIt_V4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {Initialize} from \\\"./config/initialize.sol\\\";\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract StakeIt_V4 is Initialize {\\n    constructor(\\n        address signer,\\n        address stc_addr,\\n        address[] memory tokenAddress, // 0 - BUSD, 1 - Voucher\\n        bool[] memory isAffRewardEnabled,\\n        address _operatorAddress\\n    ) {\\n        assembly {\\n            sstore(signerAddress.slot, signer)\\n            sstore(STC_Addr.slot, stc_addr)\\n            sstore(operatorAddress.slot, _operatorAddress)\\n        }\\n        BUSD = IERC20(tokenAddress[0]);\\n        VoucherAddr = IERC20(tokenAddress[1]);\\n        currentTokenPoolID = 2;\\n        initPackages();\\n        initPools(tokenAddress, isAffRewardEnabled);\\n        lastRewardPerShareUpdate = block.timestamp;\\n        initLevelRewards();\\n        initLevelsRefferalCount();\\n        initAdminActiveInAllPacks();\\n    }\\n\\n    function addAffsAndDepositToken(\\n        userDetails storage userdetails,\\n        uint tokenPoolID,\\n        Pools memory PoolInfo\\n    ) private {\\n        uint price = PoolInfo.price;\\n\\n        if (PoolInfo.isAffiliateRewardEnabled) {\\n            addAffiliateRewardAmountToTheReffs(\\n                PoolInfo.tokenAddress,\\n                tokenPoolID,\\n                userdetails,\\n                price\\n            );\\n        }\\n        require(\\n            IERC20(PoolInfo.tokenAddress).transferFrom(\\n                msg.sender,\\n                address(this),\\n                price\\n            ),\\n            \\\"Tx f\\\"\\n        );\\n    }\\n\\n    function buyPackage(\\n        Pack pack,\\n        uint256 tokenPoolID,\\n        uint256 packIdToRedeem\\n    ) public ensurePackageStatus(pack) whenNotPaused {\\n        require(pack <= Pack(2), \\\"Invalid pack!\\\");\\n        require(tokenPoolID <= currentTokenPoolID, \\\"Invalid pool ID\\\");\\n        Pools memory PoolInfo = poolInfo[tokenPoolID][pack];\\n        require(PoolInfo.tokenAddress != address(0), \\\"Pool not exist!\\\");\\n\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n\\n        address reffererAddress = userdetails.reffererAddr;\\n        require(reffererAddress != address(0), \\\"0 ref\\\");\\n\\n        userDetails storage userReffererDetails = UserDetails[reffererAddress];\\n\\n        require(userReffererDetails.uplineLength != 0, \\\"Invalid upline!\\\");\\n\\n        if (packIdToRedeem != 0)\\n            require(\\n                userdetails\\n                .packages[packIdToRedeem][pack]\\n                    .isUserAlreadyBoughtThisPackToRedeem[packIdToRedeem][pack],\\n                \\\"User not found in this id!\\\"\\n            );\\n        else {\\n            packIdToRedeem = ++userdetails.userPackId[pack];\\n            userdetails.packages[packIdToRedeem][pack].userPackId++;\\n        }\\n\\n        addAffsAndDepositToken(userdetails, tokenPoolID, PoolInfo);\\n\\n        userdetails.packages[packIdToRedeem][pack].userPackActivedIds[\\n            packIdToRedeem\\n        ][pack] = true;\\n        userdetails\\n        .packages[packIdToRedeem][pack].packageBoughtTime = userdetails\\n        .packages[packIdToRedeem][pack].lastRewardClaimedTime = block.timestamp;\\n        userdetails\\n        .packages[packIdToRedeem][pack].isUserAlreadyBoughtThisPackToRedeem[\\n                packIdToRedeem\\n            ][pack] = true;\\n\\n        if (userdetails.level == 0) userdetails.level = 1;\\n        if (!userdetails.packages[packIdToRedeem][pack].isActive)\\n            userdetails.packages[packIdToRedeem][pack].isActive = true;\\n\\n        emit packageBought(\\n            msg.sender,\\n            pack,\\n            PoolInfo.price,\\n            userdetails.userPackId[pack],\\n            tokenPoolID\\n        );\\n    }\\n\\n    function buyLevel(\\n        Pack pack,\\n        address reffererAddress,\\n        uint tokenPoolID,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public ensure(expiry) ensurePackageStatus(pack) whenNotPaused {\\n        require(pack <= Pack(2), \\\"Invalid pack!\\\");\\n        require(tokenPoolID <= currentTokenPoolID, \\\"Invalid pool ID\\\");\\n        Pools memory PoolInfo = poolInfo[tokenPoolID][pack];\\n        require(PoolInfo.tokenAddress != address(0), \\\"Pool not exist!\\\");\\n        require(\\n            validateBuyLevelHash(\\n                reffererAddress,\\n                msg.sender,\\n                tokenPoolID,\\n                pack,\\n                expiry,\\n                v,\\n                r,\\n                s\\n            ),\\n            \\\"Invalid sig\\\"\\n        );\\n        reffererAddress = reffererAddress == address(0)\\n            ? owner()\\n            : reffererAddress;\\n        userDetails storage userRefferralDetails = UserDetails[msg.sender];\\n        userDetails storage userReffererDetails = UserDetails[reffererAddress];\\n        require(\\n            userRefferralDetails.reffererAddr == address(0),\\n            \\\"User already reffered!\\\"\\n        );\\n        require(userRefferralDetails.level == 0, \\\"User exist!\\\");\\n        require(\\n            reffererAddress == owner() ||\\n                checkRefBoughtAnyPack(reffererAddress),\\n            \\\"Refferer not active in any pack yet!\\\"\\n        );\\n\\n        userReffererDetails.directRefferals.push(msg.sender);\\n\\n        if (reffererAddress != owner())\\n            userRefferralDetails.uplineLength =\\n                userReffererDetails.uplineLength +\\n                1;\\n        else userRefferralDetails.uplineLength = 1;\\n\\n        uint256 userPackId = invokeUserDetails(reffererAddress, pack);\\n\\n        userReffererDetails.reffererAddedLevel[msg.sender] = userReffererDetails\\n            .level;\\n        userReffererDetails.levelRefferredUsers[userReffererDetails.level].push(\\n                msg.sender\\n            );\\n\\n        if (\\n            reffererAddress != owner() &&\\n            userReffererDetails.directRefferals.length ==\\n            levels[userReffererDetails.level]\\n        ) {\\n            userReffererDetails.level <= 11\\n                ? userReffererDetails.level++\\n                : userReffererDetails.level;\\n        }\\n\\n        addAffsAndDepositToken(userRefferralDetails, tokenPoolID, PoolInfo);\\n\\n        setHashCompleted(\\n            prepareBuyLevelHash(\\n                reffererAddress,\\n                msg.sender,\\n                tokenPoolID,\\n                pack,\\n                expiry\\n            ),\\n            true\\n        );\\n        emit LevelBought(\\n            reffererAddress,\\n            msg.sender,\\n            pack,\\n            userPackId,\\n            tokenPoolID\\n        );\\n    }\\n\\n    function invokeUserDetails(\\n        address reffererAddress,\\n        Pack pack\\n    ) private returns (uint256 userPackId) {\\n        userDetails storage userRefferralDetails = UserDetails[msg.sender];\\n\\n        userRefferralDetails.level = 1;\\n        userRefferralDetails.reffererAddr = reffererAddress;\\n        userPackId = ++userRefferralDetails.userPackId[pack];\\n        userRefferralDetails\\n        .packages[userPackId][pack].packageBoughtTime = block.timestamp;\\n        userRefferralDetails.packages[userPackId][pack].isActive = true;\\n        userRefferralDetails\\n        .packages[userPackId][pack].isUserAlreadyBoughtThisPackToRedeem[\\n                userPackId\\n            ][pack] = true;\\n        userRefferralDetails.packages[userPackId][pack].userPackActivedIds[\\n            userPackId\\n        ][pack] = true;\\n    }\\n\\n    function stake(\\n        Pack pack,\\n        uint256 userPackId,\\n        uint256 stcAmountToStake,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public ensure(expiry) {\\n        require(stcAmountToStake > 0, \\\"Invalid STC amount\\\");\\n        require(\\n            validateHash(msg.sender, stcAmountToStake, pack, expiry, v, r, s),\\n            \\\"Invalid signature\\\"\\n        );\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n        Packages storage package = packages[pack];\\n        require(userdetails.reffererAddr != address(0), \\\"zero ref!\\\");\\n        require(\\n            userdetails.packages[userPackId][pack].userPackActivedIds[\\n                userPackId\\n            ][pack],\\n            \\\"User not active in the packId!\\\"\\n        );\\n        require(\\n            userdetails.packages[userPackId][pack].isActive,\\n            \\\"User not found in this packID and pack! stake\\\"\\n        );\\n        require(\\n            (userdetails.packages[userPackId][pack].packageBoughtTime +\\n                package.lifeSpan) > block.timestamp,\\n            \\\"User pack expired, claim capital!\\\"\\n        );\\n        require(stcAmountToStake >= package.minStakeAmount, \\\"min!\\\");\\n\\n        require(\\n            userdetails.packages[userPackId][pack].stakedAmount +\\n                stcAmountToStake <=\\n                package.maxStakeAmount,\\n            \\\"Exceeds max stake amount!\\\"\\n        );\\n\\n        userdetails.packages[userPackId][pack].unClaimedAmt += pendingReward(\\n            pack,\\n            userPackId,\\n            msg.sender\\n        );\\n        userdetails.packages[userPackId][pack].stakedTime = block.timestamp;\\n        userdetails.packages[userPackId][pack].stakedAmount += stcAmountToStake;\\n        userdetails.packages[userPackId][pack].rewardDept = (rewardPerShare *\\n            userdetails.packages[userPackId][pack].stakedAmount);\\n        totalStakedAmount += stcAmountToStake;\\n        package.poolSTCamount += stcAmountToStake;\\n        require(\\n            STC_Addr.transferFrom(msg.sender, address(this), stcAmountToStake),\\n            \\\"Tx failed!\\\"\\n        );\\n\\n        setHashCompleted(\\n            prepareHash(msg.sender, stcAmountToStake, pack, expiry),\\n            true\\n        );\\n        emit Staked(pack, msg.sender, stcAmountToStake);\\n    }\\n\\n    function claimRewardAmount(\\n        Pack pack,\\n        uint256 userPackId,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public ensure(expiry) isDisabled {\\n        require(pack <= Pack(2), \\\"Invalid pack!\\\");\\n        require(\\n            validateClaimHash(pack, msg.sender, expiry, v, r, s),\\n            \\\"Invalid sig\\\"\\n        );\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n        require(\\n            userdetails.packages[userPackId][pack].userPackActivedIds[\\n                userPackId\\n            ][pack],\\n            \\\"User not active in the packId!\\\"\\n        );\\n        require(\\n            userdetails.packages[userPackId][pack].isActive,\\n            \\\"User not found\\\"\\n        );\\n        require(\\n            userdetails.packages[userPackId][pack].stakedAmount > 0,\\n            \\\"User not staked yet!\\\"\\n        );\\n        userdetails.packages[userPackId][pack].lastRewardClaimedTime = block\\n            .timestamp;\\n        uint256 rewardAmount = _pendingReward(pack, userPackId, msg.sender);\\n        rewardAmount += userdetails.packages[userPackId][pack].unClaimedAmt;\\n        userdetails.packages[userPackId][pack].unClaimedAmt = 0;\\n        userdetails\\n        .packages[userPackId][pack].totalRewardClaimed += rewardAmount;\\n        userdetails.packages[userPackId][pack].rewardDept = (rewardPerShare *\\n            userdetails.packages[userPackId][pack].stakedAmount);\\n        require(rewardAmount > 0, \\\"No reward to claim!\\\");\\n        require(STC_Addr.transfer(msg.sender, rewardAmount), \\\"Tx failed!\\\");\\n        setHashCompleted(prepareClaimHash(pack, msg.sender, expiry), true);\\n        emit ClaimedRewardAmount(pack, msg.sender, rewardAmount);\\n    }\\n\\n    function pendingReward(\\n        Pack pack,\\n        uint256 userPackId,\\n        address userAddress\\n    ) public view returns (uint256) {\\n        return (_pendingReward(pack, userPackId, userAddress) +\\n            UserDetails[userAddress].packages[userPackId][pack].unClaimedAmt);\\n    }\\n\\n    function _pendingReward(\\n        Pack pack,\\n        uint256 userPackId,\\n        address userAddress\\n    ) private view returns (uint256) {\\n        if (\\n            UserDetails[userAddress].packages[userPackId][pack].stakedAmount ==\\n            0\\n        ) {\\n            return 0;\\n        }\\n\\n        return\\n            ((rewardPerShare *\\n                UserDetails[userAddress]\\n                .packages[userPackId][pack].stakedAmount) -\\n                UserDetails[userAddress]\\n                .packages[userPackId][pack].rewardDept) / 1e18;\\n    }\\n\\n    function addAffiliateRewardAmountToTheReffs(\\n        address tokenAddress,\\n        uint tokenPoolID,\\n        userDetails storage userRefferralDetails,\\n        uint price\\n    ) private {\\n        address[] memory reffererAddresses = new address[](14);\\n        reffererAddresses[0] = address(0);\\n        uint256 level = 1;\\n        reffererAddresses[1] = userRefferralDetails.reffererAddr;\\n        for (uint8 i = 1; i <= userRefferralDetails.uplineLength; i++) {\\n            userDetails storage userRefferralDetailsForAddingR = UserDetails[\\n                reffererAddresses[i]\\n            ];\\n            if (level == 1) {\\n                uint256 rewardAmount = calculateAffiliateRewardAmount(\\n                    price,\\n                    level\\n                );\\n\\n                if (isPackNotExpired(reffererAddresses[i]))\\n                    userRefferralDetailsForAddingR\\n                        .affiliateLevelRefferredUserReward[tokenAddress][\\n                            tokenPoolID\\n                        ][level] += rewardAmount;\\n\\n                reffererAddresses[i + 1] = userRefferralDetailsForAddingR\\n                    .reffererAddr;\\n\\n                level++;\\n            } else {\\n                if (level + 1 > 13) {\\n                    break;\\n                }\\n\\n                uint256 rewardAmount = calculateAffiliateRewardAmount(\\n                    price,\\n                    level\\n                );\\n\\n                if (isPackNotExpired(reffererAddresses[i]))\\n                    userRefferralDetailsForAddingR\\n                        .affiliateLevelRefferredUserReward[tokenAddress][\\n                            tokenPoolID\\n                        ][level] += rewardAmount;\\n\\n                reffererAddresses[i + 1] = userRefferralDetailsForAddingR\\n                    .reffererAddr;\\n                level <= 12 ? level++ : level;\\n            }\\n        }\\n    }\\n\\n    function claimAffiliateReward(\\n        uint tokenPoolID,\\n        uint256 level,\\n        Pack pack\\n    ) public isDisabled {\\n        require(level != 0 && level <= 12, \\\"Invalid level!\\\");\\n        Pools memory PoolInfo = poolInfo[tokenPoolID][pack];\\n        require(\\n            tokenPoolID <= currentTokenPoolID &&\\n                PoolInfo.tokenAddress != address(0),\\n            \\\"Invalid poolID!\\\"\\n        );\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n        address tokenAddress = PoolInfo.tokenAddress;\\n        uint256 afReward = userdetails.affiliateLevelRefferredUserReward[\\n            tokenAddress\\n        ][tokenPoolID][level];\\n        require(\\n            PoolInfo.isAffiliateRewardEnabled || afReward > 0,\\n            \\\"poolID reward claiming is disabled!\\\"\\n        );\\n\\n        require(userdetails.level >= level, \\\"User not yet reached the level!\\\");\\n\\n        require(afReward > 0, \\\"No rewards in this level!\\\");\\n        userdetails.affiliateLevelRefferredUserReward[tokenAddress][\\n            tokenPoolID\\n        ][level] = 0;\\n        require(\\n            IERC20(tokenAddress).transfer(msg.sender, afReward),\\n            \\\"Tx failed!\\\"\\n        );\\n        emit ClaimedAffiliate(\\n            msg.sender,\\n            tokenAddress,\\n            tokenPoolID,\\n            afReward,\\n            level\\n        );\\n    }\\n\\n    function claimCapital(Pack pack, uint256 userPackId) public {\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n        Packages storage package = packages[pack];\\n        require(\\n            userdetails.packages[userPackId][pack].isActive,\\n            \\\"User not found in this packID and pack! stake\\\"\\n        );\\n        require(\\n            block.timestamp >\\n                userdetails.packages[userPackId][pack].packageBoughtTime +\\n                    package.lifeSpan,\\n            \\\"Pack not yet expired!\\\"\\n        );\\n        require(\\n            pendingReward(pack, userPackId, msg.sender) == 0,\\n            \\\"Claim the pending rewards before capital!\\\"\\n        );\\n        uint256 stkAmnt = userdetails.packages[userPackId][pack].stakedAmount;\\n        userdetails.packages[userPackId][pack].stakedAmount = 0;\\n        userdetails.packages[userPackId][pack].userPackActivedIds[userPackId][\\n                pack\\n            ] = false;\\n        userdetails.packages[userPackId][pack].isActive = false;\\n        userdetails.packages[userPackId][pack].packageBoughtTime = 0;\\n        package.poolSTCamount -= stkAmnt;\\n        totalStakedAmount -= stkAmnt;\\n        require(STC_Addr.transfer(msg.sender, stkAmnt), \\\"Tx failed!\\\");\\n        emit ClaimedCapital(msg.sender, pack, stkAmnt);\\n    }\\n\\n    //let stc = 1\\n    // let busdPerStc = 2\\n    // undefined\\n    // let ratio = stc / busdPerStc\\n    // undefined\\n    // let busdPrice = ratio * 20\\n    // undefined\\n    // busdPrice\\n    // 10\\n\\n    function swapBusdToStc(\\n        uint256 busdAmount,\\n        uint256 busdPrice,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public {\\n        require(busdAmount > 0 && busdPrice > 0, \\\"0 busd\\\");\\n        require(\\n            validateSwapHash(\\n                msg.sender,\\n                busdAmount,\\n                busdPrice,\\n                expiry,\\n                v,\\n                r,\\n                s\\n            ),\\n            \\\"Invalid sig\\\"\\n        );\\n        require(\\n            BUSD.transferFrom(msg.sender, address(this), busdAmount),\\n            \\\"Tx_failed\\\"\\n        );\\n        uint256 stcAmount = (busdAmount * busdPrice) / 1e18;\\n        require(STC_Addr.transfer(msg.sender, stcAmount), \\\"Tx_2 failed\\\");\\n        emit SwapBusdToStc(msg.sender, busdAmount, busdPrice);\\n    }\\n\\n    function calculateAffiliateRewardAmount(\\n        uint256 priceForTokenPack,\\n        uint256 level\\n    ) public view returns (uint256 rewardAmount) {\\n        rewardAmount = ((priceForTokenPack * rewards[level]) / diviser);\\n    }\\n\\n    function viewRefAddedLevel(\\n        address userAddress,\\n        address refAddr\\n    ) public view returns (uint256) {\\n        userDetails storage userdetails = UserDetails[userAddress];\\n        return userdetails.reffererAddedLevel[refAddr];\\n    }\\n\\n    function viewUserLevelDetails(\\n        address userAddress,\\n        uint tokenPoolID,\\n        uint256 level,\\n        Pack pack\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 affiliateRewardForTheLevel,\\n            address[] memory levelRefferedUsers\\n        )\\n    {\\n        require(level <= 12, \\\"Invalid level\\\");\\n        Pools memory PoolInfo = poolInfo[tokenPoolID][pack];\\n        userDetails storage userdetails = UserDetails[userAddress];\\n        affiliateRewardForTheLevel = userdetails\\n            .affiliateLevelRefferredUserReward[PoolInfo.tokenAddress][\\n                tokenPoolID\\n            ][level];\\n        levelRefferedUsers = userdetails.levelRefferredUsers[level];\\n    }\\n\\n    function viewUserPackDetailsByPackId(\\n        address userAddress,\\n        Pack pack,\\n        uint256 userPackId\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 stakedAmount,\\n            uint256 rewardDept,\\n            uint256 unClaimedAmt,\\n            uint256 totalRewardsClaimed,\\n            uint256 packageBoughtTime,\\n            uint256 stakedTime,\\n            bool userPackActivedIds,\\n            bool isUserAlreadyBoughtThisPackToRedeem,\\n            bool isActive\\n        )\\n    {\\n        userDetails storage userdetails = UserDetails[userAddress];\\n        stakedAmount = userdetails.packages[userPackId][pack].stakedAmount;\\n        rewardDept = userdetails.packages[userPackId][pack].rewardDept;\\n        unClaimedAmt = userdetails.packages[userPackId][pack].unClaimedAmt;\\n        totalRewardsClaimed = userdetails\\n        .packages[userPackId][pack].totalRewardClaimed;\\n        packageBoughtTime = userdetails\\n        .packages[userPackId][pack].packageBoughtTime;\\n        stakedTime = userdetails.packages[userPackId][pack].stakedTime;\\n        userPackActivedIds = userdetails\\n        .packages[userPackId][pack].userPackActivedIds[userPackId][pack];\\n        isUserAlreadyBoughtThisPackToRedeem = userdetails\\n        .packages[userPackId][pack].isUserAlreadyBoughtThisPackToRedeem[\\n                userPackId\\n            ][pack];\\n        isActive = userdetails.packages[userPackId][pack].isActive;\\n    }\\n\\n    function viewUserDetails(\\n        address userAddress\\n    )\\n        public\\n        view\\n        returns (\\n            address reffererAddress,\\n            uint256 uplineLength,\\n            uint256 level,\\n            address[] memory directRefs\\n        )\\n    {\\n        userDetails storage userdetails = UserDetails[userAddress];\\n        reffererAddress = userdetails.reffererAddr;\\n        uplineLength = userdetails.uplineLength;\\n        level = userdetails.level;\\n        directRefs = userdetails.directRefferals;\\n    }\\n\\n    function viewUserAffiliateRewardForLevelsForPack(\\n        uint tokenPoolID,\\n        address userAddress,\\n        Pack pack\\n    ) public view returns (uint256[13] memory level) {\\n        level[0] = 0;\\n        require(tokenPoolID <= currentTokenPoolID, \\\"Invalid poolID!\\\");\\n        userDetails storage userdetails = UserDetails[userAddress];\\n        Pools memory PoolInfo = poolInfo[tokenPoolID][pack];\\n        for (uint8 j = 1; j <= 12; j++) {\\n            uint affReward = userdetails.affiliateLevelRefferredUserReward[\\n                PoolInfo.tokenAddress\\n            ][tokenPoolID][j];\\n            level[j] = affReward;\\n        }\\n    }\\n\\n    function viewUserPackCurrentId(\\n        address userAddress,\\n        Pack pack\\n    ) public view returns (uint256) {\\n        return UserDetails[userAddress].userPackId[pack];\\n    }\\n\\n    function viewUserActivePack(\\n        address userAddress,\\n        Pack pack\\n    ) public view returns (uint8) {\\n        if (UserDetails[userAddress].packages[1][pack].isActive) {\\n            return uint8(pack);\\n        } else {\\n            for (uint8 i = 0; i <= 2; i++) {\\n                if (UserDetails[userAddress].packages[i][Pack(i)].isActive) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 3;\\n    }\\n\\n    function checkRefBoughtAnyPack(\\n        address userAddress\\n    ) public view returns (bool) {\\n        uint256 length;\\n        uint8 pack;\\n        for (uint8 i; i <= 2; i++) {\\n            length = UserDetails[userAddress].userPackId[Pack(i)];\\n            if (length > 0) {\\n                pack = i;\\n                break;\\n            }\\n        }\\n        if (length == 0) return false;\\n\\n        for (uint256 j = 1; j <= length; j++) {\\n            if (\\n                UserDetails[userAddress].packages[j][Pack(pack)].isActive &&\\n                (UserDetails[userAddress]\\n                .packages[j][Pack(pack)].packageBoughtTime +\\n                    packages[Pack(pack)].lifeSpan) >\\n                block.timestamp\\n            ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function viewUserPackDetails(\\n        address userAddress,\\n        Pack pack\\n    )\\n        public\\n        view\\n        returns (\\n            string[] memory expired,\\n            bool[] memory isActive,\\n            uint256[] memory ids\\n        )\\n    {\\n        uint256 userPackLength = UserDetails[userAddress].userPackId[pack];\\n        expired = new string[](userPackLength);\\n        isActive = new bool[](userPackLength);\\n        ids = new uint256[](userPackLength);\\n        for (uint256 i = 1; i <= userPackLength; i++) {\\n            // if (i == 0) i = 1;\\n            if (\\n                UserDetails[userAddress].packages[i][pack].isActive &&\\n                (UserDetails[userAddress].packages[i][pack].packageBoughtTime +\\n                    packages[pack].lifeSpan) >\\n                block.timestamp\\n            ) {\\n                expired[i - 1] = \\\"Not expired\\\";\\n                isActive[i - 1] = true;\\n                ids[i - 1] = i;\\n            } else {\\n                expired[i - 1] = \\\"Expired\\\";\\n                isActive[i - 1] = false;\\n                ids[i - 1] = i;\\n            }\\n        }\\n    }\\n\\n    function viewUserActivePacks(\\n        address userAddress\\n    ) public view returns (uint8[3] memory packs, bool[3] memory isActive) {\\n        for (uint8 i = 0; i <= 2; i++) {\\n            if (UserDetails[userAddress].packages[i][Pack(i)].isActive) {\\n                packs[i] = i;\\n                isActive[i] = true;\\n            } else {\\n                packs[i] = 3;\\n                isActive[i] = false;\\n            }\\n        }\\n    }\\n\\n    function isPackNotExpired(address userAddress) public view returns (bool) {\\n        if (userAddress == owner()) return true;\\n        uint256 length;\\n        uint8 pack;\\n        for (uint8 i; i <= 2; i++) {\\n            length = UserDetails[userAddress].userPackId[Pack(i)];\\n            if (length > 0) {\\n                pack = i;\\n                for (uint256 j = 1; j <= length; j++) {\\n                    if (\\n                        (UserDetails[userAddress]\\n                        .packages[j][Pack(pack)].packageBoughtTime +\\n                            packages[Pack(pack)].lifeSpan) > block.timestamp\\n                    ) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function validateHash(\\n        address to,\\n        uint256 stcAmountToStake,\\n        Pack pack,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public view returns (bool result) {\\n        bytes32 hash = prepareHash(to, stcAmountToStake, pack, expiry);\\n        require(!hashStatus[hash], \\\"Hash already exist!\\\");\\n        bytes32 fullMessage = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n        );\\n        address signatoryAddress = ecrecover(fullMessage, v, r, s);\\n        result = signatoryAddress == signerAddress;\\n    }\\n\\n    function prepareHash(\\n        address to,\\n        uint256 stcAmountToStake,\\n        Pack pack,\\n        uint256 blockExpiry\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(to, stcAmountToStake, pack, blockExpiry)\\n            );\\n    }\\n\\n    function validateBuyLevelHash(\\n        address refferAddr,\\n        address referrerdAddr,\\n        uint tokenPoolID,\\n        Pack pack,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool result) {\\n        bytes32 hash = prepareBuyLevelHash(\\n            refferAddr,\\n            referrerdAddr,\\n            tokenPoolID,\\n            pack,\\n            expiry\\n        );\\n        require(!hashStatus[hash], \\\"Hash already exist!\\\");\\n        bytes32 fullMessage = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n        );\\n        address referrerAddr = ecrecover(fullMessage, v, r, s);\\n        result = referrerAddr == referrerdAddr;\\n    }\\n\\n    function validateClaimHash(\\n        Pack pack,\\n        address to,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool result) {\\n        bytes32 hash = prepareClaimHash(pack, to, expiry);\\n        require(!hashStatus[hash], \\\"Hash already exist!\\\");\\n        bytes32 fullMessage = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n        );\\n        address signatoryAddress = ecrecover(fullMessage, v, r, s);\\n        result = signatoryAddress == signerAddress;\\n    }\\n\\n    function prepareBuyLevelHash(\\n        address refferrer,\\n        address referringAddr,\\n        uint tokenPoolID,\\n        Pack pack,\\n        uint256 expiry\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    refferrer,\\n                    referringAddr,\\n                    tokenPoolID,\\n                    pack,\\n                    expiry\\n                )\\n            );\\n    }\\n\\n    function prepareClaimHash(\\n        Pack pack,\\n        address to,\\n        uint256 blockExpiry\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(pack, to, blockExpiry));\\n    }\\n\\n    function validateSwapHash(\\n        address to,\\n        uint256 busdAmount,\\n        uint256 busdPrice,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool result) {\\n        bytes32 hash = prepareSwapHash(to, busdAmount, busdPrice, expiry);\\n        require(!hashStatus[hash], \\\"Hash already exist!\\\");\\n        bytes32 fullMessage = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n        );\\n        address signatoryAddress = ecrecover(fullMessage, v, r, s);\\n        result = signatoryAddress == signerAddress;\\n    }\\n\\n    function prepareSwapHash(\\n        address to,\\n        uint256 busdAmount,\\n        uint256 busdPrice,\\n        uint256 blockExpiry\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(to, busdAmount, busdPrice, blockExpiry));\\n    }\\n\\n    function setHashCompleted(bytes32 hash, bool status) private {\\n        hashStatus[hash] = status;\\n    }\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    function viewadminAddedUserDetails(\\n        address userAddress\\n    )\\n        public\\n        view\\n        returns (\\n            address refererAddress,\\n            Pack[] memory pack,\\n            uint[] memory adminAddedPackID\\n        )\\n    {\\n        AdminAddedUserDetails storage injectADetails = adminAddedUserDetails[\\n            userAddress\\n        ];\\n        refererAddress = injectADetails.refererAddress;\\n        pack = injectADetails.pack;\\n        adminAddedPackID = injectADetails.addedPackIds;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/config/initialize.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {AdminFunctions} from \\\"../admin/AdminFunctions.sol\\\";\\n\\ncontract Initialize is AdminFunctions {\\n    function initPools(\\n        address[] memory tokenAddress,\\n        bool[] memory isAffiliateRewardEnabled\\n    ) internal onlyOwner {\\n        uint packagePrice = 100e18;\\n        for (uint8 i = 0; i < tokenAddress.length; i++) {\\n            uint packID = i == 0 ? 1 : 2;\\n            for (uint8 j = 0; j < 3; j++) {\\n                if (j > 0) (packagePrice = packagePrice * 5);\\n                poolInfo[packID][Pack(j)].tokenAddress = tokenAddress[i];\\n                poolInfo[packID][Pack(j)].price = packagePrice;\\n                poolInfo[packID][Pack(j)]\\n                    .isAffiliateRewardEnabled = isAffiliateRewardEnabled[i];\\n                if (j == 2) {\\n                    packagePrice = 100e18;\\n                }\\n            }\\n        }\\n    }\\n\\n    function initPackages() internal onlyOwner {\\n        uint256 span = 60 days;\\n        uint256 maxStakeAmount = 200e18;\\n        for (uint8 i = 0; i < 3; i++) {\\n            packages[Pack(i)] = Packages({\\n                lifeSpan: span,\\n                minStakeAmount: 0,\\n                maxStakeAmount: maxStakeAmount,\\n                poolSTCamount: 0\\n            });\\n            i == 0 ? span += 305 days : 0;\\n            i == 0 || i > 0\\n                ? (\\n                    i == 1\\n                        ? (maxStakeAmount = 5000e18)\\n                        : (maxStakeAmount = 1000e18)\\n                )\\n                : maxStakeAmount;\\n        }\\n    }\\n\\n    function initAdminActiveInAllPacks() internal onlyOwner {\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n        userdetails.uplineLength = 1;\\n        userdetails.level = 12;\\n        userdetails.reffererAddr = msg.sender;\\n        for (uint256 i = 0; i <= 2; i++) {\\n            if (i <= 2) {\\n                userdetails.packages[i][Pack(i)].isActive = true;\\n            }\\n        }\\n    }\\n\\n    function initLevelRewards() internal onlyOwner {\\n        // downline\\n        rewards[1] = 20e18;\\n        rewards[2] = 10e18;\\n        rewards[3] = 5e18;\\n        rewards[4] = 4e18;\\n        rewards[5] = 4e18;\\n        rewards[6] = 4e18;\\n        rewards[7] = 4e18;\\n        rewards[8] = 4e18;\\n        rewards[9] = 2.5e18;\\n        rewards[10] = 2.5e18;\\n        rewards[11] = 2.5e18;\\n        rewards[12] = 2.5e18;\\n    }\\n\\n    function initLevelsRefferalCount() internal onlyOwner {\\n        levels[1] = 3;\\n        levels[2] = 5;\\n        levels[3] = 7;\\n        levels[4] = 9;\\n        levels[5] = 11;\\n        levels[6] = 13;\\n        levels[7] = 15;\\n        levels[8] = 17;\\n        levels[9] = 19;\\n        levels[10] = 21;\\n        levels[11] = 23;\\n        levels[12] = 24;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/admin/AdminFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {MiddleWares} from \\\"../middlewares/MiddleWares.sol\\\";\\n\\ncontract AdminFunctions is MiddleWares {\\n    function setRewardClaiming(bool isOpen) public onlyOwner {\\n        //Eg := True = enable, False = Disable\\n        rewardClaiming = isOpen;\\n        emit RewardClaiming(isOpen);\\n    }\\n\\n    function setPackageStatus(Pack pack, bool status) public onlyOwner {\\n        //Eg := True = enable, False = Disable\\n        packageStatus[pack] = status;\\n        emit SetPackageStatus(pack, status);\\n    }\\n\\n    function updateRewardPerShare() public onlyOperator {\\n        rewardPerShare += (maxMintStcPerDay * 1e18) / totalStakedAmount;\\n        lastRewardPerShareUpdate = block.timestamp;\\n    }\\n\\n    function updateReward(\\n        uint256 level,\\n        uint256 rewardPercent\\n    ) public onlyOwner {\\n        require(level != 0 && level <= 12, \\\"Invalid level!\\\");\\n        rewards[level] = rewardPercent;\\n        emit RewardUpdated(level, rewardPercent);\\n    }\\n\\n    function updateLevelReferals(\\n        uint256 level,\\n        uint256 refCount\\n    ) public onlyOwner {\\n        require(level != 0 && level <= 12, \\\"Invalid level\\\");\\n        levels[level] = refCount;\\n        emit LevelRefCountUpdated(level, refCount);\\n    }\\n\\n    function updateToken(address tokenAddress, uint256 flag) public onlyOwner {\\n        require(tokenAddress != address(0) && flag != 0, \\\"0\\\");\\n        if (flag == 1) {\\n            BUSD = IERC20(tokenAddress);\\n        } else if (flag == 2) {\\n            STC_Addr = IERC20(tokenAddress);\\n        } else if (flag == 3) {\\n            VoucherAddr = IERC20(tokenAddress);\\n        } else {\\n            revert(\\\"Invalid flag\\\");\\n        }\\n    }\\n\\n    function updatePackage(\\n        Pack pack,\\n        uint256 span,\\n        uint256 minStakeAmount,\\n        uint256 maxStakeAmount,\\n        uint256 poolStcAmount\\n    ) public onlyOwner {\\n        require(span != 0 && maxStakeAmount != 0, \\\"0 pack\\\");\\n        require(pack <= Pack.GROWTH, \\\"Invalid pack\\\");\\n        packages[pack] = Packages({\\n            lifeSpan: span,\\n            minStakeAmount: minStakeAmount,\\n            maxStakeAmount: maxStakeAmount,\\n            poolSTCamount: poolStcAmount\\n        });\\n        emit updatedPackage(pack, span, maxStakeAmount);\\n    }\\n\\n    function updateMaxMintStcPerDay(\\n        uint256 maxMintStcPerDay_\\n    ) public onlyOwner {\\n        require(maxMintStcPerDay_ != 0, \\\"Invalid maxMintStcPerDay_\\\");\\n        maxMintStcPerDay = maxMintStcPerDay_;\\n    }\\n\\n    function updateSigner(address signer) public onlyOwner {\\n        require(signer != address(0), \\\"Signer: wut?\\\");\\n        signerAddress = signer;\\n    }\\n\\n    function updateOperator(address opAddr) public onlyOwner {\\n        require(opAddr != address(0), \\\"Operator: How?\\\");\\n        operatorAddress = opAddr;\\n    }\\n\\n    function updateMaxStakeAmount(\\n        uint256 _maxStakeAmount,\\n        Pack pack\\n    ) public onlyOwner {\\n        require(pack <= Pack(2), \\\"Invalid pack\\\");\\n        require(_maxStakeAmount != 0, \\\"0 max!\\\");\\n        Packages storage package = packages[pack];\\n        package.maxStakeAmount = _maxStakeAmount;\\n        emit UpdatedMaxStakeAmount(_maxStakeAmount, pack);\\n    }\\n\\n    function updateMinStakeAmount(\\n        uint256 _minStakeAmount,\\n        Pack pack\\n    ) public onlyOwner {\\n        require(_minStakeAmount != 0, \\\"0 min!\\\");\\n        Packages storage package = packages[pack];\\n        package.minStakeAmount = _minStakeAmount;\\n        emit UpdateMinStakeAmount(_minStakeAmount, pack);\\n    }\\n\\n    function updateAdminPacks(\\n        Pack pack,\\n        uint256 uplineLength,\\n        uint256 level,\\n        address refAddr\\n    ) public onlyOwner {\\n        require(pack <= Pack(2), \\\"Invalid pack!\\\");\\n        userDetails storage userdetails = UserDetails[msg.sender];\\n        userdetails.uplineLength = uplineLength;\\n        userdetails.level = level;\\n        userdetails.reffererAddr = refAddr;\\n    }\\n\\n    function updateTokenPoolDetails(\\n        address _tokenAddr,\\n        uint poolID,\\n        uint price,\\n        bool _isAffiliateRewardEnabled,\\n        Pack pack\\n    ) public onlyOwner {\\n        require(poolID <= currentTokenPoolID, \\\"Pool not exist!\\\");\\n        Pools storage PoolInfo = poolInfo[poolID][pack];\\n        PoolInfo.tokenAddress = _tokenAddr;\\n        PoolInfo.isAffiliateRewardEnabled = _isAffiliateRewardEnabled;\\n        PoolInfo.price = price;\\n        emit SetTokenPoolStatus(\\n            _tokenAddr,\\n            poolID,\\n            pack,\\n            price,\\n            _isAffiliateRewardEnabled\\n        );\\n    }\\n\\n    function addTokensToPool(\\n        address _tokenAddress,\\n        bool[] memory _isAffiliateRewardEnabled,\\n        uint[] memory price\\n    ) public onlyOwner {\\n        uint cpi = ++currentTokenPoolID;\\n        for (uint8 i; i < 3; i++) {\\n            Pools storage pool_info = poolInfo[cpi][Pack(i)];\\n            pool_info.tokenAddress = _tokenAddress;\\n            pool_info.isAffiliateRewardEnabled = _isAffiliateRewardEnabled[i];\\n            pool_info.price = price[i];\\n        }\\n        emit AddedTokenToPool(\\n            _tokenAddress,\\n            cpi,\\n            price,\\n            _isAffiliateRewardEnabled\\n        );\\n    }\\n\\n    function addUsers(\\n        address[] memory userAddr,\\n        address[] memory refAddr,\\n        Pack[] memory pack\\n    ) public onlyOwner {\\n        require(\\n            userAddr.length == refAddr.length && refAddr.length == pack.length,\\n            \\\"Invalid length!\\\"\\n        );\\n        for (uint8 i; i < userAddr.length; i++) {\\n            require(\\n                userAddr[i] != address(0) && refAddr[i] != address(0),\\n                \\\"0 Addr!\\\"\\n            );\\n            require(UserDetails[refAddr[i]].level != 0, \\\"ref not found!\\\");\\n            userDetails storage user_detail = UserDetails[userAddr[i]];\\n            if (user_detail.level == 0) {\\n                user_detail.level = 1;\\n                user_detail.reffererAddr = refAddr[i];\\n            }\\n\\n            userDetails storage userReffererDetails = UserDetails[\\n                user_detail.reffererAddr\\n            ];\\n\\n            if (user_detail.uplineLength == 0) {\\n                if (user_detail.reffererAddr != owner())\\n                    user_detail.uplineLength =\\n                        userReffererDetails.uplineLength +\\n                        1;\\n                else user_detail.uplineLength = 1;\\n\\n                userReffererDetails.directRefferals.push(userAddr[i]);\\n                userReffererDetails.reffererAddedLevel[\\n                    userAddr[i]\\n                ] = userReffererDetails.level;\\n                userReffererDetails\\n                    .levelRefferredUsers[userReffererDetails.level]\\n                    .push(userAddr[i]);\\n            }\\n\\n            if (\\n                user_detail.reffererAddr != owner() &&\\n                userReffererDetails.directRefferals.length ==\\n                levels[userReffererDetails.level]\\n            ) {\\n                userReffererDetails.level <= 11\\n                    ? userReffererDetails.level++\\n                    : userReffererDetails.level;\\n            }\\n\\n            uint userPackId = ++user_detail.userPackId[pack[i]];\\n            user_detail.packages[userPackId][pack[i]].packageBoughtTime = block\\n                .timestamp;\\n            user_detail.packages[userPackId][pack[i]].isActive = true;\\n            user_detail\\n            .packages[userPackId][pack[i]].isUserAlreadyBoughtThisPackToRedeem[\\n                    userPackId\\n                ][pack[i]] = true;\\n            user_detail.packages[userPackId][pack[i]].userPackActivedIds[\\n                userPackId\\n            ][pack[i]] = true;\\n            AdminAddedUserDetails\\n                storage injectADetails = adminAddedUserDetails[userAddr[i]];\\n            if (injectADetails.refererAddress == address(0))\\n                injectADetails.refererAddress = user_detail.reffererAddr;\\n            injectADetails.pack.push(pack[i]);\\n            injectADetails.addedPackIds.push(userPackId);\\n            userPackId = 0;\\n        }\\n        emit AddUsers(refAddr, userAddr, pack);\\n    }\\n\\n    function withdraw(\\n        address tokenAddress,\\n        address _toUser,\\n        uint256 amount\\n    ) public onlyOwner returns (bool status) {\\n        require(_toUser != address(0), \\\"0\\\");\\n        if (tokenAddress == address(0)) {\\n            require(address(this).balance >= amount, \\\"!\\\");\\n            require(payable(_toUser).send(amount), \\\"f\\\");\\n            return true;\\n        } else {\\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amount);\\n            IERC20(tokenAddress).transfer(_toUser, amount);\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/middlewares/MiddleWares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {StateVariables} from \\\"../config/StateVariables.sol\\\";\\n\\ncontract MiddleWares is StateVariables {\\n    modifier onlyOperator() {\\n        require(msg.sender == operatorAddress, \\\"Operator: wut?\\\");\\n        _;\\n    }\\n\\n    modifier isDisabled() {\\n        require(!rewardClaiming, \\\"disabled!\\\");\\n        _;\\n    }\\n\\n    modifier ensure(uint256 expiry) {\\n        require(expiry > block.timestamp, \\\"Expired!\\\");\\n        _;\\n    }\\n\\n    modifier ensurePackageStatus(Pack pack) {\\n        require(!packageStatus[pack], \\\"This pack is disabled!\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/config/StateVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Ownable} from \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport {Pausable} from \\\"lib/openzeppelin-contracts/contracts/security/Pausable.sol\\\";\\nimport {Counters} from \\\"lib/openzeppelin-contracts/contracts/utils/Counters.sol\\\";\\n\\ncontract StateVariables is Ownable, Pausable {\\n    address public signerAddress;\\n    address public operatorAddress;\\n\\n    IERC20 public STC_Addr;\\n    IERC20 public BUSD;\\n    IERC20 public VoucherAddr;\\n\\n    uint256 public currentTokenPoolID;\\n    uint256 public diviser = 100e18;\\n    uint256 public maxMintStcPerDay = 41e18;\\n    uint256 public updateRewardPershareLimit = 1 days;\\n    uint256 public lastRewardPerShareUpdate;\\n    uint256 public totalStakedAmount;\\n    uint256 public rewardPerShare;\\n\\n    bool public rewardClaiming;\\n    // Eg := currentPoolID -> Pack ===> poolInfo\\n    mapping(uint => mapping(Pack => Pools)) public poolInfo;\\n    mapping(Pack => bool) public packageStatus;\\n    mapping(Pack => Packages) public packages;\\n    mapping(address => userDetails) public UserDetails;\\n    mapping(uint256 => uint256) public rewards; //EG := LEVEL => REWARD\\n    mapping(uint256 => uint256) public levels;\\n    mapping(bytes32 => bool) public hashStatus;\\n    mapping(address => uint256) public tokenPoolID;\\n    mapping(address => AdminAddedUserDetails) internal adminAddedUserDetails;\\n\\n    enum Pack {\\n        TRIAL,\\n        STARTER,\\n        GROWTH\\n    }\\n\\n    struct Pools {\\n        address tokenAddress;\\n        uint price;\\n        bool isAffiliateRewardEnabled;\\n    }\\n\\n    struct Packages {\\n        uint256 lifeSpan;\\n        uint256 minStakeAmount;\\n        uint256 maxStakeAmount;\\n        uint256 poolSTCamount;\\n    }\\n\\n    struct userDetails {\\n        address reffererAddr;\\n        address[] directRefferals;\\n        uint256 uplineLength;\\n        uint256 level;\\n        //Eg := tokenAddress -> tokenPoolID -> userLevel ===> rewardAmount\\n        mapping(address => mapping(uint => mapping(uint => uint))) affiliateLevelRefferredUserReward;\\n        mapping(uint256 => address[]) levelRefferredUsers;\\n        mapping(address => uint256) reffererAddedLevel;\\n        mapping(Pack => uint256) userPackId;\\n        mapping(uint256 => mapping(Pack => UserPack)) packages;\\n    }\\n\\n    struct AdminAddedUserDetails {\\n        address refererAddress;\\n        Pack[] pack;\\n        uint[] addedPackIds;\\n    }\\n\\n    struct UserPack {\\n        uint256 stakedAmount;\\n        uint256 unClaimedAmt;\\n        uint256 rewardDept;\\n        uint256 totalRewardClaimed;\\n        uint256 packageBoughtTime;\\n        uint256 stakedTime;\\n        uint256 lastRewardClaimedTime;\\n        uint256 userPackId;\\n        // bool userPackActivedIds;\\n        mapping(uint256 => mapping(Pack => bool)) userPackActivedIds;\\n        mapping(uint256 => mapping(Pack => bool)) isUserAlreadyBoughtThisPackToRedeem;\\n        bool isActive;\\n    }\\n    event packageBought(\\n        address indexed userAddr,\\n        Pack indexed pack,\\n        uint256 busdAmount,\\n        uint256 indexed userPackId,\\n        uint256 tokenPoolID\\n    );\\n    event LevelBought(\\n        address indexed reffererAddr,\\n        address indexed refferingAddr,\\n        Pack indexed pack,\\n        uint256 userPackId,\\n        uint256 tokenPoolID\\n    );\\n    event ClaimedAffiliate(\\n        address indexed userAddress,\\n        address indexed tokenAddress,\\n        uint256 tokenPoolID,\\n        uint256 claimedRewardAmount,\\n        uint256 level\\n    );\\n    event Staked(\\n        Pack indexed pack,\\n        address indexed userAddress,\\n        uint256 stcAmountToStake\\n    );\\n    event ClaimedRewardAmount(\\n        Pack indexed pack,\\n        address indexed userAddress,\\n        uint256 indexed rewardAmount\\n    );\\n    event updatedPackage(\\n        Pack indexed pack,\\n        uint256 span,\\n        uint256 maxStakeAmount\\n    );\\n    event SwapBusdToStc(address addr, uint256 busdAmount, uint256 busdPrice);\\n    event ClaimedCapital(\\n        address indexed user,\\n        Pack indexed pack,\\n        uint256 amount\\n    );\\n    event RewardUpdated(uint256 indexed level, uint256 percentage);\\n    event LevelRefCountUpdated(uint256 indexed level, uint256 refCounts);\\n    event RewardClaiming(bool indexed isOpen);\\n    event SetPackageStatus(Pack indexed pack, bool indexed status);\\n    event UpdatedMaxStakeAmount(uint256 _maxStakeAmount, Pack pack);\\n    event UpdateMinStakeAmount(uint256 _minStakeAmount, Pack pack);\\n    event SetTokenPoolStatus(\\n        address indexed tokenAddress,\\n        uint poolID,\\n        Pack pack,\\n        uint price,\\n        bool isAffiliateRewardEnabled\\n    );\\n    event AddedTokenToPool(\\n        address indexed tokenAddresses,\\n        uint indexed cpi,\\n        uint[] price,\\n        bool[] isRewardEnabledForAffiliateReward\\n    );\\n    event AddUsers(\\n        address[] refAddr,\\n        address[] userAddr,\\n        Pack[] pack\\n    );\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stc_addr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isAffRewardEnabled\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"refAddr\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"userAddr\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"enum StateVariables.Pack[]\",\"name\":\"pack\",\"type\":\"uint8[]\"}],\"name\":\"AddUsers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddresses\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cpi\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"price\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"isRewardEnabledForAffiliateReward\",\"type\":\"bool[]\"}],\"name\":\"AddedTokenToPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedRewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"ClaimedAffiliate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedCapital\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimedRewardAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reffererAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refferingAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"}],\"name\":\"LevelBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refCounts\",\"type\":\"uint256\"}],\"name\":\"LevelRefCountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"RewardClaiming\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"RewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetPackageStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAffiliateRewardEnabled\",\"type\":\"bool\"}],\"name\":\"SetTokenPoolStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stcAmountToStake\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdPrice\",\"type\":\"uint256\"}],\"name\":\"SwapBusdToStc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"UpdateMinStakeAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"UpdatedMaxStakeAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"}],\"name\":\"packageBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"span\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"updatedPackage\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STC_Addr\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"reffererAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uplineLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VoucherAddr\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"_isAffiliateRewardEnabled\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"price\",\"type\":\"uint256[]\"}],\"name\":\"addTokensToPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddr\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"refAddr\",\"type\":\"address[]\"},{\"internalType\":\"enum StateVariables.Pack[]\",\"name\":\"pack\",\"type\":\"uint8[]\"}],\"name\":\"addUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"reffererAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packIdToRedeem\",\"type\":\"uint256\"}],\"name\":\"buyPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceForTokenPack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"calculateAffiliateRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"checkRefBoughtAnyPack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"claimAffiliateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"}],\"name\":\"claimCapital\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claimRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokenPoolID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"diviser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isPackNotExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardPerShareUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintStcPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"packageStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"packages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lifeSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSTCamount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAffiliateRewardEnabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refferrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referringAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"prepareBuyLevelHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockExpiry\",\"type\":\"uint256\"}],\"name\":\"prepareClaimHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stcAmountToStake\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"blockExpiry\",\"type\":\"uint256\"}],\"name\":\"prepareHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockExpiry\",\"type\":\"uint256\"}],\"name\":\"prepareSwapHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardClaiming\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPackageStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"setRewardClaiming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stcAmountToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"swapBusdToStc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPoolID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"uplineLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"name\":\"updateAdminPacks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"}],\"name\":\"updateLevelReferals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxMintStcPerDay_\",\"type\":\"uint256\"}],\"name\":\"updateMaxMintStcPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"updateMaxStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"updateMinStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"opAddr\",\"type\":\"address\"}],\"name\":\"updateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"span\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolStcAmount\",\"type\":\"uint256\"}],\"name\":\"updatePackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPercent\",\"type\":\"uint256\"}],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewardPerShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewardPershareLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"updateSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"updateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isAffiliateRewardEnabled\",\"type\":\"bool\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"updateTokenPoolDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stcAmountToStake\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"validateHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"name\":\"viewRefAddedLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"viewUserActivePack\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"viewUserActivePacks\",\"outputs\":[{\"internalType\":\"uint8[3]\",\"name\":\"packs\",\"type\":\"uint8[3]\"},{\"internalType\":\"bool[3]\",\"name\":\"isActive\",\"type\":\"bool[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"viewUserAffiliateRewardForLevelsForPack\",\"outputs\":[{\"internalType\":\"uint256[13]\",\"name\":\"level\",\"type\":\"uint256[13]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"viewUserDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"reffererAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uplineLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"directRefs\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPoolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"viewUserLevelDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"affiliateRewardForTheLevel\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"levelRefferedUsers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"viewUserPackCurrentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"}],\"name\":\"viewUserPackDetails\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"expired\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"isActive\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"enum StateVariables.Pack\",\"name\":\"pack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userPackId\",\"type\":\"uint256\"}],\"name\":\"viewUserPackDetailsByPackId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unClaimedAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packageBoughtTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"userPackActivedIds\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isUserAlreadyBoughtThisPackToRedeem\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"viewadminAddedUserDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"refererAddress\",\"type\":\"address\"},{\"internalType\":\"enum StateVariables.Pack[]\",\"name\":\"pack\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"adminAddedPackID\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeIt_V4", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e1859dee0b65b1d65d5109f5d7adf4fe3e00774400000000000000000000000080702018c28988dfe3c900561745f7af1b9fdb3700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001000000000000000000000000007f1ef5d0e6af80538c6fdcc3d44b6f25c9eef3370000000000000000000000000000000000000000000000000000000000000002000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000002bdf45c313eaf36e63c8d8845d94cab8770524ab000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}