{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity 0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\t\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\t\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\t\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\t\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\t\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\t\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\t\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\tfunction isExcludedFromFee(address account) external view returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\t\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n  \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n   \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\t\r\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n    using Address for address;\r\n\t\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\t\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract StakeCHEESE is Ownable, ReentrancyGuard {\r\n\r\n    using SafeBEP20 for IBEP20;\r\n\t\r\n    uint256 public minStaking = 1000 * 10**18;\r\n\tuint256 public APR = 25000;\r\n\tuint256 public poolFee;\r\n\tuint256 public totalStaked;\r\n\t\r\n    IBEP20 public stakedToken = IBEP20(0x08Aed8578dAaBf12d48031fA5d9727e4afD42dee);\r\n\t\r\n    mapping(address => UserInfo) internal userInfo;\r\n\tuint256 constant TIME_STEP = 365 days;\r\n\t\r\n\tbool public paused = false;\r\n\t\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused, \"Contract is paused\");\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused, \"Contract is unpaused\");\r\n\t\t_;\r\n\t}\r\n\t\r\n    struct UserInfo {\r\n        uint256 amount; \r\n\t\tuint256 rewardRemaining;\r\n\t\tuint256 rewardWithdrawal;\r\n        uint256 startTime;\r\n    }\r\n\t\r\n    event MigrateTokens(address tokenRecovered, uint256 amount);\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event NewAPR(uint256 APR);\r\n    event MinStakePerUser(uint256 minStakePerUser);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\tevent NewPoolFee(uint256 newFee);\r\n\tevent Pause();\r\n    event Unpause();\r\n\t\r\n    constructor() {}\r\n\t\r\n    function deposit(uint256 amount) external nonReentrant{\r\n\t    UserInfo storage user = userInfo[msg.sender];\r\n\t\t\r\n\t\trequire(!paused, \"Deposit is paused\");\r\n\t\trequire(stakedToken.balanceOf(msg.sender) >= amount, \"Balance not available for staking\");\r\n\t\trequire(stakedToken.isExcludedFromFee(address(this)), \"Contract address is not excluded from fee\");\r\n\t\trequire(amount >= minStaking, \"Amount is less than minimum staking amount\");\r\n\t\t\r\n\t\tuint256 pending = pendingreward(msg.sender);\r\n\t\t\r\n\t\tuser.amount = user.amount + amount;\r\n\t\tuser.rewardRemaining = user.rewardRemaining + pending;\r\n\t\tuser.startTime = block.timestamp;\r\n\t\t\r\n\t\ttotalStaked = totalStaked + amount;\r\n\t\t\r\n\t\tstakedToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n        emit Deposit(msg.sender, amount);\r\n    }\r\n\t\r\n    function withdraw() external nonReentrant{\r\n\t    UserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.amount > 0, \"Amount is not staked\");\r\n\t\t\r\n\t\tuint256 amount   = user.amount;\r\n\t\tuint256 pending  = pendingreward(msg.sender);\r\n\t\tuint256 reward   = user.rewardRemaining + pending;\r\n\t\tuint256 fee      = (reward * poolFee) / 10000;\r\n\t\t\r\n\t\ttotalStaked = totalStaked - amount;\r\n\t\t\r\n\t\tif(stakedToken.balanceOf(address(this)) >= amount + reward - fee)\r\n\t\t{\r\n\t\t    user.rewardRemaining = 0;\r\n\t\t\tuser.amount = 0;\r\n\t\t\tuser.rewardWithdrawal = 0;\r\n\t\t\t\r\n\t\t\tstakedToken.safeTransfer(address(msg.sender), amount + reward - fee);\r\n\t\t\temit Withdraw(msg.sender, amount + reward - fee);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    require(stakedToken.balanceOf(address(this)) >= amount, \"Token balance not available for withdraw\");\r\n\t\t\t\r\n\t\t\tuser.rewardRemaining = reward;\r\n\t\t\tuser.amount = 0;\r\n\t\t\t\r\n\t\t\tstakedToken.safeTransfer(address(msg.sender), amount);\r\n\t\t\temit Withdraw(msg.sender, amount);\r\n\t\t\t\r\n\t\t}\r\n    }\r\n\t\r\n\tfunction withdrawReward() external nonReentrant{\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\t\r\n\t\tuint256 pending = pendingreward(msg.sender);\r\n\t\tuint256 reward  = user.rewardRemaining + pending;\r\n\t\tuint256 fee     = (reward * poolFee) / 10000;\r\n\t\t\r\n\t\trequire(reward > 0, \"Reward amount is zero\");\r\n\t\trequire(stakedToken.balanceOf(address(this)) >= reward - fee, \"Token balance not available for withdraw\");\r\n\t\t\r\n\t\tif(user.amount > 0)\r\n\t\t{\r\n\t\t   user.rewardWithdrawal = user.rewardWithdrawal + reward;\r\n\t\t   user.rewardRemaining = 0;\r\n\t\t   user.startTime = block.timestamp;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t   user.rewardWithdrawal = 0;\r\n\t\t   user.rewardRemaining = 0;\r\n\t\t}\r\n\t\t\r\n\t\tstakedToken.safeTransfer(address(msg.sender), reward-fee);\r\n\t\temit Withdraw(msg.sender, reward);\r\n    }\r\n\t\r\n\tfunction pendingreward(address _user) public view returns (uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n\t\tif(user.amount > 0)\r\n\t\t{\r\n\t\t\tuint256 sTime  = user.startTime;\r\n\t\t\tuint256 eTime  = block.timestamp;\r\n\t\t\tuint256 reward = (uint(user.amount) * (APR) * (eTime-sTime)) / (TIME_STEP * 10000);\r\n\t\t\treturn reward;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    return 0;\r\n\t\t}\r\n    }\r\n\t\r\n\tfunction getUserInfo(address userAddress) public view returns (uint256, uint256, uint256, uint256) {\r\n        UserInfo storage user = userInfo[userAddress];\r\n        return (user.amount, user.rewardRemaining, user.rewardWithdrawal, user.startTime);\r\n    }\r\n\t\r\n\tfunction migrateTokens(address receiver, address tokenAddress, uint256 tokenAmount) external onlyOwner nonReentrant{\r\n       require(receiver != address(0), \"zero-address not allowed\");\r\n\t   \r\n\t   IBEP20(tokenAddress).safeTransfer(address(receiver), tokenAmount);\r\n       emit MigrateTokens(tokenAddress, tokenAmount);\r\n    }\r\n\t\r\n\tfunction updateMinStaking(uint256 minStakingAmount) external onlyOwner {\r\n\t    require(stakedToken.totalSupply() > minStakingAmount, \"Total supply is less than minimum staking amount\");\r\n\t\trequire(minStakingAmount >= 1000 * 10**18, \"Amount is less than `1000` tokens\");\r\n\t\t\r\n        minStaking = minStakingAmount;\r\n        emit MinStakePerUser(minStakingAmount);\r\n    }\r\n\t\r\n\tfunction updateAPR(uint256 newAPR) external onlyOwner {\r\n\t    require(newAPR >= 3000, \"APR is less than `30%`\");\r\n\t\trequire(newAPR <= 25000, \"APR is greater than `250%`\");\r\n\t\t\r\n        APR = newAPR;\r\n        emit NewAPR(newAPR);\r\n    }\r\n\t\r\n\tfunction updatePoolFee(uint256 newFee) external onlyOwner {\r\n\t\trequire(newFee <= 200, \"Fee is greater than `2%`\");\r\n\t\t\r\n        poolFee = newFee;\r\n        emit NewPoolFee(newFee);\r\n    }\r\n\t\r\n\tfunction pause() whenNotPaused external onlyOwner{\r\n\t\tpaused = true;\r\n\t\temit Pause();\r\n\t}\r\n\t\r\n\tfunction unpause() whenPaused external onlyOwner{\r\n\t\tpaused = false;\r\n\t\temit Unpause();\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenRecovered\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MigrateTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minStakePerUser\",\"type\":\"uint256\"}],\"name\":\"MinStakePerUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"APR\",\"type\":\"uint256\"}],\"name\":\"NewAPR\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"NewPoolFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"migrateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAPR\",\"type\":\"uint256\"}],\"name\":\"updateAPR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakingAmount\",\"type\":\"uint256\"}],\"name\":\"updateMinStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"updatePoolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeCHEESE", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2e7b93a57ef4b96632a4939d73775810e83c3502de71dd4c326d350d130e3c51"}