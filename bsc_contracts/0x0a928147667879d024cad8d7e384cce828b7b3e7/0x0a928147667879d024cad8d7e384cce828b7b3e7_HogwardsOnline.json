{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Hogwards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/*\\n*******************************\\n**                                                                                              \\n\u2580\u2588\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2588\u2580\u2580 \u2584\u2584\u2588\u2580\u2580\u2588\u2588\u2584   \u2584\u2584\u2588\u2580\u2580\u2580\u2588\u2584\u2588\u2580\u2588\u2588\u2588\u2588\u2580     \u2588     \u2580\u2588\u2588\u2588\u2580     \u2588\u2588     \u2580\u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584 \u2580\u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584  \u2584\u2588\u2580\u2580\u2580\u2588\u2584\u2588\\n  \u2588\u2588      \u2588\u2588  \u2584\u2588\u2588\u2580    \u2580\u2588\u2588\u2584\u2588\u2588\u2580     \u2580\u2588  \u2580\u2588\u2588     \u2584\u2588\u2588     \u2584\u2588      \u2584\u2588\u2588\u2584      \u2588\u2588   \u2580\u2588\u2588\u2584  \u2588\u2588    \u2580\u2588\u2588\u2584\u2588\u2588    \u2580\u2588\\n  \u2588\u2588      \u2588\u2588  \u2588\u2588\u2580      \u2580\u2588\u2588\u2588\u2580       \u2580   \u2588\u2588\u2584   \u2584\u2588\u2588\u2588\u2584   \u2584\u2588      \u2584\u2588\u2580\u2588\u2588\u2593     \u2588\u2588   \u2584\u2588\u2588   \u2588\u2588     \u2580\u2588\u2588\u2588\u2588\u2588\u2584    \\n  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588        \u2588\u2588\u2593             \u2588\u2588\u2584  \u2588\u2580 \u2588\u2588\u2584  \u2588\u2580     \u2584\u2588  \u2580\u2588\u2588     \u2593\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588      \u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2584\\n  \u2593\u2588      \u2588\u2593  \u2588\u2588        \u2588\u2588\u2593\u2584    \u2580\u2588\u2588\u2588\u2588   \u2593\u2588\u2588 \u2588\u2580  \u2580\u2588\u2588 \u2588\u2580      \u2588\u2588\u2588\u2593\u2588\u2593\u2588\u2588    \u2593\u2588  \u2588\u2588\u2584    \u2588\u2593     \u2584\u2588\u2588     \u2580\u2588\u2588\\n  \u2593\u2588      \u2588\u2593  \u2580\u2588\u2588      \u2588\u2588\u2580\u2593\u2588\u2584     \u2588\u2588     \u2593\u2588\u2588\u2584    \u2593\u2588\u2588\u2584      \u2593\u2580      \u2588\u2588   \u2593\u2588   \u2580\u2593\u2588   \u2588\u2593    \u2584\u2588\u2593\u2580\u2588     \u2588\u2588\\n  \u2592\u2593      \u2593\u2593  \u2593\u2588\u2588      \u2593\u2588\u2593\u2593\u2593    \u2580\u2593\u2588\u2593\u2593    \u2593\u2593\u2588\u2593\u2580   \u2593\u2593\u2588\u2593\u2580      \u2593\u2593\u2593\u2593\u2588\u2593\u2593\u2588    \u2593\u2588  \u2593 \u2593\u2593   \u2593\u2593     \u2593\u2593\u2593     \u2580\u2588\u2593\\n  \u2592\u2593      \u2592\u2593  \u2580\u2588\u2593\u2593\u2593    \u2593\u2593\u2593\u2592\u2593\u2593     \u2593\u2593     \u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593      \u2593\u2580      \u2593\u2593   \u2593\u2593   \u2580\u2593\u2593\u2593  \u2593\u2592    \u2593\u2593\u2592\u2580\u2593     \u2593\u2593\\n\u2592\u2592\u2592 \u2592   \u2592 \u2592\u2593\u2592\u2592  \u2592 \u2592 \u2592 \u2592    \u2592\u2592\u2592 \u2592 \u2592\u2592       \u2592       \u2592      \u2592 \u2592 \u2592   \u2592 \u2592\u2592\u2592\u2592 \u2592\u2593\u2592  \u2592 \u2592 \u2592 \u2592 \u2592 \u2592 \u2592  \u2592\u2593\u2592 \u2592 \u2592\u2593 \\n**\\n**\\n**  WEB: https://hogwards.online/\\n**\\n**  MIRROR: https://hogwards-online.com/\\n**\\n*******************************\\n*/\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\"; \\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\n\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\ncontract HogwardsOnline is Ownable, ReentrancyGuard \\n{\\n    address public PairAddress = address(0); // Token Pair Address\\n    address internal BNBAddress = 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE; // BNB/USD Mainnet \\n    AggregatorV3Interface internal BNBprice;\\n    IERC20 internal currentToken;\\n\\n    // FEE ADDRESSES\\n    address internal Owner1_receiver = 0x797878AD12bcE357b853E8E499dD68D4D883283b;\\n    address internal Owner2_receiver = 0xD60673A98F2424C315a40c3cEC6e4Ff5dcB74eb9;\\n    address internal Marketing_receiver = 0xC1EBd9c4B4F7762e630795f339A6066330c5AAf4;\\n    address internal Verifier = 0x06154188D91892Fac94cA793525A6514f467F65B;\\n\\n    uint8 internal _decimals = 18;\\n    uint256 internal MIN_DEPOSIT = 1 * 10**_decimals;\\n    uint256 internal MIN_REPLENISH = 1 * 10**_decimals;\\n    uint256 public MAX_DEPOSIT = 150 * 10**_decimals;\\n    uint256 internal MIN_WITHDRAWAL = 1 * 10**_decimals;\\n    uint256 internal MIN_BID = 10 * 10**_decimals;\\n\\n    uint256 internal PERCENT = 120;\\n    uint256[2] internal AFFILIATE_PERCENTS_1 = [30, 10];\\n    uint256[2] internal AFFILIATE_PERCENTS_2 = [40, 15];\\n    uint256[2] internal AFFILIATE_PERCENTS_3 = [50, 20];\\n    uint256[2] internal AFFILIATE_PERCENTS_4 = [70, 25];\\n    uint256[2] internal AFFILIATE_PERCENTS_5 = [100, 30];\\n\\n    uint256 public totalInvested;\\n    uint256 public totalInvestors;\\n    uint256 public totalBattles;\\n    uint256 internal daysWork;\\n    uint32 public LastHeroId = 1;\\n    uint32 public Bids = 0;\\n    address[] public Heroes;\\n    uint256 public PHASE_1 = 1696410000;\\n    uint256 public PHASE_2 = 1698829200;\\n\\n    modifier checkSender {\\n        require(_msgSender() == tx.origin, \\\"Function can only be called by a user account\\\");\\n        _;\\n    }\\n\\n    struct User \\n    {\\n        uint8 character;\\n        uint256 money;\\n        uint256 frozen;\\n        uint256 token_hold;\\n        uint256 elixir;\\n        uint256 deposit;\\n        uint256 earned;\\n        uint256 total_earned;\\n        uint256 withdrawn;\\n        uint256 timestamp;\\n        uint256 percentage;\\n        address partner;\\n        bytes32 keccak;\\n    }\\n\\n    struct UserStats\\n    {\\n        uint128 skill;\\n        uint256 skill_timestamp;\\n        uint256 replenished;\\n        uint256 refsTotal;\\n        uint256 refs1level;\\n        uint256 turnover;\\n        uint256 turnover_total;\\n        uint256 refearnUSDT;\\n        uint8 status;\\n    }\\n\\n    struct allowedTokens \\n    {\\n        address addr;\\n        uint8 decimals;\\n    }\\n\\n    struct Battles \\n    {\\n        uint256 wins;\\n        uint256 loses;\\n    }\\n\\n    struct Forest \\n    {\\n        address player1;\\n        address player2;\\n        uint256 money;\\n        uint256 timestamp;\\n        address winner;\\n        uint256 roll;\\n    }\\n\\n    struct TheLastHero \\n    {\\n        uint256 bid;\\n        uint256 bank;\\n        uint256 timestamp;\\n        address winner;\\n        bool status;\\n    }\\n\\n    mapping(address => User) public user;\\n    mapping(address => UserStats) public user_stats;\\n    mapping(uint => allowedTokens) public AllowedTokens;\\n    mapping(address => Battles) public battles;\\n    mapping(address => mapping(uint256 => Forest)) public forest;\\n    mapping(uint256 => address) public waitingBattles;\\n    mapping(uint256 => TheLastHero) public LastHero;\\n\\n    constructor() \\n    {\\n        BNBprice = AggregatorV3Interface(BNBAddress);\\n\\n        AllowedTokens[0].addr = 0x55d398326f99059fF775485246999027B3197955; // USDT-BEP20\\n        AllowedTokens[0].decimals = 18;\\n\\n        PairAddress = 0x204fEEeE77c50C433E6579486D40381787108181; \\n        AllowedTokens[1].addr = 0xCD99e5420226ad4031Bf3322FdeB5F2e91Dfc820;  // ELIXIR\\n        AllowedTokens[1].decimals = 18;\\n\\n        currentToken = IERC20(AllowedTokens[0].addr); // INIT USDT\\n    }\\n\\n    receive() external payable onlyOwner {}\\n\\n    function BuyCharacter(uint8 character, address partner, bytes memory signature, uint256 deadline) external nonReentrant checkSender\\n    {\\n        uint256 priceCharacter = 10 * 10**_decimals; // 10 GOLD\\n        require(block.timestamp >= PHASE_1, \\\"Phase 1 has not started yet\\\");\\n        require(character >= 11 && character <= 44, \\\"Parse character error\\\");\\n        require(user[_msgSender()].character == 0, \\\"Character has already been purchased\\\");\\n        require(partner != _msgSender(), \\\"Cannot set your own address as partner\\\");\\n        address sign = _verifySignature(signature, deadline, 84998, priceCharacter);\\n        require(sign == Verifier, \\\"It is possible to call only through the website\\\");\\n        \\n        // First free 888 adresses\\n        if(totalInvestors >= 888)\\n        {\\n            require(priceCharacter <= user[_msgSender()].money, \\\"Insufficient funds\\\");\\n            user[_msgSender()].money -= priceCharacter;\\n            uint256 updateFrozen = (user[_msgSender()].frozen <= priceCharacter) ? 0 : (user[_msgSender()].frozen - priceCharacter);\\n            user[_msgSender()].frozen = updateFrozen;\\n        }\\n    \\n        user[_msgSender()].character = character;\\n        address ref = user_stats[partner].status == 0 ? address(0) : partner;\\n        user[_msgSender()].partner = ref;\\n        user_stats[ref].refs1level++;\\n        user_stats[ref].refsTotal++;\\n        if(user[ref].partner != address(0))\\n            user_stats[user[ref].partner].refsTotal++;\\n        totalInvestors += 1;\\n    }\\n\\n    function ReplenishBalance(uint amount, uint tokenIndex, bytes memory signature, uint256 deadline) external nonReentrant checkSender\\n    {\\n        require(block.timestamp >= PHASE_1, \\\"Phase 1 has not started yet\\\");\\n        require(tokenIndex <= 1, \\\"Index not found\\\");\\n        require(amount >= MIN_REPLENISH, \\\"Min replenishment limit\\\");\\n        address sign = _verifySignature(signature, deadline, 39573, amount);\\n        require(sign == Verifier, \\\"It is possible to call only through the website\\\");\\n \\n        if(tokenIndex == 0) // USDT\\n        {\\n            require((user_stats[_msgSender()].replenished + amount) <= MAX_DEPOSIT, \\\"Max limit has been exceeded\\\");\\n            user_stats[_msgSender()].replenished += amount;\\n            user[_msgSender()].money += amount;\\n            user[_msgSender()].frozen += amount;\\n            totalInvested += amount;\\n        }\\n        else // ELIXIR\\n        {\\n            require(block.timestamp >= PHASE_2, \\\"Phase 2 has not started yet\\\");\\n            user[_msgSender()].elixir += amount;\\n            user[_msgSender()].token_hold = block.timestamp + (86400 * 7); // Hold 7 days\\n            _updatePercentage(_msgSender());\\n        }\\n\\n        currentToken = IERC20(AllowedTokens[tokenIndex].addr);\\n        currentToken.transferFrom(_msgSender(), address(this), amount);\\n        \\n        // Owner-Fee for USDT\\n        if(tokenIndex == 0)\\n        {\\n            uint256 feeUSDT_owner1 = (amount * 3) / 100;\\n            uint256 feeUSDT_owner2 = (amount * 2) / 100;\\n            uint256 feeUSDT_marketing = (amount * 15) / 1000;\\n            currentToken.transfer(Owner1_receiver, feeUSDT_owner1);\\n            currentToken.transfer(Owner2_receiver, feeUSDT_owner2);\\n            currentToken.transfer(Marketing_receiver, feeUSDT_marketing);\\n        }\\n    }\\n\\n    function Deposit(uint amount) external nonReentrant checkSender\\n    {\\n        require(amount >= MIN_DEPOSIT, \\\"Min deposit limit\\\");\\n        require(amount <= user[_msgSender()].money, \\\"Insufficient funds\\\");\\n        require(user[_msgSender()].character > 0, \\\"Need buy character\\\");\\n\\n        uint256 updateFrozen = (user[_msgSender()].frozen <= amount) ? 0 : (user[_msgSender()].frozen - amount);\\n        user[_msgSender()].frozen = updateFrozen;\\n        user[_msgSender()].money -= amount;\\n        user[_msgSender()].deposit += amount;\\n        user[_msgSender()].timestamp = block.timestamp;\\n\\n        if(user[_msgSender()].percentage == 0)\\n        {\\n            user[_msgSender()].percentage = PERCENT;\\n            user_stats[_msgSender()].status = 1; // REF STATUS\\n        }\\n        \\n        _referralAccrual(user[_msgSender()].partner, amount);\\n    }\\n\\n    function Withdraw(uint256 amount) external nonReentrant checkSender\\n    {\\n        require(amount >= MIN_WITHDRAWAL, \\\"Min withdrawal limit\\\");\\n        require(amount <= (user[_msgSender()].money - user[_msgSender()].frozen), \\\"Insufficient funds\\\");\\n        user[_msgSender()].money -= amount;\\n        user[_msgSender()].withdrawn += amount;\\n\\n        uint8 tokenIndex = 0; // USDT\\n        currentToken = IERC20(AllowedTokens[tokenIndex].addr);\\n\\n        // Owner-Fee\\n        uint256 feeUSDT_owner1 = (amount * 3) / 100;\\n        uint256 feeUSDT_owner2 = (amount * 2) / 100;\\n\\n        currentToken.transfer(_msgSender(), (amount-feeUSDT_owner1-feeUSDT_owner2));\\n        currentToken.transfer(Owner1_receiver, feeUSDT_owner1);\\n        currentToken.transfer(Owner2_receiver, feeUSDT_owner2);\\n    }\\n\\n    function WithdrawElixir(uint amount) external nonReentrant checkSender\\n    {\\n        require(amount <= user[_msgSender()].elixir, \\\"Insufficient funds\\\");\\n        require(block.timestamp >= user[_msgSender()].token_hold, \\\"Token hold\\\");\\n        user[_msgSender()].elixir -= amount;\\n        _updatePercentage(_msgSender());\\n\\n        uint8 tokenIndex = 1; // ELIXIR\\n        uint256 feeMarketing = (amount * 1) / 100;\\n        currentToken = IERC20(AllowedTokens[tokenIndex].addr);\\n        currentToken.transfer(_msgSender(), amount - feeMarketing);\\n        currentToken.transfer(Marketing_receiver, feeMarketing);\\n    }\\n\\n    function BankDividends() external nonReentrant checkSender\\n    {\\n        require(user[_msgSender()].deposit > 0, \\\"Insufficient deposit\\\");\\n        _updateprePayment(_msgSender());\\n    }\\n\\n    function WitchCraft() external nonReentrant checkSender\\n    {\\n        require(user[_msgSender()].character > 0, \\\"Need buy character\\\");\\n        require(block.timestamp >= user_stats[_msgSender()].skill_timestamp, \\\"Impossible\\\");\\n        user_stats[_msgSender()].skill_timestamp = block.timestamp + 86400;\\n        user_stats[_msgSender()].skill += 1;\\n    }\\n\\n    // The Last Hero :: Mini game\\n    function MakeBid(uint256 amount, uint32 round, bytes memory signature, uint256 deadline) external nonReentrant checkSender\\n    {\\n        require(user[_msgSender()].character > 0, \\\"Need buy character\\\");\\n        require(amount >= MIN_BID, \\\"Min bid is 10 Tokens\\\");\\n        require(round == LastHeroId, \\\"The round is already over\\\");\\n        address sign = _verifySignature(signature, deadline, 62294, amount);\\n        require(sign == Verifier, \\\"It is possible to call only through the website\\\");\\n        uint8 tokenIndex = 1; // ELIXIR\\n\\n        if(LastHero[LastHeroId].timestamp == 0)\\n        {\\n            // start ROUND\\n            Heroes.push(_msgSender());\\n            LastHero[LastHeroId].timestamp = block.timestamp + 60;\\n            LastHero[LastHeroId].bid = amount;\\n            LastHero[LastHeroId].bank += amount;\\n            LastHero[LastHeroId].winner = _msgSender();\\n            Bids++;\\n        }\\n        else\\n        {\\n            require(!_checkLastHero(), \\\"Round the end\\\");\\n            require(amount > LastHero[LastHeroId].bid, \\\"The new bid must be higher than the current one\\\");\\n            LastHero[LastHeroId].timestamp += 60;\\n            LastHero[LastHeroId].bid = amount;\\n            LastHero[LastHeroId].bank += amount;\\n            LastHero[LastHeroId].winner = _msgSender();\\n            Heroes.push(_msgSender());\\n            Bids++;\\n        }\\n\\n        currentToken = IERC20(AllowedTokens[tokenIndex].addr);\\n        currentToken.transferFrom(_msgSender(), address(this), amount);\\n    }\\n\\n    function StartNewRound() external nonReentrant checkSender\\n    {\\n        require(_checkLastHero(), \\\"Round is running\\\");\\n        require(LastHero[LastHeroId].timestamp > 0, \\\"No active rounds\\\");\\n\\n        uint8 tokenIndex = 1; // ELIXIR\\n        address WinnerAccount = LastHero[LastHeroId].winner;\\n        LastHero[LastHeroId].status = true;\\n        \\n        // send bank - fee\\n        uint256 bank = LastHero[LastHeroId].bank;\\n        uint256 adminFee = bank * 10 / 100;\\n        currentToken = IERC20(AllowedTokens[tokenIndex].addr);\\n        currentToken.transfer(WinnerAccount, bank - adminFee);\\n        currentToken.transfer(Owner1_receiver, adminFee / 2);\\n        currentToken.transfer(Owner2_receiver, adminFee / 2);\\n        LastHeroId++;\\n        delete Heroes;\\n        Bids = 0;\\n    }\\n\\n    function _checkLastHero() internal view returns(bool)\\n    {\\n        return (LastHero[LastHeroId].timestamp <= block.timestamp) ? true : false;\\n    }\\n\\n    function pendingReward(address account) public view returns(uint256) \\n    {\\n        uint256 DiffUnix = (block.timestamp - user[account].timestamp) / 60;\\n        uint256 IncomePerMinute = user[account].percentage * 10**18 / 1440;\\n        uint256 Reward = 0;\\n\\n        if(DiffUnix > 0)\\n        {\\n            // if the deposit is less than 84 usdt then we do not stop the reward\\n            if(user[account].deposit < (84 * 10**_decimals))\\n            {\\n                Reward = (user[account].deposit * IncomePerMinute) * DiffUnix / 10**22;\\n                Reward = (Reward >= (1 * 10**_decimals)) ? (1 * 10**_decimals) : Reward;\\n            }\\n            else // default reward with only 1 day\\n            {\\n                DiffUnix = (DiffUnix > 1440) ? 1440 : DiffUnix;\\n                Reward = (user[account].deposit * IncomePerMinute) * DiffUnix / 10**22;\\n            }\\n        }\\n\\n        return Reward;\\n    }\\n\\n    function _updateprePayment(address account) internal \\n    {\\n        uint256 pending = pendingReward(account);\\n        uint256 depo_end = (user[account].deposit * 222 / 100);\\n\\n        if(pending > 0)\\n        {\\n            user[account].timestamp = block.timestamp;\\n            user[account].money += pending;\\n            user[account].total_earned += pending;\\n            user[account].earned += pending;\\n        }\\n\\n        if(user[account].earned >= depo_end)\\n        {\\n            user[account].deposit = 0;\\n            user[account].earned = 0;\\n            user[account].timestamp = 0;\\n        }\\n\\n        uint256 newCounter = (block.timestamp >= PHASE_1) ? (block.timestamp - PHASE_1) / 86400 : 0;\\n\\n        // update daily limits\\n        if(newCounter > daysWork)\\n        {\\n            daysWork++;\\n            uint256 LimitMaxDepo = 1000000*10**18;\\n            MAX_DEPOSIT = MAX_DEPOSIT * 1128 / 1000;\\n            if(MAX_DEPOSIT >= LimitMaxDepo)\\n                MAX_DEPOSIT = LimitMaxDepo;\\n        }\\n    }\\n\\n    function _referralAccrual(address account, uint256 value) internal \\n    {\\n        if (value > 0 && account != address(0)) \\n        {\\n            for (uint8 i; i < 2; i++) \\n            {\\n                uint256 affPercent = AFFILIATE_PERCENTS_1[i];\\n\\n                if(user_stats[account].status == 2)\\n                    affPercent = AFFILIATE_PERCENTS_2[i];\\n                else if(user_stats[account].status == 3)\\n                    affPercent = AFFILIATE_PERCENTS_3[i];\\n                else if(user_stats[account].status == 4)\\n                    affPercent = AFFILIATE_PERCENTS_4[i];\\n                else if(user_stats[account].status == 5)\\n                    affPercent = AFFILIATE_PERCENTS_5[i];\\n\\n                uint256 feeUSDT = ((value * affPercent) / 1000);\\n                user[account].money += feeUSDT;\\n                user_stats[account].refearnUSDT += feeUSDT;\\n                user_stats[account].turnover_total += value;\\n\\n                if(i == 0) \\n                {\\n                    user_stats[account].turnover += value;\\n                    _updateRefStatus(account, user_stats[account].turnover);\\n                }\\n                \\n                account = user[account].partner;\\n                if(account == address(0)) break;\\n            }\\n        }\\n    }\\n\\n    function _updateRefStatus(address account, uint256 turnover) internal\\n    {\\n        uint8 refStatus;\\n        uint256 decimalsMod = 10**_decimals;\\n\\n             if(turnover >= 0 && turnover < 2500*decimalsMod) refStatus = 1;\\n        else if(turnover >= 2500*decimalsMod && turnover < 10000*decimalsMod) refStatus = 2;\\n        else if(turnover >= 10000*decimalsMod && turnover < 50000*decimalsMod) refStatus = 3;\\n        else if(turnover >= 50000*decimalsMod && turnover < 100000*decimalsMod) refStatus = 4;\\n        else if(turnover >= 100000*decimalsMod) refStatus = 5;\\n\\n        if(user_stats[account].status != refStatus)\\n        {\\n            user_stats[account].status = refStatus;\\n            _updatePercentage(account);\\n        }\\n    }\\n\\n    function _updatePercentage(address account) internal \\n    {\\n        uint256 updPercentage = PERCENT;\\n        uint256 tokenBalance = (user[account].elixir >= 1000) ? \\n            user[account].elixir / 10**_decimals : 0;\\n\\n        uint256 additionalPerc = 1; // +0.01%\\n        uint256 TOKENLIMIT = 50000*10**_decimals; // 50,000 ELIXIR LIMIT\\n        if(tokenBalance <= TOKENLIMIT)\\n        {\\n            updPercentage += (tokenBalance >= 1000) ? \\n                tokenBalance / 1000 * additionalPerc : 0;\\n        }\\n        else updPercentage += 50;  // MAX INCREASE +0.5%\\n\\n             if(user_stats[account].status == 1) updPercentage += 0;\\n        else if(user_stats[account].status == 2) updPercentage += 10;\\n        else if(user_stats[account].status == 3) updPercentage += 20;\\n        else if(user_stats[account].status == 4) updPercentage += 50;\\n        else if(user_stats[account].status == 5) updPercentage += 100;\\n            \\n        if(user[account].percentage != updPercentage)\\n            user[account].percentage = updPercentage;\\n    }\\n\\n    function createBattle(uint256 battleType, bytes memory signature, uint256 deadline) external nonReentrant checkSender\\n    {\\n        require(block.timestamp >= PHASE_2, \\\"Phase 2 has not started yet\\\");\\n        require(battleType < 3, \\\"Incorrect type\\\");\\n        address sign = _verifySignature(signature, deadline, 48395, getBattleType(battleType));\\n        require(sign == Verifier, \\\"It is possible to call only through the website\\\");\\n\\n        address Creator = waitingBattles[battleType];\\n        require(_msgSender() != Creator, \\\"You are already in forest\\\");\\n\\n        if (Creator == address(0)) \\n        {\\n            _createBattle(battleType);\\n        } \\n        else \\n        {\\n            _joinBattle(battleType, Creator);\\n            _fightBattle(battleType, Creator);\\n        }\\n    }\\n\\n    function getBattleType(uint256 battleType) internal pure returns (uint256) \\n    {\\n        return [10000000000000000000, 50000000000000000000, 100000000000000000000][battleType];\\n    }\\n\\n    function _randomNumber() internal view returns (uint256) \\n    {\\n        uint256 randomnumber = uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    block.timestamp +\\n                        block.prevrandao +\\n                        ((\\n                            uint256(keccak256(abi.encodePacked(block.coinbase)))\\n                        ) / (block.timestamp)) +\\n                        block.gaslimit +\\n                        ((uint256(keccak256(abi.encodePacked(_msgSender())))) /\\n                            (block.timestamp)) +\\n                        block.number\\n                )\\n            )\\n        );\\n\\n        return randomnumber % 100;\\n    }\\n\\n    function _createBattle(uint256 battleType) internal \\n    {\\n        forest[_msgSender()][battleType].timestamp = block.timestamp;\\n        forest[_msgSender()][battleType].player1 = _msgSender();\\n        forest[_msgSender()][battleType].player2 = address(0);\\n        forest[_msgSender()][battleType].winner = address(0);\\n        forest[_msgSender()][battleType].money = getBattleType(battleType);\\n        forest[_msgSender()][battleType].roll = 0;\\n        uint256 priceBattle = forest[_msgSender()][battleType].money;\\n        require(user[_msgSender()].money >= priceBattle, \\\"Insufficient funds\\\");\\n        uint256 updateFrozen = (user[_msgSender()].frozen <= priceBattle) ? 0 : (user[_msgSender()].frozen - priceBattle);\\n        user[_msgSender()].frozen = updateFrozen;\\n        user[_msgSender()].money -= priceBattle;\\n        waitingBattles[battleType] = _msgSender();\\n    }\\n\\n    function _joinBattle(uint256 battleType, address Creator) internal \\n    {\\n        forest[Creator][battleType].timestamp = block.timestamp;\\n        forest[Creator][battleType].player2 = _msgSender();\\n        uint256 priceBattle = forest[Creator][battleType].money;\\n        require(user[_msgSender()].money >= priceBattle, \\\"Insufficient funds\\\");\\n        uint256 updateFrozen = (user[_msgSender()].frozen <= priceBattle) ? 0 : (user[_msgSender()].frozen - priceBattle);\\n        user[_msgSender()].frozen = updateFrozen;\\n        user[_msgSender()].money -= priceBattle;\\n        waitingBattles[battleType] = address(0);\\n    }\\n\\n    function _fightBattle(uint256 battleType, address Creator) internal \\n    {\\n        uint256 random = _randomNumber();\\n        uint256 wAmount = forest[Creator][battleType].money * 2;\\n        uint256 fee = (wAmount * 10) / 100;\\n\\n        uint128 skill1 = user_stats[forest[Creator][battleType].player1].skill;\\n        uint128 skill2 = user_stats[forest[Creator][battleType].player2].skill;\\n        uint128 diff = 0;\\n        uint8 chance = 50;\\n\\n        if(skill1 > skill2)\\n        {\\n            diff = skill1 - skill2;\\n            chance = (diff <= 20) ? 60 : 75;\\n        }\\n        else if(skill1 < skill2)\\n        {\\n            diff = skill2 - skill1;\\n            chance = (diff <= 20) ? 40 : 25;\\n        }\\n\\n        address winner = random < chance\\n            ? forest[Creator][battleType].player1\\n            : forest[Creator][battleType].player2;\\n        address loser = random >= chance\\n            ? forest[Creator][battleType].player1\\n            : forest[Creator][battleType].player2;\\n\\n        user[winner].money += wAmount - fee;\\n        forest[Creator][battleType].winner = winner;\\n        forest[Creator][battleType].roll = random;\\n\\n        battles[winner].wins++;\\n        battles[loser].loses++;\\n        totalBattles++;\\n\\n        user[Owner1_receiver].money += fee / 2;\\n        user[Owner2_receiver].money += fee / 2;\\n    }\\n    \\n    function _getLatestPrice() internal view returns (uint) \\n    { \\n        (,int price,,uint timeStamp,)= BNBprice.latestRoundData();\\n        require(timeStamp > 0, \\\"Round not complete\\\");\\n        return (uint)(price * 10000000000); \\n    }\\n\\n    function _getTokenPrice(uint256 decimals) public view returns(uint)\\n    {\\n        IPancakePair pair = IPancakePair(PairAddress);\\n        (uint Res0, uint Res1,) = pair.getReserves();\\n        uint BNB_Price = _getLatestPrice();\\n        uint divider1 = (Res0 > Res1) ? Res1 : Res0;\\n        uint divider2 = (Res0 > Res1) ? Res0 : Res1;\\n        return((divider1*(10**decimals) / divider2) * BNB_Price / 10**decimals);\\n    }\\n\\n    function _verifySignature(bytes memory signature, uint256 deadline, uint32 func, uint256 amount) internal returns (address) \\n    {\\n        require(block.timestamp < deadline, \\\"Deadline has expired\\\");\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(signature, 32))\\n            s := mload(add(signature, 64))\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        require(v == 27 || v == 28, \\\"Invalid signature\\\");\\n\\n        address caller = _msgSender();\\n        \\n        bytes32 digest = keccak256(abi.encode(\\n            caller,\\n            deadline,\\n            func,\\n            amount\\n        ));\\n\\n        require(user[_msgSender()].keccak != digest, \\\"Only 1 activation of the impotence key\\\");\\n        address signer = ecrecover(digest, v, r, s);\\n        require(signer != address(0), \\\"Invalid signer address\\\");\\n        user[_msgSender()].keccak = digest;\\n        return signer;\\n    }\\n}\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AllowedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BankDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Bids\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"character\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"BuyCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Heroes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LastHero\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LastHeroId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DEPOSIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"MakeBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PHASE_1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PHASE_2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ReplenishBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StartNewRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WitchCraft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawElixir\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"_getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"battles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loses\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"battleType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createBattle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roll\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBattles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvestors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"character\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frozen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token_hold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"elixir\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"keccak\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_stats\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"skill\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"skill_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replenished\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refsTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refs1level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refearnUSDT\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"waitingBattles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HogwardsOnline", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://72a3744ee0d9e1e26263bdfcee22505b9cdd75798666c7342ce0f450d18057d4"}