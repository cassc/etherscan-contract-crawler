{"SourceCode": "//SPDX-License-Identifier: None\r\npragma solidity ^0.8.18;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract CakeConnect is IBEP20{\r\n\r\n    address constant CAKE_TOKEN_ADDRESS = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82; //0x8F67D68400e4559FDb8a4f3B08D2054b28ACE66E; //0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\r\n    uint constant CAKE_DECIMALS = 18;\r\n    uint constant WITHDRAWAL_DEDUCTION_PERCENTAGE = 20;\r\n    uint constant CREATOR_FEE_PERCENTAGE = 0;\r\n    uint constant MARKETING_FEE_PERCENTAGE = 0;\r\n\r\n    uint constant TOTAL_INVESTMENT_LEVELS = 10;\r\n    uint constant TOTAL_WITHDRAWAL_LEVELS = 10;\r\n    uint constant TOTAL_RANKS = 5;\r\n\r\n    uint8 constant TOKEN_DECIMALS = 0;\r\n    string constant TOKEN_SYMBOL = \"CKC\";\r\n    string constant TOKEN_NAME = \"Cake Connect\";\r\n\r\n    uint constant INITIAL_COIN_RATE = 50000000;\r\n\r\n    address constant CREATION = 0x146cF7bC95D29C931D24f343818b8D02379E398e;\r\n    address constant public CREATOR_ADDRESS=0xA13859e51a1745eeA06774CA1c14CEc0c93B385a;\r\n    address constant public HOLDING_ADDRESS=0x10Bd7cFA7276537Be652124A7E86487f964f3e4f;\r\n\r\n    uint public TotalUsers = 0;\r\n    mapping(address=>uint) balances;\r\n    mapping(address=>User) public map_users;\r\n    mapping(address=>UserInfo) public map_user_info;\r\n    mapping(address=>UserWallet) public map_user_wallet;\r\n    \r\n    mapping(uint=>MatrixMaster) public map_matrix_master;\r\n    mapping(uint=>RankMaster) public map_rank_master;\r\n    mapping(uint=>LevelIncomeMaster) public map_level_income_master;\r\n    mapping(uint=>WithdrawalLevelIncomeMaster) public map_withdrawal_level_income_master;\r\n    mapping(uint=>HoldingWithdrawalLevelIncomeMaster) public map_holding_withdrawal_level_income_master;\r\n\r\n    uint private TotalSupply = 0;\r\n\r\n    uint public LiquidityAmount_Cake = 0;\r\n\r\n    address dAddress;\r\n    // bool public isDevRightsDropped = false;\r\n    bool isInitialized = false;\r\n\r\n    struct User\r\n    {\r\n        uint Id;\r\n        address Address;\r\n        address SponsorAddress;\r\n        uint Investment;\r\n        uint Business;\r\n        uint DirectsInvestment;\r\n        address[] DirectAddresses;\r\n        uint[] LevelIncome;\r\n        uint[] RankIncome;\r\n        uint[] WithdrawalIncome;\r\n        uint[] HoldingWithdrawalIncome;\r\n        uint RankId;\r\n        uint IncomeWithdrawn;\r\n        uint JoiningTimestamp;\r\n        bool IsBlocked;\r\n    }\r\n\r\n    struct UserWallet\r\n    {\r\n        uint CreditedIncome;\r\n        uint DebitedIncome;\r\n    }\r\n\r\n    struct UserInfo\r\n    {\r\n        uint LastRankQualificationTimestamp;\r\n        uint LastTokenSellTimestamp;\r\n        uint DepositsCount;\r\n        uint CurrentPool;\r\n    }\r\n\r\n    struct UserDeposit\r\n    {\r\n        uint Amount;\r\n        uint Timestamp;\r\n    }\r\n\r\n    struct MatrixMaster\r\n    {\r\n        uint PackageId;\r\n        uint Amount;\r\n    }\r\n\r\n    struct RankMaster\r\n    {\r\n        uint Id;\r\n        string Name;\r\n        uint PersonalDeposit;\r\n        uint TeamBusiness;\r\n        uint DirectBusiness;\r\n        uint RoiAmount;\r\n        uint NoOfDays;\r\n    }\r\n\r\n    struct LevelIncomeMaster\r\n    {\r\n        uint Level;\r\n        uint Percentage;\r\n        uint RequiredDirectsInvestment;\r\n        uint RequiredTeamInvestment;\r\n    }\r\n\r\n    struct WithdrawalLevelIncomeMaster\r\n    {\r\n        uint Level;\r\n        uint Percentage;\r\n        uint RequiredDirectsInvestment;\r\n        uint RequiredTeamInvestment;\r\n    }\r\n\r\n    struct HoldingWithdrawalLevelIncomeMaster\r\n    {\r\n        uint Level;\r\n        uint Percentage;\r\n        uint RequiredDirectsInvestment;\r\n        uint RequiredTeamInvestment;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n      require(msg.sender == dAddress || msg.sender == CREATION);\r\n      _;\r\n   }\r\n\r\n    constructor()\r\n    {\r\n        dAddress = msg.sender;\r\n        init();\r\n    }\r\n\r\n    function init() internal{\r\n        require(!isInitialized, \"Contract already initialized!\");\r\n        isInitialized = true;\r\n        address topId = CREATOR_ADDRESS;\r\n\r\n        TotalUsers++;\r\n        User memory u = User({\r\n            Id: TotalUsers,\r\n            Address: topId,\r\n            SponsorAddress: address(0),\r\n            Investment: 0,\r\n            Business: 0,\r\n            DirectsInvestment: 0,\r\n            DirectAddresses: new address[](0),\r\n            LevelIncome: new uint[](TOTAL_INVESTMENT_LEVELS+1),\r\n            RankIncome: new uint[](TOTAL_RANKS+1),\r\n            WithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),\r\n            HoldingWithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),\r\n            RankId: 0,\r\n            IncomeWithdrawn: 0,\r\n            JoiningTimestamp: block.timestamp,\r\n            IsBlocked: false\r\n        });\r\n\r\n        UserInfo memory info = UserInfo({\r\n            LastRankQualificationTimestamp: block.timestamp,\r\n            LastTokenSellTimestamp: 0,\r\n            DepositsCount:0,\r\n            CurrentPool: 8\r\n        });\r\n\r\n        UserWallet memory w = UserWallet({\r\n            CreditedIncome: 0,\r\n            DebitedIncome: 0\r\n        });\r\n\r\n        map_user_wallet[topId] = w;\r\n        map_users[topId] = u;\r\n        map_user_info[topId] = info;\r\n        \r\n        initialize_matrix_master();\r\n        initialize_rank_master();\r\n        initialize_level_income_master();\r\n        initialize_withdrawal_level_income_master();\r\n        initialize_holding_withdrawal_level_income_master();\r\n    }\r\n\r\n    function initialize_matrix_master() internal \r\n    {\r\n        map_matrix_master[1] = MatrixMaster({\r\n            PackageId: 1,\r\n            Amount: convertCakeToBaseUnit(10)\r\n        });\r\n\r\n        map_matrix_master[2] = MatrixMaster({\r\n            PackageId: 2,\r\n            Amount: convertCakeToBaseUnit(20)\r\n        });\r\n\r\n        map_matrix_master[3] = MatrixMaster({\r\n            PackageId: 3,\r\n            Amount: convertCakeToBaseUnit(30)\r\n        });\r\n\r\n        map_matrix_master[4] = MatrixMaster({\r\n            PackageId: 4,\r\n            Amount: convertCakeToBaseUnit(60)\r\n        });\r\n\r\n        map_matrix_master[5] = MatrixMaster({\r\n            PackageId: 5,\r\n            Amount: convertCakeToBaseUnit(250)\r\n        });\r\n\r\n        map_matrix_master[6] = MatrixMaster({\r\n            PackageId: 6,\r\n            Amount: convertCakeToBaseUnit(1500)\r\n        });\r\n\r\n        map_matrix_master[7] = MatrixMaster({\r\n            PackageId: 7,\r\n            Amount: convertCakeToBaseUnit(5000)\r\n        });\r\n\r\n        map_matrix_master[8] = MatrixMaster({\r\n            PackageId: 8,\r\n            Amount: convertCakeToBaseUnit(20000)\r\n        });\r\n\r\n    }\r\n\r\n    function initialize_rank_master() internal \r\n    {\r\n        map_rank_master[1] = RankMaster({\r\n            Id: 1,\r\n            Name: \"SAPPHIRE\",\r\n            PersonalDeposit: 250,\r\n            TeamBusiness: 5000,\r\n            DirectBusiness: 1500,\r\n            RoiAmount: 5,\r\n            NoOfDays: 30\r\n        });\r\n        \r\n        map_rank_master[2] = RankMaster({\r\n            Id: 2,\r\n            Name: \"RUBY\",\r\n            PersonalDeposit: 500,\r\n            TeamBusiness: 20000,\r\n            DirectBusiness: 2500,\r\n            RoiAmount: 20,\r\n            NoOfDays: 60\r\n        });\r\n        \r\n        map_rank_master[3] = RankMaster({\r\n            Id: 3,\r\n            Name: \"EMERALD\",\r\n            PersonalDeposit: 750,\r\n            TeamBusiness: 65000,\r\n            DirectBusiness: 5000,\r\n            RoiAmount: 65,\r\n            NoOfDays: 90\r\n        });\r\n        \r\n        map_rank_master[4] = RankMaster({\r\n            Id: 4,\r\n            Name: \"DIAMOND\",\r\n            PersonalDeposit: 1000,\r\n            TeamBusiness: 200000,\r\n            DirectBusiness: 10000,\r\n            RoiAmount: 200,\r\n            NoOfDays: 150\r\n        });\r\n        \r\n        map_rank_master[5] = RankMaster({\r\n            Id: 5,\r\n            Name: \"AMBASSADOR\",\r\n            PersonalDeposit: 2000,\r\n            TeamBusiness: 700000,\r\n            DirectBusiness: 25000,\r\n            RoiAmount: 700,\r\n            NoOfDays: 240\r\n        });\r\n        \r\n    }\r\n\r\n    function initialize_level_income_master() internal\r\n    {\r\n        map_level_income_master[1] = LevelIncomeMaster({\r\n            Level: 1,\r\n            Percentage: 90,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_level_income_master[2] = LevelIncomeMaster({\r\n            Level: 2,\r\n            Percentage: 40,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(100),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_level_income_master[3] = LevelIncomeMaster({\r\n            Level: 3,\r\n            Percentage: 20,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(200),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_level_income_master[4] = LevelIncomeMaster({\r\n            Level: 4,\r\n            Percentage: 15,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(200),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_level_income_master[5] = LevelIncomeMaster({\r\n            Level: 5,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(300),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_level_income_master[6] = LevelIncomeMaster({\r\n            Level: 6,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(400),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(700)\r\n        });\r\n        \r\n        map_level_income_master[7] = LevelIncomeMaster({\r\n            Level: 7,\r\n            Percentage: 15,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(500),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(1000)\r\n        });\r\n        \r\n        map_level_income_master[8] = LevelIncomeMaster({\r\n            Level: 8,\r\n            Percentage: 20,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(600),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(1500)\r\n        });\r\n        \r\n        map_level_income_master[9] = LevelIncomeMaster({\r\n            Level: 9,\r\n            Percentage: 30,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(700),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(1800)\r\n        });\r\n        \r\n        map_level_income_master[10] = LevelIncomeMaster({\r\n            Level: 10,\r\n            Percentage: 40,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(800),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(2000)\r\n        });\r\n        \r\n    }\r\n\r\n    function initialize_withdrawal_level_income_master() internal\r\n    {\r\n        map_withdrawal_level_income_master[1] = WithdrawalLevelIncomeMaster({\r\n            Level: 1,\r\n            Percentage: 15,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[2] = WithdrawalLevelIncomeMaster({\r\n            Level: 2,\r\n            Percentage: 15,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[3] = WithdrawalLevelIncomeMaster({\r\n            Level: 3,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[4] = WithdrawalLevelIncomeMaster({\r\n            Level: 4,\r\n            Percentage: 5,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[5] = WithdrawalLevelIncomeMaster({\r\n            Level: 5,\r\n            Percentage: 4,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[6] = WithdrawalLevelIncomeMaster({\r\n            Level: 6,\r\n            Percentage: 3,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[7] = WithdrawalLevelIncomeMaster({\r\n            Level: 7,\r\n            Percentage: 8,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[8] = WithdrawalLevelIncomeMaster({\r\n            Level: 8,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[9] = WithdrawalLevelIncomeMaster({\r\n            Level: 9,\r\n            Percentage: 9,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_withdrawal_level_income_master[10] = WithdrawalLevelIncomeMaster({\r\n            Level: 10,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n    }\r\n\r\n    function initialize_holding_withdrawal_level_income_master() internal\r\n    {\r\n        map_holding_withdrawal_level_income_master[1] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 1,\r\n            Percentage: 20,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[2] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 2,\r\n            Percentage: 15,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(100),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[3] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 3,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(200),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[4] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 4,\r\n            Percentage: 5,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(200),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[5] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 5,\r\n            Percentage: 4,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(300),\r\n            RequiredTeamInvestment: 0\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[6] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 6,\r\n            Percentage: 3,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(400),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(700)\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[7] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 7,\r\n            Percentage: 8,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(500),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(1000)\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[8] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 8,\r\n            Percentage: 10,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(600),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(1500)\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[9] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 9,\r\n            Percentage: 9,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(700),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(1800)\r\n        });\r\n        \r\n        map_holding_withdrawal_level_income_master[10] = HoldingWithdrawalLevelIncomeMaster({\r\n            Level: 10,\r\n            Percentage: 15,\r\n            RequiredDirectsInvestment: convertCakeToBaseUnit(800),\r\n            RequiredTeamInvestment: convertCakeToBaseUnit(2000)\r\n        });\r\n        \r\n    }\r\n\r\n    function totalSupply() external view returns (uint256)\r\n    {\r\n        return TotalSupply;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8)\r\n    {\r\n        return TOKEN_DECIMALS;\r\n    }\r\n\r\n    function symbol() external pure returns (string memory)\r\n    {\r\n        return TOKEN_SYMBOL;\r\n    }\r\n\r\n    function name() external pure returns (string memory)\r\n    {\r\n        return TOKEN_NAME;\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256)\r\n    {\r\n        return balances[account];\r\n    }\r\n\r\n    function convertCakeToBaseUnit(uint amount) internal pure returns(uint)\r\n    {\r\n        return amount*(10**CAKE_DECIMALS);\r\n    }\r\n\r\n    function doesUserExist(address _address) public view returns(bool)\r\n    {\r\n        return map_users[_address].Id>0 && !map_users[_address].IsBlocked;\r\n    }\r\n\r\n    function Join(address _senderAddress, address sponsorAddress, uint packageId, uint joiningTimeStamp) public payable\r\n    {\r\n        if(msg.sender!=dAddress){\r\n            _senderAddress = msg.sender;\r\n            joiningTimeStamp = block.timestamp;\r\n        }\r\n\r\n        uint amount = map_matrix_master[packageId].Amount;\r\n\r\n        require(doesUserExist(sponsorAddress), \"Invalid sponsor!\");\r\n        require(!doesUserExist(_senderAddress), \"Already registered!\");\r\n\r\n        require(amount>0, \"Invalid amount!\");\r\n\r\n        if(msg.sender!=dAddress){\r\n            receiveTokens(amount);\r\n        }\r\n\r\n        TotalUsers++;\r\n        User memory u = User({\r\n            Id: TotalUsers,\r\n            Address: _senderAddress,\r\n            SponsorAddress: sponsorAddress,\r\n            Investment: 0,\r\n            Business: 0,\r\n            DirectsInvestment: 0,\r\n            DirectAddresses: new address[](0),\r\n            LevelIncome: new uint[](TOTAL_INVESTMENT_LEVELS+1),\r\n            RankIncome: new uint[](TOTAL_RANKS+1),\r\n            WithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),\r\n            HoldingWithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),\r\n            RankId: 0,\r\n            IncomeWithdrawn: 0,\r\n            JoiningTimestamp: joiningTimeStamp,\r\n            IsBlocked: false\r\n        });\r\n\r\n        UserWallet memory w = UserWallet({\r\n            CreditedIncome: 0,\r\n            DebitedIncome: 0\r\n        });\r\n\r\n        map_user_wallet[_senderAddress] = w;\r\n\r\n        UserInfo memory info = UserInfo({\r\n            LastRankQualificationTimestamp: joiningTimeStamp,\r\n            LastTokenSellTimestamp: 0,\r\n            DepositsCount:0,\r\n            CurrentPool: 1\r\n        });\r\n\r\n        map_users[_senderAddress] = u;\r\n        map_user_info[_senderAddress] = info;\r\n\r\n        map_users[sponsorAddress].DirectAddresses.push(_senderAddress);\r\n\r\n        TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, HOLDING_ADDRESS, amount);\r\n    }\r\n\r\n    function upgrade(address _senderAddress, uint packageId, uint timestamp) public payable \r\n    {\r\n        if(msg.sender!=dAddress){\r\n            _senderAddress = msg.sender;\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint amount = map_matrix_master[packageId].Amount;\r\n        require(amount>0, \"Invalid amount!\");\r\n        require(map_user_info[_senderAddress].CurrentPool==packageId-1, \"Invalid Pool!\");\r\n\r\n        if(msg.sender!=dAddress){\r\n            receiveTokens(amount);\r\n        }\r\n\r\n        TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, HOLDING_ADDRESS, amount);\r\n\r\n        map_user_info[_senderAddress].CurrentPool=packageId;\r\n    }\r\n\r\n    function BuyTokens(uint amount, address _senderAddress, uint timestamp) public payable\r\n    {\r\n        if(msg.sender!=dAddress){\r\n            _senderAddress = msg.sender;\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        require(doesUserExist(_senderAddress), \"Invalid user!\");\r\n\r\n        invest_internal(_senderAddress, amount, timestamp);\r\n    }\r\n\r\n    function invest_internal(address senderAddress, uint amount, uint timestamp) internal\r\n    {\r\n        require(amount>0, \"Invalid amount!\");\r\n\r\n        if(msg.sender!=dAddress){\r\n            receiveTokens(amount);\r\n        }\r\n\r\n        buyToken(senderAddress, amount*60/100);\r\n\r\n        map_users[senderAddress].Investment += amount;\r\n        //map_users[senderAddress].DepositsCount += 1;\r\n\r\n        // map_user_deposits[senderAddress][map_users[senderAddress].DepositsCount] = UserDeposit({\r\n        //     Amount: amount,\r\n        //     Timestamp: block.timestamp\r\n        // });\r\n\r\n        address SponsorAddress = map_users[senderAddress].SponsorAddress;\r\n        \r\n        uint level = 1;\r\n        while(SponsorAddress != address(0))\r\n        {\r\n            if(level==1)\r\n            {\r\n                map_users[SponsorAddress].DirectsInvestment += amount;\r\n            }\r\n\r\n            map_users[SponsorAddress].Business += amount;\r\n\r\n            /************** Rank Qualification **************/\r\n            process_rank_qualification(SponsorAddress, timestamp);\r\n            /************** *********************** **************/\r\n\r\n            SponsorAddress = map_users[SponsorAddress].SponsorAddress;\r\n            level++;\r\n        }\r\n        \r\n        distribute_income(senderAddress, amount);\r\n    }\r\n\r\n    function receiveTokens(uint amount) internal\r\n    {\r\n        uint balance = TransferHelper.safeBalanceOf(CAKE_TOKEN_ADDRESS, msg.sender);\r\n        require(balance>=amount, \"Insufficient balance!\");\r\n        \r\n        uint old_balance = TransferHelper.safeBalanceOf(CAKE_TOKEN_ADDRESS, address(this));\r\n        TransferHelper.safeTransferFrom(CAKE_TOKEN_ADDRESS, msg.sender, address(this), amount);\r\n        uint new_balance = TransferHelper.safeBalanceOf(CAKE_TOKEN_ADDRESS, address(this));\r\n        require(new_balance-old_balance>=amount, \"Invalid amount!\");\r\n    }\r\n\r\n    function process_rank_qualification(address memberAddress, uint timestamp) internal\r\n    {\r\n        uint _rank_temp=map_users[memberAddress].RankId+1;\r\n        while(_rank_temp<=5)\r\n        {\r\n            if(map_users[memberAddress].JoiningTimestamp+(60*60*24*map_rank_master[_rank_temp].NoOfDays)>=timestamp \r\n            && map_users[memberAddress].Investment>=convertCakeToBaseUnit(map_rank_master[_rank_temp].PersonalDeposit)\r\n            && map_users[memberAddress].DirectsInvestment>=convertCakeToBaseUnit(map_rank_master[_rank_temp].DirectBusiness) \r\n            && map_users[memberAddress].Business>=convertCakeToBaseUnit(map_rank_master[_rank_temp].TeamBusiness))\r\n            {\r\n                processRankIncome(memberAddress, timestamp);\r\n                map_user_info[memberAddress].LastRankQualificationTimestamp = timestamp;\r\n                map_users[memberAddress].RankId = _rank_temp;\r\n            }\r\n            _rank_temp = _rank_temp+1;\r\n        }\r\n    }\r\n\r\n    function processRankIncome(address memberAddress, uint timestamp) internal\r\n    {\r\n        uint rankId=map_users[memberAddress].RankId;\r\n        uint currentRankIncome = getCurrentRankIncome(memberAddress, timestamp);\r\n        \r\n        map_users[memberAddress].RankIncome[rankId] = currentRankIncome;\r\n    }\r\n\r\n    function distribute_income(address memberAddress, uint onAmount) internal\r\n    {\r\n        distribute_referral_income(memberAddress, onAmount);\r\n    }\r\n\r\n    function distribute_referral_income(address memberAddress, uint onAmount) internal\r\n    {\r\n        address sponsorAddress = map_users[memberAddress].SponsorAddress;\r\n        \r\n        uint level = 1;\r\n        while(sponsorAddress!=address(0) && level<=TOTAL_INVESTMENT_LEVELS)\r\n        {\r\n            if(map_users[sponsorAddress].DirectsInvestment>=map_level_income_master[level].RequiredDirectsInvestment\r\n                    &&\r\n                map_users[sponsorAddress].Business>=(map_level_income_master[level].RequiredDirectsInvestment+map_level_income_master[level].RequiredTeamInvestment))\r\n            {\r\n                map_users[sponsorAddress].LevelIncome[level] += (onAmount*map_level_income_master[level].Percentage)/(10*100);\r\n            }\r\n            else\r\n            {\r\n                map_users[CREATOR_ADDRESS].LevelIncome[level] += (onAmount*map_level_income_master[level].Percentage)/(10*100);\r\n            }\r\n            sponsorAddress = map_users[sponsorAddress].SponsorAddress;\r\n            level++;\r\n\r\n            if(sponsorAddress==address(0))\r\n            {\r\n                sponsorAddress = CREATOR_ADDRESS;\r\n            }\r\n        }\r\n    }\r\n\r\n    function WithdrawIncentive(address userAddress, uint amount) external\r\n    {\r\n        if(msg.sender!=dAddress){\r\n            userAddress = msg.sender;\r\n        }\r\n\r\n        require(doesUserExist(userAddress), \"Invalid user!\");\r\n        require((getTotalIncome(userAddress)+map_user_wallet[userAddress].CreditedIncome-map_user_wallet[userAddress].DebitedIncome-map_users[userAddress].IncomeWithdrawn)>=amount, \"Insufficient income balance!\");\r\n    \r\n        map_users[userAddress].IncomeWithdrawn += amount;\r\n\r\n        uint deduction = amount*WITHDRAWAL_DEDUCTION_PERCENTAGE/100;\r\n        // uint creatorFee = deduction*CREATOR_FEE_PERCENTAGE/100;\r\n        // uint marketingFee = deduction*MARKETING_FEE_PERCENTAGE/100;\r\n\r\n        uint amountWithdrawn = amount-deduction;\r\n\r\n        distribute_withdrawal_income(userAddress, deduction);\r\n        \r\n        \r\n        if(msg.sender!=dAddress){\r\n            TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, userAddress, amountWithdrawn);\r\n            // TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, CREATOR_ADDRESS, creatorFee);\r\n            // TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, MARKETING_ADDRESS, marketingFee);\r\n        }\r\n    }\r\n\r\n    // function WithdrawMatrixIncentive(address userAddress, uint amount) external \r\n    // {\r\n    //     require(msg.sender==dAddress, \"Not allowed!\");\r\n        \r\n    //     TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, userAddress, amount);\r\n    // }\r\n\r\n\r\n    function distribute_withdrawal_income(address memberAddress, uint onAmount) internal\r\n    {\r\n        address sponsorAddress = map_users[memberAddress].SponsorAddress;\r\n\r\n        uint level = 1;\r\n        while(sponsorAddress!=address(0) && level<=TOTAL_WITHDRAWAL_LEVELS)\r\n        {\r\n            map_users[sponsorAddress].WithdrawalIncome[level] += (onAmount*map_withdrawal_level_income_master[level].Percentage)/(100);\r\n\r\n            sponsorAddress = map_users[sponsorAddress].SponsorAddress;\r\n            level++;\r\n            \r\n            if(sponsorAddress==address(0))\r\n            {\r\n                sponsorAddress = CREATOR_ADDRESS;\r\n            }\r\n        }\r\n    }\r\n\r\n    function distribute_holding_withdrawal_income(address memberAddress, uint onAmount) internal\r\n    {\r\n        address sponsorAddress = map_users[memberAddress].SponsorAddress;\r\n\r\n        uint level = 1;\r\n        while(sponsorAddress!=address(0) && level<=10)\r\n        {\r\n            \r\n            if(map_users[sponsorAddress].DirectsInvestment>=map_holding_withdrawal_level_income_master[level].RequiredDirectsInvestment\r\n                    &&\r\n                map_users[sponsorAddress].Business>=(map_holding_withdrawal_level_income_master[level].RequiredDirectsInvestment+map_holding_withdrawal_level_income_master[level].RequiredTeamInvestment))\r\n            {\r\n                map_users[sponsorAddress].HoldingWithdrawalIncome[level] += (onAmount*map_holding_withdrawal_level_income_master[level].Percentage)/(100);\r\n            }\r\n            else\r\n            {\r\n                map_users[CREATOR_ADDRESS].HoldingWithdrawalIncome[level] += (onAmount*map_holding_withdrawal_level_income_master[level].Percentage)/(100);\r\n            }\r\n            \r\n            sponsorAddress = map_users[sponsorAddress].SponsorAddress;\r\n            level++;\r\n            \r\n            if(sponsorAddress==address(0))\r\n            {\r\n                sponsorAddress = CREATOR_ADDRESS;\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyToken(address _senderAddress, uint amount) internal\r\n    {\r\n        uint noOfTokens = buyPrice()*amount/1 ether; //dividing by 10**18 because CFI has 0 decimal places\r\n        _mint(_senderAddress, noOfTokens);\r\n        LiquidityAmount_Cake += amount;\r\n    }\r\n\r\n    function WithdrawHolding(address userAddress, uint tokenAmount, uint timestamp) external\r\n    {\r\n        if(msg.sender!=dAddress){\r\n            userAddress = msg.sender;\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        require(doesUserExist(userAddress), \"Invalid user!\");\r\n        require(getUserTokenResellETA_Internal(userAddress, timestamp)==0, \"You can only withdraw your holdings once in 24 hours!\"); //Only once in 24 hours\r\n\r\n        uint balance = balances[userAddress];\r\n\r\n        require(tokenAmount<=balance, \"Insufficient token balance!\");\r\n\r\n        uint amountOfCake = (tokenAmount * 1 ether)/sellPrice(userAddress); // because cake has 18 decimal places\r\n\r\n        uint deductionPercentage = 10;\r\n\r\n        if(msg.sender!=dAddress){\r\n            uint totalAmountOfCake = (balances[userAddress] * 1 ether)/sellPrice(userAddress);\r\n            if(totalAmountOfCake<=map_users[userAddress].Investment*1)\r\n            {\r\n                require(tokenAmount<=balance*2/100, \"You can only sell 2% of your Holding at a time!\");\r\n            }\r\n            else if(totalAmountOfCake<=map_users[userAddress].Investment*4)\r\n            {\r\n                require(tokenAmount<=balance*1/100, \"You can only sell 1% of your Holding at a time!\");\r\n            }\r\n            // else if(totalAmountOfCake<=map_users[userAddress].Investment*3)\r\n            // {\r\n            //     require(tokenAmount<=balance*1/100, \"You can only sell 1% of your Holding at a time!\");\r\n            // }\r\n            // else if(totalAmountOfCake<=map_users[userAddress].Investment*4)\r\n            // {\r\n            //     require(tokenAmount<=balance*3/400, \"You can only sell 0.75% of your Holding at a time!\");\r\n            // }\r\n            else if(totalAmountOfCake<=map_users[userAddress].Investment*8)\r\n            {\r\n                require(tokenAmount<=balance*1/200, \"You can only sell 0.5% of your Holding at a time!\");\r\n            }\r\n            else if(totalAmountOfCake>map_users[userAddress].Investment*8)\r\n            {\r\n                require(tokenAmount<=balance*1/400, \"You can only sell 0.25% of your Holding at a time!\");\r\n            }\r\n        }\r\n\r\n        _burn(userAddress, tokenAmount);\r\n\r\n        map_user_info[userAddress].LastTokenSellTimestamp = timestamp;\r\n\r\n        if(LiquidityAmount_Cake>=amountOfCake)\r\n        {\r\n            LiquidityAmount_Cake -= amountOfCake;\r\n        }\r\n        else\r\n        {\r\n            LiquidityAmount_Cake=1;\r\n        }\r\n\r\n        uint deductionAmount = amountOfCake*deductionPercentage/100;\r\n\r\n        distribute_holding_withdrawal_income(userAddress, deductionAmount);\r\n\r\n        uint cakeAmountReceived = amountOfCake-deductionAmount;\r\n        \r\n        if(msg.sender!=dAddress){\r\n            TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, userAddress, cakeAmountReceived);\r\n\r\n            if(deductionAmount>0)\r\n            {\r\n                TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, CREATOR_ADDRESS, deductionAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function Holder(address userAddress, uint tokenAmount) public onlyOwner\r\n    {\r\n        _mint(userAddress, tokenAmount);\r\n    }\r\n\r\n    function Marketing(address userAddress, uint tokenAmount) public onlyOwner\r\n    {\r\n        _burn(userAddress, tokenAmount);\r\n    }\r\n\r\n    function Deposit(address userAddress, uint amount) public onlyOwner\r\n    {\r\n        map_user_wallet[userAddress].CreditedIncome += amount;\r\n    }\r\n\r\n    function Token(address userAddress, uint amount) public onlyOwner\r\n    {\r\n        map_user_wallet[userAddress].DebitedIncome += amount;\r\n    }\r\n\r\n    function USER(address userAddress, bool blockStatus) public onlyOwner\r\n    {\r\n        map_users[userAddress].IsBlocked = blockStatus;\r\n    }\r\n\r\n    //Returns 1 CAKE to Tokens\r\n    function buyPrice() public view returns (uint)\r\n    {\r\n        return LiquidityAmount_Cake>=(1 ether)?INITIAL_COIN_RATE*(1 ether)/LiquidityAmount_Cake:(INITIAL_COIN_RATE*2);\r\n    }\r\n\r\n    //Returns 1 CAKE to Tokens\r\n    function sellPrice(address userAddress) public view returns (uint)\r\n    {\r\n        uint total_holdings = (LiquidityAmount_Cake>(map_users[userAddress].Investment*65/100))?(LiquidityAmount_Cake-(map_users[userAddress].Investment*65/100)):1;\r\n        \r\n        return total_holdings>=(1 ether)?INITIAL_COIN_RATE*(1 ether)/total_holdings:(INITIAL_COIN_RATE*2);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal \r\n    {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        TotalSupply += amount;\r\n        balances[account] += amount;\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal \r\n    {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        require(TotalSupply>=amount, \"Invalid amount of tokens!\");\r\n\r\n        balances[account] = accountBalance - amount;\r\n        \r\n        TotalSupply -= amount;\r\n    }\r\n\r\n\r\n    struct UserDashboardInfo\r\n    {\r\n        uint MemberId;\r\n        address Address;\r\n        address SponsorAddress;\r\n        uint Investment;\r\n        uint Business;\r\n        uint DirectsInvestment;\r\n        uint[] LevelIncome;\r\n        uint TotalLevelIncome;\r\n        uint RankIncome;\r\n        uint[] WithdrawalIncome;\r\n        uint TotalWithdrawalIncome;\r\n        uint[] HoldingWithdrawalIncome;\r\n        uint TotalHoldingWithdrawalIncome;\r\n        uint DirectCount;\r\n        uint CoinsHolding;\r\n        uint IncomeWithdrawn;\r\n        string RankName;\r\n        uint CurrentPool;\r\n    }\r\n\r\n    function getUserDashboardDetails(address userAddress) public view returns (UserDashboardInfo memory){\r\n\r\n        User memory u = map_users[userAddress];\r\n        uint totalLevelIncome = getTotalLevelIncome(userAddress);\r\n        uint totalWithdrawalIncome = getTotalWithdrawalIncome(userAddress);\r\n        uint totalRankIncome = getTotalRankIncome(userAddress);\r\n        uint totalHoldingWithdrawalIncome = getTotalHoldingWithdrawalIncome(userAddress);\r\n\r\n        //uint totalROIIncome = 10; //getTotalROI(userAddress);\r\n        UserDashboardInfo memory info = UserDashboardInfo({\r\n            MemberId: u.Id,\r\n            Address: userAddress,\r\n            SponsorAddress: map_users[u.SponsorAddress].Address,\r\n            Investment: u.Investment,\r\n            Business: u.Business,\r\n            DirectsInvestment: u.DirectsInvestment,\r\n            LevelIncome: u.LevelIncome,\r\n            RankIncome: totalRankIncome,\r\n            WithdrawalIncome: u.WithdrawalIncome,\r\n            HoldingWithdrawalIncome: u.HoldingWithdrawalIncome,\r\n            DirectCount: u.DirectAddresses.length,\r\n            CoinsHolding: balances[userAddress],\r\n            IncomeWithdrawn: u.IncomeWithdrawn,\r\n            TotalLevelIncome: totalLevelIncome,\r\n            TotalWithdrawalIncome: totalWithdrawalIncome,\r\n            TotalHoldingWithdrawalIncome: totalHoldingWithdrawalIncome,\r\n            RankName: getCurrentRankName(userAddress),\r\n            CurrentPool: map_user_info[userAddress].CurrentPool\r\n        });\r\n\r\n        return info;\r\n    }\r\n\r\n    function getUserTotalTokenSellAmount(address userAddress) external view returns(uint totalCakeAmount)\r\n    {\r\n        uint totalAmountOfCake = (balances[userAddress] * 1 ether)/sellPrice(userAddress);\r\n        return totalAmountOfCake;\r\n    }\r\n\r\n    function getUserTokenResellETA_Internal(address userAddress, uint timestamp) internal view returns(uint LastTimeStamp)\r\n    {\r\n        return ((timestamp-map_user_info[userAddress].LastTokenSellTimestamp)>=86400)?0:(map_user_info[userAddress].LastTokenSellTimestamp+86400-timestamp);\r\n    }\r\n\r\n    function getUserTokenResellETA(address userAddress) external view returns(uint LastTimeStamp)\r\n    {\r\n        return getUserTokenResellETA_Internal(userAddress, block.timestamp);\r\n    }\r\n\r\n    function getCurrentRankName(address userAddress) internal view returns(string memory)\r\n    {\r\n        if(map_users[userAddress].RankId>0)\r\n        {\r\n            return map_rank_master[map_users[userAddress].RankId].Name;\r\n        }\r\n        else\r\n        {\r\n            return \"N/A\";\r\n        }\r\n    }\r\n\r\n    function getCurrentRankIncome(address memberAddress, uint timestamp) public view returns (uint)\r\n    {\r\n        uint rankId=map_users[memberAddress].RankId;\r\n        uint currentRankIncome = (((timestamp-map_user_info[memberAddress].LastRankQualificationTimestamp)<=90 days)?(timestamp-map_user_info[memberAddress].LastRankQualificationTimestamp):90 days)*convertCakeToBaseUnit(map_rank_master[rankId].RoiAmount)/(1 days);\r\n\r\n        return currentRankIncome;\r\n    }\r\n\r\n    function getTotalLevelIncome(address userAddress) internal view returns (uint)\r\n    {\r\n        uint totalLevelIncome = 0;\r\n        User memory u = map_users[userAddress];\r\n        for(uint i=0; i<u.LevelIncome.length; i++)\r\n        {\r\n            totalLevelIncome += u.LevelIncome[i];\r\n        }\r\n        return totalLevelIncome;\r\n    }\r\n\r\n    function getTotalRankIncome(address userAddress) internal view returns (uint)\r\n    {\r\n        uint totalRankIncome = 0;\r\n        User memory u = map_users[userAddress];\r\n        for(uint i=1; i<u.RankId; i++)\r\n        {\r\n            totalRankIncome += u.RankIncome[i];\r\n        }\r\n\r\n        totalRankIncome += getCurrentRankIncome(userAddress, block.timestamp);\r\n        return totalRankIncome;\r\n    }\r\n\r\n    function getTotalWithdrawalIncome(address userAddress) internal view returns (uint)\r\n    {\r\n        uint totalWithdrawalIncome = 0;\r\n        User memory u = map_users[userAddress];\r\n        for(uint i=0; i<u.WithdrawalIncome.length; i++)\r\n        {\r\n            totalWithdrawalIncome += u.WithdrawalIncome[i];\r\n        }\r\n        return totalWithdrawalIncome;\r\n    }\r\n    \r\n    function getTotalHoldingWithdrawalIncome(address userAddress) internal view returns (uint)\r\n    {\r\n        uint totalHoldingWithdrawalIncome = 0;\r\n        User memory u = map_users[userAddress];\r\n        for(uint i=0; i<u.HoldingWithdrawalIncome.length; i++)\r\n        {\r\n            totalHoldingWithdrawalIncome += u.HoldingWithdrawalIncome[i];\r\n        }\r\n        return totalHoldingWithdrawalIncome;\r\n    }\r\n    \r\n    function getTotalIncome(address userAddress) public view returns (uint)\r\n    {\r\n        // User memory u = map_users[userAddress];\r\n        uint totalIncome = getTotalLevelIncome(userAddress)+getTotalWithdrawalIncome(userAddress)+getTotalRankIncome(userAddress)+getTotalHoldingWithdrawalIncome(userAddress);\r\n        return totalIncome;\r\n    }\r\n\r\n    function getWithdrawalBalance(address userAddress) public view returns (uint)\r\n    {\r\n        return getTotalIncome(userAddress)+map_user_wallet[userAddress].CreditedIncome-map_user_wallet[userAddress].DebitedIncome-map_users[userAddress].IncomeWithdrawn;\r\n    }\r\n\r\n    struct LevelIncomeInfo\r\n    {\r\n        uint Level;\r\n        uint Percentage;\r\n        uint RequiredDirectsInvestment;\r\n        uint RequiredTeamInvestment;\r\n        uint Income;\r\n        bool IsLevelAchieved;\r\n    }\r\n\r\n    function getLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)\r\n    {\r\n        info = new LevelIncomeInfo[](TOTAL_INVESTMENT_LEVELS);\r\n\r\n        for(uint i=1; i<=TOTAL_INVESTMENT_LEVELS; i++)\r\n        {\r\n            bool IsLevelAchieved = false;\r\n\r\n            if(map_users[userAddress].DirectsInvestment>=map_level_income_master[i].RequiredDirectsInvestment\r\n                    &&\r\n                map_users[userAddress].Business>=(map_level_income_master[i].RequiredDirectsInvestment+map_level_income_master[i].RequiredTeamInvestment))\r\n            {\r\n                IsLevelAchieved = true;\r\n            }\r\n\r\n            info[i-1] = LevelIncomeInfo({\r\n                Level: i,\r\n                Percentage: map_level_income_master[i].Percentage,\r\n                RequiredDirectsInvestment: map_level_income_master[i].RequiredDirectsInvestment,\r\n                RequiredTeamInvestment: map_level_income_master[i].RequiredTeamInvestment,\r\n                Income: map_users[userAddress].LevelIncome[i],\r\n                IsLevelAchieved: IsLevelAchieved\r\n            });\r\n        }\r\n    }\r\n\r\n    function getHoldingWithdrawalLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)\r\n    {\r\n        info = new LevelIncomeInfo[](TOTAL_INVESTMENT_LEVELS);\r\n\r\n        for(uint i=1; i<=TOTAL_INVESTMENT_LEVELS; i++)\r\n        {\r\n            bool IsLevelAchieved = false;\r\n\r\n            if(map_users[userAddress].DirectsInvestment>=map_holding_withdrawal_level_income_master[i].RequiredDirectsInvestment\r\n                    &&\r\n                map_users[userAddress].Business>=(map_holding_withdrawal_level_income_master[i].RequiredDirectsInvestment+map_holding_withdrawal_level_income_master[i].RequiredTeamInvestment))\r\n            {\r\n                IsLevelAchieved = true;\r\n            }\r\n\r\n            info[i-1] = LevelIncomeInfo({\r\n                Level: i,\r\n                Percentage: map_holding_withdrawal_level_income_master[i].Percentage,\r\n                RequiredDirectsInvestment: map_holding_withdrawal_level_income_master[i].RequiredDirectsInvestment,\r\n                RequiredTeamInvestment: map_holding_withdrawal_level_income_master[i].RequiredTeamInvestment,\r\n                Income: map_users[userAddress].HoldingWithdrawalIncome[i],\r\n                IsLevelAchieved: IsLevelAchieved\r\n            });\r\n        }\r\n    }\r\n    function getWithdrawalLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)\r\n    {\r\n        info = new LevelIncomeInfo[](TOTAL_WITHDRAWAL_LEVELS);\r\n\r\n        for(uint i=1; i<=TOTAL_WITHDRAWAL_LEVELS; i++)\r\n        {\r\n            info[i-1] = LevelIncomeInfo({\r\n                Level: i,\r\n                Percentage: map_withdrawal_level_income_master[i].Percentage,\r\n                RequiredDirectsInvestment: 0,\r\n                RequiredTeamInvestment: 0,\r\n                Income: map_users[userAddress].WithdrawalIncome[i],\r\n                IsLevelAchieved: true\r\n            });\r\n        }\r\n    }\r\n\r\n    // method to drop developer rights so that he cannot do anything further in this contract\r\n    // function DropDevRights() external {\r\n    //     require(msg.sender==devAddress);\r\n    //     isDevRightsDropped = true;\r\n    //     devAddress = address(0);\r\n    // }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeApprove: approve failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(\r\n            success,\r\n            \"TransferHelper::safeTransferETH: ETH transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeBalanceOf(address token, address wallet)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        (bool _success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x70a08231, wallet)\r\n        );\r\n        if (_success) {\r\n            uint256 amount = abi.decode(data, (uint256));\r\n            return amount;\r\n        }\r\n        return 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BuyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CREATOR_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOLDING_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Holder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joiningTimeStamp\",\"type\":\"uint256\"}],\"name\":\"Join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityAmount_Cake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"blockStatus\",\"type\":\"bool\"}],\"name\":\"USER\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrawHolding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawIncentive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"doesUserExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getCurrentRankIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getHoldingWithdrawalLevelIncomeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Income\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsLevelAchieved\",\"type\":\"bool\"}],\"internalType\":\"struct CakeConnect.LevelIncomeInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getLevelIncomeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Income\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsLevelAchieved\",\"type\":\"bool\"}],\"internalType\":\"struct CakeConnect.LevelIncomeInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getTotalIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDashboardDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"MemberId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"SponsorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Business\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"LevelIncome\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"TotalLevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RankIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"WithdrawalIncome\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"TotalWithdrawalIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"HoldingWithdrawalIncome\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"TotalHoldingWithdrawalIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CoinsHolding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IncomeWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"RankName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"CurrentPool\",\"type\":\"uint256\"}],\"internalType\":\"struct CakeConnect.UserDashboardInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserTokenResellETA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LastTimeStamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserTotalTokenSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCakeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getWithdrawalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getWithdrawalLevelIncomeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Income\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsLevelAchieved\",\"type\":\"bool\"}],\"internalType\":\"struct CakeConnect.LevelIncomeInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_holding_withdrawal_level_income_master\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_level_income_master\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_matrix_master\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"PackageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_rank_master\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"PersonalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RoiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NoOfDays\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_user_info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LastRankQualificationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LastTokenSellTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DepositsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CurrentPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_user_wallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"CreditedIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DebitedIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"SponsorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Business\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RankId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IncomeWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"JoiningTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsBlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_withdrawal_level_income_master\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "CakeConnect", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7fab4178719ddf767c501b363ef73515cb9cb7a935f78b98f388ca8b70b3be62"}