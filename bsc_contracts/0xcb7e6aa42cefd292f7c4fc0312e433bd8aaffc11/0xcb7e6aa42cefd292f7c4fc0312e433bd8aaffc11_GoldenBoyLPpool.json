{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n    contract GoldenBoyLPpool {\r\n        using SafeMath for uint256;\r\n        address private _owner;\r\n        IUniswapV2Router02 public uniswapV2Router;\r\n         uint256 constant public PERCENTS_DIVIDER = 1000;\r\n        uint256 constant public TIME_STEP = 1 days;\r\n        address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \r\n        address public  Wallet_Market=0xc897D7597C7a5ad8aE280925B911bDe874939785; \r\n        address public Wallet_GboyPool;\r\n        address  public Wallet_Project = 0x36f2dAE586cC46fA9fbfe10DdadBbBbfFd178AD8;\r\n        address payable public Wallet_FirstEcology;\r\n        bool private isburn;\r\n        address public _gldycoinAddr;\r\n        address public _subycoinAddr;\r\n         uint256 public _beginLPTime;\r\n         uint256 public totalLP;\r\n        uint256 private totalGivenLP;\r\n        uint256 private LPBonus;\r\n        uint256 private LPGivenBonus;\r\n        uint256 public totalLPWithdrawn;\r\n        uint256 public MaxSellFEE;\r\n        uint256 public totalBurn;\r\n        bool private swapping;\r\n        struct Deposit {\r\n            uint256 start;\r\n            uint256 amount;\r\n        }\r\n        struct User {\r\n            Deposit[] deposits;\r\n            uint256 checkpoint;\r\n            uint256 bonus;\r\n            uint256 withdrawn;\r\n        }\r\n        mapping(address => User) public LPUsers;\r\n       \r\n        tokenInterFace GldyToken;\r\n        tokenInterFace SubyToken;\r\n        poolInterFace GBoyPool;\r\n\r\n        event CandyWithdrawn(address indexed user, uint256 amount);\r\n        event NewCandy(address indexed user,address referrer);\r\n        event CandyUnlock(address indexed user,uint256 amount);\r\n        event NewDeposit(address indexed user, uint256 amount);\r\n        event WithdrawnLP(address indexed user, uint256 amount);\r\n        \r\n\t\r\n        constructor()   {\r\n            _owner = msg.sender;\r\n            IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \r\n            //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); \r\n            uniswapV2Router = _uniswapV2Router;\r\n\r\n            _beginLPTime = 1657022400;\r\n            //_beginLPTime = block.timestamp;\r\n            LPBonus=700* 10 ** 18;\r\n            LPGivenBonus=300* 10 ** 18;\r\n            MaxSellFEE=100000* 10 ** 18;\r\n   \r\n        }\r\n        receive() external payable {}\r\n\r\n        function buyLP(address referrer,uint256 tokenAmount) public  {\r\n\r\n            require(tokenAmount > 0);\r\n            uint balances = GldyToken.balanceOf(msg.sender);\r\n            require(balances>=tokenAmount, \"It's not enough  Token\");\r\n            require(block.timestamp > _beginLPTime);\r\n            require( GldyToken.transferFrom(msg.sender,address(this), tokenAmount),\"token transfer failed\");\r\n            uint256 burnAmount=tokenAmount.mul(400).div(PERCENTS_DIVIDER);\r\n            uint256 referralBonus = tokenAmount.mul(300).div(PERCENTS_DIVIDER);\r\n            uint256 contributionBonus = tokenAmount.mul(100).div(PERCENTS_DIVIDER);\r\n            uint256 projectBonus = tokenAmount.mul(100).div(PERCENTS_DIVIDER);\r\n            uint256 shareBonus = tokenAmount.sub(burnAmount).sub(referralBonus).sub(contributionBonus).sub(projectBonus);\r\n            if (GBoyPool.Referrers(msg.sender) == address(0) &&  referrer != msg.sender) {\r\n                GBoyPool.setReferrer(msg.sender,referrer);\r\n            }\r\n            address upline = GBoyPool.getGtokenReferrer(msg.sender);\r\n            if(upline != address(0)){\r\n                GldyToken.transfer(upline, referralBonus);\r\n            }\r\n            else{\r\n                burnAmount=burnAmount+referralBonus;\r\n            }\r\n            totalBurn=totalBurn+burnAmount;\r\n            if (!swapping && totalBurn>=MaxSellFEE) {\r\n                swapping = true;\r\n\r\n                swapTokensForBNB(_gldycoinAddr,totalBurn);\r\n                totalBurn=0;\r\n                uint256 balance= address(this).balance;\r\n                \r\n                payable(_subycoinAddr).transfer(balance );\r\n                swapping=false;\r\n            }\r\n\r\n            upline = GBoyPool.Referrers(msg.sender);\r\n            while(upline != address(0)){\r\n                if(GBoyPool.Level(upline)==2||upline==_owner){\r\n                    GldyToken.transfer(upline, contributionBonus);\r\n                    break;\r\n                }\r\n                upline =GBoyPool.Referrers(upline);\r\n                }\r\n\r\n            GldyToken.transfer(Wallet_Project, projectBonus);\r\n            GldyToken.transfer(Wallet_FirstEcology, shareBonus);\r\n            tokenInterFace(Wallet_FirstEcology).addSharePools(shareBonus,0,1);\r\n            totalLP=totalLP+tokenAmount;\r\n            User storage lpuser=LPUsers[msg.sender];\r\n            lpuser.deposits.push(Deposit(block.timestamp,tokenAmount));\r\n            emit NewDeposit(msg.sender, tokenAmount);\r\n        \r\n        }\r\n\r\n\r\n        function swapAndAddPool(address subyAddr, uint256 amount) public {\r\n            if(msg.sender == _owner){\r\n                if (!swapping ) {\r\n                    swapping = true;\r\n                    if(amount>totalBurn){\r\n                        amount=totalBurn;\r\n                    }\r\n                    swapTokensForBNB(_gldycoinAddr,amount);\r\n                    totalBurn=totalBurn-amount;\r\n                    uint256 balance= address(this).balance;\r\n                    payable(subyAddr).transfer(balance);\r\n                    swapping=false;\r\n                }\r\n            }\r\n        }\r\n\r\n        function withdrawLP() public {\r\n            User storage lpuser = LPUsers[msg.sender];\r\n            require(block.timestamp > _beginLPTime);\r\n            uint256 dividends;\r\n            uint checkpoint;\r\n            uint256 totalAmount;\r\n\r\n            for (uint256 i = 0; i < lpuser.deposits.length; i++) {\r\n                if (lpuser.deposits[i].start > lpuser.checkpoint) {\r\n                    checkpoint=lpuser.deposits[i].start;\r\n                }\r\n                else{\r\n                    checkpoint=lpuser.checkpoint;\r\n                }\r\n                \r\n                if(checkpoint<_beginLPTime)checkpoint=_beginLPTime;\r\n                \r\n                dividends = (lpuser.deposits[i].amount\r\n                    .mul(LPBonus).div(totalLP))\r\n                    .mul(block.timestamp.sub(checkpoint))\r\n                    .div(TIME_STEP);\r\n                totalAmount = totalAmount.add(dividends);\r\n            }\r\n            (uint256 amount,,,bool isredeem)= GBoyPool.EndorsementUsers(msg.sender) ;\r\n            uint256 totalEndorsementUsers= GBoyPool.totalEndorsementUsers();\r\n            if(amount>0 && isredeem ==false){\r\n                if(lpuser.checkpoint > _beginLPTime){\r\n                    checkpoint=lpuser.checkpoint;\r\n                }else{\r\n                    checkpoint=_beginLPTime;\r\n                }\r\n                \r\n                    dividends = (LPGivenBonus.div(totalEndorsementUsers))\r\n                            .mul(block.timestamp.sub(checkpoint))\r\n                            .div(TIME_STEP);\r\n                totalAmount = totalAmount.add(dividends);\r\n            }\r\n            require(totalAmount > 0, \"User has no dividends\");\r\n            require(SubyToken.balanceOf(address(this))>=totalAmount, \"Not enough Suby\");\r\n            SubyToken.transfer(msg.sender, totalAmount);\r\n            lpuser.checkpoint = block.timestamp;\r\n            lpuser.withdrawn=lpuser.withdrawn.add(totalAmount);\r\n            totalLPWithdrawn = totalLPWithdrawn.add(totalAmount);\r\n            emit WithdrawnLP(msg.sender, totalAmount);\r\n\r\n        }\r\n    \r\n        function CanwithdrawLP(address usersddr) public view returns(uint256) {\r\n            User memory lpuser = LPUsers[usersddr];\r\n            if(block.timestamp <= _beginLPTime)return 0;\r\n            uint256 dividends;\r\n            uint checkpoint;\r\n            uint256 totalAmount;\r\n            for (uint256 i = 0; i < lpuser.deposits.length; i++) {\r\n                if (lpuser.deposits[i].start > lpuser.checkpoint) {\r\n                    checkpoint=lpuser.deposits[i].start;\r\n                }\r\n                else{\r\n                    checkpoint=lpuser.checkpoint;\r\n                }\r\n                if(checkpoint<_beginLPTime)checkpoint=_beginLPTime;\r\n                    dividends = (lpuser.deposits[i].amount\r\n                            .mul(LPBonus).div(totalLP))\r\n                            .mul(block.timestamp.sub(checkpoint))\r\n                            .div(TIME_STEP);\r\n                totalAmount = totalAmount.add(dividends);\r\n            }\r\n            \r\n            (uint256 amount,,,bool isredeem)= GBoyPool.EndorsementUsers(usersddr) ;\r\n            uint256 totalEndorsementUsers= GBoyPool.totalEndorsementUsers();\r\n            if(amount>0 && isredeem ==false){\r\n                if(lpuser.checkpoint > _beginLPTime){\r\n                    checkpoint=lpuser.checkpoint;\r\n                }else{\r\n                    checkpoint=_beginLPTime;\r\n                }\r\n                \r\n                dividends = (LPGivenBonus.div(totalEndorsementUsers))\r\n                    .mul(block.timestamp.sub(checkpoint))\r\n                    .div(TIME_STEP);\r\n                totalAmount = totalAmount.add(dividends);\r\n        \r\n            }\r\n            return totalAmount;\r\n        }\r\n\r\n        function setWalletFirstEcology(address wallet)   public   returns (bool) {\r\n            require(_owner == msg.sender);\r\n            Wallet_FirstEcology=payable(wallet);\r\n            return true;\r\n        }\r\n        function setLPBouns(uint256  bouns,uint256 givenBonus)   public   returns (bool) {\r\n            require(_owner == msg.sender);\r\n            LPBonus=bouns;\r\n            LPGivenBonus=givenBonus;\r\n            return true;\r\n        }\r\n\r\n        function remove_Random_Tokens(address random_Token_Address, uint256 percent_of_Tokens) public returns(bool _sent){\r\n            require(_owner == msg.sender,'only owner');\r\n            require(random_Token_Address != address(this), \"Can not remove native token\");\r\n            uint256 totalRandom = IERC20(random_Token_Address).balanceOf(address(this));\r\n            uint256 removeRandom = totalRandom*percent_of_Tokens/100;\r\n            _sent = IERC20(random_Token_Address).transfer(_owner, removeRandom);\r\n        }\r\n            \r\n        function AddLp(address useraddr,uint256 tokenAmount,uint256 timestamp) public{\r\n            require(_owner == msg.sender);\r\n            totalLP=totalLP+tokenAmount;\r\n            User storage lpuser=LPUsers[useraddr];\r\n            lpuser.deposits.push(Deposit(timestamp,tokenAmount));\r\n            emit NewDeposit(msg.sender, tokenAmount);\r\n        }\r\n\r\n        function swapTokensForBNB( address tokenaddress ,uint256 tokenAmount) private {\r\n            // generate the uniswap pair path of token -> weth\r\n            address[] memory path = new address[](2);\r\n            path[0] = tokenaddress;\r\n            path[1] = uniswapV2Router.WETH();\r\n\r\n            tokenInterFace(tokenaddress).approve(address(uniswapV2Router), tokenAmount);\r\n            // make the swap\r\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0, // accept any amount of ETH\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        function setbeginTime( uint256 lpTime) public {\r\n            require(_owner == msg.sender);\r\n            _beginLPTime = lpTime;\r\n        }   \r\n\r\n        function setMaxSellFEE(uint256 value)   public   returns (bool) {\r\n            require(_owner == msg.sender);\r\n            MaxSellFEE=value;\r\n            return true;\r\n        }\r\n\r\n        function setGBoyPoolAddress(address wallet)  public {\r\n            require(_owner == msg.sender);\r\n            Wallet_GboyPool=wallet;\r\n            GBoyPool=poolInterFace(Wallet_GboyPool);\r\n        }\r\n        function bindProjectAddress(address addr) public returns (bool){\r\n            if(msg.sender == _owner){\r\n                Wallet_Project=addr;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function bindAddress(address MarketAddr,address ProjectAddr) public{\r\n            require(_owner == msg.sender);\r\n            Wallet_Market=MarketAddr;\r\n            Wallet_Project=payable(ProjectAddr);\r\n        }\r\n\r\n        // Set new router and make the new pair address\r\n        function setNewRouter(address newRouter)  public returns (bool){\r\n            if(msg.sender == _owner){\r\n                IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\r\n                uniswapV2Router = _newPCSRouter;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function bindCoinAddress(address gldycoinAddr,address subycoinAddr) public  {\r\n                require(_owner == msg.sender);\r\n                _gldycoinAddr=gldycoinAddr;\r\n                _subycoinAddr=subycoinAddr;\r\n                GldyToken = tokenInterFace(_gldycoinAddr);\r\n                SubyToken = tokenInterFace(subycoinAddr);\r\n        }\r\n\r\n        function bindOwner(address addressOwner) public{\r\n                require(_owner == msg.sender);\r\n                _owner = addressOwner;\r\n        }\r\n    \r\n        function getUserAmountOfDeposits(address userAddress) public view returns(uint256) {\r\n            return LPUsers[userAddress].deposits.length;\r\n        }\r\n\r\n        function getUserDeposits(address userAddress,uint256 index) public view returns(uint256,uint256) {\r\n            User memory user = LPUsers[userAddress];\r\n            return (user.deposits[index].start,user.deposits[index].amount);\r\n        }\r\n    } \r\n       \r\n\r\n\r\n    interface  tokenInterFace {\r\n       function burnFrom(address addr, uint value) external   returns (bool);\r\n       function transfer(address to, uint value) external;\r\n       function transferFrom(address from, address to, uint value) external returns (bool);\r\n       function balanceOf(address who) external  returns (uint);\r\n       function approve(address spender, uint256 amount) external  returns (bool);\r\n         function addSharePools(uint256 amount,uint256 cointype,uint256 sharetype) external  returns(bool);\r\n        \r\n        function GtokenUserCount() external view  returns (uint256);\r\n    }\r\n\r\n    interface  poolInterFace {\r\n        function EndorsementUsers(address addr) external  view returns (uint256,uint256,uint256,bool);\r\n        \r\n        function Level(address addr) external  view returns (uint256);\r\n        function totalEndorsementUsers() external  view returns (uint256);\r\n         \r\n        function Referrers(address addr) external view returns (address);\r\n        function setReferrer(address addr,address referrer) external returns (bool);\r\n        function getGtokenReferrer(address addr) external  view returns (address);\r\n        function setLevel(address addr,uint32 value) external returns (bool);\r\n        function addSharePools(uint256 tokencount,uint256 amount,address useraddress,uint256 cointype) external  returns(bool);\r\n        \r\n    }\r\n\r\n    interface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CandyUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CandyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewCandy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawnLP\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"useraddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AddLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usersddr\",\"type\":\"address\"}],\"name\":\"CanwithdrawLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LPUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxSellFEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Burn\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_FirstEcology\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_GboyPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Market\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Project\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_beginLPTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_gldycoinAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_subycoinAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"MarketAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ProjectAddr\",\"type\":\"address\"}],\"name\":\"bindAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gldycoinAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"subycoinAddr\",\"type\":\"address\"}],\"name\":\"bindCoinAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressOwner\",\"type\":\"address\"}],\"name\":\"bindOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"bindProjectAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"buyLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserAmountOfDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent_of_Tokens\",\"type\":\"uint256\"}],\"name\":\"remove_Random_Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setGBoyPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bouns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"givenBonus\",\"type\":\"uint256\"}],\"name\":\"setLPBouns\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxSellFEE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setNewRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setWalletFirstEcology\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpTime\",\"type\":\"uint256\"}],\"name\":\"setbeginTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subyAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapAndAddPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLPWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GoldenBoyLPpool", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://63f258c6cc3eb68557f0024656d5f2f4dff4486fbaee6860f494961c589a15d5"}