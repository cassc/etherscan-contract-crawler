{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/OPLimitOrderDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./Adminable.sol\\\";\\nimport \\\"./DelegatorInterface.sol\\\";\\nimport \\\"./interfaces/DexAggregatorInterface.sol\\\";\\nimport \\\"./interfaces/OpenLevInterface.sol\\\";\\n\\ncontract OPLimitOrderDelegator is DelegatorInterface, Adminable {\\n    constructor(\\n        OpenLevInterface _openLev,\\n        DexAggregatorInterface _dexAgg,\\n        address payable _admin,\\n        address implementation_\\n    ) {\\n        admin = payable(msg.sender);\\n        // Creator of the contract is admin during initialization\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address)\\\", _openLev, _dexAgg));\\n        implementation = implementation_;\\n\\n        // Set the proper admin now that initialization is done\\n        admin = _admin;\\n    }\\n\\n    /**\\n     * Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     */\\n    function setImplementation(address implementation_) public override onlyAdmin {\\n        address oldImplementation = implementation;\\n        implementation = implementation_;\\n        emit NewImplementation(oldImplementation, implementation);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/OpenLevInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >0.7.6;\\n\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title OpenLevInterface\\n * @author OpenLeverage\\n */\\ninterface OpenLevInterface {\\n    struct Market {\\n        // Market info\\n        address pool0; // Lending Pool 0\\n        address pool1; // Lending Pool 1\\n        address token0; // Lending Token 0\\n        address token1; // Lending Token 1\\n        uint16 marginLimit; // Margin ratio limit for specific trading pair. Two decimal in percentage, ex. 15.32% => 1532\\n        uint16 feesRate; // feesRate 30=>0.3%\\n        uint16 priceDiffientRatio;\\n        address priceUpdater;\\n        uint256 pool0Insurance; // Insurance balance for token 0\\n        uint256 pool1Insurance; // Insurance balance for token 1\\n    }\\n\\n    struct Trade {\\n        // Trade storage\\n        uint256 deposited; // Balance of deposit token\\n        uint256 held; // Balance of held position\\n        bool depositToken; // Indicate if the deposit token is token 0 or token 1\\n        uint128 lastBlockNum; // Block number when the trade was touched last time, to prevent more than one operation within same block\\n    }\\n\\n    function markets(uint16 marketId) external view returns (Market memory market);\\n\\n    function activeTrades(\\n        address trader,\\n        uint16 marketId,\\n        bool longToken\\n    ) external view returns (Trade memory trade);\\n\\n    function updatePrice(uint16 marketId, bytes memory dexData) external;\\n\\n    function marginTradeFor(\\n        address trader,\\n        uint16 marketId,\\n        bool longToken,\\n        bool depositToken,\\n        uint256 deposit,\\n        uint256 borrow,\\n        uint256 minBuyAmount,\\n        bytes memory dexData\\n    ) external payable returns (uint256 newHeld);\\n\\n    function closeTradeFor(\\n        address trader,\\n        uint16 marketId,\\n        bool longToken,\\n        uint256 closeHeld,\\n        uint256 minOrMaxAmount,\\n        bytes memory dexData\\n    ) external returns (uint256 depositReturn);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/DexAggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface DexAggregatorInterface {\\n    function getPrice(\\n        address desToken,\\n        address quoteToken,\\n        bytes memory data\\n    ) external view returns (uint256 price, uint8 decimals);\\n\\n    function getPriceCAvgPriceHAvgPrice(\\n        address desToken,\\n        address quoteToken,\\n        uint32 secondsAgo,\\n        bytes memory dexData\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 price,\\n            uint256 cAvgPrice,\\n            uint256 hAvgPrice,\\n            uint8 decimals,\\n            uint256 timestamp\\n        );\\n\\n    function updatePriceOracle(\\n        address desToken,\\n        address quoteToken,\\n        uint32 timeWindow,\\n        bytes memory data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/DelegatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >0.7.6;\\n\\nabstract contract DelegatorInterface {\\n    /**\\n     * Implementation address for this contract\\n     */\\n    address public implementation;\\n\\n    /**\\n     * Emitted when implementation is changed\\n     */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n     * Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     */\\n    function setImplementation(address implementation_) public virtual;\\n\\n    /**\\n     * Internal method to delegate execution to another contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param callee The contract to delegatecall\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return returnData;\\n    }\\n\\n    /**\\n     * Delegates execution to the implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\n        return delegateTo(implementation, data);\\n    }\\n\\n    /**\\n     * Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", data));\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return abi.decode(returnData, (bytes));\\n    }\\n\\n    /**\\n     * Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     */\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    receive() external payable {\\n        _fallback();\\n    }\\n\\n    function _fallback() internal {\\n        // delegate all other functions to current implementation\\n        if (msg.data.length > 0) {\\n            (bool success, ) = implementation.delegatecall(msg.data);\\n            assembly {\\n                let free_mem_ptr := mload(0x40)\\n                returndatacopy(free_mem_ptr, 0, returndatasize())\\n                switch success\\n                case 0 {\\n                    revert(free_mem_ptr, returndatasize())\\n                }\\n                default {\\n                    return(free_mem_ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >0.7.6;\\n\\nabstract contract Adminable {\\n    address payable public admin;\\n    address payable public pendingAdmin;\\n    address payable public developer;\\n\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() {\\n        developer = payable(msg.sender);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"caller must be admin\\\");\\n        _;\\n    }\\n    modifier onlyAdminOrDeveloper() {\\n        require(msg.sender == admin || msg.sender == developer, \\\"caller must be admin or developer\\\");\\n        _;\\n    }\\n\\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    function acceptAdmin() external virtual {\\n        require(msg.sender == pendingAdmin, \\\"only pendingAdmin can accept admin\\\");\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store admin with value pendingAdmin\\n        admin = payable(oldPendingAdmin);\\n        // Clear the pending value\\n        pendingAdmin = payable(0);\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract OpenLevInterface\",\"name\":\"_openLev\",\"type\":\"address\"},{\"internalType\":\"contract DexAggregatorInterface\",\"name\":\"_dexAgg\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToViewImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OPLimitOrderDelegator", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d7ad56ed09b359fd4154103569b90923675cd9fe000000000000000000000000dfe2841fbf8436dc50b49e428b0f713f7f135f100000000000000000000000004f1f6828c42891620f6734c52774b0b0966c4594000000000000000000000000d67dfbbbe96d250331fc235c76dfb86dccc5e6f9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x71f85ba5ef23102c991d671a48f7bc0d44d032cf", "SwarmSource": ""}