{"SourceCode": "pragma solidity 0.6.12;\r\ninterface tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\r\n}\r\ncontract BEP20 {\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != address(0x0));\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);                  // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n    contract PERA {\r\n    string public name;     // Token name\r\n    address public manager; // Contract owner address\r\n    string public symbol;   // Token symbol\r\n    uint256 public decimals = 18;               // Token decimals\r\n    uint256 private LPTokenDecimals = 18;       // Liquidity provider (LP) token decimals\r\n    uint256 public genesisBlock = block.number; // Block number of the contract creation\r\n    uint256 public PERASupply = 44950800 * 10 ** uint256(decimals); // Initial PERA supply\r\n    uint256 public totalSupply;\r\n\r\n    // Initial rate for holder reward distribution coefficient (transferRate), used for rebasing holders' balances\r\n    uint256 private constant transferRateInitial = ~uint240(0);\r\n    uint256 public transferRate = (transferRateInitial - (transferRateInitial % PERASupply))/PERASupply;\r\n    // Number of blocks within a day (approximately 28800 blocks for Binance Smart Chain & 6500 blocks for Ethereum Network)\r\n    uint private BlockSizeForTC = 28800;\r\n    // Number of blocks within a week\r\n    uint private oneWeekasBlock = BlockSizeForTC * 7;\r\n    // Number of blocks within 10 years (PERA emission stops after 10 years)\r\n    uint private tenYearsasBlock = oneWeekasBlock * 520;\r\n\r\n    // Daily PERA emission reward for trading competition (TC) reward pool\r\n    uint public dailyRewardForTC = 9800 * 10 ** uint256(decimals);\r\n    // Contract deployer can set the reward multiplier (see function updateTCMultiplier)\r\n    // Initial value, 20, sets the trading competition emission reward to 19600 PERA/day\r\n    uint256 public TCRewardMultiplier = 20;\r\n    // Number of users with the highest daily volume who are eligible to win the daily trading competition\r\n    uint8 private totalTCwinners = 10;\r\n    // Contract deployer can set the minimum PERA transaction that is required for the trading competition within the range 10-1000\r\n    // Initial value = min 100 PERA transaction is required  (see function updateminTCamount)\r\n    uint256 public minTCamount = 100 * 10 ** decimals;\r\n    // Record of total transaction fee rewards collected for the trading competition reward pool\r\n    mapping (uint256 => uint256) public totalRewardforTC;\r\n\r\n    // Total number of LP tokens staked in the contract\r\n    uint public totalStakedLP = 0;\r\n    // Contract releases 1.75 PERA/block as LP token staker reward\r\n    uint public blockRewardLP = 175 * 10 ** uint256(decimals);\r\n    // Contract deployer can set the reward multiplier (see function updateLPMultiplier)\r\n    // Initial value, 20, sets the LP token staker emission reward to 1.75 PERA/block\r\n    uint256 public LPRewardMultiplier = 20;\r\n    // Initial rate for LP token staker reward distribution coefficient (LPRate)\r\n    uint256 public LPRate = 0;\r\n    // Transaction fee rewards collected specifically for LP token stakers (0.75% of each PERA transaction)\r\n    uint256 public FeeRewPoolLP = 0;\r\n    // Smart contract address of the LP token (should be set by the contract owner, see function addLPToken)\r\n    address lpTokenAddress;\r\n    // Record of staked LP token amount for a given address\r\n    mapping (address => uint256) private userLPamount;\r\n    // Last block number that PERA distribution occurs for LP token stakers\r\n    uint256 private lastRewardBlock = 0;\r\n\r\n    // PERA smart contract applies a 2% transaction fee on each on-chain PERA transaction\r\n    uint public tradingCompFee = 50; // Transaction fee rate for trading competition reward pool (0.50% of each PERA transaction)\r\n    uint public holderFee = 75;      // Transaction fee rate for holder rewards (0.75% of each PERA transaction)\r\n    uint public liqproviderFee = 75; // Transaction fee rate for LP token staker rewards (0.75% of each PERA transaction)\r\n\r\n    mapping (address => bool) public isNonTaxable;\r\n\r\n    address[] public _excluded;\r\n    mapping (address => uint256) private userbalanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    using SafeMath for uint;\r\n\r\n    constructor(\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n\r\n    ) public {\r\n        initialSupply = PERASupply.mul(transferRate);\r\n        tokenName = \"PERA\";\r\n        tokenSymbol = \"PERA\";\r\n        manager = msg.sender;\r\n        userbalanceOf[msg.sender] = initialSupply;\r\n        totalSupply =  PERASupply;\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // Used for excluding an address as a holder\r\n    // Excluded addresses do not receive holder rewards (0.75% of each on-chain PERA transaction)\r\n    // For the holder rewards to be distributed properly, contract owner should follow these steps after the contract deployment:\r\n    // 1- Exclude the token smart contract address\r\n    // 2- Exclude the contract owner address\r\n    // 3- Exclude the AMM-exchange router contract address\r\n    // 4- Provide the initial liquidity to an AMM-exchange\r\n    // 5- Exclude the pool address where the initial liquidity is provided\r\n    function excludeAccount(address account) external {\r\n        require(msg.sender == manager);\r\n        require(!_isExcluded(account));\r\n        _excluded.push(account);\r\n        userbalanceOf[account] = userbalanceOf[account].div(transferRate);\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // Used for removing an address from the excluded holders list\r\n    function includeAccount(address account) external {\r\n    require(msg.sender == manager);\r\n    require(_isExcluded(account));\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _excluded.pop();\r\n                userbalanceOf[account] = userbalanceOf[account].mul(transferRate);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function for checking if a given address is in the excluded holders list\r\n    function _isExcluded(address _addr) view public returns (bool) {\r\n        for(uint i=0; i < _excluded.length; i++){\r\n            if(_addr == _excluded[i]){\r\n                return  true;\r\n            }\r\n        }\r\n    return false;\r\n    }\r\n\r\n    // Function is used to calculate how many PERA tokens is held by the users who are in the excluded holders list\r\n    function _removeExcludedAmounts() view public returns (uint) {\r\n     uint totalRemoved = 0;\r\n         for(uint i=0; i < _excluded.length; i++){\r\n            totalRemoved += userbalanceOf[_excluded[i]];\r\n         }\r\n    return totalRemoved;\r\n    }\r\n\r\n    function excludeFromTax(address _account, uint256 _checkTax) external {\r\n        require(msg.sender == manager);\r\n        if(_checkTax == 0){\r\n            isNonTaxable[_account] = false;\r\n        }else{\r\n            isNonTaxable[_account] = true;\r\n        }\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to set the transaction fee rate for holders\r\n    //Initial value = 75 (0.75%)\r\n    function updateHolderFee(uint256 newHolderFee) external {\r\n        require(msg.sender == manager);\r\n        require(newHolderFee >= 15 && newHolderFee <= 375);\r\n        holderFee = newHolderFee;\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to set the transaction fee rate for LP token stakers\r\n    //Initial value = 75 (0.75%)\r\n    function updateLPStakerFee(uint256 newLPStakerFee) external {\r\n        require(msg.sender == manager);\r\n        require(newLPStakerFee >= 15 && newLPStakerFee <= 375);\r\n        liqproviderFee = newLPStakerFee;\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to set the transaction fee rate for trading competition\r\n    //Initial value = 50\r\n    function updateTCFee(uint256 newTCFee) external {\r\n        require(msg.sender == manager);\r\n        require(newTCFee >= 10 && newTCFee <= 250);\r\n        tradingCompFee = newTCFee;\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to set the reward multiplier for LP token stakers\r\n    // Initial value is set to 20 (1,75 PERA/block)\r\n    function updateLPMultiplier(uint256 newLPMultiplier) external {\r\n        require(msg.sender == manager);\r\n        require(newLPMultiplier >= 0 && newLPMultiplier <= 200);\r\n        LPRewardMultiplier = newLPMultiplier;\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to set the reward multiplier for the trading competition reward pool\r\n    // Initial value is set to 20 (19600 PERA/day)\r\n    function updateTCMultiplier(uint256 newTCMultiplier) external {\r\n        require(msg.sender == manager);\r\n        require(newTCMultiplier >= 0 && newTCMultiplier <= 100);\r\n        TCRewardMultiplier = newTCMultiplier;\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to set the minimum PERA transaction required for the trading competition\r\n    // Initial value is set to 100 tokens\r\n    function updateminTCamount(uint256 newminTCamount) external {\r\n        require(msg.sender == manager);\r\n        require(newminTCamount >= (10 * 10 ** decimals)  && newminTCamount <= (1000 * 10 ** decimals));\r\n        minTCamount = newminTCamount;\r\n    }\r\n\r\n    // Function can only be used by the contract owner\r\n    // It is used to add the contract address of the LP token\r\n    function addLPToken(address _addr)  external {\r\n        require(msg.sender == manager);\r\n        lpTokenAddress = _addr;\r\n    }\r\n\r\n    // User balances are represented in two different ways:\r\n    // 1- If the address is excluded then the balance remains as it is\r\n    // 2- If the address is not excluded then the balance is weighted with the lastly updated value of the transferRate (see function balanceRebalance)\r\n    function balanceOf(address _addr) public view returns (uint256) {\r\n      if (_isExcluded(_addr)){\r\n          return userbalanceOf[_addr];\r\n      } else{\r\n          return balanceRebalance(userbalanceOf[_addr]);\r\n      }\r\n    }\r\n\r\n    function balanceRebalance(uint256 userBalances) private view returns(uint256) {\r\n      return userBalances.div(transferRate);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public{\r\n        require(msg.sender == manager);\r\n        require(newOwner != address(0), 'Address can not be 0x0!');\r\n        require(newOwner != address(this), 'Address can not be contract address!');\r\n        if (newOwner != address(0)) {\r\n            manager = newOwner;\r\n        }\r\n    }\r\n\r\n    // Checks if a given address is the contract owner\r\n    function isManager(address _addr) view private returns(bool) {\r\n        bool isManagerCheck = false;\r\n        if(_addr == manager){\r\n            isManagerCheck = true;\r\n        }\r\n    return  isManagerCheck;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != address(0x0));\r\n\r\n        // Checks if the transaction sender is an excluded address\r\n        // Balance checks should be weighted with the lastly updated value of the transferRate for non-excluded addresses\r\n        if(!_isExcluded(_from)){\r\n            require(userbalanceOf[_from].div(transferRate) >= _value);\r\n            require(userbalanceOf[_to].div(transferRate) + _value >= userbalanceOf[_to].div(transferRate));\r\n        }else{\r\n            require(userbalanceOf[_from] >= _value);\r\n            require(userbalanceOf[_to] + _value >= userbalanceOf[_to]);\r\n        }\r\n\r\n        // If the transaction sender is the contract owner or the contract itself then no fee is applied on the transaction\r\n        uint256 tenthousandthofamonut = _value.div(10000);\r\n        if(isNonTaxable[_from] || isNonTaxable[_to]){\r\n            tenthousandthofamonut = 0;\r\n        }\r\n\r\n        // How many days have passed since the contract creation\r\n        uint256 _bnum = (block.number - genesisBlock)/BlockSizeForTC;\r\n        // 0.5% of the transacted amount is added to the daily trading competition reward pool\r\n        totalRewardforTC[_bnum]  +=  uint(tenthousandthofamonut.mul(tradingCompFee));\r\n        // 0.75% of the transacted amount is added to the LP token staker rewards\r\n        // If there is no LP token staked in the contract, then the amount is set to zero\r\n        if(totalStakedLP != 0){\r\n            FeeRewPoolLP  +=  uint(tenthousandthofamonut.mul(liqproviderFee));\r\n        }\r\n\r\n        // Total amount of tokens taken out as the transaction fee (2% of the transacted amount)\r\n        uint totalOut = uint(tenthousandthofamonut.mul(tradingCompFee)) + uint(tenthousandthofamonut.mul(holderFee)) + uint(tenthousandthofamonut.mul(liqproviderFee));\r\n\r\n        // Balance updates should be done by considering whether the transaction sender or the receiver is an excluded address or not\r\n        if ((_isExcluded(_to)) && (_isExcluded(_from))){\r\n            userbalanceOf[_from] -= _value;\r\n            userbalanceOf[_to] +=   (_value).sub(totalOut);\r\n        } else if(_isExcluded(_to)){\r\n            userbalanceOf[_from] -= _value.mul(transferRate);\r\n            userbalanceOf[_to] +=   (_value).sub(totalOut);\r\n        } else if (_isExcluded(_from)){\r\n            userbalanceOf[_from] -= _value;\r\n            uint transferAmount = (_value).sub(totalOut);\r\n            userbalanceOf[_to] +=  transferAmount.mul(transferRate);\r\n        } else{\r\n            userbalanceOf[_from] -= _value.mul(transferRate);\r\n            uint transferAmount = (_value).sub(totalOut);\r\n            userbalanceOf[_to] +=   transferAmount.mul(transferRate);\r\n        }\r\n\r\n        // 0.75% of an on-chain transaction is instantly distributed to the token holders\r\n        // Remaining 1.25% of the transaction fee is sent to the smart contract\r\n        uint includedRewards = tenthousandthofamonut.mul(holderFee);\r\n        userbalanceOf[address(this)] += (totalOut - includedRewards);\r\n        // Amount of tokens to be sent to the token holders\r\n        uint transactionStakerFee = includedRewards.mul(transferRate);\r\n\r\n        if(PERASupply.sub(_removeExcludedAmounts().add(includedRewards)) < 1){\r\n            userbalanceOf[address(this)] += includedRewards;\r\n        }else{\r\n            uint reduceTransferRate = transactionStakerFee.div(PERASupply.sub(_removeExcludedAmounts()));\r\n            transferRate -= reduceTransferRate;\r\n        }\r\n\r\n        // Parameters to be sent to the daily trading competition functions:\r\n        // Transacted amount (_value)\r\n        // Address of the user\r\n            // If the transaction sender is a non-excluded address then the _from address is sent\r\n            // If the transaction sender is an excluded address then the _to address is sent\r\n        // How many days have passed since the contract creation (_bnum)\r\n        tradingComp(_value, _from, _bnum);\r\n        if(_isExcluded(_from) && !isManager(_from) && !_isExcluded(_to)){\r\n                tradingComp(_value, _to, _bnum);\r\n        }\r\n        emit Transfer(_from, _to, uint(_value).sub(totalOut));\r\n    }\r\n\r\n    // Checks whether a trading competition winner claimed its competition rewards or not\r\n    mapping (string => bool) public isPaid;\r\n    // Checks if a given address has made an on-chain transaction for a given day\r\n    mapping (string => bool) public isTraderIn;\r\n\r\n    // traderAddress: Addresses of Top-10 volume generators for a given day\r\n    // traderVolume: Daily volume of the Top-10 volume generators for a given day\r\n    struct topTraders {\r\n      address traderAddress;\r\n      uint256 traderVolume;\r\n    }\r\n    mapping(uint => topTraders[]) public tTraders;\r\n\r\n    // lastTVolume: Daily volume of the user who has the least daily generated volume within the Top-10 traders list (tTraders list)\r\n    // lastTIndex: Index of the trader who has the least volume within the Top-10 traders list (tTraders list)\r\n    struct findTopLast {\r\n      uint256 lastTVolume;\r\n      uint256 lastTIndex;\r\n    }\r\n    mapping(uint256 => findTopLast) public findTLast;\r\n    mapping(string => uint256) public tcdetailz;\r\n\r\n    //PERA Sort Algorithm:\r\n    function tradingComp(uint256 _value, address _addr, uint _bnum) internal {\r\n        // Check if the transacted amount is more than 100 PERA tokens and the given address is not in the excluded holders list\r\n        if((_value > minTCamount) && (!_isExcluded(_addr))){\r\n        string memory TCX = nMixAddrandSpBlock(_addr, _bnum);\r\n            // Check if the user address has previously made an on-chain transaction\r\n            if(!isTraderIn[TCX]){\r\n               isTraderIn[TCX] = true;\r\n               // Update user's daily trading volume\r\n               tcdetailz[TCX] = _value;\r\n                // Check if the length of the tTraders list has reached 10\r\n                if(tTraders[_bnum].length < totalTCwinners){\r\n                    // Push user's address and daily volume to the tTraders list\r\n                    tTraders[_bnum].push(topTraders(_addr, _value));\r\n                    // If the tTraders list is full (There should be 10 unique users within the list)\r\n                    // Find the minimum daily volume value within the Top-10 traders list\r\n                    if(tTraders[_bnum].length == totalTCwinners){\r\n                            uint minVolume = tTraders[_bnum][0].traderVolume;\r\n                            uint minIndex = 0;\r\n                        for(uint i=0; i<tTraders[_bnum].length; i++){\r\n                            if(tTraders[_bnum][i].traderVolume < minVolume){\r\n                                minVolume = tTraders[_bnum][i].traderVolume;\r\n                                minIndex = i;\r\n                            }\r\n                        }\r\n                    // lastTVolume: Minimum daily volume within the Top-10 traders list\r\n                    // lastTIndex: Index of the user who has the least volume within the Top-10 traders list\r\n                    findTLast[_bnum].lastTVolume = minVolume;\r\n                    findTLast[_bnum].lastTIndex = minIndex;\r\n                    }\r\n                }\r\n                // When the Top-10 traders list (tTraders) is filled, check if the current user's daily volume is larger than\r\n                // the user who has the least volume within the Top-10 traders\r\n                else{\r\n                    if(tcdetailz[TCX] > findTLast[_bnum].lastTVolume){\r\n                        topTradersList(tcdetailz[TCX], _bnum, _addr);\r\n                    }\r\n                }\r\n            }\r\n            // If the user address has previously made an on-chain transaction\r\n            else{\r\n                // Update user's daily trading volume\r\n                tcdetailz[TCX] += _value;\r\n                // Check if length of the tTraders list has reached 10\r\n                // If not, then find the user's index within the tTraders list and update the volume on the corresponding index point\r\n                if(tTraders[_bnum].length != totalTCwinners){\r\n                    uint256 updateIndex = findTraderIndex(_bnum, _addr);\r\n                    tTraders[_bnum][updateIndex].traderVolume = tcdetailz[TCX];\r\n                // If length of the tTraders list has reached 10\r\n                }else{\r\n                    // Check if the user's volume is larger than the minimum daily volume within the Top-10 traders list\r\n                    if(tcdetailz[TCX] > findTLast[_bnum].lastTVolume){\r\n                        // Check if the current user is already in the Top-10 if not, update tTraders list (see function topTradersList)\r\n                        if(!isTopTrader(_bnum, _addr)){\r\n                            topTradersList(tcdetailz[TCX], _bnum, _addr);\r\n                        // Check if the current user has the least volume in the Top-10 traders list if so, update tTraders list (see function updateLastTrader)\r\n                        }else if(tTraders[_bnum][findTLast[_bnum].lastTIndex].traderAddress == _addr){\r\n                            updateLastTrader(tcdetailz[TCX], _bnum, _addr);\r\n                        // Check if the current user is already in the Top-10 traders list but not the 10th rank if so,\r\n                        // only update the user's daily volume in the tTraders list\r\n                        }else if(isTopTrader(_bnum, _addr) && tTraders[_bnum][findTLast[_bnum].lastTIndex].traderAddress != _addr){\r\n                            uint256 updateIndex = findTraderIndex(_bnum, _addr);\r\n                            tTraders[_bnum][updateIndex].traderVolume = tcdetailz[TCX];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function is used if the user who has the least daily volume wtihin the Top-10 traders list makes a transaction\r\n    function updateLastTrader(uint256 _value, uint256 _bnum, address _addr) internal {\r\n\r\n        // Check if the updated daily volume of the user can overtake rank 9\r\n        // If not, 10th rank remains in the same spot and its daily volume gets updated\r\n        if(_value < checkUserVolume(sortTraders(_bnum)[8], _bnum)){\r\n            tTraders[_bnum][findTraderIndex(_bnum, _addr)].traderVolume = _value;\r\n            findTLast[_bnum].lastTVolume = _value;\r\n        }\r\n        // If the updated daily volume of the user can overtake rank 9\r\n        // then find the new minimum volume in the Top-10 traders list and the corresponding index point\r\n        else{\r\n            tTraders[_bnum][findTLast[_bnum].lastTIndex].traderVolume = _value;\r\n            uint256 minVolume = tTraders[_bnum][0].traderVolume;\r\n            uint256 minIndex;\r\n            for(uint i=0; i<tTraders[_bnum].length; i++){\r\n                if(tTraders[_bnum][i].traderVolume <= minVolume){\r\n                    minVolume = tTraders[_bnum][i].traderVolume;\r\n                    minIndex = i;\r\n                }\r\n            }\r\n            findTLast[_bnum].lastTVolume = minVolume;\r\n            findTLast[_bnum].lastTIndex = minIndex;\r\n        }\r\n    }\r\n\r\n    // Function is used when a user who is not in the Top-10 traders list makes it to the Top-10 traders list\r\n    // New user's address and daily volume are stored on the previous 10th rank's index in the tTraders list\r\n    // Minimum daily volume within the new Top-10 traders list and the corresponding index point is calculated\r\n    function topTradersList(uint256 _value, uint256 _bnum, address _addr) internal {\r\n\r\n        uint256 minVolume = _value;\r\n        uint256 minIndex;\r\n\r\n        tTraders[_bnum][findTLast[_bnum].lastTIndex].traderAddress = _addr;\r\n        tTraders[_bnum][findTLast[_bnum].lastTIndex].traderVolume = _value;\r\n        for(uint i=0; i<tTraders[_bnum].length; i++){\r\n            if(tTraders[_bnum][i].traderVolume <= minVolume){\r\n                minVolume = tTraders[_bnum][i].traderVolume;\r\n                minIndex = i;\r\n            }\r\n        }\r\n        findTLast[_bnum].lastTVolume = minVolume;\r\n        findTLast[_bnum].lastTIndex = minIndex;\r\n    }\r\n\r\n    // Function checks if a given address is in the Top-10 traders list for a given day\r\n    function isTopTrader(uint _bnum, address _addr) view public returns(bool) {\r\n        bool checkTopTrader;\r\n        for(uint i=0; i < tTraders[_bnum].length; i++){\r\n        if(tTraders[_bnum][i].traderAddress == _addr){\r\n            checkTopTrader = true;\r\n        }\r\n      }\r\n      return  checkTopTrader;\r\n   }\r\n\r\n    // Function checks the index point of a user within the tTraders list\r\n    function findTraderIndex(uint _bnum, address _addr) view public returns(uint256) {\r\n        uint256 checkIndex;\r\n        for(uint i=0; i < tTraders[_bnum].length; i++){\r\n        if(tTraders[_bnum][i].traderAddress == _addr){\r\n            checkIndex = i;\r\n        }\r\n      }\r\n      return  checkIndex;\r\n   }\r\n\r\n    // View function for users to see if they are in the Top-10 traders list\r\n    function checkTopTraderList(uint _bnum, uint _Ranking) view public returns(address) {\r\n      return  tTraders[_bnum][_Ranking].traderAddress;\r\n    }\r\n\r\n\r\n    // Contract stores the Top-10 trader's daily volume and addresses within the tTraders list however\r\n    // the list is not sorted until someone claims the trading competition rewards\r\n    function sortTraders(uint _bnum) view public returns(address[] memory) {\r\n      uint8 wlistlimit = totalTCwinners;\r\n      address[] memory dailyTCWinners = new address[](wlistlimit);\r\n      uint maxTradedNumber = 0;\r\n      address maxTraderAdd;\r\n\r\n      for(uint k=0; k<wlistlimit; k++){\r\n          for(uint j=0; j < tTraders[_bnum].length; j++){\r\n                if(!isUserWinner(dailyTCWinners, tTraders[_bnum][j].traderAddress)){\r\n                    if(tTraders[_bnum][j].traderVolume > maxTradedNumber) {\r\n                        maxTradedNumber = tTraders[_bnum][j].traderVolume;\r\n                        maxTraderAdd = tTraders[_bnum][j].traderAddress;\r\n                        dailyTCWinners[k] = maxTraderAdd;\r\n                    }\r\n                } else {\r\n                   maxTraderAdd = address(0);\r\n                }\r\n          }\r\n          maxTradedNumber = 0;\r\n       }\r\n      return  dailyTCWinners;\r\n      }\r\n\r\n    // Function checks if a user's address in the Top-10 traders list is already placed in the proper spot while sorting\r\n    function isUserWinner(address[] memory dailyTCList,address _addr) view private returns (bool) {\r\n        for(uint l=0; l < dailyTCList.length; l++){\r\n            if(_addr == dailyTCList[l]){\r\n                return  true;\r\n            }\r\n        }\r\n    return false;\r\n    }\r\n\r\n    // View function for users to check their daily volume for a given day\r\n    function checkUserVolume(address _addr, uint256 bnum)  public view returns(uint) {\r\n         string memory TCX = nMixAddrandSpBlock(_addr, bnum);\r\n         return tcdetailz[TCX];\r\n    }\r\n\r\n    // View function for users to check if they already claimed their trading competition rewards\r\n    function checkUserPayment(address _addr, uint256 bnum)  public view returns(bool) {\r\n         return isPaid[nMixAddrandSpBlock(_addr, bnum)];\r\n    }\r\n\r\n\r\n    // Function checks the placement of a user who wins the trading competition (Returns the rank of the user in the Top-10 traders list)\r\n    function checkUserTCPosition(address[] memory userinTCList,address _addr) view private returns (uint) {\r\n        for(uint l=0; l < userinTCList.length; l++){\r\n            if(_addr == userinTCList[l]){\r\n                return  l;\r\n            }\r\n        }\r\n        return totalTCwinners;\r\n    }\r\n\r\n    // Function to calculate the trading competition rewards for each winner\r\n    function calculateUserTCreward(address _addr, uint _bnum)  public view returns(uint256, uint256, uint256, uint256, uint256) {\r\n     if(_addr == address(0x0)) { return (404,404,404,404,404); } else {\r\n     address[] memory getLastWinners = new address[](totalTCwinners);\r\n     // Calculate how many days have passed since the user won the trading competition\r\n     // Claimable trading competition reward for a user is calculated as = User's total reward*(51+(7*Days passed since the user won the trading competition))/100\r\n     // It takes at least 7 days for a winner to be able to claim %100 of all its trading competition rewards\r\n     uint rDayDifference = (block.number.sub(genesisBlock.add(_bnum.mul(BlockSizeForTC)))).div(BlockSizeForTC);\r\n     _bnum = _bnum.sub(1);\r\n     if(rDayDifference > 7){rDayDifference=7;}\r\n\r\n     getLastWinners = sortTraders(_bnum);\r\n     if(isUserWinner(getLastWinners, _addr)){\r\n         // Find user's placement in the Top-10 traders list (User's placement when the tTraders list is sorted wrt each user's daily volume)\r\n         uint winnerIndex = checkUserTCPosition(getLastWinners, _addr);\r\n         // Check if a user has already claimed its trading competition rewards\r\n         if(!isPaid[nMixAddrandSpBlock(msg.sender, _bnum)]){\r\n            // Trading competition reward share of a user is calculated as = 19-(2*User's rank in the list)\r\n            // User's index in the Top-10 traders list = User's rank in the Top-10 traders list - 1\r\n            uint256 rewardRate = uint(19).sub(uint(2).mul(winnerIndex));\r\n            // If 10 years have passed since the contract creation, then the emission reward = 0\r\n            uint256 rewardEmission = 0;\r\n            if((_bnum*BlockSizeForTC) < tenYearsasBlock){\r\n                rewardEmission = dailyRewardForTC.mul(TCRewardMultiplier).mul(rewardRate).div(1000); // Total emission reward for the user\r\n            }\r\n            uint256 rewardFee = totalRewardforTC[_bnum];\r\n            rewardFee = rewardFee.mul(rewardRate).div(100);     // Total transaction fee reward for the user\r\n            uint256 traderReward = rewardEmission + rewardFee;  // Total reward for the user\r\n\r\n            rewardFee = rewardFee.mul(51+(7*rDayDifference)).div(100);              // Eligible transaction fee rewards\r\n            rewardEmission = rewardEmission.mul(51+(7*rDayDifference)).div(100);    // Eligible emission rewards\r\n            uint256 traderRewardEligible = traderReward.mul(51+(7*rDayDifference)).div(100); // Total eligible rewards\r\n            return (traderReward, traderRewardEligible, winnerIndex, rewardEmission, rewardFee);\r\n         } else {return (404,404,404,404,404);}\r\n     } else {return (404,404,404,404,404);} }\r\n    }\r\n\r\n    // Function to calculate the trading competition rewards for each winner\r\n    function pendingTCreward(address _addr, uint _bnum)  external view returns(uint256, uint256, uint256, uint256, uint256) {\r\n     if(_addr == address(0x0)) { return (404,404,404,404,404); } else {\r\n     address[] memory getLastWinners = new address[](totalTCwinners);\r\n     uint _Vbnum = _bnum.add(1);\r\n     uint rDayDifference = (block.number.sub(genesisBlock.add(_Vbnum.mul(BlockSizeForTC)))).div(BlockSizeForTC);\r\n     if(rDayDifference > 7){rDayDifference=7;}\r\n     getLastWinners = sortTraders(_bnum);\r\n     if(isUserWinner(getLastWinners, _addr)){\r\n         uint winnerIndex = checkUserTCPosition(getLastWinners, _addr);\r\n         if(!isPaid[nMixAddrandSpBlock(_addr, _bnum)]){\r\n            uint256 rewardRate = uint(19).sub(uint(2).mul(winnerIndex));\r\n            uint256 rewardEmission = 0;\r\n            if((_bnum*BlockSizeForTC) < tenYearsasBlock){\r\n                rewardEmission = dailyRewardForTC.mul(TCRewardMultiplier).mul(rewardRate).div(1000);\r\n            }\r\n            uint256 rewardFee = totalRewardforTC[_bnum];\r\n            rewardFee = rewardFee.mul(rewardRate).div(100);\r\n            uint256 traderReward = rewardEmission + rewardFee;\r\n            rewardFee = rewardFee.mul(51+(7*rDayDifference)).div(100);\r\n            rewardEmission = rewardEmission.mul(51+(7*rDayDifference)).div(100);\r\n            uint256 traderRewardEligible = traderReward.mul(51+(7*rDayDifference)).div(100);\r\n            return (traderReward, traderRewardEligible, winnerIndex, rewardEmission, rewardFee);\r\n         } else {return (404,404,404,404,404);}\r\n     } else {return (404,404,404,404,404);} }\r\n    }\r\n\r\n    // Function for trading competition winners to claim their rewards\r\n    function getTCreward(uint _bnum) external {\r\n         require(_bnum > 0,\"Min 1 TC cycle must end.\");\r\n         require(_bnum.sub(1) < showBnum(), 'Must wait at least 1 day!');\r\n         (uint256 _traderReward, uint256 _traderRewardEligible, uint _winnerIndex, uint256 _rewardEmission, uint256 _rewardFee) = calculateUserTCreward(msg.sender, _bnum);\r\n         require(_traderRewardEligible > 0, 'No Eligible Reward!');\r\n         require(!isPaid[nMixAddrandSpBlock(msg.sender, _bnum.sub(1))], 'Reward has already claimed');\r\n         if(_winnerIndex != 404) {\r\n         isPaid[nMixAddrandSpBlock(msg.sender, _bnum.sub(1))] = true;\r\n         _mint(msg.sender, _rewardEmission);\r\n         _transfer(address(this), msg.sender, _traderRewardEligible);\r\n         }\r\n    }\r\n\r\n    // Function calculates how many days have passed since the contract creation\r\n    function showBnum() public view returns(uint256) {\r\n        return (block.number - genesisBlock)/BlockSizeForTC;\r\n    }\r\n\r\n    // Function is used for mixing the data of a user's address and how many days have passed since the contract creation\r\n    // It is used for combining a unique data (address) with a non-unique but necessary data (# of the day) to create a single unique data to be used for indexing\r\n    function nMixAddrandSpBlock(address _addr, uint256 bnum)  public view returns(string memory) {\r\n         return append(uintToString(nAddrHash(_addr)),uintToString(bnum));\r\n    }\r\n\r\n    function uintToString(uint256 v) internal pure returns(string memory str) {\r\n        uint maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = byte(uint8(48 + remainder));\r\n        }\r\n        bytes memory s = new bytes(i + 1);\r\n        for (uint j = 0; j <= i; j++) {\r\n            s[j] = reversed[i - j];\r\n        }\r\n        str = string(s);\r\n    }\r\n\r\n    function nAddrHash(address _address) view private returns (uint256) {\r\n        return uint256(_address) % 10000000000;\r\n    }\r\n\r\n    function append(string memory a, string memory b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a,\"-\",b));\r\n    }\r\n\r\n    // Returns block rewards over a given _from to _to block number multiplied with the reward multiplier for LP token stakers\r\n    function getDistReward(uint256 _from, uint256 _to) public view returns (uint256) {\r\n        return _to.sub(_from).mul(LPRewardMultiplier);\r\n    }\r\n\r\n    struct LPUserInfo {\r\n        uint256 userLPamount;\r\n        uint256 userReflectedLP;\r\n    }\r\n\r\n    mapping (address => LPUserInfo) public userInfo;\r\n\r\n    // View function for LP token stakers to see pending PERA rewards\r\n    function pendingPERA(address _user) external view returns (uint256) {\r\n\r\n        LPUserInfo storage user = userInfo[_user];\r\n        uint256 vLPRate = LPRate;\r\n        uint256 vtotalStakedLP = totalStakedLP;\r\n        if (block.number > lastRewardBlock && vtotalStakedLP != 0) {\r\n            uint256 distance = getDistReward(lastRewardBlock, block.number);\r\n            uint256 PERAEmissionReward = distance.mul(blockRewardLP).div(2000);\r\n            if((block.number - genesisBlock) > tenYearsasBlock){\r\n                PERAEmissionReward = 0;\r\n            }\r\n            uint PERAReward = PERAEmissionReward + FeeRewPoolLP;\r\n            vLPRate = vLPRate.add(PERAReward.mul(1e12).div(vtotalStakedLP));\r\n        }\r\n        return user.userLPamount.mul(vLPRate).div(1e12).sub(user.userReflectedLP);\r\n    }\r\n\r\n    // Function for staking LP tokens (min 1 LP token is required)\r\n    function depositLPtoken(uint256 _amount) external {\r\n\r\n        LPUserInfo storage user = userInfo[msg.sender];\r\n        updateRate(totalStakedLP);\r\n\r\n        if (user.userLPamount > 0) {\r\n            uint256 pendingReward = user.userLPamount.mul(LPRate).div(1e12).sub(user.userReflectedLP);\r\n            if(pendingReward > 0) {\r\n                _transfer(address(this), msg.sender, pendingReward);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            totalStakedLP += _amount;\r\n            user.userLPamount = user.userLPamount.add(_amount);\r\n            BEP20(lpTokenAddress).transferFrom(msg.sender, address(this), _amount);\r\n        }\r\n        user.userReflectedLP = user.userLPamount.mul(LPRate).div(1e12);\r\n    }\r\n\r\n    // Function updates variables related to LP token staker reward distribution\r\n    function updateRate(uint256 _totalStakedLP) internal {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        if (_totalStakedLP == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n\r\n        uint256 distance = getDistReward(lastRewardBlock, block.number);\r\n        uint256 PERAEmissionReward = distance.mul(blockRewardLP).div(2000);\r\n        if((block.number - genesisBlock) > tenYearsasBlock){\r\n            PERAEmissionReward = 0;\r\n        }\r\n        uint PERAReward = PERAEmissionReward + FeeRewPoolLP;\r\n        FeeRewPoolLP = 0;\r\n        _mint(msg.sender, PERAEmissionReward);\r\n        LPRate = LPRate.add(PERAReward.mul(1e12).div(_totalStakedLP));\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0));\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n        PERASupply = PERASupply.add(amount);\r\n        userbalanceOf[address(this)] += amount;\r\n    }\r\n\r\n    // Withdraw without receiving LP token staker rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _exit) external {\r\n        LPUserInfo storage user = userInfo[msg.sender];\r\n        totalStakedLP -= user.userLPamount;\r\n        BEP20(lpTokenAddress).transfer(msg.sender,  user.userLPamount);\r\n        user.userLPamount = 0;\r\n        user.userReflectedLP = 0;\r\n        if(totalStakedLP == 0){\r\n            FeeRewPoolLP = 0;\r\n        }\r\n    }\r\n\r\n    // Function is used to withdraw LP tokens from the PERA smart contract\r\n    function withdraw(uint256 _amount) external {\r\n\r\n        LPUserInfo storage user = userInfo[msg.sender];\r\n        require(user.userLPamount >= _amount, \"Not enough balance!\");\r\n        updateRate(totalStakedLP);\r\n\r\n        uint256 pendingReward = user.userLPamount.mul(LPRate).div(1e12).sub(user.userReflectedLP);\r\n        if(pendingReward > 0) {\r\n            _transfer(address(this), msg.sender, pendingReward);\r\n        }\r\n        if(_amount > 0) {\r\n            user.userLPamount = user.userLPamount.sub(_amount);\r\n            totalStakedLP -= _amount;\r\n            BEP20(lpTokenAddress).transfer(msg.sender,  _amount);\r\n        }\r\n        if(totalStakedLP == 0){\r\n            FeeRewPoolLP = 0;\r\n        }\r\n        user.userReflectedLP = user.userLPamount.mul(LPRate).div(1e12);\r\n    }\r\n }", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FeeRewPoolLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPRewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERASupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TCRewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_excluded\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_removeExcludedAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addLPToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockRewardLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"}],\"name\":\"calculateUserTCreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Ranking\",\"type\":\"uint256\"}],\"name\":\"checkTopTraderList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnum\",\"type\":\"uint256\"}],\"name\":\"checkUserPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnum\",\"type\":\"uint256\"}],\"name\":\"checkUserVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRewardForTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositLPtoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exit\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_checkTax\",\"type\":\"uint256\"}],\"name\":\"excludeFromTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"findTLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"findTraderIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getDistReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"}],\"name\":\"getTCreward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isNonTaxable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"isPaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isTopTrader\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"isTraderIn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqproviderFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTCamount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnum\",\"type\":\"uint256\"}],\"name\":\"nMixAddrandSpBlock\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingPERA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"}],\"name\":\"pendingTCreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showBnum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnum\",\"type\":\"uint256\"}],\"name\":\"sortTraders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tTraders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"traderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"traderVolume\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"tcdetailz\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRewardforTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingCompFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newHolderFee\",\"type\":\"uint256\"}],\"name\":\"updateHolderFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLPMultiplier\",\"type\":\"uint256\"}],\"name\":\"updateLPMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLPStakerFee\",\"type\":\"uint256\"}],\"name\":\"updateLPStakerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTCFee\",\"type\":\"uint256\"}],\"name\":\"updateTCFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTCMultiplier\",\"type\":\"uint256\"}],\"name\":\"updateTCMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newminTCamount\",\"type\":\"uint256\"}],\"name\":\"updateminTCamount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userLPamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userReflectedLP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PERA", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004504552410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045045524100000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7fc7f1c92fddb6ce456783dded2c7e5db1835eea18be2244d4fb5ca824e4512a"}