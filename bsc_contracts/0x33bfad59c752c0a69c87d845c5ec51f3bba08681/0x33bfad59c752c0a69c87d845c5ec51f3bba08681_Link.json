{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    }\r\n\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    unchecked {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    }\r\n\r\n \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    unchecked {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    }\r\n\r\n \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    unchecked {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWETH is IERC20{\r\n    function deposit() payable external;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface Ipledge{\r\n    function  stakeWLuca(address _nodeAddr, uint256 _amount, address _sender) external returns(bool);\r\n    function  cancleStakeWLuca(address _sender) external returns(bool);\r\n}\r\n\r\ninterface Itrader {\r\n    function payment(address _token, address _from, address _to, uint256 _amount) external returns(bool); \r\n    function withdrawFor(address _to, uint256 _amount) external;\r\n    function suck(address _to, uint256 _amount, uint256 _lockDay) external;\r\n}\r\n\r\ninterface Ifactory {\r\n    function linkActive(address _user, uint256 _methodId) external;\r\n}\r\n\r\ninterface Ifile {\r\n    function luca() external view returns(address);\r\n    function pledger() external view returns(address);\r\n    function collector() external view returns(address);\r\n    function linkLoad() external view returns (address, address, address, address, address);//luca, wluca, weth, trader, pledger\r\n}\r\n\r\n//Ilink.sol\r\ninterface Ilink {\r\n    function getPledgedInfo() external view returns(bool pledgedA_, bool pledgedB_);\r\n    function getStatus() external view returns(string memory);\r\n    function getLinkInfo() external view returns(string memory symbol_,address token_, address userA_,address userB_, uint256 amountA_,uint256 amountB_,uint256 percentA_,uint256 totalPlan_,uint256 lockDays_, uint256 startTime_, uint256 status_, bool isAward_);\r\n    function getCloseInfo() external view returns(address closer_, uint256 startTime_,uint256 expiredTime_,uint256 closeTime_, bool closeReqA_, bool closeReqB_);\r\n    function getRecevabesInfo() external view returns(uint256 receivableA_, bool isExitA_, uint256 receivableB_, bool isExitB_);\r\n    function setUserB(address _userB) external;\r\n    function agree() external payable;\r\n    function reject() external;\r\n    function close() external;\r\n    function rejectClose() external;\r\n    function repealCloseReq() external;\r\n    function isExpire() external view returns(bool);\r\n    function pledge(address node) external;\r\n    function depledge() external;\r\n    function wtihdrawSelf() external;\r\n}\r\n\r\n//link.sol\r\ncontract Initialized {\r\n    bool internal initialized;\r\n    \r\n    modifier noInit(){\r\n        require(!initialized, \"initialized\");\r\n        _;\r\n        initialized = true;\r\n    }\r\n}\r\n\r\ncontract Enum {\r\n    Status internal status;\r\n    enum Status {INITED, AGREED, CLOSED, PLEDGED}\r\n    enum MethodId {setUserB, agree, reject, pledge, depledge, close, repealCloseReq, rejectClose, wtihdrawSelf}\r\n    \r\n    function _init() internal {status = Status.INITED;}\r\n\r\n    function _agree() internal {status = Status.AGREED;}\r\n\r\n    function _close() internal {status = Status.CLOSED;}\r\n    \r\n    function _pledge() internal {status = Status.PLEDGED;}\r\n}\r\n\r\ncontract LinkInfo is Enum {\r\n    address internal file;\r\n    address internal factory;\r\n    bool    internal closeReqA;\r\n    bool    internal closeReqB;\r\n    bool    internal pledgedA;\r\n    bool    internal pledgedB;\r\n    \r\n    string   symbol;\r\n    address  userA;\r\n    address  userB;\r\n    uint256  amountA;\r\n    uint256  amountB;\r\n    uint256  percentA;\r\n    uint256  totalPlan;\r\n    address  token;\r\n    address  closer;\r\n    uint256  lockDays;\r\n    uint256  startTime;\r\n    uint256  expiredTime;\r\n    uint256  closeTime;\r\n\r\n    uint256  receivableA;\r\n    uint256  receivableB;\r\n    bool     isExitA;\r\n    bool     isExitB;\r\n    \r\n    \r\n    modifier onlyLuca(){\r\n        require(token == Ifile(file).luca(), \"Link: only luca\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyEditLink(){\r\n        require(msg.sender == userA, \"Link: only userA\");\r\n        require(userB == address(0) && percentA == 100, \"Link: only Editable Link\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyLinkUser(){\r\n        require(msg.sender == userA || msg.sender == userB, \"Link: access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUserB(){\r\n        require(msg.sender == userB, \"Link: noly userB\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyINITED(){\r\n        require(status == Status.INITED, \"Link: only initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAGREED(){\r\n        require(status == Status.AGREED, \"Link: only agreed\");\r\n        _;\r\n    }\r\n\r\n    modifier unCLOSED(){\r\n        require(status != Status.CLOSED, \"Link: only unclosed\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPLEDGED(){\r\n        require(status == Status.PLEDGED, \"Link: only pledged\");\r\n        _;\r\n    }\r\n    \r\n    modifier unPLEDGED(){\r\n        require(status != Status.PLEDGED, \"Link: only unpledged\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Link is LinkInfo, Initialized, Ilink {\r\n    using SafeMath for uint256;\r\n    address constant ETH = address(0);\r\n    fallback() payable external{}\r\n    receive() payable external{}\r\n    \r\n    function _linkActive(MethodId _methodId) internal{\r\n        Ifactory(factory).linkActive(msg.sender, uint256(_methodId));\r\n    }\r\n    \r\n    function initialize( address _file, address _userA, address _userB, address _token, string memory _symbol, uint256 _amount, uint256 _percentA, uint256 _lockDays) external noInit{\r\n        (factory, file, userA, userB, token, symbol) = (msg.sender, _file, _userA, _userB, _token, _symbol);\r\n        (totalPlan, percentA, amountA, amountB, lockDays) = (_amount, _percentA, _amount.mul(_percentA).div(100), _amount.mul(100 - _percentA).div(100), _lockDays);\r\n        \r\n        if(_percentA == 100 && userB != address(0)){\r\n            startTime = block.timestamp;\r\n            expiredTime = startTime.add(lockDays.mul(1 days));\r\n            _agree();\r\n        }else{\r\n            _init();\r\n        }\r\n    }\r\n\r\n    function setUserB(address _userB) override external onlyEditLink {\r\n        require(_userB != address(0) && _userB != msg.sender, \"Link: unlawful address\");\r\n        _linkActive(MethodId.setUserB);\r\n        userB = _userB;\r\n        startTime = block.timestamp;\r\n        expiredTime = startTime.add(lockDays.mul(1 days));\r\n        _agree();\r\n        \r\n        (address luca,,,address trader,) = Ifile(file).linkLoad();\r\n        //airdrop gta \r\n        if(token == luca){\r\n            Itrader(trader).suck(userA, amountA, lockDays);\r\n            Itrader(trader).suck(userB, amountB, lockDays);\r\n        }\r\n    }\r\n\r\n    function reject() override external onlyUserB onlyINITED{\r\n        _linkActive(MethodId.reject);\r\n        _exit();\r\n    }\r\n\r\n    function agree() override payable external onlyUserB onlyINITED{\r\n        _linkActive(MethodId.agree);\r\n        // (luca, wluca, weth, trader, pledger)\r\n        (address luca,,address weth, address trader,) = Ifile(file).linkLoad();\r\n        if (token == ETH){\r\n            \r\n            require(msg.value == amountB, \"Link: wrong amount of ETH\");\r\n            IWETH(weth).deposit{value: msg.value}();\r\n            IWETH(weth).transfer(address(this), msg.value);\r\n        }else{\r\n            Itrader(trader).payment(token, userB, address(this), amountB);\r\n        }\r\n        \r\n        //require(_verifyDeposit(token, userB), \"Link: deposit not enough\" );\r\n        startTime = block.timestamp;\r\n        expiredTime = startTime.add(lockDays.mul(1 days));\r\n        _agree();\r\n        \r\n        //airdrop gta \r\n        if(token == luca){\r\n            Itrader(trader).suck(userA, amountA, lockDays);\r\n            Itrader(trader).suck(userB, amountB, lockDays);\r\n        }\r\n    }\r\n    \r\n    //pledge\r\n    function pledge(address node) override external onlyLuca onlyLinkUser {\r\n        require(status == Status.PLEDGED || status == Status.AGREED, \"Link: access denied\");\r\n        require(!isExpire(), \"Link: link expire\");\r\n        require(!closeReqA && !closeReqB, \"Link: please handle the closing process first\");\r\n        \r\n        _linkActive(MethodId.pledge);\r\n        \r\n        uint256 amount;\r\n        if (msg.sender == userA){\r\n             require(!pledgedA, \"Link: repledge\");\r\n             pledgedA = true;\r\n             amount = amountA;\r\n        }else{\r\n             require(!pledgedB, \"Link: repledge\");\r\n             pledgedB= true;\r\n             amount = amountB;\r\n        }\r\n        \r\n        require(amount > 0, \"Link: 0 amount\");\r\n        _pledge();\r\n        Ipledge(Ifile(file).pledger()).stakeWLuca(node, amount, msg.sender);\r\n    }\r\n    \r\n    function depledge() override external onlyLuca onlyPLEDGED onlyLinkUser{\r\n        if (msg.sender == userA){\r\n             require(pledgedA, \"Link: no pledged\");\r\n             pledgedA = false;\r\n        }else{\r\n             require(pledgedB, \"Link: no pledged\");\r\n             pledgedB= false;\r\n        }\r\n        \r\n        _linkActive(MethodId.depledge);\r\n         \r\n        Ipledge(Ifile(file).pledger()).cancleStakeWLuca(msg.sender);\r\n       \r\n        \r\n        //other exited\r\n        if (isExitA || isExitB){ \r\n            closer = msg.sender;\r\n            closeTime = block.timestamp;\r\n            _exitSelf();\r\n            _close();\r\n            return;\r\n        }\r\n        \r\n        if (!pledgedA && !pledgedB) _agree();\r\n    }\r\n    \r\n    function wtihdrawSelf() override external onlyLuca onlyPLEDGED onlyLinkUser{\r\n         require(isExpire(),\"Link: only Expire\");\r\n         _linkActive(MethodId.wtihdrawSelf);\r\n         _setReceivables(100);\r\n         _exitSelf();\r\n    }\r\n    \r\n    //Link renew\r\n    function close() override external unCLOSED unPLEDGED onlyLinkUser {\r\n        _linkActive(MethodId.close);\r\n        \r\n        //Expire \r\n        if (isExpire()){\r\n            _exit();\r\n        }\r\n        \r\n        //INITED\r\n        if (status == Status.INITED){\r\n            require(msg.sender == userA,\"Link: access denied\");\r\n            _exit();\r\n        }\r\n\r\n        //AGREED\r\n        if (status == Status.AGREED){\r\n            if (msg.sender == userA) {\r\n                closeReqA = true;\r\n            }else{\r\n                closeReqB = true;\r\n            }\r\n            \r\n            if (closeReqA && closeReqB){\r\n                _exit();\r\n            }\r\n        }\r\n    }\r\n    \r\n    function repealCloseReq() override external onlyAGREED onlyLinkUser { \r\n        _linkActive(MethodId.repealCloseReq);\r\n        \r\n        if (msg.sender == userA) {\r\n            closeReqA = false;\r\n        }else{\r\n            closeReqB = false;\r\n        }\r\n    }\r\n    \r\n    function rejectClose() override external onlyAGREED onlyLinkUser{\r\n        _linkActive(MethodId.rejectClose);\r\n        \r\n        if (msg.sender == userB) {\r\n            closeReqA = false;\r\n        }else{\r\n            closeReqB = false;\r\n        }\r\n    }\r\n    \r\n    //Link query\r\n    function isExpire() override public view returns(bool) {\r\n        if (status == Status.INITED || expiredTime == 0){\r\n            return false;\r\n        }\r\n        return (block.timestamp >= expiredTime);\r\n    }\r\n    \r\n    function getPledgedInfo() override external view returns(bool pledgedA_, bool pledgedB_){\r\n        return(pledgedA, pledgedB);\r\n    }\r\n    \r\n    function getCloseInfo() override external view returns(address closer_, uint256 startTime_,uint256 expiredTime_,uint256 closeTime_, bool closeReqA_, bool closeReqB_){\r\n        return(closer, startTime, expiredTime, closeTime, closeReqA, closeReqB);\r\n    }\r\n\r\n    function getStatus() override external view returns(string memory status_){\r\n        if (Status.INITED == status)  return \"initialized\";\r\n        if (Status.AGREED == status)  return \"agreed\";\r\n        if (Status.PLEDGED == status) return \"pledged\";\r\n        if (Status.CLOSED == status)  return \"closed\";\r\n    }\r\n    \r\n    function getRecevabesInfo() override external view returns(uint256 receivableA_, bool isExitA_, uint256 receivableB_, bool isExitB_){\r\n        return(receivableA, isExitA, receivableB, isExitB);\r\n    }\r\n\r\n    function getLinkInfo() override external view returns(string memory symbol_,address token_,address userA_, address userB_, uint256 amountA_, uint256 amountB_,uint256 percentA_,uint256 totalPlan_,uint256 lockDays_,uint256 startTime_,uint256 status_, bool isAward_){\r\n        bool isAward;\r\n        if ((status == Status.AGREED) || ((status == Status.PLEDGED) && (!isExitA && !isExitB))) {\r\n            isAward = true;\r\n        }\r\n        \r\n        return(symbol, token, userA, userB, amountA, amountB, percentA, totalPlan, lockDays, startTime, uint256(status), isAward);\r\n    }\r\n    \r\n    function _exit() internal{\r\n        closer = msg.sender;\r\n        closeTime = block.timestamp;\r\n        _liquidation();\r\n        _close();\r\n    }\r\n    \r\n    function _exitSelf() internal{\r\n        if (msg.sender == userA){\r\n            //userA unpledge and notExit\r\n            require(!pledgedA && !isExitA, \"Link: access denied \");\r\n            isExitA = true;\r\n            _withdraw(userA, receivableA);\r\n        }else{\r\n            //userB unpledge and notExit\r\n            require(!pledgedB && !isExitB, \"Link: access denied \");\r\n            isExitB = true;\r\n            _withdraw(userB, receivableB);\r\n        }\r\n    }\r\n\r\n    function _liquidation() internal{\r\n        if (status == Status.INITED || isExpire()) {\r\n            _setReceivables(100);\r\n        }else{\r\n            //AGREED\r\n            uint256 day = (closeTime.sub(startTime)).div(1 days);\r\n            //dayFator = (lockDays-day)*10^4  / lockDays \r\n            uint256 dayFator = (lockDays.sub(day)).mul(10000).div(lockDays);\r\n            \r\n            if(dayFator <= 100){         //  <1% * 10000\r\n                _setReceivables(99);\r\n            }else if(dayFator >= 1500){  // >15% * 10000\r\n                _setReceivables(85);\r\n            }else{                       // 1% ~ 15%\r\n               _setReceivables((10000 - dayFator).div(100)); \r\n            }\r\n            \r\n            uint256 fee = totalPlan.sub(receivableA.add(receivableB));\r\n            _withdraw(Ifile(file).collector(), fee);\r\n        }\r\n        \r\n        isExitA = true;\r\n        isExitB = true;\r\n        _withdraw(userA, receivableA);\r\n        if (receivableB > 0) _withdraw(userB, receivableB);\r\n    }\r\n    \r\n  \r\n    function _withdraw(address to, uint amount) internal{\r\n        (address luca, address wluca, address weth, address trader,) = Ifile(file).linkLoad();\r\n        if (token == ETH){\r\n             IWETH(weth).withdraw(amount);\r\n             payable(to).transfer(amount);\r\n        }else if(token == luca){\r\n            IERC20(wluca).approve(trader, amount);\r\n            Itrader(trader).withdrawFor(to, amount);\r\n        }else{\r\n            IERC20(token).transfer(to, amount);\r\n        }\r\n    }\r\n    \r\n    function _setReceivables(uint256 factor) internal{\r\n        receivableA = amountA.mul(factor).div(100);\r\n\r\n        if ((status == Status.AGREED || status == Status.PLEDGED) && amountB != 0){\r\n            receivableB = amountB.mul(factor).div(100);\r\n        }\r\n    }\r\n}", "ABI": "[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"agree\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depledge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCloseInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"closer_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiredTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTime_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"closeReqA_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"closeReqB_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLinkInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userA_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userB_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentA_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPlan_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDays_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAward_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPledgedInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"pledgedA_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pledgedB_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRecevabesInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivableA_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExitA_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"receivableB_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExitB_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"status_\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_file\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDays\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isExpire\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"pledge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rejectClose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repealCloseReq\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userB\",\"type\":\"address\"}],\"name\":\"setUserB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wtihdrawSelf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Link", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://154cff6fe4016059c962c3901b748fb65efb9589599408bcd71d7d3c0393dc50"}