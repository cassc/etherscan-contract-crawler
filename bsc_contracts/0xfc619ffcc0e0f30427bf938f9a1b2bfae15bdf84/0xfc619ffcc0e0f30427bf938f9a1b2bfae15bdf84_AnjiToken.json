{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/AnjiToken.sol\": {\r\n      \"content\": \"/**\\n * Anji is about building an ecosystem of altruistic defi applications to enable a decentralised digital economy that leaves the earth in a better way than we found it.\\n *\\n * Web: https://anji.eco\\n * Telegram: https://t.me/anjieco\\n * Twitter: https://twitter.com/anji_eco\\n *\\n *                 _ _   ______                        _\\n *     /\\\\         (_|_) |  ____|                      | |\\n *    /  \\\\   _ __  _ _  | |__   ___ ___  ___ _   _ ___| |_ ___ _ __ ___\\n *   / /\\\\ \\\\ | '_ \\\\| | | |  __| / __/ _ \\\\/ __| | | / __| __/ _ \\\\ '_ ` _ \\\\\\n *  / ____ \\\\| | | | | | | |___| (_| (_) \\\\__ \\\\ |_| \\\\__ \\\\ ||  __/ | | | | |\\n * /_/    \\\\_\\\\_| |_| |_| |______\\\\___\\\\___/|___/\\\\__, |___/\\\\__\\\\___|_| |_| |_|\\n *               _/ |                         __/ |\\n *              |__/                         |___/\\n */\\n\\n//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * Standard SafeMath, stripped down to just add/sub/mul/div\\n */\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n/**\\n * BEP20 standard interface.\\n */\\ninterface IBEP20 {\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function name() external view returns (string memory);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ninterface IDividendDistributor {\\n    function setShare(address shareholder, uint256 amount) external;\\n    function deposit(uint256 amount) external;\\n    function claimDividend(address shareholder) external;\\n}\\n\\ncontract BNBDistributor is IDividendDistributor {\\n    using SafeMath for uint256;\\n\\n    address _token;\\n    address charityReceiver;\\n    address marketingReceiver;\\n    address liquidityReceiver;\\n\\n    struct Share {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n    }\\n\\n    address WBNB;\\n    IDEXRouter router;\\n\\n    mapping(address => uint256) _shareAmount;\\n    mapping(address => uint256) _shareEntry;\\n    mapping(address => uint256) _accured;\\n    uint256 _totalShared;\\n    uint256 _totalReward;\\n    uint256 _totalAccured;\\n    uint256 _stakingMagnitude;\\n\\n    uint256 public minAmount = 0;\\n\\n    modifier onlyToken() {\\n        require(msg.sender == _token); _;\\n    }\\n\\n    constructor (address _wbnb, address _router, address _charityReceiver, address _marketingReceiver, address _liquidityReceiver) {\\n        WBNB = _wbnb;\\n        router = IDEXRouter(_router);\\n        _token = msg.sender;\\n        charityReceiver = _charityReceiver;\\n        marketingReceiver = _marketingReceiver;\\n        liquidityReceiver = _liquidityReceiver;\\n\\n        _stakingMagnitude = 10 * 10 ** (9 + 9); // 10 Billion\\n    }\\n\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\n        // Shareholder has given up their Reward Share\\n        if (amount < 1000000000) {\\n            uint256 current_rewards = currentRewards(shareholder);\\n            if (current_rewards > 0) {\\n                distributeDividend(shareholder, marketingReceiver);\\n            }\\n\\n            _accured[shareholder] = _accured[shareholder] - _accured[shareholder];\\n            _totalShared = _totalShared - _shareAmount[shareholder];\\n\\n            _shareAmount[shareholder] = _shareAmount[shareholder] - _shareAmount[shareholder];\\n            _shareEntry[shareholder] = _totalAccured;\\n        } else {\\n            if (_shareAmount[shareholder] > 0) {\\n                _accured[shareholder] = currentRewards(shareholder);\\n            }\\n\\n            _totalShared = _totalShared.sub(_shareAmount[shareholder]).add(amount);\\n            _shareAmount[shareholder] = amount;\\n\\n            _shareEntry[shareholder] = _totalAccured;\\n        }\\n    }\\n\\n    function getWalletShare(address shareholder) public view returns (uint256) {\\n        return _shareAmount[shareholder];\\n    }\\n\\n    function deposit(uint256 amount) external override onlyToken {\\n        _totalReward = _totalReward + amount;\\n        _totalAccured = _totalAccured + amount * _stakingMagnitude / _totalShared;\\n    }\\n\\n    function distributeDividend(address shareholder, address receiver) internal {\\n        if(_shareAmount[shareholder] == 0){ return; }\\n\\n        _accured[shareholder] = currentRewards(shareholder);\\n        require(_accured[shareholder] > minAmount, \\\"Reward amount has to be more than minimum amount\\\");\\n\\n        payable(receiver).transfer(_accured[shareholder]);\\n        _totalReward = _totalReward - _accured[shareholder];\\n        _accured[shareholder] = _accured[shareholder] - _accured[shareholder];\\n\\n        _shareEntry[shareholder] = _totalAccured;\\n    }\\n\\n    function claimDividend(address shareholder) external override onlyToken {\\n        uint256 amount = currentRewards(shareholder);\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        distributeDividend(shareholder, shareholder);\\n    }\\n\\n    function setCharityFeeReceiver(address _receiver) external onlyToken {\\n        charityReceiver = _receiver;\\n    }\\n\\n    function setMarketingFeeReceiver(address _receiver) external onlyToken {\\n        marketingReceiver = _receiver;\\n    }\\n\\n    function setLiquidityFeeReceiver(address _receiver) external onlyToken {\\n        liquidityReceiver = _receiver;\\n    }\\n\\n    function donate(address shareholder) onlyToken external {\\n        distributeDividend(shareholder, charityReceiver);\\n    }\\n\\n    function buyToken(address shareholder) external onlyToken {\\n        if(_shareAmount[shareholder] == 0){ return; }\\n\\n        uint256 amount = currentRewards(shareholder);\\n\\n        if (amount == 0) { return; }\\n\\n        _accured[shareholder] = amount;\\n\\n        uint256 amountToCharity = amount.mul(2).div(100);\\n        uint256 amountToLiquify = amount.mul(3).div(100).div(2);\\n        uint256 walletAmount = amount.mul(95).div(100);\\n\\n        uint256 amountToSwap = amountToLiquify.add(walletAmount);\\n\\n        // Pay charity fee\\n        payable(charityReceiver).transfer(amountToCharity);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = WBNB;\\n        path[1] = _token;\\n\\n        uint256 balanceBefore = IBEP20(_token).balanceOf(address(this));\\n\\n        IBEP20(_token).approve(address(router), amountToSwap);\\n        // Buy more tokens with the BNB of the shareholder and send to them\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountToSwap}(\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 swapBalance = IBEP20(_token).balanceOf(address(this)).sub(balanceBefore);\\n        uint256 amountTokensToLiquify = swapBalance.mul(3).div(98);\\n        uint256 amountTokensToShareholder = swapBalance.sub(amountTokensToLiquify);\\n\\n        if (amountTokensToShareholder > 0) {\\n            IBEP20(_token).transfer(shareholder, amountTokensToShareholder);\\n        }\\n\\n        if (amountTokensToLiquify > 0 && amountToLiquify > 0){\\n            IBEP20(_token).approve(address(router), amountTokensToLiquify);\\n            router.addLiquidityETH{ value: amountToLiquify }(\\n                _token,\\n                amountTokensToLiquify,\\n                0,\\n                0,\\n                liquidityReceiver,\\n                block.timestamp\\n            );\\n        }\\n\\n        _totalReward = _totalReward - _accured[shareholder];\\n        _accured[shareholder] = _accured[shareholder] - _accured[shareholder];\\n\\n        _shareEntry[shareholder] = _totalAccured;\\n    }\\n\\n    function depositExternalBNB(uint256 amount) external onlyToken {\\n        _totalReward = _totalReward + amount;\\n        _totalAccured = _totalAccured + amount * _stakingMagnitude / _totalShared;\\n    }\\n\\n    function _calculateReward(address addy) private view returns (uint256) {\\n        return _shareAmount[addy] * (_totalAccured - _shareEntry[addy]) / _stakingMagnitude;\\n    }\\n\\n    function currentRewards(address addy) public view returns (uint256) {\\n        uint256 totalRewards = address(this).balance;\\n\\n        uint256 calcReward = _accured[addy] + _calculateReward(addy);\\n\\n        // Fail safe to ensure rewards are never more than the contract holding.\\n        if (calcReward > totalRewards) {\\n            return totalRewards;\\n        }\\n\\n        return calcReward;\\n    }\\n\\n    receive() external payable { }\\n}\\n\\ncontract AnjiToken is Context, IBEP20, Ownable {\\n    using SafeMath for uint256;\\n\\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n\\n    string constant _name = \\\"Anji\\\";\\n    string constant _symbol = \\\"ANJI\\\";\\n    uint8 constant _decimals = 9;\\n\\n    uint256 _totalSupply = 10 * 10 ** (9 + _decimals); // 10 Billion\\n\\n    mapping (address => uint256) _balances;\\n    mapping (address => mapping (address => uint256)) _allowances;\\n\\n    mapping (address => bool) isFeeExempt;\\n    mapping (address => bool) isTxLimitExempt;\\n    mapping (address => bool) isDividendExempt;\\n    mapping (address => bool) isRestricted;\\n\\n    uint256 liquidityFee = 300;\\n    uint256 charityFee = 200;\\n    uint256 marketingFee = 200;\\n    uint256 bnbReflectionFee = 300;\\n\\n    uint256 feeDenominator = 10000;\\n\\n    address public charityFeeReceiver;\\n    address public marketingFeeReceiver;\\n    address public autoLiquidityReceiver;\\n\\n    IDEXRouter public router;\\n    address pancakeV2BNBPair;\\n    address[] public pairs;\\n\\n    bool public swapEnabled = true;\\n    bool public feesOnNormalTransfers = true;\\n\\n    BNBDistributor public bnbDistributor;\\n\\n    bool inSwap;\\n    modifier swapping { inSwap = true; _; inSwap = false; }\\n    uint256 public swapThreshold = 100 * 10 ** _decimals;\\n\\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\\n    event BuybackMultiplierActive(uint256 duration);\\n    event BoughtBack(uint256 amount, address to);\\n    event Launched(uint256 blockNumber, uint256 timestamp);\\n    event SwapBackSuccess(uint256 amount);\\n    event SwapBackFailed(string message);\\n\\n    constructor() {\\n        address _owner = msg.sender;\\n\\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        pancakeV2BNBPair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\\n        _allowances[address(this)][address(router)] = ~uint256(0);\\n\\n        pairs.push(pancakeV2BNBPair);\\n        bnbDistributor = new BNBDistributor(WBNB, address(router), _owner, _owner, _owner);\\n\\n        isFeeExempt[_owner] = true;\\n        isFeeExempt[address(this)] = true;\\n        isFeeExempt[address(bnbDistributor)] = true;\\n        isDividendExempt[pancakeV2BNBPair] = true;\\n        isDividendExempt[address(this)] = true;\\n        isDividendExempt[DEAD] = true;\\n        isDividendExempt[ZERO] = true;\\n        isDividendExempt[address(bnbDistributor)] = true;\\n        isDividendExempt[_owner] = true;\\n\\n        address upgradeContract = 0x5Ba41eAE2AE8a103B19ffE23384310B065bAF7f3;\\n        isFeeExempt[upgradeContract] = true;\\n        isDividendExempt[upgradeContract] = true;\\n\\n        charityFeeReceiver = _owner;\\n        marketingFeeReceiver = _owner;\\n        autoLiquidityReceiver = _owner;\\n\\n        _balances[_owner] = _totalSupply;\\n        emit Transfer(address(0), _owner, _totalSupply);\\n    }\\n\\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\\n    function decimals() external pure override returns (uint8) { return _decimals; }\\n    function symbol() external pure override returns (string memory) { return _symbol; }\\n    function name() external pure override returns (string memory) { return _name; }\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, ~uint256(0));\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        if(_allowances[sender][msg.sender] != ~uint256(0)){\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        require(!isRestricted[recipient], \\\"Address is restricted\\\");\\n\\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\\n\\n        if(shouldSwapBack()) { swapBack(); }\\n\\n        require(_balances[sender].sub(amount) >= 0, \\\"Insufficient Balance\\\");\\n        _balances[sender] = _balances[sender].sub(amount);\\n\\n        if (shouldTakeFee(sender, recipient)) {\\n            uint256 _marketingFee = amount.mul(marketingFee).div(feeDenominator);\\n            uint256 _charityFee = amount.mul(charityFee).div(feeDenominator);\\n            uint256 _bnbFee = amount.mul(bnbReflectionFee).div(feeDenominator);\\n            uint256 _liquidityFee = amount.mul(liquidityFee).div(feeDenominator);\\n\\n            uint256 _totalFee = _marketingFee + _charityFee + _bnbFee + _liquidityFee; // Total token fee\\n\\n            _balances[address(this)] = _balances[address(this)] + _totalFee; // New Balance\\n\\n            uint256 amountReceived = amount - _totalFee;\\n            _balances[recipient] = _balances[recipient].add(amountReceived);\\n            emit Transfer(sender, recipient, amountReceived);\\n\\n        } else {\\n            _balances[recipient] = _balances[recipient].add(amount);\\n            emit Transfer(sender, recipient, amount);\\n        }\\n\\n        if (!isDividendExempt[sender]) {\\n            try bnbDistributor.setShare(sender, _balances[sender]) {} catch {}\\n        }\\n\\n        if(!isDividendExempt[recipient]) {\\n            try bnbDistributor.setShare(recipient, _balances[recipient]) {} catch {}\\n        }\\n\\n        return true;\\n    }\\n\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        require(balanceOf(sender).sub(amount) >= 0, \\\"Insufficient Balance\\\");\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) return false;\\n\\n        address[] memory liqPairs = pairs;\\n\\n        for (uint256 i = 0; i < liqPairs.length; i++) {\\n            if (sender == liqPairs[i] || recipient == liqPairs[i]) return true;\\n        }\\n\\n        return feesOnNormalTransfers;\\n    }\\n\\n    function shouldSwapBack() internal view returns (bool) {\\n        return msg.sender != pancakeV2BNBPair\\n        && !inSwap\\n        && swapEnabled\\n        && _balances[address(this)] >= swapThreshold;\\n    }\\n\\n    function swapAndLiquidify() external onlyOwner {\\n        swapBack();\\n    }\\n\\n    function swapBack() internal swapping {\\n        uint256 balanceBefore = address(this).balance;\\n\\n        uint256 totalAmount = _balances[address(this)];\\n        uint256 denom = liquidityFee + charityFee + marketingFee + bnbReflectionFee;\\n\\n        uint256 marketingSwap = totalAmount.mul(marketingFee).div(denom);\\n        uint256 charitySwap = totalAmount.mul(charityFee).div(denom);\\n        uint256 bnbSwap = totalAmount.mul(bnbReflectionFee).div(denom);\\n        uint256 liquiditySwap = totalAmount.mul(liquidityFee).div(denom);\\n\\n        uint256 amountToLiquify = liquiditySwap.div(2);\\n\\n        uint256 amountToSwap = marketingSwap + charitySwap + bnbSwap + amountToLiquify;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n\\n        _approve(address(this), address(router), amountToSwap);\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 swapedBNBAmount = address(this).balance.sub(balanceBefore);\\n\\n        if (swapedBNBAmount > 0) {\\n            uint256 bnbDenom = liquidityFee.div(2) + charityFee + marketingFee + bnbReflectionFee;\\n            uint256 bnbSwapMarketingAmount = swapedBNBAmount.mul(marketingFee).div(bnbDenom); // BNB for Marketing\\n            uint256 bnbSwapCharityAmount = swapedBNBAmount.mul(charityFee).div(bnbDenom); // BNB for Charity\\n            uint256 bnbSwapBnbAmount = swapedBNBAmount.mul(bnbReflectionFee).div(bnbDenom); // BNB for BNB Rewards\\n            uint256 bnbLiquidify = swapedBNBAmount.mul(liquidityFee.div(2)).div(bnbDenom); // BNB for Liqudity\\n\\n            if (bnbSwapMarketingAmount > 0) {\\n                // Send BNB for Marketing\\n                payable(marketingFeeReceiver).transfer(bnbSwapMarketingAmount);\\n            }\\n\\n            if (bnbSwapCharityAmount > 0) {\\n                // Send BNB for Charity\\n                payable(charityFeeReceiver).transfer(bnbSwapCharityAmount);\\n            }\\n\\n            if (bnbSwapBnbAmount > 0) {\\n                // Send BNB for Rewards\\n                payable(bnbDistributor).transfer(bnbSwapBnbAmount);\\n                bnbDistributor.depositExternalBNB(bnbSwapBnbAmount);\\n            }\\n\\n            if (bnbLiquidify > 0){\\n                _approve(address(this), address(router), amountToLiquify);\\n                router.addLiquidityETH{ value: bnbLiquidify }(\\n                    address(this),\\n                    amountToLiquify,\\n                    0,\\n                    0,\\n                    autoLiquidityReceiver,\\n                    block.timestamp\\n                );\\n            }\\n        }\\n    }\\n\\n    function BNBbalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function BNBRewardbalance() external view returns (uint256) {\\n        return address(bnbDistributor).balance;\\n    }\\n\\n    function setIsDividendExempt(address holder, bool exempt) external onlyOwner {\\n        require(holder != address(this) && holder != pancakeV2BNBPair);\\n        isDividendExempt[holder] = exempt;\\n        if (exempt) {\\n            bnbDistributor.setShare(holder, 0);\\n        } else{\\n            bnbDistributor.setShare(holder, _balances[holder]);\\n        }\\n    }\\n\\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function setFees(\\n        uint256 _liquidityFee,\\n        uint256 _charityFee,\\n        uint256 _marketingFee,\\n        uint256 _bnbReflectionFee\\n    ) external onlyOwner {\\n        liquidityFee = _liquidityFee;\\n        charityFee = _charityFee;\\n        marketingFee = _marketingFee;\\n        bnbReflectionFee = _bnbReflectionFee;\\n    }\\n\\n    function setSwapThreshold(uint256 threshold) external onlyOwner {\\n        swapThreshold = threshold;\\n    }\\n\\n    function setSwapEnabled(bool _enabled) external onlyOwner {\\n        swapEnabled = _enabled;\\n    }\\n\\n    function setCharityFeeReceiver(address _receiver) external onlyOwner {\\n        charityFeeReceiver = _receiver;\\n        bnbDistributor.setCharityFeeReceiver(_receiver);\\n\\n        isDividendExempt[_receiver] = true;\\n        isFeeExempt[_receiver] = true;\\n    }\\n\\n    function setMarketingFeeReceiver(address _receiver) external onlyOwner {\\n        marketingFeeReceiver = _receiver;\\n        bnbDistributor.setMarketingFeeReceiver(_receiver);\\n\\n        isDividendExempt[_receiver] = true;\\n        isFeeExempt[_receiver] = true;\\n    }\\n\\n    function setLiquidityFeeReceiver(address _receiver) external onlyOwner {\\n        autoLiquidityReceiver = _receiver;\\n        bnbDistributor.setLiquidityFeeReceiver(_receiver);\\n\\n        isDividendExempt[_receiver] = true;\\n        isFeeExempt[_receiver] = true;\\n    }\\n\\n\\n    function getCirculatingSupply() external view returns (uint256) {\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\n    }\\n\\n    function getClaimableBNB() external view returns (uint256) {\\n        return bnbDistributor.currentRewards(msg.sender);\\n    }\\n\\n    function getWalletClaimableBNB(address _addr) external view returns (uint256) {\\n        return bnbDistributor.currentRewards(_addr);\\n    }\\n\\n    function getWalletShareAmount(address _addr) external view returns (uint256) {\\n        return bnbDistributor.getWalletShare(_addr);\\n    }\\n\\n    function claim() external {\\n        bnbDistributor.claimDividend(msg.sender);\\n    }\\n\\n    function donate() external {\\n        bnbDistributor.donate(msg.sender);\\n    }\\n\\n    function depositExternalBNB() external payable {\\n        payable(bnbDistributor).transfer(msg.value);\\n        bnbDistributor.depositExternalBNB(msg.value);\\n    }\\n\\n    function buyAnjiWithReward() external {\\n        bnbDistributor.buyToken(msg.sender);\\n    }\\n\\n    function addPair(address pair) external onlyOwner {\\n        pairs.push(pair);\\n    }\\n\\n    function removeLastPair() external onlyOwner {\\n        pairs.pop();\\n    }\\n\\n    function setFeesOnNormalTransfers(bool _enabled) external onlyOwner {\\n        feesOnNormalTransfers = _enabled;\\n    }\\n\\n    function setisRestricted(address adr, bool restricted) external onlyOwner {\\n        isRestricted[adr] = restricted;\\n    }\\n\\n    function walletIsDividendExempt(address adr) external view returns (bool) {\\n        return isDividendExempt[adr];\\n    }\\n\\n    function walletIsTaxExempt(address adr) external view returns (bool) {\\n        return isFeeExempt[adr];\\n    }\\n\\n    function walletisRestricted(address adr) external view returns (bool) {\\n        return isRestricted[adr];\\n    }\\n\\n    // only for recovering excess BNB in the contract, in times of miscalculation. Can only be sent to marketing wallet - ALWAYS CONFIRM BEFORE USE\\n    function recoverExcess(uint256 amount) external onlyOwner {\\n        require(amount < address(this).balance, \\\"ANJI: Can not send more than contract balance\\\");\\n        payable(marketingFeeReceiver).transfer(amount);\\n    }\\n\\n    // only for recovering tokens that are NOT ANJI tokens sent in error by wallets\\n    function withdrawTokens(address tokenaddr) external onlyOwner {\\n        require(tokenaddr != address(this), 'This is for tokens sent to the contract by mistake');\\n        uint256 tokenBal = IBEP20(tokenaddr).balanceOf(address(this));\\n        if (tokenBal > 0) {\\n            IBEP20(tokenaddr).transfer(marketingFeeReceiver, tokenBal);\\n        }\\n    }\\n\\n    receive() external payable { }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BoughtBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"BuybackMultiplierActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Launched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"SwapBackFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapBackSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BNBRewardbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BNBbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbDistributor\",\"outputs\":[{\"internalType\":\"contract BNBDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyAnjiWithReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositExternalBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesOnNormalTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimableBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getWalletClaimableBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getWalletShareAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverExcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLastPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setCharityFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_charityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bnbReflectionFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setFeesOnNormalTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setLiquidityFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setMarketingFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"}],\"name\":\"setisRestricted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquidify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"walletIsDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"walletIsTaxExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"walletisRestricted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AnjiToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}