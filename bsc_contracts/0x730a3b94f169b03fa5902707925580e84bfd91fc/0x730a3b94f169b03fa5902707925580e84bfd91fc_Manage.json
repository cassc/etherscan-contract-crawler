{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n    address internal _upgrade;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function getUpgrade() public view returns(address){\r\n        return _upgrade;\r\n    }\r\n\r\n    function setUpgrade(address upgrade) external virtual{\r\n        require(msg.sender == _owner,'!owner');\r\n        _upgrade = upgrade;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender || (_upgrade != address(0) ? msg.sender == _upgrade : false), \"!owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"new 0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Manage is Ownable{\r\n    using SafeMath for uint256;\r\n    struct Info{\r\n        string hashNumber;\r\n        uint256 timestamp; \r\n        uint256 reward; \r\n        uint256 guessMantissa;\r\n        uint256 hashMantissa; \r\n        address token; \r\n    }\r\n    struct Children{\r\n        string hashNumber;\r\n        uint256 timestamp; \r\n        uint256 bonus;\r\n    }\r\n    struct Referrals{\r\n        address[] adr; \r\n        address superior; \r\n        uint256 totalReward; \r\n        uint256 totalBets;\r\n        Info[] info;\r\n        Children[] children;\r\n        uint256 totalBonus; \r\n    }\r\n    struct Amount{\r\n        uint256 min;\r\n        uint256 max; \r\n        bool exceed; \r\n    }\r\n    address[] private tokenList;\r\n    bool private locked;\r\n    address private guessAddress = 0xe8Ad915d65Cd35E0642719C48811268785ddF8f2; \r\n    mapping(address => Referrals) private referralsList; \r\n    mapping(address => Amount) limit; \r\n    uint256 private denominator = 10000; \r\n    uint256 private retail = 150; \r\n    uint256 private odds = 9500; \r\n    address private _receiver; \r\n    address private manageAddress; \r\n    address private Usdt = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    receive() external payable {}\r\n    constructor(){\r\n\r\n        manageAddress = 0xF69E76D36fBa457841D902b240F975cB1aa0Aeb9;\r\n        _receiver = 0xaA2F14Fd45FE822a6935bE130E021962CF9354c9;\r\n\r\n        IERC20 token = IERC20(0x50fCf9351a24cb0554d68C8FC9ae49E9b96e3D2f);\r\n        IERC20 _usdt = IERC20(Usdt);\r\n\r\n        tokenList.push(address(token));\r\n        tokenList.push(address(_usdt));\r\n\r\n        Amount storage _tokenLimit = limit[address(token)];\r\n        _tokenLimit.min = 2000 * 10**token.decimals();\r\n        _tokenLimit.max = 200000 * 10**token.decimals();\r\n\r\n        Amount storage _usdtLimit = limit[Usdt];\r\n        _usdtLimit.min = 20 * 10**_usdt.decimals();\r\n        _usdtLimit.max = 5000 * 10**_usdt.decimals();\r\n\r\n\r\n    }\r\n\r\n    function setOdds(uint256 _odds) external virtual onlyOwner{\r\n        odds = _odds;\r\n    }\r\n\r\n    function getOdds() external view returns(uint256){\r\n        return odds;\r\n    }\r\n\r\n    function setRetail(uint256 _retail) external virtual onlyOwner{\r\n        retail = _retail;\r\n    }\r\n    \r\n    function getRetail() public view returns(uint256){\r\n        return retail;\r\n    }\r\n\r\n    function setDenominator(uint256 _denominator) external virtual onlyOwner{\r\n        denominator = _denominator;\r\n    }\r\n\r\n    function getDenominator() external view returns(uint256){\r\n        return denominator;\r\n    }\r\n\r\n    function setManageAdr(address manage) external virtual onlyOwner{\r\n        manageAddress = manage;\r\n    }\r\n\r\n    function getManageAdr() external view returns(address){\r\n        return manageAddress;\r\n    }\r\n\r\n    function balanceOf(address token) external view returns(uint256){\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function setLimit(address token, uint256 max,uint256 min, bool exceed) external virtual onlyOwner{\r\n        Amount storage _amount = limit[token];\r\n        _amount.max = max;\r\n        _amount.min = min;\r\n        _amount.exceed = exceed;\r\n    }\r\n\r\n    function setMaxLimit(address token, uint256 max) external virtual onlyOwner{\r\n         Amount storage _amount = limit[token];\r\n         _amount.max = max;\r\n    }\r\n\r\n    function setMinLimit(address token, uint256 min) external virtual onlyOwner{\r\n         Amount storage _amount = limit[token];\r\n         _amount.min = min;\r\n    }\r\n\r\n    function setExceedLimit(address token, bool exceed) external virtual onlyOwner{\r\n         Amount storage _amount = limit[token];\r\n         _amount.exceed = exceed;\r\n    }\r\n\r\n    function getLimit(address token) external view returns(uint256,uint256,bool,uint256){\r\n        Amount storage _amount = limit[token];\r\n        uint256 max = _amount.max;\r\n        uint256 min = _amount.min;\r\n        bool exceed = _amount.exceed;\r\n        return (max,min,exceed,IERC20(token).decimals());\r\n    }\r\n\r\n    function getReceiver() external view returns(address){\r\n        return _receiver;\r\n    }\r\n\r\n    function setReceiver(address receiver) external virtual onlyOwner{\r\n        require(receiver != address(0),'address is zero');\r\n        _receiver = receiver;\r\n    }\r\n\r\n    function getToken() external view returns(address[] memory){\r\n        return tokenList;\r\n    }\r\n\r\n    function addToken(address _token) external virtual onlyOwner{\r\n        tokenList.push(_token);\r\n    }\r\n\r\n    function removeToken(address _token) external virtual onlyOwner{\r\n        uint256 length = tokenList.length;\r\n        for(uint256 i = 0 ; i < length ; i++){\r\n            if(tokenList[i] == _token){\r\n                if(i < length - 1){\r\n                    tokenList[i] = tokenList[length - 1]; \r\n                }\r\n                tokenList.pop();\r\n                return; \r\n            }\r\n        }\r\n    }\r\n\r\n    function getGuessAddress() public view returns(address){\r\n        return guessAddress;\r\n    }\r\n\r\n    function setGuessAddress(address adr) external virtual onlyOwner{\r\n        guessAddress = adr;\r\n    }\r\n\r\n    function setSuperior(address sender,address _superior) external virtual returns(bool){\r\n        Referrals storage referrals = referralsList[sender];\r\n        require(address(0) == referrals.superior && address(0) != _superior && sender != _superior,'recommended person has been set');\r\n        referralsList[_superior].adr.push(sender);\r\n        referrals.superior = _superior;\r\n        return true;\r\n    }\r\n\r\n    function getSuperior(address sender) external view returns(address){\r\n        return referralsList[sender].superior;\r\n    }\r\n    function referralReward(address token,address from,uint256 amount) private returns(uint256,address){\r\n        address superior = referralsList[from].superior;\r\n        uint256 rewardAmount = amount.mul(retail).div(denominator);\r\n        address adr;\r\n        if(superior == address(0)){\r\n            require(IERC20(token).transfer(_receiver, rewardAmount),'Transfer failed');\r\n        }else{\r\n            Referrals storage referrals = referralsList[superior];\r\n            referrals.totalBonus = referrals.totalBonus.add(rewardAmount); \r\n            require(IERC20(token).transfer(superior, rewardAmount),'Transfer failed');\r\n            adr = superior;\r\n        }\r\n        return (rewardAmount,adr);\r\n    }\r\n\r\n    function char(bytes1 b) private pure returns (bytes1) {\r\n        if (uint8(b) < 10) { // \u5c06 bytes1 \u8f6c\u6362\u4e3a uint8\r\n            return bytes1(uint8(b) + 0x30);\r\n        } else {\r\n            return bytes1(uint8(b) + 0x57);\r\n        }\r\n    }\r\n\r\n    function toHexString(bytes32 value) private pure returns (string memory) {\r\n        bytes memory data = new bytes(64);\r\n        for (uint i = 0; i < 32; i++) {\r\n            bytes1 b = bytes1(uint8(uint(value) / (2**(8*(31 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            data[i*2] = char(hi);\r\n            data[i*2 + 1] = char(lo);\r\n        }\r\n        return string(data);\r\n    }\r\n    function getBlockHash() private view returns (string memory) {\r\n        // bytes32 blockHash = blockhash(block.number - 1);\r\n        bytes32 blockHash = keccak256(\r\n            abi.encodePacked(\r\n                blockhash(block.number -1),\r\n                block.number,\r\n                block.timestamp\r\n            )\r\n        );\r\n        return toHexString(blockHash);\r\n    }\r\n    function lastHashChar(string memory blockHash) private pure returns(uint256){\r\n        for(uint256 i = bytes(blockHash).length; i > 0 ; i--){\r\n            bytes1 lastCharacter = bytes(blockHash)[i - 1];\r\n            bytes memory result = new bytes(2);\r\n            result[0] = lastCharacter;\r\n            result[1] = 0;\r\n            if(!((lastCharacter >= \"a\" && lastCharacter <= \"z\") || (lastCharacter >= \"A\" && lastCharacter <= \"Z\"))){\r\n                bytes memory hexBytes = bytes(string(result));\r\n                uint256 last = 0;\r\n                for(uint256 j = 0 ; j < hexBytes.length ; j++){\r\n                    uint8 digit = uint8(hexBytes[j]);\r\n                    if(digit >= 48 && digit <= 57){\r\n                        last = last * 16 + (digit - 48);\r\n                    }\r\n                }\r\n                return last;\r\n            }\r\n        }\r\n        return 10;\r\n    }\r\n    function lastAmountChar(address token,uint256 amount)private view returns(uint256){\r\n        uint256 decimals = 1 * 10 ** IERC20(token).decimals();\r\n        return\r\n        amount % decimals > 0\r\n        ? (amount % decimals) / (decimals / 10):\r\n        (amount / decimals) % 10;\r\n    }\r\n\r\n    function transfer(address token,address from ,address to, uint256 amount,string memory blockHash) private{\r\n        require(from == guessAddress && guessAddress != address(0),'non guessing address');\r\n        uint256 bonusAmount = amount.mul(odds).div(denominator).add(amount); \r\n        (uint256 rewardAmount,address superior) = referralReward(token,to, amount);\r\n        computeResult(token,superior, rewardAmount, to, amount, bonusAmount,blockHash);\r\n    }\r\n    function computeResult(address token,address superior,uint256 rewardAmount,address sender,uint256 amount,uint256 bonusAmount,string memory blockHash) private{\r\n        uint256 lastHast = lastHashChar(blockHash); \r\n        uint256 lastAmount = lastAmountChar(token,amount);\r\n        bool bl;\r\n        uint256 reward;\r\n        if(((lastHast % 2 == 0) && (lastAmount % 2 == 0)) || ((lastHast % 2 != 0) && (lastAmount % 2 != 0))){ \r\n            Children[] storage children = referralsList[superior].children; \r\n            Children memory newChildren = Children({hashNumber:blockHash,timestamp:block.timestamp,bonus:rewardAmount});\r\n            children.push(newChildren);\r\n            Amount storage _limit = limit[token];\r\n            if(_limit.max < amount){ \r\n                if(_limit.exceed){\r\n                    reward = bonusAmount;\r\n                    bl = true;\r\n                }\r\n            }else{\r\n                reward = bonusAmount;\r\n                bl = true;\r\n            }\r\n        }\r\n        Referrals storage referrals = referralsList[sender];\r\n        referrals.totalBets = referrals.totalBets.add(amount);\r\n        Info memory info = Info({\r\n            hashNumber:blockHash,\r\n            timestamp:block.timestamp,\r\n            guessMantissa:lastAmount,\r\n            hashMantissa:lastHast,\r\n            token:token,\r\n            reward: reward\r\n        });\r\n        referrals.totalReward = referrals.totalReward.add(reward);\r\n        referrals.info.push(info);\r\n        if(bl){\r\n            require(IERC20(token).transfer(sender, reward),'Transfer failed');\r\n        }\r\n    }\r\n\r\n    function transferFrom(string memory blockHash,address token,address to ,uint256 amount) external virtual{\r\n        address from = msg.sender;\r\n        transfer(token,from, to, amount,blockHash);\r\n    }\r\n\r\n    function claimToken(address token, uint256 amount) external onlyOwner{\r\n        IERC20(token).transfer(_receiver, amount);\r\n    }\r\n\r\n    function claimAllToken(address token) external onlyOwner{\r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.transfer(_receiver, erc20.balanceOf(address(this)));\r\n    }\r\n\r\n    function claimBalance() external onlyOwner{\r\n        payable(_receiver).transfer(address(this).balance);\r\n    }\r\n\r\n    function getChildren(address adr) external view returns(string[] memory,uint256[] memory,uint256[] memory){\r\n        Children[] storage children = referralsList[adr].children;\r\n        uint256 length = children.length;\r\n        uint256 itemLength = children.length > 5 ? 5 : length;\r\n        string[] memory hashNumber = new string[](itemLength);\r\n        uint256[] memory timestamp = new uint256[](itemLength);\r\n        uint256[] memory bonus = new uint256[](itemLength);\r\n        uint256 count = 0;\r\n        for(uint256 i = length ;i > 0; i--){\r\n            if(count >= 5){\r\n                return (hashNumber,timestamp,bonus);\r\n            }\r\n            Children memory info = children[i-1];\r\n            hashNumber[i-1] = info.hashNumber;\r\n            timestamp[i-1] = info.timestamp;\r\n            bonus[i-1] = info.bonus;\r\n            count += 1;\r\n        }\r\n        return (hashNumber,timestamp,bonus);\r\n    }\r\n\r\n    function getTotalB(address adr) external view returns(uint256,uint256,uint256,address){\r\n        Referrals storage referrals = referralsList[adr];\r\n        return (referrals.totalReward,referrals.totalBets,referrals.totalBonus,referrals.superior);\r\n    }\r\n\r\n    function getInfo(address adr) external view returns(string[] memory,uint256[] memory,uint256[] memory){\r\n        Referrals storage referrals = referralsList[adr];\r\n        Info[] storage info = referrals.info;\r\n        uint256 length = info.length;\r\n        uint256 itemLength = info.length > 5 ? 5 : length;\r\n        string[] memory hashNumber = new string[](itemLength);\r\n        uint256[] memory timestamp = new uint256[](itemLength);\r\n        uint256[] memory reward = new uint256[](itemLength);\r\n        uint256 count = 0;\r\n        for(uint256 i = length ;i > 0; i--){\r\n            if(count >= 5){\r\n                return (hashNumber,timestamp,reward);\r\n            }\r\n            Info storage item = info[i-1];\r\n            hashNumber[i - 1] = item.hashNumber;\r\n            timestamp[i - 1] = item.timestamp;\r\n            reward[i - 1] = item.reward;\r\n            count += 1;\r\n        }\r\n        return (hashNumber,timestamp,reward);\r\n    }\r\n\r\n    function getSubList(address adr) external view returns(address[] memory,uint256){\r\n        address[] memory adrList= referralsList[adr].adr;\r\n        uint256 length = adrList.length;\r\n        uint256 count = 0;\r\n        uint256 itemLength = adrList.length > 5 ? 5 : length;\r\n        address[] memory List = new address[](itemLength);\r\n        for(uint256 i = length ;i > 0; i--){\r\n            if(count >= 5){\r\n                return (List,length);\r\n            }\r\n            List[i - 1] = adrList[i - 1];\r\n            count += 1;\r\n        }\r\n        return (List,length);\r\n    }\r\n\r\n    function getLastHash(address adr) external view returns (string memory,uint256){\r\n        Info[] memory info = referralsList[adr].info;\r\n        string memory str;\r\n        uint256 timestamp;\r\n        uint256 length = info.length;\r\n        if(length > 0){\r\n            Info memory item = info[length -1];\r\n            str = item.hashNumber;\r\n            timestamp = item.timestamp;\r\n        }\r\n        return (str,timestamp);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimAllToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getChildren\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuessAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getLastHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getManageAdr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOdds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getSubList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getSuperior\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getTotalB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUpgrade\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exceed\",\"type\":\"bool\"}],\"name\":\"setExceedLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setGuessAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exceed\",\"type\":\"bool\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manage\",\"type\":\"address\"}],\"name\":\"setManageAdr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMaxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"setMinLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_odds\",\"type\":\"uint256\"}],\"name\":\"setOdds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_retail\",\"type\":\"uint256\"}],\"name\":\"setRetail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_superior\",\"type\":\"address\"}],\"name\":\"setSuperior\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upgrade\",\"type\":\"address\"}],\"name\":\"setUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"blockHash\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Manage", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f236aebf66f59af182a712e2273d08766ec725ee376212cecd8f08ca5f54f98"}