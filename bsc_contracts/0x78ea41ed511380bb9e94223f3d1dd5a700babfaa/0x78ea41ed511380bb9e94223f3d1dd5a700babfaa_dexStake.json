{"SourceCode": "pragma solidity >= 0.7.0 < 0.9.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\ncontract dexStake{\r\n    /*\r\n    ToDO \r\n    */\r\n    address private tokenAddress; //token address used for stake\r\n    address private SetterAddress; // setter of the rewards and contract\r\n    uint256 private totalStaking = 0; // total tokens added for stake by users\r\n    uint256 private totalRewards = 0; // total tokens added for reward by setter\r\n    uint256 private totalRewardsWon = 0; // total tokens Rewards Retrieved by users\r\n    uint256 private lockedpool = 0; // make a lock on the pool not to allow more stakes (allow other withdrawls, add rewards, etc)\r\n    address private teamMember1;\r\n    address private teamMember2;\r\n    address private teamMember3;\r\n    mapping(uint256 => address) private stakingAddress; //List with all addreses staking\r\n    uint256 private StakingAddressCount = 1;\r\n    mapping(address => uint256) private balances; //Total balance for the stake (not including rewards)\r\n    mapping(address => uint256) private rewardWon; //Reward taken out from staking\r\n    mapping(address => mapping (uint256 => uint256)) private rewards; //balance for reward to withdraw\r\n    mapping(address => mapping (uint256 => uint256)) private amountStaked; //added time for stake\r\n    mapping(address => mapping (uint256 => uint256)) private savedAmountStaked; //added time for stake\r\n    mapping(address => mapping (uint256 => uint256)) private timeStake; //added time for stake\r\n    mapping(address => uint256) stakeCount; //added time for stake\r\n    mapping(address => mapping (uint256 => uint256)) private rewardAdd; //allowed\r\n    mapping(address => mapping (address => uint256)) private teamAllow; //allowed\r\n    //uint256 stakingperiod = 31536000; //1 year staking\r\n    uint256 private stakingperiod = 31536000; //5 minutes staking period\r\n    string name;\r\n\r\n    event Staked(address indexed token, address indexed staker_, uint256 stakedAmount_, uint256 indexed _time);\r\n    event EarlyWithdraw(address indexed token, address indexed staker_, uint256 stakedAmount_, uint256 indexed _time);\r\n    event StakedOut(address indexed token, address indexed staker_, uint256 stakedAmount_, uint256 indexed _time);\r\n    event RewardAdd(address indexed token, address indexed staker_, uint256 stakedAmount_);\r\n    event RewardSet();\r\n    event PoolLocked();\r\n    event PoolUnlocked();\r\n\r\n\r\n   constructor(address _tokenAddress, address _teamMember1, address _teamMember2, address _teamMember3,string memory _name, uint256 _stakingperiod){\r\n        tokenAddress = _tokenAddress; \r\n        SetterAddress = msg.sender;\r\n        teamMember1 = _teamMember1;  \r\n        teamMember2 = _teamMember2;  \r\n        teamMember3 = _teamMember3;  \r\n        name = _name;\r\n        stakingperiod = _stakingperiod;\r\n       \r\n    }\r\n\r\n    //add reward by owner of the pool\r\n    function addReward(uint _amount) _approvedByAnyTeam() public returns(bool){\r\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this) ,_amount);\r\n        totalRewards += _amount;\r\n        emit RewardAdd(tokenAddress, msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    //stake tokens after aproval\r\n    function stakeTokens(uint _amount ) _realAddress(msg.sender) _positive(_amount) _notlocked() public returns (bool){\r\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this) ,_amount);\r\n        balances[msg.sender] += _amount;\r\n        amountStaked[msg.sender][block.timestamp] = _amount;\r\n        savedAmountStaked[msg.sender][block.timestamp] = _amount;\r\n        if(stakeCount[msg.sender]<1){\r\n            stakeCount[msg.sender] = 1;\r\n            stakingAddress[StakingAddressCount] = msg.sender;\r\n            StakingAddressCount++;\r\n        }\r\n        timeStake[msg.sender][stakeCount[msg.sender]] = block.timestamp;\r\n        stakeCount[msg.sender]++;\r\n        totalStaking+= _amount;\r\n        emit Staked(tokenAddress, msg.sender, _amount, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    //withdraw after staking ends\r\n    function withdrawStake(uint256 _timestamp) _realAddress(msg.sender)  public returns(bool){\r\n        require(stakeCount[msg.sender]>1,\"You have no staked tokens\");\r\n        require(amountStaked[msg.sender][_timestamp]>0,\"You have no staked rewards\");\r\n        require((_timestamp+stakingperiod) < block.timestamp,\"Staking period not finished! Try early withdraw!\");\r\n        require(rewardAdd[msg.sender][_timestamp]==1,\"Please wait! Reward has not been added!\");\r\n        uint256 totalamount = _totalamount(_timestamp);\r\n        IERC20(tokenAddress).transfer(msg.sender,totalamount);\r\n        balances[msg.sender] -= amountStaked[msg.sender][_timestamp];\r\n        rewardWon[msg.sender] += rewards[msg.sender][_timestamp];\r\n        totalStaking -= amountStaked[msg.sender][_timestamp];\r\n        totalRewardsWon += rewards[msg.sender][_timestamp];\r\n        amountStaked[msg.sender][_timestamp] = 0;\r\n        //rewards[msg.sender][_timestamp] = 0;\r\n        emit StakedOut(tokenAddress, msg.sender, totalamount, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    //withdraw early with losing all rewards\r\n    function earlyWithdraw(uint _timestamp) _realAddress(msg.sender) public returns(bool){\r\n        require(stakeCount[msg.sender]>1,\"You have no staked tokens\");\r\n        require(amountStaked[msg.sender][_timestamp]>0,\"You have no staked rewards\");\r\n        uint256 totalamount = _totalamountWithoutReward(_timestamp);\r\n        IERC20(tokenAddress).transfer(msg.sender,totalamount);\r\n        totalStaking-= amountStaked[msg.sender][_timestamp];\r\n        amountStaked[msg.sender][_timestamp] = 0;\r\n        emit EarlyWithdraw(tokenAddress, msg.sender, totalamount, block.timestamp);\r\n        return true;\r\n    }\r\n    \r\n    //withdraw any funds that were added by mistake (different tokens)\r\n    // failsafe with funds\r\n    function withdrawAnyWrongTokenFunds(address _token) _realAddress(msg.sender) _realAddress(_token) _setter(msg.sender) _approvedByTeam(_token) public returns (bool){\r\n        IERC20(_token).transfer(msg.sender,IERC20(_token).balanceOf(address(this)));\r\n        return true;\r\n    }\r\n\r\n    //set rewards by owner\r\n    function setRewards(address[] memory _address,uint256[] memory _timestamp,uint256[] memory _reward) _approvedByAnyTeam() public returns(bool){\r\n        for(uint i=0;i<_address.length;i++){\r\n            rewards[_address[i]][_timestamp[i]] = _reward[i];\r\n            rewardAdd[_address[i]][_timestamp[i]] = 1;\r\n        }\r\n        emit RewardSet();\r\n        return true;\r\n    }\r\n\r\n    function team1Allow(address _address) public returns(uint){\r\n        require(msg.sender == teamMember1, \"You need to be Member 1 of the team\");\r\n        teamAllow[_address][teamMember1] = 1;\r\n        return teamAllow[_address][teamMember1];\r\n    }\r\n    function team2Allow(address _address) public returns(uint){\r\n        require(msg.sender == teamMember2, \"You need to be Member 2 of the team\");\r\n        teamAllow[_address][teamMember2] = 1;\r\n        return teamAllow[_address][teamMember2];\r\n    }\r\n    function team3Allow(address _address) public returns(uint){\r\n        require(msg.sender == teamMember3, \"You need to be Member 3 of the team\");\r\n        teamAllow[_address][teamMember3] = 1;\r\n        return teamAllow[_address][teamMember3];\r\n    }\r\n\r\n    function setLockedPool() _approvedByAnyTeam() public returns (bool){\r\n        lockedpool = 1;\r\n        emit PoolLocked();\r\n        return true;\r\n    }\r\n    function setUnlockedPool() _approvedByAnyTeam() public returns (bool){\r\n        lockedpool = 0;\r\n        emit PoolUnlocked();\r\n        return true;\r\n    }\r\n\r\n    function getName() public view returns(string memory){\r\n        return name;\r\n    }\r\n\r\n    /*\r\n\r\n        Get Functions for Staked Variables\r\n\r\n    */\r\n\r\n    //get full balanced for how many tokens are staked\r\n    //todo\r\n    function getStakedBalance(address _address) public view returns(uint){\r\n        return balances[_address];\r\n    }\r\n\r\n    //get balance for every stake made\r\n    //todo\r\n    function getStakedBalanceByTimestamp(address _address, uint256 _time) public view returns(uint){\r\n        return amountStaked[_address][_time];\r\n    }\r\n    \r\n    //get balance for every stake made\r\n    //todo\r\n    function getSavedStakedBalanceByTimestamp(address _address, uint256 _time) public view returns(uint){\r\n        return savedAmountStaked[_address][_time];\r\n    }\r\n\r\n\r\n    //get balance for every stake made\r\n    //todo\r\n    function getStakedTimestamp(address _address, uint256 _i) public view returns(uint ){\r\n         return timeStake[_address][_i];\r\n    }\r\n\r\n    //get how many stakings is done by an address\r\n    //todo\r\n    function getStakedCount(address _address) public view returns(uint256){\r\n        if(stakeCount[_address]>0){\r\n            return stakeCount[_address];\r\n        }else{\r\n            return 0;\r\n        }\r\n        \r\n    }\r\n\r\n    //get total staking tokens count\r\n    function getTotalStaking() public view returns (uint256){\r\n        return totalStaking;\r\n    }\r\n\r\n    //get staking counter for addresses\r\n    function getStakingAddressCount() public view returns(uint256){\r\n        return StakingAddressCount;\r\n    }\r\n    \r\n    //get staking address by id\r\n    function getStakingAddress (uint _i) public view returns(address){\r\n        return stakingAddress[_i];\r\n    }\r\n\r\n    //get staking address by id\r\n    function getStakingPeriod() public view returns(uint256){\r\n        return stakingperiod;\r\n    }\r\n\r\n    /*\r\n\r\n        Get Functions for Reward Variables\r\n\r\n    */\r\n\r\n    //get reward by every stake\r\n    function getRewardByTimestamp(address _address, uint256 _time) public view returns(uint){\r\n        return rewards[_address][_time];\r\n    }\r\n\r\n\r\n     //get reward state added by every stake\r\n    function getRewardAddByTimestamp(address _address, uint256 _time) public view returns(uint){\r\n        return rewardAdd[_address][_time];\r\n    }\r\n\r\n     //get rewardWon added by every stake\r\n    function getRewardWonByAddress(address _address) public view returns(uint){\r\n        return rewardWon[_address];\r\n    }\r\n    \r\n    //get total rewards added by now\r\n    function getTotalRewards() public view returns(uint256){\r\n        return totalRewards;\r\n    }\r\n\r\n    //get total rewards won\r\n    function getTotalRewardsWon() public view returns(uint256){\r\n        return totalRewardsWon;\r\n    }\r\n\r\n    //get total amount of rewards won by a single address\r\n    function getRewardWon(address _address) public view returns(uint256){\r\n        return rewardWon[_address];\r\n    }\r\n\r\n    /*\r\n        Private Functions\r\n    */\r\n\r\n    function _totalamount(uint _timestamp) private view returns(uint){\r\n        return amountStaked[msg.sender][_timestamp]+ rewards[msg.sender][_timestamp];\r\n    }\r\n\r\n    function _totalamountWithoutReward(uint _timestamp) private view returns(uint){\r\n        return amountStaked[msg.sender][_timestamp];\r\n    }\r\n\r\n    /*\r\n\r\n        Modifiers\r\n\r\n    */\r\n    modifier _realAddress(address addr) {\r\n        require(addr != address(0), \"Zero address\");\r\n        _;\r\n    }\r\n\r\n    modifier _positive(uint256 amount) {\r\n        require(amount != 0, \"Negative amount\");\r\n        _;\r\n    }\r\n\r\n    modifier _after(uint eventTime) {\r\n        require(block.timestamp >= eventTime, \"Bad timing for the request\");\r\n        _;\r\n    }\r\n\r\n    modifier _before(uint eventTime) {\r\n        require(block.timestamp < eventTime, \"Bad timing for the request\");\r\n        _;\r\n    }\r\n    modifier _setter(address _address) {\r\n        require(_address==SetterAddress,\"You don't have access to this funds\");\r\n        _;\r\n    }\r\n    modifier _notlocked() {\r\n        require(lockedpool!=1,\"Pool is locked!\");\r\n        _;\r\n    }\r\n    modifier _approvedByTeam(address _address) {\r\n        require(teamAllow[_address][teamMember1]==1,\"Team Member 1 needs to allow this\");\r\n        require(teamAllow[_address][teamMember2]==1,\"Team Member 2 needs to allow this\");\r\n        require(teamAllow[_address][teamMember3]==1,\"Team Member 3 needs to allow this\");\r\n        _;\r\n    }\r\n    modifier _approvedByAnyTeam() {\r\n        if((msg.sender==teamMember1)||(msg.sender==teamMember2)||(msg.sender==teamMember3)||(msg.sender==SetterAddress)){\r\n\r\n        }else{\r\n            require(1==0,\"Team member required to do this function\");\r\n        }\r\n        _;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamMember1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamMember2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamMember3\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_stakingperiod\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"EarlyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PoolLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PoolUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"}],\"name\":\"RewardAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RewardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"StakedOut\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"earlyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getRewardAddByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getRewardByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRewardWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRewardWonByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getSavedStakedBalanceByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getStakedBalanceByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getStakedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getStakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingAddressCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewardsWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setLockedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_address\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamp\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_reward\",\"type\":\"uint256[]\"}],\"name\":\"setRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUnlockedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"team1Allow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"team2Allow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"team3Allow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawAnyWrongTokenFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "dexStake", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000e2b41ea957624a314108cc4e33703e9d78f4b3c000000000000000000000000be996e9cd5886add200861f4b57ae955a6a47636000000000000000000000000be996e9cd5886add200861f4b57ae955a6a47636000000000000000000000000be996e9cd5886add200861f4b57ae955a6a4763600000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000001e13380000000000000000000000000000000000000000000000000000000000000000843424420506f6f6c000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4fd74c4566f2c74d54f3136de6055d45c3fe73b1e924b5393bb5be6c06acfc98"}