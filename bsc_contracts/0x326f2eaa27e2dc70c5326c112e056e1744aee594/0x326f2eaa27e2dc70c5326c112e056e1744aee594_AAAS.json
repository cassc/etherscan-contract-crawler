{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-05-08\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IFlashBorrower {\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param tokenToBorrow The loan currency, must be an approved stable coin.\r\n     * @param tokenToRepay The repayment currency, must be an approved stable coin.\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address tokenToBorrow,\r\n        address tokenToRepay,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IFlashLender {\r\n    /**\r\n     * @dev The amount of currency available to be lent.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(address token, uint256 amount) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param tokenToBorrow The loan currency, must be an approved stable coin\r\n     * @param tokenToRepay The Repayment currency, must be an approved stable coin\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IFlashBorrower receiver,\r\n        address tokenToBorrow,\r\n        address tokenToRepay,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IXFlashBorrower {\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param token The loan currency, must be XUSD\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IXFlashLender {\r\n    /**\r\n     * @dev The amount of currency available to be lent.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param from The wallet borrowing the currency\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(address from, uint256 amount) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IXFlashBorrower receiver,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IXUSD {\r\n    function sell(uint256 amount, address token) external returns (address, uint256);\r\n    function mintWithBacking(address backingToken, uint256 amount) external returns (uint256);\r\n}\r\n\r\n/**\r\n    Arbitrage As A Service Contract\r\n */\r\ncontract AAAS is IFlashBorrower, IXFlashBorrower{\r\n\r\n    /** Wrapped BNB */\r\n    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\r\n    /** XUSD */\r\n    address constant XUSD = 0x324E8E649A6A3dF817F97CdDBED2b746b62553dD;\r\n\r\n    /** Wallet To Receive Dev Percent Of Profit Generated */\r\n    address public feeReceiver;\r\n\r\n    /** Flash Loan Provider */\r\n    address public provider;\r\n\r\n    /** XUSD Flash Loan Provider */\r\n    address public xProvider;\r\n\r\n    /** Callback Success */\r\n    bytes32 public constant CALLBACK_SUCCESS = keccak256('ERC3156FlashBorrower.onFlashLoan');\r\n\r\n    /** Number Of Projects Listed */\r\n    uint64 public nListed;\r\n\r\n    /** Total Value Borrowed */\r\n    uint256 public totalValueBorrowed;\r\n\r\n    /** Total Profit Generated */\r\n    uint256 public totalValueGained;\r\n\r\n    /** Total XUSD Value Borrowed */\r\n    uint256 public totalXValueBorrowed;\r\n\r\n    /** Total XUSD Profit Generated */\r\n    uint256 public totalXValueGained;\r\n\r\n    /** Approved XUSD Stables */\r\n    mapping( address => bool ) public approvedStables;\r\n\r\n    /** Listed Project Structure */\r\n    struct ListedProject {\r\n        string name;\r\n        address receiveAddress;\r\n        uint256 amountEarned;\r\n        uint256 earnPercentage;\r\n    }\r\n\r\n    /** ID -> Listed Project */\r\n    mapping ( uint64 => ListedProject ) public listedProjects;\r\n\r\n    /** Swap Information */\r\n    address[] DEXes;\r\n    address[] token0;\r\n    address[] token1;\r\n\r\n    /** Contract Operator */\r\n    address public operator;\r\n    modifier onlyOperator(){\r\n        require(msg.sender == operator, 'Only Operator');\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address feeReceiver_\r\n    ){\r\n        feeReceiver = feeReceiver_;\r\n        operator = msg.sender;\r\n        provider = 0x7FEeb737D07F24eAa76F146295f0f3D4ad9c2Adc;\r\n        xProvider = 0x1Bc2ABdb4190d6006ccf21724508477820A72dC8;\r\n        approvedStables[0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56] = true;\r\n        approvedStables[0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param tokenToBorrow The loan currency, must be an approved stable coin.\r\n     * @param tokenToRepay The repayment currency, must be an approved stable coin.\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address tokenToBorrow,\r\n        address tokenToRepay,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external override returns (bytes32) {\r\n\r\n        data;\r\n        initiator;\r\n        tokenToBorrow;\r\n\r\n        // cycle through swaps\r\n        for (uint i = 0; i < DEXes.length; i++) {\r\n            handleSwaps(\r\n                DEXes[i], \r\n                token0[i], \r\n                token1[i], \r\n                token0[i] == WETH ? address(this).balance : IERC20(token0[i]).balanceOf(address(this))\r\n            );\r\n        }\r\n\r\n        // check profitability\r\n        require(\r\n            amount + fee <= IERC20(tokenToRepay).balanceOf(address(this)),\r\n            'Non Profitable'\r\n        );\r\n\r\n        // repay flash loan\r\n        IERC20(tokenToRepay).transfer(\r\n            provider,\r\n            amount + fee\r\n        );\r\n\r\n        // increment amount borrowed\r\n        totalValueBorrowed += amount;\r\n\r\n        // increment fee generated\r\n        totalValueGained += IERC20(tokenToRepay).balanceOf(address(this));\r\n\r\n        return CALLBACK_SUCCESS;\r\n    }\r\n\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param token The loan currency, must be XUSD\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external override returns (bytes32) {\r\n        data;\r\n        initiator;\r\n        \r\n        // cycle through swaps\r\n        for (uint i = 0; i < DEXes.length; i++) {\r\n            handleSwaps(\r\n                DEXes[i], \r\n                token0[i], \r\n                token1[i], \r\n                token0[i] == WETH ? address(this).balance : IERC20(token0[i]).balanceOf(address(this))\r\n            );\r\n        }\r\n\r\n        // check profitability\r\n        require(\r\n            amount + fee <= IERC20(token).balanceOf(address(this)),\r\n            'Non Profitable'\r\n        );\r\n\r\n        // repay flash loan\r\n        IERC20(token).transfer(\r\n            xProvider,\r\n            amount + fee\r\n        );\r\n\r\n        // increment amount borrowed\r\n        totalXValueBorrowed += amount;\r\n\r\n        // increment fee generated\r\n        totalXValueGained += IERC20(token).balanceOf(address(this));\r\n\r\n        return CALLBACK_SUCCESS;\r\n    }\r\n\r\n    // BNB -> Token0 on Sushi Swap\r\n    // Token0 -> BNB on Pancake Swap\r\n\r\n    // Token0: [BNB, Token0]\r\n    // Token1: [Token0, BNB]\r\n    // DEXES:  [Sushi, Pancake]\r\n    function trigger(\r\n        address[] calldata token0_,\r\n        address[] calldata token1_,\r\n        address[] calldata DEXes_,\r\n        uint64 projectIndex,\r\n        uint256 borrowAmount,\r\n        uint256 gasCost\r\n    ) external {\r\n\r\n        // Save Input Data To State\r\n        token0 = token0_;\r\n        token1 = token1_;\r\n        DEXes = DEXes_;\r\n\r\n        address tokenToRepay  = token1_[token1_.length - 1];\r\n\r\n        if (token0_[0] == XUSD) {\r\n            IXFlashLender(xProvider).flashLoan(\r\n                IXFlashBorrower(address(this)),\r\n                borrowAmount,\r\n                ''\r\n            );\r\n        } else {            \r\n            // Trigger Flash Loan, Handle Data In onFlashLoan\r\n            IFlashLender(provider).flashLoan(\r\n                IFlashBorrower(address(this)),\r\n                token0_[0],\r\n                tokenToRepay,\r\n                borrowAmount,\r\n                ''\r\n            );\r\n        }\r\n\r\n        // Divvy Up Remainder\r\n        uint remainder = IERC20(tokenToRepay).balanceOf(address(this));\r\n        require(\r\n            remainder >= gasCost,\r\n            'Non Profitable'\r\n        );\r\n\r\n        // Amount For Fee Receiver To Receive\r\n        uint toReceive = shouldForwardProfitsToProject(projectIndex, remainder, gasCost) ?\r\n            gasCost + ( ( ( remainder - gasCost ) * ( 100 - listedProjects[projectIndex].earnPercentage ) ) / 100 )  :\r\n            remainder;\r\n\r\n        // refund gas\r\n        if (toReceive > 0) {\r\n            IERC20(tokenToRepay).transfer(\r\n                feeReceiver,\r\n                toReceive\r\n            );\r\n        }\r\n\r\n        // send listed project the remaining tokens\r\n        uint leftOver = IERC20(tokenToRepay).balanceOf(address(this));\r\n        if (leftOver > 0) {\r\n            listedProjects[projectIndex].amountEarned += leftOver;\r\n            IERC20(tokenToRepay).transfer(\r\n                listedProjects[projectIndex].receiveAddress,\r\n                leftOver\r\n            );\r\n        }\r\n\r\n        // delete saved data\r\n        delete DEXes;\r\n        delete token0;\r\n        delete token1;\r\n    }\r\n\r\n    function shouldForwardProfitsToProject(uint64 index, uint remainder, uint gasCost) public view returns (bool) {\r\n        return \r\n            index < nListed && \r\n            remainder >= gasCost + 10**16 && \r\n            listedProjects[index].receiveAddress != address(0) &&\r\n            listedProjects[index].earnPercentage > 0;\r\n    }\r\n\r\n    function handleSwaps(\r\n        address DEX, \r\n        address _token0, \r\n        address _token1, \r\n        uint256 amount\r\n    ) internal {\r\n\r\n        if (_token0 == XUSD && approvedStables[_token1]) {\r\n            // Sell XUSD Via Contract\r\n            _sellXUSD(_token1, amount);\r\n        } else if (_token1 == XUSD && approvedStables[_token0]) {\r\n            // Buy XUSD Via Contract\r\n            _mintXUSD(_token0, amount);\r\n        } else if (_token1 == WETH) {\r\n            // DEX Sell \r\n            _sellTokenForBNB(DEX, _token0, amount);\r\n        } else if (_token0 == WETH) {\r\n            // DEX Buy\r\n            _buyTokenWithBNB(DEX, _token1, amount);\r\n        } else {\r\n            // DEX Swap\r\n            _swapTokenForToken(DEX, _token0, _token1, amount);\r\n        }\r\n\r\n    }\r\n\r\n    // DEX Router Swaps\r\n\r\n    function _sellXUSD(address forToken, uint256 amount) internal {\r\n        IXUSD(XUSD).sell(amount, forToken);\r\n    }\r\n\r\n    function _mintXUSD(address withToken, uint256 amount) internal {\r\n        IERC20(withToken).approve(XUSD, amount);\r\n        IXUSD(XUSD).mintWithBacking(withToken, amount);\r\n    }\r\n\r\n    function _swapTokenForToken(address DEX, address tokenIn, address tokenOut, uint256 amountTokenIn) internal {\r\n\r\n        IUniswapV2Router02 router = IUniswapV2Router02(DEX);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n\r\n        // make approval\r\n        IERC20(tokenIn).approve(DEX, amountTokenIn);\r\n\r\n        // make the swap\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountTokenIn, 0, path, address(this), block.timestamp + 3000);\r\n    \r\n        // clear saved data\r\n        delete path;\r\n    }\r\n\r\n    function _sellTokenForBNB(address DEX, address token, uint256 amount) internal {\r\n\r\n        IUniswapV2Router02 router = IUniswapV2Router02(DEX);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = router.WETH();\r\n\r\n        // make approval\r\n        IERC20(token).approve(DEX, amount);\r\n\r\n        // make the swap\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp + 3000);\r\n\r\n        // clear saved data\r\n        delete path;\r\n    }\r\n\r\n    function _buyTokenWithBNB(address DEX, address token, uint256 amount) internal {\r\n        IUniswapV2Router02 router = IUniswapV2Router02(DEX);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = token;\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(0, path, address(this), block.timestamp + 3000);\r\n    \r\n        // clear saved data\r\n        delete path;\r\n    }\r\n\r\n    // operator functions\r\n    function withdraw(address token) external onlyOperator {\r\n        IERC20(token).transfer(operator, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function withdraw() external onlyOperator {\r\n        (bool s,) = payable(operator).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function changeOwner(address newOwner) external onlyOperator {\r\n        operator = newOwner;\r\n    }\r\n\r\n    function changeFeeRecipient(address newRecipient) external onlyOperator {\r\n        feeReceiver = newRecipient;\r\n    }\r\n\r\n    function approveStable(address stable, bool isApproved) external onlyOperator {\r\n        approvedStables[stable] = isApproved;\r\n    }\r\n\r\n    function registerProject(string calldata projectName, address receiveWallet, uint256 earnPercentage) external onlyOperator {\r\n        listedProjects[nListed].name = projectName;\r\n        listedProjects[nListed].receiveAddress = receiveWallet;\r\n        listedProjects[nListed].earnPercentage = earnPercentage;\r\n        nListed++;\r\n    }\r\n\r\n    function updateListing(\r\n        uint64 projectIndex,\r\n        string calldata projectName, \r\n        address receiveWallet, \r\n        uint256 earnPercentage\r\n    ) external onlyOperator {\r\n        listedProjects[projectIndex].name = projectName;\r\n        listedProjects[projectIndex].receiveAddress = receiveWallet;\r\n        listedProjects[projectIndex].earnPercentage = earnPercentage;\r\n    }\r\n\r\n    function setProvider(address nFlashProvider) external onlyOperator {\r\n        provider = nFlashProvider;\r\n    }\r\n\r\n    // On BNB Received\r\n    receive() external payable {}\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeReceiver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CALLBACK_SUCCESS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stable\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"approveStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedStables\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"changeFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"listedProjects\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"receiveAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nListed\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenToBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenToRepay\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"projectName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"receiveWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnPercentage\",\"type\":\"uint256\"}],\"name\":\"registerProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nFlashProvider\",\"type\":\"address\"}],\"name\":\"setProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"shouldForwardProfitsToProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValueBorrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValueGained\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalXValueBorrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalXValueGained\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"token0_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"token1_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"DEXes_\",\"type\":\"address[]\"},{\"internalType\":\"uint64\",\"name\":\"projectIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"trigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"projectIndex\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"projectName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"receiveWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnPercentage\",\"type\":\"uint256\"}],\"name\":\"updateListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AAAS", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008074abee62f37b294a5c499c5bde86af2ad7bdef", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a0d9eec8cd5a57aa3cabb125990a7d842a23302aa7395be2928c6dc41d44cbf4"}