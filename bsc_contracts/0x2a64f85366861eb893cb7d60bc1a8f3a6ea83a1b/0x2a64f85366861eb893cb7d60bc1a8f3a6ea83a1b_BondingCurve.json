{"SourceCode": "// SPDX-License-Identifier: Bprotocol Foundation (Bancor) LICENSE\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ninterface IBancorFormula {\r\n    function purchaseTargetAmount(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveWeight,\r\n        uint256 _amount\r\n    ) external view returns (uint256);\r\n\r\n    function saleTargetAmount(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveWeight,\r\n        uint256 _amount\r\n    ) external view returns (uint256);\r\n\r\n    function fundCost(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveRatio,\r\n        uint256 _amount\r\n    ) external view returns (uint256);\r\n\r\n    function fundSupplyAmount(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveRatio,\r\n        uint256 _amount\r\n    ) external view returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract BancorFormula is IBancorFormula {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant ONE = 1;\r\n    uint32 private constant MAX_WEIGHT = 1000000;\r\n    uint8 private constant MIN_PRECISION = 32;\r\n    uint8 private constant MAX_PRECISION = 127;\r\n\r\n    // Auto-generated via 'PrintIntScalingFactors.py'\r\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\r\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\r\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\r\n\r\n    // Auto-generated via 'PrintLn2ScalingFactors.py'\r\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\r\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\r\n\r\n    // Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\r\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\r\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\r\n\r\n    // Auto-generated via 'PrintLambertFactors.py'\r\n    uint256 private constant LAMBERT_CONV_RADIUS = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;\r\n    uint256 private constant LAMBERT_POS2_SAMPLE = 0x0003060c183060c183060c183060c18306;\r\n    uint256 private constant LAMBERT_POS2_MAXVAL = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;\r\n    uint256 private constant LAMBERT_POS3_MAXVAL = 0x6b22d43e72c326539cceeef8bb48f255ff;\r\n\r\n    // Auto-generated via 'PrintWeightFactors.py'\r\n    uint256 private constant MAX_UNF_WEIGHT = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\r\n\r\n    // Auto-generated via 'PrintMaxExpArray.py'\r\n    uint256[128] private maxExpArray;\r\n\r\n    function initMaxExpArray() private {\r\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\r\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\r\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\r\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\r\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\r\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\r\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\r\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\r\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\r\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\r\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\r\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\r\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\r\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\r\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\r\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\r\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\r\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\r\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\r\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\r\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\r\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\r\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\r\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\r\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\r\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\r\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\r\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\r\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\r\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\r\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\r\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\r\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\r\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\r\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\r\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\r\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\r\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\r\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\r\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\r\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\r\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\r\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\r\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\r\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\r\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\r\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\r\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\r\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\r\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\r\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\r\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\r\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\r\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\r\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\r\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\r\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\r\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\r\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\r\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\r\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\r\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\r\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\r\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\r\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\r\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\r\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\r\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\r\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\r\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\r\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\r\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\r\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\r\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\r\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\r\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\r\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\r\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\r\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\r\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\r\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\r\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\r\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\r\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\r\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\r\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\r\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\r\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\r\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\r\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\r\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\r\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\r\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\r\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\r\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\r\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\r\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\r\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\r\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\r\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\r\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\r\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\r\n    }\r\n\r\n    // Auto-generated via 'PrintLambertArray.py'\r\n    uint256[128] private lambertArray;\r\n\r\n    function initLambertArray() private {\r\n        lambertArray[0] = 0x60e393c68d20b1bd09deaabc0373b9c5;\r\n        lambertArray[1] = 0x5f8f46e4854120989ed94719fb4c2011;\r\n        lambertArray[2] = 0x5e479ebb9129fb1b7e72a648f992b606;\r\n        lambertArray[3] = 0x5d0bd23fe42dfedde2e9586be12b85fe;\r\n        lambertArray[4] = 0x5bdb29ddee979308ddfca81aeeb8095a;\r\n        lambertArray[5] = 0x5ab4fd8a260d2c7e2c0d2afcf0009dad;\r\n        lambertArray[6] = 0x5998b31359a55d48724c65cf09001221;\r\n        lambertArray[7] = 0x5885bcad2b322dfc43e8860f9c018cf5;\r\n        lambertArray[8] = 0x577b97aa1fe222bb452fdf111b1f0be2;\r\n        lambertArray[9] = 0x5679cb5e3575632e5baa27e2b949f704;\r\n        lambertArray[10] = 0x557fe8241b3a31c83c732f1cdff4a1c5;\r\n        lambertArray[11] = 0x548d868026504875d6e59bbe95fc2a6b;\r\n        lambertArray[12] = 0x53a2465ce347cf34d05a867c17dd3088;\r\n        lambertArray[13] = 0x52bdce5dcd4faed59c7f5511cf8f8acc;\r\n        lambertArray[14] = 0x51dfcb453c07f8da817606e7885f7c3e;\r\n        lambertArray[15] = 0x5107ef6b0a5a2be8f8ff15590daa3cce;\r\n        lambertArray[16] = 0x5035f241d6eae0cd7bacba119993de7b;\r\n        lambertArray[17] = 0x4f698fe90d5b53d532171e1210164c66;\r\n        lambertArray[18] = 0x4ea288ca297a0e6a09a0eee240e16c85;\r\n        lambertArray[19] = 0x4de0a13fdcf5d4213fc398ba6e3becde;\r\n        lambertArray[20] = 0x4d23a145eef91fec06b06140804c4808;\r\n        lambertArray[21] = 0x4c6b5430d4c1ee5526473db4ae0f11de;\r\n        lambertArray[22] = 0x4bb7886c240562eba11f4963a53b4240;\r\n        lambertArray[23] = 0x4b080f3f1cb491d2d521e0ea4583521e;\r\n        lambertArray[24] = 0x4a5cbc96a05589cb4d86be1db3168364;\r\n        lambertArray[25] = 0x49b566d40243517658d78c33162d6ece;\r\n        lambertArray[26] = 0x4911e6a02e5507a30f947383fd9a3276;\r\n        lambertArray[27] = 0x487216c2b31be4adc41db8a8d5cc0c88;\r\n        lambertArray[28] = 0x47d5d3fc4a7a1b188cd3d788b5c5e9fc;\r\n        lambertArray[29] = 0x473cfce4871a2c40bc4f9e1c32b955d0;\r\n        lambertArray[30] = 0x46a771ca578ab878485810e285e31c67;\r\n        lambertArray[31] = 0x4615149718aed4c258c373dc676aa72d;\r\n        lambertArray[32] = 0x4585c8b3f8fe489c6e1833ca47871384;\r\n        lambertArray[33] = 0x44f972f174e41e5efb7e9d63c29ce735;\r\n        lambertArray[34] = 0x446ff970ba86d8b00beb05ecebf3c4dc;\r\n        lambertArray[35] = 0x43e9438ec88971812d6f198b5ccaad96;\r\n        lambertArray[36] = 0x436539d11ff7bea657aeddb394e809ef;\r\n        lambertArray[37] = 0x42e3c5d3e5a913401d86f66db5d81c2c;\r\n        lambertArray[38] = 0x4264d2395303070ea726cbe98df62174;\r\n        lambertArray[39] = 0x41e84a9a593bb7194c3a6349ecae4eea;\r\n        lambertArray[40] = 0x416e1b785d13eba07a08f3f18876a5ab;\r\n        lambertArray[41] = 0x40f6322ff389d423ba9dd7e7e7b7e809;\r\n        lambertArray[42] = 0x40807cec8a466880ecf4184545d240a4;\r\n        lambertArray[43] = 0x400cea9ce88a8d3ae668e8ea0d9bf07f;\r\n        lambertArray[44] = 0x3f9b6ae8772d4c55091e0ed7dfea0ac1;\r\n        lambertArray[45] = 0x3f2bee253fd84594f54bcaafac383a13;\r\n        lambertArray[46] = 0x3ebe654e95208bb9210c575c081c5958;\r\n        lambertArray[47] = 0x3e52c1fc5665635b78ce1f05ad53c086;\r\n        lambertArray[48] = 0x3de8f65ac388101ddf718a6f5c1eff65;\r\n        lambertArray[49] = 0x3d80f522d59bd0b328ca012df4cd2d49;\r\n        lambertArray[50] = 0x3d1ab193129ea72b23648a161163a85a;\r\n        lambertArray[51] = 0x3cb61f68d32576c135b95cfb53f76d75;\r\n        lambertArray[52] = 0x3c5332d9f1aae851a3619e77e4cc8473;\r\n        lambertArray[53] = 0x3bf1e08edbe2aa109e1525f65759ef73;\r\n        lambertArray[54] = 0x3b921d9cff13fa2c197746a3dfc4918f;\r\n        lambertArray[55] = 0x3b33df818910bfc1a5aefb8f63ae2ac4;\r\n        lambertArray[56] = 0x3ad71c1c77e34fa32a9f184967eccbf6;\r\n        lambertArray[57] = 0x3a7bc9abf2c5bb53e2f7384a8a16521a;\r\n        lambertArray[58] = 0x3a21dec7e76369783a68a0c6385a1c57;\r\n        lambertArray[59] = 0x39c9525de6c9cdf7c1c157ca4a7a6ee3;\r\n        lambertArray[60] = 0x39721bad3dc85d1240ff0190e0adaac3;\r\n        lambertArray[61] = 0x391c324344d3248f0469eb28dd3d77e0;\r\n        lambertArray[62] = 0x38c78df7e3c796279fb4ff84394ab3da;\r\n        lambertArray[63] = 0x387426ea4638ae9aae08049d3554c20a;\r\n        lambertArray[64] = 0x3821f57dbd2763256c1a99bbd2051378;\r\n        lambertArray[65] = 0x37d0f256cb46a8c92ff62fbbef289698;\r\n        lambertArray[66] = 0x37811658591ffc7abdd1feaf3cef9b73;\r\n        lambertArray[67] = 0x37325aa10e9e82f7df0f380f7997154b;\r\n        lambertArray[68] = 0x36e4b888cfb408d873b9a80d439311c6;\r\n        lambertArray[69] = 0x3698299e59f4bb9de645fc9b08c64cca;\r\n        lambertArray[70] = 0x364ca7a5012cb603023b57dd3ebfd50d;\r\n        lambertArray[71] = 0x36022c928915b778ab1b06aaee7e61d4;\r\n        lambertArray[72] = 0x35b8b28d1a73dc27500ffe35559cc028;\r\n        lambertArray[73] = 0x357033e951fe250ec5eb4e60955132d7;\r\n        lambertArray[74] = 0x3528ab2867934e3a21b5412e4c4f8881;\r\n        lambertArray[75] = 0x34e212f66c55057f9676c80094a61d59;\r\n        lambertArray[76] = 0x349c66289e5b3c4b540c24f42fa4b9bb;\r\n        lambertArray[77] = 0x34579fbbd0c733a9c8d6af6b0f7d00f7;\r\n        lambertArray[78] = 0x3413bad2e712288b924b5882b5b369bf;\r\n        lambertArray[79] = 0x33d0b2b56286510ef730e213f71f12e9;\r\n        lambertArray[80] = 0x338e82ce00e2496262c64457535ba1a1;\r\n        lambertArray[81] = 0x334d26a96b373bb7c2f8ea1827f27a92;\r\n        lambertArray[82] = 0x330c99f4f4211469e00b3e18c31475ea;\r\n        lambertArray[83] = 0x32ccd87d6486094999c7d5e6f33237d8;\r\n        lambertArray[84] = 0x328dde2dd617b6665a2e8556f250c1af;\r\n        lambertArray[85] = 0x324fa70e9adc270f8262755af5a99af9;\r\n        lambertArray[86] = 0x32122f443110611ca51040f41fa6e1e3;\r\n        lambertArray[87] = 0x31d5730e42c0831482f0f1485c4263d8;\r\n        lambertArray[88] = 0x31996ec6b07b4a83421b5ebc4ab4e1f1;\r\n        lambertArray[89] = 0x315e1ee0a68ff46bb43ec2b85032e876;\r\n        lambertArray[90] = 0x31237fe7bc4deacf6775b9efa1a145f8;\r\n        lambertArray[91] = 0x30e98e7f1cc5a356e44627a6972ea2ff;\r\n        lambertArray[92] = 0x30b04760b8917ec74205a3002650ec05;\r\n        lambertArray[93] = 0x3077a75c803468e9132ce0cf3224241d;\r\n        lambertArray[94] = 0x303fab57a6a275c36f19cda9bace667a;\r\n        lambertArray[95] = 0x3008504beb8dcbd2cf3bc1f6d5a064f0;\r\n        lambertArray[96] = 0x2fd19346ed17dac61219ce0c2c5ac4b0;\r\n        lambertArray[97] = 0x2f9b7169808c324b5852fd3d54ba9714;\r\n        lambertArray[98] = 0x2f65e7e711cf4b064eea9c08cbdad574;\r\n        lambertArray[99] = 0x2f30f405093042ddff8a251b6bf6d103;\r\n        lambertArray[100] = 0x2efc931a3750f2e8bfe323edfe037574;\r\n        lambertArray[101] = 0x2ec8c28e46dbe56d98685278339400cb;\r\n        lambertArray[102] = 0x2e957fd933c3926d8a599b602379b851;\r\n        lambertArray[103] = 0x2e62c882c7c9ed4473412702f08ba0e5;\r\n        lambertArray[104] = 0x2e309a221c12ba361e3ed695167feee2;\r\n        lambertArray[105] = 0x2dfef25d1f865ae18dd07cfea4bcea10;\r\n        lambertArray[106] = 0x2dcdcee821cdc80decc02c44344aeb31;\r\n        lambertArray[107] = 0x2d9d2d8562b34944d0b201bb87260c83;\r\n        lambertArray[108] = 0x2d6d0c04a5b62a2c42636308669b729a;\r\n        lambertArray[109] = 0x2d3d6842c9a235517fc5a0332691528f;\r\n        lambertArray[110] = 0x2d0e402963fe1ea2834abc408c437c10;\r\n        lambertArray[111] = 0x2cdf91ae602647908aff975e4d6a2a8c;\r\n        lambertArray[112] = 0x2cb15ad3a1eb65f6d74a75da09a1b6c5;\r\n        lambertArray[113] = 0x2c8399a6ab8e9774d6fcff373d210727;\r\n        lambertArray[114] = 0x2c564c4046f64edba6883ca06bbc4535;\r\n        lambertArray[115] = 0x2c2970c431f952641e05cb493e23eed3;\r\n        lambertArray[116] = 0x2bfd0560cd9eb14563bc7c0732856c18;\r\n        lambertArray[117] = 0x2bd1084ed0332f7ff4150f9d0ef41a2c;\r\n        lambertArray[118] = 0x2ba577d0fa1628b76d040b12a82492fb;\r\n        lambertArray[119] = 0x2b7a5233cd21581e855e89dc2f1e8a92;\r\n        lambertArray[120] = 0x2b4f95cd46904d05d72bdcde337d9cc7;\r\n        lambertArray[121] = 0x2b2540fc9b4d9abba3faca6691914675;\r\n        lambertArray[122] = 0x2afb5229f68d0830d8be8adb0a0db70f;\r\n        lambertArray[123] = 0x2ad1c7c63a9b294c5bc73a3ba3ab7a2b;\r\n        lambertArray[124] = 0x2aa8a04ac3cbe1ee1c9c86361465dbb8;\r\n        lambertArray[125] = 0x2a7fda392d725a44a2c8aeb9ab35430d;\r\n        lambertArray[126] = 0x2a57741b18cde618717792b4faa216db;\r\n        lambertArray[127] = 0x2a2f6c81f5d84dd950a35626d6d5503a;\r\n    }\r\n\r\n    /**\r\n     * @dev should be executed after construction (too large for the constructor)\r\n     */\r\n    function init() public {\r\n        initMaxExpArray();\r\n        initLambertArray();\r\n    }\r\n\r\n    /**\r\n     * @dev given a token supply, reserve balance, weight and a deposit amount (in the reserve token),\r\n     * calculates the target amount for a given conversion (in the main token)\r\n     *\r\n     * Formula:\r\n     * return = _supply * ((1 + _amount / _reserveBalance) ^ (_reserveWeight / 1000000) - 1)\r\n     *\r\n     * @param _supply          liquid token supply\r\n     * @param _reserveBalance  reserve balance\r\n     * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\r\n     * @param _amount          amount of reserve tokens to get the target amount for\r\n     *\r\n     * @return target\r\n     */\r\n    function purchaseTargetAmount(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveWeight,\r\n        uint256 _amount\r\n    ) public view override returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0, \"ERR_INVALID_SUPPLY\");\r\n        require(_reserveBalance > 0, \"ERR_INVALID_RESERVE_BALANCE\");\r\n        require(_reserveWeight > 0 && _reserveWeight <= MAX_WEIGHT, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n\r\n        // special case for 0 deposit amount\r\n        if (_amount == 0) return 0;\r\n\r\n        // special case if the weight = 100%\r\n        if (_reserveWeight == MAX_WEIGHT) return _supply.mul(_amount) / _reserveBalance;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = _amount.add(_reserveBalance);\r\n        (result, precision) = power(baseN, _reserveBalance, _reserveWeight, MAX_WEIGHT);\r\n        uint256 temp = _supply.mul(result) >> precision;\r\n        return temp - _supply;\r\n    }\r\n\r\n    /**\r\n     * @dev given a token supply, reserve balance, weight and a sell amount (in the main token),\r\n     * calculates the target amount for a given conversion (in the reserve token)\r\n     *\r\n     * Formula:\r\n     * return = _reserveBalance * (1 - (1 - _amount / _supply) ^ (1000000 / _reserveWeight))\r\n     *\r\n     * @param _supply          liquid token supply\r\n     * @param _reserveBalance  reserve balance\r\n     * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\r\n     * @param _amount          amount of liquid tokens to get the target amount for\r\n     *\r\n     * @return reserve token amount\r\n     */\r\n    function saleTargetAmount(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveWeight,\r\n        uint256 _amount\r\n    ) public view override returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0, \"ERR_INVALID_SUPPLY\");\r\n        require(_reserveBalance > 0, \"ERR_INVALID_RESERVE_BALANCE\");\r\n        require(_reserveWeight > 0 && _reserveWeight <= MAX_WEIGHT, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n        require(_amount <= _supply, \"ERR_INVALID_AMOUNT\");\r\n\r\n        // special case for 0 sell amount\r\n        if (_amount == 0) return 0;\r\n\r\n        // special case for selling the entire supply\r\n        if (_amount == _supply) return _reserveBalance;\r\n\r\n        // special case if the weight = 100%\r\n        if (_reserveWeight == MAX_WEIGHT) return _reserveBalance.mul(_amount) / _supply;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseD = _supply - _amount;\r\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _reserveWeight);\r\n        uint256 temp1 = _reserveBalance.mul(result);\r\n        uint256 temp2 = _reserveBalance << precision;\r\n        return (temp1 - temp2) / result;\r\n    }\r\n\r\n/**\r\n     * @dev given a pool token supply, reserve balance, reserve ratio and an amount of requested pool tokens,\r\n     * calculates the amount of reserve tokens required for purchasing the given amount of pool tokens\r\n     *\r\n     * Formula:\r\n     * return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio) - 1)\r\n     *\r\n     * @param _supply          pool token supply\r\n     * @param _reserveBalance  reserve balance\r\n     * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\r\n     * @param _amount          requested amount of pool tokens\r\n     *\r\n     * @return reserve token amount\r\n     */\r\n    function fundCost(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveRatio,\r\n        uint256 _amount\r\n    ) public view override returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0, \"ERR_INVALID_SUPPLY\");\r\n        require(_reserveBalance > 0, \"ERR_INVALID_RESERVE_BALANCE\");\r\n        require(_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2, \"ERR_INVALID_RESERVE_RATIO\");\r\n\r\n        // special case for 0 amount\r\n        if (_amount == 0) return 0;\r\n\r\n        // special case if the reserve ratio = 100%\r\n        if (_reserveRatio == MAX_WEIGHT) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = _supply.add(_amount);\r\n        (result, precision) = power(baseN, _supply, MAX_WEIGHT, _reserveRatio);\r\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\r\n        return temp - _reserveBalance;\r\n    }\r\n\r\n     /**\r\n     * @dev given a pool token supply, reserve balance, reserve ratio and an amount of reserve tokens to fund with,\r\n     * calculates the amount of pool tokens received for purchasing with the given amount of reserve tokens\r\n     *\r\n     * Formula:\r\n     * return = _supply * ((_amount / _reserveBalance + 1) ^ (_reserveRatio / MAX_WEIGHT) - 1)\r\n     *\r\n     * @param _supply          pool token supply\r\n     * @param _reserveBalance  reserve balance\r\n     * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\r\n     * @param _amount          amount of reserve tokens to fund with\r\n     *\r\n     * @return pool token amount\r\n     */\r\n    function fundSupplyAmount(\r\n        uint256 _supply,\r\n        uint256 _reserveBalance,\r\n        uint32 _reserveRatio,\r\n        uint256 _amount\r\n    ) public view override returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0, \"ERR_INVALID_SUPPLY\");\r\n        require(_reserveBalance > 0, \"ERR_INVALID_RESERVE_BALANCE\");\r\n        require(_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2, \"ERR_INVALID_RESERVE_RATIO\");\r\n\r\n        // special case for 0 amount\r\n        if (_amount == 0) return 0;\r\n\r\n        // special case if the reserve ratio = 100%\r\n        if (_reserveRatio == MAX_WEIGHT) return _amount.mul(_supply) / _reserveBalance;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = _reserveBalance.add(_amount);\r\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_WEIGHT);\r\n        uint256 temp = _supply.mul(result) >> precision;\r\n        return temp - _supply;\r\n    }\r\n\r\n    /**\r\n     * @dev General Description:\r\n     *     Determine a value of precision.\r\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\r\n     *     Return the result along with the precision used.\r\n     *\r\n     * Detailed Description:\r\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\r\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\r\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\r\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\r\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\r\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\r\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\r\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\r\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\r\n     */\r\n    function power(\r\n        uint256 _baseN,\r\n        uint256 _baseD,\r\n        uint32 _expN,\r\n        uint32 _expD\r\n    ) internal view returns (uint256, uint8) {\r\n        require(_baseN < MAX_NUM);\r\n\r\n        uint256 baseLog;\r\n        uint256 base = (_baseN * FIXED_1) / _baseD;\r\n        if (base < OPT_LOG_MAX_VAL) {\r\n            baseLog = optimalLog(base);\r\n        } else {\r\n            baseLog = generalLog(base);\r\n        }\r\n\r\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\r\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\r\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\r\n        } else {\r\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\r\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev computes log(x / FIXED_1) * FIXED_1.\r\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\r\n     */\r\n    function generalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\r\n        if (x >= FIXED_2) {\r\n            uint8 count = floorLog2(x / FIXED_1);\r\n            x >>= count; // now x < 2\r\n            res = count * FIXED_1;\r\n        }\r\n\r\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\r\n        if (x > FIXED_1) {\r\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\r\n                x = (x * x) / FIXED_1; // now 1 < x < 4\r\n                if (x >= FIXED_2) {\r\n                    x >>= 1; // now 1 < x < 2\r\n                    res += ONE << (i - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\r\n    }\r\n\r\n    /**\r\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\r\n     */\r\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\r\n        uint8 res = 0;\r\n\r\n        if (_n < 256) {\r\n            // At most 8 iterations\r\n            while (_n > 1) {\r\n                _n >>= 1;\r\n                res += 1;\r\n            }\r\n        } else {\r\n            // Exactly 8 iterations\r\n            for (uint8 s = 128; s > 0; s >>= 1) {\r\n                if (_n >= (ONE << s)) {\r\n                    _n >>= s;\r\n                    res |= s;\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\r\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\r\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\r\n     */\r\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\r\n        uint8 lo = MIN_PRECISION;\r\n        uint8 hi = MAX_PRECISION;\r\n\r\n        while (lo + 1 < hi) {\r\n            uint8 mid = (lo + hi) / 2;\r\n            if (maxExpArray[mid] >= _x) lo = mid;\r\n            else hi = mid;\r\n        }\r\n\r\n        if (maxExpArray[hi] >= _x) return hi;\r\n        if (maxExpArray[lo] >= _x) return lo;\r\n\r\n        require(false);\r\n    }\r\n\r\n    /**\r\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\r\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\r\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\r\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\r\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n     */\r\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\r\n        uint256 xi = _x;\r\n        uint256 res = 0;\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\r\n\r\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\r\n    }\r\n\r\n    /**\r\n     * @dev computes log(x / FIXED_1) * FIXED_1\r\n     * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\r\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\r\n     * Detailed description:\r\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\r\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\r\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\r\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\r\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\r\n     */\r\n    function optimalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n        uint256 w;\r\n\r\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\r\n            res += 0x40000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\r\n        } // add 1 / 2^1\r\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\r\n            res += 0x20000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\r\n        } // add 1 / 2^2\r\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\r\n            res += 0x10000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\r\n        } // add 1 / 2^3\r\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\r\n            res += 0x08000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\r\n        } // add 1 / 2^4\r\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\r\n            res += 0x04000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\r\n        } // add 1 / 2^5\r\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\r\n            res += 0x02000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\r\n        } // add 1 / 2^6\r\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\r\n            res += 0x01000000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\r\n        } // add 1 / 2^7\r\n        if (x >= 0x808040155aabbbe9451521693554f733) {\r\n            res += 0x00800000000000000000000000000000;\r\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\r\n        } // add 1 / 2^8\r\n\r\n        z = y = x - FIXED_1;\r\n        w = (y * y) / FIXED_1;\r\n        res += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\r\n        res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\r\n        res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\r\n        res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\r\n        res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\r\n        res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\r\n        res += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\r\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\r\n        res += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\r\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\r\n     * auto-generated via 'PrintFunctionOptimalExp.py'\r\n     * Detailed description:\r\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\r\n     * - The exponentiation of each binary exponent is given (pre-calculated)\r\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\r\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\r\n     */\r\n    function optimalExp(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n\r\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\r\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\r\n\r\n        if ((x & 0x010000000000000000000000000000000) != 0)\r\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\r\n        if ((x & 0x020000000000000000000000000000000) != 0)\r\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\r\n        if ((x & 0x040000000000000000000000000000000) != 0)\r\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\r\n        if ((x & 0x080000000000000000000000000000000) != 0)\r\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\r\n        if ((x & 0x100000000000000000000000000000000) != 0)\r\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\r\n        if ((x & 0x200000000000000000000000000000000) != 0)\r\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\r\n        if ((x & 0x400000000000000000000000000000000) != 0)\r\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\r\n\r\n        return res;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title Admin parameters\r\n* @dev Define administration parameters for this contract\r\n*/\r\ncontract Admined { //This token contract is administered\r\n    address public owner; //Master address is public\r\n    mapping(address => uint256) public level; //Admin level\r\n\r\n    /**\r\n    * @dev Contract constructor\r\n    * define initial administrator\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender; //Set initial owner to contract creator\r\n        level[msg.sender] = 2;\r\n        emit Owned(owner);\r\n    }\r\n\r\n    modifier onlyAdmin(uint8 _level) { //A modifier to define admin-only functions\r\n        require(msg.sender == owner || level[msg.sender] >= _level);\r\n        _;\r\n    }\r\n\r\n   /**\r\n    * @dev Function to set new owner address\r\n    * @param _newOwner The address to transfer administration to\r\n    */\r\n    function transferOwnership(address _newOwner) onlyAdmin(2) public { //owner can be transfered\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n        level[_newOwner] = 2;\r\n        emit TransferOwnership(owner);\r\n    }\r\n\r\n    function setAdminLevel(address _target, uint8 _level) onlyAdmin(2) public {\r\n        level[_target] = _level;\r\n        emit AdminLevelSet(_target,_level);\r\n    }\r\n\r\n    //All admin actions have a log for public review\r\n    event TransferOwnership(address newAdminister);\r\n    event Owned(address administer);\r\n    event AdminLevelSet(address _target,uint8 _level);\r\n\r\n}\r\n\r\n/**\r\n * @title Bonding Curve\r\n * @dev Bonding curve contract based on Bacor formula\r\n * inspired by bancor protocol and simondlr\r\n * https://github.com/bancorprotocol/contracts\r\n * https://github.com/ConsenSys/curationmarkets/blob/master/CurationMarkets.sol\r\n */\r\ncontract BondingCurve is BancorFormula, Admined {\r\n    \r\n  address public ethChainTokenAddress;\r\n  uint256 INITIAL_BASE = 1000000000 * 10 ** 18;\r\n  uint256 INITIAL_PRICE = 10000000; // 0.10$\r\n  uint256 MAX_SUPPLY = INITIAL_BASE + 2000000000 * (10 ** 18); //2.0B IAX\r\n  \r\n  /*\r\n    reserve ratio, represented in ppm, 1-1000000\r\n    1/3 corresponds to y= multiple * x^2\r\n    1/2 corresponds to y= multiple * x\r\n    2/3 corresponds to y= multiple * x^1/2\r\n    multiple will depends on contract initialization,\r\n    specificallytotalAmount and poolBalance parameters\r\n    we might want to add an 'initialize' function that will allow\r\n    the owner to send ether to the contract and mint a given amount of tokens\r\n  */\r\n  \r\n  uint32 reserveRatio = 250000;\r\n\r\n  \r\n  uint256 public baseFactor = INITIAL_BASE;\r\n  uint256 public poolBalance = reserveRatio * baseFactor * INITIAL_PRICE / (1000000 * 10 ** 18);\r\n\r\n  constructor(address tokenAddress) public {\r\n      ethChainTokenAddress = tokenAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev default function\r\n   */\r\n  fallback() external {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * @dev Buy tokens\r\n   * @param buyAmount usd purchase amount\r\n   */\r\n  function buy(uint256 buyAmount, address beneficiary_) public onlyAdmin(1) returns(bool,uint256) {\r\n    require(buyAmount > 0);\r\n    uint256 tokensToSell = purchaseTargetAmount(baseFactor, poolBalance, reserveRatio, buyAmount);\r\n\r\n    baseFactor = baseFactor.add(tokensToSell);\r\n\r\n    require(baseFactor <= MAX_SUPPLY);\r\n\r\n    poolBalance = poolBalance.add(buyAmount);\r\n\r\n    emit LogPurchase( tokensToSell, buyAmount, beneficiary_);\r\n    return (true,tokensToSell);\r\n  }\r\n\r\n  /**\r\n   * @dev Sell tokens\r\n   * @param sellAmount sold token amount\r\n   */\r\n  function sell(uint256 sellAmount, address beneficiary_) public onlyAdmin(1) returns(bool,uint256) {\r\n    require(sellAmount > 0);\r\n\r\n    uint256 amountValue = saleTargetAmount(baseFactor, poolBalance, reserveRatio, sellAmount);\r\n\r\n    poolBalance = poolBalance.sub(amountValue);\r\n    baseFactor = baseFactor.sub(sellAmount);\r\n\r\n    require(baseFactor >= INITIAL_BASE);\r\n\r\n    emit LogWithdraw(sellAmount, amountValue, beneficiary_);\r\n    return (true,amountValue);\r\n  }\r\n  \r\n  /**\r\n   * @dev Buy tokens calculation\r\n   * @param buyAmount usd purchase amount\r\n   */\r\n  function buyReturn(uint256 buyAmount) public view returns(uint256) {\r\n    require(buyAmount > 0);\r\n    uint256 tokensToSell = purchaseTargetAmount(baseFactor, poolBalance, reserveRatio, buyAmount);\r\n\r\n    require(baseFactor.add(tokensToSell) <= MAX_SUPPLY);\r\n\r\n    return (tokensToSell);\r\n  }\r\n  \r\n  /**\r\n   * @dev Sell tokens calculation\r\n   * @param sellAmount sold token amount\r\n   */\r\n    function sellReturn(uint256 sellAmount) public view returns(uint256) {\r\n    require(sellAmount > 0);\r\n\r\n    uint256 amountValue = saleTargetAmount(baseFactor, poolBalance, reserveRatio, sellAmount);\r\n\r\n    require(baseFactor.sub(sellAmount) >= INITIAL_BASE);\r\n\r\n    return (amountValue);\r\n  }\r\n  \r\n  /**\r\n   * @dev How much to deposit to get an amount of tokens calculation\r\n   * @param tokensRequested amount\r\n   */\r\n    function buyRequired(uint256 tokensRequested) public view returns(uint256) {\r\n    require(tokensRequested > 0);\r\n\r\n    uint256 amountValue = fundCost(baseFactor, poolBalance, reserveRatio, tokensRequested);\r\n\r\n    require(baseFactor.add(tokensRequested) <= MAX_SUPPLY);\r\n\r\n    return (amountValue);\r\n  }\r\n  \r\n  /**\r\n   * @dev How much to sell to get an amount of usd calculation\r\n   * @param usdRequested amount\r\n   */\r\n    function sellRequired(uint256 usdRequested) public view returns(uint256) {\r\n    require(usdRequested > 0);\r\n\r\n    uint256 amountValue = fundSupplyAmount(baseFactor, poolBalance, reserveRatio, usdRequested);\r\n\r\n    require(baseFactor.sub(amountValue) >= INITIAL_BASE);\r\n\r\n    return (amountValue);\r\n  }\r\n  \r\n  \r\n  function adminFixCurve(uint32 _newCurve) onlyAdmin(2) public {\r\n    reserveRatio = _newCurve;\r\n    emit LogBondingCurve('Fixed curve value',reserveRatio);\r\n\r\n  }\r\n\r\n  function adminFixMaxSupply(uint256 _newMax) onlyAdmin(2) public {\r\n    MAX_SUPPLY = _newMax;\r\n    emit LogBondingCurve('Fixed MAX_SUPPLY value',MAX_SUPPLY);\r\n\r\n  }\r\n\r\n  function adminFixTokenAddress(address _newAddress) onlyAdmin(2) public {\r\n    ethChainTokenAddress = _newAddress;\r\n    emit LogTokenAddress('Fixed Token address', ethChainTokenAddress);\r\n  }\r\n\r\n  event LogPurchase(uint256 amountSold, uint256 totalCost, address beneficiary);\r\n  event LogWithdraw(uint256 amountWithdrawn, uint256 reward, address beneficiary);\r\n  event LogBondingCurve(string logString, uint256 value);\r\n  event LogTokenAddress(string logString, address value);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"AdminLevelSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"logString\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogBondingCurve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"LogPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"logString\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"LogTokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"administer\",\"type\":\"address\"}],\"name\":\"Owned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdminister\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newCurve\",\"type\":\"uint32\"}],\"name\":\"adminFixCurve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMax\",\"type\":\"uint256\"}],\"name\":\"adminFixMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"adminFixTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensRequested\",\"type\":\"uint256\"}],\"name\":\"buyRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"name\":\"buyReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethChainTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundSupplyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"purchaseTargetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"saleTargetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdRequested\",\"type\":\"uint256\"}],\"name\":\"sellRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"}],\"name\":\"sellReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"setAdminLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BondingCurve", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e429575042170ac4c1ddfa9927356a40661cf00b", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58ad4e2e6fd206df5ebcc7f7ff61bbb5a7628f687039e1461da2f048ec5c1d58"}